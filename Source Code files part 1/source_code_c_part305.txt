        printf(" ---------   ------\n");
            printf(" Add         -a <key> <cur> <birthid>\n");
            printf(" Delete      -d <key>\n");
            printf(" Modify      -m <key> <cur> <birthid>\n");
            printf(" Query       -q <key>\n");
            printf(" Touch       -t <key>\n");
            printf(" Fill        -f <number of entries> // aaa,aab,aac ...\n");
            printf(" Purge       -p 'purge all server database state'\n");
            printf(" Cache Purge -c\n");
            printf(" Run tests   -r\n");
            printf(" Interactive -i\n");
        }
        hr = S_OK;
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception number %08X caught\n", GetExceptionCode());
        hr = GetExceptionCode();
    }

    test.UnInitialize(hr);

Exit:

    return(0);
}

#else
EXTERN_C int __cdecl _tmain(int cArgs, TCHAR **tszArgs )
{
    printf("Retail build of tldap.exe doesn't run\n");
    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\toidsnap.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"

DWORD g_Debug = 0;


inline void
WriteToSnapshot( HANDLE hFileSnapshot, const TCHAR *ptsz )
{
    ULONG cb, cbWritten;

    if( NULL != ptsz )
        cb = _tcslen( ptsz ) * sizeof(TCHAR);
    else
    {
        cb = sizeof(TCHAR);
        ptsz = TEXT("");
    }

    if( !WriteFile( hFileSnapshot, ptsz, cb, &cbWritten, NULL ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed WriteFile (%lu)"), GetLastError() ));
        TrkRaiseLastError();
    }

    if( cb != cbWritten )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Not all of the data was written (%d/%d)"),
                 cbWritten, cb ));
        TrkRaiseWin32Error( ERROR_WRITE_FAULT );
    }
}

void
Usage()
{
    printf( "\n" );
    printf( " Purpose: Take a snapshot of the volume ID and all object IDs for a volume\n" );
    printf( " Usage:   toidsnap [-g|-s] <drive letter>: <snapshot file>\n" );
    printf( " Where:   -g indicates get (create a snapshot)\n" );
    printf( "          -s indicates set (from the snapshot file)\n" );
    printf( " E.g.:    toidsnap -g d: snapshot.txt\n" );
    printf( "          toidsnap -s d: snapshot.txt\n" );
    return;
}

EXTERN_C void __cdecl _tmain( int cArg, TCHAR *rgtszArg[] )
{
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    TCHAR* ptcTmp = NULL;
    LONG iVol;
    BOOL fSuccess = TRUE;
    BOOL fSaving = FALSE;
    HANDLE hFileSnapshot = INVALID_HANDLE_VALUE;
    HANDLE hMapping = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK Iosb;
    TCHAR tszFileData[ 3 * MAX_PATH ];
    ULONG cLine = 0;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "TOidSnap" );


    //  -------------------------
    //  Validate the command-line
    //  -------------------------

    if( 4 != cArg )
    {
        Usage();
        goto Exit;
    }

    _tcslwr( rgtszArg[1] );
    _tcslwr( rgtszArg[2] );

    if( TEXT('-') != rgtszArg[1][0] && TEXT('/') != rgtszArg[1][0]
        ||
        TEXT('g') != rgtszArg[1][1] && TEXT('s') != rgtszArg[1][1]
        ||
        TEXT(':') != rgtszArg[2][1]
        ||
        TEXT('a') > rgtszArg[2][0] || TEXT('z') < rgtszArg[2][0]
      )
    {
        Usage();
        goto Exit;
    }

    fSaving = TEXT('g') == rgtszArg[1][1];

    iVol = rgtszArg[2][0] - TEXT('a');
    if( !IsLocalObjectVolume( iVol ))
    {
        _tprintf( TEXT("%c: isn't an NTFS5 volume\n"), VolChar(iVol) );
        goto Exit;
    }


    __try
    {
        FILE_FS_OBJECTID_INFORMATION fsobOID;

        EnableRestorePrivilege();

        // Open the snapshot file

        hFileSnapshot = CreateFile( rgtszArg[3],
                            fSaving ? GENERIC_WRITE : GENERIC_READ,
                            0, NULL,
                            fSaving ? CREATE_ALWAYS : OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFileSnapshot )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open file: %s (%lu)"),
                     rgtszArg[3], GetLastError() ));
            TrkRaiseLastError();
        }

        //  ----
        //  Save
        //  ----

        if( fSaving )
        {
            // Get the volid

            CVolumeId volid;
            status = QueryVolumeId( iVol, &volid );
            if( STATUS_OBJECT_NAME_NOT_FOUND != status && !NT_SUCCESS(status) )
                TrkRaiseNtStatus( status );

            // Write the volid to the snapshot file.

            WriteToSnapshot( hFileSnapshot, TEXT("VolId, ") );

            CStringize strVolid(volid);
            WriteToSnapshot( hFileSnapshot, static_cast<const TCHAR*>(strVolid) );
            WriteToSnapshot( hFileSnapshot, TEXT("\n") );
            WriteToSnapshot( hFileSnapshot, NULL );
            cLine++;

            CObjId                  objid;
            CDomainRelativeObjId    droidBirth;
            CObjIdEnumerator        oie;

            // Loop through the files with object IDs

            if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
            {
                if(oie.FindFirst(&objid, &droidBirth))
                {
                    do
                    {
                        // Open the file so that we can get its path

                        HANDLE hFile;
                        status = OpenFileById(  iVol, objid, SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                                0, &hFile);
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed OpenFileById for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Get the local path 

                        status = QueryVolRelativePath( hFile, tszFileData );
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed QueryVolRelativePath for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Write the path, objid, and birth ID to the snapshot file.

                        _tcscat( tszFileData, TEXT(" = ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(objid)) );
                        _tcscat( tszFileData, TEXT(", ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(droidBirth)) );
                        _tcscat( tszFileData, TEXT("\n") );


                        // Write a line terminator to the snapshot file.

                        WriteToSnapshot( hFileSnapshot, tszFileData );
                        WriteToSnapshot( hFileSnapshot, NULL );

                        cLine++;

                    } while(oie.FindNext(&objid, &droidBirth));

                    // Write an marker to show end-of-file

                    WriteToSnapshot( hFileSnapshot, TEXT("\n") );
                    WriteToSnapshot( hFileSnapshot, NULL );
                }
            }

            printf( "%d IDs saved\n", cLine );
        
        }   // if fSaving

        //  ---------
        //  Restoring
        //  ---------

        else
        {
            ULONG cCollisions = 0, cSuccess = 0;
            TCHAR *ptsz = NULL;

            // Map the snapshot file into memory.

            hMapping = CreateFileMapping( hFileSnapshot, NULL, PAGE_READONLY, 0, 0, NULL );
            if( NULL == hMapping )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed CreateFileMapping") ));
                TrkRaiseLastError();
            }

            ptsz = reinterpret_cast<TCHAR*>( MapViewOfFile( hMapping, FILE_MAP_READ, 0, 0, 0 ));
            if( NULL == ptsz )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't map view of file") ));
                TrkRaiseLastError();
            }

            // The file should start with the volid

            if( NULL == _tcsstr( ptsz, TEXT("VolId, ") ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't find volid") ));
                TrkRaiseException( E_FAIL );
            }

            // Move ptsz to the start of the stringized volid
            ptsz += _tcslen(TEXT("VolId, "));

            // Unstringize the volid and set it on the volume.

            CVolumeId volid;
            CStringize stringize;
            stringize.Use( ptsz );
            volid = stringize;

            status = SetVolId( iVol, volid );
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set volid") ));
                TrkRaiseNtStatus(status);
            }
            cSuccess++;

            // Move past the eol & null after the volid.

            ptsz = _tcschr( ptsz, TEXT('\n') );
            if( NULL == ptsz || TEXT('\0') != ptsz[1] )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Unexpected end of file") ));
                TrkRaiseException( E_FAIL );
            }
            cLine++;
            ptsz += 2;  // Past '\n' and '\0'

            // Init tszPath with the drive letter.

            TCHAR tszPath[ MAX_PATH + 1 ];
            tszPath[0] = VolChar(iVol);
            tszPath[1] = TEXT(':');

            // Loop through the object IDs in the snapshot file.
            // They are in the form:
            //
            //    <file> = <objid>, <birth ID>
            //
            // E.g.
            //    \test = {...}, {...}{...}

            while( TRUE )
            {
                // Find the separator between the file name and the objid

                TCHAR *ptszSep;
                ptszSep = _tcschr( ptsz, TEXT('=') );
                if( NULL == ptszSep )
                    TrkRaiseException( E_FAIL );

                // cch is the length of the file name

                ULONG cch = ptszSep - ptsz;
                if( 0 == cch )
                    TrkRaiseException( E_FAIL );
                cch--;

                // Put the file name into tszPath

                _tcsncpy( &tszPath[2], ptsz, cch );
                tszPath[2+cch] = TEXT('\0');

                // Move ptsz to the beginning of the stringized objid

                ptsz = ptszSep + 1;
                if( TEXT(' ') != *ptsz )
                    TrkRaiseException( E_FAIL );
                ptsz++;

                // Unstringize the objid

                stringize.Use( ptsz );
                CObjId objid = stringize;

                // Move ptsz to the beginning of the birth ID, and unstringize it.

                ptsz = _tcschr( ptsz, TEXT(',') );
                if( NULL == ptsz || TEXT(' ') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                ptsz += 2;
                stringize.Use( ptsz );
                CDomainRelativeObjId droidBirth;
                droidBirth = stringize;

                // Set the objid and birth ID

                status = SetObjId( tszPath, objid, droidBirth );
                if( STATUS_OBJECT_NAME_COLLISION == status )
                {
                    cCollisions++;
                    status = STATUS_SUCCESS;
                }
                else if( FAILED(status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set objid on %s"), tszPath ));
                    TrkRaiseNtStatus( status );
                }
                else
                    cSuccess++;

                //_tprintf( TEXT("Set %s on %s\n"), static_cast<const TCHAR*>(CStringize(objid)), tszPath );

                // Move to the endo of the line

                ptsz = _tcschr( ptsz, TEXT('\n') );
                if( NULL == ptsz || TEXT('\0') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                // Move to the beginning of the next line
                ptsz += 2;  // '\n' & '\0'

                // If this is an empty line, then we're at the end of the file.
                if( TEXT('\n') == *ptsz )
                    break;

            }   // while( TRUE )

            printf( "%d IDs successfully set, %d ID collisions\n", cSuccess, cCollisions );

        }   // if fSaving ... else
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        printf( "Error exception at line %d: %08x\n", cLine, GetExceptionCode() );
    }


Exit:

    return;

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\tshlink.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include <windows.h>
#include <shlobj.h>
#include <shlguid.h>

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"

DWORD g_Debug = 0;


void Usage()
{
    wprintf( L"\n"
             L"Purpose:  Create/resolve shell links\n"
             L"Usage:    tshlink <-c <link client> <link source>> | <-r <link client>>\n"
             L"E.g.:     tshlink -c myfile.txt.lnk myfile.txt\n"
             L"          tshlink -r myfile.txt.lnk\n" );
    exit(0);
}


class CMyApp
{
public:

    CMyApp()
    {
        m_hwnd = NULL;
        *m_szAppName = '\0';
        m_nCmdShow = 0;
    }

    ~CMyApp() {}

public:

    __declspec(dllexport)
    static long FAR PASCAL
    WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam);


    BOOL Init( HANDLE hInstance, HANDLE hPrevInstance,
               LPSTR lpszCmdLine, int nCmdShow,
               int cArg, TCHAR *rgtszArg[] );

    WORD Run( void );

private:

    static HWND            m_hwnd;
    static CHAR            m_szAppName[80];
    static HINSTANCE       m_hInstance;
    static int             m_nCmdShow;
    static int             m_cArg;
    static TCHAR **        m_rgtszArg;

};


HWND            CMyApp::m_hwnd;
CHAR            CMyApp::m_szAppName[80];
HINSTANCE       CMyApp::m_hInstance;
int             CMyApp::m_nCmdShow;
int             CMyApp::m_cArg;
TCHAR **        CMyApp::m_rgtszArg;



CMyApp cMyApp;

EXTERN_C void __cdecl _tmain( int cArg, TCHAR *rgtszArg[] )
{

    if( cMyApp.Init(NULL, NULL, //hInstance, hPrevInstance,
                    NULL, SW_SHOWNORMAL, //lpszCmdLine, nCmdShow) )
                    cArg, rgtszArg ))

    {
        cMyApp.Run();
    }

}

void ShellLink( HWND hwnd, int cArg, TCHAR *rgtszArg[] );

long FAR PASCAL
CMyApp::WndProc (HWND hwnd, UINT message,
                 UINT wParam, LONG lParam)
{
    switch (message)
    {
        case WM_CREATE:

            ShellLink( hwnd, m_cArg, m_rgtszArg );
            PostQuitMessage(0);
            break;

        case WM_CLOSE :

            DestroyWindow( hwnd );
            break;

        case WM_DESTROY :

            PostQuitMessage (0) ;
            return 0 ;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}



BOOL
CMyApp::Init( HANDLE hInstance, HANDLE hPrevInstance,
              LPSTR lpszCmdLine, int nCmdShow,
              int cArg, TCHAR *rgtszArg[] )
{
    WNDCLASSA wndclass;

    sprintf( m_szAppName, "ShellLink" );
    m_hInstance = (HINSTANCE) hInstance;
    m_nCmdShow = nCmdShow;
    m_cArg = cArg;
    m_rgtszArg = rgtszArg;

    if( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc    = CMyApp::WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = m_hInstance;
        wndclass.hIcon          = LoadIconA( m_hInstance, m_szAppName );
        wndclass.hCursor        = LoadCursorA( NULL, MAKEINTRESOURCEA(32512) ); // IDC_ARROW
        wndclass.hbrBackground  = (HBRUSH) GetStockObject( WHITE_BRUSH );
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = m_szAppName;

        RegisterClassA( &wndclass );
    }

    return( TRUE ); // Successful
}


#ifdef CreateWindowA
#undef CreateWindow
#endif

WORD
CMyApp::Run( void )
{
    MSG msg;
    HRESULT hr;
    CHAR szErrorMessage[80];

    msg.wParam = 0;

    m_hwnd = CreateWindowA( m_szAppName,
                           "ShellLink",
                           WS_OVERLAPPEDWINDOW,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           NULL, NULL, m_hInstance, NULL );
    if( NULL == m_hwnd )
    {
        sprintf( szErrorMessage, "Failed CreateWindowA (%lu)", GetLastError() );
        goto Exit;
    }

    ShowWindow( m_hwnd, SW_MINIMIZE );
    UpdateWindow( m_hwnd );


    while( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

Exit:

    return( msg.wParam );
}



void ShellLink( HWND hwnd, int cArg, TCHAR *rgtszArg[] )
{
    HRESULT hr;
    IPersistFile *ppf = NULL;
    IShellLink *psl = NULL;
    TCHAR tszPath[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    WIN32_FIND_DATA fd;
    DWORD dwFlags;

    try
    {

        if( 2 > cArg ) Usage();
        if( L'-' != rgtszArg[1][0] ) Usage();

        hr = CoInitialize( NULL );
        if( FAILED(hr) ) throw L"Failed CoInit";

        hr = CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void**) &psl );
        if( FAILED(hr) ) throw L"Failed CoCreateInstance";

        hr = psl->QueryInterface( IID_IPersistFile, (void**) &ppf );
        if( FAILED(hr) ) throw L"Failed QI for IPersistFile";

        switch( rgtszArg[1][1] )
        {
        case L'c':
        case L'C':

            if( 4 > cArg ) Usage();

            if( L':' == rgtszArg[3][1]
                ||
                !wcsncmp( L"\\\\", rgtszArg[3], 2 ))
            {
                if( L':' == rgtszArg[3][1] && L'\\' != rgtszArg[3][2] )
                    Usage();

                wcscpy( tszPath, rgtszArg[3] );

                wcscpy( tszDir, tszPath );
                TCHAR *ptsz = wcsrchr( tszDir, L'\\' );
                *ptsz = L'\0';

            }
            else
            {
                if( !GetCurrentDirectory( sizeof(tszDir), tszDir ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    throw L"Failed GetCurrentDirectory";
                }

                wcscpy( tszPath, tszDir );
                wcscat( tszPath, L"\\" );
                wcscat( tszPath, rgtszArg[3] );
            }
            
            hr = psl->SetPath( tszPath );
            if( FAILED(hr) ) throw L"Failed IShellLink::SetPath";

            hr = psl->SetWorkingDirectory( tszDir );
            if( FAILED(hr) ) throw L"Failed IShellLink::SetWorkingDirectory";

            hr = ppf->Save( rgtszArg[2], TRUE );
            if( FAILED(hr) ) throw L"Failed IPersistFile::Save";

            wprintf( L"Success\n" );
            break;

        case L'r':
        case L'R':

            if( 3 > cArg ) Usage();

            hr = ppf->Load( rgtszArg[2], STGM_READ );
            if( FAILED(hr) ) throw L"Failed IPersistFile::Load";

            dwFlags = (180*1000 << 16) | SLR_ANY_MATCH;
            hr = psl->Resolve( hwnd, dwFlags );
            if( FAILED(hr) ) throw L"Failed Resolve";

            hr = psl->GetPath( tszPath, sizeof(tszPath), &fd, 0 );
            if( FAILED(hr) ) throw L"Failed IShellLink::GetPath";

            wprintf( L"Path = \"%s\"\n", tszPath );
            break;

        default:

            Usage();
            break;

        }   // switch

    }
    catch( TCHAR *tszError )
    {
        wprintf( L"Error:  %s (%08x)\n", tszError, hr );
    }

    if( ppf ) ppf->Release();
    if( psl ) psl->Release();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\ttrkcom.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       ttrkcom.cxx
//
//  Contents:   testing IPersistStreamInit interface
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    21-Apl-97  weiruc      Created.
//
//  Notes:      Use IStream on global memory instead of a file. Not sure if
//              it's worth the trouble to test with disk file.
//
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include <trkwks.hxx>
#include <cfiletim.hxx>
#include <trkcom.h>
#include <trkcom.hxx>
#include <ocidl.h>

DWORD g_Debug = TRKDBG_ERROR;

void ExtractPersistentState(CTrackFile* pTrackFile, LinkTrackPersistentState* target)
{
    memcpy(target, &(pTrackFile->_PersistentState), sizeof(pTrackFile->_PersistentState));
}

BOOL CmpPersistentState(CTrackFile* pTrackFile, LinkTrackPersistentState* target)
{
    if(memcmp(&(pTrackFile->_PersistentState), target, sizeof(pTrackFile->_PersistentState)) != 0)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

void FakeCreateFromPath(CTrackFile* pTrackFile)
{
    char*       pbScanner;

    // I can't get time() function to work. xxx
    // srand((unsigned)time(NULL));
 
        
    pTrackFile->_fLoaded = FALSE;
    pTrackFile->InitNew();

    pbScanner = (char*)&pTrackFile->_PersistentState.droidCurrent;
        TrkAssert(FIELD_OFFSET(LinkTrackPersistentState, droidCurrent) == sizeof(DWORD)+sizeof(CLSID));
    for(; pbScanner < (char*)&pTrackFile->_PersistentState + sizeof(pTrackFile->_PersistentState); pbScanner++)
    {
        *pbScanner = (char)rand();
    }

    pTrackFile->_fDirty = TRUE;
}

EXTERN_C int __cdecl _tmain(int argc, TCHAR **argv)
{ 
    HRESULT                     hr;
    ITrackFile*                 pTrackFile1 = NULL;
    ITrackFile*                 pTrackFile2 = NULL;
    IPersistStreamInit*         pPersistStreamInit = NULL;
    IPersistMemory*             pPersistMemory = NULL;
    IStream*                    pStream = NULL;
    HGLOBAL                     hmemStream = NULL, hmemMemory = NULL;
    CLSID                       clsid;
    ULARGE_INTEGER              cbSize_PersistStream;
    ULONG                       cbSize_PersistMemory;
    LinkTrackPersistentState    target;
    HANDLE                      hfileTest = INVALID_HANDLE_VALUE;
    LPVOID                      pszErrorMsg;
    BOOL                        fInitNew = TRUE,              // flags of whether
                                fIsDirty = TRUE,              // tests succeeded or
                                fSaveStream = TRUE,           // failed
                                fLoadStream = TRUE,
                                fSaveMemory = TRUE,
                                fLoadMemory = TRUE;
    ULARGE_INTEGER              ulSize1;                          //
    ULONG                       ulSize2;                          // filled by GetSizeMax
    ULONG                       cbWritten;
    LARGE_INTEGER               zeroOffset;                     // to reset IStream seek pointer
    DWORD                       cbPath;
    OLECHAR                     oszPath[ MAX_PATH + 1 ];
    BYTE                        rgb[256];

    __try
    {
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TTRKCOM" );
        CoInitialize( NULL );

        hmemStream = GlobalAlloc(GMEM_FIXED, sizeof(target));
        if(NULL == hmemStream)
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &pszErrorMsg,
                          0,
                          NULL);

            _tprintf(TEXT("Fatal error: %s\n"), pszErrorMsg);
            LocalFree(pszErrorMsg);
            goto ExitWithError;
        }
        hmemMemory = GlobalAlloc(GMEM_FIXED, sizeof(target));
        if(NULL == hmemMemory)
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &pszErrorMsg,
                          0,
                          NULL);

            _tprintf(TEXT("Fatal error: %s\n"), pszErrorMsg);
            LocalFree(pszErrorMsg);
            goto ExitWithError;
        }

        if(argc > 1)
        {
            _tprintf(TEXT("Usage: %s"), argv[0]);
            goto ExitWithError;
        }

        _tprintf(TEXT("********** Testing IPersistStreamInit and IPersistMemory **********\n"));

        // Create a temporary file for testing.
        hfileTest = CreateFile(TEXT("c:\\_testfile_"),
                               GENERIC_WRITE, 0, NULL, CREATE_NEW,
                               FILE_ATTRIBUTE_TEMPORARY,
                               NULL);
        if(hfileTest == INVALID_HANDLE_VALUE)
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &pszErrorMsg,
                          0,
                          NULL);


            _tprintf(TEXT("Fatal error: %s\n"), pszErrorMsg);
            LocalFree(pszErrorMsg);
            goto ExitWithError;
        }

        if(CloseHandle(hfileTest) == 0)
        {
            _tprintf(TEXT("Fatal error: Can't close test file \"c:\\_testfile_\"\n"));
            goto ExitWithError;
        }
        hfileTest = INVALID_HANDLE_VALUE;
        
        zeroOffset.QuadPart = 0;

        hr = CoCreateInstance(CLSID_TrackFile, NULL, CLSCTX_ALL, IID_ITrackFile, (void**)&pTrackFile1);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't get an ITrackFile (%08x)\n"), hr);
            goto ExitWithError;
        }

        hr = pTrackFile1->QueryInterface(IID_IPersistStreamInit, (void**)&pPersistStreamInit);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistStreamInit. hr = %08x"), hr);
        }
        hr = pTrackFile1->QueryInterface(IID_IPersistMemory, (void**)&pPersistMemory);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistMemory. hr = %08x"), hr);
        }

        hr = pPersistStreamInit->InitNew();            //  Should be able to call InitNew
        if(!SUCCEEDED(hr))                                 //  on a newly created object
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
            fInitNew = FALSE;
        }



        //  --------------------
        //  Parameter Validation
        //  --------------------

        hr = pTrackFile1->QueryInterface( IID_IPersistStreamInit, NULL );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::QueryInterface(...,NULL) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->CreateFromPath( NULL );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::CreateFromPath(NULL) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->QueryInterface( IID_IPersistStreamInit, NULL );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::QueryInterface(...,NULL) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->Resolve( NULL, oszPath, 1 );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::Resolve(NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->Resolve( &cbPath, NULL, 1 );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::Resolve(...,NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->GetClassID( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::GetClassID(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->Load( NULL, 1);
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::Load(NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->Save( NULL, TRUE, 1);
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::Save(NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->Save( &rgb, TRUE, 1);
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("IPersistMemory::Save(...,1) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->GetSizeMax( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::GetSizeMax(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistStreamInit->GetSizeMax( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistStreamInit::GetSizeMax(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistStreamInit->Load( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistStreamInit::Load(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistStreamInit->Save( NULL, TRUE );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistStreamInit::Save(NULL,...) FAILED, hr = %08x\n"), hr );









        if(fInitNew == TRUE)
        {
            hr = pPersistMemory->InitNew();            // InitNew can only be called once
            if(SUCCEEDED(hr))
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
                fInitNew = FALSE;
            }
            else if(E_UNEXPECTED != hr)
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
                fInitNew = FALSE;
            }
        }

        hr = pPersistStreamInit->IsDirty();            // IsDirty should return FALSE
        if(S_FALSE != hr)
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr);
            fIsDirty = FALSE;
        }

        pPersistStreamInit->GetSizeMax(&ulSize1);        // Test GetSizeMax
        pPersistMemory->GetSizeMax(&ulSize2);
        if(ulSize1.QuadPart != sizeof(target))
        {
            _tprintf(TEXT("IPersistStreamInit::GetSizeMax FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit::GetSizeMax PASSED\n"));
        }
        if(ulSize2 != sizeof(target))
        {
            _tprintf(TEXT("IPersistMemory::GetSizeMax FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistMemory::GetSizeMax PASSED\n"));
        }

        pPersistStreamInit->GetClassID(&clsid);          // Test GetClassID
        if(IID_ITrackFile != clsid)
        {
            _tprintf(TEXT("IPersistStreamInit::GetClassID FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit::GetClassID PASSED\n"));
        }
        pPersistMemory->GetClassID(&clsid);
        if(IID_ITrackFile != clsid)
        {
            _tprintf(TEXT("IPersistMemory::GetClassID FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistMemory::GetClassID PASSED\n"));
        }

        // This call breaks on my test machine. Since I don't really need it to test my
        // program, I'm going to fake the result from this call.
        // hr = pTrackFile1->CreateFromPath(TEXT("c:\\_testfile_"));
        // if(!SUCCEEDED(hr))
        // {
                // _tprintf(TEXT("Fatal error: Couldn't call CTrackFile::CreateFromPath(\"c:\\_testfile_\") (%08x)\n"), hr);
                // goto ExitWithError;
        // }

        FakeCreateFromPath((CTrackFile*)pTrackFile1);

        if(fIsDirty == TRUE)
        {
            hr = pPersistStreamInit->IsDirty();            // After CreateFromPath IsDirty
            if(S_OK != hr)                                  // should return dirty.
            {
                _tprintf(TEXT("IPersistStreamInit::IsDirty FAILED. hr = %08x\n"), hr);
                _tprintf(TEXT("IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr );
                fIsDirty = FALSE;
            }
        }

        if(fInitNew == TRUE)
        {
            hr = pPersistStreamInit->InitNew();         // Shouldn't be able to call InitNew
            if(S_OK == hr || E_UNEXPECTED != hr)        // after TrackFile is initialized.
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
            }
            else
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew PASSED\n"));
            }
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
        }

        hr = CreateStreamOnHGlobal(hmemStream, FALSE, &pStream);   // pPersistStreamInit::Save test
        if( !SUCCEEDED(hr) )
        {
            _tprintf(TEXT("Fatal error: Couldn't get an IStream (%08x)\n"), hr);
            goto ExitWithError;
        }
        hr = pPersistStreamInit->Save(pStream, FALSE);  // fClearDirty is set to FALSE
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistStreamInit::Save FAILED (%08x)\n"), hr);
            fSaveStream = FALSE;
        }
        else
        {
            if(fIsDirty == TRUE)
            {
                hr = pPersistStreamInit->IsDirty();  // After Save, IsDirty should still return
                if(S_OK != hr)                       // dirty when fClearDirty is set to be FALSE.
                {
                    _tprintf(TEXT("Either IPersistStreamInit/IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr);
                    _tprintf(TEXT("or     IPersistStreamInit::Save with fClearDirty = FALSE FAILED\n"));
                    fIsDirty = FALSE;
                }
            }
        }
        pStream->Seek(zeroOffset, STREAM_SEEK_SET, NULL);
        hr = pPersistStreamInit->Save(pStream, TRUE);   // set fClearDirty to be TRUE
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistStreamInit::Save FAILED (%08x)\n"), hr);
            fSaveStream = FALSE;
        }
        else
        {
            if(fIsDirty == TRUE)
            {
                hr = pPersistStreamInit->IsDirty();     // After Save, IsDirty should return
                if(S_FALSE != hr)                       // clean when fClearDirty is TRUE.
                {
                    _tprintf(TEXT("Either IPersistStreamInit/IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr);
                    _tprintf(TEXT("or     IPersistStreamInit::Save with fClearDirty = TRUE FAILED\n"));
                    fIsDirty = FALSE;
                }
            }
        }

        if(fIsDirty == TRUE)
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::IsDirty PASSED\n"));
        }

        hr = pPersistMemory->Save(hmemMemory, FALSE, GlobalSize(hmemMemory));   // test IPersistMemory::Save
        if(!SUCCEEDED(hr))                                                                      // fClearDirty is set to be FALSE
        {
            _tprintf(TEXT("IPersistMemory::Save FAILED (%08x)\n"), hr);
            fSaveMemory = FALSE;
        }
        hr = pPersistMemory->Save(hmemMemory, TRUE, GlobalSize(hmemMemory));    // fClearDirty = TRUE
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistMemory::Save FAILED (%08x)\n"), hr);
            fSaveMemory = FALSE;
        }

        if(TRUE == fSaveStream && TRUE == fSaveMemory)  // Compare the memory content after
        {                                                   // Save operation
            ExtractPersistentState((CTrackFile*)pTrackFile1, &target);
            if(memcmp(hmemStream, &target, sizeof(target)) == 0)
            {
                _tprintf(TEXT("IPersistStreamInit::Save PASSED (if no error message before about fClearDirty)\n"));
            }
            else
            {
                _tprintf(TEXT("IPersistStreamInit::Save FAILED\n"));
            }
            if(memcmp(hmemMemory, &target, sizeof(target)) == 0)
            {
                _tprintf(TEXT("IPersistMemory::Save PASSED (if no error message before about fClearDirty)\n"));
            }
            else
            {
                _tprintf(TEXT("IPersistMemory::Save FAILED\n"));
            }
        }
        RELEASE_INTERFACE(pTrackFile1);
        RELEASE_INTERFACE(pPersistMemory);
        RELEASE_INTERFACE(pPersistStreamInit);
        RELEASE_INTERFACE(pStream);

        // Test Load functions
        hr = CoCreateInstance(IID_ITrackFile, NULL, CLSCTX_ALL, IID_ITrackFile, (void**)&pTrackFile1);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't get an ITrackFile (%08x)\n"), hr);
            goto ExitWithError;
        }   
        hr = pTrackFile1->QueryInterface(IID_IPersistStreamInit, (void**)&pPersistStreamInit);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistStreamInit"));
            goto ExitWithError;
        }

        hr = CoCreateInstance(IID_ITrackFile, NULL, CLSCTX_ALL, IID_ITrackFile, (void**)&pTrackFile2);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't get an ITrackFile (%08x)\n"), hr);
            goto ExitWithError;
        }
        hr = pTrackFile2->QueryInterface(IID_IPersistMemory, (void**)&pPersistMemory);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistMemory"));
            goto ExitWithError;
        }

        memcpy(hmemMemory, &target, sizeof(target));     // Set up sources to load from
        CreateStreamOnHGlobal(hmemStream, TRUE, &pStream);
        hr = pStream->Write((byte*)&target, sizeof(target), &cbWritten);
        if(!SUCCEEDED(hr) || sizeof(target) != cbWritten)
        {
            _tprintf(TEXT("Fatal error: Can't create stream object\n"));
            goto ExitWithError;
        }
        pStream->Seek(zeroOffset, STREAM_SEEK_SET, NULL);

        hr = pPersistStreamInit->Load(pStream);         // Test IPersistStreamInit::Load
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistStreamInit::Load FAILED. hr = %08x\n"), hr);
        }
        else if(CmpPersistentState((CTrackFile*)pTrackFile1, (LinkTrackPersistentState*)hmemStream) != TRUE)
        {
            _tprintf(TEXT("IPersistStreamInit::Load FAILED"));
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit::Load PASSED\n"));
        }

        hr = pPersistMemory->Load(hmemMemory, GlobalSize(hmemMemory));  // Test IPersistMemory::Load
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistMemory::Load FAILED. hr = %08x\n"), hr);
        }
        else if(CmpPersistentState((CTrackFile*)pTrackFile2, (LinkTrackPersistentState*)hmemMemory) != TRUE)
        {
            _tprintf(TEXT("IPersistMemory::Load FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistMemory::Load PASSED\n"));
        }
    }
    __except(BreakOnDebuggableException())
    {
        _tprintf(TEXT("Exception happened. Exception code = %08x\n"), GetExceptionCode());
    }

ExitWithError:

    RELEASE_INTERFACE(pTrackFile1);
    RELEASE_INTERFACE(pTrackFile2);
    RELEASE_INTERFACE(pPersistStreamInit);
    RELEASE_INTERFACE(pPersistMemory);
    RELEASE_INTERFACE(pStream);
    
    GlobalFree(hmemStream);
    GlobalFree(hmemMemory);

    if(DeleteFile(TEXT("c:\\_testfile_")) == 0)
    {
        _tprintf(TEXT("WARNING: Couldn't delete test file \"c:\\_testfile_\""));
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\trestore.cxx ===
#include "pch.cxx"
#pragma hdrstop
#include "teststub.cxx"

#define TRKDATA_ALLOCATE
#include "trksvr.hxx"

#include "itrkadmn.h"

DWORD g_Debug = 0xffffffff & ~TRKDBG_WORKMAN;

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

EXTERN_C void __cdecl _tmain( ULONG cArgs, TCHAR *rgtszArgs[] )
{
    TCHAR tsz[ MAX_PATH + 1 ];

    IBindCtx *pBC = NULL;
    IMoniker* pMnk = NULL;
    ITrkRestoreNotify *pTrkRestore = NULL; 
    ULONG cchEaten = 0;
    HRESULT hr = E_FAIL;


    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TRestore" );
    CoInitialize(NULL);

    if( 1 >= cArgs )
    {
        printf( "\n"
                "This test takes a path and calls ITrkRestoreNotify on that machine\n" );
        printf( "Usage:  TRestore <path>\n" );
        printf( "E.g.:   TRestore \\\\machine\\share\\dir\\path.ext\n" );
        goto Exit;
    }

    __try
    {
        _tcscpy( tsz, TEXT("@LinkTrack@") );
        _tcscat( tsz, rgtszArgs[1] );

        // Get the moniker
        CreateBindCtx( 0, &pBC ); 
        hr = MkParseDisplayName( pBC, tsz, &cchEaten, &pMnk );
        if( FAILED(hr) ) TrkRaiseException( hr );

        // Get the ITrkRestoreNotify object
        hr = pMnk->BindToObject( pBC, NULL, IID_ITrkRestoreNotify, reinterpret_cast<void**>(&pTrkRestore) );
        if( FAILED(hr) ) TrkRaiseException( hr );

        // Do the notification
        hr = pTrkRestore->OnRestore();
        if( FAILED(hr) ) TrkRaiseException( hr );
    }
    __except( BreakOnDebuggableException() )
    {
        TrkAssert( STATUS_ACCESS_VIOLATION != GetExceptionCode() );
        TrkLog(( TRKDBG_ERROR, TEXT("Exception %d caught in TRestore\n"), GetExceptionCode() ));
    }

Exit:

    if( SUCCEEDED(hr) ) printf("Passed\n");

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\tlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       tlink.cxx
//
//  Contents:   Utility to create/mend links and move files with notify
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE    // This is the main module, trigger trkwks.hxx to do definitions
#include <trkwks.hxx>
#include <cfiletim.hxx>
#include <ocidl.h>

#include <shlobj.h>
#include <shlguid.h>

DWORD g_Debug = TRKDBG_ERROR;

#define CB_LINK_CLIENT_MAX  256

// Implicitely load shell32.dll, rather than waiting for the CoCreate of IShellLink,
// in order to make it easier to debug in windbg.
#pragma comment( lib, "shell32.lib" )


enum EXTRAFLAGS
{
    EXTRAFLAG_SHOW_IDS = 1
};



extern "C"
IID IID_ISLTracker
#ifdef TRKDATA_ALLOCATE
= { /* 7c9e512f-41d7-11d1-8e2e-00c04fb9386d */
    0x7c9e512f,
    0x41d7,
    0x11d1,
    {0x8e, 0x2e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
};
#else
;
#endif

class ISLTracker : public IUnknown
{
public:

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) ()  PURE;
    STDMETHOD_(ULONG,Release) () PURE;

    STDMETHOD(Resolve)(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions) PURE;
    STDMETHOD(GetIDs)(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid) PURE;
};  // interface ISLTracker




void
EnumObjects()
{
    CObjIdEnumerator oie;

    __try
    {
        CObjId aobjid[1000];
        CDomainRelativeObjId adroid[1000];
        int cSources=0;
        
        const int FirstDrive = 'c';
        const int LastDrive = 'z';

        for (int Drive = FirstDrive-'a'; 
                 Drive < LastDrive-'a'+1; 
                 Drive ++)
        {
            // fill up the array with ids from all the drives
            if (oie.Initialize(CVolumeDeviceName(Drive)))
            {
                if (oie.FindFirst(aobjid, adroid))
                {
                    BOOL fGotOne = FALSE;


                    do
                    {
                        do
                        {
                            CDomainRelativeObjId droidBirth;

                            TCHAR tszObjId[256];
                            TCHAR tszBirthLink[256];
                            TCHAR tszPath[MAX_PATH+1];
                            TCHAR * ptszObjId = tszObjId;

                            StringizeGuid(*(GUID*)&aobjid[cSources], ptszObjId);
                            FindLocalPath( Drive, aobjid[cSources], &droidBirth, &tszPath[2]);
                            tszPath[0] = VolChar(Drive);
                            tszPath[1] = TEXT(':');

                            _tprintf(TEXT("%s %s %s\n"),
                                tszObjId,
                                adroid[cSources].Stringize(tszBirthLink,256),
                                tszPath);

                            cSources ++;
                        } while (cSources < sizeof(aobjid)/sizeof(aobjid[0]) &&
                                 (fGotOne = oie.FindNext(&aobjid[ cSources ], &adroid[ cSources ])));
        
                        TrkAssert(cSources > 0);
                        cSources = 0;

                    } while (fGotOne);
                }
            }
        }
    }
    __except(BreakOnDebuggableException())
    {
    }

    oie.UnInitialize();
}

void
AttackDC()
{
    CMachineId mcidDomain(MCID_DOMAIN);
    CRpcClientBinding rcConnect;

    rcConnect.RcInitialize(mcidDomain, s_tszTrkSvrRpcProtocol, s_tszTrkSvrRpcEndPoint);

    TRKSVR_MESSAGE_UNION m;
    CObjId objidCurrent;
    CDomainRelativeObjId droidBirth, droidNew;
    CVolumeId volid;
    

    m.MessageType = MOVE_NOTIFICATION;
    m.Priority = PRI_0;
    m.MoveNotification.cNotifications = 0;
    m.MoveNotification.pvolid = &volid;
    m.MoveNotification.rgobjidCurrent = &objidCurrent;
    m.MoveNotification.rgdroidBirth = &droidBirth;
    m.MoveNotification.rgdroidNew = &droidNew;

    while (1)
    {
        LnkSvrMessage( rcConnect, &m);
    }

    rcConnect.UnInitialize();
}

void
DoCreateLink(IShellLink * pshlink, const TCHAR *ptszLink, const TCHAR *ptszSrc)
{
    HRESULT hr;
    IPersistFile *pPersistFile = NULL;

    __try
    {
        DWORD dwWritten;
        BYTE rgb[ CB_LINK_CLIENT_MAX ];
        ULONG cbPersist = 0;

        memset( rgb, 0, sizeof(rgb) );

        hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI IShellLink for IPersistFile") ));
            TrkRaiseException( hr );
        }

        hr = pshlink->SetPath( ptszSrc );
        _tprintf( TEXT("IShellLink::SetPath returned %08X (%s)\n"),
                  hr, 0==hr ? TEXT("no error") : GetErrorString(hr));
        if( S_OK != hr )
        {
            TrkRaiseException( hr );
        }

        hr = pPersistFile->Save( ptszLink, TRUE );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't persist IShellLink") ));
            TrkRaiseException( hr );
        }
        pPersistFile->SaveCompleted( ptszLink );

        RELEASE_INTERFACE( pPersistFile );

    }
    __except( BreakOnDebuggableException() )
    {
        RELEASE_INTERFACE( pPersistFile );
    }

}

TCHAR *
GetRestrict(DWORD r)
{
    static TCHAR tszError[256];

    tszError[0] = 0;
    if (r == TRK_MEND_DEFAULT)
    {
        _tcscpy(tszError, TEXT("TRK_MEND_DEFAULT "));
    }
    if (r & TRK_MEND_DONT_USE_LOG)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_LOG "));
    }
    if (r & TRK_MEND_DONT_USE_DC)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_DC "));
    }
    if (r & TRK_MEND_SLEEP_DURING_MEND)
    {
        _tcscat(tszError, TEXT("TRK_MEND_SLEEP_DURING_SEARCH "));
    }
    if (r & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_SEARCH_ALL_VOLUMES "));
    }
    if (r & TRK_MEND_DONT_USE_VOLIDS)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_VOLIDS "));
    }
    return(tszError);
}



void
DisplayIDs( ISLTracker *ptracker )
{
    HRESULT hr = S_OK;
    CDomainRelativeObjId droidBirth, droidLast;
    CMachineId mcid;
    TCHAR tsz[ MAX_PATH ];
    TCHAR *ptsz = tsz;

    hr = ptracker->GetIDs( &droidBirth, &droidLast, &mcid );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get IDs") ));
        TrkRaiseException( hr );
    }

    droidBirth.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Birth =\t%s\n"), tsz );

    droidLast.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Last =\t%s\n"), tsz );

    ptsz = tsz;
    mcid.Stringize(ptsz);
    _tprintf( TEXT("Machine =\t%s\n"), tsz );

}


void
DoResolveLink(IShellLink * pshlink, const TCHAR * ptszLink, DWORD r, DWORD dwSLR, DWORD grfExtra )
{
    IPersistFile * pPersistFile = NULL;
    ISLTracker * ptracker = NULL;

    __try
    {
        DWORD dwRead;
        HRESULT  hr;
        WCHAR    wszPath[MAX_PATH+1];
        ULONG    cbPath = sizeof(wszPath);
        WIN32_FIND_DATA fd;

        hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for IPersistFile")));
            TrkRaiseException( hr );
        }

        hr = pPersistFile->Load( ptszLink, STGM_SHARE_EXCLUSIVE | STGM_READWRITE );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't load IShellLink")));
            TrkRaiseException( hr );
        }
        RELEASE_INTERFACE( pPersistFile );

        // Track it (within 30 seconds).
        if( TRK_MEND_DEFAULT == r && 0 == grfExtra )
        {
            hr = pshlink->Resolve( GetDesktopWindow(), 0xfffe0000 | dwSLR | SLR_ANY_MATCH );
        }
        else
        {
            hr = pshlink->QueryInterface( IID_ISLTracker, (void**) &ptracker );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for ISLTracker")));
                TrkRaiseException( hr );
            }

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );

            hr = ptracker->Resolve( GetDesktopWindow(), 0x00100000 /*0xfffe0000*/ | dwSLR | SLR_ANY_MATCH, r );

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );
        }

        pshlink->GetPath( wszPath, cbPath, &fd, 0 );


        _tprintf( TEXT("%ws %08X (%s) %s\n"),
                  wszPath, hr, GetErrorString(hr), GetRestrict(r) );

        RELEASE_INTERFACE( ptracker );

    }
    __except( BreakOnDebuggableException() )
    {
        RELEASE_INTERFACE( pPersistFile );
        RELEASE_INTERFACE( ptracker );

    }

}


void
SignalLockVolume()
{
    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("LOCK_VOLUMES"));
    if (hEvent != NULL)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
    else
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open LOCK_VOLUMES event %d\n"), GetLastError()));
    }

}

void
DoTestWksSvcUp(TCHAR * ptszMachine)
{
    CRpcClientBinding rc;
    CMachineId mcid(ptszMachine);
    BOOL fCalledMachine = FALSE;

    __try
    {
        
        rc.RcInitialize(mcid);

        if (E_NOTIMPL == LnkRestartDcSynchronization(rc))
            fCalledMachine = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    TrkLog((TRKDBG_ERROR,
        TEXT("%successfully called machine %s\n"),
        fCalledMachine ? TEXT("S") : TEXT("Uns"),
        ptszMachine));
}

typedef BOOL (WINAPI *PFNMoveFileWithProgress)( LPCWSTR lpExistingFileName,
                                                LPCWSTR lpNewFileName,
                                                LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
                                                LPVOID lpData OPTIONAL,
                                                DWORD dwFlags
                                                );

#ifndef MOVEFILE_FAIL_IF_NOT_TRACKABLE
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE  0x00000020
#endif


#ifndef UNICODE
#error Unicode required for wszFullPath
#endif

EXTERN_C void __cdecl _tmain(int argc, TCHAR **argv)
{ 
    BOOL fError = FALSE;
    HRESULT hr;
    CMachineId mcid(MCID_LOCAL);
    int ArgC = argc;
    TCHAR ** ArgV = argv;
    DWORD r = TRK_MEND_DEFAULT;
    DWORD grfExtra = 0;
    DWORD dwSLR = 0;    // SLR_ flags
    IShellLink *pshlink = NULL;
    WCHAR wszFullPath[ MAX_PATH + 1 ];
    DWORD dwMoveFlags = MOVEFILE_FAIL_IF_NOT_TRACKABLE |
        MOVEFILE_COPY_ALLOWED |
        MOVEFILE_REPLACE_EXISTING;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TLink" );
    CoInitialize( NULL );

    hr = CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_ALL, IID_IShellLink, (void**)&pshlink );
    if( FAILED(hr) )
    {
        printf( "Couldn't get an IShellLink (%08x)\n", hr );
        goto Exit;
    }

    ArgC--;
    ArgV++;

    if (ArgC == 0)
    {
        fError = TRUE;
    }


    while (!fError && ArgC > 0)
    {
        fError = TRUE;
        if (ArgV[0][0] == TEXT('-') || ArgV[0][0] == TEXT('/'))
        {
            switch (ArgV[0][1])
            {
            case TEXT('a'):
            case TEXT('A'):
                fError = FALSE;
                ArgC --;
                ArgV ++;
                AttackDC();
                break;
            case TEXT('e'):
            case TEXT('E'):
                fError = FALSE;
                ArgC --;
                ArgV ++;
                EnumObjects();
                break;

            case TEXT('v'):
            case TEXT('V'):
                fError = FALSE;
                ArgC --;
                ArgV ++;
                SignalLockVolume();
                break;

            case TEXT('m'):
            case TEXT('M'):
                if (ArgC >= 3)
                {

                    PFNMoveFileWithProgress pfnMoveFileWithProgress = NULL;
                    HMODULE hmodKernel32;

                    for( int i = 2; ArgV[0][i] != TEXT('\0'); i++ )
                    {
                        switch(ArgV[0][i])
                        {
                            case TEXT('f'):
                            case TEXT('F'):
                                dwMoveFlags &= ~ MOVEFILE_FAIL_IF_NOT_TRACKABLE;
                                break;

                            case TEXT('n'):
                            case TEXT('N'):
                                dwMoveFlags &= ~ MOVEFILE_COPY_ALLOWED;
                                break;

                            case TEXT('o'):
                            case TEXT('O'):
                                dwMoveFlags &= ~ MOVEFILE_REPLACE_EXISTING;
                                break;
                            default:
                                _tprintf( TEXT("Bad Move switch: %c\n"), ArgV[0][i] );
                                goto Exit;
                        }   // switch
                    }   // for

                    hmodKernel32 = GetModuleHandle( TEXT("kernel32.dll") );
                    if( NULL == hmodKernel32 )
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("Failed GetModuleHeader for kernel32.dll") ));
                        TrkRaiseLastError( );
                    }
                    pfnMoveFileWithProgress = (PFNMoveFileWithProgress)
                                              GetProcAddress( hmodKernel32, "MoveFileWithProgressW" );
                    if( NULL == pfnMoveFileWithProgress )
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("Couldn't get MoveFileWithProgress export")));
                        TrkRaiseLastError( );
                    }

                    if( !pfnMoveFileWithProgress( ArgV[1], ArgV[2], NULL, NULL, dwMoveFlags ))
                    {
                        _tprintf( TEXT("Failed MoveFileWithProgress (%lu)\n"), GetLastError() );
                    }

                    ArgC -= 3;
                    ArgV += 3;
                    fError = FALSE;
                }
                break;


            case TEXT('c'):
            case TEXT('C'):
                if (ArgC >= 3)
                {
                    if( MAX_PATH < RtlGetFullPathName_U( ArgV[2], sizeof(wszFullPath), wszFullPath, NULL ))
                    {
                        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get full path name") ));
                        TrkRaiseWin32Error( ERROR_BAD_PATHNAME );
                    }


                    DoCreateLink( pshlink, ArgV[1], wszFullPath );

                    ArgC -= 3;
                    ArgV += 3;
                    fError = FALSE;
                }
                break;
            case TEXT('r'):
            case TEXT('R'):
                if (ArgC >= 2)
                {
                    for( int i = 2; ArgV[0][i] != TEXT('\0'); i++ )
                    {
                        switch(ArgV[0][i])
                        {
                            case TEXT('l'):
                            case TEXT('L'):
                                r |= TRK_MEND_DONT_USE_LOG;
                                break;
                            case TEXT('d'):
                            case TEXT('D'):
                                r |= TRK_MEND_DONT_USE_DC;
                                break;
                            case TEXT('i'):
                            case TEXT('I'):
                                r |= TRK_MEND_DONT_USE_VOLIDS;
                                break;
                            case TEXT('m'):
                            case TEXT('M'):
                                r |= TRK_MEND_DONT_SEARCH_ALL_VOLUMES;
                                break;
                            case TEXT('s'):
                            case TEXT('S'):
                                dwSLR |= SLR_NOSEARCH;
                                break;
                            case TEXT('t'):
                            case TEXT('T'):
                                dwSLR |= SLR_NOTRACK;
                                break;
                            case TEXT('u'):
                            case TEXT('U'):
                                dwSLR |= SLR_NO_UI;
                                break;
                            case TEXT('x'):
                            case TEXT('X'):
                                grfExtra |= EXTRAFLAG_SHOW_IDS;
                                break;
                            case TEXT('z'):
                            case TEXT('Z'):
                                r |= TRK_MEND_SLEEP_DURING_MEND;
                                break;

                            default:
                                _tprintf( TEXT("Bad Resolve switch: %c\n"), ArgV[0][i] );
                                goto Exit;
                        }   // switch
                    }   // for

                    DoResolveLink( pshlink, ArgV[1], r, dwSLR, grfExtra );
                    ArgC -= 2;
                    ArgV += 2;
                    fError = FALSE;
                }
                break;
            case TEXT('t'):
            case TEXT('T'):
                if (ArgC >= 2)
                {
                    DoTestWksSvcUp( ArgV[1] );
                    ArgC -= 2;
                    ArgV += 2;
                    fError = FALSE;
                }
                break;

            default:
                break;
            }
        }
    }

Exit:

    if (fError)
    {
        printf("Usage: \n");
        printf(" Operation   Params\n");
        printf(" ---------   ------\n");
        printf(" AttackDC    -a\n");
        printf(" MoveFileWP  -m<opts> <src> <dst>\n");
        printf("   where <opts> may use:  -f = NO fail if not trackable flag\n");
        printf("                          -n = NO copy-allowed flag\n");
        printf("                          -o = NO overwrite existing flag\n");
        printf(" CreateLink  -c <link> <src>\n");
        printf(" EnumObjects -e\n");
        printf(" SignalLockVolume -v\n");
        printf(" ResolveLink -r<opts> <link>\n");
        printf("   where <opts> may use:  -l = don't use log\n");
        printf("                          -d = don't use dc\n");
        printf("                          -i = don't use volids\n");
        printf("                          -m = don't scan all volumes on a machine\n");
        printf("                          -s = no search (SLR_NOSEARCH)\n");
        printf("                          -t = no track (SLR_NOTRACK)\n");
        printf("                          -x = show before/after droids\n");
        printf("                          -u = no UI (SLR_NOUI)\n");
        printf("                          -z = sleep in CTrkWksSvc::Mend\n");
        printf("E.g.:\n");
        printf(" tlink -c l1 t1\n");
        printf(" tlink -mf t1 t1a\n");
        printf(" tlink -r l1\n");
        printf(" tlink -rd l1\n");

    }


    RELEASE_INTERFACE( pshlink );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\cmacs.h ===
/****************************** Module Header ******************************\
* Module Name: CMACS.H
*
* This module contains common macros used by C routines.
*
* Created: 9-Feb-1989
*
* Copyright (c) 1985 - 1989  Microsoft Corporation
*
* History:
*   Created by Raor
*
\***************************************************************************/

#define _WINDOWS
#define  DLL_USE

#define INTERNAL        PASCAL NEAR
#define FARINTERNAL     PASCAL FAR

#define DEBUG_OUT(err, val) ;
#define ASSERT(cond, msg)
#define Puts(msg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\defcreat.c ===
/****************************** Module Header ******************************\
* Module Name: defcreat.c
*
* Purpose: Handles the various object creation routines, which are exported
*          to the DLL writers.
*
* Created: November 1990
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*   Srinik (11/12/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;


RENDER_ENTRY stdRender[NUM_RENDER] = {
    { "METAFILEPICT",   0, MfLoadFromStream}, 
    { "DIB",            0, DibLoadFromStream},
    { "BITMAP",         0, BmLoadFromStream},
    { "ENHMETAFILE",    0, EmfLoadFromStream} 
};


OLESTATUS  FARINTERNAL  DefLoadFromStream (
    LPOLESTREAM         lpstream,
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    int         i;

    UNREFERENCED_PARAMETER(lpprotocol);

    *lplpobj = NULL;        

    if ((objType == CT_PICTURE) || (objType == CT_STATIC)) {
        for (i = 0; i < NUM_RENDER; i++) {
            if (stdRender[i].aClass == aClass) {
                retVal = (*stdRender[i].Load) (lpstream, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, objType);
                if (aClass)
                    GlobalDeleteAtom (aClass);
                return retVal;
            }
        }
        
        return GenLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
    else {
        return LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
}


OLESTATUS FAR PASCAL DefCreateFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    LONG                objType
){
    UNREFERENCED_PARAMETER(lpprotocol);

    if (objType == CT_EMBEDDED)
        return EmbPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat);
    
    if (objType == CT_LINK)
        return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat, cfOwnerLink);

    return OLE_ERROR_CLIPBOARD;                          
}




OLESTATUS FAR PASCAL DefCreateLinkFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                optRender, cfFormat, cfObjectLink);
}


OLESTATUS FAR PASCAL DefCreateFromTemplate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LeCreateFromTemplate (lpclient,
                    lptemplate,
                    lhclientdoc,
                    lpobjname,
                    lplpoleobject,
                    optRender,
                    cfFormat);
}


OLESTATUS FAR PASCAL DefCreate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LeCreate (lpclient,
                lpclass,
                lhclientdoc,
                lpobjname,
                lplpoleobject,
                optRender,
                cfFormat);
}



OLESTATUS FAR PASCAL DefCreateFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        NULL,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_EMBEDDED);
}


OLESTATUS FAR PASCAL DefCreateLinkFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LPSTR               lpitem,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        lpitem,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_LINK);
}


OLESTATUS FAR PASCAL DefCreateInvisible (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                fActivate
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LeCreateInvisible (lpclient,
                        lpclass,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        fActivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\dde.c ===
/****************************** Module Header ******************************\
* Module Name: DDE.C (Extensible Compound Documents -DDE)
*
* Copyright (c) 1985 - 1991 Microsoft Corporation
*
* PURPOSE: Handles all API routines for the dde sub-dll of the ole dll.
*
* History:
*   Raor,Srinik  (../../90,91)  Designed and coded
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"
#include "strsafe.h"

/* #define GRAPHBUG */


// ### may not need seperate wndproc for system topic!
HANDLE  GetDDEDataHandle (DDEDATA FAR *, UINT, HANDLE);

extern  ATOM        aSystem;
extern  ATOM        aOle;
extern  HANDLE      hInstDLL;


// DocWndProc: Window procedure used to document DDE conversations

LRESULT FAR PASCAL DocWndProc(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
){
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;



    Puts("DocWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLongPtr (hwnd, 0))
    {
        pedit = lpobj->pDocEdit;
    }
    else
    {
        // Can't cope so just pass this message on
        DEBUG_OUT ("SYS: doc conv block missing",0);
        return DefWindowProc (hwnd, message, wParam, lParam);
    }

    switch (message){

        case WM_DDE_ACK:
            DEBUG_OUT ("WM_DDE_ACK ", 0);
            if (pedit->bTerminating){
                // ### this error recovery may not be correct.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch(pedit->awaitAck){

                case AA_INITIATE:
                    HandleAckInitMsg (pedit, (HWND)wParam);
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));
                    break;

                case AA_REQUEST:
                    Puts("Request");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_UNADVISE:
                    Puts("Unadvise");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_EXECUTE:
                    Puts("Execute");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_ADVISE:
                    Puts("Advise");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_POKE:

                    // freeing pokedata is done in handleack
                    Puts("Poke");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;

            } // end of switch
            break;

        case WM_TIMER:
            HandleTimerMsg (lpobj, pedit);
            break;

        case WM_DDE_DATA:
            DEBUG_OUT ("WM_DDE_DATA",0);
            HandleDataMsg (lpobj, GET_WM_DDE_DATA_HDATA(wParam,lParam),
                                  GET_WM_DDE_DATA_ITEM(wParam,lParam));
            DDEFREE(message, lParam);
            break;

        case WM_DDE_TERMINATE:

            DEBUG_OUT ("WM_DDE_TERMINATE",0);
            HandleTermMsg (lpobj, pedit, (HWND)wParam, TRUE);
            break;

        case WM_DESTROY:

            DEBUG_OUT ("Client window being destroyed", 0)
            pedit->hClient = NULL;
            break;

        default:
            return DefWindowProc (hwnd, message, wParam, lParam);

    }
    return 0L;
}



// SrvrWndProc: Window Procedure for System Topic DDE conversations
// wndproc for system topic

LRESULT FAR PASCAL SrvrWndProc(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
){
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;

    Puts("SysWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLongPtr (hwnd, 0))
    {
        pedit = lpobj->pSysEdit;
    }
    else
    {
        // Can't cope so just pass this message on
        DEBUG_OUT ("SYS: conv edit block missing",0);
        return DefWindowProc (hwnd, message, wParam, lParam);
    }


    switch (message){

       case WM_DDE_ACK:


            DEBUG_OUT ("SYS: WM_DDE_ACK",0);

            if(pedit->bTerminating){
                //### Error recovery may not be OK.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch (pedit->awaitAck) {


                case AA_INITIATE:

#ifdef      HISTORY
                    if (GETWINDOWUINT((HWND)wParam, GWW_HINSTANCE) == pedit->hInst ||
                            IsSrvrDLLwnd ((HWND)wParam, pedit->hInst)) {
                        // For exact instance match or for
                        // DLL instance match, keep the new one

                        pedit->hServer = (HWND)wParam;
                    } else {

                        ++pedit->extraTerm;
                        // This post directly is alright since we are
                        // terminating extra initiates.

                        PostMessage ((HWND)wParam,
                                WM_DDE_TERMINATE, hwnd, 0);
                    }
#else

                    HandleAckInitMsg (pedit, (HWND)wParam);
#endif
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));

                    break;

                case AA_EXECUTE:
                    HandleAck(lpobj, pedit, wParam, lParam);
                    break;


                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;


            }

            break;

       case WM_TIMER:

            HandleTimerMsg (lpobj, pedit);
            break;

       case WM_DDE_TERMINATE:

            HandleTermMsg (lpobj, pedit, (HWND)wParam, FALSE);
            break;

       case WM_DESTROY:
            DEBUG_OUT ("destroy window for the sys connection", 0);
            pedit->hClient = NULL;
            break;


       default:
            return DefWindowProc (hwnd, message, wParam, lParam);

       }
       return 0L;
}

void    INTERNAL    HandleTimerMsg (
    LPOBJECT_LE lpobj,
    PEDIT_DDE   pedit
){


    // Since there is only one timer for each client, just
    // repost the message and delete the timer.

    KillTimer (pedit->hClient, 1);
    pedit->wTimer = 0;

    if (PostMessageToServer(pedit, pedit->msg, pedit->lParam))
        return ; // return something.

    // Postmessage failed. We need to getback to the main stream of
    // commands for the object.
    HandleAck (lpobj, pedit, (WPARAM)NULL, pedit->lParam);
    return ;
}


void INTERNAL   HandleTermMsg (lpobj, pedit, hwndPost, bDoc)
    LPOBJECT_LE     lpobj;
    PEDIT_DDE       pedit;
    HWND            hwndPost;
    BOOL            bDoc;
{
    UINT    asyncCmd;
    BOOL    bBusy;

    if (pedit->hServer != hwndPost){
        DEBUG_OUT ("Got terminate for extra conversation",0)
        if (--pedit->extraTerm == 0 && pedit->bTerminating)
            ScheduleAsyncCmd (lpobj);
        return;

    }

    if (!pedit->bTerminating){

        // If we are waiting for any ack, then goto next step with error

        // delete any data if we were in busy mode.
        bBusy = DeleteBusyData (lpobj, pedit);

        asyncCmd = lpobj->asyncCmd;
        PostMessageToServer(pedit, WM_DDE_TERMINATE, 0);
        pedit->hServer = NULL;
        if (pedit->awaitAck || bBusy) {
            // Set error and goto next step.
            lpobj->subErr = OLE_ERROR_COMM;
            pedit->awaitAck = 0;
            ScheduleAsyncCmd (lpobj);
        }

        // If the command is delete, do not delete
        // the edit blocks. It will be deleted
        // in the OleLnkDelete routine and for delete it is
        // possible that by the time we come here, the object
        // may not exist at all.

        if (asyncCmd != OLE_DELETE){
            // QueryOpen() is done because excel is sending WM_DDE_TERMINATE
            // for system without sending for doc in case of failure.

            if (bDoc || QueryOpen (lpobj)) {
                // if the termination is for document and no async command
                // terminate the server conversation also.
                if ((asyncCmd == OLE_NONE) || (asyncCmd == OLE_REQUESTDATA)
                       || (asyncCmd == OLE_OTHER) || (asyncCmd == OLE_SETDATA)
                       || (asyncCmd == OLE_RUN) || (asyncCmd == OLE_SHOW)
                       || (asyncCmd == OLE_SETUPDATEOPTIONS)) {
                    if (lpobj->pDocEdit && lpobj->pDocEdit->awaitAck)
                        // we are waiting for an ack on Doc channel. So start
                        // the unlaunch process after we get the ack.
                        lpobj->bUnlaunchLater = TRUE;
                    else
                        CallEmbLnkDelete (lpobj);
                } else {
                    if (bDoc)
                        DeleteDocEdit (lpobj);

                }
            }else
                DeleteSrvrEdit (lpobj);

        }
    } else {
        pedit->hServer = NULL;
        if (pedit->extraTerm == 0)
            ScheduleAsyncCmd (lpobj);
    }
}





//  HandleAckInitMsg: Handles WM_DDE_ACKs received while in initiate state.  If
//  this is the first reply, save its window handle.  If multiple replies
//  are received, take the one with the prefered instance, if there is
//  one.  Keep a count of WM_DDE_TERMINATEs we send so that we don't shut
//  the window until we get all of the responses for  WM_DDE_TERMINATEs.

void INTERNAL HandleAckInitMsg (
    PEDIT_DDE      pedit,
    HWND           hserver
){

    Puts("HandleAckInitMsg");

    if (pedit->hServer){
        // just take the very first one. Direct post is OK
        PostMessage (hserver, WM_DDE_TERMINATE, (WPARAM)pedit->hClient, 0);
        ++pedit->extraTerm;
    } else
        pedit->hServer = hserver;

}


// HandleAck: returns 0 if <ack> is not positive, else non-0.  Should probably be
//  a macro.

BOOL INTERNAL HandleAck (
    LPOBJECT_LE     lpobj,
    PEDIT_DDE       pedit,
    WPARAM          wParam,
    LPARAM          lParam
){
    WORD    wStatus = GET_WM_DDE_ACK_STATUS(wParam,lParam);
    HANDLE  hData  = NULL;
    BOOL    retval = TRUE;

    UNREFERENCED_PARAMETER(wParam);

    // check for busy bit
    if ((wStatus & 0x4000) && ContextCallBack ((LPOLEOBJECT)lpobj, OLE_QUERY_RETRY)){
        // we got busy from the server. create a timer and wait for time out.

        // We do not need makeprocinstance since, DLLs are single insance, all
        // we need to do is export for this function.

        if ((pedit->wTimer = SetTimer (pedit->hClient, 1, 3000, NULL)))
            return TRUE;
    }

    // even if the client got terminate we have to go thru this path.

    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }

    if (pedit->awaitAck == AA_POKE)
        // We have to free the data first. Handleack can trigger
        // another Poke (like pokehostnames)
        FreePokeData (lpobj, pedit);

    if (pedit->awaitAck == AA_EXECUTE) {
        hData = GET_WM_DDE_EXECACK_HDATA(wParam,lParam);
        if (hData) GlobalFree (hData);
    } else {
        ATOM aItem = GET_WM_DDE_ACK_ITEM(wParam,lParam);

        ASSERT (CheckAtomValid(aItem),"Invalid atom in ACK")

        if (aItem)
            GlobalDeleteAtom (aItem);
    }

    if (!(wStatus & 0x8000)) {
        // error case. set the error
        DEBUG_OUT ("DDE ACK with failure", 0)

        if (lpobj->errHint){
            lpobj->subErr = lpobj->errHint;
            lpobj->errHint = OLE_OK;
        } else
            lpobj->subErr = OLE_ERROR_COMM;

        retval = FALSE;

        if (pedit->awaitAck == AA_ADVISE) {

#ifdef  ASSERT
        ASSERT (pedit->hopt, "failed advise, options block missing");
#endif
           GlobalFree (pedit->hopt);
        }
    }

    pedit->hopt = NULL;
    pedit->awaitAck = 0;
    ScheduleAsyncCmd (lpobj);
    return retval;
}

// HandleDataMsg: Called for WM_DDE_DATA message.  If data is from an
//  ADVISE-ON-CLOSE and this is there are no more outstanding
//  ADVISE-ON-CLOSE requests, close the document and end the
//  conversation.

void INTERNAL HandleDataMsg (
    LPOBJECT_LE     lpobj,
    HANDLE          hdata,
    ATOM            aItem
){
    DDEDATA         far *lpdata = NULL;
    BOOL            fAck;
    BOOL            fRelease;
    int             options;
    PEDIT_DDE       pedit;

    Puts("HandleDataMsg");

    if (ScanItemOptions (aItem, (int far *)&options) != OLE_OK) {
        DEBUG_OUT (FALSE, "Improper item options");
        return;
    }

    pedit = lpobj->pDocEdit;

    if (hdata) {
        if (!(lpdata = (DDEDATA FAR *) GlobalLock(hdata)))
            return;

        fAck = lpdata->fAckReq;
        fRelease = lpdata->fRelease;

        if (pedit->bTerminating) {
            DEBUG_OUT ("Got DDE_DATA in terminate sequence",0)
            fRelease = TRUE;
        }
        else {
            if ((OLECLIPFORMAT)lpdata->cfFormat == cfBinary && aItem == aStdDocName) {
                ChangeDocName (lpobj, (LPSTR)lpdata->Value);
            }
            else
                SetData (lpobj, hdata, options);


            // important that we post the acknowledge first. Otherwist the
            // messages are not in sync.

            if (fAck)
            {
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,POSITIVE_ACK,aItem);
                PostMessageToServer (pedit, WM_DDE_ACK, lparamNew);
            }
            else if (aItem)
                GlobalDeleteAtom (aItem);

            if ((lpdata->fResponse) && (pedit->awaitAck == AA_REQUEST)) {
                // we sent the request. So, schedule next step.
                pedit->awaitAck = 0;
                ScheduleAsyncCmd (lpobj);
            }
        }

        GlobalUnlock (hdata);
        if (fRelease)
            GlobalFree (hdata);
    }
    else {
        if (CanCallback (lpobj, options)) {
            if (options != OLE_CLOSED)
                ContextCallBack ((LPOLEOBJECT)lpobj, options);
            else
                lpobj->bSvrClosing = FALSE;

        }
    }

    // PREfix COM+ 27104
    // The call to ScheduleAsyncCmd above can cause EmbLnkDelete to be called.
    // In that case lpobj->pDocEdit has already been deleted, and we don't need
    // to start another EmbLinkDelete.
    if ((options == OLE_CLOSED) && (lpobj->pDocEdit)) {
        if ((lpobj->pDocEdit->nAdviseClose <= 2) && (lpobj->asyncCmd == OLE_NONE)) {
            InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH, EMBLNKDELETE);
            EmbLnkDelete (lpobj);
        }
    }
}


HANDLE  GetDDEDataHandle (
   DDEDATA far     *lpdata,
   UINT            cfFormat,
   HANDLE          hdata
){

    if (cfFormat == CF_METAFILEPICT) {
#ifdef _WIN64
        return (*(void* _unaligned*)lpdata->Value);
#else
        return LongToHandle(*(LONG*)lpdata->Value);
#endif
    }

    if (cfFormat == CF_BITMAP || cfFormat == CF_ENHMETAFILE)
         return LongToHandle(*(LONG*)lpdata->Value);

    if (cfFormat == CF_DIB)
        return GlobalReAlloc (LongToHandle(*(LONG*)lpdata->Value), 0L,
                    GMEM_MODIFY|GMEM_SHARE);

    return CopyData (((LPSTR)lpdata)+4, (DWORD)(GlobalSize (hdata) - 4));
}

// SetData: Given the DDEDATA structure from a WM_DDE_DATA message, set up the
//  appropriate data in lpobj.  If the native is in native format, add
//  that field, otherwise, if it is in picture format, ask the picture
//  to add it itself.

void INTERNAL SetData (
    LPOBJECT_LE     lpobj,
    HANDLE          hdata,
    int             options
){
    DDEDATA far     *lpdata   = NULL;
    OLESTATUS       retVal = OLE_ERROR_MEMORY;
    HANDLE          hdataDDE;

    Puts("SetData");

    if (!(lpdata = (DDEDATA far *) (GlobalLock (hdata))))
        goto errrtn;


    if (!(hdataDDE =  GetDDEDataHandle (lpdata, lpdata->cfFormat, hdata)))
        goto errrtn;

    if ((OLECLIPFORMAT)lpdata->cfFormat == cfNative) {
        retVal = (*lpobj->head.lpvtbl->ChangeData) ( (LPOLEOBJECT)lpobj,
                        hdataDDE,
                        lpobj->head.lpclient,
                        TRUE);  // use this data, don't copy

    }
    else if ((BOOL)lpdata->cfFormat && (lpdata->cfFormat == (int)GetPictType (lpobj))) {

            retVal = (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                        hdataDDE,
                        lpobj->head.lpclient,
                        lpdata->fRelease);

    } else {
        // case of extra data in the object.
        DeleteExtraData (lpobj);
        lpobj->cfExtra = lpdata->cfFormat;
        lpobj->hextraData = hdataDDE;
        goto end;
    }

    if (retVal == OLE_OK) {
        SetExtents (lpobj);
        if (CanCallback (lpobj, options)) {
            if (options == OLE_CLOSED) {
                ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CHANGED);
                ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CLOSED);
                lpobj->bSvrClosing = FALSE;
            }
            else
                ContextCallBack ((LPOLEOBJECT)lpobj, options);
        }
    }

end:
errrtn:
    if (lpdata)
        GlobalUnlock (hdata);

    return;
}


// SysStartConvDDE: Starts a system conversation.  Returns a handle to that
//  conversation, or NULL.

BOOL INTERNAL InitSrvrConv (
    LPOBJECT_LE     lpobj,
    HANDLE          hInst
){
    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;

    Puts("InitSrvrConv");

    if (!lpobj->hSysEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL))
            goto errRtn;

    } else {
        hedit  =  lpobj->hSysEdit;
        pedit =   lpobj->pSysEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if((pedit->hClient = CreateWindow ("OleSrvrWndClass", "",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL)
        goto errRtn;


    lpobj->hSysEdit     = hedit;
    lpobj->pSysEdit     = pedit;
    pedit->hInst        = hInst;
    pedit->awaitAck     = AA_INITIATE;

    SetWindowLongPtr (pedit->hClient, 0, (LONG_PTR)lpobj);
    SendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM)pedit->hClient,
             MAKELPARAM (lpobj->app, aOle));

    ASSERT (CheckAtomValid(aOle),"systopic invalid atom")

    pedit->awaitAck    = 0;
    if (pedit->hServer == NULL) {
        pedit->awaitAck    = AA_INITIATE;
        // Now try the System topic
        SendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM)pedit->hClient,
                 MAKELPARAM (lpobj->app, aSystem));

        ASSERT (CheckAtomValid(aSystem),"systopic invalid atom")

        pedit->awaitAck    = 0;
        if (pedit->hServer == NULL) {
            DEBUG_OUT ("Srver connection failed", 0);
            goto errRtn;
        }
    }

    // Put the long ptr handle in the object.
    return TRUE;

errRtn:

    if (pedit) {
        if (pedit->hClient)
            DestroyWindow (pedit->hClient);
        LocalUnlock (hedit);
    }

    if (hedit)
        LocalFree (hedit);

    lpobj->hSysEdit     = NULL;
    lpobj->pSysEdit    = NULL;

    return FALSE;
}


// TermSrvrConv: Ends conversation indicated by hedit.
void INTERNAL TermSrvrConv (LPOBJECT_LE lpobj)
{
    PEDIT_DDE pedit;

    Puts("TermSrvrConv");


    if (!(pedit = lpobj->pSysEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)){
        lpobj->bAsync        = TRUE;
        pedit->bTerminating = TRUE;
    } else {
        pedit->bTerminating = FALSE;
        lpobj->subErr = OLE_ERROR_TERMINATE;
    }
    return;
}


void INTERNAL  DeleteAbortData (
   LPOBJECT_LE    lpobj,
   PEDIT_DDE     pedit
){
    UNREFERENCED_PARAMETER(lpobj);

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }
    return;


}

BOOL INTERNAL   DeleteBusyData (
    LPOBJECT_LE    lpobj,
    PEDIT_DDE     pedit
){
    UNREFERENCED_PARAMETER(lpobj);

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;

        if (pedit->hData) {
            GlobalFree (pedit->hData);
            pedit->hData = NULL;
        }

        if (pedit->hopt) {
            GlobalFree (pedit->hopt);
            pedit->hopt = NULL;
        }

        if (pedit->awaitAck && (HIWORD(pedit->lParam))) {
            if (pedit->awaitAck == AA_EXECUTE) {
		HANDLE hData = GET_WM_DDE_EXECACK_HDATA(pedit->wParam, pedit->lParam);
	        if (hData) GlobalFree (hData);
	    } else {
                ASSERT (CheckAtomValid(HIWORD(pedit->lParam)),
                    "Invalid atom in ACK")
                if (HIWORD(pedit->lParam))
                    GlobalDeleteAtom (HIWORD(pedit->lParam));
            }

            // we want to wipe out the HIWORD of lParam
            pedit->lParam &= 0x0000FFFF;
        }

        return TRUE;
    }

    return FALSE;
}

void INTERNAL   DeleteSrvrEdit (
   LPOBJECT_LE    lpobj
){

    PEDIT_DDE pedit;

    Puts("deleteSrvrEdit");

    if (!(pedit = lpobj->pSysEdit))
        return;


    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pSysEdit)
        LocalUnlock (lpobj->hSysEdit);

    if (lpobj->hSysEdit)
        LocalFree (lpobj->hSysEdit);

    lpobj->hSysEdit  = NULL;
    lpobj->pSysEdit = NULL;

    return;
}


void INTERNAL   SendStdExit (
   LPOBJECT_LE    lpobj
){


    Puts("SendSrvrExit");

    if (!lpobj->pSysEdit)
        return;

    SrvrExecute (lpobj, MapStrToH ("[StdExit]"));

}

void INTERNAL   SendStdClose (
    LPOBJECT_LE    lpobj
){


    Puts("SendDocClose");

    if (!lpobj->pDocEdit)
        return;

    DocExecute (lpobj, MapStrToH ("[StdCloseDocument]"));

}


// SrvrExecute: Sends execute command to system conversation.
BOOL INTERNAL SrvrExecute (
    LPOBJECT_LE lpobj,
    HANDLE      hdata
){
    PEDIT_DDE   pedit = NULL;
    int         retval = FALSE;

    Puts("SrvrExecute");

    pedit = lpobj->pSysEdit;

    if (hdata == NULL || pedit == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        return FALSE;
    }


    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }


    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, (LPARAM)hdata)) {
        // data is being freed in the acknowledge
        lpobj->bAsync    = TRUE;
        pedit->awaitAck = AA_EXECUTE;
        return TRUE;
    } else {
        lpobj->subErr = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}

// StartConvDDE: Starts the document conversation for an object based on
// .app and .topic atoms.
BOOL FARINTERNAL InitDocConv (
    LPOBJECT_LE lpobj,
    BOOL        fNetDlg
){

    // ### This routine looks very similar to IitSrvrConv
    // combine with the it

    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;
    char        buf[MAX_NET_NAME];
    int         nDrive = 2;     // drive C
    char        cOldDrive;

    Puts("InitDocConv");

    if (QueryOpen (lpobj)){
        DEBUG_OUT ("Attempt to start already existing conversation",0);
        return FALSE;
    }

    cOldDrive = lpobj->cDrive;
    if (CheckNetDrive (lpobj, fNetDlg) != OLE_OK)
        return FALSE;

    if (!lpobj->pDocEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL)){
            lpobj->subErr = OLE_ERROR_MEMORY;
            goto errRtn;
        }
    } else {
        hedit  =  lpobj->hDocEdit;
        pedit =  lpobj->pDocEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if ((pedit->hClient = CreateWindow ("OleDocWndClass", "Window Name",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        goto errRtn;
    }
    lpobj->hDocEdit     = hedit;
    lpobj->pDocEdit     = pedit;
    SetWindowLongPtr (pedit->hClient, 0, (LONG_PTR)lpobj);

    // buf will filled by netname in the first call to SetNextNetDrive()
    buf[0] = '\0';
    do {
        pedit->awaitAck = AA_INITIATE;

        // !!! Where are the atom counts bumped?

        SendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM)pedit->hClient,
                MAKELPARAM (lpobj->app, lpobj->topic));

        pedit->awaitAck = 0;

        if (pedit->hServer) {
            if ((cOldDrive != lpobj->cDrive)
                    && (lpobj->asyncCmd != OLE_CREATEFROMFILE))
                ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RENAMED);
            return TRUE;
        }

    } while ((lpobj->head.ctype == CT_LINK) && (lpobj->aNetName)
                && SetNextNetDrive (lpobj, &nDrive, buf)) ;

errRtn:
    if (cOldDrive != lpobj->cDrive) {
        // put back the old drive
        lpobj->cDrive = cOldDrive;
        ChangeTopic (lpobj);
    }

    if (pedit && pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (pedit)
        LocalUnlock (hedit);

    if (hedit)
        LocalFree (hedit);

    lpobj->hDocEdit     = NULL;
    lpobj->pDocEdit     = NULL;
    return FALSE;
}


// Execute: Sends an execute string WM_DDE_EXECUTE to the document conversation.
BOOL INTERNAL DocExecute(
    LPOBJECT_LE lpobj,
    HANDLE      hdata
){
    PEDIT_DDE   pedit;

    Puts("DocExecute");
    pedit = lpobj->pDocEdit;

    if (hdata == NULL || pedit == NULL)
        return FALSE;



    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }

    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, (LPARAM)hdata)) {
        // data is being freed in the execute command
        pedit->awaitAck    = AA_EXECUTE;
        lpobj->bAsync       = TRUE;
        return TRUE;
    } else {
        lpobj->subErr    = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}


// EndConvDDE: terminates the doc level conversation.
void INTERNAL TermDocConv (
    LPOBJECT_LE    lpobj
){
    PEDIT_DDE pedit;

    Puts ("TermDocConv");

    DEBUG_OUT ("About to terminate convs from destroy",0)

    if (!(pedit = lpobj->pDocEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)) {
        pedit->bTerminating = TRUE;
        lpobj->bAsync        = TRUE;
    } else
        lpobj->subErr = OLE_ERROR_TERMINATE;

    return;

}

// Deletes the document conversdation memory.
void INTERNAL DeleteDocEdit (lpobj)
LPOBJECT_LE    lpobj;
{

    PEDIT_DDE pedit;

    Puts ("DeleteDocEdit");

    if (!(pedit = lpobj->pDocEdit))
        return;

    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    // Delete if any data blocks.
    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pDocEdit)
        LocalUnlock (lpobj->hDocEdit);

    if (lpobj->hDocEdit)
        LocalFree (lpobj->hDocEdit);

    lpobj->hDocEdit  = NULL;
    lpobj->pDocEdit = NULL;

    return;
}


// LeLauchApp: Launches app based on the ClassName in lpobj.
// History:
// curts changed LoadModule calls to WinExec
//

HANDLE INTERNAL  LeLaunchApp (LPOBJECT_LE lpobj)
{
//    struct CMDSHOW
//    {
//        WORD first;
//        WORD second;
//    } cmdShow = {2, SW_SHOWNORMAL};
//
//    struct
//    {
//        WORD wEnvSeg;
//        LPSTR lpcmdline;
//        struct CMDSHOW FAR *lpCmdShow;
//        DWORD dwReserved;
//    } paramBlock;

    WORD    cmdShow = SW_SHOWNORMAL;
    char    cmdline[MAX_STR];
    char    exeName[MAX_STR];
    char    lpstr[2*MAX_STR];
    HANDLE  hInst;

    #define EMB_STR     " -Embedding "

    Puts("LeLaunchApp");

    if (!GlobalGetAtomName (lpobj->aServer, exeName, MAX_STR))
    {
        return NULL;
    }

    cmdline[0] = ' ';
    if (lpobj->bOldLink) {
        cmdShow = SW_SHOWMINIMIZED;
        if (!GlobalGetAtomName (lpobj->topic, cmdline + 1, MAX_STR - 1)) {
                 cmdline[1] = '\0';
        }
    } else {
        StringCchCopy ((LPSTR)cmdline+1, sizeof(cmdline)-1, (LPSTR) EMB_STR);

        // For all link servers we want to give the filename on the command
        // line. But Excel is not registering the document before returning
        // from WinMain, if it has auto load macros. So, we want send StdOpen
        // for the old servers, instead of giving the file name on the command
        // line.

        if (lpobj->bOleServer && (lpobj->fCmd & LN_MASK) == LN_LNKACT) {
            if (!GlobalGetAtomName (lpobj->topic, cmdline+sizeof(EMB_STR), MAX_STR-sizeof(EMB_STR)-1))
                cmdline[sizeof(EMB_STR)] = '\0';
        }
        if (lpobj->fCmd & ACT_MINIMIZE)
            cmdShow = SW_SHOWMINIMIZED;
        else if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB))
                    // we want to launch with show in create invisible case
                    // even though ACT_SHOW flag will be false
                    && ((lpobj->fCmd & LN_MASK) != LN_NEW))
            cmdShow = SW_HIDE;
    }

//    paramBlock.wEnvSeg      = NULL;
//    paramBlock.lpcmdline    = (LPSTR)cmdline;
//    paramBlock.lpCmdShow    = &cmdShow;
//    paramBlock.dwReserved   = NULL;

    if (FAILED(StringCchCopy(lpstr, sizeof(lpstr), exeName)))
        return NULL;
    if (FAILED(StringCchCat(lpstr, sizeof(lpstr), cmdline)))
        return NULL;

    if ((hInst =  (HANDLE)ULongToPtr(WinExec(lpstr, cmdShow))) < (HANDLE)32)
        hInst = NULL;

    if (!hInst) {
        LPSTR   lptmp;
        char    ch;

        // strip off the path and try again
        lptmp = (LPSTR)exeName;
        lptmp += lstrlen ((LPSTR) exeName);
        ch = *lptmp;
        while (ch != '\\' && ch != ':') {
            if (lptmp == (LPSTR) exeName) {
                // exe did not have path in it's name. we already tried
                // loading and it failed, no point trying again.
                return NULL;
            }
            else
                ch = *--lptmp;
        }

        if (FAILED(StringCchCopy(lpstr, sizeof(lpstr), ++lptmp)))
            return NULL;
        if (FAILED(StringCchCat(lpstr, sizeof(lpstr), cmdline)))
            return NULL;

        if ((hInst =  (HANDLE)ULongToPtr(WinExec(lpstr,cmdShow))) < (HANDLE)32)
            hInst = NULL;
    }

    return hInst;
}



//ScanItemOptions: Scan for the item options like Close/Save etc.

int INTERNAL ScanItemOptions (
   ATOM    aItem,
   int far *lpoptions
){

    ATOM    aModifier;

    LPSTR   lpbuf;
    char    buf[MAX_STR] = {0};

    *lpoptions = OLE_CHANGED;

    if (!aItem) {
        // NULL item with no modifier means OLE_CHANGED for NULL item
        return OLE_OK;
    }

    if(GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR) == 0)
    {
        return OLE_ERROR_SYNTAX;
    }
    lpbuf = (LPSTR)buf;

    while ( *lpbuf && *lpbuf != '/')
           lpbuf++;

    // no modifier same as /change

    if (*lpbuf == '\0')
        return OLE_OK;

    *lpbuf++ = '\0';        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknown modifier
    return OLE_ERROR_SYNTAX;

}

void   INTERNAL   ChangeDocName (
    LPOBJECT_LE lpobj,
    LPSTR       lpdata

){
    ATOM      aOldTopic;
    OLESTATUS retVal;

    aOldTopic = lpobj->topic;
    lpobj->topic = GlobalAddAtom (lpdata);
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        return;
        // !!! what should we do in case of error? Currently, we will not
        // change the topic if SetNetName fails.
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);

    // Delete the link data block
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RENAMED);



}


BOOL INTERNAL CanCallback (
    LPOBJECT_LE lpobj,
    int         options
){
    LPINT    lpCount;

    if (options == OLE_CLOSED) {
        lpobj->bSvrClosing = TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseClose);
    }
    else if (options == OLE_SAVED) {
        if (lpobj->head.ctype == CT_LINK)
            return TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseSave);
    }
    else {
        // it must be due to request
        if ((lpobj->pDocEdit->awaitAck == AA_REQUEST)
                && lpobj->pDocEdit->bCallLater)
            return FALSE;

        return TRUE;
    }

    switch (*lpCount) {
        case 1:
            break;

        case 2:
            ++(*lpCount);
            return FALSE;

        case 3:
            --(*lpCount);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


void  FARINTERNAL CallEmbLnkDelete (
    LPOBJECT_LE lpobj
){
    InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH,EMBLNKDELETE);
    EmbLnkDelete (lpobj);

    if (lpobj->head.ctype == CT_EMBEDDED) {
        lpobj->bSvrClosing = TRUE;
        ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CLOSED);
        if (FarCheckObject ((LPOLEOBJECT)lpobj))
            lpobj->bSvrClosing = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\ttunnel.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       ttunnel.cxx
//
//  Contents:   Utility for multi-thread tunnel tests
//
//  Codework:
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE    // This is the main module, trigger trkwks.hxx to do definitions

#include <trkwks.hxx>

typedef struct
{
    ULONG Vol;
    int file1;
    int file2;
} PARAMS;

class THREAD_FILE_NAME
{
public:
    THREAD_FILE_NAME(LPVOID pv)
    {
        PARAMS *params = (PARAMS*)pv;

        wsprintf(Name1, TEXT("%d"), params->file1);
        wsprintf(Name2, TEXT("%d"), params->file2);

        Vol = params->Vol;
    }

    TCHAR Name1[MAX_PATH];
    TCHAR Name2[MAX_PATH];

    ULONG Vol;
}; 

void
PrintThreadId()
{
    printf("[%d]", GetCurrentThreadId());
}

// dis app
// --- ---
// ren ren
// ren cre
// del cre
// del ren
//

void
CreateWithId( TCHAR * Name, CDomainRelativeObjId * pdroid )
{
    CDomainRelativeObjId droidBirth;

    HANDLE h = CreateFile(
        Name,
        GENERIC_READ|GENERIC_WRITE,
        0,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL );

    if (h!=INVALID_HANDLE_VALUE)
    {
        GetDroids(h, pdroid, &droidBirth, RGO_READ_OBJECTID);
        GetDroids(h, pdroid, &droidBirth, RGO_GET_OBJECTID);

        DelObjId( h );
        GetDroids(h, pdroid, &droidBirth, RGO_READ_OBJECTID);

        GetDroids(h, pdroid, &droidBirth, RGO_GET_OBJECTID);
        CloseHandle(h);
    }
}

void
OpenById(ULONG Vol, const CDomainRelativeObjId & droidCurrent)
{
    NTSTATUS Status;
    HANDLE h;

    Status = OpenFileById( Vol,
                droidCurrent.GetObjId(),
                SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                0,
                0,
                &h );
    if ( NT_SUCCESS(Status) )
    {
        CloseHandle(h);
    }
}

DWORD
WINAPI
RenRen( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("RenRen( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );
            OpenById( Names.Vol, droidCurrent );

        MoveFile( Names.Name1, Names.Name2 );

            OpenById( Names.Vol, droidCurrent );
    
        MoveFile( Names.Name2, Names.Name1 );

            OpenById( Names.Vol, droidCurrent );

        DeleteFile( Names.Name1 );
            OpenById( Names.Vol, droidCurrent );
    }
    return(0);
}

DWORD
WINAPI
RenCre( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("RenCre( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );
            OpenById( Names.Vol, droidCurrent );
    
        MoveFile( Names.Name1, Names.Name2 );

            OpenById( Names.Vol, droidCurrent );
    
        CreateWithId( Names.Name1, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );

        DeleteFile( Names.Name1 );
        DeleteFile( Names.Name2 );

            OpenById( Names.Vol, droidCurrent );

    }    
    return(0);
}

DWORD
WINAPI
DelCre( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("DelCre( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );
    
        DeleteFile( Names.Name1 );

            OpenById( Names.Vol, droidCurrent );
    
        CreateWithId( Names.Name1, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );

        DeleteFile( Names.Name1 );

            OpenById( Names.Vol, droidCurrent );

    }    
    return(0);
}

DWORD
WINAPI
DelRen( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("DelRen( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );
            OpenById( Names.Vol, droidCurrent );
    
        DeleteFile( Names.Name1 );

            OpenById( Names.Vol, droidCurrent );
    
        CreateWithId( Names.Name2, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );

        MoveFile( Names.Name2, Names.Name1 );

            OpenById( Names.Vol, droidCurrent );

    }    
    return(0);
}

LPTHREAD_START_ROUTINE pfn[8] = {
    RenRen,
    RenCre,
    DelRen,
    DelCre
};

#ifdef _UNICODE
EXTERN_C void __cdecl wmain( int argc, wchar_t **argv )
#else
void __cdecl main( int argc, char **argv )
#endif
{
    HRESULT hr = S_OK;
    NTSTATUS status = 0;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TTunnel" );


    // Convert the option to upper case (options are case-insensitive).

    __try
    {
        PARAMS params[24];

        TCHAR tszDir[MAX_PATH];

        GetCurrentDirectory( sizeof(tszDir)/sizeof(tszDir[0]), tszDir );
        CharUpper(tszDir);

        for (int i=0;i<24;i++)
        {
            DWORD dw;
            
            params[i].Vol = tszDir[0]-TEXT('A');

            if (i<8)
            {
                // 8 threads on two files
                params[i].file1 = 0;
                params[i].file2 = 1;
            }
            else
            if (i<16)
            {
                // 8 threads on 4 pairs of files
                params[i].file1 = i/2;  // 4 .. 7
                params[i].file2 = i/2+1; // 5 .. 8
            }
            else
            {
                // 8 threads on 8 pairs of files
                params[i].file1 = i+8;
                params[i].file2 = i+16;
            }

            if (i&1)
            {
                int s = params[i].file1;
                params[i].file1 = params[i].file2;
                params[i].file2 = s;
            }

            HANDLE h = CreateThread(0,NULL,pfn[i%4],&params[i],0,&dw);
            if (h)
            {
                CloseHandle(h);
            }
        }
        Sleep(INFINITE);
    }

    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
        printf( "HR = %08X\n", hr );

    return;

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\checkptr.c ===
/* CheckPtr.c
   Pointer validation routine
   Written by t-jasonf.
*/

#include "windows.h"
#include "dll.h"


/* CheckPointer()
   Parameters : 
      LPVOID lp         - pointer to check
      int    nREADWRITE - READ_ACCESS or WRITE_ACCESS
   Returns:
      0 if process does not have that kind of access to memory at lp.
      1 if process does have access.
*/
int CheckPointer (void *lp, int nReadWrite)
{
   char ch;
   int iRet;

   try
   {
      switch (nReadWrite)
      {
         case READ_ACCESS:
            ch = *((volatile char *)lp);
            break;
         case WRITE_ACCESS:
            ch = *((volatile char *)lp);
            *((volatile char *)lp) = ch;
            break;
      }
      iRet = 1;
   }
   except ( /*
            GetExceptionCode == STATUS_ACCESS_VIOLATION 
            ? EXCEPTION_EXECUTE_HANDLER
            : EXCEPTION_CONTINUE_SEARCH
            */
            EXCEPTION_EXECUTE_HANDLER
          )
   {
      iRet = 0;
   }

   return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\dib.c ===
/****************************** Module Header ******************************\
* Module Name: DIB.C
*
* Handles all API routines for the device independent bitmap sub-dll of
* the ole dll.
*
* Created: Oct-1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik, Raor  (../../1990,91)   Designed, coded
*   curts created portable version for win16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

void FARINTERNAL DibGetExtents (LPSTR, LPPOINT);

OLEOBJECTVTBL    vtblDIB  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        DibRelease,         // Release
        ErrShow,            // Show
        ErrPlay,            // show
        DibGetData,         // Get the object data
        ErrSetData,         // Set the object data
        ErrSetTargetDevice, //

        ErrSetBounds,       // set viewport bounds
        DibEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        DibRelease,         // delete
        ErrSetHostNames,    //

        DibSaveToStream,    // write to file
        DibClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Lnk

        DibEqual,           // compares the given objects for data equality

        DibCopy,            // copy to clip

        DibDraw,            // draw the object

        ErrActivate,        // open
        ErrExecute,         // excute
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name

        ObjQueryType,      // Object type
        DibQueryBounds,    // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current

        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        DibChangeData        // change data of the existing object
};



OLESTATUS  FARINTERNAL DibRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;
    HOBJECT hobj;

    if (lpobj->hDIB){
        GlobalFree (lpobj->hDIB);
        lpobj->hDIB = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);

    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL DibSaveToStream (
    LPOLEOBJECT  lpoleobj,
    LPOLESTREAM  lpstream
){
    DWORD        dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_DIB lpobj     = (LPOBJECT_DIB)lpoleobj;
    LPSTR        lpDIBbuf;

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen (lpstream, (LPSTR)"DIB"))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    lpobj->sizeBytes = (DWORD)GlobalSize (lpobj->hDIB);
    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (!(lpDIBbuf = GlobalLock (lpobj->hDIB)))
        return OLE_ERROR_MEMORY;

    if (PutBytes (lpstream, lpDIBbuf, lpobj->sizeBytes))
        return OLE_ERROR_STREAM;

    GlobalUnlock (lpobj->hDIB);
    return OLE_OK;
}



OLESTATUS FARINTERNAL  DibClone (
    LPOLEOBJECT         lpoleobjsrc,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){
    LPOBJECT_DIB lpobjsrc = (LPOBJECT_DIB)lpoleobjsrc;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(*lplpoleobj = (LPOLEOBJECT)DibCreateObject (lpobjsrc->hDIB, lpclient,
                            FALSE, lhclientdoc, (LPSTR)lpobjname,
                            lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}



OLESTATUS FARINTERNAL  DibEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_DIB lpobj1 = (LPOBJECT_DIB)lpoleobj1;
    LPOBJECT_DIB lpobj2 = (LPOBJECT_DIB)lpoleobj2;

    if (CmpGlobals (lpobj1->hDIB, lpobj1->hDIB))
        return OLE_OK;

    return OLE_ERROR_NOT_EQUAL;
}


OLESTATUS FARINTERNAL DibCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;
    HANDLE       hDIB;

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    if (!(hDIB = DuplicateGlobal (lpobj->hDIB, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    SetClipboardData (CF_DIB, hDIB);
    return OLE_OK;
}


OLESTATUS FARINTERNAL DibQueryBounds (
    LPOLEOBJECT  lpoleobj,
    LPRECT       lpRc
){
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;

    Puts("DibQueryBounds");

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    lpRc->left     = 0;
    lpRc->top      = 0;
    lpRc->right    = (int) lpobj->head.cx;
    lpRc->bottom   = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL DibEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;

    if (!cfFormat)
        return CF_DIB;

    return 0;
}


OLESTATUS FARINTERNAL DibGetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    LPHANDLE      lphandle
){
    LPOBJECT_DIB  lpobj = (LPOBJECT_DIB)lpoleobj;

    if (cfFormat != CF_DIB)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hDIB))
        return OLE_ERROR_BLANK;

    return OLE_OK;
}



LPOBJECT_DIB FARINTERNAL DibCreateObject (
    HANDLE      hDIB,
    LPOLECLIENT lpclient,
    BOOL        fDelete,
    LHCLIENTDOC lhclientdoc,
    LPCSTR      lpobjname,
    LONG        objType
){
    LPOBJECT_DIB    lpobj;

    if (lpobj = DibCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (DibChangeData ((LPOLEOBJECT)lpobj, hDIB, lpclient, fDelete) != OLE_OK) {
            DibRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}



// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewDIB will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL DibChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hNewDIB,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_DIB        lpobj = (LPOBJECT_DIB)lpoleobj;
    BITMAPINFOHEADER    bi;
    DWORD               dwSize;
    LPBITMAPINFOHEADER  lpBi;

    if (!hNewDIB)
        return OLE_ERROR_BLANK;

    lpBi = (LPBITMAPINFOHEADER) &bi;
    if (!fDelete) {
        if (!(hNewDIB = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself

        HANDLE htmp;

        if (!(htmp = GlobalReAlloc (hNewDIB, 0L, GMEM_MODIFY|GMEM_SHARE))) {
            htmp = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE);
            GlobalFree (hNewDIB);
            if (!htmp)
                return OLE_ERROR_MEMORY;
        }

        hNewDIB = htmp;
    }

    if (!(lpBi = (LPBITMAPINFOHEADER) GlobalLock (hNewDIB))) {
        GlobalFree (hNewDIB);
        return OLE_ERROR_MEMORY;
    }

    dwSize = (DWORD)GlobalSize (hNewDIB);
    if (lpobj->hDIB)
        GlobalFree (lpobj->hDIB);
    DibUpdateStruct (lpobj, lpclient, hNewDIB, lpBi, dwSize);
    return OLE_OK;
}


void INTERNAL DibUpdateStruct (
    LPOBJECT_DIB        lpobj,
    LPOLECLIENT         lpclient,
    HANDLE              hDIB,
    LPBITMAPINFOHEADER  lpBi,
    DWORD               dwBytes
){
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->sizeBytes = dwBytes;

#ifdef OLD
    lpobj->xSize = point.x = (int) lpBi->biWidth;
    lpobj->ySize = point.y = (int) lpBi->biHeight;
    ConvertToHimetric (&point);
#else
    DibGetExtents ((LPSTR) lpBi, &point);
#endif

    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->hDIB = hDIB;
}



OLESTATUS FARINTERNAL DibLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    LPOBJECT_DIB lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = DibCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto errLoad;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        goto errLoad;

    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto errLoad;

     if (DibStreamRead (lpstream, lpobj)) {
         *lplpoleobject = (LPOLEOBJECT) lpobj;
         return OLE_OK;
    }

errLoad:
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



LPOBJECT_DIB FARINTERNAL DibCreateBlank (
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType
){
    HOBJECT hobj;
    LPOBJECT_DIB lpobj;

    if((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_DIB)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_DIB) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    // The structure is ZERO initialized at allocation time. So only the
    // fields that need to be filled with values other than ZEROS are
    // initialized below

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblDIB;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}




BOOL INTERNAL DibStreamRead (
    LPOLESTREAM     lpstream,
    LPOBJECT_DIB    lpobj
){
    HANDLE              hDIBbuf;
    LPSTR               lpDIBbuf;
    BOOL                retVal = FALSE;
    BITMAPINFOHEADER    bi;

    if (GetBytes (lpstream, (LPSTR) &bi, sizeof(bi)))
        return FALSE;

    if (hDIBbuf = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpDIBbuf = (LPSTR)GlobalLock (hDIBbuf)){
            *((LPBITMAPINFOHEADER) lpDIBbuf) = bi;
            if (!GetBytes (lpstream, lpDIBbuf+sizeof(bi),
                     (lpobj->sizeBytes - sizeof(bi)))) {

                lpobj->hDIB = hDIBbuf;
#ifdef OLD
                //!!! this info should be part of the stream
                if (!lpobj->head.cx) {
                    DibGetExtents ((LPSTR) lpDIBbuf, &point);
                    lpobj->head.cx = (LONG) point.x;
                    lpobj->head.cy = (LONG) point.y;
                }
#endif
                retVal = TRUE;
            }
            GlobalUnlock(hDIBbuf);
        }
        //* Hang on to the memory allocated for the DIB
    }
    return  retVal;
}


OLESTATUS FARINTERNAL DibPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HANDLE     hDIB;

    if ((hDIB = GetClipboardData (CF_DIB)) == NULL)
        return  OLE_ERROR_MEMORY;

    *lplpoleobject = (LPOLEOBJECT) DibCreateObject (hDIB, lpclient, FALSE,
                                        lhclientdoc, lpobjname, objType);

    return OLE_OK;

}


void FARINTERNAL DibGetExtents (
    LPSTR   lpData,
    LPPOINT lpPoint
){
    #define HIMET_PER_METER     100000L  // number of HIMETRIC units / meter

    LPBITMAPINFOHEADER  lpbmi;

    lpbmi = (LPBITMAPINFOHEADER)lpData;

    if (!(lpbmi->biXPelsPerMeter && lpbmi->biYPelsPerMeter)) {
        HDC hdc;

        if (hdc = GetDC (NULL)){
            lpbmi->biXPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSX),
                                    10000, 254);
            lpbmi->biYPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSY),
                                    10000, 254);
        ReleaseDC (NULL, hdc);
        } else {
            //1000x1000 pixel coordinate system to avoid mod by 0
            lpbmi->biXPelsPerMeter = 1000;
            lpbmi->biYPelsPerMeter = 1000;
        }
    }

    lpPoint->x = (int) (lpbmi->biWidth * HIMET_PER_METER
                            / lpbmi->biXPelsPerMeter);
    lpPoint->y = -(int) (lpbmi->biHeight * HIMET_PER_METER
                            / lpbmi->biYPelsPerMeter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\bm.c ===
/****************************** Module Header ******************************\
* Module Name: BM.C
*
* Handles all API routines for the bitmap sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor,Srinik  (../../1990,91)    Designed, coded
*   Curts create NT version
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

extern int   maxPixelsX, maxPixelsY;
void INTERNAL GetHimetricUnits(HBITMAP, LPPOINT);


OLEOBJECTVTBL    vtblBM  = {

        ErrQueryProtocol,  // check whether the speced protocol is supported

        BmRelease,         // Release
        ErrShow,           // Show
        ErrPlay,           // play
        BmGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//

        ErrSetBounds,      // set viewport bounds
        BmEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //
        BmRelease,         // delete
        ErrSetHostNames,   //

        BmSaveToStream,    // write to file
        BmClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Link

        BmEqual,           // compares the given objects for data equality

        BmCopy,            // copy to clip

        BmDraw,            // draw the object

        ErrActivate,       // open
        ErrExecute,        // excute
        ErrClose,          // Stop
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type

        ErrGetUpdateOptions,// update options
        ErrSetUpdateOptions,// update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name

        ObjQueryType,      // Object type
        BmQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current

        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        BmChangeData        // change data of the existing object
};

OLESTATUS  FARINTERNAL BmRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    HOBJECT     hobj;

    if (lpobj->hBitmap) {
        DeleteObject (lpobj->hBitmap);
        lpobj->hBitmap = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);

    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL BmSaveToStream (
    LPOLEOBJECT    lpoleobj,
    LPOLESTREAM    lpstream
){
    DWORD       dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_BM lpobj     = (LPOBJECT_BM)lpoleobj;
    DWORD       dwSize    = lpobj->sizeBytes - sizeof(BITMAP) + sizeof(WIN16BITMAP);

    if (!lpobj->hBitmap || !lpobj->sizeBytes)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"BITMAP"))
        return OLE_ERROR_STREAM;

    if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
            if (!PutBytes (lpstream, (LPSTR) &dwSize, sizeof(DWORD)))
            return BmStreamWrite (lpstream, lpobj);
    }
    return OLE_ERROR_STREAM;
}


OLESTATUS FARINTERNAL  BmClone (
    LPOLEOBJECT         lpoleobj,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){
    LPOBJECT_BM         lpobjsrc = (LPOBJECT_BM)lpoleobj;
    LPOBJECT_BM  FAR *  lplpobj  = (LPOBJECT_BM  FAR *)lplpoleobj;

    if (!CheckClientDoc ((LPCLIENTDOC)lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(*lplpobj = BmCreateObject (lpobjsrc->hBitmap, lpclient, FALSE,
                            lhclientdoc, lpobjname,
                            lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}


OLESTATUS FARINTERNAL  BmEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_BM lpobj1 = (LPOBJECT_BM)lpoleobj1;
    LPOBJECT_BM lpobj2 = (LPOBJECT_BM)lpoleobj2;
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    LPSTR       lpBits1 = NULL, lpBits2 = NULL;
    OLESTATUS   retVal;
    DWORD       dwBytes1, dwBytes2;


    if (lpobj1->sizeBytes != lpobj2->sizeBytes)
        return OLE_ERROR_NOT_EQUAL;

    retVal = OLE_ERROR_MEMORY;

    if (!(hBits1 = GlobalAlloc (GMEM_MOVEABLE, lpobj1->sizeBytes)))
        goto errEqual;

    if (!(lpBits1 = GlobalLock (hBits1)))
        goto errEqual;

    if (!(hBits2 = GlobalAlloc (GMEM_MOVEABLE, lpobj2->sizeBytes)))
        goto errEqual;

    if (!(lpBits2 = GlobalLock (hBits2)))
        goto errEqual;

    dwBytes1 = GetBitmapBits (lpobj1->hBitmap, lpobj1->sizeBytes, lpBits1);
    dwBytes2 = GetBitmapBits (lpobj2->hBitmap, lpobj2->sizeBytes, lpBits2);

    if (dwBytes1 != dwBytes2) {
        retVal = OLE_ERROR_NOT_EQUAL;
        goto errEqual;
    }

    // !!! UtilMemCmp has to be redone for >64k bitmaps
    if (UtilMemCmp (lpBits1, lpBits2, dwBytes1))
        retVal = OLE_ERROR_NOT_EQUAL;
    else
        retVal = OLE_OK;

errEqual:
    if (lpBits1)
        GlobalUnlock (hBits1);

    if (lpBits2)
        GlobalUnlock (hBits2);

    if (hBits1)
        GlobalFree (hBits1);

    if (hBits2)
        GlobalFree (hBits2);

    return retVal;
}



OLESTATUS FARINTERNAL BmCopy (
    LPOLEOBJECT lpoleobj
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    HBITMAP hBitmap;
    DWORD   size;

    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    if(!(hBitmap = BmDuplicate (lpobj->hBitmap, &size, NULL)))
        return OLE_ERROR_MEMORY;

    SetClipboardData(CF_BITMAP, hBitmap);
    return OLE_OK;
}


OLESTATUS FARINTERNAL BmQueryBounds (
    LPOLEOBJECT lpoleobj,
    LPRECT      lpRc
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;

    Puts("BmQueryBounds");

    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL BmEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;

    if (!cfFormat)
        return CF_BITMAP;

    return 0;
}



OLESTATUS FARINTERNAL BmGetData (
   LPOLEOBJECT     lpoleobj,
   OLECLIPFORMAT   cfFormat,
   LPHANDLE        lphandle
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;

    if (cfFormat != CF_BITMAP)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hBitmap))
        return OLE_ERROR_BLANK;
    return OLE_OK;

}




OLESTATUS FARINTERNAL BmLoadFromStream (
   LPOLESTREAM         lpstream,
   LPOLECLIENT         lpclient,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpoleobject,
   LONG                objType
){
    LPOBJECT_BM lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = BmCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
            if (!GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
            if (BmStreamRead (lpstream, lpobj)) {
                *lplpoleobject = (LPOLEOBJECT)lpobj;
                return OLE_OK;
            }
    }

    OleDelete ((LPOLEOBJECT)lpobj);
    return OLE_ERROR_STREAM;;
}



OLESTATUS INTERNAL BmStreamWrite (
   LPOLESTREAM     lpstream,
   LPOBJECT_BM     lpobj
){
    HANDLE      hBits;
    LPSTR       lpBits;
    int         retVal   = OLE_ERROR_STREAM;
    BITMAP      bm;
    DWORD       dwSize;

    dwSize = lpobj->sizeBytes - sizeof(BITMAP);

    if (hBits = GlobalAlloc (GMEM_MOVEABLE, dwSize)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (GetBitmapBits (lpobj->hBitmap, dwSize, lpBits)) {
                WIN16BITMAP w16bm;

                GetObject (lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm);
                ConvertBM32to16(&bm, &w16bm);

                if (!PutBytes (lpstream, (LPSTR) &w16bm, sizeof(WIN16BITMAP)))
                    if (!PutBytes (lpstream, (LPSTR) lpBits, dwSize))
                        retVal = OLE_OK;
            }
            GlobalUnlock(hBits);
        } else
            retVal = OLE_ERROR_MEMORY;
        GlobalFree(hBits);
    } else
        retVal = OLE_ERROR_MEMORY;

    return retVal;
}



BOOL INTERNAL BmStreamRead (
   LPOLESTREAM     lpstream,
   LPOBJECT_BM     lpobj
){
    HANDLE      hBits;
    LPSTR       lpBits;
    BOOL        retVal   = FALSE;
    BITMAP      bm;
    WIN16BITMAP w16bm;
    POINT       point;

    if (GetBytes (lpstream, (LPSTR)&w16bm, sizeof(WIN16BITMAP)))
        return FALSE;

    ConvertBM16to32(&w16bm,&bm);

    lpobj->sizeBytes -= sizeof(WIN16BITMAP) ;

    if (hBits = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (!GetBytes(lpstream, lpBits, lpobj->sizeBytes)) {
                if (lpobj->hBitmap = CreateBitmap (bm.bmWidth,
                                            bm.bmHeight,
                                            bm.bmPlanes,
                                            bm.bmBitsPixel,
                                            lpBits)) {
                    retVal = TRUE;
                    lpobj->xSize = point.x = bm.bmWidth;
                    lpobj->ySize = point.y = bm.bmHeight;

                    // size of (bitmap header + bits)
                    lpobj->sizeBytes += sizeof(BITMAP);

#ifdef OLD
                    // !!! We shouldn't do the conversion. The info should be
                    // part of the stream.
                    if (!lpobj->head.cx) {
                        ConvertToHimetric (&point);
                        lpobj->head.cx = (LONG) point.x;
                        lpobj->head.cy = (LONG) point.y;
                    }
#endif
                 }
             }
             GlobalUnlock(hBits);
        }
        GlobalFree(hBits);
    }
    return  retVal;
}


OLESTATUS FARINTERNAL BmPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HBITMAP     hBitmap;

    *lplpoleobject = NULL;

    if ((hBitmap = (HBITMAP) GetClipboardData(CF_BITMAP)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) BmCreateObject (hBitmap,
                                                lpclient, FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;

}


LPOBJECT_BM INTERNAL BmCreateObject (
    HBITMAP     hBitmap,
    LPOLECLIENT lpclient,
    BOOL        fDelete,
    LHCLIENTDOC lhclientdoc,
    LPCSTR      lpobjname,
    LONG        objType
){
    LPOBJECT_BM     lpobj;

    if (lpobj = BmCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (BmChangeData ((LPOLEOBJECT)lpobj, (HANDLE)hBitmap, lpclient, fDelete) != OLE_OK) {
            BmRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewBitmap will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL BmChangeData (
    LPOLEOBJECT lpoleobj,
    HANDLE      hNewBitmap,
    LPOLECLIENT lpclient,
    BOOL        fDelete
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    BITMAP      bm;
    DWORD       dwSize;
    HBITMAP     hOldBitmap;

    hOldBitmap = lpobj->hBitmap;

    if (!fDelete) {
        if (!(hNewBitmap = BmDuplicate (hNewBitmap, &dwSize, &bm)))
            return OLE_ERROR_MEMORY;
    }
    else {
        if (!GetObject (hNewBitmap, sizeof(BITMAP), (LPSTR) &bm)) {
            DeleteObject (hNewBitmap);
            return OLE_ERROR_MEMORY;
        }
//*add get bitmap bits
        dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
                 ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);
    }

    BmUpdateStruct (lpobj, lpclient, hNewBitmap, &bm, dwSize);
    if (hOldBitmap)
        DeleteObject (hOldBitmap);

    return OLE_OK;
}


void INTERNAL BmUpdateStruct (
   LPOBJECT_BM lpobj,
   LPOLECLIENT lpclient,
   HBITMAP     hBitmap,
   LPBITMAP    lpBm,
   DWORD       dwBytes
){
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->xSize = point.x = lpBm->bmWidth;
    lpobj->ySize = point.y = lpBm->bmHeight;
    GetHimetricUnits (hBitmap, &point);
    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->sizeBytes = dwBytes + sizeof(BITMAP);
    lpobj->hBitmap = hBitmap;
}

LPOBJECT_BM FARINTERNAL BmCreateBlank (
   LHCLIENTDOC lhclientdoc,
   LPSTR       lpobjname,
   LONG        objType
){
    HOBJECT hobj;
    LPOBJECT_BM lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_BM)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_BM) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblBM;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                    (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}



HBITMAP FARINTERNAL BmDuplicate (
    HBITMAP     hold,
    DWORD FAR * lpdwSize,
    LPBITMAP    lpBm
){
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;
    INT         iX,iY;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL)) {
        if (hnew) retVal = SetBitmapBits (hnew, dwSize, lpMem);
    }

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }
    *lpdwSize = dwSize;
    if (lpBm)
        *lpBm = bm;

    if (MGetBitmapDimension (hold,&iX,&iY))
        if (hnew) MSetBitmapDimension (hnew, iX, iY);

    return hnew;
}


void INTERNAL GetHimetricUnits(HBITMAP hBitmap, LPPOINT lpPoint)
{
    HDC     hdc;
    INT     iX,iY;

    MGetBitmapDimension (hBitmap,&iX,&iY);

    if (iX || iY) {
        lpPoint->x = 10 * iX;
        lpPoint->y = - (10 * iY);
        return;
    }

    // clip if it exceeds maxPixels. Note that we have a limitation of
    // 0x8FFF HIMETRIC units in OLE1.0

    if (lpPoint->x > maxPixelsX)
        lpPoint->x = maxPixelsX;

    if (lpPoint->y > maxPixelsY)
        lpPoint->y = maxPixelsY;

    if (hdc = GetDC (NULL)) {
        lpPoint->x = MulDiv (lpPoint->x, 2540,
                         GetDeviceCaps (hdc, LOGPIXELSX));
        lpPoint->y = - MulDiv (lpPoint->y, 2540,
                         GetDeviceCaps (hdc, LOGPIXELSY));
        ReleaseDC (NULL, hdc);
    }
    else {
        lpPoint->x = 0;
        lpPoint->y = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\dll.h ===
/****************************** Module Header ******************************\
* Module Name: dll.h
*
* PURPOSE: Private definitions file for ole.c
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*  curts created portable version for win16/32
*
\***************************************************************************/

#define  OLE_INTERNAL

#include    "port1632.h"
#include    "cmacs.h"
#include    "ole.h"

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// WIN16                                                                  //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#ifdef WIN16


#define PROBE_MODE(bProtMode) {\
        if (!bProtMode) \
            return OLE_ERROR_PROTECT_ONLY; \
}

extern  WORD FARINTERNAL FarCheckPointer (LPVOID, int);

extern  WORD            wWinVer;
extern  BOOL            bProtMode;
extern  BOOL            bWLO;

#define MAKE_DDE_LPARAM(x,y,z) MAKELONG(y,z)
#define UNREFERENCED_PARAMETER(p) (p)
#define WIN16METAFILEPICT     METAFILEPICT
#define LPWIN16METAFILEPICT   LPMETAFILEPICT
#define WIN16BITMAP           BITMAP
#define LPWIN16BITMAP         LPBITMAP

// Routines in OLE.ASM                                                     //

WORD    GetGDIds (DWORD);
WORD    IsMetaDC (HDC, WORD);
WORD    CheckPointer (LPVOID, int);

#endif

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// WIN32                                                                  //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#ifdef WIN32

typedef struct tagWIN16METAFILEPICT
{
    short   mm;
    short   xExt;
    short   yExt;
    WORD    hMF;
} WIN16METAFILEPICT ,FAR* LPWIN16METAFILEPICT;

#ifndef RC_INVOKED
#pragma pack(1)
typedef struct tagWIN16BITMAP
{
    short   bmType;
    short   bmWidth;
    short   bmHeight;
    short   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} WIN16BITMAP, FAR* LPWIN16BITMAP;
#pragma pack()      /* Resume normal packing */
#endif  /* !RC_INVOKED */

#define PROBE_MODE(bProtMode)

#define GET_WM_DDE_EXECUTE_LPARAM(hdataExec)    ((UINT)hdataExec)
#define MAKE_DDE_LPARAM(x,y,z) PackDDElParam((UINT)x,(UINT_PTR)y,(UINT_PTR)z)

#define FarCheckPointer CheckPointer
INT  CheckPointer (LPVOID, int);
#define FarInitAsyncCmd InitAsyncCmd

#endif

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines, Object methods table and Structures.                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


//#ifndef HUGE
//#define HUGE    huge
//#endif

/* file format types */

#define OS_WIN16    0x0000
#define OS_MAC      0x0001
#define OS_WIN32    0x0002


// Characteristics Type Field
#define CT_NULL     0L
#define CT_LINK     1L
#define CT_EMBEDDED 2L
#define CT_STATIC   3L
#define CT_OLDLINK  4L
#define CT_PICTURE  5L

#define OLE_NO          0   // for boolean query functions
#define OLE_YES         1   // for boolean query functions

#define MAX_STR         256
#define MAX_NET_NAME    MAX_STR
#define INVALID_INDEX   -1
#define MAX_ATOM        256

#define NUM_RENDER      4

#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_STATIC     ((LPSTR)"Static")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")

#define READ_ACCESS     0
#define WRITE_ACCESS    1

#define POPUP_NETDLG    1

#define PROBE_OLDLINK(lpobj){\
        if (lpobj->bOldLink)\
            return OLE_ERROR_OBJECT;\
}


#define PROBE_READ(lp){\
        if (!CheckPointer((LPVOID)(lp), READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer((LPVOID)(lp), WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}


#define FARPROBE_READ(lp){\
        if (!FarCheckPointer((LPVOID)(lp), READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define FARPROBE_WRITE(lp){\
        if (!FarCheckPointer((LPVOID)(lp), WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}


extern  OLECLIPFORMAT   cfBinary;
extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfLink;
extern  OLECLIPFORMAT   cfNative;

extern  ATOM            aStdHostNames;
extern  ATOM            aStdTargetDevice ;
extern  ATOM            aStdDocDimensions;
extern  ATOM            aStdDocName;
extern  ATOM            aStdColorScheme;
extern  ATOM            aNullArg;
extern  ATOM            aSave;
extern  ATOM            aChange;
extern  ATOM            aClose;
extern  ATOM            aPackage;

extern  HANDLE          hInstDLL;
extern  WORD            wReleaseVer;
extern  DWORD           dwVerFromFile;

// Used by QuerySize() API;
extern  DWORD           dwObjSize;

extern  OLESTREAM       dllStream;



typedef struct _OLEOBJECT { /*object */
    LPOLEOBJECTVTBL lpvtbl;
    char            objId[2];
    HOBJECT         hobj;
    LPOLECLIENT     lpclient;
    LONG            ctype;
    LONG            cx;
    LONG            cy;
    LONG            mm;
    int             iTable;        // Index into the dll table
    ATOM            aObjName;      //** Client
    LHCLIENTDOC     lhclientdoc;   //      Document
    LPOLEOBJECT     lpPrevObj;     //      related
    LPOLEOBJECT     lpNextObj;     //** fileds
    LPOLEOBJECT     lpParent;      // NULL for LE or Static objects.
} OBJECT;



typedef struct _CF_NAME_ATOM {
    char *  cfName;
    ATOM    cfAtom;
} CF_NAME_ATOM;

extern  CF_NAME_ATOM    cfNameAtom[];


/////////////////////////////////////////////////////////////////////////////
// METAFFILE object structures
/////////////////////////////////////////////////////////////////////////////

typedef struct _METADC {
    int     xMwo;
    int     yMwo;
    int     xMwe;
    int     yMwe;
    int     xre;
    int     yre;
    struct _METADC * pNext;
} METADC, *PMETADC;

typedef struct _METAINFO {
    METADC  headDc;
    int         xwo;
    int         ywo;
    int         xwe;
    int         ywe;
    int         xro;
    int         yro;
} METAINFO, *PMETAINFO;

typedef struct OBJECT_MF { /* object_mf */
    OBJECT          head;
    DWORD           sizeBytes;
    METAFILEPICT    mfp;
    HANDLE          hmfp;
    BOOL            fMetaDC;
    OLESTATUS       error;
    int             nRecord;
    PMETAINFO       pMetaInfo;
    PMETADC         pCurMdc;
} OBJECT_MF;

typedef OBJECT_MF  FAR * LPOBJECT_MF;


#ifdef WIN32
/////////////////////////////////////////////////////////////////////////////
// ENHMETAFILE structures
/////////////////////////////////////////////////////////////////////////////


typedef struct OBJECT_EMF {
    OBJECT          head;
    DWORD           sizeBytes;
    HENHMETAFILE    hemf;
    BOOL            fMetaDC;
    OLESTATUS       error;
    int             nRecord;
} OBJECT_EMF;

typedef OBJECT_EMF  FAR * LPOBJECT_EMF;

#endif

/////////////////////////////////////////////////////////////////////////////
// BITMAP object structure
/////////////////////////////////////////////////////////////////////////////

typedef struct
{
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;  // width in pixels
    int     ySize;  // height in pixels
    HBITMAP hBitmap;
} OBJECT_BM;

typedef OBJECT_BM FAR * LPOBJECT_BM;


// DIB object structures

typedef struct _OBJECT_DIB {
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;
    int     ySize;
    HANDLE  hDIB;
} OBJECT_DIB;

typedef OBJECT_DIB FAR * LPOBJECT_DIB;

//* GENERIC object structure

typedef struct
{
    OBJECT          head;
    OLECLIPFORMAT   cfFormat;
    ATOM            aClass;
    DWORD           sizeBytes;
    HANDLE          hData;
} OBJECT_GEN;

typedef OBJECT_GEN FAR * LPOBJECT_GEN;



typedef struct  _RENDER_ENTRY { /* dll_entry */
    LPSTR       lpClass;
    ATOM        aClass;
    OLESTATUS   (FARINTERNAL *Load) (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
} RENDER_ENTRY;


typedef struct _DLL_ENTRY {
    ATOM        aDll;     /* global atom for dll name with full path */
    HANDLE      hDll;     /* handle to the dll module */
    int         cObj;     /* count of objects, unload dll when this is 0 */
    OLESTATUS   (FAR PASCAL *Load) (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Clip) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

    OLESTATUS   (FAR PASCAL *Link) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromTemplate) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Create) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateLinkFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
    OLESTATUS   (FAR PASCAL *CreateInvisible) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

} DLL_ENTRY;


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in OLE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

BOOL      INTERNAL      CheckObject(LPOLEOBJECT);
BOOL      FARINTERNAL   FarCheckObject(LPOLEOBJECT);
OLESTATUS INTERNAL      LeQueryCreateFromClip (LPSTR, OLEOPT_RENDER, OLECLIPFORMAT, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DEFCREAT.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   DefLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   DefCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in PBHANDLR.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   PbLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   PbCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines common for le.c, ledde.c, dde.c, doc.c                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


// Constants for chekcing whether the instance is SrvrDLL instance.

#define   WW_LPTR           0       // ptr tosrvr/doc/item
#define   WW_LE             4       // signature
#define   WW_HANDLE         6       // instance handle

#define   WC_LE             0x4c45  // LE chars


// command flags
#define     ACT_SHOW        0x0001      // show the window
#define     ACT_ACTIVATE    0x0002      // activate
#define     ACT_DOVERB      0x0004      // Run the item
#define     ACT_ADVISE      0x0008      // advise for data
#define     ACT_REQUEST     0x0010      // request for data
#define     ACT_CLOSE       0x0020      // request for advise only on close
#define     ACT_UNLAUNCH    0x0040      // unload the server after all the
#define     ACT_TERMSRVR    0x0080      // terminate server
#define     ACT_TERMDOC     0x0100      // terminate document

#define     ACT_NATIVE      0x0200      // only for LNKed objects, if we
                                        // need native data.

#define     ACT_MINIMIZE    0x0400      // launch the app minimized

#define     ACT_NOLAUNCH    0x0800      // don't launch the server


#define     LN_TEMPLATE     0x0000       // create from template
#define     LN_NEW          0x1000       // create new
#define     LN_EMBACT       0x2000       // activate emb
#define     LN_LNKACT       0x3000       // activate link
#define     LN_MASK         0xf000       // launch mask
#define     LN_SHIFT        12            // shift count for LN_MASK

typedef struct _EDIT_DDE { /* edit_dde */
    HANDLE      hInst;
    int         extraTerm;
    HWND        hClient;
    HWND        hServer;
    BOOL        bTerminating;
    BOOL        bAbort;
    BOOL        bCallLater;     // used in request cases. if this is FALSE
                                // then OLE_CHANGED is sent to client
    int         awaitAck;
    HANDLE      hopt;           // Memory block I may have to free
    int         nAdviseClose;   // count of outstanding advises on closes
    int         nAdviseSave;    // count of outstanding advises on save
    HANDLE      hData;          // Poked data/ temp for holding the
                                // handle in DDE messages

                                // busy parameters
    LPARAM      lParam;         // lparam value in case we need to
                                // repost the message
    UINT        msg;            // busy repost message

    UINT_PTR    wTimer;         // timer id.
} EDIT_DDE;

typedef EDIT_DDE NEAR   *PEDIT_DDE;
typedef EDIT_DDE FAR    *LPEDIT_DDE;

typedef struct _OBJECT_LE { /* object_le */
    OBJECT          head;
    ATOM            app;
    ATOM            topic;
    ATOM            item;
    ATOM            aServer;
    BOOL            bOldLink;           // whether a linked object for old link
    BOOL            bOleServer;         // server which supports the verbs
    UINT            verb;               // verb nuymber;
    UINT            fCmd;               // Command flags;
    OLEOPT_UPDATE   optUpdate;
    OLEOPT_UPDATE   optNew;             // new update options
    LPSTR           lptemplate;         // ptr to the template string, if
                                        // create from template

    ATOM            aNetName;           // network name on which the doc is
    char            cDrive;             // local drive for that network
    DWORD           dwNetInfo;          // LOW WORD = Net type
                                        // HIGH WORD = Driver version

    LPOLEOBJECT     lpobjPict;

    LONG            lAppData;           // apps data
    LONG            lHandlerData;       // handler data

    HANDLE          hnative;
    HANDLE          hLink;
    HANDLE          hhostNames;         // host name block
    HANDLE          htargetDevice;      // target device info
    HANDLE          hdocDimensions;     // document dimensions
    HANDLE          hextraData;         // reqestdata handle
    UINT            cfExtra;            // extra format data
    HANDLE          hlogpal;          // logiccal palette


    UINT            oldasyncCmd;        // previous asynchronous command
    UINT            asyncCmd;           // asynchronous command
    BOOL            endAsync;           // true if we need to send END_RELEASE.
    BOOL            bAsync;             // true if async command on.
    UINT            mainRtn;            // main async routine
    UINT            subRtn;             // step within the main async routine
    UINT            mainErr;            // failure error
    UINT            subErr;             // step error
    UINT            errHint;            // ;error hint

    BOOL            bSvrClosing;        // TRUE - server in the process of
                                        // closing down
    BOOL            bUnlaunchLater;     // Call EmbLnkDelete from EndAsyncCmd
                                        // if this flag is TRUE

    HANDLE          hSysEdit;           // handle to system edit.
    PEDIT_DDE       pSysEdit;           // near ptr to system edit.
    HANDLE          hDocEdit;           // handle to doc level channel
    PEDIT_DDE       pDocEdit;           // near ptr to the doc level channel
    BOOL            bNewPict;

} OBJECT_LE;
typedef OBJECT_LE  FAR * LPOBJECT_LE;


typedef struct _CLIENTDOC { /* object_le */
    char                    docId[2];
    LPOLEOBJECT             lpHeadObj;
    LPOLEOBJECT             lpTailObj;
    ATOM                    aClass;
    ATOM                    aDoc;
    HANDLE                  hdoc;
    DWORD                   dwFileVer;
    struct _CLIENTDOC FAR * lpPrevDoc;
    struct _CLIENTDOC FAR * lpNextDoc;
} CLIENTDOC;
typedef CLIENTDOC  FAR * LPCLIENTDOC;


typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;

//
// BOUNDSRECT must be defined as the same size in both
// 16 and 32 bit versions.
//
typedef struct _BOUNDSRECT {
    USHORT    defaultWidth;
    USHORT    defaultHeight;
    USHORT    maxWidth;
    USHORT    maxHeight;
} BOUNDSRECT;

typedef BOUNDSRECT FAR *LPBOUNDSRECT;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Function pointer types                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
typedef OLESTATUS       (FAR PASCAL *_LOAD)                  (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CLIP)                  (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);
typedef OLESTATUS       (FAR PASCAL *_LINK)                  (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATEFROMTEMPLATE)    (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATE)                (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATEFROMFILE)        (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATELINKFROMFILE)    (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATEINVISIBLE)       (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


// AwaitAck values
#define AA_REQUEST  1
#define AA_ADVISE   2
#define AA_POKE     3
#define AA_EXECUTE  4
#define AA_UNADVISE 5
#define AA_INITIATE 6

// Bits for Positive WM_DDE_ACK
#define POSITIVE_ACK 0x8000



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LE.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPVOID      FARINTERNAL LeQueryProtocol (LPOLEOBJECT, OLE_LPCSTR);
OLESTATUS   FARINTERNAL LeRelease (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS   FARINTERNAL LeCopyFromLink (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS   FARINTERNAL LeEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeCopy (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS   FARINTERNAL LeDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLECLIPFORMAT   FARINTERNAL LeEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeGetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);
OLESTATUS   FARINTERNAL LeRequestData (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeQueryOutOfDate (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeObjectConvert (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS   FARINTERNAL LeChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
LPOBJECT_LE FARINTERNAL LeCreateBlank(LHCLIENTDOC, LPSTR, LONG);
void        FARINTERNAL SetExtents (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   FARINTERNAL LeLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS   INTERNAL    LeStreamRead (LPOLESTREAM, LPOBJECT_LE);
OLESTATUS   INTERNAL    LeStreamWrite (LPOLESTREAM, LPOBJECT_LE);
int         FARINTERNAL ContextCallBack (LPOLEOBJECT, OLE_NOTIFICATION);
void        INTERNAL    DeleteObjectAtoms (LPOBJECT_LE);
void        FARINTERNAL DeleteExtraData (LPOBJECT_LE);

OLESTATUS   FARINTERNAL LeGetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS   FARINTERNAL LnkPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL EmbPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
BOOL        INTERNAL    SetLink (LPOBJECT_LE, HANDLE, LPSTR FAR *);
HANDLE      INTERNAL    GetLink (LPOBJECT_LE);
void        FARINTERNAL SetEmbeddedTopic (LPOBJECT_LE);

OLESTATUS   FAR PASCAL  LeQueryReleaseStatus (LPOLEOBJECT);
OLESTATUS   FAR PASCAL  LeQueryReleaseError (LPOLEOBJECT);
OLE_RELEASE_METHOD FAR PASCAL LeQueryReleaseMethod (LPOLEOBJECT);

OLESTATUS   FARINTERNAL LeQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS   FARINTERNAL LeObjectLong (LPOLEOBJECT, UINT, LPLONG);


void SetNetDrive (LPOBJECT_LE);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LEDDE.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeDoVerb  (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS   FARINTERNAL LeShow (LPOLEOBJECT, BOOL);
OLESTATUS   FARINTERNAL LeQueryOpen (LPOLEOBJECT);
BOOL        INTERNAL    QueryOpen (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeActivate (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
OLESTATUS   FARINTERNAL LeUpdate (LPOLEOBJECT);
OLESTATUS   FARINTERNAL EmbOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL EmbUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL EmbOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL LnkUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeClose (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeReconnect (LPOLEOBJECT);
OLESTATUS   INTERNAL    PokeNativeData (LPOBJECT_LE);
BOOL        INTERNAL    PostMessageToServer (PEDIT_DDE, UINT, LPARAM);

OLESTATUS   FARINTERNAL LeCreateFromTemplate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreateInvisible (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

OLESTATUS   FARINTERNAL CreateFromClassOrTemplate (LPOLECLIENT, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, UINT, LPSTR, LHCLIENTDOC, LPSTR);

OLESTATUS   FARINTERNAL CreateEmbLnkFromFile (LPOLECLIENT, LPCSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS   FARINTERNAL LeSetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE);

void        INTERNAL    AdvisePict (LPOBJECT_LE, ATOM);
void        INTERNAL    UnAdvisePict (LPOBJECT_LE);
int         INTERNAL    GetPictType (LPOBJECT_LE);
void        INTERNAL    AdviseOn (LPOBJECT_LE, int, ATOM);
void        INTERNAL    UnAdviseOn (LPOBJECT_LE, int);
void        INTERNAL    RequestOn (LPOBJECT_LE, int);
void        INTERNAL    RequestPict (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetHostNames (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
OLESTATUS   INTERNAL    PokeHostNames (LPOBJECT_LE);
OLESTATUS   INTERNAL    SetHostNamesHandle (LPOBJECT_LE, LPSTR, LPSTR);
void        INTERNAL    FreePokeData (LPOBJECT_LE, PEDIT_DDE);
OLESTATUS   INTERNAL    SendPokeData (LPOBJECT_LE, ATOM, HANDLE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS   INTERNAL    PokeTargetDeviceInfo (LPOBJECT_LE);
OLESTATUS   INTERNAL    PokeDocDimensions (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);

OLESTATUS   FARINTERNAL LeSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
BOOL        INTERNAL SendSrvrMainCmd (LPOBJECT_LE, LPSTR);
ATOM        INTERNAL    ExtendAtom (LPOBJECT_LE, ATOM);
BOOL        INTERNAL    CreatePictObject (LHCLIENTDOC, LPSTR, LPOBJECT_LE, OLEOPT_RENDER, OLECLIPFORMAT, LPCSTR);
BOOL        INTERNAL    IsSrvrDLLwnd (HWND, HANDLE);
OLESTATUS   INTERNAL    ChangeDocAndItem (LPOBJECT_LE, HANDLE);
BOOL                    QueryUnlaunch (LPOBJECT_LE);
BOOL                    QueryClose (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS   INTERNAL    PokeColorScheme (LPOBJECT_LE);
OLESTATUS   FARINTERNAL ProbeAsync (LPOBJECT_LE);
BOOL        INTERNAL    IsServerValid (LPOBJECT_LE);
BOOL        INTERNAL    IsWindowValid (HWND);
OLESTATUS   FARINTERNAL LeExecute (LPOLEOBJECT, HANDLE, UINT);
void        INTERNAL    FreeGDIdata (HANDLE, OLECLIPFORMAT);
BOOL        INTERNAL    CanPutHandleInPokeBlock (LPOBJECT_LE, OLECLIPFORMAT);
BOOL        INTERNAL    ChangeEMFtoMF( LPOBJECT_LE );
BOOL        INTERNAL    ChangeEMFtoMFneeded(LPOBJECT_LE, ATOM );


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DDE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LRESULT     FARINTERNAL DocWndProc(HWND, UINT, WPARAM, LPARAM );
LRESULT     FARINTERNAL SrvrWndProc(HWND, UINT, WPARAM, LPARAM );
BOOL        INTERNAL    CheckAtomValid (ATOM);
void        INTERNAL    HandleAckInitMsg (PEDIT_DDE, HWND);
BOOL        INTERNAL    HandleAck (LPOBJECT_LE, PEDIT_DDE, WPARAM, LPARAM);
void        INTERNAL    HandleDataMsg (LPOBJECT_LE, HANDLE, ATOM);
void        INTERNAL    HandleTermMsg (LPOBJECT_LE, PEDIT_DDE, HWND, BOOL);
void        INTERNAL    HandleTimerMsg (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    SetData (LPOBJECT_LE, HANDLE, int);
BOOL        INTERNAL    DeleteBusyData (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    DeleteAbortData (LPOBJECT_LE, PEDIT_DDE);

BOOL        INTERNAL    WaitDDE (HWND, BOOL);
BOOL        INTERNAL    WaitDDEAck (PEDIT_DDE);

BOOL        INTERNAL    InitSrvrConv (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermSrvrConv (LPOBJECT_LE);
void        INTERNAL    DeleteSrvrEdit (LPOBJECT_LE);
BOOL        INTERNAL    SrvrExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    SendStdExit (LPOBJECT_LE);
void        INTERNAL    SendStdClose (LPOBJECT_LE);
void        INTERNAL    SendStdExit  (LPOBJECT_LE);

BOOL        FARINTERNAL InitDocConv (LPOBJECT_LE, BOOL);
BOOL        INTERNAL    DocExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermDocConv (LPOBJECT_LE);
void        INTERNAL    DeleteDocEdit (LPOBJECT_LE);

HANDLE      INTERNAL    LeLaunchApp (LPOBJECT_LE);
HANDLE      INTERNAL    LoadApp (LPSTR, UINT);

int         INTERNAL    ScanItemOptions (ATOM, int FAR *);
void        INTERNAL    ChangeDocName (LPOBJECT_LE, LPSTR);
BOOL        INTERNAL    CanCallback (LPOBJECT_LE, int);

void        FARINTERNAL CallEmbLnkDelete (LPOBJECT_LE);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Picture Object routines used by routines in other modules               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPOBJECT_BM  FARINTERNAL BmCreateBlank (LHCLIENTDOC, LPSTR, LONG);
OLESTATUS    FARINTERNAL BmLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL BmPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_DIB FARINTERNAL DibCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_DIB FARINTERNAL DibCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPCSTR, LONG);
OLESTATUS    FARINTERNAL DibLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL DibPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_MF  FARINTERNAL MfCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_MF  FARINTERNAL MfCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPCSTR, LONG);
OLESTATUS    FARINTERNAL MfLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL MfPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);

LPOBJECT_EMF  FARINTERNAL EmfCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_EMF  FARINTERNAL EmfCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPCSTR, LONG);
OLESTATUS    FARINTERNAL EmfLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL EmfPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);

LPOBJECT_GEN FARINTERNAL GenCreateBlank (LHCLIENTDOC, LPSTR, LONG, ATOM);
OLESTATUS    FARINTERNAL GenLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS    FARINTERNAL GenPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LPSTR, OLECLIPFORMAT, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MAIN.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

void    FARINTERNAL UnloadDll (void);
int     FARINTERNAL LoadDll (LPCSTR);
void    FARINTERNAL DecreaseHandlerObjCount (int);

void    FARINTERNAL RemoveLinkStringFromTopic (LPOBJECT_LE);

OLESTATUS FARINTERNAL CreatePictFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LPSTR, LONG);

OLESTATUS FARINTERNAL CreatePackageFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in UTILS.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        PutStrWithLen (LPOLESTREAM, LPSTR);
BOOL        GetStrWithLen (LPOLESTREAM, LPSTR);
ATOM        GetAtomFromStream (LPOLESTREAM);
BOOL        PutAtomIntoStream (LPOLESTREAM, ATOM);
BOOL        GetBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        PutBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        QueryApp (LPCSTR, LPCSTR, LPSTR);
HANDLE      MapStrToH (LPSTR);
void        UtilMemClr (PSTR, UINT);
BOOL        QueryHandler (UINT);

OLESTATUS INTERNAL      FileExists (LPOBJECT_LE);
ATOM      FARINTERNAL   GetAppAtom (LPCSTR);
HANDLE    FARINTERNAL   DuplicateGlobal (HANDLE, UINT);
HANDLE    FARINTERNAL   CopyData (LPSTR, DWORD);
ATOM      FARINTERNAL   DuplicateAtom (ATOM);
BOOL      FARINTERNAL   UtilQueryProtocol (LPOBJECT_LE, OLE_LPCSTR);
BOOL      FARINTERNAL   CmpGlobals (HANDLE, HANDLE);
void      FARINTERNAL   ConvertToHimetric(LPPOINT);
BOOL      FARINTERNAL   QueryVerb (LPOBJECT_LE, UINT, LPSTR, LONG);
BOOL      FARINTERNAL   MapExtToClass (LPSTR, LPSTR, int);
int       FARINTERNAL   GlobalGetAtomLen (ATOM);
void      FARINTERNAL   UtilMemCpy (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   UtilMemCmp (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   IsObjectBlank (LPOBJECT_LE);

OLESTATUS FARINTERNAL   ObjQueryName (LPOLEOBJECT, LPSTR, UINT FAR *);
OLESTATUS FARINTERNAL   ObjRename (LPOLEOBJECT, OLE_LPCSTR);
void      INTERNAL      SetExeAtom (LPOBJECT_LE);
BOOL      INTERNAL      OleIsDcMeta (HDC hdc);
void      INTERNAL      ConvertMF32to16(LPMETAFILEPICT, LPWIN16METAFILEPICT);
void      INTERNAL      ConvertMF16to32(LPWIN16METAFILEPICT, LPMETAFILEPICT);
void      INTERNAL      ConvertBM32to16(LPBITMAP, LPWIN16BITMAP);
void      INTERNAL      ConvertBM16to32(LPWIN16BITMAP, LPBITMAP);
DWORD     INTERNAL      GetFileVersion(LPOLEOBJECT);


// !!!make a routine and let the macro call the routine
// definitions related to the asynchronous operations.
#define WAIT_FOR_ASYNC_MSG(lpobj) {  \
    lpobj->subRtn++;                 \
    if (lpobj->bAsync){              \
        lpobj->endAsync = TRUE;      \
        return OLE_WAIT_FOR_RELEASE; \
    }                                \
}

#define STEP_NOP(lpobj)     lpobj->subRtn++;

// !!! Assumes all the creates are in order
#define PROBE_CREATE_ASYNC(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEINVISIBLE) {\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;\
    }

#define PROBE_OBJECT_BLANK(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEFROMFILE) { \
        if ((ProbeAsync(lpobj) == OLE_BUSY) && IsObjectBlank(lpobj)) \
            return OLE_ERROR_BLANK;\
    }

#define PROBE_ASYNC(lpobj)\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;

#define IS_SVRCLOSING(lpobj)\
        ((lpobj->bUnlaunchLater || lpobj->bSvrClosing) ? TRUE : FALSE)

#define PROBE_SVRCLOSING(lpobj)\
        if (IS_SVRCLOSING(lpobj)) \
            return OLE_ERROR_NOT_OPEN; \


#define CLEAR_STEP_ERROR(lpobj) lpobj->subErr = OLE_OK;


#define   SKIP_TO(a, b)    if (a) goto b;
#define   RESETERR(lpobj)  lpobj->mainErr = OLE_OK
#define   SETSTEP(lpobj, no)  lpobj->subRtn = no
#define   SETERRHINT(lpobj, no) lpobj->errHint = no
#define   CLEARASYNCCMD(lpobj)  lpobj->asyncCmd = OLE_NONE



// routines.
BOOL        ProcessErr          (LPOBJECT_LE);
void        InitAsyncCmd        (LPOBJECT_LE, UINT, UINT);
void        NextAsyncCmd        (LPOBJECT_LE, UINT);
void        ScheduleAsyncCmd    (LPOBJECT_LE);
OLESTATUS   EndAsyncCmd         (LPOBJECT_LE);
OLESTATUS   DocShow             (LPOBJECT_LE);
OLESTATUS   DocRun              (LPOBJECT_LE);
void        SendStdShow         (LPOBJECT_LE);
OLESTATUS   EmbLnkClose         (LPOBJECT_LE);
OLESTATUS   LnkSetUpdateOptions (LPOBJECT_LE);
OLESTATUS   EmbSrvrUnlaunch     (LPOBJECT_LE);
OLESTATUS   LnkChangeLnk        (LPOBJECT_LE);
OLESTATUS   RequestData         (LPOBJECT_LE, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL EmbLnkDelete(LPOBJECT_LE);

void FARINTERNAL FarInitAsyncCmd(LPOBJECT_LE, UINT, UINT);

// async command routines.
#define  EMBLNKDELETE           1
#define  LNKOPENUPDATE          2
#define  DOCSHOW                3
#define  EMBOPENUPDATE          4
#define  EMBLNKCLOSE            5
#define  LNKSETUPDATEOPTIONS    6
#define  LNKCHANGELNK           7
#define  REQUESTDATA            8
#define  DOCRUN                 9

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DOC.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        FARINTERNAL     CheckClientDoc (LPCLIENTDOC);
void        FARINTERNAL     DocAddObject (LPCLIENTDOC, LPOLEOBJECT, LPCSTR);
void        FARINTERNAL     DocDeleteObject (LPOLEOBJECT);
LPOLEOBJECT INTERNAL        DocGetNextObject (LPCLIENTDOC, LPOLEOBJECT);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in NET.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define     IDD_DRIVE       500
#define     IDD_PASSWORD    501
#define     IDD_PATH        502

#define     IDS_NETERR          600
#define     IDS_NETCONERRMSG    601
#define     IDS_FILENOTFOUNDMSG 602
#define     IDS_BADPATHMSG      603

OLESTATUS   FARINTERNAL SetNetName (LPOBJECT_LE);
BOOL        FARINTERNAL SetNextNetDrive (LPOBJECT_LE, int FAR *, LPSTR);
OLESTATUS   FARINTERNAL CheckNetDrive (LPOBJECT_LE, BOOL);
OLESTATUS   INTERNAL    FixNet (LPOBJECT_LE, LPSTR, BOOL);
OLESTATUS   INTERNAL    ConnectNet (LPOBJECT_LE, LPSTR);
BOOL        FARINTERNAL ChangeTopic (LPOBJECT_LE);
VOID        INTERNAL    FillDrives (HWND);
INT_PTR     FAR PASCAL  ConnectDlgProc(HWND, UINT, WPARAM, LPARAM);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL   ObjQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL   ObjQuerySize (LPOLEOBJECT, DWORD FAR *);
DWORD     PASCAL FAR    DllPut (LPOLESTREAM, OLE_CONST void FAR*, DWORD);
HANDLE    FARINTERNAL   DuplicateGDIdata (HANDLE, OLECLIPFORMAT);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

HBITMAP   FARINTERNAL   BmDuplicate (HBITMAP, DWORD FAR *, LPBITMAP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\doc.c ===
/****************************** Module Header ******************************\
* Module Name: doc.c
*
* PURPOSE: Contains client document maipulation routines.
*
* Created: Jan 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  01/11/1191  Orginal
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"


LPCLIENTDOC lpHeadDoc = NULL;
LPCLIENTDOC lpTailDoc  = NULL;

extern ATOM aClipDoc;
extern int  iUnloadableDll;

OLESTATUS FAR PASCAL OleRegisterClientDoc(
    LPCSTR               lpClassName,
    LPCSTR               lpDocName,
    LONG                future,
    LHCLIENTDOC FAR *   lplhclientdoc
){
    HANDLE      hdoc = NULL;
    LPCLIENTDOC lpdoc;
    OLESTATUS   retVal;
    ATOM        aClass, aDoc;

    UNREFERENCED_PARAMETER(future);


    Puts ("OleRegisterClientDoc");

    PROBE_MODE(bProtMode);
    FARPROBE_WRITE(lplhclientdoc);
    *lplhclientdoc = 0;
    FARPROBE_READ(lpClassName);
    FARPROBE_READ(lpDocName);
    if (!lpDocName[0])
        return OLE_ERROR_NAME;

    aDoc = GlobalAddAtom (lpDocName);
    aClass = GlobalAddAtom (lpClassName);

    if (!(hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE,
                        sizeof(CLIENTDOC)))
            || !(lpdoc = (LPCLIENTDOC) GlobalLock (hdoc))) {
        retVal =  OLE_ERROR_MEMORY;
        goto err;
    }

    lpdoc->docId[0] = 'C';
    lpdoc->docId[1] = 'D';
    lpdoc->aClass   = aClass;
    lpdoc->aDoc     = aDoc;
    lpdoc->hdoc     = hdoc;
    lpdoc->dwFileVer= (DWORD)MAKELONG(wReleaseVer,OS_WIN16);

    // Documents are doubly linked

    if (!lpHeadDoc) {
        lpHeadDoc = lpTailDoc = lpdoc;
    }
    else {
        lpTailDoc->lpNextDoc = lpdoc;
        lpdoc->lpPrevDoc = lpTailDoc;
        lpTailDoc = lpdoc;
    }

    *lplhclientdoc = (LHCLIENTDOC) lpdoc;

    // inform the link manager;
    return OLE_OK;

err:
    if (aClass)
        GlobalDeleteAtom (aClass);

    if (aDoc)
        GlobalDeleteAtom (aDoc);

    if (hdoc)
        GlobalFree (hdoc);

    return retVal;
}


OLESTATUS FAR PASCAL OleRevokeClientDoc (
   LHCLIENTDOC lhclientdoc
){
    LPCLIENTDOC lpdoc;

    Puts ("OleRevokeClientDoc");

    // if there is any handler dll that can be freed up, free it now.
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll)
        UnloadDll ();

    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (lpdoc->lpHeadObj) {
        ASSERT (0, "OleRevokeClientDoc() called without freeing all objects");
        return OLE_ERROR_NOT_EMPTY;
    }

    if (lpdoc->aClass)
        GlobalDeleteAtom (lpdoc->aClass);

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);

    // if only one doc is in the list then it's prev and next docs are NULL

    if (lpdoc == lpHeadDoc)
        lpHeadDoc = lpdoc->lpNextDoc;

    if (lpdoc == lpTailDoc)
        lpTailDoc = lpdoc->lpPrevDoc;

    if (lpdoc->lpPrevDoc)
        lpdoc->lpPrevDoc->lpNextDoc = lpdoc->lpNextDoc;

    if (lpdoc->lpNextDoc)
        lpdoc->lpNextDoc->lpPrevDoc = lpdoc->lpPrevDoc;

    GlobalUnlock (lpdoc->hdoc);
    GlobalFree (lpdoc->hdoc);

    // inform link manager
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRenameClientDoc (
    LHCLIENTDOC lhclientdoc,
    LPCSTR       lpNewDocName
){
    LPCLIENTDOC lpdoc;
    ATOM        aNewDoc;
    LPOLEOBJECT lpobj = NULL;

    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    FARPROBE_READ(lpNewDocName);

    aNewDoc = GlobalAddAtom (lpNewDocName);
    if (aNewDoc == lpdoc->aDoc) {
        if (aNewDoc)
            GlobalDeleteAtom (aNewDoc);
        return OLE_OK;
    }

    // Document name has changed. So, change the topic of all embedded objects
    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = aNewDoc;

    while (lpobj = DocGetNextObject (lpdoc, lpobj)) {
        if (lpobj->ctype == CT_EMBEDDED)
            if (OleQueryReleaseStatus (lpobj) != OLE_BUSY)
                SetEmbeddedTopic ((LPOBJECT_LE) lpobj);
    }

    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRevertClientDoc (
    LHCLIENTDOC lhclientdoc
){
    // if there is any handler dll that can be freed up, free it now.
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll)
        UnloadDll ();

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}


OLESTATUS FAR PASCAL OleSavedClientDoc (
    LHCLIENTDOC lhclientdoc
){
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}

OLESTATUS FAR PASCAL OleEnumObjects (
    LHCLIENTDOC         lhclientdoc,
    LPOLEOBJECT FAR *   lplpobj
){
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    FARPROBE_WRITE(lplpobj);

    if (*lplpobj) {
        // we are making lhclientdoc field of the object NULL at deletion
        // time. The check (*lpobj->lhclientdoc != lhclientdoc) will take care
        // of the case where same chunk of memory is allocated again for the
        // same pointer and old contents are not erased yet.
        if (!FarCheckObject (*lplpobj)
                || ((*lplpobj)->lhclientdoc != lhclientdoc))
            return OLE_ERROR_OBJECT;
    }

    *lplpobj = DocGetNextObject ((LPCLIENTDOC) lhclientdoc, *lplpobj);
    return OLE_OK;
}



LPOLEOBJECT INTERNAL DocGetNextObject (
    LPCLIENTDOC lpdoc,
    LPOLEOBJECT lpobj
){
    if (!lpobj)
        return lpdoc->lpHeadObj;

    return lpobj->lpNextObj;
}


BOOL FARINTERNAL CheckClientDoc (
    LPCLIENTDOC lpdoc
){
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
        return FALSE;

    if ((lpdoc->docId[0] == 'C') && (lpdoc->docId[1] == 'D'))
        return TRUE;
    return FALSE;
}


void FARINTERNAL DocAddObject (
    LPCLIENTDOC lpdoc,
    LPOLEOBJECT lpobj,
    LPCSTR      lpobjname
){
    if (lpobjname)
        lpobj->aObjName = GlobalAddAtom (lpobjname);
    else
        lpobj->aObjName = (ATOM)0;

    // Objects of a doc are doubly linked

    if (!lpdoc->lpHeadObj)
        lpdoc->lpHeadObj = lpdoc->lpTailObj = lpobj;
    else {
        lpdoc->lpTailObj->lpNextObj = lpobj;
        lpobj->lpPrevObj = lpdoc->lpTailObj;
        lpdoc->lpTailObj = lpobj;
    }
    lpobj->lhclientdoc = (LHCLIENTDOC)lpdoc;
}


void FARINTERNAL DocDeleteObject (
    LPOLEOBJECT lpobj
){
    LPCLIENTDOC lpdoc;

    if (!(lpdoc = (LPCLIENTDOC) lpobj->lhclientdoc))
        return;

    if (lpobj->aObjName) {
        GlobalDeleteAtom (lpobj->aObjName);
        lpobj->aObjName = (ATOM)0;
    }

    // Remove this obj from object chain of the relevant client doc.
    // The objects of a doc are doubly linked.

    if (lpdoc->lpHeadObj == lpobj)
        lpdoc->lpHeadObj = lpobj->lpNextObj;

    if (lpdoc->lpTailObj == lpobj)
        lpdoc->lpTailObj = lpobj->lpPrevObj;

    if (lpobj->lpPrevObj)
        lpobj->lpPrevObj->lpNextObj = lpobj->lpNextObj;

    if (lpobj->lpNextObj)
        lpobj->lpNextObj->lpPrevObj = lpobj->lpPrevObj;

    lpobj->lhclientdoc = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: DRAW.C
*
* PURPOSE: Contains all the drawing related routines
*
* Created: March 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*       (03/21/91) Srinik  Original
*       (03/22/91) Srinik  Added support for drawing metafile in a metafile
*       curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

#define RECORD_COUNT    16

int       INTERNAL    PaletteSize (int);
HANDLE    INTERNAL    DibMakeLogPalette(LPSTR, UINT, LPLOGPALETTE FAR *);
OLESTATUS FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);
OLESTATUS INTERNAL    wDrawBitmap (LPOBJECT_BM, HDC, HDC, LPRECT);
OLESTATUS INTERNAL    wDrawBitmapUsingDib (LPOBJECT_BM, HDC, HDC, HDC, LPRECT, LPRECT);

void SetPictOrg (LPOBJECT_MF, HDC, int, int, BOOL);
void SetPictExt (LPOBJECT_MF, HDC, int, int);
void ScalePictExt (LPOBJECT_MF, HDC, int, int, int, int);
void ScaleRectExt (LPOBJECT_MF, HDC, int, int, int, int);

void CleanStack(LPOBJECT_MF, HANDLE);
BOOL PopDc (LPOBJECT_MF);
BOOL PushDc (LPOBJECT_MF);

#ifdef META_DEBUG
void PutMetaFuncName (UINT);
#endif

OLESTATUS  FARINTERNAL BmDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    int         iScreenDevCaps;
    HDC         hMemDC, hScreenDC;
    OLESTATUS   ret = OLE_OK;

    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    if (!(hScreenDC = GetDC (NULL))){
        return OLE_ERROR_MEMORY;
    }

    iScreenDevCaps = GetDeviceCaps (hScreenDC, TECHNOLOGY);
    if (!OleIsDcMeta (hdc)
            && (iScreenDevCaps != GetDeviceCaps (hdc, TECHNOLOGY))) {
        ret = wDrawBitmapUsingDib (lpobj, hdc, hScreenDC,
                        hdcTarget, (LPRECT)lprc, (LPRECT)lpWrc);
    }
    else {
        hMemDC = CreateCompatibleDC (hdc);
        if (hMemDC) {
            ret = wDrawBitmap (lpobj, hdc, hMemDC, (LPRECT)lprc);
            DeleteDC (hMemDC);
        } else {
            ret = OLE_ERROR_MEMORY;
        }

    }

    ReleaseDC (NULL, hScreenDC);
    return ret;

}

OLESTATUS INTERNAL wDrawBitmap (
    LPOBJECT_BM lpobj,
    HDC         hdc,
    HDC         hMemDC,
    LPRECT      lprc
){
    HBITMAP     hOldBitmap;
    OLESTATUS   ret = OLE_OK;

    if (!hMemDC)
        return OLE_ERROR_MEMORY;

    if (!(hOldBitmap = SelectObject(hMemDC, lpobj->hBitmap)))
        return OLE_ERROR_DRAW;

    if (!StretchBlt(hdc,
            lprc->left, lprc->top,
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            hMemDC, 0, 0, lpobj->xSize, lpobj->ySize, SRCCOPY)) {
        ret = OLE_ERROR_DRAW;
    }

    SelectObject (hMemDC, hOldBitmap);
    return ret;
}


OLESTATUS INTERNAL wDrawBitmapUsingDib (
    LPOBJECT_BM     lpobj,
    HDC             hdc,
    HDC             hScreenDC,
    HDC             hTargetDC,
    LPRECT          lprc,
    LPRECT          lpWrc
){
    BITMAP              bm;
    LPBITMAPINFOHEADER  lpBmi;
    HANDLE              hBmi, hDib = NULL;
    UINT                wBmiSize;
    OLESTATUS           retVal = OLE_ERROR_MEMORY;

    if (!GetObject(lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm))
        return OLE_ERROR_HANDLE;

    wBmiSize = sizeof(BITMAPINFOHEADER)
                    + PaletteSize(bm.bmPlanes * bm.bmBitsPixel);

    if (!(hBmi = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, wBmiSize)))
        return OLE_ERROR_MEMORY;

    if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hBmi))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }

    GlobalUnlock (hBmi);

    lpBmi->biSize          = (LONG) sizeof(BITMAPINFOHEADER);
    lpBmi->biWidth         = (LONG) bm.bmWidth;
    lpBmi->biHeight        = (LONG) bm.bmHeight;
    lpBmi->biPlanes        = 1;
    lpBmi->biBitCount      = bm.bmPlanes * bm.bmBitsPixel;
    lpBmi->biCompression   = BI_RGB;
    lpBmi->biSizeImage     = 0L;
    lpBmi->biXPelsPerMeter = 0L;
    lpBmi->biYPelsPerMeter = 0L;
    lpBmi->biClrUsed       = 0L;
    lpBmi->biClrImportant  = 0L;

    // Call GetDIBits with a NULL lpBits parm, so that it will calculate
    // the biSizeImage field for us
    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, bm.bmHeight, NULL,
            (LPBITMAPINFO)lpBmi, DIB_RGB_COLORS))
        return OLE_ERROR_HANDLE;

    // Realloc the buffer to provide space for the bits
    if (!(hDib = GlobalReAlloc (hBmi, (wBmiSize + lpBmi->biSizeImage),
                        GMEM_MOVEABLE))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }

    // If reallocation gave a new handle then lock that handle and get the
    // long pointer to it.
    if (hDib != hBmi) {
        if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hDib)))
            goto errRtn;
        GlobalUnlock (hDib);
    }

    // Call GetDIBits with a NON-NULL lpBits parm, and get the actual bits

    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, (WORD) lpBmi->biHeight,
             ((LPSTR)lpBmi)+wBmiSize,
             (LPBITMAPINFO) lpBmi,
             DIB_RGB_COLORS)) {
        retVal = OLE_ERROR_HANDLE;
        goto errRtn;
    }

    retVal = wDibDraw (hDib, hdc, lprc, lpWrc, hTargetDC, FALSE);

errRtn:
    if (hDib)
        GlobalFree (hDib);
    return retVal;
}

OLESTATUS  FARINTERNAL DibDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_DIB    lpobj = (LPOBJECT_DIB)lpoleobj;

    return wDibDraw (lpobj->hDIB, hdc, (LPRECT)lprc, (LPRECT)lpWrc, hdcTarget, FALSE);
}



OLESTATUS  FARINTERNAL wDibDraw (
    HANDLE  hData,
    HDC     hdc,
    LPRECT  lprc,
    LPRECT  lpWrc,
    HDC     hdcTarget,
    BOOL    bPbrushData
){
    // !!! current implementation is not using hdcTarget
    OLESTATUS       ret = OLE_ERROR_DRAW;
    LPSTR           lpData;
    HANDLE          hPalette = NULL;
    HPALETTE        hLogPalette = NULL, hOldPalette = NULL;
    LPLOGPALETTE    lpLogPalette;
    UINT            wPalSize;
    int             iOffBits;
	 HANDLE          hbminfo = NULL;
	 LPBITMAPINFO    lpbminfo;

    UNREFERENCED_PARAMETER(lpWrc);
    UNREFERENCED_PARAMETER(hdcTarget);

    if (!hData)
        return OLE_ERROR_BLANK;

    if (!(lpData = GlobalLock (hData)))
        return OLE_ERROR_MEMORY;

    if (bPbrushData)
	 {
	     BITMAPINFO UNALIGNED * lpbminfoTmp;
		  DWORD dwSize;
	
	  	  lpData     += sizeof(BITMAPFILEHEADER);
		  lpbminfoTmp = (BITMAPINFO UNALIGNED *)lpData;
	
		  dwSize =  sizeof(BITMAPINFOHEADER) + PaletteSize (lpbminfoTmp->bmiHeader.biBitCount);
								
		  if (!(hbminfo = GlobalAlloc(GHND, dwSize)) )
			  return OLE_ERROR_MEMORY;

        if (!(lpbminfo = (LPBITMAPINFO)GlobalLock(hbminfo)) )
		  {
            ret = OLE_ERROR_MEMORY;
			   goto end;
		  }
		
		  memcpy( (LPSTR)lpbminfo, lpData, dwSize );
		
	 }
	 else
		  lpbminfo = (LPBITMAPINFO)lpData;

    wPalSize = PaletteSize (lpbminfo->bmiHeader.biBitCount);
    iOffBits  = sizeof(BITMAPINFOHEADER) + wPalSize;

    // if color palette exits do the following
    if (wPalSize) {
        if (!(hLogPalette = DibMakeLogPalette(lpData+sizeof(BITMAPINFOHEADER),
                                    wPalSize, &lpLogPalette))) {
            ret = OLE_ERROR_MEMORY;
            goto end;
        }

        if (!(hPalette = CreatePalette (lpLogPalette)))
            goto end;

        // select as a background palette
        if (!(hOldPalette = SelectPalette (hdc, hPalette, TRUE)))
            goto end;

        RealizePalette(hdc);
    }

    if (!StretchDIBits(hdc,
            lprc->left, lprc->top,
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            0, 0,
            (UINT) lpbminfo->bmiHeader.biWidth,
            (UINT) lpbminfo->bmiHeader.biHeight,
            lpData + iOffBits,
            lpbminfo,
            DIB_RGB_COLORS,
            SRCCOPY)) {
        ret = OLE_ERROR_DRAW;
    }
    else
        ret = OLE_OK;

end:
    // if color palette exists do the following
    if (wPalSize) {
        hOldPalette = (OleIsDcMeta (hdc) ? GetStockObject(DEFAULT_PALETTE)
                                         : hOldPalette);
        if (hOldPalette) {
            // select as a background palette
            SelectPalette (hdc, hOldPalette, TRUE);
            RealizePalette (hdc);
        }

        if (hPalette)
            DeleteObject (hPalette);

        if (hLogPalette)
            GlobalFree (hLogPalette);
    }

    GlobalUnlock (hData);
	
	 if (hbminfo)
	 {
		 GlobalUnlock(hbminfo);
		 GlobalFree(hbminfo);
	 }
		
    return ret;
}





HANDLE INTERNAL DibMakeLogPalette (
    LPSTR               lpColorData,
    UINT                wDataSize,
    LPLOGPALETTE FAR *  lplpLogPalette
){
    HANDLE          hLogPalette=NULL;
    LPLOGPALETTE    lpLogPalette;
    DWORD           dwLogPalSize = wDataSize +  2 * sizeof(UINT);
    LPPALETTEENTRY  lpPE;
    RGBQUAD FAR *   lpQuad;

    if (!(hLogPalette = GlobalAlloc(GMEM_MOVEABLE,dwLogPalSize)))
        return NULL;

    if (!(lpLogPalette = (LPLOGPALETTE) GlobalLock (hLogPalette))) {
        GlobalFree (hLogPalette);
        return NULL;
    }

    GlobalUnlock (hLogPalette);
    *lplpLogPalette = lpLogPalette;

    lpLogPalette->palVersion = 0x300;
    lpLogPalette->palNumEntries = (WORD)(wDataSize / sizeof(PALETTEENTRY));

    /* now convert RGBQUAD to PALETTEENTRY as we copy color info */
    for (lpQuad = (RGBQUAD far *)lpColorData,
            lpPE   = (LPPALETTEENTRY)lpLogPalette->palPalEntry,
            wDataSize /= sizeof(RGBQUAD);
            wDataSize--;
            ++lpQuad,++lpPE) {
        lpPE->peFlags=0;
        lpPE->peRed = lpQuad->rgbRed;
        lpPE->peBlue = lpQuad->rgbBlue;
        lpPE->peGreen = lpQuad->rgbGreen;
    }

    return hLogPalette;
}


int INTERNAL PaletteSize (int iBitCount)
{
    switch (iBitCount) {
        case 1:
            return (2*sizeof(RGBQUAD));

        case 4:
            return (16*sizeof(RGBQUAD));

        case 8:
            return (256*sizeof(RGBQUAD));

        default:
            return 0;   /* A 24 bitcount DIB has no color table */
    }
}


OLESTATUS  FARINTERNAL GenDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_GEN    lpobj = (LPOBJECT_GEN) lpoleobj;

    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(lprc);
    UNREFERENCED_PARAMETER(lpWrc);
    UNREFERENCED_PARAMETER(hdcTarget);

    return OLE_ERROR_GENERIC;
}

////////////////////////////////////////////////////////////////////////////
//  METAFILE draw routines
////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL MfDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_MF lpobj = (LPOBJECT_MF) lpoleobj;
    HANDLE  hInfo;
    int     iOldDc;
    RECT    rect;
    LPRECT  lpRrc = (LPRECT) &rect;

    UNREFERENCED_PARAMETER(hdcTarget);

    rect.left   = lprc->left;
    rect.right  = lprc->right;
    rect.top    = lprc->top;
    rect.bottom = lprc->bottom;

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    lpobj->nRecord = RECORD_COUNT;
    lpobj->fMetaDC = OleIsDcMeta (hdc);

    if (!(iOldDc = SaveDC (hdc)))
        return OLE_ERROR_MEMORY;

    IntersectClipRect (hdc, lpRrc->left, lpRrc->top,
        lpRrc->right, lpRrc->bottom);

    if (!lpobj->fMetaDC) {
        LPtoDP (hdc, (LPPOINT) lpRrc, 2);
        SetMapMode (hdc, MM_ANISOTROPIC);
        MSetViewportOrg (hdc, lpRrc->left, lpRrc->top);
        MSetViewportExt (hdc, lpRrc->right - lpRrc->left,
            lpRrc->bottom - lpRrc->top);
    }
    else {

        iOldDc = -1;

        if (!lpWrc) {
            return OLE_ERROR_DRAW;
        }

        if (!(hInfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT,
                            sizeof(METAINFO))))
            return OLE_ERROR_MEMORY;

        if (!(lpobj->pMetaInfo = (PMETAINFO) LocalLock (hInfo))) {
            LocalFree (hInfo);
            return OLE_ERROR_MEMORY;
        }

        LocalUnlock (hInfo);

        lpobj->pCurMdc          = (PMETADC) (lpobj->pMetaInfo);

        lpobj->pMetaInfo->xwo   = lpWrc->left;
        lpobj->pMetaInfo->ywo   = lpWrc->top;
        lpobj->pMetaInfo->xwe   = lpWrc->right;
        lpobj->pMetaInfo->ywe   = lpWrc->bottom;

        lpobj->pMetaInfo->xro   = lpRrc->left - lpWrc->left;
        lpobj->pMetaInfo->yro   = lpRrc->top - lpWrc->top;

        lpobj->pCurMdc->xre     = lpRrc->right - lpRrc->left;
        lpobj->pCurMdc->yre     = lpRrc->bottom - lpRrc->top;

    }

    lpobj->error = OLE_OK;
    MfInterruptiblePaint(lpobj, hdc);

    if (lpobj->fMetaDC)
        CleanStack (lpobj, hInfo);

    RestoreDC (hdc, iOldDc);
    return lpobj->error;
}


void INTERNAL MfInterruptiblePaint (
    LPOBJECT_MF lpobj,
    HDC         hdc
){

    EnumMetaFile (hdc,lpobj->mfp.hMF, (MFENUMPROC)MfCallbackFunc, (LPARAM)lpobj);
	
}



BOOL APIENTRY MfCallbackFunc (
    HDC             hdc,
    LPHANDLETABLE   lpHTable,
    LPMETARECORD    lpMFR,
    int             nObj,
    LPVOID          lpobj
){
    LPOBJECT_MF lpobjMf;

    lpobjMf = (LPOBJECT_MF) lpobj;
    if (!--lpobjMf->nRecord) {
        lpobjMf->nRecord = RECORD_COUNT;
        if (!ContextCallBack ((lpobjMf->head.lpParent
                                    ? lpobjMf->head.lpParent
                                    : (LPOLEOBJECT) lpobjMf),
                        OLE_QUERY_PAINT)) {
            lpobjMf->error = OLE_ERROR_ABORT;
            return FALSE;
        }
    }

    if (lpobjMf->fMetaDC) {

#ifdef META_DEBUG
        PutMetaFuncName (lpMFR->rdFunction);
#endif

        switch (lpMFR->rdFunction) {
            case META_SETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1],
                    lpMFR->rdParm[0], FALSE);
                return TRUE;

            case META_OFFSETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1],
                    lpMFR->rdParm[0], TRUE);
                return TRUE;

            case META_SETWINDOWEXT:
                SetPictExt (lpobjMf, hdc, lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;

            case META_SCALEWINDOWEXT:
                ScalePictExt (lpobjMf, hdc,
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;

            case META_SAVEDC:
                if (!PushDc (lpobjMf))
                    return FALSE;
                break;

            case META_RESTOREDC:
                PopDc (lpobjMf);
                break;

            case META_SCALEVIEWPORTEXT:
                ScaleRectExt (lpobjMf, hdc,
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;

            case META_OFFSETVIEWPORTORG:
                return TRUE;

            case META_SETVIEWPORTORG:
                return TRUE;

            case META_SETVIEWPORTEXT:
                return TRUE;

            case META_SETMAPMODE:
                return TRUE;

            default:
                break;
        }
    }
    else {
        switch (lpMFR->rdFunction) {
            int extX,extY;

            case META_SCALEWINDOWEXT:
                if (MGetWindowExt (hdc,&extX,&extY))
                {
                     MSetWindowExt (
                        hdc,
                        MulDiv(extX, lpMFR->rdParm[3], lpMFR->rdParm[2]),
                        MulDiv(extY, lpMFR->rdParm[1], lpMFR->rdParm[0])
                     );
                     return TRUE;
                }
                return FALSE;

            case META_SCALEVIEWPORTEXT:
                if (MGetViewportExt (hdc,&extX,&extY))
                {
                     MSetViewportExt (
                        hdc,
                        MulDiv(extX, lpMFR->rdParm[3], lpMFR->rdParm[2]),
                        MulDiv(extY, lpMFR->rdParm[1], lpMFR->rdParm[0])
                     );
                     return TRUE;
                }
                return FALSE;

            default:
                break;
        }
    }

    PlayMetaFileRecord (hdc, lpHTable, lpMFR, nObj);
    return TRUE;
}


void SetPictOrg (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xOrg,
    int         yOrg,
    BOOL        fOffset
){
    if (fOffset) {
        // it's OffsetWindowOrg() call
        lpobj->pCurMdc->xMwo += xOrg;
        lpobj->pCurMdc->yMwo += yOrg;
    }
    else {
        // it's SetWindowOrg()
        lpobj->pCurMdc->xMwo = xOrg;
        lpobj->pCurMdc->yMwo = yOrg;
    }

    if (lpobj->pCurMdc->xMwe && lpobj->pCurMdc->yMwe) {
        MSetWindowOrg (hdc,
            (lpobj->pCurMdc->xMwo - MulDiv (lpobj->pMetaInfo->xro,
                                        lpobj->pCurMdc->xMwe,
                                        lpobj->pCurMdc->xre)),
            (lpobj->pCurMdc->yMwo - MulDiv (lpobj->pMetaInfo->yro,
                                        lpobj->pCurMdc->yMwe,
                                        lpobj->pCurMdc->yre)));
    }
}


void SetPictExt (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xExt,
    int         yExt
){
    lpobj->pCurMdc->xMwe = xExt;
    lpobj->pCurMdc->yMwe = yExt;

    MSetWindowExt (hdc,
        MulDiv (lpobj->pMetaInfo->xwe, xExt, lpobj->pCurMdc->xre),
        MulDiv (lpobj->pMetaInfo->ywe, yExt, lpobj->pCurMdc->yre));

    MSetWindowOrg (hdc,
        (lpobj->pCurMdc->xMwo
            - MulDiv (lpobj->pMetaInfo->xro, xExt, lpobj->pCurMdc->xre)),
        (lpobj->pCurMdc->yMwo
            - MulDiv (lpobj->pMetaInfo->yro, yExt, lpobj->pCurMdc->yre)));
}


void ScalePictExt (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xNum,
    int         xDenom,
    int         yNum,
    int         yDenom
){
    SetPictExt (lpobj, hdc, MulDiv (lpobj->pCurMdc->xMwe, xNum, xDenom),
        MulDiv (lpobj->pCurMdc->yMwe, yNum, yDenom));
}


void ScaleRectExt (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xNum,
    int         xDenom,
    int         yNum,
    int         yDenom
){
    lpobj->pCurMdc->xre = MulDiv (lpobj->pCurMdc->xre, xNum, xDenom);
    lpobj->pCurMdc->yre = MulDiv (lpobj->pCurMdc->yre, yNum, yDenom);

    SetPictExt (lpobj, hdc, lpobj->pCurMdc->xMwe, lpobj->pCurMdc->yMwe);
}



BOOL PushDc (LPOBJECT_MF lpobj)
{
    HANDLE  hNode = NULL;
    PMETADC pNode = NULL;

    if ((hNode = LocalAlloc (LMEM_MOVEABLE, sizeof (METADC)))
            && (pNode = (PMETADC) LocalLock (hNode))) {
        *pNode =  *lpobj->pCurMdc;
        lpobj->pCurMdc->pNext = pNode;
        pNode->pNext = NULL;
        lpobj->pCurMdc = pNode;
        LocalUnlock (hNode);
        return TRUE;
    }

    if (pNode)
        LocalFree (hNode);

    lpobj->error = OLE_ERROR_MEMORY;
    return FALSE;
}


BOOL PopDc (LPOBJECT_MF lpobj)
{
    PMETADC pPrev = (PMETADC) (lpobj->pMetaInfo);
    PMETADC pCur  = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;

    if (!pCur)
        // more Pops than Pushes
        return FALSE;

    while (pCur->pNext) {
        pPrev = pCur;
        pCur  = pCur->pNext;
    }

    if (hCur = LocalHandle ((MAPTYPE(WORD,LPSTR)) pCur))
        LocalFree (hCur);
    pPrev->pNext    = NULL;
    lpobj->pCurMdc  = pPrev;
    return TRUE;
}


void CleanStack(
    LPOBJECT_MF lpobj,
    HANDLE      hMetaInfo
){
    PMETADC pCur = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;

    while (pCur) {
        hCur = LocalHandle ((MAPTYPE(WORD,LPSTR)) pCur);
        ((PMETADC) (lpobj->pMetaInfo))->pNext = pCur = pCur->pNext;
        if (hCur)
            LocalFree (hCur);
    }

    LocalFree (hMetaInfo);
    lpobj->fMetaDC      = FALSE;
    lpobj->pCurMdc      = NULL;
    lpobj->pMetaInfo    = NULL;
}

#ifdef META_DEBUG
void PutMetaFuncName (WORD value)
{
    switch (value) {
        case META_SETBKCOLOR:
             OutputDebugString ("SetBkColor ");
             break;

        case META_SETBKMODE:
             OutputDebugString ("SetBkMode ");
             break;

        case META_SETMAPMODE:
             OutputDebugString ("SetMapMode ");
             break;

        case META_SETROP2:
             OutputDebugString ("SetRop2 ");
             break;

        case META_SETRELABS:
             OutputDebugString ("SetRelabs ");
             break;

        case META_SETPOLYFILLMODE:
             OutputDebugString ("SetPolyfillMode ");
             break;

        case META_SETSTRETCHBLTMODE:
             OutputDebugString ("SetStretchBltMode ");
             break;

        case META_SETTEXTCHAREXTRA:
             OutputDebugString ("SetTextCharExtra ");
             break;

        case META_SETTEXTCOLOR:
             OutputDebugString ("SetTextColor ");
             break;

        case META_SETTEXTJUSTIFICATION:
             OutputDebugString ("SetTextJustification ");
             break;

        case META_SETWINDOWORG:
             OutputDebugString ("SetWindowOrg ");
             break;

        case META_SETWINDOWEXT:
             OutputDebugString ("SetWindowExt ");
             break;

        case META_SETVIEWPORTORG:
             OutputDebugString ("SetViewportOrg ");
             break;

        case META_SETVIEWPORTEXT:
             OutputDebugString ("SetViewportExt ");
             break;

        case META_OFFSETWINDOWORG:
             OutputDebugString ("OffsetWindowOrg ");
             break;

        case META_SCALEWINDOWEXT:
             OutputDebugString ("ScaleWindowExt ");
             break;

        case META_OFFSETVIEWPORTORG:
             OutputDebugString ("OffsetViewportOrg ");
             break;

        case META_SCALEVIEWPORTEXT:
             OutputDebugString ("ScaleViewportExt ");
             break;

        case META_LINETO:
             OutputDebugString ("LineTo ");
             break;

        case META_MOVETO:
             OutputDebugString ("MoveTo ");
             break;

        case META_EXCLUDECLIPRECT:
             OutputDebugString ("ExcludeCliprect ");
             break;

        case META_INTERSECTCLIPRECT:
             OutputDebugString ("IntersectCliprect ");
             break;

        case META_ARC:
             OutputDebugString ("Arc ");
             break;

        case META_ELLIPSE:
             OutputDebugString ("Ellipse ");
             break;

        case META_FLOODFILL:
             OutputDebugString ("FloodFill ");
             break;

        case META_PIE:
             OutputDebugString ("Pie ");
             break;

        case META_RECTANGLE:
             OutputDebugString ("Rectangle ");
             break;

        case META_ROUNDRECT:
             OutputDebugString ("RoundRect ");
             break;

        case META_PATBLT:
             OutputDebugString ("PatBlt ");
             break;

        case META_SAVEDC:
             OutputDebugString ("SaveDC ");
             break;

        case META_SETPIXEL:
             OutputDebugString ("SetPixel ");
             break;

        case META_OFFSETCLIPRGN:
             OutputDebugString ("OffsetClipRegion ");
             break;

        case META_TEXTOUT:
             OutputDebugString ("TextOut ");
             break;

        case META_BITBLT:
             OutputDebugString ("BitBlt ");
             break;

        case META_STRETCHBLT:
             OutputDebugString ("StrechBlt ");
             break;

        case META_POLYGON:
             OutputDebugString ("Polygon ");
             break;

        case META_POLYLINE:
             OutputDebugString ("PolyLine ");
             break;

        case META_ESCAPE:
             OutputDebugString ("Escape ");
             break;

        case META_RESTOREDC:
             OutputDebugString ("RestoreDC ");
             break;

        case META_FILLREGION:
             OutputDebugString ("FillRegion ");
             break;

        case META_FRAMEREGION:
             OutputDebugString ("FrameRegion ");
             break;

        case META_INVERTREGION:
             OutputDebugString ("InvertRegion ");
             break;

        case META_PAINTREGION:
             OutputDebugString ("PaintRegion ");
             break;

        case META_SELECTCLIPREGION:
             OutputDebugString ("SelectClipRegion ");
             break;

        case META_SELECTOBJECT:
             OutputDebugString ("SelectObject ");
             break;

        case META_SETTEXTALIGN:
             OutputDebugString ("SetTextAlign ");
             break;

        case META_DRAWTEXT:
             OutputDebugString ("DrawText");
             break;

        case META_CHORD:
             OutputDebugString ("Chord ");
             break;

        case META_SETMAPPERFLAGS:
             OutputDebugString ("SetMapperFlags ");
             break;

        case META_EXTTEXTOUT:
             OutputDebugString ("ExtTextOut ");
             break;

        case META_SETDIBTODEV:
             OutputDebugString ("SetDIBitsToDevice ");
             break;

        case META_SELECTPALETTE:
             OutputDebugString ("SelectPalette ");
             break;

        case META_REALIZEPALETTE:
             OutputDebugString ("RealizePalette ");
             break;

        case META_ANIMATEPALETTE:
             OutputDebugString ("AnimatePalette ");
             break;

        case META_SETPALENTRIES:
             OutputDebugString ("SetPaletteEntries ");
             break;

        case META_POLYPOLYGON:
             OutputDebugString ("PolyPolygon ");
             break;

        case META_RESIZEPALETTE:
             OutputDebugString ("ResizePalette ");
             break;

        case META_DIBBITBLT:
             OutputDebugString ("DibBitBlt ");
             break;

        case META_DIBSTRETCHBLT:
             OutputDebugString ("DibStrechBlt ");
             break;

        case META_DIBCREATEPATTERNBRUSH:
             OutputDebugString ("DibCreatePatternBrush ");
             break;

        case META_STRETCHDIB:
             OutputDebugString ("StretchDIBits ");
             break;

        case META_DELETEOBJECT:
             OutputDebugString ("DeleteObject ");
             break;

        case META_CREATEPALETTE:
             OutputDebugString ("CreatePalette ");
             break;

        case META_CREATEBRUSH:
             OutputDebugString ("CreateBrush ");
             break;

        case META_CREATEPATTERNBRUSH:
             OutputDebugString ("CreatePatternBrush ");
             break;

        case META_CREATEPENINDIRECT:
             OutputDebugString ("CreatePenIndirect ");
             break;

        case META_CREATEFONTINDIRECT:
             OutputDebugString ("CreateFontIndirect ");
             break;

        case META_CREATEBRUSHINDIRECT:
             OutputDebugString ("CreateBrushIndirect ");
             break;

        case META_CREATEBITMAPINDIRECT:
             OutputDebugString ("CreateBitmapIndirect ");
             break;

        case META_CREATEBITMAP:
             OutputDebugString ("CreateBitmap ");
             break;

        case META_CREATEREGION:
             OutputDebugString ("CreateRegion ");
             break;

        default:
             OutputDebugString ("Invalid+Function+encountered ");
             break;

    }
}
#endif

////////////////////////////////////////////////////////////////////////////
//  ENHMETAFILE draw routines
////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmfDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF) lpoleobj;

     UNREFERENCED_PARAMETER(hdcTarget);
     UNREFERENCED_PARAMETER(lpWrc);

     if (!lpobj->hemf)
         return OLE_ERROR_BLANK;

     lpobj->nRecord = RECORD_COUNT;
     lpobj->fMetaDC = OleIsDcMeta (hdc);

     if (!SaveDC(hdc))
         return OLE_ERROR_MEMORY;

     IntersectClipRect (hdc, lprc->left, lprc->top,
         lprc->right, lprc->bottom);

     lpobj->error = OLE_OK;
     EmfInterruptiblePaint(lpobj, hdc, (LPRECT)lprc);

     RestoreDC(hdc, -1);

     return lpobj->error;
}

void INTERNAL EmfInterruptiblePaint (
    LPOBJECT_EMF lpobj,
    HDC         hdc ,
    LPRECT      lprc
){

    EnumEnhMetaFile (hdc,(HENHMETAFILE)lpobj->hemf, (ENHMFENUMPROC)EmfCallbackFunc, (LPVOID)lpobj, lprc);

}

int FARINTERNAL EmfCallbackFunc (
    HDC             hdc,
    LPHANDLETABLE   lpHTable,
    LPENHMETARECORD lpEMFR,
    int             nObj,
    LPVOID          lpobj
){
    LPOBJECT_EMF lpobjEmf = (LPOBJECT_EMF) lpobj;

    if (!--lpobjEmf->nRecord) {
        lpobjEmf->nRecord = RECORD_COUNT;
        if (!ContextCallBack ((lpobjEmf->head.lpParent
                                    ? lpobjEmf->head.lpParent
                                    : (LPOLEOBJECT) lpobjEmf),
                        OLE_QUERY_PAINT)) {
            lpobjEmf->error = OLE_ERROR_ABORT;
            return FALSE;
        }
    }

    PlayEnhMetaFileRecord (hdc, lpHTable, lpEMFR, nObj);
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\generic.c ===
/****************************** Module Header ******************************\
* Module Name: GENERIC.C
*
* Handles all API routines for the generic sub-dll of the ole dll.
* Since the data format is unknown, all the routines are written with the
* assumption that all the relevant data is placed in a single global data
* segment. Note that this assumption is not valid for metafiles, bitmaps, and
* and there can always be some other formats with such idiosyncracies. To
* accommodate those cases the rendering dll writer should replace the relevant
* routines after the creation of the generic object. If for a given class this
* assumption (about data format) is valid then the dll writer need to replace
* only the Draw and QueryBounds functions.
*
* Created: November-1990
*
* Copyright (c) 1990, 1991 Microsoft Corporation
*
* History:
*
*  Srinik, Raor  (11/05/90) Designed, coded
*  Curts created NT version
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

char aMacText[4] = {'T', 'E', 'X', 'T'};
char aMacRtf[4]  = "RTF";

extern OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

OLEOBJECTVTBL    vtblGEN  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        GenRelease,         // Release
        ErrShow,            // Show
        ErrPlay,            // plat
        GenGetData,         // Get the object data
        GenSetData,         // Set the object data
        ErrSetTargetDevice, //

        ErrSetBounds,       // set viewport bounds
        GenEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        GenRelease,         // delete
        ErrSetHostNames,    //

        GenSaveToStream,    // write to file
        GenClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Link

        GenEqual,           // compares the given objects for data equality

        GenCopy,            // copy to clip

        GenDraw,            // draw the object

        ErrActivate,        // open
        ErrExecute,         // excute
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,          // Change Object name
        ObjQueryName,       // Get current object name

        GenQueryType,       // Object type
        GenQueryBounds,     // QueryBounds
        ObjQuerySize,       // Find the size of the object
        ErrQueryOpen,       // Query open
        ErrQueryOutOfDate,  // query whether object is current

        ErrQueryRelease,     // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        GenChangeData      // change data of the existing object
};


OLESTATUS  FARINTERNAL GenRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_GEN lpobj = (LPOBJECT_GEN)lpoleobj;
    HOBJECT      hobj;

    if (lpobj->hData) {
        GlobalFree (lpobj->hData);
        lpobj->hData = NULL;
    }

    if (lpobj->aClass)
        GlobalDeleteAtom (lpobj->aClass);

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);

    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL GenSaveToStream (
    LPOLEOBJECT     lpoleobj,
    LPOLESTREAM     lpstream
){
    DWORD        dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_GEN lpobj     = (LPOBJECT_GEN)lpoleobj;
    LPSTR        lpData;
    OLESTATUS    retVal    = OLE_OK;
    DWORD        dwClipFormat = 0;
    char         formatName[MAX_STR];

    if (!lpobj->hData)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutAtomIntoStream (lpstream, lpobj->aClass))
        return OLE_ERROR_STREAM;

    if (lpobj->cfFormat < 0xC000)
        // then it is a predefined format
        dwClipFormat = lpobj->cfFormat;

    if (PutBytes (lpstream, (LPSTR) &dwClipFormat, sizeof(DWORD)))
        return OLE_ERROR_STREAM;

    if (!dwClipFormat) {
        if (!GetClipboardFormatName (lpobj->cfFormat, (LPSTR) formatName,
                        sizeof(formatName)))
            return OLE_ERROR_FORMAT;

        if (PutStrWithLen (lpstream, formatName))
            return OLE_ERROR_STREAM;
    }

    if (!lpobj->sizeBytes)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
        return OLE_ERROR_STREAM;

    if (!(lpData = GlobalLock (lpobj->hData)))
        return OLE_ERROR_MEMORY;

    if (PutBytes (lpstream, lpData, lpobj->sizeBytes))
        retVal = OLE_ERROR_STREAM;

    GlobalUnlock (lpobj->hData);
    return retVal;
}


OLESTATUS FARINTERNAL  GenClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_GEN lpobjsrc = (LPOBJECT_GEN)lpoleobjsrc;

    if (!lpobjsrc->hData)
        return OLE_ERROR_BLANK;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(*lplpoleobj = (LPOLEOBJECT)GenCreateObject (lpobjsrc->hData, lpclient,
                            FALSE, lhclientdoc,
                            (LPSTR)lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else {
        ((LPOBJECT_GEN)(*lplpoleobj))->cfFormat = lpobjsrc->cfFormat;
        ((LPOBJECT_GEN)(*lplpoleobj))->aClass = DuplicateAtom (lpobjsrc->aClass);
        return OLE_OK;
    }
}



OLESTATUS FARINTERNAL  GenEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_GEN lpobj1 = (LPOBJECT_GEN)lpoleobj1;
    LPOBJECT_GEN lpobj2 = (LPOBJECT_GEN)lpoleobj2;

    if (CmpGlobals (lpobj1->hData, lpobj2->hData))
        return OLE_OK;

    return  OLE_ERROR_NOT_EQUAL;
}



OLESTATUS FARINTERNAL GenCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_GEN lpobj = (LPOBJECT_GEN)lpoleobj;
    HANDLE  hData;

    if (!lpobj->hData)
        return OLE_ERROR_BLANK;

    if (!(hData = DuplicateGlobal (lpobj->hData, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    SetClipboardData (lpobj->cfFormat, hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    LPOBJECT_GEN    lpobj = NULL;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    HANDLE          hData;
    LPSTR           lpData;
    DWORD           dwClipFormat;
    char            formatName[MAX_STR];
    LONG            length;

    if (!(*lplpobj = (LPOLEOBJECT) (lpobj = GenCreateBlank(lhclientdoc,
                                                    lpobjname, objType,
                                                    aClass)))) {
        if (aClass)
            GlobalDeleteAtom(aClass);
        return OLE_ERROR_MEMORY;
    }

    if (GetBytes (lpstream, (LPSTR) &dwClipFormat, sizeof (DWORD)))
        goto errLoad;

    // If object is from MAC then we will keep the data intact if the data
    // format is either TEXT or RTF
    if (HIWORD(dwVerFromFile) == OS_MAC) {
        if (dwClipFormat ==  *((DWORD *) aMacText))
            lpobj->cfFormat = CF_TEXT;
        else if (dwClipFormat == *((DWORD *) aMacRtf))
            lpobj->cfFormat = (OLECLIPFORMAT)RegisterClipboardFormat ((LPSTR) "Rich Text Format");
        else
            lpobj->cfFormat = 0;
    }
    else {
        // object is created on windows
        if (!dwClipFormat) {
            // this is new file format. format name string follows
            if (GetBytes (lpstream, (LPSTR) &length, sizeof (LONG))
                    || GetBytes (lpstream, (LPSTR)formatName, length)
                    || (!(lpobj->cfFormat = (OLECLIPFORMAT)RegisterClipboardFormat ((LPSTR) formatName))))
                goto errLoad;
        }
        else if ((lpobj->cfFormat = (WORD) dwClipFormat) >= 0xc000) {
            // if format is not predefined and file format is old, then use
            // what value is passed to you through "cfFormat" argument
            lpobj->cfFormat = cfFormat;
        }
    }

    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof (DWORD)))
        goto errLoad;

    lpobj->head.lpclient = lpclient;

    retVal = OLE_ERROR_MEMORY;
    if (!(hData = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)))
        goto errLoad;

    if (!(lpData = GlobalLock (hData)))
        goto errMem;

    if (GetBytes (lpstream, lpData, lpobj->sizeBytes)) {
        retVal = OLE_ERROR_STREAM;
        GlobalUnlock (hData);
        goto errMem;
    }

    lpobj->hData = hData;
    GlobalUnlock (hData);

    // if the object is from MAC then we want delete this and create blank
    // metafile object, which draws a rectangle
    if ((HIWORD(dwVerFromFile) == OS_MAC) && !lpobj->cfFormat) {
        LPOBJECT_MF lpobjMf;

        OleDelete ((LPOLEOBJECT)lpobj);  // delete generic object

        // Now create a dummy metafile object which draws a rectangle of size
        // 1" x 1". Note that 1" = 2540 HIMETRIC units
        lpobjMf = MfCreateBlank (lhclientdoc, lpobjname, objType);
        lpobjMf->head.cx = lpobjMf->mfp.xExt = 2540;
        lpobjMf->head.cy = - (lpobjMf->mfp.yExt = 2540);
        if ((retVal = wCreateDummyMetaFile (lpobjMf, lpobjMf->mfp.xExt,
                                    lpobjMf->mfp.yExt)) != OLE_OK) {
            OleDelete ((LPOLEOBJECT) lpobjMf);
            return retVal;
        }
    }

    return OLE_OK;

errMem:
    GlobalFree (hData);

errLoad:
    OleDelete ((LPOLEOBJECT)lpobj);
    *lplpobj = NULL;
    return OLE_ERROR_STREAM;

}




LPOBJECT_GEN INTERNAL GenCreateObject (
    HANDLE      hData,
    LPOLECLIENT lpclient,
    BOOL        fDelete,
    LHCLIENTDOC lhclientdoc,
    LPCSTR      lpobjname,
    LONG        objType
){
    LPOBJECT_GEN     lpobj;

    if (!hData)
        return NULL;

    if (lpobj = GenCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType, (ATOM)0)) {
        if (GenChangeData ((LPOLEOBJECT)lpobj, hData, lpclient, fDelete) != OLE_OK) {
            GenRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewData will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL GenChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hSrcData,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_GEN lpobj = (LPOBJECT_GEN)lpoleobj;
    HANDLE      hDestData;

    if (!fDelete) {
        if (!(hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself
        if (!(hDestData = GlobalReAlloc(hSrcData,0L,GMEM_MODIFY|GMEM_SHARE))){
            hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
            GlobalFree (hSrcData);
            if (!hDestData)
                return OLE_ERROR_MEMORY;
        }
    }

    lpobj->head.lpclient = lpclient;
    if (lpobj->hData)
        GlobalFree (lpobj->hData);
    lpobj->hData = hDestData;
    lpobj->sizeBytes = (DWORD)GlobalSize (hDestData);

    return OLE_OK;
}



LPOBJECT_GEN FARINTERNAL GenCreateBlank(
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType,
    ATOM        aClass
){
    HOBJECT         hobj;
    LPOBJECT_GEN    lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_GEN)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_GEN) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblGEN;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    lpobj->aClass           = aClass;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
            (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}


OLESTATUS FARINTERNAL GenPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LPSTR               lpClass,
    OLECLIPFORMAT       cfFormat,
    LONG                objType
){
    HANDLE  hData = NULL;

    *lplpobj = NULL;
    if (!cfFormat)
        return OLE_ERROR_FORMAT;

    if (!(hData = GetClipboardData(cfFormat)))
        return OLE_ERROR_MEMORY;

    if (!(*lplpobj = (LPOLEOBJECT) GenCreateObject (hData, lpclient,
                                        FALSE, lhclientdoc,
                                        lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    ((LPOBJECT_GEN)(*lplpobj))->cfFormat = cfFormat;
    ((LPOBJECT_GEN)(*lplpobj))->aClass = GlobalAddAtom (lpClass);
    return OLE_OK;

}



OLESTATUS FARINTERNAL GenQueryType (
    LPOLEOBJECT lpobj,
    LPLONG      lptype
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lptype);

    return OLE_ERROR_GENERIC;;
}



OLESTATUS FARINTERNAL GenSetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    HANDLE        hData
){
    LPOBJECT_GEN  lpobj = (LPOBJECT_GEN)lpoleobj;

    if (lpobj->cfFormat != cfFormat)
        return OLE_ERROR_FORMAT;

    if (!hData)
        return OLE_ERROR_BLANK;

    GlobalFree (lpobj->hData);
    lpobj->hData = hData;
    lpobj->sizeBytes = (DWORD)GlobalSize (hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenGetData (
    LPOLEOBJECT     lpoleobj,
    OLECLIPFORMAT   cfFormat,
    LPHANDLE        lphandle
){
    LPOBJECT_GEN    lpobj = (LPOBJECT_GEN)lpoleobj;

    if (cfFormat != lpobj->cfFormat)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hData))
        return OLE_ERROR_BLANK;

    return OLE_OK;

}


OLECLIPFORMAT FARINTERNAL GenEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_GEN  lpobj = (LPOBJECT_GEN)lpoleobj;

    if (!cfFormat)
        return lpobj->cfFormat;

    return 0;
}


OLESTATUS FARINTERNAL GenQueryBounds (
    LPOLEOBJECT     lpoleobj,
    LPRECT          lpRc
){
    LPOBJECT_GEN    lpobj = (LPOBJECT_GEN)lpoleobj;

    lpRc->right     = 0;
    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->bottom    = 0;
    return OLE_ERROR_GENERIC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\emf.c ===
/****************************** Module Header ******************************\
* Module Name:EMF.C (Extensible Compound Documents - EnhancedMetafile)
*
* PURPOSE:Handles all API routines for the metafile sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   cloned mf.c and banged into form curts March 92
*
* Comments:
*   fun, fun, until hockl takes the enhanced metafile api away
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

#define RECORD_COUNT    16

OLEOBJECTVTBL    vtblEMF = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        EmfRelease,         // Release
        ErrShow,            // show
        ErrPlay,            // play
        EmfGetData,         // Get the object data
        ErrSetData,         // Set the object data
        ErrSetTargetDevice, //
        ErrSetBounds,       // set viewport bounds
        EmfEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        EmfRelease,         // delete
        ErrSetHostNames,    //

        EmfSaveToStream,    // write to file
        EmfClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Lnk

        EmfEqual,           // compares the given objects for data equality

        EmfCopy,            // copy to clip

        EmfDraw,            // draw the object

        ErrActivate,        // open
        ErrExecute,         // excute
        ErrClose,           // stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,          // Change Object name
        ObjQueryName,       // Get current object name
        ObjQueryType,       // Object type
        EmfQueryBounds,     // QueryBounds
        ObjQuerySize,       // Find the size of the object
        ErrQueryOpen,       // Query open
        ErrQueryOutOfDate,  // query whether object is current

        ErrQueryRelease,    // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,     // requestdata
        ErrObjectLong,      // objectLong
        EmfChangeData       // change data of the existing object
};


OLESTATUS FARINTERNAL  EmfRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;
    HOBJECT hobj;

    if (lpobj->hemf) {
        DeleteEnhMetaFile ((HENHMETAFILE)lpobj->hemf);
        lpobj->hemf = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT)lpobj);

    if (hobj = lpobj->head.hobj) {
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}


OLESTATUS FARINTERNAL  SaveEmfAsMfToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD             dwFileVer = (DWORD)MAKELONG(wReleaseVer,OS_WIN32);
    LPOBJECT_EMF      lpobj     = (LPOBJECT_EMF)lpoleobj;
    OLESTATUS         retval    = OLE_ERROR_MEMORY;
    HDC               hdc       = NULL ;
    LPBYTE            lpBytes   = NULL ;
    HANDLE            hBytes    = NULL ;
    WIN16METAFILEPICT w16mfp;
    UINT              lSizeBytes;

    w16mfp.mm   = MM_ANISOTROPIC;
    w16mfp.xExt = (short)lpobj->head.cx;

    if ((short)lpobj->head.cy <0 ) {
       w16mfp.yExt = -(short)lpobj->head.cy;
    } else {
       w16mfp.yExt = (short)lpobj->head.cy;
    }

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"METAFILEPICT"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    hdc = GetDC(NULL);
    if (!(lSizeBytes = GetWinMetaFileBits((HENHMETAFILE)lpobj->hemf, 0, NULL, MM_ANISOTROPIC, hdc)) ) {
        if (hdc) ReleaseDC(NULL, hdc);
        return OLE_ERROR_METAFILE;
    }

    if (!(hBytes = GlobalAlloc(GHND, lSizeBytes)) )
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock(hBytes)) )
        goto error;

    if (GetWinMetaFileBits((HENHMETAFILE)lpobj->hemf, lSizeBytes, lpBytes, MM_ANISOTROPIC, hdc) != lSizeBytes) {
        retval = OLE_ERROR_METAFILE;
        goto error;
    }

    lSizeBytes += sizeof(WIN16METAFILEPICT);

    if (PutBytes (lpstream, (LPSTR) &lSizeBytes, sizeof(UINT)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR)&w16mfp, sizeof(WIN16METAFILEPICT)))
        goto error;

    if (!PutBytes (lpstream, (LPSTR)lpBytes, lSizeBytes - sizeof(WIN16METAFILEPICT)))
        retval = OLE_OK;

error:
    if (lpBytes)
        GlobalUnlock(hBytes);
    if (hBytes)
        GlobalFree(hBytes);

    if (hdc)
      ReleaseDC(NULL, hdc);

    return retval;

}

OLESTATUS FARINTERNAL  EmfSaveToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD        dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_EMF lpobj     = (LPOBJECT_EMF)lpoleobj;
    OLESTATUS    retval    = OLE_ERROR_MEMORY;
    LPBYTE       lpBytes   = NULL ;
    HANDLE       hBytes    = NULL ;


    if (!lpobj->hemf)
        return OLE_ERROR_BLANK;

    if (HIWORD(dwFileVer) == OS_WIN16)
      if (!SaveEmfAsMfToStream(lpoleobj,lpstream))
         return OLE_OK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"ENHMETAFILE"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (!(hBytes = GlobalAlloc(GHND, lpobj->sizeBytes)) )
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock(hBytes)) )
        goto error;

    retval = OLE_ERROR_METAFILE;

    if (GetEnhMetaFileBits((HENHMETAFILE)lpobj->hemf, lpobj->sizeBytes, lpBytes) != lpobj->sizeBytes )
        goto error;

    if (!PutBytes (lpstream, (LPSTR)lpBytes, lpobj->sizeBytes))
        retval = OLE_OK;

error:
    if (lpBytes)
        GlobalUnlock(hBytes);
    if (hBytes)
        GlobalFree(hBytes);

    return retval;

}

OLESTATUS FARINTERNAL  EmfClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_EMF lpobjsrc = (LPOBJECT_EMF)lpoleobjsrc;
    LPOBJECT_EMF lpobjEmf;
    HENHMETAFILE hemf;

    *lplpoleobj = (LPOLEOBJECT)NULL;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;


    if (!((HENHMETAFILE)hemf = CopyEnhMetaFile ((HENHMETAFILE)lpobjsrc->hemf, NULL)))
        return OLE_ERROR_MEMORY;

    if (lpobjEmf = EmfCreateBlank (lhclientdoc, (LPSTR)lpobjname,
                        lpobjsrc->head.ctype)) {
        lpobjEmf->sizeBytes      = lpobjsrc->sizeBytes;
        lpobjEmf->head.lpclient  = lpclient;
		  lpobjEmf->hemf           = hemf;
        EmfSetExtents (lpobjEmf);

        *lplpoleobj = (LPOLEOBJECT)lpobjEmf;
        return OLE_OK;
    }

    return OLE_ERROR_MEMORY;
}



OLESTATUS FARINTERNAL  EmfEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_EMF lpobj1   = (LPOBJECT_EMF)lpoleobj1;
    HANDLE       hBytes1  = NULL;
    LPBYTE       lpBytes1 = NULL;
    LPOBJECT_EMF lpobj2   = (LPOBJECT_EMF)lpoleobj2;
    HANDLE       hBytes2  = NULL;
    LPBYTE       lpBytes2 = NULL;
    OLESTATUS    retval   = OLE_ERROR_MEMORY;


    if (lpobj1->sizeBytes != lpobj2->sizeBytes)
        return OLE_ERROR_NOT_EQUAL;

    if (!(hBytes1 = GlobalAlloc(GHND, lpobj1->sizeBytes)) )
        goto errMemory;

    if (!(lpBytes1 = (LPBYTE)GlobalLock(hBytes1)) )
        goto errMemory;

    if (!(hBytes2 = GlobalAlloc(GHND, lpobj2->sizeBytes)) )
        goto errMemory;

    if (!(lpBytes2 = (LPBYTE)GlobalLock(hBytes2)) )
        goto errMemory;

    if (GetEnhMetaFileBits((HENHMETAFILE)lpobj1->hemf, lpobj1->sizeBytes, lpBytes1) != lpobj1->sizeBytes)
        goto errMemory;

    if (GetEnhMetaFileBits((HENHMETAFILE)lpobj2->hemf, lpobj2->sizeBytes, lpBytes2) != lpobj2->sizeBytes)
        goto errMemory;

    if (CmpGlobals (hBytes1, hBytes2))
        retval = OLE_OK;
    else
        retval = OLE_ERROR_NOT_EQUAL;

errMemory:
   if (lpBytes1)
      GlobalUnlock(lpBytes1);
   if (hBytes1)
      GlobalFree(hBytes1);

   if (lpBytes2)
      GlobalUnlock(lpBytes2);
   if (hBytes2)
      GlobalFree(hBytes2);

   return retval;
}


OLESTATUS FARINTERNAL  EmfCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;
    HENHMETAFILE hemf;

    if (!((HENHMETAFILE)hemf = CopyEnhMetaFile ((HENHMETAFILE)lpobj->hemf, NULL)))
        return OLE_ERROR_MEMORY;

    SetClipboardData(CF_ENHMETAFILE, hemf);

    return OLE_OK;
}



OLESTATUS FARINTERNAL EmfQueryBounds (
    LPOLEOBJECT lpoleobj,
    LPRECT      lpRc
){
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;

    Puts("EmfQueryBounds");

    if (!lpobj->hemf)
        return OLE_ERROR_BLANK;

    // Bounds are given in MM_HIMETRIC mode.

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;

}

OLECLIPFORMAT FARINTERNAL  EmfEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    UNREFERENCED_PARAMETER(lpoleobj);

    if (!cfFormat)
        return CF_ENHMETAFILE;

    return 0;
}


OLESTATUS FARINTERNAL EmfGetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    LPHANDLE      lphandle
){
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;

    if (cfFormat != CF_ENHMETAFILE)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hemf))
        return OLE_ERROR_BLANK;

    return OLE_OK;
}


LPOBJECT_EMF FARINTERNAL  EmfCreateObject (
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete,
    LHCLIENTDOC     lhclientdoc,
    LPCSTR          lpobjname,
    LONG            objType
){
    LPOBJECT_EMF     lpobj;

    if (lpobj = EmfCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (EmfChangeData ((LPOLEOBJECT)lpobj, hMeta, lpclient, fDelete) != OLE_OK) {
            EmfRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}

// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.

OLESTATUS FARINTERNAL EmfChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_EMF    lpobj   = (LPOBJECT_EMF)lpoleobj;
    DWORD           dwSizeBytes;
	
	 Puts("EmfChangeData");

    if (hMeta) {
       dwSizeBytes = lpobj->sizeBytes;
       if (lpobj->sizeBytes = GetEnhMetaFileBits(hMeta, 0, NULL)) {
         if (lpobj->hemf)
            DeleteEnhMetaFile ((HENHMETAFILE)lpobj->hemf);
         if (fDelete)
            lpobj->hemf = hMeta;
         else
            (HENHMETAFILE)lpobj->hemf = CopyEnhMetaFile(hMeta,NULL);
         lpobj->head.lpclient = lpclient;
         EmfSetExtents (lpobj);
         return OLE_OK;
       }
       else
         lpobj->sizeBytes = dwSizeBytes;
    }

    return OLE_ERROR_METAFILE;

}


LPOBJECT_EMF FARINTERNAL EmfCreateBlank(
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType
){
    HOBJECT     hobj;
    LPOBJECT_EMF lpobj;

    if(!(hobj = GlobalAlloc (GHND, sizeof(OBJECT_EMF))))
        return NULL;

    if (!(lpobj = (LPOBJECT_EMF) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    lpobj->head.ctype    = objType;
    lpobj->head.lpvtbl   = (LPOLEOBJECTVTBL)&vtblEMF;
    lpobj->head.iTable   = INVALID_INDEX;
    lpobj->head.hobj     = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                    (LPOLEOBJECT) lpobj, lpobjname);

    // Unlock will be done at object deletion time.
    return lpobj;
}


OLESTATUS  FARINTERNAL  EmfLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType
){
    LPOBJECT_EMF lpobj   = NULL;
    OLESTATUS    retval  = OLE_ERROR_STREAM;
    HANDLE       hBytes  = NULL;
    LPBYTE       lpBytes = NULL;

    // Class name would've been read by this time.

    *lplpobj = NULL;

    if (!(lpobj = EmfCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto error;

    if (!lpobj->sizeBytes) {
        retval = OLE_ERROR_BLANK;
        goto error;
    }

    retval = OLE_ERROR_MEMORY;
    if (!(hBytes = GlobalAlloc (GHND, lpobj->sizeBytes)))
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock (hBytes)))
        goto error;

    if (GetBytes (lpstream, (LPSTR)lpBytes, lpobj->sizeBytes))
        goto error;

    if (!((HENHMETAFILE)lpobj->hemf = SetEnhMetaFileBits (lpobj->sizeBytes,lpBytes)) )
        goto error;

    EmfSetExtents (lpobj);

    *lplpobj = (LPOLEOBJECT) lpobj;
    GlobalUnlock(hBytes);
    GlobalFree (hBytes);
    return OLE_OK;

error:
    if (lpBytes)
      GlobalUnlock(hBytes);
    if (hBytes)
      GlobalFree (hBytes);

    OleDelete ((LPOLEOBJECT)lpobj);
    return retval;
}

OLESTATUS FARINTERNAL  EmfPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HANDLE      hMeta;

    *lplpoleobject = NULL;

    if((hMeta = GetClipboardData (CF_ENHMETAFILE)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) EmfCreateObject (hMeta, lpclient,
                                                FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;
}

void FARINTERNAL EmfSetExtents (LPOBJECT_EMF lpobj)
{
    ENHMETAHEADER enhmetaheader;

    GetEnhMetaFileHeader((HENHMETAFILE)lpobj->hemf, sizeof(enhmetaheader), &enhmetaheader);

    lpobj->head.cx = enhmetaheader.rclFrame.right - enhmetaheader.rclFrame.left;
    lpobj->head.cy = enhmetaheader.rclFrame.top - enhmetaheader.rclFrame.bottom;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\ledde.c ===
/****************************** Module Header ******************************\
* Module Name: LEDDE.C
*
* Purpose: ?????
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik   (../../1990,91)  Designed and coded
*   curts created portable version for win16/32
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"
#include "pict.h"
#include "strsafe.h"

#define LN_FUDGE        16      // [],(), 3 * 3 (2 double quotes and comma)
#define RUNITEM

#define OLEVERB_CONNECT     0xFFFF

// Definitions for sending the server sys command.
char *srvrSysCmd[] = {"StdNewFromTemplate",
                      "StdNewDocument",
                      "StdEditDocument",
                      "StdOpenDocument"
                      };

#define EMB_ID_INDEX    11          // index of ones digit in #00
extern  char    embStr[];
extern  BOOL    gbCreateInvisible;
extern  BOOL    gbLaunchServer;

extern  ATOM    aMSDraw;

extern  BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// !!! set error hints

OLESTATUS FARINTERNAL LeDoVerb (
    LPOLEOBJECT lpoleobj,
    UINT        verb,
    BOOL        fShow,
    BOOL        fActivate
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->verb = verb;
    lpobj->fCmd = ACT_DOVERB;

    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_RUN, DOCSHOW);
    return DocShow (lpobj);
}



OLESTATUS FARINTERNAL LeShow (
   LPOLEOBJECT lpoleobj,
   BOOL        fActivate
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    UNREFERENCED_PARAMETER(fActivate);

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->fCmd = ACT_SHOW;
    InitAsyncCmd (lpobj, OLE_SHOW, DOCSHOW);
    return DocShow (lpobj);
}


// DocShow : If the server is connected, show the item
// for editing. For embedded objects us NULL Item.
OLESTATUS DocShow (LPOBJECT_LE lpobj)
{
    switch (lpobj->subRtn) {

        case 0:
            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


void SendStdShow (LPOBJECT_LE lpobj)
{
    UINT    len;
    UINT    size;
    LPSTR   lpdata = NULL;
    HANDLE  hdata = NULL;
    BOOL    bShow;

    lpobj->subErr = OLE_OK;

    if (lpobj->verb == OLEVERB_CONNECT) {
        lpobj->verb = 0;
        return;
    }

    if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB)))
        return;

    if (bShow = (!lpobj->bOleServer || !(lpobj->fCmd & ACT_DOVERB))) {

        // show is off, do not show the server.
        if (!(lpobj->fCmd & ACT_SHOW))
            return;

        SETERRHINT(lpobj, OLE_ERROR_SHOW);
        //  and 18 "[StdShowItem(\"")for 5 extra for ",FALSE
        len = 18 + 7;
    } else {
        // 19 for the string [StdDoVerbItem(\"") and
        // 18 extra is for ",000,FALSE,FALSE
        SETERRHINT(lpobj, OLE_ERROR_DOVERB);
        len = 19 + 18;
    }

    len += GlobalGetAtomLen (lpobj->item);

    len +=  4;                 // ")]" + NULL

    hdata = GlobalAlloc (GMEM_DDESHARE, size = len);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    if (bShow)
    {
        if (!SUCCEEDED(StringCchCopy(lpdata, size, "[StdShowItem(\"")))
            goto errRtn;
    }
    else
    {
        if (!SUCCEEDED(StringCchCopy(lpdata, size, "[StdDoVerbItem(\"")))
            goto errRtn;
    }

    len = lstrlen (lpdata);

    if (lpobj->item)
        GlobalGetAtomName (lpobj->item , lpdata + len, size - len);

    if (!bShow) {
        if (!SUCCEEDED(StringCchCat(lpdata, size, (LPSTR)"\",")))
            goto errRtn;
        // assume that the number of verbs are < 10

        len = lstrlen (lpdata);
        if (len < size - 1)
        {
            lpdata += len;
            *lpdata++ = (char)((lpobj->verb & 0x000f) + '0');
            *lpdata = 0;
        }
        else
            goto errRtn;

        if (lpobj->fCmd & ACT_SHOW)
        {
            if (!SUCCEEDED(StringCchCat(lpdata, size, (LPSTR) ",TRUE")))
                goto errRtn;
        }
        else
        {
            if (!SUCCEEDED(StringCchCat(lpdata, size, (LPSTR) ",FALSE")))
                goto errRtn;
        }
                // StdVerbItem (item, verb, TRUE
        // add TRUE/FALSE constant for the activate
        if (!(lpobj->fCmd & ACT_ACTIVATE))
        {
            if (!SUCCEEDED(StringCchCat(lpdata, size, (LPSTR) ",TRUE)]")))
                goto errRtn;
        }
        else
        {
            if (!SUCCEEDED(StringCchCat(lpdata, size, (LPSTR) ",FALSE)]")))
                goto errRtn;
        }
            // [StdDoVerb ("item", verb, FALSE, FALSE)]
    } 
    else
        if (!SUCCEEDED(StringCchCat(lpdata, size, (LPSTR)"\")]")))
                goto errRtn;
        // apps like excel and wingraph do not suuport activate at
        // item level.


    GlobalUnlock (hdata);
    DocExecute (lpobj, hdata);
    return;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);

    lpobj->subErr = OLE_ERROR_MEMORY;
    return;
}



OLESTATUS FARINTERNAL  LeQueryOpen (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (QueryOpen(lpobj))
       return OLE_OK;
    else
       return OLE_ERROR_NOT_OPEN;

}


BOOL    INTERNAL  QueryOpen (LPOBJECT_LE lpobj)
{

    if (lpobj->pDocEdit &&  lpobj->pDocEdit->hClient) {
        if (IsServerValid (lpobj))
            return TRUE;
        // destroy the windows and pretend as if the server was never
        // connected.

        DestroyWindow (lpobj->pDocEdit->hClient);
        if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
            DestroyWindow (lpobj->pSysEdit->hClient);

    }
    return FALSE;
}



OLESTATUS FARINTERNAL  LeActivate (
    LPOLEOBJECT lpoleobj,
    UINT        verb,
    BOOL        fShow,
    BOOL        fActivate,
    HWND        hWnd,
    OLE_CONST RECT FAR* lprc
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    lpobj->verb = verb;
    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbOpen (lpobj, fShow, fActivate, hWnd, (LPRECT)lprc);

    return LnkOpen (lpobj, fShow, fActivate, hWnd, (LPRECT)lprc);

}


OLESTATUS FARINTERNAL  LeUpdate (
    LPOLEOBJECT lpoleobj
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbUpdate (lpobj);

    return LnkUpdate (lpobj);
}



OLESTATUS FARINTERNAL  EmbOpen (
   LPOBJECT_LE lpobj,
   BOOL        fShow,
   BOOL        fActivate,
   HWND        hWnd,
   LPRECT      lprc
){
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if(QueryOpen (lpobj))
        return LeDoVerb ((LPOLEOBJECT)lpobj, lpobj->verb, fShow, fActivate);

    // show the window
    // advise for data only on close
    // and shut down the conv  after the advises.

    lpobj->fCmd = LN_EMBACT | ACT_DOVERB | ACT_ADVISE | ACT_CLOSE;
    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL  EmbUpdate (lpobj)
*
* This function updates an EMB object. If the server is connected
* simply send a request for the native as well as the display formats.
* If the server is connected, then tries to start the conversationa and
* get the data. If the conversation fails, then load the server and
* start the conversation. The embeded objects may have links in it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FARINTERNAL  EmbUpdate (LPOBJECT_LE lpobj)
{

    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    lpobj->fCmd = LN_EMBACT | ACT_REQUEST | (QueryOpen(lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



OLESTATUS FARINTERNAL  EmbOpenUpdate (LPOBJECT_LE lpobj)
{

    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step6);
            SendSrvrMainCmd  (lpobj, lpobj->lptemplate);
            lpobj->lptemplate = NULL;
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            // Init doc conversation should set the failure error
            if (!InitDocConv (lpobj, !POPUP_NETDLG))
                 goto errRtn;

            // If there is no native data, do not do any poke.
            // creates will not have any poke data to start with

            SKIP_TO (!(lpobj->hnative), step6);
            PokeNativeData (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            if (ProcessErr (lpobj))
                 goto errRtn;
            // Now poke the hostnames etc stuff.
            PokeHostNames (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 3:

            // do not worry about the poke hostname errors
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 4:

            PokeDocDimensions (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 5:

            PokeColorScheme (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 6:

            step6:

            // wingraph does not accept the  doc dimensions
            // after sttedit.
            CLEAR_STEP_ERROR (lpobj);
            SETSTEP (lpobj, 6);
            STEP_NOP (lpobj);
            // step_nop simply increments the step numebr
            // merge the steps later on



        case 7:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step13);
            lpobj->optUpdate = oleupdate_onsave;
            lpobj->pDocEdit->nAdviseSave = 0;
            AdviseOn (lpobj, cfNative, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 8:

            // do not go for errors on /save. Some servers may not support
            // this.

            CLEAR_STEP_ERROR (lpobj);
            AdvisePict (lpobj, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 9:

            // see if server will positive ack a metafile advise if enhmetafile
            // advise failed
            if (ChangeEMFtoMFneeded(lpobj,aSave))
               WAIT_FOR_ASYNC_MSG (lpobj);


        case 10:

            if (!lpobj->subErr && lpobj->bNewPict)
               if (!ChangeEMFtoMF(lpobj))
                  goto errRtn;

            // do not worry about the error case for save. Ignore them

            CLEAR_STEP_ERROR (lpobj);
            lpobj->optUpdate = oleupdate_onclose;
            lpobj->pDocEdit->nAdviseClose = 0;
            AdviseOn (lpobj, cfNative, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 11:
            if (ProcessErr(lpobj))
                goto errRtn;

            AdvisePict (lpobj, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 12:
            if (ChangeEMFtoMFneeded(lpobj,aClose))
               WAIT_FOR_ASYNC_MSG (lpobj);

        case 13:

            step13:
            SETSTEP (lpobj, 13);
            if (ProcessErr(lpobj))
                goto errRtn;

            if (lpobj->bNewPict && !ChangeEMFtoMF(lpobj))
                  goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step15);

            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

            // If request pict fails, then native and pict are
            // not in sync.

        case 14:
            if (ProcessErr(lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 15:

            step15:
            SETSTEP(lpobj, 15);

            if (ProcessErr(lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 16:


            if (ProcessErr(lpobj))
                goto errRtn;

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step17);
            return EndAsyncCmd (lpobj);


        case 17:

errRtn:
            step17:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE)
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);

            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;


      default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}




OLESTATUS FARINTERNAL  LnkOpen (
   LPOBJECT_LE lpobj,
   BOOL        fShow,
   BOOL        fActivate,
   HWND        hWnd,
   LPRECT      lprc
){
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if(QueryOpen (lpobj))
        return LeDoVerb ((LPOLEOBJECT)lpobj, lpobj->verb, fShow, fActivate);

    // Just end the system conversation. we are not unloading
    // this instance at all.

    lpobj->fCmd = LN_LNKACT |  ACT_DOVERB;

    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;
    else if (lpobj->optUpdate == oleupdate_onsave)
        lpobj->fCmd |= ACT_ADVISE;

    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);

}


OLESTATUS FARINTERNAL  LnkUpdate (LPOBJECT_LE lpobj)
{
    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    lpobj->fCmd = LN_LNKACT | ACT_REQUEST | (QueryOpen (lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}



OLESTATUS FARINTERNAL  LnkOpenUpdate (LPOBJECT_LE lpobj)
{
    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step2);
            InitDocConv (lpobj, !POPUP_NETDLG);
            if (QueryOpen(lpobj)) {
                if (lpobj->app == aPackage)
                    RemoveLinkStringFromTopic (lpobj);
                goto step2;
            }

            SendSrvrMainCmd (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            if (lpobj->app == aPackage)
                RemoveLinkStringFromTopic (lpobj);

            if (!InitDocConv (lpobj, POPUP_NETDLG)) {
                lpobj->subErr = OLE_ERROR_OPEN;
                goto errRtn;
            }

        case 2:

            step2:

            SETSTEP (lpobj, 2);
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 3:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step7);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step4);
            AdviseOn (lpobj, cfNative, (ATOM)0);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 4:
            step4:
            SETSTEP  (lpobj, 4);
            if (ProcessErr (lpobj))
                goto errRtn;

            AdvisePict (lpobj, (ATOM)0);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 5:

            // see if server will positive ack a metafile advise if enhmetafile
            // advise failed
            if (ChangeEMFtoMFneeded(lpobj,(ATOM)0))
               WAIT_FOR_ASYNC_MSG (lpobj);

       case 6:

            if (ProcessErr (lpobj))
                goto errRtn;

            if (lpobj->bNewPict && !ChangeEMFtoMF(lpobj))
                goto errRtn;

            // Now send advise for renaming the documnet.
            AdviseOn (lpobj, cfBinary, aStdDocName);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 7:

            step7:
            // if name advise fails ignore it
            SETSTEP (lpobj, 7);

            CLEAR_STEP_ERROR (lpobj);
            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step9);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step8);

            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 8:
            step8:

            SETSTEP (lpobj, 8);
            if (ProcessErr (lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 9:

            step9:
			
   			if (lpobj->subErr && CF_ENHMETAFILE == GetPictType(lpobj)) {
      	   		CLEAR_STEP_ERROR (lpobj);

               	if (!ChangeEMFtoMF(lpobj))
               		goto errRtn;
				
               	RequestPict (lpobj);
               	WAIT_FOR_ASYNC_MSG (lpobj);

   			}

            else if (ProcessErr (lpobj))
                goto errRtn;

            SETSTEP     (lpobj, 9);
			
            SKIP_TO (!(lpobj->fCmd & ACT_TERMDOC), step11);
            // terminate the document conversataion.
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 10:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteDocEdit (lpobj);

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step15);
            return EndAsyncCmd (lpobj);

      case 11:

            step11:
            SETSTEP     (lpobj, 11);

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_TERMSRVR), step13);

            // terminate the server conversataion.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 12:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


      case 13:

            step13:
            SETSTEP     (lpobj, 13);
            if (ProcessErr (lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 14:

            if (ProcessErr (lpobj))
                goto errRtn;
            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step15);
            return EndAsyncCmd (lpobj);


      case 15:

            errRtn:
            step15:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE)
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);

            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;

       default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



OLESTATUS EmbLnkClose (LPOBJECT_LE lpobj)
{
    switch (lpobj->subRtn) {

        case    0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS FARINTERNAL  LeClose (
   LPOLEOBJECT lpoleobj
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    PROBE_ASYNC (lpobj);
    if (IS_SVRCLOSING(lpobj))
        return OLE_OK;


    lpobj->fCmd = 0;

    if (lpobj->head.ctype == CT_EMBEDDED) {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKDELETE);
        return EmbLnkDelete (lpobj);
    }
    else {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKCLOSE);
        return EmbLnkClose (lpobj);
    }
}



OLESTATUS FARINTERNAL  LeReconnect (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // check for the existing conversation.
    // if the client window is non-null, then
    // connection exits.

    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;     // allow only for linked

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (QueryOpen (lpobj))
        return OLE_OK;

    // start just the conversation. Do not load
    // the app.

    if (!InitDocConv (lpobj, !POPUP_NETDLG))
         return OLE_OK;             // document is not loaded , it is OK.

    lpobj->fCmd = LN_LNKACT;
    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;

    InitAsyncCmd (lpobj, OLE_RECONNECT, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}




OLESTATUS INTERNAL PokeNativeData (LPOBJECT_LE lpobj)
{
   SETERRHINT(lpobj, OLE_ERROR_POKE_NATIVE);
   return SendPokeData (
            lpobj,
            lpobj->item,
            lpobj->hnative,
            cfNative
   );
}




BOOL INTERNAL PostMessageToServer (
   PEDIT_DDE   pedit,
   UINT        msg,
   LPARAM      lparam
){

    // save the lparam and msg fpr possible reposting incase of error.

    // we are in abort state.  no messages except for terminate.

    if (pedit->bAbort && msg != WM_DDE_TERMINATE)
        return FALSE;

    pedit->lParam = lparam;
    pedit->msg    = msg;

    if (pedit->hClient && pedit->hServer) {
        while (TRUE){
            if (!IsWindowValid (pedit->hServer))
                return FALSE;
            if (PostMessage (pedit->hServer, msg, (WPARAM)pedit->hClient, lparam) == FALSE)
                Yield ();
            else
                return TRUE;
        }
    }
    return FALSE;
}


OLESTATUS FARINTERNAL LeCreateFromTemplate (
    LPOLECLIENT         lpclient,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    char            buf[MAX_STR];

    if (!MapExtToClass (lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;

    return CreateFromClassOrTemplate (lpclient, (LPSTR) buf, lplpoleobject,
                        optRender, cfFormat, LN_TEMPLATE, lptemplate,
                        lhclientdoc, lpobjname);
}


OLESTATUS FARINTERNAL LeCreate (
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    if (gbCreateInvisible) {
        // this is in fact a call for invisible create
        return LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname,
                        lplpoleobject, optRender, cfFormat, gbLaunchServer);
    }

    return CreateFromClassOrTemplate (lpclient, lpclass, lplpoleobject,
                        optRender, cfFormat, LN_NEW, NULL,
                        lhclientdoc, lpobjname);
}



OLESTATUS FARINTERNAL CreateFromClassOrTemplate (
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    UINT                lnType,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname
){
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [32];

    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;

    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }

    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    SetEmbeddedTopic (lpobj);
    lpobj->item          = (ATOM)0;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 32);
    lpobj->aServer       = aServer;

    // launch the app and start the system conversation.

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj,
                optRender, cfFormat, lpclass))
        goto errRtn;


    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = (UINT)(lnType | ACT_SHOW | ACT_ADVISE | ACT_CLOSE);
    InitAsyncCmd (lpobj, lptemplate? OLE_CREATEFROMTEMPLATE : OLE_CREATE, EMBOPENUPDATE);
    *lplpoleobject = (LPOLEOBJECT)lpobj;

    lpobj->lptemplate = lptemplate;

    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }

    return retval;
}



OLESTATUS FARINTERNAL CreateEmbLnkFromFile (
   LPOLECLIENT         lpclient,
   LPCSTR              lpclass,
   LPSTR               lpfile,
   LPSTR               lpitem,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpoleobject,
   OLEOPT_RENDER       optRender,
   OLECLIPFORMAT       cfFormat,
   LONG                objType
){
    OLESTATUS           retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE         lpobj = NULL;
    ATOM                aServer;
    char                buf[MAX_STR];
    OLE_RELEASE_METHOD  releaseMethod;
    UINT                wFlags = 0;
    char                chVerb[32];

    if (!lpclass && (lpclass = (LPSTR) buf)
            && !MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;

    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK))) {
        GlobalDeleteAtom (aServer);
        goto errFileCreate;
    }

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->topic         = GlobalAddAtom (lpfile);
    lpobj->aServer       = aServer;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 32);
    if ((retval = SetNetName (lpobj)) != OLE_OK)
        goto errFileCreate;

    if (lpitem)
        lpobj->item = GlobalAddAtom (lpitem);

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj,
                optRender, cfFormat, lpclass)) {
        retval = OLE_ERROR_MEMORY;
        goto errFileCreate;
    }

    *lplpoleobject = (LPOLEOBJECT) lpobj;

    if (objType == CT_EMBEDDED) {
        releaseMethod = OLE_CREATEFROMFILE;
        if ((optRender == olerender_format) && (cfFormat == cfNative))
            wFlags = 0;
        else
            wFlags = ACT_NATIVE;
    }
    else {
        // caller wants linked object to be created

        // if no presentation data is requested and the link is to the whole
        // file, then there is no need to launch the server.

        if ((optRender == olerender_none) && !lpobj->item)
            return FileExists (lpobj);

        // we want to establish hot link
        wFlags = ACT_ADVISE;
        releaseMethod = OLE_CREATELINKFROMFILE;
    }

    lpobj->fCmd = (UINT)(LN_LNKACT | ACT_REQUEST | ACT_UNLAUNCH | wFlags);
    InitAsyncCmd (lpobj, releaseMethod , LNKOPENUPDATE);

    if ((retval = LnkOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.


errFileCreate:

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }

    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FARINTERNAL LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bActivate)
//
//  Arguments:
//
//     lpclient -
//     lpclass  -
//     lhclientdoc  -
//     lpobjname    -
//     lplpoleobject    -
//     optRender    -
//     cfFormat -
//     fActivate    -
//
//  Returns:
//
//      OLE_ERROR_CLASS -
//      OLE_OK  -
//      EmbOpenUpdate (lpobj)   -
//      retval  -
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeCreateInvisible (
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                fActivate
){
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [32];

    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;

    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }

    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->item          = (ATOM)0;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 32);
    lpobj->aServer       = aServer;
    lpobj->lptemplate    = NULL;
    SetEmbeddedTopic (lpobj);

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj,
                optRender, cfFormat, lpclass))
        goto errRtn;

    *lplpoleobject = (LPOLEOBJECT)lpobj;

    if (!fActivate)
        return OLE_OK;

    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = LN_NEW | ACT_ADVISE | ACT_CLOSE;
    InitAsyncCmd (lpobj, OLE_CREATEINVISIBLE, EMBOPENUPDATE);

    // launch the app and start the system conversation.
    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }

    return retval;
}



// LeSetUpdateOptions: sets the update options. If the server
// is connectd then it unadvises for the current options and
// advises for the new options.

OLESTATUS   FARINTERNAL LeSetUpdateOptions (
    LPOLEOBJECT         lpoleobj,
    OLEOPT_UPDATE       options
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    PROBE_OLDLINK (lpobj);
    PROBE_ASYNC (lpobj);

    //!!! make sure the options are within range.

    if (lpobj->head.ctype != CT_LINK)
        return (OLE_ERROR_OBJECT);

    if (options > oleupdate_oncall)
        return OLE_ERROR_OPTION;

    if (lpobj->optUpdate == options)
        return OLE_OK;

    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
       lpobj->optUpdate = options;
       return OLE_OK;
    }

    lpobj->optNew = options;
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETUPDATEOPTIONS, LNKSETUPDATEOPTIONS);
    return LnkSetUpdateOptions (lpobj);

}

OLESTATUS   LnkSetUpdateOptions (LPOBJECT_LE lpobj)
{

    switch (lpobj->subRtn) {

        case 0:

            if (lpobj->optUpdate == oleupdate_oncall)
                goto step1;

            // If the server is active then unadvise for old
            // options.

            UnAdvisePict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            step1:

            SETSTEP (lpobj, 1);
            ProcessErr (lpobj);

            lpobj->optUpdate = lpobj->optNew;
            if (lpobj->optUpdate == oleupdate_oncall)
                goto step3;

            AdvisePict (lpobj, (ATOM)0);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            SETSTEP (lpobj, 2);
            if (ProcessErr (lpobj))
                goto errRtn;

            if (lpobj->optUpdate == oleupdate_onsave)
                goto step3;

            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 3:
            errRtn:
            step3:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



//AdvisePict: Sends advise for pict data

void    INTERNAL AdvisePict (
    LPOBJECT_LE lpobj,
    ATOM        aAdvItem
){
    int         cftype;

    if (cftype = GetPictType (lpobj))
        AdviseOn (lpobj, cftype, aAdvItem);
}


//UnAdvisePict: Sends unadvise for pict data

void   INTERNAL UnAdvisePict (LPOBJECT_LE lpobj)
{
    int         cftype;

    SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);
    if (cftype = GetPictType (lpobj))
         UnAdviseOn (lpobj, cftype);
}

// GetPictType: Given the object, returns the pict type.

int     INTERNAL GetPictType (LPOBJECT_LE lpobj)
{
    if (lpobj->lpobjPict)
        return (int)(*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, 0);
    return 0;
}


// AdviseOn : Sends advise for a given picture type
// Send advise only if the advise options is not on call.

void  INTERNAL AdviseOn (
    LPOBJECT_LE lpobj,
    int         cftype,
    ATOM        advItem
){
    HANDLE          hopt   = NULL;
    DDEADVISE FAR   *lpopt = NULL;
    ATOM            item   = (ATOM)0;
    PEDIT_DDE       pedit;
    OLESTATUS       retval= OLE_ERROR_MEMORY;
    LPARAM          lParamNew;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_ADVISE_NATIVE);
    else {
        if (cftype == (int)cfBinary)
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_RENAME);
        else
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);

    }

    if (lpobj->optUpdate == oleupdate_oncall)
        return;

    if(!(hopt = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof(DDEADVISE))))
        goto errRtn;

    retval = OLE_ERROR_MEMORY;
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    pedit = lpobj->pDocEdit;
    lpopt->fAckReq = TRUE;

    // get data always. Currently there is no way for the
    // deferred updates.

    lpopt->fDeferUpd = 0;
    lpopt->cfFormat = (WORD)cftype;
    GlobalUnlock (hopt);

    pedit->hopt = hopt;

    if (advItem == aStdDocName)
        item = DuplicateAtom (advItem);
    else
        item = ExtendAtom (lpobj, lpobj->item);

    retval = OLE_ERROR_COMM;
    if (!PostMessageToServer(pedit, WM_DDE_ADVISE,
               lParamNew = MAKE_DDE_LPARAM(WM_DDE_ADVISE, (UINT_PTR)hopt, item)))
    {
        DDEFREE(WM_DDE_ADVISE,lParamNew);
        goto errRtn;
    }

    pedit->awaitAck = AA_ADVISE;
    lpobj->bAsync    = TRUE;

    if (advItem == aClose)
       lpobj->pDocEdit->nAdviseClose++;
    else if (advItem == aSave)
       lpobj->pDocEdit->nAdviseSave++;

    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);

    if (lpopt)
        GlobalUnlock (hopt);

    if (hopt)
        GlobalFree (hopt);
    lpobj->subErr = retval;

    return ;


}



//UnAdviseOn: Sends unadvise for an item.
void INTERNAL UnAdviseOn (
    LPOBJECT_LE lpobj,
    int         cftype
){
    ATOM        item;
    PEDIT_DDE   pedit;

    UNREFERENCED_PARAMETER(cftype);

    pedit  =  lpobj->pDocEdit;
    item    = ExtendAtom (lpobj, lpobj->item);

    if (!PostMessageToServer(pedit, WM_DDE_UNADVISE, MAKELONG (NULL, item)))
        lpobj->subErr = OLE_ERROR_COMM;
    else {
        lpobj->bAsync   = TRUE;
        pedit->awaitAck = AA_UNADVISE;
    }
}

// RequestOn: Semd WM_DDE_REQUEST for the item of the
// for a given type;

void INTERNAL RequestOn (
    LPOBJECT_LE lpobj,
    int         cftype
){
    ATOM        item = (ATOM)0;
    PEDIT_DDE   pedit;
    OLESTATUS   retval = OLE_ERROR_COMM;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_NATIVE);
    else
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_PICT);

    pedit = lpobj->pDocEdit;

    item = DuplicateAtom (lpobj->item);
    if (!PostMessageToServer (pedit, WM_DDE_REQUEST, MAKELONG (cftype, item)))
        goto errRtn;


    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_REQUEST;
    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);
    return ;

}


//RequestPict: Sends request for apicture type.
void INTERNAL RequestPict (LPOBJECT_LE lpobj)
{
    int cftype;

    if (cftype = GetPictType (lpobj))
        RequestOn (lpobj, cftype);
}



// LeSetHostNames: Sets the host names. If the server is connected
// send the host names to the server.
OLESTATUS FARINTERNAL  LeSetHostNames (
    LPOLEOBJECT    lpoleobj,
    OLE_LPCSTR     lpclientName,
    OLE_LPCSTR     lpdocName
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS   retval = OLE_ERROR_MEMORY;

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);
    if ((retval = SetHostNamesHandle (lpobj, (LPSTR)lpclientName, (LPSTR)lpdocName))
            != OLE_OK)
        return retval;


    // If the server is connected poke the hostnames
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeHostNames (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



OLESTATUS   FARINTERNAL  LeSetTargetDevice (
    LPOLEOBJECT lpoleobj,
    HANDLE      hdata
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    HANDLE      hdup = NULL;
    OLESTATUS   retval;

    PROBE_ASYNC (lpobj);

    if(!(hdup = DuplicateGlobal (hdata, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    if (lpobj->htargetDevice)
        GlobalFree (lpobj->htargetDevice);

    lpobj->htargetDevice = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeTargetDeviceInfo (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



OLESTATUS FARINTERNAL  LeSetBounds(
    LPOLEOBJECT         lpoleobj,
    OLE_CONST RECT FAR* lprcBounds
){
    LPOBJECT_LE     lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    HANDLE          hdata = NULL;
    LPBOUNDSRECT    lprc  = NULL;

    PROBE_ASYNC (lpobj);

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    if(!(hdata = GlobalAlloc (GMEM_MOVEABLE, (UINT)sizeof (BOUNDSRECT))))
        return OLE_ERROR_MEMORY;

    if (!(lprc = (LPBOUNDSRECT)GlobalLock (hdata)))
        goto errrtn;

    //
    // Now set the data
    //
    // Note: The 16-bit implementations are expecting USHORT sized values
    // Actually, they are expected a 16-bit RECT which is 4 ints. Why we
    // are sending a LPBOUNDSRECT instead of a 16-bit RECT is a mystery,
    // but thats the backward compatible story.
    //

    lprc->defaultWidth    = (USHORT) (lprcBounds->right  - lprcBounds->left);
    lprc->defaultHeight   = (USHORT) -(lprcBounds->bottom - lprcBounds->top);
    lprc->maxWidth        = (USHORT) (lprcBounds->right  - lprcBounds->left);
    lprc->maxHeight       = (USHORT) -(lprcBounds->bottom - lprcBounds->top);

    GlobalUnlock (hdata);

    if (lpobj->hdocDimensions)
        GlobalFree (lpobj->hdocDimensions);

    lpobj->hdocDimensions = hdata;
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeDocDimensions (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;

errrtn:
    if (lprc)
        GlobalUnlock (hdata);
    if (hdata)
        GlobalFree (hdata);

    return retval;
}


OLESTATUS FARINTERNAL LeSetData (
    LPOLEOBJECT     lpoleobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE          hData
){
    LPOBJECT_LE     lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS       retVal = OLE_OK;
    BOOL            fKnown = FALSE;

    PROBE_ASYNC (lpobj);

    if ((cfFormat == cfObjectLink) || (cfFormat == cfOwnerLink))
        return ChangeDocAndItem (lpobj, hData);

    if (fKnown = (cfFormat && (cfFormat == (OLECLIPFORMAT)GetPictType (lpobj)))) {
        retVal =  (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                                    hData, lpobj->head.lpclient, FALSE);

        (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict,
                                cfFormat, &hData);
    }
    else if (fKnown = (cfFormat == cfNative)) {
        retVal = LeChangeData (lpoleobj, hData, lpobj->head.lpclient, FALSE);
        hData = lpobj->hnative;
    }

    if (retVal != OLE_OK)
        return retVal;

    if (fKnown)
        ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CHANGED);

    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
        if (!fKnown)
            return OLE_ERROR_NOT_OPEN;
        return OLE_OK;
    }

    // except for the following formats all the other data will be copied
    // into DDEPOKE block. So there is no need to duplicate the data of the
    // other formats
    if (  cfFormat == CF_METAFILEPICT
          || cfFormat == CF_ENHMETAFILE
          || cfFormat == CF_BITMAP
          || cfFormat == CF_DIB)
    {

        if (!(hData = DuplicateGDIdata (hData, cfFormat)))
            return OLE_ERROR_MEMORY;
    }

    // *** The last parameter must be NULL, don't change it ***
    InitAsyncCmd (lpobj, OLE_SETDATA, 0);
    if ((retVal = SendPokeData (lpobj, lpobj->item, hData, cfFormat))
            != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retVal;
}



OLESTATUS   FARINTERNAL  LeSetColorScheme (
    LPOLEOBJECT               lpoleobj,
    OLE_CONST LOGPALETTE FAR* lplogpal
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    HANDLE      hdup = NULL;
    DWORD       cblogpal;
    OLESTATUS   retval;
    LPBYTE      lptemp;

    lptemp = (LPBYTE) lplogpal;

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);

    FARPROBE_READ(lptemp + (cblogpal = 2*sizeof(UINT)));
    cblogpal += ((sizeof(PALETTEENTRY) * lplogpal->palNumEntries) -1);
    if (!FarCheckPointer (lptemp + cblogpal, READ_ACCESS))
        return OLE_ERROR_PALETTE;

    if (!(hdup = CopyData ((LPSTR) lplogpal, cblogpal)))
        return OLE_ERROR_MEMORY;

    if (lpobj->hlogpal)
        GlobalFree (lpobj->hlogpal);

    lpobj->hlogpal = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeColorScheme (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



//PokeHostNames: Pokes hostname data to the server
OLESTATUS INTERNAL PokeHostNames (LPOBJECT_LE lpobj)
{
    OLESTATUS   retVal = OLE_ERROR_MEMORY;

    // if the server is connectd then poke the host names
    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

    if (!lpobj->hhostNames)
        return OLE_OK;

    aStdHostNames = GlobalAddAtom ("StdHostNames");
    return SendPokeData (lpobj,aStdHostNames,lpobj->hhostNames,cfBinary);
}


OLESTATUS INTERNAL  PokeTargetDeviceInfo (LPOBJECT_LE lpobj)
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->htargetDevice)
        return OLE_OK;

   aStdTargetDevice = GlobalAddAtom ("StdTargetDevice");
   return SendPokeData (lpobj, aStdTargetDevice,
                    lpobj->htargetDevice,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeDocDimensions (LPOBJECT_LE lpobj)
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hdocDimensions)
        return OLE_OK;

   aStdDocDimensions = GlobalAddAtom ("StdDocDimensions");
   return SendPokeData (lpobj, aStdDocDimensions,
                    lpobj->hdocDimensions,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeColorScheme (LPOBJECT_LE lpobj)
{
   // if the server is connected then poke the palette info
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hlogpal)
        return OLE_OK;

   aStdColorScheme = GlobalAddAtom ("StdColorScheme");
   return SendPokeData (lpobj, aStdColorScheme,
                    lpobj->hlogpal,
                    cfBinary);
}


OLESTATUS INTERNAL SendPokeData (
    LPOBJECT_LE     lpobj,
    ATOM            aItem,
    HANDLE          hdata,
    OLECLIPFORMAT   cfFormat
){
    HANDLE      hdde = NULL;
    DDEPOKE FAR * lpdde = NULL;
    LPSTR       lpdst = NULL;
    LPSTR       lpsrc = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    DWORD       dwSize = 0;
    PEDIT_DDE   pedit;
    BOOL        bGDIdata = FALSE;
    LPARAM      lParamNew;

    pedit = lpobj->pDocEdit;

    // If it is GDI data then we can stuff the handle into POKE block.
    // Otherwise we have to copy the data into DDE data block. There
    // is a special case with old MSDraw, that will be handled by
    // the routine CanPutHandleInPokeBlock()

    if (!(bGDIdata = CanPutHandleInPokeBlock (lpobj, cfFormat))) {
        if (!(dwSize = (DWORD)GlobalSize (hdata)))
            return OLE_ERROR_MEMORY;

        if (!(lpsrc = (LPSTR) GlobalLock (hdata)))
            return OLE_ERROR_MEMORY;

        GlobalUnlock (hdata);
    }

    // Now allocate the DDE data block

    if (!(hdde = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT,
                 (dwSize + sizeof(DDEPOKE) - sizeof(BYTE) + sizeof(HANDLE)))))
        goto errRtn;

    if (!(lpdde = (DDEPOKE FAR *)GlobalLock (hdde)))
        goto errRtn;

    GlobalUnlock (hdde);

    // !!! We may want to set it TRUE, for performance reasons. But it
    // will require some rework on the server side
    lpdde->fRelease = 0;
    lpdde->cfFormat = (WORD)cfFormat;

    if (bGDIdata) {
#ifdef _WIN64
        if (lpdde->cfFormat == CF_METAFILEPICT)
            *(void* _unaligned*)lpdde->Value = hdata;
        else
#endif
            *(LONG*)lpdde->Value = HandleToLong(hdata);

    } else {
        lpdst = (LPSTR)lpdde->Value;
        UtilMemCpy (lpdst, lpsrc, dwSize);

        // For the CF_METAFILEPICT format, we would come here only if we are
        // dealing with the old version of MSDraw. In that case we want to
        // free the handle to METAFILEPICT strcuture, because we've already
        // copied its contents to DDEPOKE structure.

        // Note that that the old MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (cfFormat == CF_METAFILEPICT) {
            GlobalFree (hdata);
            hdata = NULL;
        }
    }

    // *** From here onwards if there is an error call FreePokeData(), don't
    // jump to errRtn

    aItem = DuplicateAtom (aItem);

    ASSERT(pedit->hData == NULL, "Poke data is not null");

    pedit->hData = hdde;
    if (!PostMessageToServer (pedit, WM_DDE_POKE,
            lParamNew = MAKE_DDE_LPARAM(WM_DDE_POKE, (UINT_PTR)hdde, aItem)))
   {
        if (aItem)
            GlobalDeleteAtom (aItem);
        FreePokeData (lpobj, pedit);
        DDEFREE(WM_DDE_POKE,lParamNew);
        return (lpobj->subErr = OLE_ERROR_COMM);
    }

    if (lpobj->asyncCmd == OLE_NONE)
        lpobj->asyncCmd = OLE_OTHER;

    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_POKE;
    // !!! after poke of the hostnames etc. we are not processing error.,

    // Data is freed after the Poke is acknowledged. OLE_RELEASE will be sent
    // to when ACK comes.

    return OLE_WAIT_FOR_RELEASE;

errRtn:
    if (hdata)
        FreeGDIdata (hdata, cfFormat);

    if (hdde)
        GlobalFree (hdde);

    pedit->hData = NULL;

    return (lpobj->subErr = retval);
}



// FreePokeData: Frees the poked data.
void  INTERNAL FreePokeData (
    LPOBJECT_LE lpobj,
    PEDIT_DDE   pedit
){
    DDEPOKE FAR * lpdde;


    if (lpdde = (DDEPOKE FAR *) GlobalLock (pedit->hData)) {
        GlobalUnlock (pedit->hData);

        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && (lpobj->app == aMSDraw)
                && (lpdde->cfFormat == CF_METAFILEPICT)) {
            DeleteMetaFile (((LPMETAFILEPICT) ((LPSTR) &lpdde->Value))->hMF);
        }
        else {
#ifdef _WIN64
            if (lpdde->cfFormat == CF_METAFILEPICT)
                FreeGDIdata(*(void* _unaligned*)lpdde->Value, lpdde->cfFormat);
            else
#endif
                FreeGDIdata (LongToHandle(*(LONG*)lpdde->Value), lpdde->cfFormat);
        }
    }

    GlobalFree (pedit->hData);
    pedit->hData = NULL;
}



BOOL INTERNAL  SendSrvrMainCmd (
    LPOBJECT_LE lpobj,
    LPSTR       lptemplate
){
    UINT        size;
    UINT        len;
    OLESTATUS   retval = OLE_ERROR_COMM;
    int         cmd = 0;
    HANDLE      hInst = NULL;
    LPSTR       lpdata= NULL;
    HANDLE      hdata = NULL;
    BOOL        bLaunch = TRUE;

    Puts("Launch App and Send Sys command");


    if (!lpobj->aServer) {
        retval = OLE_ERROR_REGISTRATION;
        goto errRtn;
    }

    if (!lpobj->bOldLink) {
        bLaunch = !(lpobj->fCmd & ACT_NOLAUNCH);
        cmd = lpobj->fCmd & LN_MASK;
    }

    if (cmd == LN_LNKACT) {
        // take care of network based document
        char    cDrive = lpobj->cDrive;

        if ((retval = CheckNetDrive (lpobj, POPUP_NETDLG)) != OLE_OK) {
            lpobj->cDrive = cDrive;
            goto errRtn;
        }

        if (cDrive != lpobj->cDrive)
            ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RENAMED);
    }

    if (!InitSrvrConv (lpobj, hInst)) {

        if (!bLaunch)
            goto errRtn;

        if (!(hInst = LeLaunchApp (lpobj))) {
            // We failed to launch the app. If it is a linked object, see
            // whether the docname is valid for new servers.  We wouldn't
            // have given the doc name on the command line for the old
            // servers. So, there is no point in checking for file existance
            // in that case.
            if (lpobj->bOleServer && (lpobj->bOldLink || (cmd == LN_LNKACT))){
                if ((retval = FileExists (lpobj)) != OLE_OK)
                    goto errRtn;
            }

            retval = OLE_ERROR_LAUNCH;
            goto errRtn;
        }

        if (lpobj->bOldLink)
            return TRUE;

        if (lpobj->bOleServer && (cmd == LN_LNKACT)) {
            // We are not using any data blocks if the object is old link.
            // we launched with docname, and don't have to establish system
            // level and also we don't have to send exec strings.

            // for non-ole servers like excel, we do want to connect at
            // the system level, so that we can send "StdOpen". We also
            // have to send "StdExit" for the server to exit in the
            // invisible launch case.

            return TRUE;
        }

        retval = OLE_ERROR_COMM;
        if(!InitSrvrConv (lpobj, hInst))
            goto errRtn;
#ifdef OLD
        if (!lpobj->bOleServer && (cmd == LN_LNKACT))
            return TRUE;
#endif
    }

    if (!lpobj->bOldLink) {
        cmd = lpobj->fCmd & LN_MASK;
        len =  lstrlen (srvrSysCmd[cmd >> LN_SHIFT]);

        // for template and new, add the class name also
        if (cmd == LN_NEW || cmd == LN_TEMPLATE)
            len += GlobalGetAtomLen (lpobj->app);

        // Now add the document length.
        len += GlobalGetAtomLen (lpobj->topic);

        // add the length of the template name
        if (lptemplate)
            len += lstrlen (lptemplate);

        // now add the fudge factor for the Quotes etc.
        len += LN_FUDGE;

        // allocate the buffer and set the command.
        hdata = GlobalAlloc (GMEM_DDESHARE, size = len);

        retval = OLE_ERROR_MEMORY;
        SETERRHINT(lpobj, OLE_ERROR_MEMORY);

        if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
            goto errRtn;
    }

    if (!SUCCEEDED(StringCchCopy(lpdata, size, (LPSTR)"[")))           // [
	goto errRtn;
    if (!SUCCEEDED(StringCchCat(lpdata, size, srvrSysCmd[cmd >> LN_SHIFT])))      // [Std....
	goto errRtn;
    if (!SUCCEEDED(StringCchCat(lpdata, size, "(\"")))                // [std...("
	goto errRtn;

    if (cmd == LN_NEW  || cmd == LN_TEMPLATE) {
        len = lstrlen (lpdata);
        GlobalGetAtomName (lpobj->app, (LPSTR)lpdata + len, size - len);
                                            // [std...("class
        if (!SUCCEEDED(StringCchCat(lpdata, size, "\",\"")))          // [std...("class", "
            goto errRtn;
    }
    len = lstrlen (lpdata);
    // now get the topic name.
    GlobalGetAtomName (lpobj->topic, lpdata + len, (UINT)size - len);
                                            // [std...("class","doc
    if (lptemplate) {
        if (!SUCCEEDED(StringCchCat(lpdata, size, "\",\"")))          // [std...("class","doc","
            goto errRtn;
        if (!SUCCEEDED(StringCchCat(lpdata, size, lptemplate)))      // [std...("class","doc","temp
            goto errRtn;
    }

   if (!SUCCEEDED(StringCchCat(lpdata, size, "\")]")))               // [std...("class","doc","temp")]
	goto errRtn;

    GlobalUnlock (hdata);

    // !!!optimize with mapping.
    SETERRHINT(lpobj, (OLE_ERROR_TEMPLATE + (cmd >> LN_SHIFT)));

    return SrvrExecute (lpobj, hdata);

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    lpobj->subErr = retval;
    return FALSE;
}




// ExtendAtom: Create a new atom, which is the old one plus extension

ATOM INTERNAL ExtendAtom (
    LPOBJECT_LE lpobj,
    ATOM    item
){
    char    buffer[MAX_ATOM+1];
    LPSTR   lpext;

    Puts("ExtendAtom");

    buffer[0] = 0;
    if (item)
        GlobalGetAtomName (item, buffer, MAX_ATOM);

    switch (lpobj->optUpdate) {


        case oleupdate_always:
            lpext = (LPSTR)"";
            break;

        case oleupdate_onsave:
            lpext = (LPSTR)"/Save";
            break;

        case oleupdate_onclose:
            lpext = (LPSTR)"/Close";
            break;

        default:
            ASSERT (FALSE, "on call options not expected here");
            break;

    }

    if (!SUCCEEDED(StringCchCat(buffer, MAX_ATOM+1, lpext)))
        goto errRtn;
    if (buffer[0])
        return GlobalAddAtom (buffer);

errRtn:
        return (ATOM)0;
}


BOOL INTERNAL CreatePictObject (
    LHCLIENTDOC     lhclientdoc,
    LPSTR           lpobjname,
    LPOBJECT_LE     lpobj,
    OLEOPT_RENDER   optRender,
    OLECLIPFORMAT   cfFormat,
    LPCSTR          lpclass
){
    LPOLEOBJECT lpPictObj = NULL;
    ATOM        aClass;

    lpobj->lpobjPict = NULL;
    if (optRender == olerender_format) {
        switch (cfFormat) {
            case 0:
                return FALSE;

            case CF_ENHMETAFILE:
                if (!(lpPictObj = (LPOLEOBJECT) EmfCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE)))
                return FALSE;

            case CF_METAFILEPICT:
                if (!(lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;

            case CF_DIB:
                if (!(lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;

            case CF_BITMAP:
                if (!(lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;

            default:
                aClass = GlobalAddAtom (lpclass);
                if (!(lpPictObj = (LPOLEOBJECT) GenCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE, aClass)))
                    return FALSE;

                ((LPOBJECT_GEN)lpPictObj)->cfFormat = cfFormat;
                break;
        }
    }
    else if (optRender == olerender_draw) {
#ifdef WIN32HACK
          if (!(lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE)))
                return FALSE;
#else
          if (!(lpPictObj = (LPOLEOBJECT) EmfCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE)))
                return FALSE;
#endif
#ifdef LATER
        if (AdviseOn (lpobj, (cfFormat = CF_METAFILEPICT), NULL))
            lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE);
        // !!! for the time being take assume we need to get metafile.
        else if (AdviseOn (lpobj, (cfFormat = CF_DIB), NULL))
            lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE);
        else if (AdviseOn (lpobj, (cfFormat = CF_BITMAP), NULL))
            lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE);
        else
            goto errPict;
#endif

    }
    else
        return (optRender == olerender_none);

    if (lpobj->lpobjPict = lpPictObj)
        lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    return TRUE;
}


OLESTATUS LnkChangeLnk (LPOBJECT_LE lpobj)
{

    switch (lpobj->subRtn) {

        case 0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);

            // now try to activate the new link.
            SKIP_TO (!InitDocConv (lpobj, !POPUP_NETDLG), step3);
            lpobj->fCmd = LN_LNKACT | ACT_ADVISE | ACT_REQUEST;
            InitAsyncCmd (lpobj, OLE_SETDATA, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);

        case    3:
            step3:
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS INTERNAL ChangeDocAndItem (
    LPOBJECT_LE lpobj,
    HANDLE      hinfo
){
    LPSTR       lpinfo;
    ATOM        aNewTopic, aNewItem = (ATOM)0, aOldTopic;
    OLESTATUS   retVal = OLE_ERROR_BLANK;

    PROBE_SVRCLOSING(lpobj);

    if (!(lpinfo = GlobalLock (hinfo)))
        return OLE_ERROR_MEMORY;

    lpinfo += lstrlen (lpinfo) + 1;
    aNewTopic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        aNewItem = GlobalAddAtom (lpinfo);

    if (!aNewTopic && (lpobj->head.ctype == CT_LINK))
        goto errRtn;

    aOldTopic = lpobj->topic;
    lpobj->topic = aNewTopic;
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        goto errRtn;
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);

    if (lpobj->item)
        GlobalDeleteAtom (lpobj->item);

    lpobj->item = aNewItem;

    // As the atoms have already changed, lpobj->hLink becomes irrelevant.
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    GlobalUnlock(hinfo);

    // Now disconnect the old link and try to connect to the new one.
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETDATA, LNKCHANGELNK);
    return LnkChangeLnk (lpobj);

errRtn:

    if (aNewItem)
        GlobalDeleteAtom (aNewItem);

    GlobalUnlock (hinfo);
    return retVal;
}


BOOL    QueryUnlaunch (LPOBJECT_LE lpobj)
{
    if (!(lpobj->fCmd & ACT_UNLAUNCH))
        return FALSE;

    // only if we loaded the app
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient && lpobj->pSysEdit->hInst)
        return TRUE;

    return FALSE;
}


BOOL     QueryClose (LPOBJECT_LE lpobj)
{
    if (!((lpobj->fCmd & ACT_UNLAUNCH) ||
            (lpobj->head.ctype == CT_EMBEDDED)))
        return FALSE;

    // only if we loaded the documnet
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
        return TRUE;

    return FALSE;
}


OLESTATUS INTERNAL SetHostNamesHandle (
    LPOBJECT_LE lpobj,
    LPSTR       lpclientName,
    LPSTR       lpdocName
){
    UINT        cchClientName;
    UINT        cchDocName;
    UINT        size;
    HANDLE      hhostNames      = NULL;
    LPHOSTNAMES lphostNames     = NULL;
    LPSTR       lpdata;

    cchDocName = lstrlen(lpdocName);
    cchClientName = lstrlen(lpclientName);
    // 4 bytes  is for the two offsets
    size = (cchClientName+1) + (cchDocName+1) + (2*sizeof(UINT));

    if ((hhostNames = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size))
            == NULL)
        goto errRtn;

    if ((lphostNames = (LPHOSTNAMES)GlobalLock (hhostNames)) == NULL)
        goto errRtn;

    lphostNames->clientNameOffset = 0;
    lphostNames->documentNameOffset = (WORD)cchClientName;

    lpdata = (LPSTR)lphostNames->data;
    lstrcpyn (lpdata, lpclientName, cchClientName+1);
    lstrcpyn (lpdata + cchClientName, lpdocName, cchDocName+1);
    if (lpobj->hhostNames)
        GlobalFree ( lpobj->hhostNames);
    GlobalUnlock (hhostNames);
    lpobj->hhostNames = hhostNames;
    return OLE_OK;

errRtn:
    if (lphostNames)
        GlobalUnlock (hhostNames);

    if (hhostNames)
        GlobalFree (hhostNames);

    return  OLE_ERROR_MEMORY;
}


#if 0
OLESTATUS  FARINTERNAL LeAbort (LPOBJECT_LE lpobj)
{


    BOOL        bAbort = FALSE;
    PEDIT_DDE   pedit;


    // check whether the any transaction pending for
    // the document level.

    //  channel open
    //  any transaction pending.
    //  and we are not in terminate mode.


    if ((pedit = lpobj->pDocEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        // delete any data we need to delete. Ricght now
        // we kill only the timer. We can not delete any
        // since the server could potentially look at the data.

        DeleteAbortData (lpobj, pedit);
    }

    if ((pedit = lpobj->pSysEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        DeleteAbortData (lpobj, pedit);

    }

    if (!bAbort)
        return OLE_OK;

    // Now send the EndAsync
    lpobj->mainErr = OLE_ERROR_ABORT;
    EndAsyncCmd (lpobj);
    return OLE_OK;

}
#endif


OLESTATUS  FARINTERNAL ProbeAsync(LPOBJECT_LE lpobj)
{

    if (lpobj->asyncCmd == OLE_NONE)
        return OLE_OK;

    if (!IsServerValid (lpobj)) {

        // Now send the EndAsync
        lpobj->mainErr = OLE_ERROR_TASK;
        EndAsyncCmd (lpobj);
        return OLE_OK;
    }

    return OLE_BUSY;
}


BOOL    INTERNAL IsWindowValid (HWND hwnd)
{

#define TASK_OFFSET 0x00FA

    HANDLE  htask;

    if (!IsWindow (hwnd))
        return FALSE;

    // now get the task handle and find out it is valid.
    htask  = GetWindowTask (hwnd);

#ifdef WIN32
//   if (IsTask(htask))
      return TRUE;
#endif

    return FALSE;
}



BOOL    INTERNAL IsServerValid (LPOBJECT_LE lpobj)
{

    MSG msg;
    BOOL    retval = FALSE;


    if (lpobj->pDocEdit && lpobj->pDocEdit->hServer) {

        retval = TRUE;

        if (!IsWindowValid (lpobj->pDocEdit->hServer)) {
            if (!PeekMessage ((LPMSG)&msg, lpobj->pDocEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                            PM_NOREMOVE | PM_NOYIELD)){
                return FALSE;
            }

        }

    }

    if (lpobj->pSysEdit && lpobj->pSysEdit->hServer) {
        retval = TRUE;

        if (!IsWindowValid (lpobj->pSysEdit->hServer)) {

            if (!PeekMessage ((LPMSG)&msg, lpobj->pSysEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                                PM_NOREMOVE | PM_NOYIELD)){
                return FALSE;

            }


        }
    }

   return retval;
}


OLESTATUS FARINTERNAL LeExecute (
    LPOLEOBJECT lpoleobj,
    HANDLE      hCmds,
    UINT        wReserve
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    UNREFERENCED_PARAMETER(wReserve);

    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!(lpobj =  (*lpobj->head.lpvtbl->QueryProtocol) (lpoleobj,
                                            PROTOCOL_EXECUTE)))
        return OLE_ERROR_PROTOCOL;

    if (!QueryOpen (lpobj))
        return OLE_ERROR_NOT_OPEN;

    if (!(hCmds = DuplicateGlobal (hCmds, GMEM_MOVEABLE|GMEM_DDESHARE)))
        return OLE_ERROR_MEMORY;

    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    SETERRHINT(lpobj, OLE_ERROR_COMMAND);
    if (DocExecute(lpobj, hCmds))
        return OLE_WAIT_FOR_RELEASE;
    else
        return OLE_ERROR_COMMAND;
}


void INTERNAL FreeGDIdata (
    HANDLE          hData,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }

    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);

    else if (cfFormat == CF_DIB)
        GlobalFree (hData);

    else if (cfFormat == CF_ENHMETAFILE)
        DeleteEnhMetaFile(hData);

}

// This routine figures out whether the handle to data block can be copied
// to DDEPOKE block rather than the contents of the handle

BOOL INTERNAL CanPutHandleInPokeBlock (
    LPOBJECT_LE     lpobj,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_BITMAP || cfFormat == CF_DIB || cfFormat == CF_ENHMETAFILE)
        return TRUE;

    if (cfFormat == CF_METAFILEPICT) {
        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && lpobj->app == aMSDraw)
            return FALSE;

        return TRUE;
    }

    return FALSE;
}

// MakeMFfromEMF()
// make a metafile from and enhanced metafile

HMETAFILE MakeMFfromEMF (
   HENHMETAFILE hemf
){
    HANDLE hBytes;
    LPBYTE lpBytes = NULL;
    LONG   lSizeBytes;
    HDC    hdc = GetDC(NULL);
    HMETAFILE    hmf = NULL;

    if (!(lSizeBytes = GetWinMetaFileBits((HENHMETAFILE)hemf, 0, NULL, MM_ANISOTROPIC, hdc)) ) {
        if (hdc) ReleaseDC(NULL, hdc);
        return NULL;
    }

    if (!(hBytes = GlobalAlloc(GHND, lSizeBytes)) )
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock(hBytes)) )
        goto error;

    GetWinMetaFileBits((HENHMETAFILE)hemf, lSizeBytes, lpBytes, MM_ANISOTROPIC, hdc);

#ifdef NOBUGS
    if (GetWinMetaFileBits(((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf, lSizeBytes, lpBytes, MM_ANISOTROPIC, hdc) != lSizeBytes) {
        retval = OLE_ERROR_METAFILE;
        goto error;
    }
#endif

    (HMETAFILE)hmf = SetMetaFileBitsEx(lSizeBytes,lpBytes);

error:
    if (lpBytes)
        GlobalUnlock(hBytes);

    if (hBytes)
        GlobalFree(hBytes);

    if (hdc)
      ReleaseDC(NULL, hdc);

    return hmf;
}


// MakeMFPfromEMF()
// make a metafile picture structure from an enhanced metafile

HANDLE MakeMFPfromEMF (
   HENHMETAFILE hemf,
   HANDLE hmf

){
    HANDLE         hmfp;
    LPMETAFILEPICT lpmfp = NULL;
    ENHMETAHEADER  enhmetaheader;

    if (GetEnhMetaFileHeader((HENHMETAFILE)hemf, sizeof(enhmetaheader), &enhmetaheader) == GDI_ERROR)
        goto error;

    if (!(hmfp = GlobalAlloc(GHND, sizeof(METAFILEPICT))) )
        goto error;

    if (!(lpmfp = (LPMETAFILEPICT)GlobalLock(hmfp)) )
        goto error;

    lpmfp->xExt = enhmetaheader.rclFrame.right - enhmetaheader.rclFrame.left;
    lpmfp->yExt = enhmetaheader.rclFrame.bottom - enhmetaheader.rclFrame.top;
    lpmfp->mm   = MM_ANISOTROPIC;
    lpmfp->hMF  = hmf;

    GlobalUnlock(hmfp);
    return hmfp;

error:

    if (lpmfp)
        GlobalUnlock(hmfp);

    if (hmfp)
        GlobalFree(hmfp);

    return NULL;

}

// ChangeEMFtoMF
// Change and enhanced metafile object to a metafile object

BOOL INTERNAL ChangeEMFtoMF(
    LPOBJECT_LE   lpobj
){
    HMETAFILE      hmf;
    HANDLE         hmfp = NULL;
    LPOBJECT_MF    lpobjMF;
    char           szobjname[MAX_ATOM];
    DWORD          dwSize = MAX_ATOM;


    // the blank picture case

    if (!((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf) {
        GlobalGetAtomName(lpobj->head.aObjName, (LPSTR)szobjname, dwSize);
        if (!(lpobjMF = MfCreateBlank (lpobj->head.lhclientdoc, (LPSTR)szobjname, CT_PICTURE)))
             return FALSE;
        EmfRelease(lpobj->lpobjPict);
        lpobj->lpobjPict = (LPOLEOBJECT)lpobjMF;
        return TRUE;
    }

    // the normal case

    if (!(hmf = MakeMFfromEMF(((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf)) )
        goto error;

    if (!(hmfp = MakeMFPfromEMF(((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf, hmf)) )
        goto error;

    GlobalGetAtomName(lpobj->head.aObjName, (LPSTR)szobjname, dwSize);

    if (!(lpobjMF = MfCreateObject(
         hmfp,
         lpobj->head.lpclient,
         TRUE,
         lpobj->head.lhclientdoc,
         szobjname,
         CT_PICTURE
    ))) goto error;

    EmfRelease(lpobj->lpobjPict);
    lpobj->lpobjPict = (LPOLEOBJECT)lpobjMF;

    return TRUE;

error:

    if (hmf)
        DeleteMetaFile((HMETAFILE)hmf);

    if (hmfp)
        GlobalFree(hmfp);

    return FALSE;

}

BOOL INTERNAL ChangeEMFtoMFneeded(LPOBJECT_LE lpobj, ATOM advItem)
{

   lpobj->bNewPict = FALSE;
   if (lpobj->subErr && CF_ENHMETAFILE == GetPictType(lpobj)) {
      CLEAR_STEP_ERROR (lpobj);

      if (advItem == aClose)
         lpobj->pDocEdit->nAdviseClose--;
      else if (advItem == aSave)
         lpobj->pDocEdit->nAdviseSave--;

      AdviseOn (lpobj, CF_METAFILEPICT, advItem);
      lpobj->bNewPict = TRUE;
      return TRUE;
   }
   else
   {
      lpobj->subRtn++;
      return FALSE;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\le.c ===
/****************************** Module Header ******************************\
* Module Name: le.c
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*   curts created portable version for win16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

#define EMB_ID_INDEX    3          // index of ones digit in #000
char    embStr[]        = "#000";

extern  HANDLE          hInfo;
extern  OLECLIPFORMAT   cfNetworkName;

HANDLE  GetNetNameHandle (LPOBJECT_LE);
BOOL    AreTopicsEqual (LPOBJECT_LE, LPOBJECT_LE);

ATOM FARINTERNAL wAtomCat (ATOM, ATOM);


OLEOBJECTVTBL    vtblLE  = {

        LeQueryProtocol,   // check whether the speced protocol is supported

        LeRelease,         // release
        LeShow,            // Show
        LeDoVerb,          // run
        LeGetData,
        LeSetData,
        LeSetTargetDevice, //

        LeSetBounds,       // set viewport bounds
        LeEnumFormat,      // returns format
        LeSetColorScheme,  // set color scheme
        LeRelease,         // delete
        LeSetHostNames,    //
        LeSaveToStream,    // write to file
        LeClone,           // clone object
        LeCopyFromLink,    // Create embedded from Link

        LeEqual,           // test whether the object data is similar

        LeCopy,            // copy to clip

        LeDraw,            // draw the object

        LeActivate,        // activate
        LeExecute,         // excute the given commands
        LeClose,           // stop
        LeUpdate,          // Update
        LeReconnect,       // Reconnect

        LeObjectConvert,        // convert object to specified type

        LeGetUpdateOptions,     // Get Link Update options
        LeSetUpdateOptions,     // Set Link Update options

        ObjRename,              // Change Object name
        ObjQueryName,           // Get current object name

        LeQueryType,            // object Type
        LeQueryBounds,          // QueryBounds
        ObjQuerySize,           // Find the size of the object
        LeQueryOpen,            // Query open
        LeQueryOutOfDate,       // query whether object is current

        LeQueryReleaseStatus,   // returns release status
        LeQueryReleaseError,    // assynchronusrelease error
        LeQueryReleaseMethod,   // the method/proc which is in assynchronus
                                // operation.
        LeRequestData,          // requestdata
        LeObjectLong,           // objectLong
        LeChangeData            // change native data of existing object
};



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeObjectLong (lpoleobj, wFlags, lpData)
//
//
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//
//  Arguments:
//
//      lpoleobj    -   ole object pointer
//      wFlags      -   get, set flags
//      lpData      -   long pointer to data
//
//  Returns:
//
//      OLE_OK
//      OLE_ERROR_OBJECT
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeObjectLong (
    LPOLEOBJECT lpoleobj,
    UINT        wFlags,
    LPLONG      lpData
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    LONG    lData;

    Puts("LeObjectLong");

    if (!FarCheckObject((LPOLEOBJECT) lpobj))
        return OLE_ERROR_OBJECT;

    if ((lpobj->head.ctype != CT_EMBEDDED) && (lpobj->head.ctype != CT_LINK))
        return OLE_ERROR_OBJECT;

    if (wFlags & OF_HANDLER) {
        lData = lpobj->lHandlerData;
        if (wFlags & OF_SET)
            lpobj->lHandlerData = *lpData;

        if (wFlags & OF_GET)
            *lpData = lData;
    }
    else {
        lData = lpobj->lAppData;
        if (wFlags & OF_SET)
            lpobj->lAppData = *lpData;

        if (wFlags & OF_GET)
            *lpData = lData;
    }

    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseStatus (lpoleobj)
//
//
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//
//  Arguments:
//
//      lpoleobj    -   ole object pointer
//
//  Returns:
//
//      OLE_BUSY    -   object is busy
//      OLE_OK      -   not busy
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FAR PASCAL LeQueryReleaseStatus (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // probe async will clean up the channels
    // if the server died.


    PROBE_ASYNC (lpobj);
    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseError (lpoleobj)
//
//  returns the errors of an asynchronous command.
//
//  Arguments:
//
//      lpoleobj        -   ole object pointer
//
//  Returns:
//
//      OLE_ERROR_..    -   if there is any error
//      OLE_OK          -   no error
//
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE.
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS   FAR PASCAL LeQueryReleaseError (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    return lpobj->mainErr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (lpoleobj)
//
//  returns the method/command of the asynchronous command which
//  resulted in the OLE_RELEASE call back.
//
//  Arguments:
//
//      lpoleobj   -   ole object pointer
//
//  Returns:
//      OLE_RELEASE_METHOD
//
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE. Using this api, clients can decide which previous
//        asynchronous command resulted in OLE_RELEASE.
//
//////////////////////////////////////////////////////////////////////////////
OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    return lpobj->oldasyncCmd;
}



//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID  FARINTERNAL LeQueryProtocol (lpoleobj, lpprotocol)
//
//  Given an oject, returns the new object handle for the new protocol.
//  Does the conversion of objects from one protocol to another one.
//
//  Arguments:
//
//      lpoleobj    -   ole object pointer
//      lpprotocol  -   ptr to new protocol string
//
//  Returns:
//      lpobj       -   New object handle
//      null        -   if the protocol is not supported.
//
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FARINTERNAL  LeQueryProtocol (
    LPOLEOBJECT lpoleobj,
    OLE_LPCSTR  lpprotocol
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->bOldLink)
        return NULL;

    if (!lstrcmp (lpprotocol, PROTOCOL_EDIT))
        return lpobj;

    if  (!lstrcmp (lpprotocol, PROTOCOL_EXECUTE)) {
        if (UtilQueryProtocol (lpobj, lpprotocol))
            return lpobj;

        return NULL;
    }

    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS EmbLnkDelete (lpoleobj)
//
//  Routine for the object termination/deletion. Schedules differnt
//  asynchronous commands depending on different conditions.
//  Arguments:
//
//  Sends "StdClose" only if it is Ok to close the document. Sends
//  "StdExit" only if the server has to be unlaunched.  Deletes the object
//  only if the original command is OLE_DELETE.  No need to call back the
//  client if the deletion is internal.
//
//  While delete, this routine is entered several times. EAIT_FOR_ASYNC_MSG
//  results in going back to from where it is called and the next DDE message
//  brings back the control to this routine.
//
//  Arguments:
//
//      lpobj   -    object pointer
//
//  Returns:
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmbLnkDelete (LPOBJECT_LE lpobj)
{
    HOBJECT     hobj;

    switch (lpobj->subRtn) {

        case    0:

            SKIP_TO (!QueryClose (lpobj), step1);
            // Send "StdCloseDocument"
            SendStdClose (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            step1:
            SETSTEP (lpobj, 1);

            // End the doc conversation
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case    2:


            // delete the doc edit block. It is Ok even if the object
            // is not actually getting deleted.
            DeleteDocEdit (lpobj);

            // if need to unluanch the app, send stdexit.
            SKIP_TO (!QueryUnlaunch (lpobj), step3);
            SendStdExit (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    3:

            step3:
            SETSTEP (lpobj, 3);

            // Do not set any errors.
            // Terminate the server conversation.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    4:

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            if (lpobj->asyncCmd != OLE_DELETE) {

                // if this delete is called because of unlauncinh of
                // object because of some error, no need to
                // call end asynchronous. It  should have been already
                // called from somewhere else.

                if (lpobj->asyncCmd == OLE_SERVERUNLAUNCH){
                    // send the async cmd;
                    CLEARASYNCCMD (lpobj);
                } else
                    EndAsyncCmd (lpobj);
                return OLE_OK;
            }



            // for real delete delete the atoms and space.
            DeleteObjectAtoms (lpobj);

            if (lpobj->lpobjPict)
                (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);

            if (lpobj->hnative)
                GlobalFree (lpobj->hnative);

            if (lpobj->hLink)
                GlobalFree (lpobj->hLink);

            if (lpobj->hhostNames)
                GlobalFree (lpobj->hhostNames);

            if (lpobj->htargetDevice)
                GlobalFree (lpobj->htargetDevice);

            if (lpobj->hdocDimensions)
                GlobalFree (lpobj->hdocDimensions);

            DeleteExtraData (lpobj);

            DocDeleteObject ((LPOLEOBJECT) lpobj);
            // send the async cmd;
            EndAsyncCmd (lpobj);

            if (lpobj->head.iTable != INVALID_INDEX)
                DecreaseHandlerObjCount (lpobj->head.iTable);

            hobj = lpobj->head.hobj;
            ASSERT (hobj, "Object handle NULL in delete")

            GlobalUnlock (hobj);
            GlobalFree (hobj);

            return OLE_OK;
    }

    return OLE_ERROR_GENERIC;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeRelease (lpoleobj)
//
//  Deletes the given object. This is can be asynchronous operation.
//
//  Arguments:
//
//      lpoleobj   -   ole object pointer
//
//  Returns:
//
//      OLE_WAIT_FOR_RELASE: If any DDE_TRANSACTIONS have been queued
//      OLE_OK             : If deletion successfully
//      OLE_ERROR_...      : If any error
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE    lpobj = (LPOBJECT_LE) lpoleobj;


    // For delete allow if the object has been aborted.

    PROBE_ASYNC (lpobj);

    // reset the flags so that we do not delete the object based on the old
    // flags
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_DELETE, EMBLNKDELETE);
    return  EmbLnkDelete (lpobj);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeClone (lpoleobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Clones a given object.
//
//  Arguments:
//
//      lpoleobjsrc:    ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//
//  Note: If the object being cloned is connected to the server, then
//        the cloned object is not connected to the server. For linked
//        objects, OleConnect has to be called.
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_LE lpobjsrc = (LPOBJECT_LE) lpoleobjsrc;
    LPOBJECT_LE lpobj    = (LPOBJECT_LE) NULL;
    int         retval   = OLE_ERROR_MEMORY;

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobjsrc);

    PROBE_CREATE_ASYNC(lpobjsrc);

    if (!(lpobj = LeCreateBlank(lhclientdoc, (LPSTR)lpobjname,
                        lpobjsrc->head.ctype)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;
    lpobj->head.iTable  = lpobjsrc->head.iTable; //!!! dll loading
    lpobj->head.lpvtbl  = lpobjsrc->head.lpvtbl;

    // set the atoms.
    lpobj->app          = DuplicateAtom (lpobjsrc->app);
    lpobj->topic        = DuplicateAtom (lpobjsrc->topic);
    lpobj->item         = DuplicateAtom (lpobjsrc->item);
    lpobj->aServer      = DuplicateAtom (lpobjsrc->aServer);

    lpobj->bOleServer   = lpobjsrc->bOleServer;
    lpobj->verb         = lpobjsrc->verb;
    lpobj->fCmd         = lpobjsrc->fCmd;

    lpobj->aNetName     = DuplicateAtom (lpobjsrc->aNetName);
    lpobj->cDrive       = lpobjsrc->cDrive;
    lpobj->dwNetInfo    = lpobjsrc->dwNetInfo;

    if (lpobjsrc->htargetDevice)
        lpobj->htargetDevice = DuplicateGlobal (lpobjsrc->htargetDevice,
                                    GMEM_MOVEABLE);

    if (lpobjsrc->head.ctype == CT_EMBEDDED) {
        if (lpobjsrc->hnative) {
            if (!(lpobj->hnative = DuplicateGlobal (lpobjsrc->hnative,
                                        GMEM_MOVEABLE)))
                goto errRtn;
        }

        if (lpobjsrc->hdocDimensions)
            lpobj->hdocDimensions = DuplicateGlobal (lpobjsrc->hdocDimensions,
                                            GMEM_MOVEABLE);
        if (lpobjsrc->hlogpal)
            lpobj->hlogpal = DuplicateGlobal (lpobjsrc->hlogpal,
                                            GMEM_MOVEABLE);
        SetEmbeddedTopic (lpobj);
    }
    else {
        lpobj->bOldLink     = lpobjsrc->bOldLink;
        lpobj->optUpdate    = lpobjsrc->optUpdate;
    }

    retval = OLE_OK;
    // if picture is needed clone the picture object.
    if ((!lpobjsrc->lpobjPict) ||
         ((retval = (*lpobjsrc->lpobjPict->lpvtbl->Clone)(lpobjsrc->lpobjPict,
                                    lpclient, lhclientdoc, lpobjname,
                                    (LPOLEOBJECT FAR *)&lpobj->lpobjPict))
                    == OLE_OK)) {
        SetExtents (lpobj);
        *lplpoleobj = (LPOLEOBJECT)lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    }

    return retval;

errRtn:

    // This oledelete should not result in any async communication.
    if (lpobj)
        OleDelete ((LPOLEOBJECT)lpobj);

    return retval;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopyFromLink (lpoleobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Creates an embedded object from a lonked object. If the linked object
//  is not activated, then launches the server, gets the native data and
//  unlaunches the server. All these operations are done silently.
//
//  Arguments:
//
//      lpoleobjsrc:    ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//      OLE_WAITF_FOR_RELEASE : if DDE transcation is queued
//
//  Note: Could result in asynchronous operation if there is any
//        DDE operaion involved in getting any data from the server.
//
//        Also, If there is any error in getting the native data, the
//        client is expected delete the object after the OLE_RELEASE
//        call back
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopyFromLink (
    LPOLEOBJECT         lpoleobjsrc,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){

    LPOBJECT_LE    lpobjsrc = (LPOBJECT_LE)lpoleobjsrc;
    LPOBJECT_LE    lpobj;
    int            retval;


    *lplpoleobj = (LPOLEOBJECT)NULL;
    PROBE_OLDLINK (lpobjsrc);
    if (lpobjsrc->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;

    PROBE_ASYNC (lpobjsrc);
    PROBE_SVRCLOSING(lpobjsrc);

    if ((retval = LeClone ((LPOLEOBJECT)lpobjsrc, lpclient, lhclientdoc, lpobjname,
                    (LPOLEOBJECT FAR *)&lpobj)) != OLE_OK)
        return retval;


    // we successfully cloned the object. if picture object has native data
    // then grab it and put it in LE object. otherwise activate and get native
    // data also.

    if (lpobj->lpobjPict
            && (*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, 0) == cfNative){
        // Now we know that the picture object is of native format, and it
        // means that it is a generic object. So grab the handle to native
        // data and put it in LE object.

        lpobj->hnative = ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData;
        ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData = (HANDLE)NULL;
        (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);
        lpobj->lpobjPict = (LPOLEOBJECT)NULL;
        SetEmbeddedTopic (lpobj);
        *lplpoleobj = (LPOLEOBJECT)lpobj;
        return OLE_OK;
    } else {

        // if necessary launch, get native data and unlaunch the app.
        lpobj->fCmd = LN_LNKACT | ACT_REQUEST | ACT_NATIVE | (QueryOpen(lpobjsrc) ? ACT_TERMDOC : ACT_UNLAUNCH);
        InitAsyncCmd (lpobj, OLE_COPYFROMLNK, LNKOPENUPDATE);
        if ((retval = LnkOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            LeRelease ((LPOLEOBJECT)lpobj);
        else
            *lplpoleobj = (LPOLEOBJECT)lpobj;

        return retval;

        // we will be changing the topic in end conversation.
    }
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeEqual (lpoleobj1, lpoleobj2)
//
//  Checks whethere two objects are equal. Checks for equality
//  of links, native data and picture data.
//
//  Arguments:
//
//      lpoleobj1:      first object
//      lpoleobj2:      second object
//
//  Returns:
//      OLE_OK              : equal
//      OLE_ERROR_NOT_EQUAL : if not equal
//      OLE_ERROR_.....     : any errors
//
//  Note: If any of the objects are connectd to the servers, leequal operaion
//        may not make much sense because the data might be changing from the
//        the server
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_LE lpobj1 = (LPOBJECT_LE)lpoleobj1;
    LPOBJECT_LE lpobj2 = (LPOBJECT_LE)lpoleobj2;

    if (lpobj1->app != lpobj2->app)
        return OLE_ERROR_NOT_EQUAL;

    // type of the objects is same. Otherwise this routine won't be called
    if (lpobj1->head.ctype == CT_LINK) {
        if (AreTopicsEqual (lpobj1, lpobj2) && (lpobj1->item == lpobj2->item))
            return OLE_OK;

        return OLE_ERROR_NOT_EQUAL;
    }
    else {
        ASSERT (lpobj1->head.ctype == CT_EMBEDDED, "Invalid ctype in LeEqual")

        if (lpobj1->item != lpobj2->item)
            return OLE_ERROR_NOT_EQUAL;

        if (CmpGlobals (lpobj1->hnative, lpobj2->hnative))
            return OLE_OK;
        else
            return OLE_ERROR_NOT_EQUAL;
    }

    //### we may have to compare the picture data also
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopy (lpoleobj)
//
//  Copies the object to the clipboard. Even for linked objects
//  we do not render the objectlink. It is up to the client app
//  to render object link
//
//  Arguments:
//
//      lpoleobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    HANDLE      hlink    = (HANDLE)NULL;
    HANDLE      hnative  = (HANDLE)NULL;

    PROBE_OLDLINK (lpobj);
    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);

    if (lpobj->head.ctype == CT_EMBEDDED){
        if (!(hnative = DuplicateGlobal (lpobj->hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
        SetClipboardData (cfNative, hnative);
    }

    hlink = GetLink (lpobj);
    if (!(hlink = DuplicateGlobal (hlink, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;
    SetClipboardData (cfOwnerLink, hlink);

    // copy network name if it exists
    if (lpobj->head.ctype == CT_LINK  && lpobj->aNetName) {
        HANDLE hNetName;

        if (hNetName = GetNetNameHandle (lpobj))
            SetClipboardData (cfNetworkName, hNetName);
    }

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->CopyToClipboard)(lpobj->lpobjPict);

    return OLE_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeQueryBounds (lpoleobj, lpRc)
//
//  Returns the bounding rectangle of the object. Returns topleft
//  as zero always and the units are himetric units.
//
//  Arguments:
//
//      lpoleobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL LeQueryBounds (
    LPOLEOBJECT    lpoleobj,
    LPRECT         lpRc
){
    LPOBJECT_LE    lpobj = (LPOBJECT_LE)lpoleobj;
    Puts("LeQueryBounds");

    // MM_HIMETRIC units

    lpRc->left     =  0;
    lpRc->top      =  0;
    lpRc->right    =  (int) lpobj->head.cx;
    lpRc->bottom   =  (int) lpobj->head.cy;

    if (lpRc->right || lpRc->bottom)
        return OLE_OK;

    if (!lpobj->lpobjPict)
        return OLE_ERROR_BLANK;

    return (*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict, lpRc);
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeDraw (lpoleobj, hdc, lprc, lpWrc, hdcTarget)
//
//  Draws the object. Calls the picture object for drawing the object
//
//
//  Arguments:
//
//       lpoleobj:    source object
//       hdc:         handle to dest dc. Could be metafile dc
//       lprc:        rectangle into which the object should be drawn
//                    should be in himetric units and topleft
//                    could be nonzero.
//       hdctarget:   Target dc for which the object should be drawn
//                    (Ex: Draw metafile on the dest dc using the attributes
//                         of traget dc).
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_BLANK     : no picture
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->Draw) (lpobj->lpobjPict,
                                        hdc, lprc, lpWrc, hdcTarget);
    return OLE_ERROR_BLANK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLECLIPFORMAT FARINTERNAL LeEnumFormat (lpoleobj, cfFormat)
//
//  Enumerates the object formats.
//
//
//  Arguments:
//
//       lpoleobj      :  source object
//       cfFormat   :  ref fprmat
//
//  Returns:
//      NULL        :  no more formats or if we do not understand the
//                     given format.
//
//  Note: Even if the object is connected, we do not enumerate all the formats
//        the server can render. Server protocol can render the format list
//        only on system channel. Object can be connected only on the doc
//        channel
//
//////////////////////////////////////////////////////////////////////////////

OLECLIPFORMAT FARINTERNAL LeEnumFormat (
   LPOLEOBJECT    lpoleobj,
   OLECLIPFORMAT  cfFormat
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    Puts("LeEnumFormat");

    ASSERT((lpobj->head.ctype == CT_LINK)||(lpobj->head.ctype == CT_EMBEDDED),
        "Invalid Object Type");

    // switch is not used because case won't take variable argument
    if (cfFormat == (OLECLIPFORMAT)NULL) {
        if (lpobj->head.ctype == CT_EMBEDDED)
            return cfNative;
        else
            return (lpobj->bOldLink ? cfLink : cfObjectLink);
    }

    if (cfFormat == cfNative) {
        if (lpobj->head.ctype == CT_EMBEDDED)
            return cfOwnerLink;
        else
            return 0;
    }

    if (cfFormat == cfObjectLink) {
        if (lpobj->aNetName)
            return cfNetworkName;
        else
            cfFormat = (OLECLIPFORMAT)NULL;
    }
    else if  (cfFormat == cfOwnerLink || cfFormat == cfLink
                        || cfFormat == cfNetworkName)
        cfFormat = (OLECLIPFORMAT)NULL;

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, cfFormat);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeRequestData (lpoleobj, cfFormat)
//
//  Requests data from the server for a given format, if the server
//  is connected. If the server is not connected returns error.
//
//
//  Arguments:
//
//       lpoleobj:    source object
//       cfFormat:    ref fprmat
//
//  Returns:
//       OLE_WAIT_FOR_RELEASE : If the data request data is sent to
//                              the server.
//       OLE_ERROR_NOT_OPEN   : Server is not open for data
//
//  Note: If the server is ready, sends request to the server. When the
//        the data comes back from the server OLE_DATA_READY is sent in
//        the callback and the client can use Getdata to get the data.
//
//
//////////////////////////////////////////////////////////////////////////////



OLESTATUS FARINTERNAL LeRequestData (
   LPOLEOBJECT     lpoleobj,
   OLECLIPFORMAT   cfFormat
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // Assumes all the creates are in order
    PROBE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!QueryOpen (lpobj))
        return  OLE_ERROR_NOT_OPEN;

    if (cfFormat == cfOwnerLink || cfFormat == cfObjectLink)
        return OLE_ERROR_FORMAT;

    if (!(cfFormat == cfNative && lpobj->head.ctype == CT_EMBEDDED)
            && (cfFormat != (OLECLIPFORMAT) GetPictType (lpobj))) {
        DeleteExtraData (lpobj);
        lpobj->cfExtra = cfFormat;
    }

    InitAsyncCmd (lpobj, OLE_REQUESTDATA, REQUESTDATA);
    lpobj->pDocEdit->bCallLater = FALSE;
    return RequestData(lpobj, cfFormat);
}


OLESTATUS  RequestData (
   LPOBJECT_LE     lpobj,
   OLECLIPFORMAT   cfFormat
){
    switch (lpobj->subRtn) {

        case 0:
            RequestOn (lpobj, cfFormat);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            ASSERT (TRUE, "unexpected step in Requestdata");
            return OLE_ERROR_GENERIC;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeGetData (lpoleobj, cfFormat, lphandle)
//
//  Returns the data handle for a given format
//
//  Arguments:
//
//       lpoleobj:    source object
//       cfFormat:    ref fprmat
//       lphandle:    handle return
//
//  Returns:
//      NULL                : no more formats or if we do not understand the
//                            given format.
//
//  Note: Even if the object is connected, we do not get the data from the
//        server. Getdata can not be used for getting data in any other
//        format other than the formats available with the object on
//        the client side.
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeGetData (
    LPOLEOBJECT     lpoleobj,
    OLECLIPFORMAT   cfFormat,
    LPHANDLE        lphandle
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);

    *lphandle = (HANDLE)NULL;

    // The assumption made here is that the native data can be in either
    // LE object or picture object.
    if ((cfFormat == cfNative) && (lpobj->hnative)) {
        ASSERT ((lpobj->head.ctype == CT_EMBEDDED) || (!lpobj->lpobjPict) ||
            ((*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, NULL)
                        != cfNative), "Native data at wrong Place");
        *lphandle = lpobj->hnative;
        return OLE_OK;
    }

    if (cfFormat == cfOwnerLink && lpobj->head.ctype == CT_EMBEDDED) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if ((cfFormat == cfObjectLink || cfFormat == cfLink) &&
            lpobj->head.ctype == CT_LINK) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if (cfFormat == cfNetworkName) {
        if (lpobj->aNetName && (*lphandle = GetNetNameHandle (lpobj)))
            return OLE_WARN_DELETE_DATA;

        return OLE_ERROR_BLANK;
    }

    if (cfFormat == (OLECLIPFORMAT)lpobj->cfExtra) {
        if (*lphandle = lpobj->hextraData)
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if (!lpobj->lpobjPict && cfFormat)
        return OLE_ERROR_FORMAT;

    return (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict, cfFormat, lphandle);
}




OLESTATUS FARINTERNAL LeQueryOutOfDate (LPOLEOBJECT lpoleobj)
{
    UNREFERENCED_PARAMETER(lpoleobj);

    return OLE_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeObjectConvert (lpoleobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Converts a given  linked/embedded object to static object.
//
//  Arguments:
//          lpoleobj   : source object
//          lpprotocol : protocol
//          lpclient   : client callback for the new object
//          lhclientdoc: client doc
//          lpobjname  : object name
//          lplpoleobj : object return
//
//
//  Returns:
//      OLE_OK          :  successful
//      OLE_ERROR_....  :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeObjectConvert (
    LPOLEOBJECT         lpoleobj,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS   retVal;

    PROBE_ASYNC (lpobj);

    *lplpoleobj = (LPOLEOBJECT)NULL;

    if (lstrcmp (lpprotocol, PROTOCOL_STATIC))
        return OLE_ERROR_PROTOCOL;

    if (!lpobj->lpobjPict ||
            ((*lpobj->lpobjPict->lpvtbl->QueryType) (lpobj->lpobjPict, NULL)
                    == OLE_ERROR_GENERIC)) {
        // Either no picture object or non-standard picture object.
        // Create a metafile Object.

        HDC             hMetaDC;
        RECT            rc;
        HANDLE          hMF = (HANDLE)NULL, hmfp = (HANDLE)NULL;
        LPMETAFILEPICT  lpmfp;

        OleQueryBounds ((LPOLEOBJECT) lpobj, &rc);
        if (!(hMetaDC = CreateMetaFile (NULL)))
            goto Cleanup;

        MSetWindowOrg (hMetaDC, rc.left, rc.top);
        MSetWindowExt (hMetaDC, rc.right - rc.left, rc.bottom - rc.top);
        retVal = OleDraw ((LPOLEOBJECT) lpobj, hMetaDC, &rc, &rc, NULL);
        hMF = CloseMetaFile (hMetaDC);
        if ((retVal != OLE_OK) ||  !hMF)
            goto Cleanup;

        if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof (METAFILEPICT))))
            goto Cleanup;

        if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp)))
            goto Cleanup;

        lpmfp->hMF  = hMF;
        lpmfp->mm   = MM_ANISOTROPIC;
        lpmfp->xExt = rc.right - rc.left;
        lpmfp->yExt = rc.top - rc.bottom;
        GlobalUnlock (hmfp);

        if (*lplpoleobj = (LPOLEOBJECT) MfCreateObject (hmfp, lpclient, TRUE,
                                        lhclientdoc, lpobjname, CT_STATIC))
            return OLE_OK;

Cleanup:
        if (hMF)
            DeleteMetaFile (hMF);

        if (hmfp)
            GlobalFree (hmfp);

        return OLE_ERROR_MEMORY;
    }


    // Picture object is one of the standard objects
    if ((retVal = (*lpobj->lpobjPict->lpvtbl->Clone) (lpobj->lpobjPict,
                                lpclient, lhclientdoc,
                                lpobjname, lplpoleobj)) == OLE_OK) {
        (*lplpoleobj)->ctype = CT_STATIC;
        DocAddObject ((LPCLIENTDOC) lhclientdoc, *lplpoleobj, lpobjname);
    }

    return retVal;
}



// internal method used for changing picture/native data
OLESTATUS FARINTERNAL LeChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hnative,
    LPOLECLIENT     lpoleclient,
    BOOL            fDelete
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    UNREFERENCED_PARAMETER(lpoleclient);

    if (!fDelete) {
        if (!(hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }

    // In case of a CopyFromLink, eventhough the object type is CT_LINK, the
    // native data should go to LE object rather than the picture object, as
    // we are going to change the object type to embedded after the required
    // data is recieved.

    if ((lpobj->head.ctype == CT_LINK)
            && (lpobj->asyncCmd != OLE_COPYFROMLNK)
            && (lpobj->asyncCmd != OLE_CREATEFROMFILE)) {
        if (lpobj->lpobjPict)
            return  (*lpobj->lpobjPict->lpvtbl->SetData)
                            (lpobj->lpobjPict, cfNative, hnative);
    }
    else { // It must be embedded.
        if (lpobj->hnative)
            GlobalFree (lpobj->hnative);
        lpobj->hnative = hnative;
        return OLE_OK;
    }

    GlobalFree(hnative);
    return OLE_ERROR_BLANK;
}



////////////////////////////////////////////////////////////////////////////////
//
//  LPOBJECT_LE FARINTERNAL LeCreateBlank (lhclientdoc, lpobjname, ctype)
//
//  Create a blank object. Global block is used for the object and it is
//  locked once sucessful. Unlocking is done only while deletion. Object
//  is added to the corresponding doc.
//
//  'LE' signature is used for object validation.
//
//  Arguments:
//      lhclientdoc     :  client doc handle
//      lpobjname       :  object name
//      ctype           :  type of object to be created
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

LPOBJECT_LE FARINTERNAL LeCreateBlank (
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        ctype
){
    HOBJECT        hobj;
    LPOBJECT_LE    lpobj;

    if (!(ctype == CT_LINK || ctype == CT_EMBEDDED || ctype == CT_OLDLINK))
        return NULL;

    if (!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,
                        sizeof (OBJECT_LE))))
        return NULL;

    if (!(lpobj = (LPOBJECT_LE) GlobalLock (hobj))) {
        GlobalFree (hobj);
        return NULL;
    }

    if (ctype == CT_OLDLINK) {
        ctype = CT_LINK;
        lpobj->bOldLink = TRUE;
    }

    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    lpobj->head.ctype    = ctype;
    lpobj->head.iTable   = INVALID_INDEX;

    lpobj->head.lpvtbl  = (LPOLEOBJECTVTBL)&vtblLE;

    if (ctype == CT_LINK){
        lpobj->optUpdate = oleupdate_always;

    }else {
        lpobj->optUpdate = oleupdate_onclose;
    }
    lpobj->head.hobj = hobj;
    DocAddObject ((LPCLIENTDOC) lhclientdoc, (LPOLEOBJECT) lpobj, lpobjname);
    return lpobj;
}


void FARINTERNAL SetExtents (LPOBJECT_LE lpobj)
{
    RECT    rc = {0, 0, 0, 0};

    if (lpobj->lpobjPict) {
        if ((*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict,
                                        (LPRECT)&rc) == OLE_OK) {
            // Bounds are in MM_HIMETRIC units
            lpobj->head.cx = (LONG) (rc.right - rc.left);
            lpobj->head.cy = (LONG) (rc.bottom - rc.top);
        }
        return;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeSaveToStream (lpoleobj, lpstream)
//
//  Save the object to the stream. Uses the stream functions provided
//  in the lpclient.
//
//  Format: (!!! Document the fomrat here).
//
//
//
//  Arguments:
//      lpoleobj - pointer to ole object
//      lpstream - pointer to stream
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeSaveToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD       dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_LE lpobj     = (LPOBJECT_LE)lpoleobj;
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);

    if (lpobj->head.ctype == CT_LINK && lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    return LeStreamWrite (lpstream, lpobj);
}



////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS  FARINTERNAL  LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, ctype, aClass, cfFormat)
//
//  Create an object, loading the object from the stream.
//
//  Arguments:
//      lpstream            : stream table
//      lpclient            : client callback table
//      lhclientdoc         : Doc handle foe which the object should be created
//      lpobjname           : Object name
//      lplpoleobject       : object return
//      ctype               : Type of object
//      aClass              : class atom
//      cfFormat            : render format
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS  FARINTERNAL  LeLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                ctype,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)NULL;
    OLESTATUS   retval = OLE_ERROR_STREAM;
    LONG        type;   // this not same as ctype
    char        chVerb [80];

    *lplpoleobject = (LPOLEOBJECT)NULL;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, ctype)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    lpobj->app = aClass;
    // if the entry is present, then it is
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 80);

    if (LeStreamRead (lpstream, lpobj) == OLE_OK) {

        // Get exe name from aClass and set it as aServer
        SetExeAtom (lpobj);
        if (!GetBytes (lpstream, (LPSTR) &dwVerFromFile, sizeof(LONG))) {
            if (!GetBytes (lpstream, (LPSTR) &type, sizeof(LONG))) {
                if (type == CT_NULL)
                    retval = OLE_OK;
                else if (aClass = GetAtomFromStream (lpstream)) {
                    retval = DefLoadFromStream (lpstream, NULL, lpclient,
                                        lhclientdoc, lpobjname,
                                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict,
                                        CT_PICTURE, aClass, cfFormat);
                }
            }
        }

        if (retval == OLE_OK) {
            SetExtents (lpobj);
            *lplpoleobject = (LPOLEOBJECT) lpobj;
            if (lpobj->lpobjPict)
                lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;

            if ((lpobj->head.ctype != CT_LINK)
                    || (!InitDocConv (lpobj, !POPUP_NETDLG))
                    || (lpobj->optUpdate >= oleupdate_oncall))
                return OLE_OK;

            lpobj->fCmd = ACT_ADVISE;

            // If it's auto update, then get the latest data.
            if (lpobj->optUpdate == oleupdate_always)
                lpobj->fCmd |= ACT_REQUEST;

            FarInitAsyncCmd (lpobj, OLE_LOADFROMSTREAM, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);
        }
    }

    // This delete will not run into async command. We did not even
    // even connect.
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



//

OLESTATUS INTERNAL LeStreamRead (
    LPOLESTREAM lpstream,
    LPOBJECT_LE lpobj
){
    DWORD          dwBytes;
    LPSTR          lpstr;
    OLESTATUS      retval = OLE_OK;

    if (!(lpobj->topic = GetAtomFromStream(lpstream))
            && (lpobj->head.ctype != CT_EMBEDDED))
        return OLE_ERROR_STREAM;

    // !!! This atom could be NULL. How do we distinguish the
    // error case

    lpobj->item = GetAtomFromStream(lpstream);

    if (lpobj->head.ctype == CT_EMBEDDED)  {
        if (GetBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (!(lpobj->hnative = GlobalAlloc (GMEM_MOVEABLE, dwBytes)))
            return OLE_ERROR_MEMORY;
        else if (!(lpstr = GlobalLock (lpobj->hnative))) {
            GlobalFree (lpobj->hnative);
            return OLE_ERROR_MEMORY;
        }
        else {
            if (GetBytes(lpstream, lpstr, dwBytes))
                retval = OLE_ERROR_STREAM;
            GlobalUnlock (lpobj->hnative);
        }

        if (retval == OLE_OK)
            SetEmbeddedTopic (lpobj);
    }
    else {
        if (lpobj->aNetName = GetAtomFromStream (lpstream)) {
            if (HIWORD(dwVerFromFile) == OS_MAC) {
                // if it is a mac file this field will have "ZONE:MACHINE:"
                // string. Lets prepend this to the topic, so that server
                // app or user can fix the string

                ATOM    aTemp;

                aTemp = wAtomCat (lpobj->aNetName, lpobj->topic);
                GlobalDeleteAtom (lpobj->aNetName);
                lpobj->aNetName = (ATOM)0;
                GlobalDeleteAtom (lpobj->topic);
                lpobj->topic = aTemp;
            }
            else
                SetNetDrive (lpobj);
        }

        if (HIWORD(dwVerFromFile) != OS_MAC) {
            if (GetBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
                return OLE_ERROR_STREAM;
        }

        if (GetBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    return retval;

}



OLESTATUS INTERNAL LeStreamWrite (
    LPOLESTREAM lpstream,
    LPOBJECT_LE lpobj
){
    DWORD   dwFileVer = GetFileVersion((LPOLEOBJECT)lpobj);
    LPSTR   lpstr;
    DWORD   dwBytes   = 0L;
    LONG    nullType  = CT_NULL;
    int     error;

    if (PutAtomIntoStream(lpstream, lpobj->app))
        return OLE_ERROR_STREAM;

    if (lpobj->head.ctype == CT_EMBEDDED) {
        // we set the topic at load time, no point in saving it
        if (PutBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->topic))
            return OLE_ERROR_STREAM;
    }

#ifdef OLD
    if (PutAtomIntoStream(lpstream, lpobj->topic))
        return OLE_ERROR_STREAM;
#endif

    if (PutAtomIntoStream(lpstream, lpobj->item))
        return OLE_ERROR_STREAM;

    // !!! deal with objects > 64k

    if (lpobj->head.ctype == CT_EMBEDDED) {

        if (!lpobj->hnative)
            return OLE_ERROR_BLANK;

        // assumption low bytes are first
        dwBytes = (DWORD)GlobalSize (lpobj->hnative);

        if (PutBytes (lpstream, (LPSTR)&dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (!(lpstr = GlobalLock (lpobj->hnative)))
            return OLE_ERROR_MEMORY;

        error = PutBytes (lpstream, lpstr, dwBytes);
        GlobalUnlock (lpobj->hnative);

        if (error)
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->aNetName))
            return OLE_ERROR_STREAM;

        if (PutBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (PutBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->SaveToStream) (lpobj->lpobjPict,
                                                    lpstream);

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &nullType, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    return OLE_OK;
}


/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL LeQueryType (lpobj, lptype)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL LeQueryType (
    LPOLEOBJECT lpoleobj,
    LPLONG      lptype
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    Puts("LeQueryType");

    if ((lpobj->head.ctype == CT_EMBEDDED)
            || (lpobj->asyncCmd == OLE_COPYFROMLNK)
            || (lpobj->asyncCmd == OLE_CREATEFROMFILE))
        *lptype = CT_EMBEDDED;
    else if ((lpobj->head.ctype == CT_LINK)
                || (lpobj->head.ctype == CT_OLDLINK))
        *lptype = CT_LINK;
    else
        return OLE_ERROR_OBJECT;

    return OLE_OK;
}



// ContextCallBack: internal function. Calls callback function of <hobj>
// with flags.

int FARINTERNAL ContextCallBack (
    LPOLEOBJECT         lpobj,
    OLE_NOTIFICATION    flags
){
    LPOLECLIENT     lpclient;

    Puts("ContextCallBack");

    if (!FarCheckObject(lpobj))
        return FALSE;

    if (!(lpclient = lpobj->lpclient))
        return FALSE;

    ASSERT (lpclient->lpvtbl->CallBack, "Client Callback ptr is NULL");

    return ((*lpclient->lpvtbl->CallBack) (lpclient, flags, lpobj));
}


void FARINTERNAL DeleteExtraData (LPOBJECT_LE lpobj)
{
    if (lpobj->hextraData == (HANDLE)NULL)
        return;

    switch (lpobj->cfExtra) {
        case CF_BITMAP:
            DeleteObject (lpobj->hextraData);
            break;

        case CF_METAFILEPICT:
        {
            LPMETAFILEPICT  lpmfp;

            if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (lpobj->hextraData)))
                break;

            DeleteMetaFile (lpmfp->hMF);
            GlobalUnlock (lpobj->hextraData);
            GlobalFree (lpobj->hextraData);
            break;
        }

        default:
            GlobalFree (lpobj->hextraData);
    }

    lpobj->hextraData = (HANDLE)NULL;
}


void   INTERNAL DeleteObjectAtoms(LPOBJECT_LE lpobj)
{
    if (lpobj->app) {
        GlobalDeleteAtom (lpobj->app);
        lpobj->app = (ATOM)0;
    }

    if (lpobj->topic) {
        GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = (ATOM)0;
    }

    if (lpobj->item) {
        GlobalDeleteAtom (lpobj->item);
        lpobj->item  = (ATOM)0;
    }

    if (lpobj->aServer) {
        GlobalDeleteAtom (lpobj->aServer);
        lpobj->aServer = (ATOM)0;
    }

    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = (ATOM)0;
    }
}


// LeGetUpdateOptions: Gets the update options.

OLESTATUS   FARINTERNAL LeGetUpdateOptions (
    LPOLEOBJECT       lpoleobj,
    OLEOPT_UPDATE FAR *lpOptions
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_OBJECT;

    *lpOptions = lpobj->optUpdate;
    return OLE_OK;
}




OLESTATUS FARINTERNAL  LnkPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    OLECLIPFORMAT       sfFormat
){
    LPOBJECT_LE lpobj  = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD
    if (!bWLO) {
        // we are not running under WLO
        if (!(hInfo = GetClipboardData (sfFormat))) {
            if (hInfo = GetClipboardData (cfLink))
                lpobj->bOldLink = TRUE;
        }
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!IsClipboardFormatAvailable (sfFormat))
        lpobj->bOldLink = TRUE;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    if ((retval = SetNetName(lpobj)) != OLE_OK) {
        // see whether network name is on the clipboard and try to use it
        HANDLE  hNetName;
        LPSTR   lpNetName;

        if (!IsClipboardFormatAvailable (cfNetworkName))
            goto errRtn;

        if (!(hNetName = GetClipboardData (cfNetworkName)))
            goto errRtn;

        if (!(lpNetName = GlobalLock (hNetName)))
            goto errRtn;

        GlobalUnlock (hNetName);
        if (!(lpobj->aNetName = GlobalAddAtom (lpNetName)))
            goto errRtn;

        SetNetDrive (lpobj);
    }

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname,
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);

    if (retval == OLE_OK) {
        SetExtents (lpobj);
                // why do we have to update the link, do we show it?

        // Reconnect if we could and advise for updates
        *lplpoleobject = (LPOLEOBJECT)lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;

        if (!InitDocConv (lpobj, !POPUP_NETDLG))
             return OLE_OK;             // document is not loaded , it is OK.

        lpobj->fCmd = ACT_ADVISE | ACT_REQUEST;
        FarInitAsyncCmd (lpobj, OLE_LNKPASTE, LNKOPENUPDATE);
        return LnkOpenUpdate (lpobj);

    }
    else {
errRtn:
        if (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

    return retval;
}



// !!! EmbPaste and LnkPaste Can be combined
OLESTATUS FARINTERNAL  EmbPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    LPOBJECT_LE lpobj = NULL;
    HANDLE      hnative;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;

    if (!IsClipboardFormatAvailable (cfOwnerLink))
        return OLE_ERROR_CLIPBOARD;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD
    if (!bWLO) {
        // we are not running under WLO
        hInfo = GetClipboardData (cfOwnerLink);
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    SetEmbeddedTopic (lpobj);

    hnative = GetClipboardData (cfNative);
    if (!(lpobj->hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
        goto errRtn;

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname,
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);

    if (retval == OLE_OK) {
        SetExtents (lpobj);
        *lplpoleobject = (LPOLEOBJECT) lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    }
    else {
errRtn:
        // Note:  This oledelete should not result in any async commands.
        if  (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

#ifdef EXCEL_BUG
    // Some server apps (ex: Excel) copy picture (to clipboard) which is
    // formatted for printer DC. So, we want to update the picture if the
    // server app is running, and the it's a old server

    if ((retval == OLE_OK) && (!lpobj->bOleServer)) {
        lpobj->fCmd =  LN_EMBACT | ACT_NOLAUNCH | ACT_REQUEST | ACT_UNLAUNCH;
        FarInitAsyncCmd (lpobj, OLE_EMBPASTE, EMBOPENUPDATE);
        if ((retval = EmbOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            return OLE_OK;
    }
#endif

    return retval;
}



BOOL INTERNAL SetLink (
    LPOBJECT_LE     lpobj,
    HANDLE          hinfo,
    LPSTR FAR *     lpLpClass
){
    LPSTR   lpinfo;
    char    chVerb[80];
    // If there exits a conversation, then terminate it.

    if (!(lpinfo = GlobalLock (hinfo)))
        return FALSE;

    *lpLpClass = lpinfo;

    lpobj->app = GlobalAddAtom (lpinfo);
    SetExeAtom (lpobj);
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 80);

//  lpobj->aServer = GetAppAtom (lpinfo);

    lpinfo += lstrlen (lpinfo) + 1;
    lpobj->topic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        lpobj->item = GlobalAddAtom (lpinfo);
    else
        lpobj->item = (ATOM)0;

    if (lpobj->hLink) {             // As the atoms have already changed,
        GlobalFree (lpobj->hLink);  // lpobj->hLink becomes irrelevant.
        lpobj->hLink = NULL;
    }

    if (lpinfo)
        GlobalUnlock(hinfo);

    if (!lpobj->app)
        return FALSE;

    if (!lpobj->topic && (lpobj->head.ctype == CT_LINK))
        return FALSE;

    lpobj->hLink = DuplicateGlobal (hinfo, GMEM_MOVEABLE);
    return TRUE;
}



HANDLE INTERNAL GetLink (LPOBJECT_LE lpobj)
{
    HANDLE  hLink = NULL;
    LPSTR   lpLink;
    int     len;
    WORD    size;

    if (lpobj->hLink)
        return lpobj->hLink;

    size = 4;    // three nulls and one null at the end
    size += (WORD)GlobalGetAtomLen (lpobj->app);
    size += (WORD)GlobalGetAtomLen (lpobj->topic);
    size += (WORD)GlobalGetAtomLen (lpobj->item);

    if (!(hLink = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;

    if (!(lpLink = GlobalLock (hLink))) {
        GlobalFree (hLink);
        return NULL;
    }

    len = (int) GlobalGetAtomName (lpobj->app, lpLink, size);
    lpLink += ++len;

    len = (int) GlobalGetAtomName (lpobj->topic, lpLink, (size -= (WORD)len));
    lpLink += ++len;

    if (!lpobj->item)
        *lpLink = '\0';
    else {
        len = (int) GlobalGetAtomName (lpobj->item, lpLink, size - len);
        lpLink += len;
    }

    *++lpLink = '\0';     // put another null the end
    GlobalUnlock (hLink);
    return (lpobj->hLink = hLink);

}


void FARINTERNAL SetEmbeddedTopic (LPOBJECT_LE lpobj)
{
    LPCLIENTDOC lpdoc;
    char        buf[MAX_STR];
    char        buf1[MAX_STR];
    LPSTR       lpstr, lptmp;
    int         len;

    if (lpobj->topic)
        GlobalDeleteAtom (lpobj->topic);

    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = (ATOM)0;
    }

    lpobj->cDrive       = '\0';
    lpobj->dwNetInfo    = 0;
    lpobj->head.ctype   = CT_EMBEDDED;

    lpdoc = (LPCLIENTDOC) lpobj->head.lhclientdoc;
    lpstr = (LPSTR) buf;
    lptmp = (LPSTR) buf1;
    ASSERT(lpdoc->aDoc, "lpdoc->aDoc is null");
    if (!GlobalGetAtomName (lpdoc->aDoc, lpstr, sizeof(buf)))
        goto fail;

     // strip the path
     lpstr += (len = lstrlen(lpstr));
     while (--lpstr != (LPSTR) buf) {
         if ((*lpstr == '\\') || (*lpstr == ':')) {
             lpstr++;
             break;
         }
     }

    if (!(len = GlobalGetAtomName (lpdoc->aClass, lptmp, sizeof(buf1))))
        goto fail;
    if (lstrlen(lpstr) + 2 + len < MAX_STR - 1)
    {
        lstrcat (lptmp, "%");
        lstrcat (lptmp, lpstr);
        lstrcat (lptmp, "%");
    }
    lpstr = lptmp;
    lptmp += lstrlen (lptmp);

    if (lpobj->head.aObjName) {
        if (!GlobalGetAtomName (lpobj->head.aObjName, lptmp, sizeof(buf1)-lstrlen(lpstr)-1))
            goto fail;
    }

    if ((embStr[EMB_ID_INDEX] += 1) > '9') {
        embStr[EMB_ID_INDEX] = '0';
        if ((embStr[EMB_ID_INDEX - 1] += 1) > '9') {
            embStr[EMB_ID_INDEX - 1] = '0';
            if ((embStr[EMB_ID_INDEX - 2] += 1) > '9')
                embStr[EMB_ID_INDEX - 2] = '0';
        }
    }

    if (lstrlen(lpstr) - lstrlen(embStr) < MAX_STR - 1)
        lstrcat (lptmp, embStr);
    else
        goto fail;

    lpobj->topic = GlobalAddAtom (lpstr);
    goto end;

fail:
    lpobj->topic = (ATOM)0;
    // Topic, item have changed, lpobj->hLink is out of date.

end:
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
}


/////////////////////////////////////////////////////////////////////
//                                                                 //
// Routines related to the asynchronous processing.                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////

void NextAsyncCmd (
    LPOBJECT_LE lpobj,
    UINT        mainRtn
){
    lpobj->mainRtn  = mainRtn;
    lpobj->subRtn   = 0;

}

void  InitAsyncCmd (
    LPOBJECT_LE lpobj,
    UINT        cmd,
    UINT        mainRtn
){

    lpobj->asyncCmd = cmd;
    lpobj->mainErr  = OLE_OK;
    lpobj->mainRtn  = mainRtn;
    lpobj->subRtn   = 0;
    lpobj->subErr   = 0;
    lpobj->bAsync   = 0;
    lpobj->endAsync = 0;
    lpobj->errHint  = 0;

}

OLESTATUS EndAsyncCmd (LPOBJECT_LE lpobj)
{
    OLESTATUS   olderr;


    if (!lpobj->endAsync) {
        lpobj->asyncCmd = OLE_NONE;
        return OLE_OK;
    }


    // this is an asynchronous operation. Send callback with or without
    // error.

    switch (lpobj->asyncCmd) {

        case    OLE_DELETE:
            break;

        case    OLE_COPYFROMLNK:
        case    OLE_CREATEFROMFILE:
            // change the topic name to embedded.
            SetEmbeddedTopic (lpobj);
            break;

        case    OLE_LOADFROMSTREAM:
        case    OLE_LNKPASTE:
        case    OLE_RUN:
        case    OLE_SHOW:
        case    OLE_ACTIVATE:
        case    OLE_UPDATE:
        case    OLE_CLOSE:
        case    OLE_RECONNECT:
        case    OLE_CREATELINKFROMFILE:
        case    OLE_CREATEINVISIBLE:
        case    OLE_CREATE:
        case    OLE_CREATEFROMTEMPLATE:
        case    OLE_SETUPDATEOPTIONS:
        case    OLE_SERVERUNLAUNCH:
        case    OLE_SETDATA:
        case    OLE_REQUESTDATA:
        case    OLE_OTHER:
            break;

        case    OLE_EMBPASTE:
            lpobj->mainErr = OLE_OK;
            break;

        default:
            DEBUG_OUT ("unexpected maincmd", 0);
            break;

    }

    lpobj->bAsync   = FALSE;
    lpobj->endAsync = FALSE;
    lpobj->oldasyncCmd = lpobj->asyncCmd;
    olderr          = lpobj->mainErr;
    lpobj->asyncCmd = OLE_NONE;  // no async command in progress.

    if (lpobj->head.lpclient)
        ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RELEASE);

    lpobj->mainErr  = OLE_OK;
    return olderr;
}


BOOL   ProcessErr   (LPOBJECT_LE  lpobj)
{

    if (lpobj->subErr == OLE_OK)
        return FALSE;

    if (lpobj->mainErr == OLE_OK)
        lpobj->mainErr = lpobj->subErr;

    lpobj->subErr = OLE_OK;
    return TRUE;
}


void ScheduleAsyncCmd (LPOBJECT_LE  lpobj)
{

    // replacs this with direct proc jump later on.
    lpobj->bAsync = FALSE;

    // if the object is active and we do pokes we go thru this path
    // !!! We may have to go thru the endasynccmd.

    if ((lpobj->asyncCmd == OLE_OTHER)
            || ((lpobj->asyncCmd == OLE_SETDATA) && !lpobj->mainRtn)) {
        lpobj->endAsync = TRUE;
        lpobj->mainErr = lpobj->subErr;
        EndAsyncCmd (lpobj);
        if (lpobj->bUnlaunchLater) {
            lpobj->bUnlaunchLater = FALSE;
            CallEmbLnkDelete(lpobj);
        }

        return;
    }

    switch (lpobj->mainRtn) {

        case EMBLNKDELETE:
            EmbLnkDelete (lpobj);
            break;

        case LNKOPENUPDATE:
            LnkOpenUpdate (lpobj);
            break;

        case DOCSHOW:
            DocShow (lpobj);
            break;


        case EMBOPENUPDATE:
            EmbOpenUpdate (lpobj);
            break;


        case EMBLNKCLOSE:
            EmbLnkClose (lpobj);
            break;

        case LNKSETUPDATEOPTIONS:
            LnkSetUpdateOptions (lpobj);
            break;

        case LNKCHANGELNK:
            LnkChangeLnk (lpobj);
            break;

        case REQUESTDATA:
            RequestData (lpobj, 0);
            break;

        default:
            DEBUG_OUT ("Unexpected asyn command", 0);
            break;
    }

    return;
}

void SetNetDrive (LPOBJECT_LE lpobj)
{
    char    buf[MAX_STR];

    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))
            && (buf[1] == ':')) {
        AnsiUpperBuff ((LPSTR) buf, 1);
        lpobj->cDrive = buf[0];
    }
}

HANDLE GetNetNameHandle (LPOBJECT_LE lpobj)
{
    HANDLE  hNetName;
    LPSTR   lpNetName;
    int     size;

    if (!(size = GlobalGetAtomLen (lpobj->aNetName)))
        return NULL;

    size++;
    if (!(hNetName = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;

    if (lpNetName = GlobalLock (hNetName)) {
        GlobalUnlock (hNetName);
        if (GlobalGetAtomName(lpobj->aNetName, lpNetName, size))
            return hNetName;
    }

    // error case
    GlobalFree (hNetName);
    return NULL;
}

BOOL AreTopicsEqual (
    LPOBJECT_LE lpobj1,
    LPOBJECT_LE lpobj2
){
    char    buf1[MAX_STR];
    char    buf2[MAX_STR];

    if (lpobj1->aNetName != lpobj2->aNetName)
        return FALSE;

    if (!lpobj1->aNetName) {
        if (lpobj1->topic == lpobj2->topic)
            return TRUE;

        return FALSE;
    }

    if (!GlobalGetAtomName (lpobj1->topic, buf1, MAX_STR))
        return FALSE;

    if (!GlobalGetAtomName (lpobj2->topic, buf2, MAX_STR))
        return FALSE;

    if (!lstrcmpi (&buf1[1], &buf2[1]))
        return TRUE;

    return FALSE;
}

ATOM FARINTERNAL wAtomCat (
   ATOM        a1,
   ATOM        a2
){
    char    buf[MAX_STR+MAX_STR];
    LPSTR   lpBuf = (LPSTR)buf;

    if (!GlobalGetAtomName (a1, lpBuf, MAX_STR+MAX_STR))
        return (ATOM)0;

    lpBuf += lstrlen(lpBuf);

    if (!GlobalGetAtomName(a2, lpBuf, MAX_STR))
        return (ATOM)0;

    return GlobalAddAtom ((LPSTR) buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\error.c ===
/****************************** Module Header ******************************\
* Module Name: ERROR.C
*
* PURPOSE:  Contains routines which are commonly used, as method functions, by
*           bm.c, mf.c and dib.c. These routines do nothing more than 
*           returning an error code.
*
* Created: November 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (11/20/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

OLESTATUS FARINTERNAL ErrQueryRelease (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    
    return OLE_ERROR_STATIC;
}

OLE_RELEASE_METHOD FARINTERNAL ErrQueryReleaseMethod (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrPlay (
    LPOLEOBJECT lpobj,
    UINT        verb,
    BOOL        fAct,
    BOOL        fShow
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(verb);
    UNREFERENCED_PARAMETER(fAct);
    UNREFERENCED_PARAMETER(fShow);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrShow (
    LPOLEOBJECT lpobj,
    BOOL        fAct
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(fAct);

    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrAbort (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL  ErrCopyFromLink(
    LPOLEOBJECT         lpobj,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpclient);
    UNREFERENCED_PARAMETER(lhclientdoc);
    UNREFERENCED_PARAMETER(lpobjname);
    UNREFERENCED_PARAMETER(lplpobj);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetHostNames (
    LPOLEOBJECT lpobj,
    OLE_LPCSTR  lpclientName,
    OLE_LPCSTR  lpdocName
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpclientName);
    UNREFERENCED_PARAMETER(lpdocName);

    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetTargetDevice (
    LPOLEOBJECT lpobj,
    HANDLE      hDevInfo
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(hDevInfo);

    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetColorScheme (
    LPOLEOBJECT               lpobj,
    OLE_CONST LOGPALETTE FAR* lplogpal
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lplogpal);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetBounds(
    LPOLEOBJECT         lpobj,
    OLE_CONST RECT FAR* lprc
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lprc);

    return OLE_ERROR_MEMORY;
}


OLESTATUS FARINTERNAL  ErrQueryOpen (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrActivate (
    LPOLEOBJECT         lpobj,
    UINT                verb,
    BOOL                fShow,
    BOOL                fAct,
    HWND                hWnd,
    OLE_CONST RECT FAR* lprc
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(verb);
    UNREFERENCED_PARAMETER(fShow);
    UNREFERENCED_PARAMETER(fAct);
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrEdit (
    LPOLEOBJECT lpobj,
    BOOL        fShow,
    HWND        hWnd,
    LPRECT      lprc
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(fShow);
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrClose (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrUpdate (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrReconnect (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object

}


OLESTATUS FARINTERNAL ErrSetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE          hData
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(cfFormat);
    UNREFERENCED_PARAMETER(hData);

    return OLE_ERROR_MEMORY;
}


OLESTATUS   FARINTERNAL  ErrReadFromStream (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    LPOLESTREAM     lpstream
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(cfFormat);
    UNREFERENCED_PARAMETER(lpstream);

    return OLE_ERROR_STREAM;
}



OLESTATUS FARINTERNAL ErrQueryOutOfDate (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);
 
   return OLE_OK;
}


OLESTATUS FARINTERNAL ErrObjectConvert (
    LPOLEOBJECT         lpobj,
    OLE_LPCSTR          lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpprotocol);
    UNREFERENCED_PARAMETER(lpclient);
    UNREFERENCED_PARAMETER(lhclientdoc);
    UNREFERENCED_PARAMETER(lpobjname);
    UNREFERENCED_PARAMETER(lplpobj);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrGetUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE  FAR  *lpoptions
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpoptions);

    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrSetUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE       options
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(options);

    return OLE_ERROR_STATIC;

}

LPVOID  FARINTERNAL ErrQueryProtocol (
    LPOLEOBJECT lpobj,
    LPCSTR      lpprotocol
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpprotocol);
 
   return NULL;
}

OLESTATUS FARINTERNAL ErrRequestData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(cfFormat);

    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrExecute (
    LPOLEOBJECT     lpobj,
    HANDLE          hData,
    UINT            wReserved
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(hData);
    UNREFERENCED_PARAMETER(wReserved);

    return OLE_ERROR_STATIC;
}



OLESTATUS FARINTERNAL ErrObjectLong (
    LPOLEOBJECT     lpobj,
    UINT            wFlags,
    LPLONG          lplong
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(wFlags);
    UNREFERENCED_PARAMETER(lplong);

    return OLE_ERROR_STATIC;
}


HANDLE FARINTERNAL DuplicateGDIdata (
    HANDLE          hSrcData,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpSrcMfp;
        LPMETAFILEPICT  lpDstMfp = NULL;        
        HANDLE          hMF = NULL;
        HANDLE          hDstMfp = NULL;
        
        if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
            return NULL;
        
        GlobalUnlock (hSrcData);
        
        if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
            return NULL;
        
        if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
            goto errMfp;    

        if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
            goto errMfp;
        
        GlobalUnlock (hDstMfp);
        
        *lpDstMfp = *lpSrcMfp;
        lpDstMfp->hMF = hMF;
        return hDstMfp;
errMfp:
        if (hMF)
            DeleteMetaFile (hMF);
        
        if (hDstMfp)
            GlobalFree (hDstMfp);
        
        return NULL;
    }
    
    if (cfFormat == CF_BITMAP) {
        DWORD dwSize;
        
        return BmDuplicate (hSrcData, &dwSize, NULL);
    }
    
    if (cfFormat == CF_DIB) 
        return DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
    
    if (cfFormat == CF_ENHMETAFILE) 
        return CopyEnhMetaFile(hSrcData, NULL);

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\main.c ===
/****************************** Module Header ******************************\
* Module Name: MAIN.C
*
* PURPOSE: WinMain, WEP and some other misc routines
*
* Created: 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik   (04/01/91)  Pulled some routines, into this, from ole.c.
*   curts    Create portable version for win16/32.
*
\***************************************************************************/

#include <windows.h>
#include <reghelp.hxx>

#include "dll.h"
#include "strsafe.h"

#ifndef WF_WLO
#define WF_WLO  0x8000
#endif

// ordinal number new win31 API IsTask
#define ORD_IsTask  320

#define NUM_DLL     30  /* space for this many DLL_ENTRYs is created on */
			/* each alloc/realloc */

OLECLIPFORMAT   cfOwnerLink     = 0;     // global variables for clip frmats
OLECLIPFORMAT   cfObjectLink    = 0;
OLECLIPFORMAT   cfLink          = 0;
OLECLIPFORMAT   cfNative        = 0;
OLECLIPFORMAT   cfBinary        = 0;
OLECLIPFORMAT   cfFileName      = 0;
OLECLIPFORMAT   cfNetworkName   = 0;

ATOM            aStdHostNames;
ATOM            aStdTargetDevice ;
ATOM            aStdDocDimensions;
ATOM            aStdDocName;
ATOM            aStdColorScheme;
ATOM            aNullArg = 0;
ATOM            aSave;
ATOM            aChange;
ATOM            aClose;
ATOM            aSystem;
ATOM            aOle;
ATOM            aClipDoc;
ATOM            aPackage;

// Used in work around for MSDraw bug
ATOM            aMSDraw;

extern LPCLIENTDOC  lpHeadDoc;
extern LPCLIENTDOC  lpTailDoc;

extern RENDER_ENTRY stdRender[];

HANDLE          hInstDLL;

/* HANDLE   hDllTable;          !!! Add this when bug in WEP is fixed */
DLL_ENTRY   lpDllTable[NUM_DLL]; //!!! change this when WEP bug is fixed
DWORD       dllTableSize;
int         iLast = 0;
int         iMax = NUM_DLL -1;
int         iUnloadableDll =  0; // index to handler than can be freed up

char        packageClass[] = "Package";

// For QuerySize() API & methods.
extern  OLESTREAMVTBL  dllStreamVtbl;
extern  CLIENTDOC      lockDoc;


// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD reserved

DWORD  dwOleVer = 0x0901L;  // change this when we want to update dll version
			    // number

WORD   wReleaseVer = 0x0001;  // This is used while object is being saved to
			      // file. There is no need to change this value
			      // whenever we change ole dll version number

static BOOL  bLibInit = FALSE;



HANDLE  hModule;

#define MAX_HIMETRIC    0x7FFF

int     maxPixelsX = MAX_HIMETRIC;
int     maxPixelsY = MAX_HIMETRIC;
void    SetMaxPixel (void);

VOID FAR PASCAL WEP (int);

//////////////////////////////////////////////////////////////////////////////
//
//  int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
//
//  The main library entry point. This routine is called when the library
//  is loaded.
//
//  Arguments:
//
//      hInst       -   dll's instance handle
//      wDataSeg    -   DS register value
//      cbHeapSize  -   heap size defined def file
//      lpszCmdLine -   command line info
//
//  Returns:
//
//      0   -   failure
//      1   -   success
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

#ifdef WIN32
BOOL LibMain(
   HANDLE hInst,
   ULONG Reason,
   PCONTEXT Context
#endif  // WIN32

){
    WNDCLASS  wc;
    int     i;
#ifdef WIN32
    char szDocClass[] = "OleDocWndClass" ;
    char szSrvrClass[] = "OleSrvrWndClass" ;
#endif

    Puts("LibMain");


#ifdef WIN32                        // begin WIN32
    UNREFERENCED_PARAMETER(Context);
    if (Reason == DLL_PROCESS_DETACH)
    {
	WEP(0);
   UnregisterClass (szDocClass, hInst) ;
   UnregisterClass (szSrvrClass, hInst) ;
	return TRUE;
    }
    else if (Reason != DLL_PROCESS_ATTACH)
	return TRUE;
#endif                              // end WIN32

    bLibInit  = TRUE;
    hInstDLL  = hInst;
    hModule = GetModuleHandle ("OLECLI");

    // REGISTER LINK FORMAT

    cfObjectLink    = (OLECLIPFORMAT)RegisterClipboardFormat("ObjectLink");
    cfLink          = (OLECLIPFORMAT)RegisterClipboardFormat("Link");
    cfOwnerLink     = (OLECLIPFORMAT)RegisterClipboardFormat("OwnerLink");
    cfNative        = (OLECLIPFORMAT)RegisterClipboardFormat("Native");
    cfBinary        = (OLECLIPFORMAT)RegisterClipboardFormat("Binary");
    cfFileName      = (OLECLIPFORMAT)RegisterClipboardFormat("FileName");
    cfNetworkName   = (OLECLIPFORMAT)RegisterClipboardFormat("NetworkName");

    if (!(cfObjectLink && cfOwnerLink && cfNative && cfLink))
	return 0;

    // SET UP OLEWNDCLASS
    wc.style        = 0;
    wc.lpfnWndProc  = DocWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG_PTR);     //we are storing longs
    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName= szDocClass;
    if (!RegisterClass(&wc))
	     return 0;

    wc.lpfnWndProc = SrvrWndProc;
    wc.lpszClassName = szSrvrClass ;

    if (!RegisterClass(&wc))
	return 0;
/*
    // !!! Add this when bug in WEP is fixed.
    // Allocate memory for DLL table
    dllTableSize = NUM_DLL * sizeof(DLL_ENTRY);
    if (!(hDllTable = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
			    dllTableSize)))
	return 0;

    if (!(lpDllTable = (DLL_ENTRY FAR *) GlobalLock (hDllTable)))
	return 0;
*/

    // !!! remove the following when WEP bug is fixed
    for (i = 0; i < NUM_DLL; i++)
	lpDllTable[i].aDll = (ATOM)0;

    // !!! BEGIN hack for Pbrush.

    lpDllTable[0].hDll                  = NULL;
    lpDllTable[0].aDll                  = GlobalAddAtom ((LPSTR) "ole");
    lpDllTable[0].Load                  = PbLoadFromStream;
    lpDllTable[0].Clip                  = PbCreateFromClip;
    lpDllTable[0].Link                  = PbCreateLinkFromClip;
    lpDllTable[0].Create                = PbCreate;
    lpDllTable[0].CreateFromTemplate    = PbCreateFromTemplate;
    lpDllTable[0].CreateFromFile        = PbCreateFromFile;
    lpDllTable[0].CreateLinkFromFile    = PbCreateLinkFromFile;
    lpDllTable[0].CreateInvisible       = PbCreateInvisible;


    // !!! END hack for pbrush

    // For ObjectSize API
    dllStream.lpstbl      = (LPOLESTREAMVTBL) &dllStreamVtbl;
    dllStream.lpstbl->Put = DllPut;

    // add the atoms required.
    aStdDocName       = GlobalAddAtom ((LPSTR)"StdDocumentName");
    aSave             = GlobalAddAtom ((LPSTR)"Save");
    aChange           = GlobalAddAtom ((LPSTR)"Change");
    aClose            = GlobalAddAtom ((LPSTR)"Close");
    aSystem           = GlobalAddAtom ((LPSTR)"System");
    aOle              = GlobalAddAtom ((LPSTR)"OLEsystem");
    aPackage          = GlobalAddAtom ((LPSTR) packageClass);

    // Used in work around for MSDraw bug
    aMSDraw           = GlobalAddAtom ((LPSTR) "MSDraw");

    // clipboard document name atom
    aClipDoc          = GlobalAddAtom ((LPSTR)"Clipboard");

    stdRender[0].aClass = GlobalAddAtom ("METAFILEPICT");
    stdRender[1].aClass = GlobalAddAtom ("DIB");
    stdRender[2].aClass = GlobalAddAtom ("BITMAP");
    stdRender[3].aClass = GlobalAddAtom ("ENHMETAFILE");

    SetMaxPixel();

    return 1;
}



//////////////////////////////////////////////////////////////////////////////
//
//  VOID FAR PASCAL WEP (nParameter)
//
//  Called just before the library is being unloaded. Delete all the atoms
//  added by this dll and also frees up all unloaded handler dlls.
//
//  Arguments:
//
//      nParameter  -   Termination code
//
//  Returns:
//
//      none
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


VOID FAR PASCAL WEP (int nParameter)
{
    int i;


    Puts("LibExit");

#ifdef WIN32                        // begin WIN32
	UNREFERENCED_PARAMETER(nParameter);
	DEBUG_OUT ("---L&E DLL EXIT---\n",0)
#endif                              // end WIN32
    // case when the DLLs are missing

    if (!bLibInit)
	return;

    // Delete atoms added by us

    for (i = 0; i < NUM_RENDER; i++) {
	if (stdRender[i].aClass)
	    GlobalDeleteAtom (stdRender[i].aClass);
    }

    if (aStdDocName)
	GlobalDeleteAtom (aStdDocName);
    if (aSave)
	GlobalDeleteAtom (aSave);
    if (aChange)
	GlobalDeleteAtom (aChange);
    if (aClose)
	GlobalDeleteAtom (aClose);
    if (aSystem)
	GlobalDeleteAtom (aSystem);
    if (aOle)
	GlobalDeleteAtom (aOle);
    if (aPackage)
	GlobalDeleteAtom (aPackage);
    if (aClipDoc)
	GlobalDeleteAtom (aClipDoc);
    if (aMSDraw)
	GlobalDeleteAtom (aMSDraw);

    // Free handler dlls if there are any still loaded. Entry 0 is used for
    // Pbrush handler which is part of this dll.


    for (i = 0; i <= iLast; i++) {
	if (lpDllTable[i].aDll)
	    GlobalDeleteAtom (lpDllTable[i].aDll);

	if (lpDllTable[i].hDll)
	    FreeLibrary (lpDllTable[i].hDll);
    }



/* !!! Add this when bug in WEP is fixed

    if (lpDllTable)
	GlobalUnlock (hDllTable);

    if (hDllTable)
	GlobalFree (hDllTable);
*/
}

int FARINTERNAL LoadDll (LPCSTR   lpClass)
{
    char        str[MAX_STR];
    char        str1[MAX_STR];
    ATOM        aDll = (ATOM)0;
    int         index;
    int         iEmpty;
    BOOL        found = FALSE;
    HANDLE      hDll;
    LONG        cb = MAX_STR;

    if (!lstrcmpi (lpClass, "Pbrush"))
	return 0;

    if (FAILED(StringCchCopy(str, sizeof(str)/sizeof(str[0]), lpClass)))
        return 0;
    if (FAILED(StringCchCat(str, sizeof(str)/sizeof(str[0]), "\\protocol\\StdFileEditing\\handler32")))
        return 0;
    if (QueryClassesRootValueA (str, str1, &cb))
        return INVALID_INDEX;

    if (aDll = GlobalFindAtom (str1)) {
	for (index = 1; index <= iLast && index < sizeof(lpDllTable)/sizeof(lpDllTable[0]); index++) {
	    if (lpDllTable[index].aDll == aDll) { // Dll already loaded
		lpDllTable[index].cObj ++;

		if (index == iUnloadableDll)  {
		    // since the object count is not zero anymore, this
		    // handler can not be freed up.
		    iUnloadableDll = 0;
		}

		return index;
	    }
	}
    }

    aDll = GlobalAddAtom (str1);

    // Look for an empty entry
    for (iEmpty = 1; iEmpty <= iLast && iEmpty < sizeof(lpDllTable)/sizeof(lpDllTable[0]); iEmpty++) {
	if (!lpDllTable[iEmpty].aDll) {
	    found = TRUE;
	    break;
	}
    }

    if (iEmpty > iMax)
	goto errLoad;
/*
    if (!found) {// no empty entry exists create a new one if necessary.
	if (iEmpty > iMax) {
	    dllTableSize += (blockSize = NUM_DLL * sizeof(DLL_ENTRY));
	    hTable = GlobalReAlloc (hDllTable, dllTableSize,
				GMEM_MOVEABLE | GMEM_ZEROINIT);
	    if (hTable == hDllTable)
		iMax += NUM_DLL;
	    else {
		dllTableSize -= blockSize;
		iEmpty = INVALID_INDEX;
	    }
	}
    }
*/
#ifdef WIN32
    hDll = LoadLibrary ((LPSTR) str1);
#endif

    if (MAPVALUE(hDll < 32, !hDll))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Load = (_LOAD)GetProcAddress(hDll,
					  "DllLoadFromStream")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Clip = (_CLIP)GetProcAddress (hDll,
					    "DllCreateFromClip")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Link = (_LINK)GetProcAddress (hDll,
					    "DllCreateLinkFromClip")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromTemplate = (_CREATEFROMTEMPLATE)
					     GetProcAddress (hDll,
					    "DllCreateFromTemplate")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Create = (_CREATE)GetProcAddress (hDll,
					  "DllCreate")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromFile = (_CREATEFROMFILE)GetProcAddress (hDll,
						    "DllCreateFromFile")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].CreateLinkFromFile = (_CREATELINKFROMFILE)GetProcAddress (hDll,
					    "DllCreateLinkFromFile")))
	goto errLoad;

    lpDllTable[iEmpty].CreateInvisible = (_CREATEINVISIBLE)GetProcAddress (hDll,
					    "DllCreateInvisible");

    lpDllTable[iEmpty].aDll = aDll;
    lpDllTable[iEmpty].cObj = 1;
    lpDllTable[iEmpty].hDll = hDll;
    if (iEmpty > iLast)
	iLast++;
    return iEmpty;

errLoad:
    if (aDll)
	GlobalDeleteAtom (aDll);
    if (MAPVALUE(hDll >= 32, !hDll))
	FreeLibrary (hDll);
    return INVALID_INDEX;
}


// unload the the handler that can be free up (whose object count is NULL)

void FARINTERNAL UnloadDll ()
{
    if (!iUnloadableDll)
	return;

    if (iUnloadableDll == iLast)
	iLast--;

    if (iUnloadableDll >= sizeof(lpDllTable)/sizeof(lpDllTable[0]))
        return;

    if (lpDllTable[iUnloadableDll].aDll)
	GlobalDeleteAtom (lpDllTable[iUnloadableDll].aDll);
    lpDllTable[iUnloadableDll].aDll = (ATOM)0;
    FreeLibrary (lpDllTable[iUnloadableDll].hDll);
    lpDllTable[iUnloadableDll].hDll = NULL;

    iUnloadableDll = 0;
}


//
// Reduce the object count of the handler, refered to by the index, by one.
// If the object count becomes NULL, free up the handler that is ready to be
// freed (refered to by index iUnloadableDll), and then make this handler the
// freeable one.
//
// As you can see we are trying to implement a simple mechanism of caching.
//

void FARINTERNAL DecreaseHandlerObjCount (int iTable)
{
    if (!iTable)
	return;

    if (iTable != INVALID_INDEX) {
	ASSERT (lpDllTable[iTable].cObj, "Handler Obj count is already NULL");
	if (!--lpDllTable[iTable].cObj) {
	    UnloadDll ();
	    iUnloadableDll = iTable;
	}
    }
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FARINTERNAL CreatePictFromClip (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, lpClass, ctype)
*
*  CreatePictFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create a static picture object if
*  it understands any rendering formats on the clipboard. Currently, it
*  understands only bitmaps and metafiles.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL CreatePictFromClip (
   LPOLECLIENT         lpclient,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpobj,
   OLEOPT_RENDER       optRender,
   OLECLIPFORMAT       cfFormat,
   LPSTR               lpClass,
   LONG                objType
){
    OLESTATUS   retVal = OLE_ERROR_OPTION;

    *lplpobj = NULL;

    if (optRender == olerender_none)
	return OLE_OK;
    else if (optRender == olerender_format) {
	switch (cfFormat) {
	    case 0:
		return OLE_ERROR_FORMAT;

	    case CF_ENHMETAFILE:
		return EmfPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    case CF_METAFILEPICT:
		return MfPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    case CF_DIB:
		return DibPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    case CF_BITMAP:
		return BmPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    default:
		return GenPaste (lpclient, lhclientdoc, lpobjname, lplpobj,
			    lpClass, cfFormat, objType);
	}
    }
    else if (optRender == olerender_draw) {
	cfFormat = (OLECLIPFORMAT)EnumClipboardFormats (0);
	while ((cfFormat) && (retVal > OLE_WAIT_FOR_RELEASE)) {
	    switch (cfFormat) {

		case CF_ENHMETAFILE:
		    retVal = EmfPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);
		    break;

		case CF_METAFILEPICT:
		    retVal = MfPaste (lpclient, lhclientdoc,
				lpobjname, lplpobj, objType);
		    break;

		case CF_DIB:
		    retVal = DibPaste (lpclient, lhclientdoc,
				lpobjname, lplpobj, objType);
		    break;

		case CF_BITMAP:
		    retVal = BmPaste (lpclient, lhclientdoc,
				lpobjname, lplpobj, objType);
		    break;
	    }

	    cfFormat = (OLECLIPFORMAT)EnumClipboardFormats (cfFormat);
	}
    }

    return retVal;
}



OLESTATUS FARINTERNAL CreatePackageFromClip (
   LPOLECLIENT         lpclient,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpobj,
   OLEOPT_RENDER       optRender,
   OLECLIPFORMAT       cfFormat,
   LONG                objType
){
    char    file[MAX_STR+6];
    HANDLE  hData;
    LPSTR   lpFileName;

    if (!(hData = GetClipboardData (cfFileName))
	    || !(lpFileName = GlobalLock (hData)))
	return OLE_ERROR_CLIPBOARD;


    if (objType == OT_LINK) {
	StringCchCopy(file, sizeof(file)/sizeof(file[0]), lpFileName);
	StringCchCat(file, sizeof(file)/sizeof(file[0]), "/Link");
	lpFileName = (LPSTR) file;
    }

    GlobalUnlock (hData);

    return  CreateEmbLnkFromFile (lpclient, packageClass, lpFileName,
			NULL, lhclientdoc, lpobjname, lplpobj,
			optRender, cfFormat, OT_EMBEDDED);
}



void FARINTERNAL RemoveLinkStringFromTopic (
   LPOBJECT_LE lpobj
){
    char    buf[MAX_STR+6];
    int     i = 0;

    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))) {
	// scan the topic for "/Link"
	while (buf[i] != '/') {
	    if (!buf[i])
		return;
	    i++;
	}

	buf[i] = '\0';
	if (lpobj->topic)
	    GlobalDeleteAtom (lpobj->topic);
	lpobj->topic = GlobalAddAtom (buf);
    }
}


void SetMaxPixel ()
{
    HDC hdc;
    // find out the pixel equivalent of MAX_HIMETRIC in X and Y directions

    if (hdc = GetDC (NULL)) {
	maxPixelsX = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSX),
			2540);
	maxPixelsY = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSY),
			2540);
	ReleaseDC (NULL, hdc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\mf.c ===
/****************************** Module Header ******************************\
* Module Name:MF.C (Extensible Compound Documents - Metafile)
*
* PURPOSE:Handles all API routines for the metafile sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*
*   Raor, Srinik    (../../1990,91)  Designed, coded
*   Curts create NT version
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

WORD    wGDIds = 0;
OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

OLEOBJECTVTBL    vtblMF = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        MfRelease,         // Release
        ErrShow,           // show
        ErrPlay,           // play
        MfGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//
        ErrSetBounds,      // set viewport bounds
        MfEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //
        MfRelease,         // delete
        ErrSetHostNames,   //

        MfSaveToStream,    // write to file
        MfClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Lnk

        MfEqual,           // compares the given objects for data equality

        MfCopy,            // copy to clip

        MfDraw,            // draw the object

        ErrActivate,       // open
        ErrExecute,        // excute
        ErrClose,          // stop
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name
        ObjQueryType,      // Object type
        MfQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current

        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        MfChangeData       // change data of the existing object
};




OLESTATUS FARINTERNAL  MfRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;
    HOBJECT hobj;

    if (lpobj->mfp.hMF) {
        DeleteMetaFile (lpobj->mfp.hMF);
        lpobj->mfp.hMF = NULL;
    }

    if (lpobj->hmfp)
        GlobalFree (lpobj->hmfp);

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT)lpobj);

    if (hobj = lpobj->head.hobj) {
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}


OLESTATUS FARINTERNAL  MfSaveToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD       dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_MF lpobj     = (LPOBJECT_MF)lpoleobj;
    OLESTATUS   retVal    = OLE_ERROR_STREAM;
    HANDLE      hBits;
    LPSTR       lpBits;
    LONG        lSizeBytes;

    lSizeBytes = lpobj->sizeBytes - sizeof(METAFILEPICT)
                                  + sizeof(WIN16METAFILEPICT);

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"METAFILEPICT"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lSizeBytes, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (!(hBits = MGetMetaFileBits (lpobj->mfp.hMF)))
        return OLE_ERROR_MEMORY;

    if (lpBits = (LPSTR) GlobalLock (hBits)) {
        WIN16METAFILEPICT   w16mfp;

        ConvertMF32to16(&lpobj->mfp, &w16mfp);

        if (!PutBytes (lpstream, (LPSTR)&w16mfp, sizeof(WIN16METAFILEPICT)))
            if (!PutBytes (lpstream, (LPSTR)lpBits,
                        lSizeBytes - sizeof(WIN16METAFILEPICT)))
                retVal = OLE_OK;

        GlobalUnlock(hBits);
    }
    else
        retVal = OLE_ERROR_MEMORY;

    lpobj->mfp.hMF = MSetMetaFileBits (hBits);
    return retVal;
}




OLESTATUS FARINTERNAL  MfClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_MF lpobjsrc = (LPOBJECT_MF)lpoleobjsrc;
    LPOBJECT_MF lpobjMf;
    HANDLE      hmf;

    *lplpoleobj = (LPOLEOBJECT)NULL;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(hmf = CopyMetaFile (lpobjsrc->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    if (lpobjMf = MfCreateBlank (lhclientdoc, (LPSTR)lpobjname,
                        lpobjsrc->head.ctype)) {
        lpobjMf->mfp            = lpobjsrc->mfp;
        lpobjMf->sizeBytes      = lpobjsrc->sizeBytes;
        lpobjMf->mfp.hMF        = hmf;
        lpobjMf->head.lpclient  = lpclient;
        lpobjMf->head.mm        = lpobjMf->mfp.mm;
        MfSetExtents (lpobjMf);

        *lplpoleobj = (LPOLEOBJECT)lpobjMf;
        return OLE_OK;
    }

    return OLE_ERROR_MEMORY;
}



OLESTATUS FARINTERNAL  MfEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_MF lpobj1 = (LPOBJECT_MF)lpoleobj1;
    LPOBJECT_MF lpobj2 = (LPOBJECT_MF)lpoleobj2;
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    OLESTATUS   retval = OLE_ERROR_NOT_EQUAL;

    if (!(hBits1 = MGetMetaFileBits (lpobj1->mfp.hMF)))
        goto errEqual;

    if (!(hBits2 = MGetMetaFileBits (lpobj2->mfp.hMF)))
        goto errEqual;

    if (CmpGlobals (hBits1, hBits2))
        retval = OLE_OK;

errEqual:
    if (hBits1)
        lpobj1->mfp.hMF = MSetMetaFileBits (hBits1);

    if (hBits2)
        lpobj2->mfp.hMF = MSetMetaFileBits (hBits2);

    return retval;
}


OLESTATUS FARINTERNAL  MfCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;
    HANDLE      hMF;

    if (!(hMF = CopyMetaFile (lpobj->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    return (MfCopyToClip (lpobj, hMF));
}



OLESTATUS FARINTERNAL MfQueryBounds (
    LPOLEOBJECT lpoleobj,
    LPRECT      lpRc
){
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;
    Puts("MfQueryBounds");

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    // Bounds are given in MM_HIMETRIC mode.

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL  MfEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_MF   lpobj = (LPOBJECT_MF)lpoleobj;

    if (!cfFormat)
        return CF_METAFILEPICT;

    return 0;
}


OLESTATUS FARINTERNAL MfGetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    LPHANDLE      lphandle
){
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;

    if (cfFormat != CF_METAFILEPICT)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = GetHmfp (lpobj)))
        return OLE_ERROR_BLANK;

    return OLE_OK;
}


LPOBJECT_MF FARINTERNAL  MfCreateObject (
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete,
    LHCLIENTDOC     lhclientdoc,
    LPCSTR          lpobjname,
    LONG            objType
){
    LPOBJECT_MF     lpobj;

    if (lpobj = MfCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (MfChangeData ((LPOLEOBJECT)lpobj, hMeta, lpclient, fDelete) != OLE_OK) {
            MfRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}

// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.

OLESTATUS FARINTERNAL MfChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_MF     lpobj = (LPOBJECT_MF)lpoleobj;
    HANDLE          hNewMF;
    LPMETAFILEPICT  lpMetaPict;

    if ((lpMetaPict = (LPMETAFILEPICT) GlobalLock (hMeta)) == NULL) {
        if (fDelete)
            GlobalFree (hMeta);
        return OLE_ERROR_MEMORY;
    }

    GlobalUnlock (hMeta);

    if (!fDelete) {
        if (!(hNewMF = CopyMetaFile (lpMetaPict->hMF, NULL)))
            return OLE_ERROR_MEMORY;
    }
    else {
        hNewMF = lpMetaPict->hMF;
    }

    return MfUpdateStruct (lpobj, lpclient, hMeta, lpMetaPict, hNewMF, fDelete);
}


OLESTATUS INTERNAL MfUpdateStruct (
    LPOBJECT_MF     lpobj,
    LPOLECLIENT     lpclient,
    HANDLE          hMeta,
    LPMETAFILEPICT  lpMetaPict,
    HANDLE          hMF,
    BOOL            fDelete
){
    OLESTATUS   retVal;
    DWORD       size;
    HANDLE      hOldMF;

    hOldMF = lpobj->mfp.hMF;

    ASSERT(lpMetaPict->mm == MM_ANISOTROPIC, "Wrong mapping mode")
    if (lpMetaPict->mm != MM_ANISOTROPIC)
        retVal = OLE_ERROR_METAFILE;
    else if (!(size = MfGetSize (&hMF)))
        retVal = OLE_ERROR_BLANK;
    else {
        lpobj->mfp     = *lpMetaPict;
        lpobj->mfp.hMF = hMF;
        lpobj->sizeBytes = size + sizeof(METAFILEPICT);
        lpobj->head.lpclient = lpclient;
        lpobj->head.mm = lpobj->mfp.mm;
        if (lpobj->hmfp) {
            GlobalFree (lpobj->hmfp);
            lpobj->hmfp = NULL;
        }
        MfSetExtents (lpobj);
        if (hOldMF)
            DeleteMetaFile (hOldMF);
        retVal =  OLE_OK;
    }

    if (retVal != OLE_OK)
        DeleteMetaFile (hMF);

    if (fDelete)
        GlobalFree (hMeta);
    return retVal;
}


LPOBJECT_MF FARINTERNAL MfCreateBlank(
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType
){
    HOBJECT     hobj;
    LPOBJECT_MF lpobj;

    if(!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_MF))))
        return NULL;

    if (!(lpobj = (LPOBJECT_MF) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblMF;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                    (LPOLEOBJECT) lpobj, lpobjname);

    // Unlock will be done at object deletion time.
    return lpobj;
}


OLESTATUS  FARINTERNAL  MfLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType
){
    LPOLEOBJECT  lpoleobj  = NULL;
    OLESTATUS    retval    = OLE_ERROR_STREAM;
    HANDLE       hBytes    = NULL;
    LPSTR        lpBytes   = NULL;
    DWORD        dwSizeBytes;
    METAFILEPICT mfp;


    // Class name would've been read by this time.

    *lplpobj = NULL;

    switch (HIWORD(dwVerFromFile)) {

         case OS_WIN32:
            if (!(lpoleobj = (LPOLEOBJECT)EmfCreateBlank (lhclientdoc, lpobjname, objType)))
               return OLE_ERROR_MEMORY;
            break;

         case OS_WIN16:
         case OS_MAC:
            if (!(lpoleobj = (LPOLEOBJECT)MfCreateBlank (lhclientdoc, lpobjname, objType)))
               return OLE_ERROR_MEMORY;
            break;

         default:
            return OLE_ERROR_FILE_VER;

    }

    lpoleobj->lpclient = lpclient;

    if (GetBytes (lpstream, (LPSTR) &lpoleobj->cx, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &lpoleobj->cy, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &dwSizeBytes, sizeof(LONG)))
        goto error;

    if (!dwSizeBytes) {
        retval = OLE_ERROR_BLANK;
        goto error;
    }

    // if we are reading a MAC object we want to skip this
    if (HIWORD(dwVerFromFile) != OS_MAC) {
        WIN16METAFILEPICT w16mfp;

        if (GetBytes (lpstream, (LPSTR) &w16mfp, sizeof(WIN16METAFILEPICT)))
            goto error;

        ConvertMF16to32(&w16mfp, &mfp);
    }


    retval       = OLE_ERROR_MEMORY;
    dwSizeBytes -= sizeof(WIN16METAFILEPICT);

    if (!(hBytes = GlobalAlloc (GMEM_MOVEABLE, dwSizeBytes)))
        goto error;

    if (!(lpBytes = (LPSTR)GlobalLock (hBytes)))
        goto error;

    if (GetBytes (lpstream, (LPSTR)lpBytes, dwSizeBytes))
        goto error;

    switch (HIWORD(dwVerFromFile)){

      case OS_WIN32: {
        LPOBJECT_EMF lpemfobj = (LPOBJECT_EMF)lpoleobj;

        lpemfobj->sizeBytes = dwSizeBytes;
        if (!((HENHMETAFILE)lpemfobj->hemf = SetWinMetaFileBits(dwSizeBytes, lpBytes, 0 , &mfp)))
            goto error;
        EmfSetExtents (lpemfobj);

        break;
      }

      case OS_WIN16: {
         LPOBJECT_MF lpmfobj = (LPOBJECT_MF)lpoleobj;
		
        lpmfobj->mfp =  mfp;
        lpmfobj->sizeBytes = dwSizeBytes + sizeof(METAFILEPICT);
        lpmfobj->head.mm = lpmfobj->mfp.mm;
		GlobalUnlock (hBytes);
		lpBytes = NULL;
        if (!(lpmfobj->mfp.hMF = MSetMetaFileBits(hBytes)))
            goto error;
		hBytes = NULL;
        MfSetExtents (lpmfobj);

        break;
      }

      case OS_MAC: {
        LPOBJECT_MF lpmfobj = (LPOBJECT_MF)lpoleobj;

        lpmfobj->mfp.xExt = (int) lpmfobj->head.cx;
        lpmfobj->mfp.yExt = (int) lpmfobj->head.cy;

        if ((retval = wCreateDummyMetaFile (lpmfobj, lpmfobj->mfp.xExt,
                                   lpmfobj->mfp.yExt)) != OLE_OK)
            goto error;

        break;
      }

    }

    *lplpobj = lpoleobj;
    retval   = OLE_OK;

error:

    if (hBytes)
    {
        if (lpBytes)
            GlobalUnlock (hBytes);
        GlobalFree (hBytes);
    }

    if (retval != OLE_OK)
      OleDelete (lpoleobj);

    return retval;
}




OLESTATUS FARINTERNAL  MfPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HANDLE      hMeta;

    *lplpoleobject = NULL;

    if((hMeta = GetClipboardData (CF_METAFILEPICT)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) MfCreateObject (hMeta, lpclient,
                                                FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;
}




OLESTATUS INTERNAL MfCopyToClip (
    LPOBJECT_MF lpobj,
    HANDLE      hMF
){
    LPMETAFILEPICT  lpMeta;
    HANDLE          hMeta;

    if (!(hMeta = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return OLE_ERROR_MEMORY;

    if (lpMeta = (LPMETAFILEPICT) GlobalLock(hMeta)){
        *lpMeta = lpobj->mfp;
        if (hMF)
            lpMeta->hMF = hMF;
        else
            lpobj->mfp.hMF = NULL;
        GlobalUnlock (hMeta);
        SetClipboardData(CF_METAFILEPICT, hMeta);
        return OLE_OK;
    }

    GlobalFree(hMeta);
    return OLE_ERROR_MEMORY;
}



void FARINTERNAL MfSetExtents (LPOBJECT_MF lpobj)
{
    if (lpobj->mfp.xExt > 0) {
        // The extents are assumed to be in MM_HIMETIRC units
        lpobj->head.cx = (LONG) lpobj->mfp.xExt;
        lpobj->head.cy = (LONG) - lpobj->mfp.yExt;
    }
}


DWORD INTERNAL MfGetSize (LPHANDLE lphmf)
{
    HANDLE hBits;
    DWORD  size;

    if ((hBits = MGetMetaFileBits (*lphmf)) == NULL)
        return 0;

    size = (DWORD)GlobalSize(hBits);
    *lphmf = MSetMetaFileBits (hBits);
    return size;
}



HANDLE INTERNAL GetHmfp (LPOBJECT_MF lpobj)
{
    HANDLE          hmfp;
    LPMETAFILEPICT  lpmfp = NULL;

    if (lpobj->hmfp)
        return lpobj->hmfp;

    if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return NULL;

    if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp))) {
        GlobalFree (hmfp);
        return NULL;
    }

    *lpmfp = lpobj->mfp;
    GlobalUnlock (hmfp);
    return (lpobj->hmfp = hmfp);
}



OLESTATUS FARINTERNAL wCreateDummyMetaFile (
    LPOBJECT_MF     lpobj,
    int             xExt,
    int             yExt
){
    HDC hMetaDC;

    if (!(hMetaDC = CreateMetaFile (NULL)))
        return OLE_ERROR_MEMORY;

    MSetWindowOrg (hMetaDC, 0, 0);
    MSetWindowExt (hMetaDC, xExt, yExt);
    Rectangle (hMetaDC, 0, 0, xExt, yExt);
    if (!(lpobj->mfp.hMF = CloseMetaFile (hMetaDC)))
        return OLE_ERROR_MEMORY;
    lpobj->mfp.mm    = MM_ANISOTROPIC;
    lpobj->sizeBytes = MfGetSize ( (LPHANDLE) &lpobj->mfp.hMF) + sizeof(METAFILEPICT);
    return OLE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\cmacs.h ===
/****************************** Module Header ******************************\
* Module Name: CMACS.H
*
* This module contains common macros used by C routines.
*
* Created: 9-Feb-1989
*
* Copyright (c) 1985 - 1989  Microsoft Corporation
*
* History:
*   Created by Raor
*
\***************************************************************************/

#define _WINDOWS
#define  DLL_USE

#define INTERNAL        PASCAL NEAR
#define FARINTERNAL     PASCAL FAR

#define DEBUG_OUT(err, val) ;
#define ASSERT(cond, msg)
#define Puts(msg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\pbhandlr.c ===
/****************************** Module Header ******************************\
* Module Name: Pbhandlr.C -- Native data based handler (for Pbrush server) 
*
* PURPOSE: Contains handler routines for Pbrush server. This handler makes
*   use of most of the standard library methods. It replaces only the "Draw",
*   "QueryBounds", "CopyToClipboard" methods of the OLE object. Note that this
*   handler draws the picture from the native data.
*
* Created: December 1990
*
* Copyright (c) 1990  Microsoft Corporation
*
* History:
*   SriniK  (../12/1990)    Original
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"


OLESTATUS FAR PASCAL _LOADDS PbDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FAR PASCAL _LOADDS PbQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FAR PASCAL _LOADDS PbCopyToClipboard (LPOLEOBJECT);
OLESTATUS FAR PASCAL _LOADDS PbGetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);
OLECLIPFORMAT FAR PASCAL _LOADDS PbEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);

extern OLESTATUS  FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);


void    PbGetExtents (LPSTR, LPPOINT);
void    PbReplaceFunctions (LPOLEOBJECT);
HANDLE  PbGetPicture (LPOLEOBJECT);
BOOL    IsStandardPict (LPOLEOBJECT);

extern void FARINTERNAL DibGetExtents(LPSTR, LPPOINT);

OLEOBJECTVTBL   vtblDLL;

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;

OLESTATUS (FAR PASCAL *DefQueryBounds)      (LPOLEOBJECT, LPRECT);
OLESTATUS (FAR PASCAL *DefDraw)             (LPOLEOBJECT, HDC, LPRECT, LPRECT, HDC);
OLESTATUS (FAR PASCAL *DefCopyToClipboard)  (LPOLEOBJECT);
OLECLIPFORMAT (FAR PASCAL *DefEnumFormats)  (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS (FAR PASCAL *DefGetData)          (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);


OLESTATUS FAR PASCAL PbLoadFromStream (
    LPOLESTREAM         lpstream,
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (objType == OT_LINK) 
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfNative);
    else
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    LONG                objType
){
    OLESTATUS   retVal;
    
    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {       
        if (objType == OT_EMBEDDED) 
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_none, 0, objType);
        else
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_format, cfNative, objType);
    }
    else {
        retVal = DefCreateFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat, objType);
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);
        
    return retVal;
}



OLESTATUS FAR PASCAL PbCreateLinkFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS       retVal;

    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);
    }
    else {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);       
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromTemplate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, 0);

    else 
        retVal = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, 0);
    else 
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, 0);

    else 
        retVal = DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}


OLESTATUS FAR PASCAL PbCreateLinkFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LPSTR               lpitem,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);

    else 
        retVal = DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreateInvisible (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                fActivate
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, 0, fActivate);
    else 
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat, fActivate);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}


void PbReplaceFunctions (
    LPOLEOBJECT lpobj
){
    if (IsStandardPict (lpobj))
        return;
    
    vtblDLL = *lpobj->lpvtbl;
    lpobj->lpvtbl = (LPOLEOBJECTVTBL) &vtblDLL;
    
    DefDraw                         = lpobj->lpvtbl->Draw;
    DefQueryBounds                  = lpobj->lpvtbl->QueryBounds;
    DefCopyToClipboard              = lpobj->lpvtbl->CopyToClipboard;
    DefEnumFormats                  = lpobj->lpvtbl->EnumFormats;
    DefGetData                      = lpobj->lpvtbl->GetData;   
    
    lpobj->lpvtbl->Draw             = PbDraw;
    lpobj->lpvtbl->QueryBounds      = PbQueryBounds;
    lpobj->lpvtbl->CopyToClipboard  = PbCopyToClipboard;
    lpobj->lpvtbl->EnumFormats      = PbEnumFormats;    
    lpobj->lpvtbl->GetData          = PbGetData;        
}



OLESTATUS  FAR PASCAL _LOADDS PbQueryBounds (
    LPOLEOBJECT lpobj,
    LPRECT      lprc
){
    OLESTATUS     retVal;
    HANDLE        hData = NULL;
    LPSTR         lpData;
    POINT         point;
	 HANDLE        hbminfo = NULL;
	 LPBITMAPINFO  lpbminfo;

    if ((retVal = (*DefQueryBounds) (lpobj, lprc)) == OLE_OK) {
        if (lprc->top || lprc->bottom || lprc->right || lprc->left)
            return OLE_OK;
    }
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return retVal;

    if (!hData)
        return OLE_ERROR_BLANK;     
            
    if (!(lpData = GlobalLock (hData)))
		  goto error;
	 
	 if (!(hbminfo = GlobalAlloc(GHND, sizeof(BITMAPINFO))) )
		  goto error;

	 if (!(lpbminfo = (LPBITMAPINFO)GlobalLock(hbminfo)) )
		  goto error;
	 
    memcpy((LPSTR)lpbminfo, (LPSTR)(lpData+sizeof(BITMAPFILEHEADER)), sizeof(BITMAPINFO));
	 
    DibGetExtents ((LPSTR)lpbminfo, &point);
	 
    GlobalUnlock (hData);
	 GlobalUnlock (hbminfo);
	 GlobalFree (hbminfo);
    
    lprc->left     = 0;
    lprc->top      = 0;
    lprc->right    = point.x;
    lprc->bottom   = point.y;
    
    return OLE_OK;

error:

    if (hData)
       GlobalUnlock (hData);
	 
	 if (hbminfo)
	 {   
		 GlobalUnlock (hbminfo);
	    GlobalFree (hbminfo);
	 }   

	 return OLE_ERROR_MEMORY;
	 
}


OLESTATUS  FAR PASCAL _LOADDS PbDraw (
    LPOLEOBJECT         lpobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    HANDLE  hData;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return (*DefDraw) (lpobj, hdc, (LPRECT)lprc, (LPRECT)lpWrc, hdcTarget);

    return wDibDraw (hData, hdc, (LPRECT)lprc, (LPRECT)lpWrc, hdcTarget, TRUE);
}


OLECLIPFORMAT FAR PASCAL _LOADDS PbEnumFormats (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    OLECLIPFORMAT   retFormat = 0;

    if (cfFormat == CF_METAFILEPICT)
        return 0;
    
    if (!(retFormat =  (*DefEnumFormats) (lpobj, cfFormat))) 
        return CF_METAFILEPICT;
    
    return retFormat;
}


OLESTATUS  FAR PASCAL _LOADDS PbGetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE FAR *    lpHandle
){
    OLESTATUS retval;
    
    retval = (*DefGetData) (lpobj, cfFormat, lpHandle);

    if (retval == OLE_OK || retval == OLE_BUSY || retval  == OLE_ERROR_BLANK)
        return retval;
    
    if (cfFormat == CF_METAFILEPICT) {
        if (*lpHandle = PbGetPicture (lpobj))
            return OLE_WARN_DELETE_DATA;
        
        return OLE_ERROR_MEMORY;
    }

    return OLE_ERROR_FORMAT;
}



OLESTATUS  FAR PASCAL _LOADDS PbCopyToClipboard (
    LPOLEOBJECT     lpobj
){
    OLESTATUS   retVal;
    HANDLE      hPict; 
    
    if ((retVal = (*DefCopyToClipboard) (lpobj)) == OLE_OK) {
        if (hPict = PbGetPicture (lpobj))
            SetClipboardData (CF_METAFILEPICT, hPict);
        else
            return OLE_ERROR_MEMORY;         
    }
    
    return retVal;
}

HANDLE PbGetPicture (
    LPOLEOBJECT lpobj
){
    HANDLE          hMF, hMfp;
	 HANDLE          hData = NULL;
	 HANDLE          hbminfo = NULL;
    RECT            rc = {0, 0, 0, 0};
    POINT           point;
    HDC             hMetaDC;
    LPMETAFILEPICT  lpmfp;
    OLESTATUS       retVal;
    LPSTR           lpData;
	 LPBITMAPINFO    lpbminfo;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return NULL;
    
    if (!hData)
        return NULL;
            
    if (!(lpData = GlobalLock (hData)))
        return NULL;
	  
	 if (!(hbminfo = GlobalAlloc(GHND, sizeof(BITMAPINFO))) )
		  goto memory_error;

	 if (!(lpbminfo = (LPBITMAPINFO)GlobalLock(hbminfo)) )
		  goto memory_error;
	 
    memcpy((LPSTR)lpbminfo, (LPSTR)(lpData+sizeof(BITMAPFILEHEADER)), sizeof(BITMAPINFO));

    rc.right  = (int) lpbminfo->bmiHeader.biWidth;
    rc.bottom = (int) lpbminfo->bmiHeader.biHeight;
    DibGetExtents((LPSTR)lpbminfo, &point);
	 
    GlobalUnlock (hData);
	 GlobalUnlock (hbminfo);
	 GlobalFree (hbminfo);
	
    if (!(hMetaDC = CreateMetaFile (NULL)))
        return NULL;
    
    MSetWindowOrg (hMetaDC, 0, 0);
    MSetWindowExt (hMetaDC, rc.right, rc.bottom);
    retVal = PbDraw (lpobj, hMetaDC, &rc, NULL, NULL);
    hMF = CloseMetaFile (hMetaDC);

    if (retVal != OLE_OK) 
        goto error;

    if (hMF && (hMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT)))
            && (lpmfp = (LPMETAFILEPICT) GlobalLock (hMfp))) {
        lpmfp->hMF = hMF;
        lpmfp->xExt = point.x;
        lpmfp->yExt = -point.y;
        lpmfp->mm   = MM_ANISOTROPIC;
        GlobalUnlock (hMfp);
        return hMfp;
    }

error:

    if (hMF)
        DeleteMetaFile (hMF);
    
    if (hMfp)
        GlobalFree (hMfp);

    return NULL;

memory_error:

	 GlobalUnlock(hData);

	 if (hbminfo)
	 {   
	    GlobalUnlock(hbminfo);
		 GlobalFree(hbminfo);
	 }
 
	 return(NULL);
	 
}


// normal handler can't do this. since this handler is part of olecli.dll, we
// we are doing this.

BOOL IsStandardPict (
    LPOLEOBJECT lpobj
){
    LPOBJECT_LE lpLEobj;
    LONG        type;
    
    lpLEobj = (LPOBJECT_LE) lpobj;
    if (!lpLEobj->lpobjPict)
        return FALSE;
    
    if ((*lpLEobj->lpobjPict->lpvtbl->QueryType) (lpLEobj->lpobjPict, &type)
            == OLE_ERROR_GENERIC)
        return FALSE;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\net.c ===
/****************************** Module Header ******************************\
* Module Name: net.c
*
* PURPOSE: Contains routines  network support
*
* Created: Feb 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  02\12\1190  Orginal
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>

#ifdef WIN16
#include <winnet.h>
#endif

#ifdef WIN32
#include <winnetwk.h>
#endif

#include "dll.h"

#define MAX_DRIVE   26

char    szNULL[]   = "";
char    szNetName[]= "NetName";


BOOL FAR PASCAL GetTaskVisibleWindow (HWND, LPARAM);
void INTERNAL RemoveNetName (LPOBJECT_LE);

// Gets the drive letter from topic (if one exists) and then gets the remote
// name for that drive and then saves it in the object.

OLESTATUS FARINTERNAL SetNetName (
   LPOBJECT_LE lpobj
){
    char        buf[MAX_STR];
    WORD2DWORD  cbBuf = sizeof(buf);
    WORD2DWORD  driveType;
    char        szDrive[3];

    if (lpobj->head.ctype == CT_EMBEDDED)
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->topic, buf, cbBuf))
        return OLE_ERROR_BLANK;

    if (buf[1] != ':') {
        RemoveNetName (lpobj);
        return OLE_OK;
    }

    szDrive[2] = '\0';
    szDrive[1] = ':';
    szDrive[0] = buf[0];
    AnsiUpperBuff ((LPSTR) szDrive, 1);

    if (!(driveType = GetDriveType (MAPVALUE(szDrive[0] - 'A',szDrive)) )) {
        // drive is non existent
        return OLE_ERROR_DRIVE;
    }

    if  (driveType == DRIVE_REMOTE) {
         if (WNetGetConnection (szDrive, buf, (MAPTYPE(LPWORD,LPDWORD)) &cbBuf)
                    != WN_SUCCESS)
             return OLE_ERROR_DRIVE;

         lpobj->cDrive = szDrive[0];
         if (lpobj->aNetName)
             GlobalDeleteAtom (lpobj->aNetName);
         lpobj->aNetName = GlobalAddAtom(buf);
#ifdef WIN16
         lpobj->dwNetInfo = MAKELONG((WNetGetCaps (WNNC_NET_TYPE)),
                                     (WNetGetCaps (WNNC_DRIVER_VERSION)));
#endif

    }
    else {
        RemoveNetName (lpobj);
    }

    return OLE_OK;
}


// If netname exists for the given object, then it makes sure that drive
// in topic corresponds to the netname. If it's not the drive letter will
// be fixed by calling FixNet()

OLESTATUS FARINTERNAL CheckNetDrive (
    LPOBJECT_LE lpobj,
    BOOL        fNetDlg
){
    char    buf[MAX_NET_NAME];
    char    netName[MAX_NET_NAME];
    WORD2DWORD    cbBuf = sizeof(buf);
    char    szDrive[3];

    if (lpobj->head.ctype == CT_EMBEDDED)
        return OLE_OK;

    if (!lpobj->aNetName)
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->aNetName, netName, sizeof(netName)))
        return OLE_ERROR_MEMORY;

    szDrive[2] = '\0';
    szDrive[1] = ':';
    if (!(szDrive[0] = lpobj->cDrive)) {
        if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf)))
            szDrive[0] = lpobj->cDrive = buf[0];
    }

    if ((WNetGetConnection (szDrive, buf, (MAPTYPE(LPWORD,LPDWORD)) &cbBuf)
            == WN_SUCCESS)  && (!lstrcmp(netName, buf)))
        return OLE_OK;

    return FixNet (lpobj, netName, fNetDlg);
}


// Find if there is a drive connected to the given server. If so, get the
// drive letter and set it in topic. If not try to make connection, and if
// that attempt is successful the set the drive letter in topic.

OLESTATUS INTERNAL FixNet (
    LPOBJECT_LE lpobj,
    LPSTR       lpNetName,
    BOOL        fNetDlg
){
    int         nDrive = 2;     // drive 'C'
    OLESTATUS   retVal;

    if (SetNextNetDrive(lpobj, &nDrive, lpNetName))
        return OLE_OK;

    if (fNetDlg != POPUP_NETDLG)
        return OLE_ERROR_NETWORK;

    if ((retVal = ConnectNet (lpobj, lpNetName)) == OLE_OK) {
        if (!ChangeTopic (lpobj))
            return OLE_ERROR_BLANK;
    }

    return retVal;
}



BOOL FARINTERNAL SetNextNetDrive (
    LPOBJECT_LE lpobj,
    int FAR *   lpnDrive,
    LPSTR       lpNetName
){
    char    buf[MAX_STR];
    WORD2DWORD    cbBuf = sizeof(buf);
    char    szDrive[3];

    if (!lpNetName[0]) {
        if (!GlobalGetAtomName(lpobj->aNetName, lpNetName, MAX_STR))
            return FALSE;
    }

    szDrive[2] = '\0';
    szDrive[1] = ':';
    while (*lpnDrive < MAX_DRIVE) {
        szDrive[0] = (char) ('A' + (++*lpnDrive));
        if (GetDriveType (szDrive) == DRIVE_REMOTE) {
#ifdef WIN16
        if (GetDriveType (++*lpnDrive) == DRIVE_REMOTE) {
#endif
            cbBuf = sizeof(buf);
            if ((WNetGetConnection (szDrive, buf, (MAPTYPE(LPWORD,LPDWORD)) &cbBuf)
                        == WN_SUCCESS) && (!lstrcmp(lpNetName, buf))) {
                lpobj->cDrive = szDrive[0];
                return ChangeTopic (lpobj);
            }
        }
    }

    return FALSE;
}


BOOL FARINTERNAL ChangeTopic (
    LPOBJECT_LE lpobj
){
    char buf[MAX_STR];

    if (!GlobalGetAtomName(lpobj->topic, buf, sizeof(buf)))
        return FALSE;
    if (lpobj->topic)
        GlobalDeleteAtom(lpobj->topic);
    buf[0] = lpobj->cDrive;
    lpobj->topic = GlobalAddAtom (buf);
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    return TRUE;
}



OLESTATUS INTERNAL ConnectNet (
    LPOBJECT_LE lpobj,
    LPSTR       lpNetName
){
    HWND        hCurTask;
    HWND        hwndParent = NULL;


    hCurTask = (HWND)ULongToPtr(MGetCurrentTask());
    ASSERT (hCurTask, "Current task handle in NULL");

    // Get the container task's main window, and use that as parent for
    // the dlg box.
    EnumTaskWindows (hCurTask, (WNDENUMPROC)GetTaskVisibleWindow,
        (DWORD_PTR) ((WORD FAR *) &hwndParent));

    if (lpobj->cDrive = (char) DialogBoxParam (hInstDLL, "CONNECTDLG",
                                    hwndParent, ConnectDlgProc,
                                    (LONG_PTR) lpNetName))
        return OLE_OK;
    else
        return OLE_ERROR_NETWORK;


}



INT_PTR FAR PASCAL ConnectDlgProc(
    HWND    hDlg,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
){
    char            szPassword[32];
    char            szTitle[64];
 
    switch (wMsg) {
        case WM_INITDIALOG:
            SetProp (hDlg, szNetName, (HANDLE)lParam);
            FillDrives (hDlg);
            SetDlgItemText (hDlg, IDD_PATH, (LPSTR) lParam);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam,lParam)) {

                case IDOK:
                {
                    int    cch = 128;
                    char    szMessage[128];
                    char    szDrive[3];
                    LPSTR   lpNetName;

                    GetDlgItemText(hDlg, IDD_DRIVE, szDrive, sizeof(szDrive));
                    GetDlgItemText(hDlg, IDD_PASSWORD, szPassword,
                                sizeof(szPassword));
                    lpNetName = (LPSTR) GetProp (hDlg, szNetName);
                    wParam = WNetAddConnection (lpNetName,
                                (LPSTR) szPassword, szDrive);

                    if (wParam == WN_SUCCESS)  {
                        RemoveProp (hDlg, szNetName);
			EndDialog (hDlg, szDrive[0]);
                        return TRUE;
                    }

                    LoadString (hInstDLL, IDS_NETERR, szTitle,
                        sizeof(szTitle));
#ifdef WIN16
                    if (WNetGetErrorText ((UINT)wParam, szMessage, &cch)
                                    != WN_SUCCESS)
#endif
                        LoadString (hInstDLL, IDS_NETCONERRMSG,
                            szMessage, sizeof(szMessage));

                    if (MessageBox (hDlg, szMessage, szTitle,
                            MB_RETRYCANCEL)  == IDCANCEL)
                        goto error;

                    if (wParam == WN_ALREADY_CONNECTED)
                        FillDrives (hDlg);
                    SetDlgItemText (hDlg, IDD_PASSWORD, szNULL);
                    break;
                }

                case IDCANCEL:
error:
                    RemoveProp (hDlg, szNetName);
                    EndDialog(hDlg, 0);
                    return TRUE;

                case IDD_DRIVE:
                    break;

                case IDD_PATH:
                    if (GET_WM_COMMAND_CMD(wParam,lParam) == EN_KILLFOCUS) {
                        LPSTR   lpNetName;

                        lpNetName = (LPSTR) GetProp (hDlg, szNetName);

                        SendDlgItemMessage (hDlg, IDD_PATH, WM_SETTEXT, 0,
                                    (DWORD_PTR) lpNetName);
                    }
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }

    return FALSE;
}


VOID INTERNAL FillDrives (
    HWND    hDlg
){
    HWND    hwndCB;
    int     nDrive = 3;
    char    szDrive[3];
    DWORD   dwDriveType;

    hwndCB = GetDlgItem(hDlg, IDD_DRIVE);
    SendMessage(hwndCB, CB_RESETCONTENT, 0, 0L);
    szDrive[2] = '\0';
    szDrive[1] = ':';
    while (nDrive < MAX_DRIVE) {
        szDrive[0] = (char) ('A' + nDrive);
#ifdef WIN32
        if ((dwDriveType = GetDriveType (szDrive)) == 1)
#endif
#ifdef WIN16
        if (!GetDriveType (nDrive))
#endif
            SendMessage(hwndCB, CB_ADDSTRING, 0, (DWORD_PTR)(LPSTR)szDrive);
        nDrive++;
    }
    SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);
}


BOOL FAR PASCAL GetTaskVisibleWindow (
    HWND    hWnd,
    LPARAM  lpTaskVisWnd
){
    if (IsWindowVisible (hWnd)) {
        *(HWND FAR *)lpTaskVisWnd = hWnd;
         return FALSE;
    }

    return TRUE;
}

void INTERNAL RemoveNetName (LPOBJECT_LE lpobj)
{
    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = (ATOM)0;
    }

    lpobj->cDrive = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include <reghelp.hxx>

#include "dll.h"
#include "strsafe.h"

#define KB_64      65536
#define NULL_WORD  0x0000

extern ATOM  aPackage;
extern OLEOBJECTVTBL    vtblMF, vtblBM, vtblDIB, vtblGEN;

// QuerySize API support
DWORD           dwObjSize = 0;
OLESTREAMVTBL   dllStreamVtbl;
OLESTREAM       dllStream;

BOOL PutStrWithLen(
    LPOLESTREAM   lpstream,
    LPSTR         lpbytes
){
    LONG     len;

    len = (LONG) lstrlen(lpbytes) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, lpbytes, len);

}

BOOL GetStrWithLen(
    LPOLESTREAM   lpstream,
    LPSTR         lpbytes
){
    if (GetBytes (lpstream, lpbytes, sizeof(LONG)))
        return TRUE;

    return GetBytes (lpstream, lpbytes + sizeof(LONG), (*(LONG FAR *)lpbytes));
}

ATOM GetAtomFromStream(
    LPOLESTREAM lpstream
){
    BOOL    err = TRUE;
    LONG    len;
    char    str[MAX_STR+1];


    if (GetBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return (ATOM)0;

    if (len == 0)
        return (ATOM)0;

    if (GetBytes(lpstream, (LPSTR)str, len))
        return (ATOM)0;

    return GlobalAddAtom(str);

}

BOOL PutAtomIntoStream(
    LPOLESTREAM     lpstream,
    ATOM            at
){
    LONG    len = 0;
    char    buf[MAX_STR + 1];

    if (at == 0)
        return  (PutBytes (lpstream, (LPSTR)&len, sizeof(len)));


    len = GlobalGetAtomName (at,(LPSTR)buf, MAX_STR) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, buf, len);
}


// DuplicateAtom: Bump the use count up on a global atom.

ATOM FARINTERNAL DuplicateAtom (
    ATOM atom
){
    char buffer[MAX_ATOM+1];

    Puts("DuplicateAtom");

    if (!atom)
        return (ATOM)0;

    GlobalGetAtomName (atom, buffer, MAX_ATOM);
    return GlobalAddAtom (buffer);
}



BOOL GetBytes(
    LPOLESTREAM     lpstream,
    LPSTR           lpstr,
    LONG            len
){

    ASSERT (lpstream->lpstbl->Get , "stream get function is null");
    return (((*lpstream->lpstbl->Get)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}


BOOL PutBytes(
    LPOLESTREAM     lpstream,
    LPSTR           lpstr,
    LONG            len
){

    ASSERT (lpstream->lpstbl->Put , "stream get function is null");
    return (((*lpstream->lpstbl->Put)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}



BOOL FARINTERNAL UtilMemCmp (
    LPSTR   lpmem1,
    LPSTR   lpmem2,
    DWORD   dwCount
){
    UINT HUGE_T * hpmem1;
    UINT HUGE_T * hpmem2;
    DWORD       words;
    DWORD       bytes;

    bytes = dwCount %  MAPVALUE(2,4);
    words = dwCount >> MAPVALUE(1,2);//* we compare DWORDS
                                     //* in the 32 bit version
   {
        hpmem1 = (UINT HUGE_T *) lpmem1;
        hpmem2 = (UINT HUGE_T *) lpmem2;

        while (words--) {
            if (*hpmem1++ != *hpmem2++)
                return FALSE;
        }

	 	  lpmem1 = (LPSTR)hpmem1;
		  lpmem2 = (LPSTR)hpmem2;

        for (; bytes-- ; ) {
            if ( *lpmem1++ != *lpmem2++ )
                return FALSE;
        }
    }

    return TRUE;
}


void FARINTERNAL UtilMemCpy (
    LPSTR   lpdst,
    LPSTR   lpsrc,
    DWORD   dwCount
){
    UINT HUGE_T * hpdst;
    UINT HUGE_T * hpsrc;
    DWORD       words;
    DWORD       bytes;
							
    bytes = dwCount %  MAPVALUE(2,4);
    words = dwCount >> MAPVALUE(1,2);//* we compare DWORDS
                                     //* in the 32 bit version
    {			
        hpdst = (UINT HUGE_T *) lpdst;
        hpsrc = (UINT HUGE_T *) lpsrc;

        for(;words--;    )
            *hpdst++ = *hpsrc++;

        lpdst = (LPSTR)hpdst;
        lpsrc = (LPSTR)hpsrc;
		
        for (;bytes--;)
            *lpdst++ = *lpsrc++;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE FARINTERNAL DuplicateGlobal (
    HANDLE  hdata,
    UINT    flags
){
    LPSTR   lpdst = NULL;
    LPSTR   lpsrc = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;

    if (!hdata)
        return NULL;

    if(!(lpsrc = GlobalLock (hdata)))
        return NULL;

    hdup = GlobalAlloc (flags, (size = (DWORD)GlobalSize(hdata)));

    if(!(lpdst = GlobalLock (hdup)))
        goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);

errRtn:
    if(lpsrc)
        GlobalUnlock (hdata);

    if(lpdst)
        GlobalUnlock (hdup);

    if (err && hdup) {
        GlobalFree (hdup);
        hdup = NULL;
    }

    return hdup;
}


BOOL FARINTERNAL CmpGlobals (
    HANDLE  hdata1,
    HANDLE  hdata2
){
    LPSTR       lpdata1 = NULL;
    LPSTR       lpdata2 = NULL;
    DWORD       size1;
    DWORD       size2;
    BOOL        retval = FALSE;


    size1 = (DWORD)GlobalSize (hdata1);
    size2 = (DWORD)GlobalSize (hdata2);

    if (size1 != size2)
        return FALSE;

    if (!(lpdata1 = GlobalLock (hdata1)))
        goto errRtn;

    if (!(lpdata2 = GlobalLock (hdata2)))
        goto errRtn;

    retval = UtilMemCmp (lpdata1, lpdata2, size1);

errRtn:
    if (lpdata1)
        GlobalUnlock (hdata1);

    if (lpdata2)
        GlobalUnlock (hdata2);

    return retval;
}


int  FARINTERNAL GlobalGetAtomLen (
    ATOM    aItem
){
    // !!! Change this
    char    buf[MAX_STR];

    if (!aItem)
        return 0;

    return (GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR));

}


BOOL FARINTERNAL MapExtToClass (
    LPSTR   lptemplate,
    LPSTR   lpbuf,
    int     len
){
    LONG    cb;
	 LPSTR    lpstrBack = NULL;

	 while (*lptemplate)
       {
		 if ((*lptemplate) == '\\'){
			 lpstrBack = lptemplate ;
			 }

		 lptemplate ++ ;
		 }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
		 lpstrBack++ ;


    cb = len;
    if (lpstrBack == NULL || *(lpstrBack+1) == '\0')
        return FALSE;

    if (QueryClassesRootValueA (lpstrBack, lpbuf, &cb))
        return FALSE;

    return TRUE;
}


// Get exe name from aClass and set it as aServer
void INTERNAL SetExeAtom (
    LPOBJECT_LE lpobj
){
    char    key[MAX_STR];

    // if old link object assume the class same as the exe file name.
    if (lpobj->bOldLink)
        lpobj->aServer = DuplicateAtom (lpobj->app);
    else {
        if (GlobalGetAtomName (lpobj->app, key, sizeof(key)))
            lpobj->aServer = GetAppAtom ((LPSTR)key);
    }
}


ATOM FARINTERNAL GetAppAtom (
    LPCSTR   lpclass
){
    char    buf1[MAX_STR];


    if (!QueryApp (lpclass, PROTOCOL_EDIT, buf1)) {
        return (ATOM)0;
    }

    return GlobalAddAtom ((LPSTR)buf1);
}


BOOL FARINTERNAL QueryVerb (
    LPOBJECT_LE lpobj,
    UINT        verb,
    LPSTR       lpbuf,
    LONG        cbmax
){
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    // do not need 256 bytes buffer
    char    class[MAX_STR];
    int     len;

    if (!GlobalGetAtomName (lpobj->app, (LPSTR)class, sizeof(class)))
        return FALSE;

    StringCchCopy(key, sizeof(key)/sizeof(key[0]), (LPSTR)class);
    StringCchCat (key, sizeof(key)/sizeof(key[0]), "\\protocol\\StdFileEditing\\verb\\");
    len = lstrlen (key);
    // If we don't have room to add the char fail
    if (len >= sizeof(key)/sizeof(key[0]) - 1)
        return FALSE;
    key [len++] = (char) ('0' + verb);
    key [len++] = 0;

    if (QueryClassesRootValueA (key, lpbuf, &cbmax))
        return FALSE;
    return TRUE;
}




BOOL QueryApp (
    LPCSTR  lpclass,
    LPCSTR  lpprotocol,
    LPSTR   lpbuf
){
    LONG    cb = MAX_STR;
    char    key[MAX_STR];

    if (FAILED(StringCchCopy (key, sizeof(key)/sizeof(key[0]), lpclass)))
        return FALSE;
    if (FAILED(StringCchCat(key,  sizeof(key)/sizeof(key[0]), "\\protocol\\")))
        return FALSE;
    if (FAILED(StringCchCat(key,  sizeof(key)/sizeof(key[0]), lpprotocol)))
        return FALSE;
    if (FAILED(StringCchCat(key,  sizeof(key)/sizeof(key[0]), "\\server")))
        return FALSE;

    if (QueryClassesRootValueA (key, lpbuf, &cb))
        return FALSE;
    return TRUE;
}


HANDLE MapStrToH (
    LPSTR   lpstr
){

    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;
    UINT cch = lstrlen(lpstr) + 1;

    hdata = GlobalAlloc (GMEM_DDESHARE, cch);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    StringCchCopy(lpdata, cch, lpstr);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    return NULL;
}


HANDLE FARINTERNAL CopyData (
    LPSTR       lpsrc,
    DWORD       dwBytes
){
    HANDLE  hnew;
    LPSTR   lpnew;
    BOOL    retval = FALSE;

    if (hnew = GlobalAlloc (GMEM_MOVEABLE, dwBytes)){
        if (lpnew = GlobalLock (hnew)){
            UtilMemCpy (lpnew, lpsrc, dwBytes);
            GlobalUnlock (hnew);
            return hnew;
        }
        else
            GlobalFree (hnew);
    }

    return NULL;
}

void  UtilMemClr (
    PSTR    pstr,
    UINT    size
){

    while (size--)
        *pstr++ = 0;

}


OLESTATUS FAR PASCAL ObjQueryName (
    LPOLEOBJECT lpobj,
    LPSTR       lpBuf,
    UINT FAR *  lpcbBuf
){
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;

    PROBE_WRITE(lpBuf);
    if (!*lpcbBuf)
        return OLE_ERROR_SIZE;

    if (!CheckPointer(lpBuf+*lpcbBuf-1, WRITE_ACCESS))
        return OLE_ERROR_SIZE;

    ASSERT(lpobj->aObjName, "object name ATOM is NULL\n");
    *lpcbBuf = GlobalGetAtomName (lpobj->aObjName, lpBuf, *lpcbBuf);
    return OLE_OK;
}


OLESTATUS FAR PASCAL ObjRename (
    LPOLEOBJECT lpobj,
    LPCSTR      lpNewName
){
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;

    PROBE_READ(lpNewName);
    if (!lpNewName[0])
        return OLE_ERROR_NAME;

    if (lpobj->aObjName)
        GlobalDeleteAtom (lpobj->aObjName);
    lpobj->aObjName = GlobalAddAtom (lpNewName);
    return OLE_OK;
}




BOOL QueryHandler(
    UINT cfFormat
){
    HANDLE  hInfo = NULL;
    LPSTR   lpInfo = NULL;
    BOOL    fRet = FALSE, fOpen = FALSE;
    LONG    cb = MAX_STR;
    char    str[MAX_STR];
    HKEY    hKey;

    // we don't have the client app window handle, use the screen handle
    fOpen = OpenClipboard (NULL);

    if (!(hInfo = GetClipboardData (cfFormat)))
        goto errRtn;

    if (!(lpInfo = GlobalLock(hInfo)))
        goto errRtn;

    // First string of lpInfo is CLASS. See whether any handler is installed
    // for this class.

    if (FAILED(StringCchCopy (str, sizeof(str)/sizeof(str[0]), lpInfo)))
        goto errRtn;
    if (FAILED(StringCchCat (str, sizeof(str)/sizeof(str[0]), "\\protocol\\StdFileEditing\\handler")))
        goto errRtn;
    if (OpenClassesRootKeyA (str, &hKey))
        goto errRtn;
    RegCloseKey (hKey);
    fRet = TRUE;

errRtn:
    if (lpInfo)
        GlobalUnlock (hInfo);

    if (fOpen)
        CloseClipboard();
    return fRet;
}

OLESTATUS INTERNAL FileExists (
    LPOBJECT_LE lpobj
){
    char        filename[MAX_STR];
    OFSTRUCT    ofstruct;

    if (!GlobalGetAtomName (lpobj->topic, filename, MAX_STR))
        return OLE_ERROR_MEMORY;

    // For package with link we append "/LINK" to the filename. We don't want
    // to check for it's existence here.
    if (lpobj->app != aPackage) {
        // when OF_EXIST is specified, file is opened and closed immediately
        if (OpenFile (filename, &ofstruct, OF_EXIST) == -1)
            return OLE_ERROR_OPEN;
    }

    return OLE_OK;
}


BOOL  FARINTERNAL UtilQueryProtocol (
    LPOBJECT_LE lpobj,
    LPCSTR      lpprotocol
){
    char    buf[MAX_STR];
    ATOM    aExe;

    if (!GlobalGetAtomName (lpobj->app, (LPSTR) buf, MAX_STR))
        return FALSE;

    if (!QueryApp (buf, lpprotocol, (LPSTR) buf))
        return FALSE;

    aExe = GlobalAddAtom (buf);
    if (aExe)
        GlobalDeleteAtom (aExe);
    if (aExe != lpobj->aServer)
        return FALSE;

    return TRUE;
}

DWORD PASCAL FAR DllPut (
    LPOLESTREAM lpstream,
    OLE_CONST void FAR *lpstr,
    DWORD       dwSize
){
    UNREFERENCED_PARAMETER(lpstream);
    UNREFERENCED_PARAMETER(lpstr);

    dwObjSize += dwSize;
    return dwSize;
}



OLESTATUS FARINTERNAL ObjQueryType (
    LPOLEOBJECT lpobj,
    LPLONG      lptype
){
    Puts("ObjQueryType");

    if (lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;

    *lptype = lpobj->ctype;
    return OLE_OK;
}

OLESTATUS FARINTERNAL ObjQuerySize (
    LPOLEOBJECT    lpobj,
    DWORD FAR *    lpdwSize
){
    Puts("ObjQuerySize");

    *lpdwSize = dwObjSize = 0;

    if ((*lpobj->lpvtbl->SaveToStream) (lpobj, &dllStream) == OLE_OK) {
        *lpdwSize = dwObjSize;
        return OLE_OK;
    }

    return OLE_ERROR_BLANK;
}

BOOL FARINTERNAL IsObjectBlank (
    LPOBJECT_LE lpobj
){
    LPOLEOBJECT lpPictObj;
    BOOL        retval=FALSE;

    // Cleaner way is to provide a method like QueryBlank()

    if (!lpobj->hnative)
        return TRUE;

    if (!(lpPictObj = lpobj->lpobjPict))
        return FALSE;

    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblMF)
        retval = (((LPOBJECT_MF)lpPictObj)->hmfp != NULL);
    else if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblBM)
        retval = (((LPOBJECT_BM)lpPictObj)->hBitmap != NULL);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblDIB)
        retval = (((LPOBJECT_DIB)lpPictObj)->hDIB != NULL);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblGEN)
        retval = (((LPOBJECT_GEN)lpPictObj)->hData != NULL);

    return retval;
}

BOOL FAR PASCAL OleIsDcMeta (HDC hdc)
{
        return (GetDeviceCaps (hdc, TECHNOLOGY) == DT_METAFILE);
}

void ConvertBM32to16(
   LPBITMAP      lpsrc,
   LPWIN16BITMAP lpdest
){
#ifdef WIN32
    lpdest->bmType       = (short)lpsrc->bmType;
    lpdest->bmWidth      = (short)lpsrc->bmWidth;
    lpdest->bmHeight     = (short)lpsrc->bmHeight;
    lpdest->bmWidthBytes = (short)lpsrc->bmWidthBytes;
    lpdest->bmPlanes     = (BYTE)lpsrc->bmPlanes;
    lpdest->bmBitsPixel  = (BYTE)lpsrc->bmBitsPixel;
#endif

#ifdef WIN16
    *lpdest = *lpsrc;
#endif

}

void ConvertBM16to32(
   LPWIN16BITMAP lpsrc,
   LPBITMAP     lpdest
){
#ifdef WIN32
    lpdest->bmType       = MAKELONG(lpsrc->bmType,NULL_WORD);
    lpdest->bmWidth      = MAKELONG(lpsrc->bmWidth,NULL_WORD);
    lpdest->bmHeight     = MAKELONG(lpsrc->bmHeight,NULL_WORD);
    lpdest->bmWidthBytes = MAKELONG(lpsrc->bmWidthBytes,NULL_WORD);
    lpdest->bmPlanes     = (WORD)lpsrc->bmPlanes;
    lpdest->bmBitsPixel  = (WORD)lpsrc->bmBitsPixel;
#endif

#ifdef WIN16
    *lpdest = *lpsrc;
#endif

}
void ConvertMF16to32(
   LPWIN16METAFILEPICT lpsrc,
   LPMETAFILEPICT      lpdest
){
#ifdef WIN32
   lpdest->mm     = (DWORD)lpsrc->mm;
   lpdest->xExt   = (DWORD)MAKELONG(lpsrc->xExt,NULL_WORD);
   lpdest->yExt   = (DWORD)MAKELONG(lpsrc->yExt,NULL_WORD);
#endif

#ifdef WIN16
   *lpdest = *lpsrc;
#endif

}


void ConvertMF32to16(
   LPMETAFILEPICT      lpsrc,
   LPWIN16METAFILEPICT lpdest
){
#ifdef WIN32
   lpdest->mm     = (short)lpsrc->mm;
   lpdest->xExt   = (short)lpsrc->xExt;
   lpdest->yExt   = (short)lpsrc->yExt;
#endif

#ifdef WIN16
   *lpdest = *lpsrc;
#endif
}

DWORD INTERNAL GetFileVersion(LPOLEOBJECT lpoleobj)
{

   if (lpoleobj->lhclientdoc)
      return ((LPCLIENTDOC)(lpoleobj->lhclientdoc))->dwFileVer;

   if (lpoleobj->lpParent)
      return GetFileVersion(lpoleobj->lpParent);

   return (DWORD)MAKELONG(wReleaseVer,OS_WIN32);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\pict.h ===
/****************************** Module Header ******************************\
* Module Name: pict.h
*
* PURPOSE: Private definitions file for presentation object related files
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*  curts created portable version for WIN16/32
*
\***************************************************************************/


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MF.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL MfRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL MfSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL MfClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL MfEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL MfCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL MfQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL MfGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL MfSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL MfChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    MfCopyToClip (LPOBJECT_MF, HANDLE);
void      FARINTERNAL MfSetExtents (LPOBJECT_MF);
DWORD     INTERNAL    MfGetSize (LPHANDLE);
HANDLE    INTERNAL    GetHmfp (LPOBJECT_MF);
OLESTATUS INTERNAL    MfUpdateStruct (LPOBJECT_MF, LPOLECLIENT, HANDLE, 
                            LPMETAFILEPICT, HANDLE, BOOL);
OLECLIPFORMAT FARINTERNAL MfEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in EMF.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmfRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL EmfSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL EmfClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL EmfEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL EmfCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL EmfQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL EmfGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL EmfSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL EmfChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
void      FARINTERNAL EmfSetExtents (LPOBJECT_EMF);
DWORD     INTERNAL    EmfGetSize (LPHANDLE);
HANDLE    INTERNAL    GetHemfp (LPOBJECT_EMF);
OLESTATUS INTERNAL    EmfUpdateStruct (LPOBJECT_EMF, LPOLECLIENT, HANDLE, 
                            LPMETAFILEPICT, HANDLE, BOOL);
OLECLIPFORMAT FARINTERNAL EmfEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DIB.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

/* The DIB file will be of the following format:                        */
/*                                                                      */
/*      0004                                                            */
/*      "DIB"                                                           */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAPINFOHEADER + RBGQUAD + bit array)     */
/*      BITMAPINFOHEADER structure                                      */
/*      RBGQUAD array                                                   */
/*      array of DI bits                                                */
/*                                                                      */

OLESTATUS FARINTERNAL DibRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL DibSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL DibClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL DibEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL DibCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL DibQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL DibGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL DibChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
BOOL      INTERNAL    DibStreamRead (LPOLESTREAM,LPOBJECT_DIB);
void      INTERNAL    DibUpdateStruct (LPOBJECT_DIB, LPOLECLIENT, HANDLE, LPBITMAPINFOHEADER, DWORD);

OLECLIPFORMAT FARINTERNAL DibEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


/* The BM file will be of the following format:                         */
/*                                                                      */
/*      0007                                                            */
/*      "BITMAP"                                                        */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAP + bits)                              */
/*      BITMAP structure                                                */
/*      bitmap bits                                                     */
/*                                                                      */

OLESTATUS FARINTERNAL BmRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL BmSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL BmClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL BmEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL BmCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL BmQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL BmGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL BmChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    BmStreamWrite (LPOLESTREAM, LPOBJECT_BM);
BOOL      INTERNAL    BmStreamRead (LPOLESTREAM, LPOBJECT_BM);
void      INTERNAL    BmUpdateStruct (LPOBJECT_BM, LPOLECLIENT, HBITMAP, LPBITMAP, DWORD);

OLECLIPFORMAT FARINTERNAL BmEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);
LPOBJECT_BM   INTERNAL    BmCreateObject (HBITMAP, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPCSTR, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in GENERIC.C                                                   //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////




/* The GENERIC file will be of the following format:                    */
/*                                                                      */
/*      0007                                                            */
/*      "GENERIC"                                                       */
/*      4 bytes of cfFormat                                             */

OLESTATUS FARINTERNAL GenRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL GenSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL GenEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL GenCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL GenQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL GenGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL GenSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL GenChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    GenDeleteData (HANDLE);
OLESTATUS FARINTERNAL GenQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL GenClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);

OLECLIPFORMAT FARINTERNAL GenEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);
LPOBJECT_GEN  INTERNAL    GenCreateObject (HANDLE, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPCSTR, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL ErrPlay (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS FARINTERNAL ErrShow (LPOLEOBJECT, BOOL);
OLESTATUS FARINTERNAL ErrSetHostNames (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
OLESTATUS FARINTERNAL ErrSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS FARINTERNAL ErrSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS FARINTERNAL ErrSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);
OLESTATUS FARINTERNAL ErrQueryOpen (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrActivate (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
OLESTATUS FARINTERNAL ErrClose (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrUpdate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrReconnect (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL ErrQueryOutOfDate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrGetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS FARINTERNAL ErrSetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE);
void FAR* FARINTERNAL ErrQueryProtocol (LPOLEOBJECT, OLE_LPCSTR);
OLE_RELEASE_METHOD FARINTERNAL ErrQueryReleaseMethod (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrQueryRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrAbort (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrCopyFromLink (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS FARINTERNAL ErrRequestData (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS FARINTERNAL ErrExecute (LPOLEOBJECT, HANDLE, UINT);

OLESTATUS FARINTERNAL ErrObjectConvert (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*); 

OLESTATUS FARINTERNAL ErrObjectLong (LPOLEOBJECT, UINT, LPLONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DRAW.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
                    

OLESTATUS FARINTERNAL DibDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FARINTERNAL BmDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FARINTERNAL GenDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FARINTERNAL MfDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
void      INTERNAL    MfInterruptiblePaint (LPOBJECT_MF, HDC);
BOOL      APIENTRY    MfCallbackFunc (HDC, LPHANDLETABLE, LPMETARECORD, int, LPVOID);
OLESTATUS FARINTERNAL EmfDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
void      INTERNAL    EmfInterruptiblePaint (LPOBJECT_EMF, HDC, LPRECT);
int       FARINTERNAL EmfCallbackFunc (HDC, LPHANDLETABLE, LPENHMETARECORD, int, LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\block.c ===
/****************************** Module Header ******************************\
* Module Name: Block.c
*
* Purpose: Includes OleServerBlock(), OleServerUnblock() and related routines.
*
* Created: Dec. 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Srinik (../12/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/


#include "windows.h"
#include "cmacs.h"
#include "dde.h"
#include "ole.h"
#include "srvr.h"


OLESTATUS APIENTRY OleBlockServer (
    LHSERVER  lhsrvr
){
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_BLOCK(lpsrvr);
    lpsrvr->bBlock = TRUE;
    return OLE_OK;
}


// On return from this routine, if *lpStatus is TRUE it means that more
// messages are to be unblocked.

OLESTATUS APIENTRY OleUnblockServer (
    LHSERVER    lhsrvr,
    BOOL FAR *  lpStatus
){
    HANDLE  hq;
    PQUE    pq;
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_WRITE(lpStatus);

    *lpStatus = lpsrvr->bBlock;
    if (hq = lpsrvr->hqHead) {
        if (!(pq = (PQUE) LocalLock (hq)))
            return OLE_ERROR_MEMORY;
        lpsrvr->bBlockedMsg = TRUE;
        lpsrvr->hqHead = pq->hqNext;
		
		  if (pq->wType)
				DocWndProc (pq->hwnd, pq->msg, pq->wParam, pq->lParam);
		  else
				SrvrWndProc (pq->hwnd, pq->msg, pq->wParam, pq->lParam);
			
        LocalUnlock (hq);
        LocalFree (hq);

        // Server could've got freed up as a result of the above SendMessage
        // Validate server handle before trying to access it.
        if (CheckServer (lpsrvr)) {
            lpsrvr->bBlockedMsg = FALSE;

            if (!lpsrvr->hqHead) {
                lpsrvr->hqTail = NULL;
                *lpStatus = lpsrvr->bBlock = FALSE;
            }
        }
        else {
            *lpStatus = FALSE;
        }
    }
    else {
        *lpStatus = lpsrvr->bBlock = FALSE;
    }

    return OLE_OK;
}


BOOL INTERNAL AddMessage (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    int     wType
){
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    BOOL    bBlocked = TRUE;

    if ((msg <= WM_DDE_INITIATE) || (msg > WM_DDE_LAST))
        return FALSE;


    if (!(lpsrvr = (LPSRVR) GetWindowLongPtr ((wType == WT_DOC) ? GetParent (hwnd) : hwnd, 0)))
        return FALSE;

    if (lpsrvr->bBlockedMsg || !lpsrvr->bBlock)
        return FALSE;

#ifdef LATER
    if ((msg == WM_DDE_INITIATE) && (lpsrvr->useFlags == OLE_SERVER_MULTI))
        return TRUE;
#endif

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
	 pq->wType  = wType;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqHead) {
        // Queue is empty.
        lpsrvr->hqHead = lpsrvr->hqTail = hq;
    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqTail);
        lpsrvr->hqTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);

    while (bBlocked && !OleUnblockServer ((LHSERVER) lpsrvr, &bBlocked))
            ;

    return FALSE;
}



// dispatches the queued message, till all the messages are posted
// does yielding  if necessary. if bPeek is true, may allow some of
// incoming messages to get in.


BOOL INTERNAL  UnblockPostMsgs (
    HWND    hwnd,
    BOOL    bPeek
){
    HANDLE  hq = NULL;
    PQUE    pq = NULL;
    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    UNREFERENCED_PARAMETER(bPeek);

    // get the parent windows
    while (hwndTmp = GetParent (hwnd))
           hwnd = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLongPtr (hwnd, 0);

    while (hq = lpsrvr->hqPostHead) {

        if (!(pq = (PQUE) LocalLock (hq))) {

            break;
        }
        if (IsWindowValid (pq->hwnd)) {
            if (!PostMessage (pq->hwnd, pq->msg, pq->wParam, pq->lParam)) {
                LocalUnlock (hq);
                break;
            }
        }

        lpsrvr->hqPostHead = pq->hqNext;
        LocalUnlock (hq);
        LocalFree (hq);
    }


    if (!lpsrvr->hqPostHead)
        lpsrvr->hqPostTail = NULL;

    return TRUE;
}


// Moves a message which can not be posted to a server to
// the internal queue. We use this when we have to enumerate
// the properties. When we change the properties stuff to
// some other form, this may not be necassry.

BOOL INTERNAL BlockPostMsg (
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
){
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    HWND    hwndTmp;
    HWND    hwndParent;

    hwndParent = (HWND)wParam;
    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwndParent))
           hwndParent = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLongPtr (hwndParent, 0);

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqPostHead) {
        // Queue is empty.
        lpsrvr->hqPostHead = lpsrvr->hqPostTail = hq;

        // create a timer.
        if (!SetTimer (lpsrvr->hwnd, 1, 100, NULL))
            return FALSE;

    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqPostTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqPostTail);
        lpsrvr->hqPostTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);
    return FALSE;
}


BOOL INTERNAL IsBlockQueueEmpty (
    HWND    hwnd
){

    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwnd))
            hwnd= hwndTmp;
    lpsrvr = (LPSRVR) GetWindowLongPtr (hwnd, 0);
    return (!lpsrvr->hqPostHead);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\client\ole.c ===
/******************************* Module Header *******************************
* Module Name: OLE.C
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* PURPOSE: API routines for handling generic objects (which may be static,
*    linked, or embedded).  These routines will be made into a DLL.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik  (../../90, 91)    Designed/coded.
*   curts created portable version for WIN16/32
*
*****************************************************************************/

#include <windows.h>

#include "dll.h"
#include "strsafe.h"

extern DLL_ENTRY        lpDllTable[];
extern char             packageClass[];
extern OLECLIPFORMAT    cfFileName;
extern DWORD            dwOleVer;

DWORD           dwVerFromFile;
HANDLE          hInfo = NULL;
CLIENTDOC       lockDoc = {{'C', 'D'}, 0L, 0L, 0, 0, 0, 0L, 0L};
LHCLIENTDOC     lhLockDoc = (LHCLIENTDOC) ((LPCLIENTDOC) &lockDoc);
BOOL            gbCreateInvisible = FALSE;
BOOL            gbLaunchServer;

OLESTATUS INTERNAL LockServer (LPOBJECT_LE);

#ifdef USE_FILE_VERSION_APIS
//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleSetFileVer ()
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL OleSetFileVer (
    LHCLIENTDOC lhclientdoc,
    WORD        wFileVer
){
   LPCLIENTDOC lpclientdoc = (LPCLIENTDOC)lhclientdoc;
char lpstr[256];

   switch (wFileVer)
   {
      case OS_WIN16:
      case OS_WIN32:
         lpclientdoc->dwFileVer = (DWORD)MAKELONG(wReleaseVer,wFileVer);
         return OLE_OK;
      default:
         return OLE_ERROR_FILE_VER;
    }

}

//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleQueryFileVer ()
//
//////////////////////////////////////////////////////////////////////////////


DWORD FAR PASCAL OleQueryFileVer (
    LPCLIENTDOC lpclientdoc
){

    return (lpclientdoc->dwFileVer);

}

#endif

//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleQueryProtocol (lpobj, lpprotocol)
//
//  Tells whether the object supports the specified protocol.
//
//  Arguments:
//
//      lpobj       -   object pointer
//      lpprotocol  -   protocol string
//
//  Returns:
//
//      long ptr to object if the protocol is supported
//      NULL if not.
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


LPVOID FAR PASCAL OleQueryProtocol (
    LPOLEOBJECT lpobj,
    LPCSTR       lpprotocol
){
    if (!CheckObject(lpobj))
        return NULL;

    return (*lpobj->lpvtbl->QueryProtocol) (lpobj, lpprotocol);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FAR PASCAL  OleDelete (lpobj)
//
//  Deletes the given object and all memory associated with its sub-parts.
//  The calling function should cease to use 'lpobj', as it is now invalid.
//  If handler dll is used reference count is reduced by one, and if it
//  reaches zero the hanlder dll will be freed up.
//
//  Arguments:
//
//      lpobj   -   object pointer
//
//  Returns:
//
//      OLE_OK
//      OLE_ERROR_OBJECT
//      OLE_WAIT_FOR_RELEASE
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL  OleDelete (
    LPOLEOBJECT    lpobj
){
    Puts("OleDelete");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Delete) (lpobj);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRelease (lpobj)
*
* OleRelease:
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRelease (
    LPOLEOBJECT    lpobj
){
    Puts("OleRelease");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Release) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleSaveToStream (lpobj, lpstream)
*
* oleSaveToStream: This will read <hobj> to the stream based on the <hfile>
* structure.  It will return TRUE on success.  This is the only object
* function for which it is not an error to pass a NULL <hobj>.  In the case
* of NULL, this function will simply put a placemarker for an object.
* See oleLoadFromStream.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleSaveToStream (
    LPOLEOBJECT    lpobj,
    LPOLESTREAM    lpstream
){
    Puts("OleSaveToStream");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ(lpstream);

    return ((*lpobj->lpvtbl->SaveToStream) (lpobj, lpstream));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleLoadFromStream (lpstream, lpprotcol, lpclient, lhclientdoc, lpobjname, lplpobj)
*
*  oleLoadFromStream: This will read an object out of the stream based on the
*  <hfile> structure.  It will return a HANDLE to the object it creates.
*  On error, the return value is NULL, but since NULL is also a valid object
*  in the file, the <error> parameter should be checked as well.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleLoadFromStream (
    LPOLESTREAM         lpstream,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    LONG            len;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    char            class[100];
    ATOM            aClass;
    BOOL            bEdit = FALSE, bStatic = FALSE;
    LONG            ctype;
    int             objCount;
    int             iTable = INVALID_INDEX;

    Puts("OleLoadFromStream");

    *lplpobj = NULL;

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpstream);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (!(bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)))
        if (!(bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)))
            return OLE_ERROR_PROTOCOL;

    if (GetBytes (lpstream, (LPSTR) &dwVerFromFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (GetBytes (lpstream, (LPSTR)&ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (ctype == CT_NULL)
        return (bStatic ? OLE_OK: OLE_ERROR_PROTOCOL);

    if (((ctype != CT_PICTURE) && (ctype != CT_STATIC) && bStatic) ||
            ((ctype != CT_LINK) && (ctype != CT_OLDLINK)
                && (ctype != CT_EMBEDDED) && bEdit))
        return OLE_ERROR_PROTOCOL;

    //** Get Class
    if (GetBytes(lpstream, (LPSTR)&len, sizeof(len)))
        return OLE_ERROR_STREAM;

    if (len == 0)
        return OLE_ERROR_STREAM;

    if (GetBytes(lpstream, (LPSTR)&class, len))
        return OLE_ERROR_STREAM;

    aClass = GlobalAddAtom (class);

    if ((ctype == CT_PICTURE) || (ctype == CT_STATIC))
        retVal = DefLoadFromStream (lpstream, (LPSTR)lpprotocol, lpclient,
                    lhclientdoc, (LPSTR)lpobjname, lplpobj, ctype, aClass, 0);

    //!!! It's the DLL's responsibility to delete the atom. But in case of
    // failure we delete the atom if our DefLoadFromStream().

    else if ((iTable = LoadDll (class)) == INVALID_INDEX) {
        retVal = DefLoadFromStream (lpstream, (LPSTR)lpprotocol, lpclient,
                        lhclientdoc, (LPSTR)lpobjname, lplpobj, ctype, aClass, 0);
    }
    else {
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Load) (lpstream, (LPSTR)lpprotocol, lpclient,
                       lhclientdoc, (LPSTR)lpobjname, lplpobj, ctype, aClass, 0);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;
    }

    return retVal;
}



OLESTATUS FAR PASCAL  OleClone (
    LPOLEOBJECT         lpobjsrc,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    OLESTATUS   retVal;

    Puts("OleClone");

    if (!CheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpclient);

    PROBE_READ(lpobjname);

    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    PROBE_WRITE(lplpobj);

    *lplpobj = NULL;

    retVal = (*lpobjsrc->lpvtbl->Clone) (lpobjsrc, lpclient,
                        lhclientdoc, lpobjname, lplpobj);

    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;

    return retVal;
}


OLESTATUS FAR PASCAL  OleCopyFromLink (
    LPOLEOBJECT         lpobjsrc,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    OLESTATUS   retVal;

    Puts("OleCopyFromLnk");

    if (!CheckObject(lpobjsrc))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpclient);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    *lplpobj = NULL;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    retVal = (*lpobjsrc->lpvtbl->CopyFromLink) (lpobjsrc, lpclient,
                        lhclientdoc, lpobjname, lplpobj);

    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;


    return retVal;

}



OLESTATUS FAR PASCAL  OleEqual (
    LPOLEOBJECT lpobj1,
    LPOLEOBJECT lpobj2
){
    if (!CheckObject(lpobj1))
        return OLE_ERROR_OBJECT;

    if (!CheckObject(lpobj2))
        return OLE_ERROR_OBJECT;

    if (lpobj1->ctype != lpobj2->ctype)
        return OLE_ERROR_NOT_EQUAL;

    return ((*lpobj1->lpvtbl->Equal) (lpobj1, lpobj2));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryLinkFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryFromClip: Returns OLE_OK if a linked object can be created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryLinkFromClip (
    LPCSTR          lpprotocol,
    OLEOPT_RENDER   optRender,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleQueryLinkFromClip");
    return LeQueryCreateFromClip ((LPSTR)lpprotocol, optRender,
                       cfFormat, CT_LINK);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryCreateFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryCreateFromClip: Returns true if a non-linked object can be
* created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryCreateFromClip (
    LPCSTR          lpprotocol,
    OLEOPT_RENDER   optRender,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleQueryCreateFromClip");
    return (LeQueryCreateFromClip ((LPSTR)lpprotocol, optRender,
                        cfFormat, CT_EMBEDDED));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateLinkFromClip (lpprotcol, lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
*
*
*  oleCreateLinkFromClip: This function creates the LP to an object from the
*  clipboard.  It will try to create a linked object.  Return value is OLE_OK
*  is the object is successfully created it
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateLinkFromClip (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT  FAR *  lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    int         objCount;
    int         iTable = INVALID_INDEX;
    OLESTATUS   retVal;
    LPSTR       lpInfo;

    Puts("OleCreateLinkFromClip");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_WRITE(lplpobj);

    PROBE_READ(lpobjname);

    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    *lplpobj = NULL;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (IsClipboardFormatAvailable (cfFileName))
        return CreatePackageFromClip (lpclient, lhclientdoc, (LPSTR)lpobjname,
                        lplpobj, optRender, cfFormat, CT_LINK);

    if (!(hInfo = GetClipboardData (cfObjectLink)))
        return OLE_ERROR_CLIPBOARD;

    if (!(lpInfo = GlobalLock(hInfo)))
        return OLE_ERROR_CLIPBOARD;

    iTable = LoadDll (lpInfo);
    GlobalUnlock (hInfo);


    if (iTable == INVALID_INDEX)
        retVal = DefCreateLinkFromClip ((LPSTR)lpprotocol, lpclient, lhclientdoc,
                        (LPSTR)lpobjname, lplpobj, optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Link) ((LPSTR)lpprotocol, lpclient,
                    lhclientdoc, (LPSTR)lpobjname, lplpobj, optRender, cfFormat);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;
    }

    hInfo = NULL;
    return retVal;
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateFromClip (lpprotcol, lpclient, lplpoleobject, optRender, cfFormat)
*
*
* oleCreateFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create an embedded object if
*  OwnerLink and Native are available, otherwise it will create a static
*  picture.  Return value is OLE_OK if the object is successfully
*  created it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateFromClip (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS       retVal;
    LONG            ctype;
    int             iTable = INVALID_INDEX;
    LPSTR           lpInfo;
    LPSTR           lpClass = NULL;
    int             objCount;
    OLECLIPFORMAT   cfEnum = 0;

    Puts("OleCreateFromClip");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_WRITE(lplpobj);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    *lplpobj = NULL;

    if (!lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (optRender == olerender_none)
            return OLE_ERROR_OPTION;

        if ( (optRender == olerender_format) &&
             (cfFormat != CF_METAFILEPICT) &&
             (cfFormat != CF_DIB) &&
             (cfFormat != CF_BITMAP) &&
             (cfFormat != CF_ENHMETAFILE))
            return OLE_ERROR_FORMAT;

        if (!IsClipboardFormatAvailable (CF_METAFILEPICT)
                && !IsClipboardFormatAvailable (CF_DIB)
                && !IsClipboardFormatAvailable (CF_BITMAP)
                && !IsClipboardFormatAvailable (CF_ENHMETAFILE) )
            return OLE_ERROR_FORMAT;

        return CreatePictFromClip (lpclient, lhclientdoc,
                        (LPSTR)lpobjname, lplpobj, optRender,
                        cfFormat, NULL, CT_STATIC);
    }
    else if (!lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {
        if (IsClipboardFormatAvailable (cfFileName))
            return CreatePackageFromClip (lpclient, lhclientdoc, (LPSTR)lpobjname,
                            lplpobj, optRender, cfFormat, CT_EMBEDDED);

        if (!(hInfo = GetClipboardData (cfOwnerLink)))
            return OLE_ERROR_CLIPBOARD;

        while (TRUE) {
            cfEnum = (OLECLIPFORMAT)EnumClipboardFormats ((WORD)cfEnum);
            if (cfEnum == (OLECLIPFORMAT)cfNative) {
                ctype = CT_EMBEDDED;
                break;
            }
            else if (cfEnum == cfOwnerLink) {
                ctype = CT_LINK;
                break;
            }
        }

        if (!(lpInfo = GlobalLock(hInfo)))
            return OLE_ERROR_CLIPBOARD;

        iTable = LoadDll (lpInfo);
        GlobalUnlock (hInfo);
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }

    if (iTable == INVALID_INDEX)
        retVal = DefCreateFromClip ((LPSTR)lpprotocol, lpclient, lhclientdoc,
                        (LPSTR)lpobjname, lplpobj, optRender, cfFormat, ctype);
    else {
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Clip) ((LPSTR)lpprotocol, lpclient,
                            lhclientdoc, (LPSTR)lpobjname, lplpobj,
                            optRender, cfFormat, ctype);

        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;
    }

    hInfo = NULL;
    return retVal;
}




/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCopyToClipboard (lpobj)
*
*
* oleCopyToClipboard: This routine executes the standard "Copy" menu item
* on the typical "Edit" menu. Returns TRUE if successful.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCopyToClipboard (
    LPOLEOBJECT lpobj
){
    Puts("OleCopyToClipboard");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->CopyToClipboard) (lpobj));
}


OLESTATUS FAR PASCAL OleSetHostNames (
    LPOLEOBJECT lpobj,
    LPCSTR      lpclientName,
    LPCSTR      lpdocName
){
    Puts ("OleSetHostNames");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_READ(lpclientName);
    PROBE_READ(lpdocName);

    return ((*lpobj->lpvtbl->SetHostNames) (lpobj, lpclientName, lpdocName));
}



OLESTATUS   FAR PASCAL OleSetTargetDevice (
    LPOLEOBJECT lpobj,
    HANDLE      hDevInfo
){
    Puts("OleSetTargetDevice");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->SetTargetDevice) (lpobj, hDevInfo));
}



OLESTATUS   FAR PASCAL OleSetColorScheme (
    LPOLEOBJECT           lpobj,
    const LOGPALETTE FAR *lplogpal
){
    Puts("OleSetColorScheme");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->SetColorScheme) (lpobj, (LOGPALETTE FAR *)lplogpal));
}



OLESTATUS FAR PASCAL  OleSetBounds(
    LPOLEOBJECT     lpobj,
    const RECT FAR *lprc
){
    Puts("OleSetBounds");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ((RECT FAR *)lprc);

    return ((*lpobj->lpvtbl->SetBounds) (lpobj, (RECT FAR *)lprc));

}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQueryBounds (lpobj, lpRc)
*
* Returns the bounds of the object in question in MM_HIMETRIC mode.
*           width  = lprc->right - lprc->left;  in HIMETRIC units
*           height = lprc->top - lprc->bottom;  in HIMETRIC units
*
* Returns OLE_OK or OLE_ERROR_MEMORY.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryBounds (
    LPOLEOBJECT    lpobj,
    LPRECT         lprc
){

    Puts("OleQueryBounds");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lprc);

    return (*lpobj->lpvtbl->QueryBounds) (lpobj, lprc);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQuerySize (lpobj, lpsize)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQuerySize (
    LPOLEOBJECT    lpobj,
    DWORD FAR *    lpdwSize
){
    Puts("OleQuerySize");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_WRITE(lpdwSize);

    *lpdwSize = 0;
    return (*lpobj->lpvtbl->QuerySize) (lpobj, lpdwSize);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleDraw (lpobj, hdc, lprc, lpWrc, lphdcTarget)
*
* oleObjectDraw: This displays the given object on the device context <hcd>.
* The <htargetdc> parameter is not currently used. Returns same as Draw().
*
* Expects rectangle coordinates in MM_HIMETRIC units.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleDraw (
    LPOLEOBJECT     lpobj,
    HDC             hdc,
    const RECT FAR *lprc,
    const RECT FAR *lpWrc,
    HDC             hdcTarget
){

    Puts("OleObjectDraw");

    if (!FarCheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_READ((RECT FAR *)lprc);
    if (lpWrc)
        PROBE_READ((RECT FAR *)lpWrc);

    return ((*lpobj->lpvtbl->Draw) (lpobj, hdc, (RECT FAR *)lprc, (RECT FAR *)lpWrc, hdcTarget));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryOpen (lpobj)
*
* returns TRUE is an object has been activated.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryOpen (
    LPOLEOBJECT lpobj
){
    Puts("OleQueryOpen");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOpen) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleActivate (lpobj)
*
* Activates an object. For embeded objects always a new instance is
* loaded and the instance is destroyed once the data is transferred
* at close time. For linked objects, an instance of the render is created
* only if one does not exist.
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleActivate (
    LPOLEOBJECT     lpobj,
    UINT            verb,
    BOOL            fShow,
    BOOL            fActivate,
    HWND            hWnd,
    const RECT FAR *lprc
){

    Puts("OleActivate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    /* PROBE_READ(lprc); */

    return (*lpobj->lpvtbl->Activate) (lpobj, verb, fShow, fActivate, hWnd, (RECT FAR *)lprc);
}




OLESTATUS FAR PASCAL OleClose (
    LPOLEOBJECT lpobj
){

    Puts("OleClose");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

     return (*lpobj->lpvtbl->Close) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleUpdate (lpobj)
*
* If there exists a link, sends advise for getting the latest rendering
* infromation. If there is no link, loads an instance, advises for the
* render information and closes the instance once the data is available.
* (If possible should not show the window).
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleUpdate (
   LPOLEOBJECT lpobj
){

    Puts("OleUpdate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Update) (lpobj);

}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleReconnect (lpobj)
*
* Reconnects to the renderer if one does not exist already.
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleReconnect (
    LPOLEOBJECT lpobj
){
    Puts("OleReconnect");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Reconnect) (lpobj);
}


OLESTATUS FAR PASCAL OleGetLinkUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE FAR * lpOptions
){
    Puts("OleGetLinkUpdateOptions");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lpOptions);

    return (*lpobj->lpvtbl->GetLinkUpdateOptions) (lpobj, lpOptions);
}



OLESTATUS FAR PASCAL OleSetLinkUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE       options
){
    Puts("OleSetLinkUpdateOptions");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetLinkUpdateOptions) (lpobj, options);

}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleEnumFormats (lpobj, cfFormat)
*
* Returns OLE_YES if the object is of type LINK or EMBEDDED.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLECLIPFORMAT FAR PASCAL OleEnumFormats (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleEnumFormats");

    if (!CheckObject(lpobj))
        return 0;

    return (*lpobj->lpvtbl->EnumFormats) (lpobj, cfFormat);
}

OLESTATUS FAR PASCAL OleRequestData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!cfFormat)
        return OLE_ERROR_FORMAT;

    return (*lpobj->lpvtbl->RequestData) (lpobj, cfFormat);
}


OLESTATUS FAR PASCAL OleGetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    LPHANDLE        lphandle
){
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE((LPVOID)lphandle);

    return (*lpobj->lpvtbl->GetData) (lpobj, cfFormat, lphandle);
}


OLESTATUS FAR PASCAL OleSetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE          hData
){
    Puts("OleSetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetData) (lpobj, cfFormat, hData);
}



OLESTATUS FAR PASCAL OleQueryOutOfDate (
    LPOLEOBJECT lpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOutOfDate) (lpobj);
}


OLESTATUS FAR PASCAL OleLockServer (
    LPOLEOBJECT     lpobjsrc,
    LHSERVER FAR *  lplhsrvr
){
    LPOBJECT_LE lpobj;
    OLESTATUS   retVal = OLE_OK;
    ATOM        aCliClass, aSvrClass;

    Puts ("OleLockServer");

    if (!FarCheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;

    if (lpobjsrc->ctype == CT_STATIC)
        return OLE_ERROR_STATIC;

    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(((LPOBJECT_LE)lpobjsrc));
    FARPROBE_WRITE(lplhsrvr);

    aCliClass = ((LPCLIENTDOC)(lpobjsrc->lhclientdoc))->aClass;
    aSvrClass = ((LPOBJECT_LE)lpobjsrc)->app;

    // See whether the server is already locked
    lpobj = (LPOBJECT_LE) (lockDoc.lpHeadObj);
    while (lpobj) {
        if ((lpobj->app == aSvrClass) && (lpobj->topic == aCliClass)) {
            if (!lpobj->head.cx) {
                // The unlocking process of server handle has started. This
                // is an asynchronous process. We want to let it complete.
                // Let's try the next handle

                ;
            }
            else {
                if (!IsServerValid (lpobj)) {
                    DeleteSrvrEdit (lpobj);
                    retVal = LockServer (lpobj);
                }
                else {
                    // Lock count
                    lpobj->head.cx++;
                }

                if (retVal == OLE_OK)
                    *lplhsrvr = (LHSERVER) lpobj;

                return retVal;
            }
        }

        lpobj = (LPOBJECT_LE) (lpobj->head.lpNextObj);
    }


    if (!(lpobj = LeCreateBlank(lhLockDoc, NULL, OT_EMBEDDED)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient    = NULL;
    lpobj->head.lpvtbl      = lpobjsrc->lpvtbl;
    lpobj->app              = DuplicateAtom (aSvrClass);
    lpobj->topic            = DuplicateAtom (aCliClass);
    lpobj->aServer          = DuplicateAtom(((LPOBJECT_LE)lpobjsrc)->aServer);
    lpobj->bOleServer       = ((LPOBJECT_LE)lpobjsrc)->bOleServer;

    if ((retVal = LockServer (lpobj)) == OLE_OK) {
        // Change signature
        lpobj->head.objId[0] = 'S';
        lpobj->head.objId[1] = 'L';
        *lplhsrvr = (LHSERVER) lpobj;
    }
    else {
        LeRelease ((LPOLEOBJECT)lpobj);
    }

    return retVal;
}


OLESTATUS INTERNAL LockServer (
    LPOBJECT_LE lpobj
){
    HANDLE hInst;

    if (!InitSrvrConv (lpobj, NULL)) {
        if (!lpobj->bOleServer)
            lpobj->fCmd = ACT_MINIMIZE;
        else
            lpobj->fCmd = 0;

        if (!(hInst = LeLaunchApp (lpobj)))
            return OLE_ERROR_LAUNCH;

        if (!InitSrvrConv (lpobj, hInst))
            return OLE_ERROR_COMM;

    }

    // lock count
    lpobj->head.cx++;
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleUnlockServer (
    LHSERVER lhsrvr
){
    LPOBJECT_LE lpobj;
    OLESTATUS   retval;

    Puts ("OleUnlockServer");

    if (!FarCheckPointer ((lpobj = (LPOBJECT_LE)lhsrvr), WRITE_ACCESS))
        return OLE_ERROR_HANDLE;

    if (lpobj->head.objId[0] != 'S' || lpobj->head.objId[1] != 'L')
        return OLE_ERROR_HANDLE;

    if (!lpobj->head.cx)
        return OLE_OK;

    if (--lpobj->head.cx)
        return OLE_OK;

    //change signature
    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';

    if ((retval = LeRelease((LPOLEOBJECT)lpobj)) == OLE_WAIT_FOR_RELEASE)
        DocDeleteObject ((LPOLEOBJECT)lpobj);

    return retval;
}


OLESTATUS FAR PASCAL OleObjectConvert (
    LPOLEOBJECT         lpobj,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;


    return (*lpobj->lpvtbl->ObjectConvert) (lpobj, lpprotocol, lpclient,
                    lhclientdoc, lpobjname, lplpobj);
}


//OleCreateFromTemplate: Creates an embedded object from Template

OLESTATUS FAR PASCAL OleCreateFromTemplate (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromTemplate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lptemplate);
    PROBE_WRITE(lplpoleobject);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (!MapExtToClass ((LPSTR)lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;


    // !!! we found the class name. At this point, we need to load
    // the right library and call the right entry point;

    iTable = LoadDll (buf);
    if (iTable == INVALID_INDEX)
        retval = DefCreateFromTemplate ((LPSTR)lpprotocol, lpclient,
                            (LPSTR)lptemplate,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromTemplate) ((LPSTR)lpprotocol,
                                lpclient, (LPSTR)lptemplate,
                                lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreate: Creates an embedded object from the class.

OLESTATUS FAR PASCAL OleCreate (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX)
        retval = DefCreate ((LPSTR)lpprotocol, lpclient, (LPSTR)lpclass,
                        lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                        optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].Create) ((LPSTR)lpprotocol,
                            lpclient, (LPSTR)lpclass,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FAR PASCAL OleCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bLaunchServer)
//
// Creates an embedded object from the class.
//
//  Arguments:
//
//     lpprotocol   -
//     lpclient -
//     lpclass  -
//     lhclientdoc  -
//     lpobjname    -
//     lplpoleobject    -
//     optRender    -
//     cfFormat -
//     bLaunchServer -
//
//  Returns:
//
//      OLE_ERROR_HANDLE    -
//      OLE_ERROR_NAME      -
//      OLE_ERROR_PROTOCOL  -
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL OleCreateInvisible (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                bLaunchServer
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreateInvisible");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX) {
        retval = DefCreateInvisible ((LPSTR)lpprotocol, lpclient, (LPSTR)lpclass,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat, bLaunchServer);
    }
    else {
        objCount = lpDllTable[iTable].cObj;

        if (!(lpDllTable[iTable].CreateInvisible)) {
            // dll didn't export this function. Lets call DllCreate, so that
            // handler will get a chance to replace the methods. The flag is
            // used to tell the internal functions that this call infact wants
            // to achieve the effect of CreateInvisble.
            gbCreateInvisible = TRUE;
            gbLaunchServer = bLaunchServer;
            retval = (*lpDllTable[iTable].Create) ((LPSTR)lpprotocol,
                                    lpclient, (LPSTR)lpclass,
                                    lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                    optRender, cfFormat);
            gbCreateInvisible = FALSE;
        }
        else {
            retval   = (*lpDllTable[iTable].CreateInvisible) ((LPSTR)lpprotocol,
                                    lpclient, (LPSTR)lpclass,
                                    lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                    optRender, cfFormat, bLaunchServer);
        }

        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateFromFile: Creates an embedded object from file

OLESTATUS FAR PASCAL OleCreateFromFile (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LPCSTR              lpfile,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
    if (lpclass)
        PROBE_READ(lpclass);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;

        if (!lstrcmp (lpclass, packageClass))
            iTable = INVALID_INDEX;
        else
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass ((LPSTR)lpfile, buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateFromFile ((LPSTR)lpprotocol,
                            lpclient, (LPSTR)lpclass, (LPSTR)lpfile,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromFile) ((LPSTR)lpprotocol,
                                lpclient, (LPSTR)lpclass, (LPSTR)lpfile,
                                lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateLinkFromFile: Creates a linked object from file

OLESTATUS FAR PASCAL OleCreateLinkFromFile (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LPCSTR              lpfile,
    LPCSTR              lpitem,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR+6];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateLinkFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
    if (lpclass)
        PROBE_READ(lpclass);
    if (lpitem)
        PROBE_READ(lpitem);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;

        if (!lstrcmp (lpclass, packageClass)) {
            if (FAILED(StringCchCopy(buf, sizeof(buf)/sizeof(buf[0]), lpfile)))
                return OLE_ERROR_NAME;
            if (FAILED(StringCchCat(buf, sizeof(buf)/sizeof(buf[0]), "/Link")))
                return OLE_ERROR_NAME;
            return  CreateEmbLnkFromFile (lpclient, packageClass, buf,
                                NULL, lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat, OT_EMBEDDED);
        }
        else
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass ((LPSTR)lpfile, buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateLinkFromFile ((LPSTR)lpprotocol,
                            lpclient, (LPSTR)lpclass, (LPSTR)lpfile, (LPSTR)lpitem,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);

    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateLinkFromFile) ((LPSTR)lpprotocol,
                                lpclient, (LPSTR)lpclass, (LPSTR)lpfile, (LPSTR)lpitem,
                                lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



// Routines related to asynchronous operations.
OLESTATUS   FAR PASCAL  OleQueryReleaseStatus (
    LPOLEOBJECT lpobj
){
    if (!CheckPointer (lpobj, WRITE_ACCESS))
        return OLE_ERROR_OBJECT;

    // make sure that it is a long pointer to L&E object or a lock handle
    if (!(lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
            && !(lpobj->objId[0] == 'S' && lpobj->objId[1] == 'L'))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->QueryReleaseStatus) (lpobj);
}


OLESTATUS   FAR PASCAL  OleQueryReleaseError  (
    LPOLEOBJECT lpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseError) (lpobj);
}

OLE_RELEASE_METHOD FAR PASCAL OleQueryReleaseMethod (
    LPOLEOBJECT lpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseMethod) (lpobj);
}


OLESTATUS FAR PASCAL OleRename (
    LPOLEOBJECT lpobj,
    LPCSTR       lpNewName
){
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Rename) (lpobj, lpNewName);
}


OLESTATUS FAR PASCAL OleExecute (
    LPOLEOBJECT lpobj,
    HANDLE      hCmds,
    UINT        wReserved
){
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Execute) (lpobj, hCmds, wReserved);
}


OLESTATUS FAR PASCAL OleQueryName (
    LPOLEOBJECT lpobj,
    LPSTR       lpBuf,
    UINT FAR *  lpcbBuf
){
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->QueryName) (lpobj, lpBuf, lpcbBuf);
}

OLESTATUS FAR PASCAL OleQueryType (
    LPOLEOBJECT lpobj,
    LPLONG      lptype
){
    Puts("OleQueryType");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lptype);

    return (*lpobj->lpvtbl->QueryType) (lpobj, lptype);
}



DWORD FAR PASCAL OleQueryClientVersion ()
{
    return dwOleVer;
}


OLESTATUS INTERNAL LeQueryCreateFromClip (
    LPSTR               lpprotocol,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    LONG                cType
){
    OLESTATUS   retVal = TRUE;
    BOOL        bEdit = FALSE, bStatic = FALSE;

    PROBE_MODE(bProtMode);
    PROBE_READ(lpprotocol);

    if (bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {
        if (IsClipboardFormatAvailable (cfFileName))
            return OLE_OK;

        if (cType == CT_LINK)
            retVal = IsClipboardFormatAvailable (cfObjectLink);
#ifdef OLD
                        || IsClipboardFormatAvailable (cfLink) ;
#endif
        else if (cType == CT_EMBEDDED)
            retVal = IsClipboardFormatAvailable (cfOwnerLink);

        if (!retVal)
            return OLE_ERROR_FORMAT;

        if (optRender == olerender_none)
            return OLE_OK;
    }
    else if (bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (cType == CT_LINK)
            return OLE_ERROR_PROTOCOL;

        if (optRender == olerender_none)
            return OLE_ERROR_FORMAT;
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }

    if (optRender == olerender_draw) {
        if (!IsClipboardFormatAvailable (CF_METAFILEPICT) &&
                !IsClipboardFormatAvailable (CF_DIB)      &&
                !IsClipboardFormatAvailable (CF_BITMAP)   &&
                !IsClipboardFormatAvailable (CF_ENHMETAFILE)   &&
                !(bEdit && QueryHandler((cType == CT_LINK) ? cfObjectLink : cfOwnerLink)))
            return OLE_ERROR_FORMAT;
    }
    else if (optRender == olerender_format) {
        if (!IsClipboardFormatAvailable (cfFormat))
            return OLE_ERROR_FORMAT;

        if (bStatic &&
            (cfFormat != CF_METAFILEPICT) &&
            (cfFormat != CF_ENHMETAFILE) &&
            (cfFormat != CF_DIB) &&
            (cfFormat != CF_BITMAP))
            return OLE_ERROR_FORMAT;

    }
    else {
        return OLE_ERROR_FORMAT;
    }

    return OLE_OK;
}



BOOL INTERNAL CheckObject(
    LPOLEOBJECT lpobj
){
    if (!CheckPointer(lpobj, WRITE_ACCESS))
        return FALSE;

    if (lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
        return TRUE;

    return FALSE;
}

BOOL FARINTERNAL FarCheckObject(
    LPOLEOBJECT lpobj
){
    return (CheckObject (lpobj));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\checkptr.c ===
/* CheckPtr.c
   Pointer validation routine
   Written by t-jasonf.
*/

#include "windows.h"
#include "dde.h"
#include "ole.h"
#include "cmacs.h"
#include "srvr.h"


/* CheckPointer()
   Parameters :
      LPVOID lp         - pointer to check
      int    nREADWRITE - READ_ACCESS or WRITE_ACCESS
   Returns:
      0 if process does not have that kind of access to memory at lp.
      1 if process does have access.
*/
WORD CheckPointer (void *lp, int nReadWrite)
{
   char ch;
   WORD iRet;

   try
   {
      switch (nReadWrite)
      {
         case READ_ACCESS:
            ch = *((volatile char *)lp);
            break;
         case WRITE_ACCESS:
            ch = *((volatile char *)lp);
            *((volatile char *)lp) = ch;
            break;
      }
      iRet = 1;
   }
   except ( /*
            GetExceptionCode == STATUS_ACCESS_VIOLATION
            ? EXCEPTION_EXECUTE_HANDLER
            : EXCEPTION_CONTINUE_SEARCH
            */
            EXCEPTION_EXECUTE_HANDLER
          )
   {
      iRet = 0;
   }

   return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\item.c ===
/****************************** Module Header ******************************\
* Module Name: Item.c Object(item) main module
*
* Purpose: Includes All the object releated routiens.
*
* Created: Oct 1990.
*
* Copyright (c) 1990 - 1992  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/


#include "windows.h"
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

extern HANDLE   hdllInst;
extern FARPROC  lpFindItemWnd;
extern FARPROC  lpItemCallBack;
extern FARPROC  lpSendDataMsg;
extern FARPROC  lpSendRenameMsg;
extern FARPROC  lpDeleteClientInfo;
extern FARPROC  lpEnumForTerminate;


extern  ATOM    cfNative;
extern  ATOM    cfBinary;
extern  ATOM    aClose;
extern  ATOM    aChange;
extern  ATOM    aSave;
extern  ATOM    aEditItems;
extern  ATOM    aStdDocName;

extern  WORD    cfLink;
extern  WORD    cfOwnerLink;
HWND            hwndItem;
HANDLE          hddeRename;
HWND            hwndRename;

UINT            enummsg;
UINT            enuminfo;
LPOLEOBJECT     enumlpoleobject;
OLECLIENTVTBL   clVtbl;
BOOL            bClientUnlink;

BOOL            fAdviseSaveDoc;
BOOL            fAdviseSaveItem;

char *  stdStrTable[STDHOSTNAMES+1] =
        {
            NULL,
            "StdTargetDevice",
            "StdDocDimensions",
            "StdColorScheme",
            "StdHostNames"
        };

void ChangeOwner (HANDLE hmfp);

// !!!change child enumeration.
// !!!No consistency in errors (Sometimes Bools and sometimes OLESTATUS).


//SearchItem: Searches for a given item in a document tree.
//If found, returns the corresponding child windows handle.

HWND  INTERNAL SearchItem (
    LPDOC lpdoc,
    LPSTR lpitemname
){
    ATOM  aItem;

    Puts ("SearchItem");

    // If the item passed is an atom, get its name.
    if (!HIWORD(lpitemname))
        aItem = (ATOM) (LOWORD(lpitemname));
    else if (!lpitemname[0])
        aItem = (ATOM)0;
    else
        aItem = GlobalFindAtom (lpitemname);

    hwndItem = NULL;

    // !!! We should avoid hwndItem static. It should not cause
    // any problems since while enumerating we will not be calling
    // any window procs  or no PostMessages are entertained.

    EnumChildWindows (lpdoc->hwnd, (WNDENUMPROC)lpFindItemWnd,
        MAKELONG (aItem, ITEM_FIND));

    return hwndItem;

}

// FindItem: Given the itemname and the document handle,
// searches for the the item (object) in the document tree.
// Items are child windows for the document window.

// !!! change the child windows to somekind of
// linked lists at the item level. This will free up
// the space taken by the item windows.

int  INTERNAL FindItem (
    LPDOC          lpdoc,
    LPSTR          lpitemname,
    LPCLIENT FAR * lplpclient
){
    LPCLIENT    lpclient;
    HWND        hwnd;
    char        buf[MAX_STR];

    Puts ("FindItem");

    hwnd = SearchItem (lpdoc, lpitemname);

    if (!HIWORD(lpitemname)){
        if (LOWORD(lpitemname)){
            if (!GlobalGetAtomName ((ATOM)LOWORD(lpitemname), (LPSTR)buf, MAX_STR))
                 return OLE_ERROR_BLANK;
        }
        else
            buf[0] = '\0';

        lpitemname = (LPSTR)buf;
    }

    if (hwnd) {
        // we found the item window
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

            *lplpclient = lpclient;
            return OLE_OK;

    }

    // Item (object)window is not create yet. Let us create one.
    return RegisterItem ((LHDOC)lpdoc, lpitemname, lplpclient, TRUE);
}



//RegisterItem: Given the document handle and the item string
//creates item with the given document.

int  INTERNAL RegisterItem (
    LHDOC          lhdoc,
    LPSTR          lpitemname,
    LPCLIENT FAR * lplpclient,
    BOOL           bSrvr
){
    LPDOC           lpdoc;
    HANDLE          hclient  = NULL;
    LPCLIENT        lpclient = NULL;
    OLESTATUS        retval   = OLE_ERROR_MEMORY;
    LPOLESERVERDOC  lpoledoc;
    LPOLEOBJECT     lpoleobject = NULL;


    Puts ("CreateItem");

    lpdoc = (LPDOC)lhdoc;

    // First create the callback client structure.

    hclient = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (CLIENT));
    if(!(hclient && (lpclient = (LPCLIENT)GlobalLock (hclient))))
        goto errRtn;

    lpclient->hclient       = hclient;
    hclient                 = NULL;

    if (!HIWORD(lpitemname)) {
        ASSERT (!bSrvr, "invalid lpitemname in RegisterItem\n");
        lpclient->aItem = LOWORD(lpitemname);
    }
    else if (!lpitemname[0])
        lpclient->aItem = (ATOM)0;
    else
        lpclient->aItem = GlobalAddAtom (lpitemname);

    lpclient->oleClient.lpvtbl = &clVtbl;
    lpclient->oleClient.lpvtbl->CallBack = ItemCallBack;

    lpoledoc = lpdoc->lpoledoc;

    // Call the server app to create its own object structure and link
    // it to the given document.

    // Call the server if the item is not one of the standard items.

    if (bSrvr) {
        retval = (*lpoledoc->lpvtbl->GetObject)(lpoledoc, lpitemname,
                    (LPOLEOBJECT FAR *)&lpoleobject, (LPOLECLIENT)lpclient);
        if (retval != OLE_OK)
            goto errRtn;
    }

    lpclient->lpoleobject   = lpoleobject;

    lpclient->hwnd = CreateWindowEx (WS_EX_NOPARENTNOTIFY,"ItemWndClass", "ITEM",
                        WS_CHILD,0,0,0,0,lpdoc->hwnd,NULL, hdllInst, NULL);

    if (lpclient->hwnd == NULL)
        goto errRtn;

    // save the ptr to the item in the window.
    SetWindowLongPtr (lpclient->hwnd, 0, (LONG_PTR)lpclient);
    *lplpclient = lpclient;
    return OLE_OK;

errRtn:

    if (lpclient)
        RevokeObject ((LPOLECLIENT)lpclient, FALSE);

    else {
        if(hclient)
            GlobalFree (hclient);
    }

    return retval;

}


OLESTATUS  FAR PASCAL OleRevokeObject (
    LPOLECLIENT    lpoleclient
){
    return RevokeObject (lpoleclient, TRUE);

}

// OleRevokeObject: Revokes an object (unregisres an object
// from the document tree.

OLESTATUS  INTERNAL RevokeObject (
    LPOLECLIENT    lpoleclient,
    BOOL           bUnlink
){
    HANDLE      hclient;
    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)lpoleclient;

    PROBE_WRITE(lpoleclient);
    if (lpclient->lpoleobject) {
       // first call the object for deletetion.

        (*lpclient->lpoleobject->lpvtbl->Release)(lpclient->lpoleobject);

    }

    if (ISATOM(lpclient->aItem)) {
        GlobalDeleteAtom (lpclient->aItem);
        lpclient->aItem = (ATOM)0;
    }

    if (lpclient->hwnd) {
        SetWindowLongPtr (lpclient->hwnd, 0, (LONG_PTR)NULL);

        // another static for enumerating the properties.
        // we need to change these .
        bClientUnlink = bUnlink;

        EnumProps(lpclient->hwnd, (PROPENUMPROC)lpDeleteClientInfo);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);
        DestroyWindow (lpclient->hwnd);
    }

    GlobalUnlock (hclient = lpclient->hclient);
    GlobalFree (hclient);
    return OLE_OK;

}

BOOL    FAR PASCAL  DeleteClientInfo (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hclinfo
){
    PCLINFO     pclinfo = NULL;
    HWND        hwndDoc;
    LPDOC       lpdoc;

    // delete the printer dev info block
    if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
        if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);


        if (bClientUnlink) {
            // terminate the conversation for the client.
            TerminateDocClients ((hwndDoc = GetParent(hwnd)), NULL, pclinfo->hwnd);
            lpdoc = (LPDOC)GetWindowLongPtr (hwndDoc, 0);
            // for some reason this delete is gving circular lists for properties

            //DeleteClient (hwndDoc, pclinfo->hwnd);
            //lpdoc->cClients--;
        }
        LocalUnlock (hclinfo);
    }
    LocalFree (hclinfo);

    RemoveProp(hwnd, lpstr);
    return TRUE;
}




// Call back for the Object windows numeration. data  field
// has the command and the extra information


BOOL    FAR PASCAL FindItemWnd(
    HWND    hwnd,
    LONG    data
){

    LPCLIENT    lpclient;
    int         cmd;
    HANDLE      hclinfo;
    PCLINFO     pclinfo = NULL;


    lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

    cmd = HIWORD(data);
    switch (cmd) {
        case    ITEM_FIND:
            if (lpclient->aItem == (ATOM)(LOWORD (data))) {
                // we found the window we required. Remember the
                // object window.

                hwndItem = hwnd;
                return FALSE; // terminate enumeration.

            }
            break;

        case    ITEM_SAVED:
            if (lpclient->lpoleobject) {
                if (ItemCallBack ((LPOLECLIENT) lpclient, OLE_SAVED,
                        lpclient->lpoleobject) == OLE_ERROR_CANT_UPDATE_CLIENT)
                    fAdviseSaveDoc = FALSE;
            }
            break;

        case    ITEM_DELETECLIENT:

            // delete the client from our list if we have one

            hclinfo = FindClient (hwnd, (HWND) (LOWORD(data)));
            if (hclinfo){
                // delete the printer dev info block
                if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
                    if(pclinfo->hdevInfo)
                        GlobalFree (pclinfo->hdevInfo);
                    LocalUnlock (hclinfo);
                }
                LocalFree (hclinfo);
                DeleteClient ( hwnd, (HWND) (LOWORD(data)));
            }
            break;

        case    ITEM_DELETE:
            // delete the client it self.
            RevokeObject ((LPOLECLIENT)lpclient, FALSE);
            break;

    }
    return TRUE;        // continue enumeration.
}



//DeleteFromItemsList: Deletes a client from the object lists of
//all the objects of a given  document. Thie client possibly
//is terminating the conversation with our doc window.


void INTERNAL   DeleteFromItemsList (
    HWND    hwndDoc,
    HWND    hwndClient
){

    EnumChildWindows (hwndDoc, (WNDENUMPROC)lpFindItemWnd,
        MAKELONG (hwndClient, ITEM_DELETECLIENT));

}


// DeleteAllItems: Deletes all the objects of a given
// document window.


void INTERNAL   DeleteAllItems (
    HWND    hwndDoc
){

    EnumChildWindows (hwndDoc, (WNDENUMPROC)lpFindItemWnd, MAKELONG (NULL, ITEM_DELETE));

}


// Object widnow proc:

LRESULT FAR PASCAL ItemWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
){

    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

    switch (msg) {
       case WM_DESTROY:
            DEBUG_OUT("Item: Destroy window",0)

            break;
       default:
            DEBUG_OUT("item:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }
    return 0L;

}

// PokeData: Prepares and gives the data to the server app thru
// the SetData object method.

OLESTATUS    INTERNAL PokeData (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam
){
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPCLIENT        lpclient;
    DDEPOKE FAR *   lpPoke = NULL;
    HANDLE          hPoke = NULL;
    HANDLE          hnew   = NULL;
    OLECLIPFORMAT   format;
    BOOL            fRelease = FALSE;
    ATOM            aItem = GET_WM_DDE_POKE_ITEM((WPARAM)NULL,lparam);

    UNREFERENCED_PARAMETER(hwndClient);

    // Get the object handle first. Look in the registration
    // tree and if one is not created otherwise create one.

    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(aItem),
                (LPCLIENT FAR *)&lpclient);

    if (retval != OLE_OK)
        goto errRtn;

    hPoke = GET_WM_DDE_POKE_HDATA((WPARAM)NULL,lparam);
    if(!(hPoke && (lpPoke = (DDEPOKE FAR *) GlobalLock (hPoke))))
        goto errRtn;

    GlobalUnlock (hPoke);

    format   = lpPoke->cfFormat;
    fRelease = lpPoke->fRelease;

    // We found the item. Now prepare the data to be given to the object
    if (!(hnew = MakeItemData (lpPoke, hPoke, format)))
        goto errRtn;

    // Now send the data to the object


    retval = (*lpclient->lpoleobject->lpvtbl->SetData) (lpclient->lpoleobject,
                                                format, hnew);

    // We free the data if server returns OLE_ERROR_SETDATA_FORMAT.
    // Otherwise server must've deleted it.

    if (retval == OLE_ERROR_SETDATA_FORMAT) {
        if (!FreeGDIdata (hnew, format))
            GlobalFree (hnew);
    }


errRtn:
    if (retval == OLE_OK && fRelease) {
        if (hPoke)
            GlobalFree (hPoke);
    }

    return retval;
}




OLESTATUS  INTERNAL UnAdviseData (
    LPDOC   lpdoc,
    HWND    hwndClient,
    LPARAM  lparam
){
    char      buf[MAX_STR];
    int       options;
    LPCLIENT  lpclient;
    OLESTATUS retval  = OLE_ERROR_MEMORY;
    HANDLE    hclinfo = NULL;
    PCLINFO   pclinfo = NULL;

    UNREFERENCED_PARAMETER(hwndClient);

    if (!(HIWORD (lparam)))
        buf[0] = '\0';
    else
        if (!GlobalGetAtomName ((ATOM)(HIWORD (lparam)), (LPSTR)buf, MAX_STR))
            return OLE_ERROR_BLANK;

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    if (buf[0] == '\0') {
        // Unadvise for null should terminate all the advises
        DeleteFromItemsList (lpdoc->hwnd, hwndClient);
        return OLE_OK;
    }

    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;


    // Find the client structure to be attcahed to the object.
    if ((hclinfo = FindClient (lpclient->hwnd, hwndClient)) == NULL ||
        (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL ){
            retval = OLE_ERROR_MEMORY;
            goto errRtn;
    }

    pclinfo->options &= (~(0x0001 << options));

errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);
    return retval;

}



// AdviseStdItems: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseStdItems (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam,
    BOOL FAR *  lpfack
){
    HANDLE          hopt   = GET_WM_DDE_ADVISE_HOPTIONS((WPARAM)NULL,lparam);
    ATOM            aItem  = GET_WM_DDE_ADVISE_ITEM((WPARAM)NULL,lparam);
    DDEADVISE FAR  *lpopt;
    OLESTATUS       retval = OLE_ERROR_MEMORY;

    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errrtn;

    *lpfack = lpopt->fAckReq;
    retval = SetStdInfo (lpdoc, hwndClient, (LPSTR)"StdDocumentName",  NULL);

    if (lpopt)
        GlobalUnlock (hopt);

errrtn:

    if (retval == OLE_OK)
        // !!! make sure that we have to free the data for error case
        GlobalFree (hopt);
    return retval;
}



//AdviseData: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseData (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam,
    BOOL FAR *  lpfack
){
    HANDLE          hopt   = GET_WM_DDE_ADVISE_HOPTIONS((WPARAM)NULL,lparam);
    ATOM            aitem  = GET_WM_DDE_ADVISE_ITEM((WPARAM)NULL,lparam);
    DDEADVISE FAR   *lpopt = NULL;
    OLECLIPFORMAT   format = 0;
    char            buf[MAX_STR];
    int             options;
    LPCLIENT        lpclient;
    OLESTATUS       retval  = OLE_ERROR_MEMORY;
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;

    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    if (!aitem)
        buf[0] = '\0';
    else
    {
        if (!GlobalGetAtomName (aitem, (LPSTR)buf, MAX_STR))
        {
            retval = OLE_ERROR_BLANK;
            goto errRtn;
        }
    }

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    if (!IsFormatAvailable (lpclient, lpopt->cfFormat)){
        retval = OLE_ERROR_DATATYPE;       // this format is not supported;
        goto errRtn;
    }

    *lpfack = lpopt->fAckReq;

    // Create the client structure to be attcahed to the object.
    if (!(hclinfo = FindClient (lpclient->hwnd, hwndClient)))
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));

    if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL){
        retval = OLE_ERROR_MEMORY;
        goto errRtn;
    }

    // Remember the client window (Needed for sending DATA later on
    // when the data change message comes from the server)

    pclinfo->hwnd = hwndClient;
    if (lpopt->cfFormat == (SHORT)cfNative)
        pclinfo->bnative = TRUE;
    else
        pclinfo->format = lpopt->cfFormat;

    // Remeber the data transfer options.
    pclinfo->options |= (0x0001 << options);
    pclinfo->bdata   = !lpopt->fDeferUpd;
    LocalUnlock (hclinfo);
    pclinfo = (PCLINFO)NULL;


    // if the entry exists already, delete it.
    DeleteClient (lpclient->hwnd, hwndClient);

    // Now add this client to item client list
    // !!! This error recovery is not correct.
    if(!AddClient (lpclient->hwnd, hwndClient, hclinfo))
        goto errRtn;


errRtn:
    if (lpopt)
        GlobalUnlock (hopt);

    if (pclinfo)
        LocalUnlock (hclinfo);

    if (retval == OLE_OK) {
        // !!! make sure that we have to free the data
        GlobalFree (hopt);

    }else {
        if (hclinfo)
            LocalFree (hclinfo);
    }
    return retval;

}

BOOL INTERNAL IsFormatAvailable (
    LPCLIENT        lpclient,
    OLECLIPFORMAT   cfFormat
){
      OLECLIPFORMAT  cfNext = 0;


      do{

        cfNext = (*lpclient->lpoleobject->lpvtbl->EnumFormats)
                                (lpclient->lpoleobject, cfNext);
        if (cfNext == cfFormat)
            return TRUE;

      }while (cfNext != 0);

      return FALSE;
}

//ScanItemOptions: Scan for the item options like Close/Save etc.

OLESTATUS INTERNAL ScanItemOptions (
    LPSTR   lpbuf,
    int far *lpoptions
){
    ATOM    aModifier;

    *lpoptions = OLE_CHANGED;
    while ( *lpbuf && *lpbuf != '/')
           lpbuf++;

    // no modifier same as /change

    if (*lpbuf == '\0')
        return OLE_OK;

    *lpbuf++ = '\0';        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknow modifier
    return OLE_ERROR_SYNTAX;

}

//RequestData: Sends data in response to a DDE Request message.
// for  agiven doc and an object.

OLESTATUS INTERNAL   RequestData (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam,
    LPHANDLE    lphdde
){
    OLESTATUS   retval = OLE_OK;
    HANDLE      hdata;
    LPCLIENT    lpclient;
    char        buf[20];

    // If edit environment Send data if we can
    if ((HIWORD (lparam)) == aEditItems)
        return RequestDataStd (lparam, lphdde);

    // Get the object.
    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(HIWORD(lparam)),
                (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    retval = OLE_ERROR_DATATYPE;
    if (!IsFormatAvailable (lpclient, (OLECLIPFORMAT)(LOWORD (lparam))))
        goto errRtn;

    // Now ask the item for the given format  data

    MapToHexStr ((LPSTR)buf, hwndClient);
    SendDevInfo (lpclient, (LPSTR)buf);

    retval = (*lpclient->lpoleobject->lpvtbl->GetData) (lpclient->lpoleobject,
                (OLECLIPFORMAT)(LOWORD(lparam)), (LPHANDLE)&hdata);

    if (retval != OLE_OK)
        goto errRtn;

    if (LOWORD(lparam) == CF_METAFILEPICT)
        ChangeOwner (hdata);

    // Duplicate the DDE data
    if (MakeDDEData(hdata, (OLECLIPFORMAT)(LOWORD (lparam)), lphdde, TRUE)){
        // !!! Why do we have to duplicate the atom
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
    else
       return OLE_ERROR_MEMORY;

errRtn:
    return retval;

}

#ifdef WIN32
HANDLE INTERNAL BmDuplicate (
   HBITMAP     hold
){
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, dwSize+sizeof(BITMAP)+sizeof(DWORD))))
        return NULL;

    if (!(lpMem = (LPBYTE)GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }
    *((DWORD FAR *) lpMem) = dwSize;
    *(BITMAP FAR *) (lpMem+sizeof(DWORD)) = bm;
    lpMem += (sizeof(DWORD) + sizeof (BITMAP));
    dwSize = GetBitmapBits (hold, 0, NULL);
    retVal = GetBitmapBits (hold, dwSize, lpMem);

    GlobalUnlock (hMem);
    return hMem;


}
#endif

//MakeDDEData: Create a Global DDE data handle from the server
// app data handle.

BOOL    INTERNAL MakeDDEData (
    HANDLE        hdata,
    OLECLIPFORMAT format,
    LPHANDLE      lph,
    BOOL          fResponse
){
    DWORD       size;
    HANDLE      hdde   = NULL;
    DDEDATA FAR *lpdata= NULL;
    BOOL        bnative;
    LPSTR       lpdst;
    LPSTR       lpsrc;

    if (!hdata) {
        *lph = NULL;
        return TRUE;
    }

    if (bnative = !(format == CF_METAFILEPICT || format == CF_DIB ||
                            format == CF_BITMAP || format == CF_ENHMETAFILE))
       size = (DWORD)GlobalSize (hdata) + sizeof (DDEDATA);
    else
#ifdef WIN32HACK
    {
       if (format == CF_BITMAP)
           hdata = BmDuplicate(hdata);

           size = sizeof (HANDLE_PTR) + sizeof (DDEDATA);
    }
#else
           size = sizeof (HANDLE_PTR) + sizeof (DDEDATA);
#endif


    hdde = (HANDLE) GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, size);
    if (hdde == NULL || (lpdata = (DDEDATA FAR *) GlobalLock (hdde)) == NULL)
        goto errRtn;

    // set the data otions. Ask the client to delete
    // it always.

    lpdata->fRelease  = TRUE;  // release the data
    lpdata->cfFormat  = (WORD)format;
    lpdata->fResponse = (WORD)fResponse;

    if (!bnative) {
        // If not native, stick in the handle what the server gave us.
        
        // Com1x bug 23211: data misalignment: truncate handle to 32 bits on Win64 
        // because a) handle is only 32 bit significant; b) this was causing data misalignment 
        // error; c) we're only allocating 32 bits for it above. 
#ifdef _WIN64
        if (format == CF_METAFILEPICT)
            *(void* __unaligned*)lpdata->Value = hdata;
    	else
#endif
            *(LONG*)lpdata->Value = HandleToLong(hdata);
   	}
    else {
        // copy the native data junk here.
        lpdst = (LPSTR)lpdata->Value;
        if(!(lpsrc = (LPSTR)GlobalLock (hdata)))
            goto errRtn;

         size -= sizeof (DDEDATA);
         UtilMemCpy (lpdst, lpsrc, size);
         GlobalUnlock (hdata);
         GlobalFree (hdata);

    }

    GlobalUnlock (hdde);
    *lph = hdde;
    return TRUE;

errRtn:
    if (lpdata)
        GlobalUnlock (hdde);

    if (hdde)
        GlobalFree (hdde);

    if (bnative)
         GlobalFree (hdata);

    return FALSE;
}


// ItemCallback: Calback routine for the server to inform the
// data changes. When the change message is received, DDE data
// message is sent to each of the clients depending on the
// options.

int FAR PASCAL  ItemCallBack (
    LPOLECLIENT      lpoleclient,
    OLE_NOTIFICATION msg,        // notification message
    LPOLEOBJECT      lpoleobject
){

    LPCLIENT    lpclient;
    int         retval = OLE_OK;
    HANDLE      hdata  = NULL;
    LPSTR       lpdata = NULL;
    LPDOC       lpdoc;
    HWND        hStdWnd;

    lpclient  = (LPCLIENT)lpoleclient;
    lpdoc = (LPDOC)GetWindowLongPtr (GetParent (lpclient->hwnd), 0);

    if (msg == OLE_RENAMED) {
        if (IsFormatAvailable (lpclient, cfLink)) {

            // Get the link data.

            retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                cfLink, (LPHANDLE)&hdata);
        }
        else {
            if(IsFormatAvailable (lpclient, cfOwnerLink)) {

                // Get the link data.
                retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                    cfOwnerLink, (LPHANDLE)&hdata);
            } else
                retval = OLE_ERROR_DATATYPE;
        }

        if (retval != OLE_OK)
            goto errrtn;

        if (!(lpdata = (LPSTR)GlobalLock (hdata)))
            goto errrtn;

        if (lpdoc->aDoc) {
            GlobalDeleteAtom (lpdoc->aDoc);
            lpdoc->aDoc = (ATOM)0;
        }

        // Move the string to the beginning and still terminated by null;
        lstrcpy (lpdata, lpdata + lstrlen (lpdata) + 1);
        lpdoc->aDoc = GlobalAddAtom (lpdata);

        // Now make the DDE data block
        GlobalUnlock (hdata);
        lpdata = NULL;

        // find if any StdDocName item is present at all
        if (!(hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))))
            GlobalFree (hdata);
        else {

            // hdata is freed by Makeddedata
            if (!MakeDDEData (hdata, cfBinary, (LPHANDLE)&hddeRename,
                        FALSE)) {
                retval = OLE_ERROR_MEMORY;
                goto errrtn;
            }

            EnumProps(hStdWnd, (PROPENUMPROC)lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);
        }

        // static. Avoid this. This may not cause any problems for now.
        // if there is any better way, change it.
        hwndRename = hStdWnd;

        // Post termination for each of the doc clients.
        EnumProps(lpdoc->hwnd, (PROPENUMPROC)lpEnumForTerminate);

        lpdoc->fEmbed = FALSE;

        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpdoc->hwnd, FALSE);
        return OLE_OK;

     errrtn:
        if (lpdata)
            GlobalUnlock (hdata);

        if (hdata)
            GlobalFree (hdata);

        return retval;

    } else {

        // !!! any better way to do instead of putting in static
        // (There may not be any problems since we are not allowing
        // any messages to get thru while we are posting messages).


        if ((enummsg = msg) == OLE_SAVED)
            fAdviseSaveItem = FALSE;

        enumlpoleobject = lpoleobject;

        // Enumerate all the clients and send DDE_DATA if necessary.
        EnumProps(lpclient->hwnd, (PROPENUMPROC)lpSendDataMsg);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);

        if ((msg == OLE_SAVED) && lpdoc->fEmbed && !fAdviseSaveItem)
            return OLE_ERROR_CANT_UPDATE_CLIENT;

        return OLE_OK;
    }
}


BOOL    FAR PASCAL  EnumForTerminate (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hdata
){
    LPDOC   lpdoc;

    UNREFERENCED_PARAMETER(lpstr);

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd , 0);

    // This client is in the rename list. So, no terminate
    if(hwndRename && FindClient (hwndRename, (HWND)hdata))
        return TRUE;

    if (PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE, (WPARAM)hwnd, (LPARAM)0))
        lpdoc->termNo++;

    //DeleteClient (hwnd, (HWND)hdata);
    //lpdoc->cClients--;
    return TRUE;
}


BOOL    FAR PASCAL  SendRenameMsg (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hclinfo
){
    ATOM    aData       = (ATOM)0;
    HANDLE  hdde        = NULL;
    PCLINFO pclinfo     = NULL;
    HWND    hwndClient;
    LPARAM  lParamNew;

    UNREFERENCED_PARAMETER(lpstr);

    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errrtn;

    // Make the item atom with the options.
    aData =  DuplicateAtom (aStdDocName);
    hdde  = DuplicateData (hddeRename);

    hwndClient  = pclinfo->hwnd;
    LocalUnlock (hclinfo);

    // Post the message
    lParamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
    if (!PostMessageToClientWithBlock (hwndClient,WM_DDE_DATA,
            (WPARAM)GetParent(hwnd),lParamNew))
    {
        DDEFREE(WM_DDE_DATA,lParamNew);
        goto errrtn;
    }

    return TRUE;

errrtn:

    if (hdde)
        GlobalFree (hdde);
    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}



//SendDataMsg: Send data to the clients, if the data change options
//match the data advise options.

BOOL    FAR PASCAL  SendDataMsg (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hclinfo
){
    PCLINFO    pclinfo = NULL;
    HANDLE      hdde    = NULL;
    ATOM        aData   = (ATOM)0;
    int         retval;
    HANDLE      hdata;
    LPCLIENT    lpclient;
    LPARAM      lParamNew;


    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errRtn;

    lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

    // if the client dead, then no message
    if (!IsWindowValid(pclinfo->hwnd))
        goto errRtn;

    if (pclinfo->options & (0x0001 << enummsg)) {
        fAdviseSaveItem = TRUE;
        SendDevInfo (lpclient, lpstr);

        // send message if the client needs data for every change or
        // only for the selective ones he wants.

        // now look for the data option.
        if (pclinfo->bnative){
            // prepare native data
            if (pclinfo->bdata){

                // Wants the data with DDE_DATA message
                // Get native data from the server.

                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            cfNative, (LPHANDLE)&hdata);
                if (retval != OLE_OK)
                    goto errRtn;

                // Prepare the DDE data block.
                if(!MakeDDEData (hdata, cfNative, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }


            // Make the item atom with the options.
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            lParamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
            // Post the message
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (WPARAM)GetParent(hwnd), lParamNew))
            {
                DDEFREE(WM_DDE_DATA,lParamNew);
                goto errRtn;
            }
            hdde = NULL;
            aData = (ATOM)0;
        }

        // Now post the data for the disply format
        if (pclinfo->format){
            if (pclinfo->bdata){
                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            pclinfo->format, (LPHANDLE)&hdata);

                if (retval != OLE_OK)
                    goto errRtn;

                if (pclinfo->format == CF_METAFILEPICT)
                    ChangeOwner (hdata);
Puts("sending metafile...");
                if(!MakeDDEData (hdata, pclinfo->format, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }
            // atom is deleted. So, we need to duplicate for every post
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            lParamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
            // now post the message to the client;
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (WPARAM)GetParent(hwnd), lParamNew))
            {
                DDEFREE(WM_DDE_DATA,lParamNew);
                goto errRtn;
            }

            hdde = NULL;
            aData = (ATOM)0;

        }

    }


errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hdde)
        GlobalFree (hdde);

    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}


// IsAdviseStdItems: returns true if the item is one of the standard items
// StdDocName;
BOOL    INTERNAL IsAdviseStdItems (
    ATOM   aItem
){

    if ( aItem == aStdDocName)
        return TRUE;
    else
        return FALSE;
}

// GetStdItemIndex: returns index to Stditems in the "stdStrTable" if the item
// is one of the standard items StdHostNames, StdTargetDevice,
// StdDocDimensions, StdColorScheme

int INTERNAL GetStdItemIndex (
    ATOM  aItem
){
    char  str[MAX_STR];

    if (!aItem)
        return 0;

    if (!GlobalGetAtomName (aItem, (LPSTR) str, MAX_STR))
        return 0;

    if (!lstrcmpi (str, stdStrTable[STDTARGETDEVICE]))
        return STDTARGETDEVICE;
    else if (!lstrcmpi (str, stdStrTable[STDHOSTNAMES]))
        return STDHOSTNAMES;
    else if (!lstrcmpi (str, stdStrTable[STDDOCDIMENSIONS]))
        return STDDOCDIMENSIONS;
    else if (!lstrcmpi (str, stdStrTable[STDCOLORSCHEME]))
        return STDCOLORSCHEME;

    return 0;
}

//
// The wire representation of STDDOCDIMENSIONS is a 16-bit
// format. This means instead of 4 longs, there are
// 4 shorts. This structure is used below to pick the data
// from the wire representation.
// backward compatible is the name of the game.
//
typedef struct tagRECT16
{
  SHORT left;
  SHORT top;
  SHORT right;
  SHORT bottom;

} RECT16, *LPRECT16;

// PokeStdItems: Pokes the data for the standard items.
// For StdHostnames, StdDocDimensions and SetColorScheme the data is
// sent immediately and for the the StdTargetDeviceinfo the
// data is set in each client block and the data is sent just
// before the GetData call for rendering the right data.


OLESTATUS    INTERNAL PokeStdItems (
    LPDOC   lpdoc,
    HWND    hwndClient,
    HANDLE  hdata,
    int     index
){
    DDEDATA FAR *   lpdata = NULL;
    HANDLE          hnew   = NULL;
    LPOLESERVERDOC  lpoledoc;
    LPHOSTNAMES     lphostnames;
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    OLECLIPFORMAT   format;
    BOOL            fRelease;
    RECT            rcDoc;

    if(!(hdata && (lpdata = (DDEDATA FAR *)GlobalLock (hdata))))
        goto errRtn;

    format   = lpdata->cfFormat;
    fRelease = lpdata->fRelease;

#ifdef FIREWALSS
    ASSERT (format == cfBinary, "Format is not binary");
#endif

    // we have extracted the data successfully.
    lpoledoc = lpdoc->lpoledoc;

    if (index == STDHOSTNAMES){
        lphostnames = (LPHOSTNAMES)lpdata->Value;
        retval = (*lpoledoc->lpvtbl->SetHostNames)(lpdoc->lpoledoc,
                       (LPSTR)lphostnames->data,
                       ((LPSTR)lphostnames->data) +
                        lphostnames->documentNameOffset);
        goto end;
    }

    if (index == STDDOCDIMENSIONS){
        rcDoc.left   = 0;
        rcDoc.top    = ((LPRECT16)(lpdata->Value))->top;
        rcDoc.bottom = 0;
        rcDoc.right  = ((LPRECT16)lpdata->Value)->left;

        retval = (*lpoledoc->lpvtbl->SetDocDimensions)(lpdoc->lpoledoc,
                                            (LPRECT)&rcDoc);

        goto end;

    }

    if (index == STDCOLORSCHEME) {
        retval = (*lpoledoc->lpvtbl->SetColorScheme)(lpdoc->lpoledoc,
                                            (LPLOGPALETTE) lpdata->Value);
        goto end;
    }

    // case of the printer decvice info

    if (!(hnew = MakeItemData ((DDEPOKE FAR *)lpdata, hdata, format)))
        goto errRtn;

    // Go thru the all the items lists for this doc and replace the
    // printer device info information.
    // Free the block we duplicated.
    retval = SetStdInfo (lpdoc, hwndClient,
                (LPSTR) ULongToPtr(MAKELONG(STDTARGETDEVICE,0)),hnew);


end:
errRtn:
    if (hnew)
        // can only be global memory block
        GlobalFree (hnew);

    if (lpdata) {
        GlobalUnlock (hdata);
        if (retval == OLE_OK && fRelease)
            GlobalFree (hdata);
    }
    return retval;
}


// SetStdInfo: Sets the targetdevice info. Creates a client
// for "StdTargetDevice". This item is created only within the
// lib and it is never visible in server app. When the change
// message comes from the server app, before we ask for
// the data, we send the targetdevice info if there is
// info for the client whom we are trying to send the data
// on advise.


int INTERNAL   SetStdInfo (
    LPDOC   lpdoc,
    HWND    hwndClient,
    LPSTR   lpitemname,
    HANDLE  hdata
){
    HWND        hwnd;
    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    LPCLIENT    lpclient;
    OLESTATUS   retval   = OLE_OK;


    // first create/find the StdTargetDeviceItem.

    if ((hwnd = SearchItem (lpdoc, lpitemname))
                == NULL){
         retval = RegisterItem ((LHDOC)lpdoc, lpitemname,
                          (LPCLIENT FAR *)&lpclient, FALSE);

         if (retval != OLE_OK)
            goto errRtn;

         hwnd = lpclient->hwnd;

      }

    if(hclinfo = FindClient (hwnd, hwndClient)){
        if (pclinfo = (PCLINFO) LocalLock (hclinfo)){
            if (pclinfo->hdevInfo)
                GlobalFree (pclinfo->hdevInfo);
            pclinfo->bnewDevInfo = TRUE;
            if (hdata)
                pclinfo->hdevInfo = DuplicateData (hdata);
            else
                pclinfo->hdevInfo = NULL;
            pclinfo->hwnd = hwndClient;
            LocalUnlock (hclinfo);

            // We do not have to reset the client because we did not
            // change the handle it self.
        }
    } else {
        // Create the client structure to be attcahed to the object.
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
        if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL)
            goto errRtn;

        pclinfo->bnewDevInfo = TRUE;
        if (hdata)
            pclinfo->hdevInfo = DuplicateData (hdata);
        else
            pclinfo->hdevInfo = NULL;

        pclinfo->hwnd = hwndClient;
        LocalUnlock (hclinfo);


        // Now add this client to item client list
        // !!! This error recovery is not correct.
        if (!AddClient (hwnd, hwndClient, hclinfo))
            goto errRtn;

    }
    return OLE_OK;
errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hclinfo)
        LocalFree (hclinfo);
    return OLE_ERROR_MEMORY;
}


// SendDevInfo: Sends targetdevice info to the  the object.
// Caches the last targetdevice info sent to the object.
// If the targetdevice block is same as the one in the
// cache, then no targetdevice info is sent.
// (!!! There might be some problem here getting back
// the same global handle).

void INTERNAL    SendDevInfo (
    LPCLIENT    lpclient,
    LPSTR       lppropname
){
    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    HANDLE      hdata;
    OLESTATUS   retval;
    HWND        hwnd;
    LPDOC       lpdoc;



    lpdoc = (LPDOC)GetWindowLongPtr (GetParent (lpclient->hwnd), 0);

    // find if any StdTargetDeviceInfo item is present at all
    hwnd = SearchItem (lpdoc, (LPSTR)ULongToPtr(MAKELONG(STDTARGETDEVICE, 0)));
    if (hwnd == NULL)
        return;

    hclinfo = GetProp(hwnd, lppropname);

    // This client has not set any target device info. no need to send
    // any stdtargetdevice info
    if (hclinfo != NULL) {
        if (!(pclinfo = (PCLINFO)LocalLock (hclinfo)))
            goto end;

        // if we cached it, do not send it again.
        if ((!pclinfo->bnewDevInfo) && pclinfo->hdevInfo == lpclient->hdevInfo)
            goto end;

        pclinfo->bnewDevInfo = FALSE;
        if(!(hdata = DuplicateData (pclinfo->hdevInfo)))
            goto end;
    } else {

        // already screen
        if (!lpclient->hdevInfo)
            goto end;

        //for screen send NULL.
        hdata = NULL;
    }


    // Now send the targetdevice info
    retval = (*lpclient->lpoleobject->lpvtbl->SetTargetDevice)
                    (lpclient->lpoleobject, hdata);

    if (retval == OLE_OK) {
        if (pclinfo)
            lpclient->hdevInfo = pclinfo->hdevInfo;
        else
            lpclient->hdevInfo = NULL;

    }
    // !!! error case who frees the data?'

end:
    if (pclinfo)
        LocalUnlock (hclinfo);

    return;
}

void ChangeOwner (
    HANDLE hmfp
){
    LPMETAFILEPICT  lpmfp;

#ifdef WIN32
    UNREFERENCED_PARAMETER(hmfp);
    UNREFERENCED_PARAMETER(lpmfp);
#endif

}


HANDLE INTERNAL MakeItemData (
    DDEPOKE FAR *   lpPoke,
    HANDLE          hPoke,
    OLECLIPFORMAT   cfFormat
){
    HANDLE  hnew;
    LPSTR   lpnew;
    DWORD   dwSize;

 
    if (cfFormat == CF_ENHMETAFILE)
        return CopyEnhMetaFile (LongToHandle(*(LONG*)lpPoke->Value), NULL);

    if (cfFormat == CF_METAFILEPICT) {
#ifdef _WIN64
        return DuplicateMetaFile(*(void* _unaligned*)lpPoke->Value);
#else
        return DuplicateMetaFile (*(LPHANDLE)lpPoke->Value);
#endif
    }

    if (cfFormat == CF_BITMAP)
        return DuplicateBitmap (LongToHandle(*(LONG*)lpPoke->Value));

    if (cfFormat == CF_DIB)
        return DuplicateData (LongToHandle(*(LONG*)lpPoke->Value));

    // Now we are dealing with normal case
    if (!(dwSize = (DWORD)GlobalSize (hPoke)))
        return NULL;

    dwSize = dwSize - sizeof (DDEPOKE) + sizeof(BYTE);

    if (hnew = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, dwSize)) {
        if (lpnew = GlobalLock (hnew)) {
            UtilMemCpy (lpnew, (LPSTR) lpPoke->Value, dwSize);
            GlobalUnlock (hnew);
        }
        else {
            GlobalFree (hnew);
            hnew = NULL;
        }
    }

    return hnew;
}



HANDLE INTERNAL DuplicateMetaFile (
    HANDLE hSrcData
){
    LPMETAFILEPICT  lpSrcMfp;
    LPMETAFILEPICT  lpDstMfp = NULL;
    HANDLE          hMF = NULL;
    HANDLE          hDstMfp = NULL;

    if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
        return NULL;

    GlobalUnlock (hSrcData);

    if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
        return NULL;

    if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        goto errMfp;

    if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
        goto errMfp;

    GlobalUnlock (hDstMfp);

    *lpDstMfp = *lpSrcMfp;
    lpDstMfp->hMF = hMF;
    return hDstMfp;
errMfp:
    if (hMF)
        DeleteMetaFile (hMF);

    if (hDstMfp)
        GlobalFree (hDstMfp);

     return NULL;
}



HBITMAP INTERNAL DuplicateBitmap (
    HBITMAP     hold
){
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL))
        retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }

    return hnew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\srvr.h ===
/****************************** Module Header ******************************\
* Module Name: srvr.h
*
* PURPOSE: Private definitions file for server code
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor (../../90,91)  Original
*  curts created portable version for WIN16/32
*
\***************************************************************************/

#include "port1632.h"

#define DEFSTD_ITEM_INDEX   0
#define STDTARGETDEVICE     1
#define STDDOCDIMENSIONS    2
#define STDCOLORSCHEME      3
#define STDHOSTNAMES        4


#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")

#define SRVR_CLASS          ((LPSTR)"SrvrWndClass")
#define DOC_CLASS           ((LPSTR)"DocWndClass")
#define ITEM_CLASS          ((LPSTR)"ItemWndClass")


#define   ISATOM(a)     ((a >= 0xC000) && (a <= 0xFFFF))

#define   MAX_STR       124

#define   WW_LPTR       0       // ptr tosrvr/doc/item
#define   WW_HANDLE     WW_LPTR + sizeof(PVOID) // instance handle
#define   WW_LE         WW_HANDLE + sizeof(PVOID) // signature

#define   WC_LE         0x4c45  // LE chars

// If we running under WLO, the HIGHWORD of version number will be >= 0x0A00
#define VER_WLO     0x0A00

extern  WORD CheckPointer (LPVOID, int);

#define READ_ACCESS     0
#define WRITE_ACCESS    1

#define PROBE_READ(lp){\
        if (!CheckPointer((LPVOID)(lp), READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer((LPVOID)(lp), WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define   OLE_COMMAND       1
#define   NON_OLE_COMMAND   2


#define   WT_SRVR           0       // server window
#define   WT_DOC            1       // document window

#define   PROBE_BLOCK(lpsrvr) {             \
    if (lpsrvr->bBlock)                     \
        return OLE_ERROR_SERVER_BLOCKED;    \
}


#define   SET_MSG_STATUS(retval, status) { \
    if (retval == OLE_OK)                 \
        status |= 0x8000;                  \
    if (retval == OLE_BUSY)                \
        status |= 0x4000;                  \
}


typedef   LHSERVER         LHSRVR;
typedef   LHSERVERDOC       LHDOC;

typedef struct _QUE {       // nodes in Block/Unblock queue
    HWND        hwnd;       //***
    unsigned    msg;        //      window
    WPARAM      wParam;     //      procedure parameters
    LPARAM      lParam;     //***
    HANDLE      hqNext;     // handle to next node
	 int         wType;      // WT_SRVR || WT_DOC
} QUE;

typedef QUE NEAR *  PQUE;
typedef QUE FAR *   LPQUE;


typedef struct _SRVR { /*srvr*/     // private data
    LPOLESERVER     lpolesrvr;          // corresponding server
    char            sig[2];             // signature "SR"
    HANDLE          hsrvr;              // global handle
    ATOM            aClass;             // class atom
    ATOM            aExe;
    HWND            hwnd;               // corresponding window
    BOOL            bTerminate;         // Set if we are terminating.
    int             termNo;             // termination count
    BOOL            relLock;            // ok to release the server.
    BOOL            bnoRelease;         // Block release. call
    OLE_SERVER_USE  useFlags;           // instance usage flags
    int             cClients;           // no of clients;
    BOOL            bBlock;             // blocked if TRUE
    BOOL            bBlockedMsg;        // msg from block queue if TRUE
    HANDLE          hqHead;             // Head and tail of the blocked
    HANDLE          hqTail;             //   messages queue.

    HANDLE          hqPostHead;         // Head and tail of the blocked post msg
    HANDLE          hqPostTail;         // .
    BOOL            fAckExit;
    HWND            hwndExit;
    HANDLE          hDataExit;
} SRVR;

typedef  SRVR FAR   *LPSRVR;


LRESULT FAR  PASCAL DocWndProc (HWND, UINT, WPARAM, LPARAM);
LRESULT FAR  PASCAL ItemWndProc (HWND, UINT, WPARAM, LPARAM);
LRESULT FAR  PASCAL SrvrWndProc (HWND, UINT, WPARAM, LPARAM);
BOOL    FAR  PASCAL TerminateClients (HWND, LPSTR, HANDLE);
void                SendMsgToChildren (HWND, UINT, WPARAM, LPARAM);


OLESTATUS   INTERNAL    RequestDataStd (LPARAM, HANDLE FAR *);
BOOL        INTERNAL    ValidateSrvrClass (LPCSTR, ATOM FAR *);
ATOM        INTERNAL    GetExeAtom (LPSTR);
BOOL        INTERNAL    AddClient (HWND, HANDLE, HANDLE);
BOOL        INTERNAL    DeleteClient (HWND, HANDLE);
HANDLE      INTERNAL    FindClient (HWND, HANDLE);
BOOL        INTERNAL    MakeSrvrStr(LPSTR, int, LPSTR, HANDLE);
int         INTERNAL    RevokeAllDocs (LPSRVR);
int         INTERNAL    ReleaseSrvr (LPSRVR);
void        INTERNAL    WaitForTerminate (LPSRVR);
OLESTATUS   INTERNAL    SrvrExecute (HWND, HANDLE, HWND);
BOOL        INTERNAL    HandleInitMsg (LPSRVR, LPARAM);
BOOL        INTERNAL    QueryRelease (LPSRVR);
BOOL        INTERNAL    IsSingleServerInstance (void);


// doc stuff
typedef struct _DOC { /*doc*/       // private data
    LPOLESERVERDOC  lpoledoc;           // corresponding oledoc
    char            sig[2];             // signature "SD"
    HANDLE          hdoc;               // global handle
    ATOM            aDoc;
    HWND            hwnd;
    BOOL            bTerminate;
    int             termNo;
    int             cClients;           // no of clients;
    BOOL            fEmbed;             // TRUE if embedded document
    BOOL            fAckClose;
    HWND            hwndClose;
    HANDLE          hDataClose;
} DOC;

typedef  DOC  FAR   *LPDOC;


LPDOC       INTERNAL    FindDoc (LPSRVR, LPSTR);
int         INTERNAL    ReleaseDoc (LPDOC);
OLESTATUS   INTERNAL    DocExecute (HWND, HANDLE, HWND);
BOOL        FAR PASCAL  TerminateDocClients (HWND, LPSTR, HANDLE);
int         INTERNAL    DocShowItem (LPDOC, LPSTR, BOOL);
int         INTERNAL    DocDoVerbItem (LPDOC, LPSTR, UINT, BOOL, BOOL);


// client struct definitions.

typedef struct _CLIENT { /*doc*/    // private data
    OLECLIENT   oleClient;          // oleclient structure
    LPOLEOBJECT lpoleobject;        // corresponding oledoc
    HANDLE      hclient;            // global handle
    ATOM        aItem;              // item atom or index for some std items
    HWND        hwnd;               // item window
    HANDLE      hdevInfo;           // latest printer dev info sent
} CLIENT;

typedef  CLIENT FAR   *LPCLIENT;

typedef struct _CLINFO {  /*clInfo*/  // client transaction info
    HWND          hwnd;               // client window handle
    BOOL          bnative;            // doe sthis client require native
    OLECLIPFORMAT format;             // dusplay format
    int           options;            // transaction advise time otipns
    BOOL          bdata;              // need wdat with advise?
    HANDLE        hdevInfo;           // device info handle
    BOOL          bnewDevInfo;        // new device info
} CLINFO;

typedef  CLINFO  *PCLINFO;




BOOL    FAR PASCAL  FindItemWnd (HWND, LONG);
BOOL    FAR PASCAL  SendRenameMsg (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  EnumForTerminate (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  SendDataMsg(HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  DeleteClientInfo (HWND, LPSTR, HANDLE);
int     FAR PASCAL  ItemCallBack (LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);

int         INTERNAL    RegisterItem (LHDOC, LPSTR, LPCLIENT FAR *, BOOL);
int         INTERNAL    FindItem (LPDOC, LPSTR, LPCLIENT FAR *);
HWND        INTERNAL    SearchItem (LPDOC, LPSTR);
void        INTERNAL    DeleteFromItemsList (HWND, HWND);
void        INTERNAL    DeleteAllItems (HWND);
OLESTATUS   INTERNAL    PokeData (LPDOC, HWND, LPARAM);
HANDLE      INTERNAL    MakeItemData (DDEPOKE FAR *, HANDLE, OLECLIPFORMAT);
OLESTATUS   INTERNAL    AdviseData (LPDOC, HWND, LPARAM, BOOL FAR *);
OLESTATUS   INTERNAL    AdviseStdItems (LPDOC, HWND, LPARAM, BOOL FAR *);
OLESTATUS   INTERNAL    UnAdviseData (LPDOC, HWND, LPARAM);
OLESTATUS   INTERNAL    RequestData (LPDOC, HWND, LPARAM, HANDLE FAR *);
BOOL        INTERNAL    MakeDDEData (HANDLE, OLECLIPFORMAT, LPHANDLE, BOOL);
HANDLE      INTERNAL    MakeGlobal (LPCSTR);
OLESTATUS   INTERNAL    ScanItemOptions (LPSTR, int far *);
OLESTATUS   INTERNAL    PokeStdItems (LPDOC, HWND, HANDLE, int);
int         INTERNAL    GetStdItemIndex (ATOM);
BOOL        INTERNAL    IsAdviseStdItems (ATOM);
int         INTERNAL    SetStdInfo (LPDOC, HWND, LPSTR, HANDLE);
void        INTERNAL    SendDevInfo (LPCLIENT, LPSTR);
BOOL        INTERNAL    IsFormatAvailable (LPCLIENT, OLECLIPFORMAT);
OLESTATUS   INTERNAL    RevokeObject (LPOLECLIENT, BOOL);


BOOL        INTERNAL    AddMessage (HWND, UINT, WPARAM, LPARAM, int);

#define   ITEM_FIND          1      // find the item
#define   ITEM_DELETECLIENT  2      // delete the client from item clients
#define   ITEM_DELETE        3      // delete th item window itself
#define   ITEM_SAVED         4      // item saved

// host names data structcure
typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;


// routines in UTILS.C

void    INTERNAL    MapToHexStr (LPSTR, HANDLE);
void    INTERNAL    UtilMemCpy (LPSTR, LPCSTR, DWORD);
HANDLE  INTERNAL    DuplicateData (HANDLE);
LPSTR   INTERNAL    ScanArg(LPSTR);
LPSTR   INTERNAL    ScanBoolArg (LPSTR, BOOL FAR *);
WORD    INTERNAL    ScanCommand(LPSTR, UINT, LPSTR FAR *, ATOM FAR *);
LPSTR   INTERNAL    ScanLastBoolArg (LPSTR);
LPSTR   INTERNAL    ScanNumArg (LPSTR, LPINT);
ATOM    INTERNAL    MakeDataAtom (ATOM, int);
ATOM    INTERNAL    DuplicateAtom (ATOM);
WORD    INTERNAL    StrToInt (LPSTR);
BOOL    INTERNAL    CheckServer (LPSRVR);
BOOL    INTERNAL    CheckServerDoc (LPDOC);
BOOL    INTERNAL    PostMessageToClientWithBlock (HWND, UINT, WPARAM, LPARAM);
BOOL    INTERNAL    PostMessageToClient (HWND, UINT, WPARAM, LPARAM);
BOOL    INTERNAL    IsWindowValid (HWND);
BOOL    INTERNAL    IsOleCommand (ATOM, UINT);
BOOL    INTERNAL    UtilQueryProtocol (ATOM, LPSTR);


// routines for queueing messages and posting them
BOOL INTERNAL  UnblockPostMsgs(HWND, BOOL);
BOOL INTERNAL  BlockPostMsg (HWND, UINT, WPARAM, LPARAM);
BOOL INTERNAL  IsBlockQueueEmpty (HWND);

// routine in GIVE2GDI.ASM
HANDLE  FAR PASCAL   GiveToGDI (HANDLE);


// routine in item.c
HBITMAP INTERNAL DuplicateBitmap (HBITMAP);
HANDLE  INTERNAL DuplicateMetaFile (HANDLE);

// routines in doc.c
void    INTERNAL FreePokeData (HANDLE);
BOOL    INTERNAL FreeGDIdata (HANDLE, OLECLIPFORMAT);

// props stuff
#ifdef WIN16

#define MAKE_DDE_LPARAM(x,y,z) MAKELONG(y,z)

//#define ENUMPROPS EnumProps
//#define REMOVEPROP RemoveProp
//#define GETPROP GetProp
//#define SETPROP SetProp

#endif

#ifdef WIN32

#define MAKE_DDE_LPARAM(x,y,z) PackDDElParam((UINT)x,(UINT_PTR)y,(UINT_PTR)z)

//#define ENUMPROPS OleEnumProps
//#define REMOVEPROP OleRemoveProp
//#define GETPROP OleGetProp
//#define SETPROP OleSetProp

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\srvr.c ===
/****************************** Module Header ******************************\
* Module Name: Srvr.c Server Main module
*
* Purpose: Includes All the server communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*    Raor:   Wrote the original version.
*    curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include <reghelp.hxx>
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"
#include "strsafe.h"
// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD is reserved

#define OLE_VERSION 0x0901L


extern ATOM    aOLE;
extern ATOM    aSysTopic;
extern ATOM    aStdExit;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdShowItem;
extern ATOM    aProtocols;
extern ATOM    aTopics;
extern ATOM    aFormats;
extern ATOM    aStatus;
extern ATOM    cfNative;
extern ATOM    aEditItems;
extern ATOM    aStdClose;


extern HANDLE  hdllInst;

extern FARPROC lpTerminateClients;

DWORD APIENTRY  OleQueryServerVersion ()
{
    return OLE_VERSION;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRegisterServer (lpclass, lpolesrvr, lplhsrvr)
*
* OleRegisterServer: Registers the server with the server library.
*
* Parameters:
*       1. Ptr to the server class.
*       2. Ptr to the olesrvr. This is private to the server app.
*          (Typically this is the ptr to the private storage area of
*           server app server related info).
*       3. Ptr to the LHSRVR. Place where to pass back the long
*          handle of the server in DLL (This is private to the DLL).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS APIENTRY  OleRegisterServer (
    LPCSTR          lpclass,            // class name
    LPOLESERVER     lpolesrvr,          // ole srvr(private to srvr app)
    LHSRVR FAR *    lplhsrvr,           // where we pass back our private handle
    HINSTANCE       hInst,
    OLE_SERVER_USE  useFlags
){
    HANDLE  hsrvr  = NULL;
    LPSRVR  lpsrvr = NULL;
    ATOM    aExe = (ATOM)0;

    Puts ("OleRegisterServer");

    PROBE_READ(lpclass);
    PROBE_WRITE(lpolesrvr);
    PROBE_WRITE(lplhsrvr);

    // add the app atom to global list
    if (!ValidateSrvrClass (lpclass, &aExe))
        return OLE_ERROR_CLASS;

    hsrvr = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (SRVR));
    if (! (hsrvr && (lpsrvr = (LPSRVR)GlobalLock (hsrvr))))
        goto errReturn;

    // set the signature handle and the app atom.
    lpsrvr->sig[0]      = 'S';
    lpsrvr->sig[1]      = 'R';
    lpsrvr->hsrvr       = hsrvr;
    lpsrvr->aClass      = GlobalAddAtom (lpclass);
    lpsrvr->lpolesrvr   = lpolesrvr;
    lpsrvr->relLock     = TRUE;     // set the release lock.
    lpsrvr->aExe        = aExe;
    lpsrvr->useFlags    = useFlags;

    // Create the servre window and do not show it.
    if (!(lpsrvr->hwnd = CreateWindow ("SrvrWndClass", "Srvr",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the srever struct in the window.
    SetWindowLongPtr (lpsrvr->hwnd, 0, (LONG_PTR)lpsrvr);

    // Set the signature.
    SetWindowWord (lpsrvr->hwnd, WW_LE, WC_LE);
    SetWindowLongPtr (lpsrvr->hwnd, WW_HANDLE, (LONG_PTR)hInst);
    *lplhsrvr = (LONG_PTR)lpsrvr;

    return OLE_OK;

errReturn:
    if (lpsrvr){
        if (lpsrvr->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpsrvr->aClass)
            GlobalDeleteAtom (lpsrvr->aClass);

        if (lpsrvr->aExe)
            GlobalDeleteAtom (lpsrvr->aExe);

        GlobalUnlock (hsrvr);
    }

    if (hsrvr)
        GlobalFree (hsrvr);

    return OLE_ERROR_MEMORY;

}


// ValidateSrvrClass checks whether the given server class is valid by
// looking in the win.ini.

BOOL INTERNAL ValidateSrvrClass (
    LPCSTR      lpclass,
    ATOM FAR *  lpAtom
){
    char    buf[MAX_STR];
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    LPSTR   lptmp;
    LPSTR   lpbuf;
    char    ch;

    if (FAILED(StringCchCopy(key, sizeof(key)/sizeof(key[0]), lpclass)))
        return FALSE;
    if (FAILED(StringCchCat(key, sizeof(key)/sizeof(key[0]), "\\protocol\\StdFileEditing\\server")))
        return FALSE;

    if (QueryClassesRootValueA (key, buf, &cb))
        return FALSE;

    if (!buf[0])
        return FALSE;

    // Get exe name without path and then get an atom for that

    lptmp = lpbuf = (LPSTR)buf;
    while ((ch = *lptmp++) && ch != '\0') {
        if (ch == '\\' || ch == ':')
            lpbuf = lptmp;
    }
    *lpAtom =  GlobalAddAtom (lpbuf);

    return TRUE;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServer (lhsrvr)
*
* OlerevokeServer: Unregisters the server which has been registered.
*
* Parameters:
*       1. DLL server handle.
*
*
* return values:
*        returns OLE_OK if the server is successfully unregisterd.
*        ( It is Ok for the app free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Server class release entry point when the server
*        can be released.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS APIENTRY  OleRevokeServer (
    LHSRVR  lhsrvr
){
    HWND         hwndSrvr;
    LPSRVR       lpsrvr;

    Puts ("OleRevokeServer");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    if (lpsrvr->bTerminate  && lpsrvr->termNo)
        return OLE_WAIT_FOR_RELEASE;

    hwndSrvr = lpsrvr->hwnd;

    // Terminate the conversation with all clients.
    // If there are any clients to be terminated
    // return back with OLE_STARTED and srvr relase
    // will be called for releasing the server finally.

    // we are terminating.
    lpsrvr->bTerminate  = TRUE;
    lpsrvr->termNo      = 0;

    // send ack if Revoke is done as a result of StdExit
    if (lpsrvr->fAckExit) {
        LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK, 0x8000, lpsrvr->hDataExit);

        // Post the acknowledge to the client
        if (!PostMessageToClient (lpsrvr->hwndExit, WM_DDE_ACK, (WPARAM)lpsrvr->hwnd,
                            lparamNew))
        {
            // if the window died or post failed, delete the atom.
            GlobalFree (lpsrvr->hDataExit);
            DDEFREE(WM_DDE_ACK,lparamNew);
        }
    }

    // revoks all the documents registered with this server.
    RevokeAllDocs (lpsrvr);

    // enumerate all the clients which are in your list and post the
    // termination.
    EnumProps (hwndSrvr, (PROPENUMPROC)lpTerminateClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndSrvr, TRUE);

    // reset the release lock. Now it is ok to release the server
    // when all the doc clients and server clients have sent back the
    // termination.

    lpsrvr->relLock = FALSE;
    return ReleaseSrvr (lpsrvr);

}


// ReleaseSrvr: Called when ever a matching WM_TERMINATE is received
// from doc clients or the server clients of a particular server.
// If there are no more terminates pending, it is ok to release the server.
// Calls the server app "release" proc for releasing the server.

int INTERNAL    ReleaseSrvr (
    LPSRVR      lpsrvr
){

    HANDLE  hsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT

    if (lpsrvr->bTerminate){
        // only if we are  revoking server then see whether it is ok to
        // call Release.

        // First check whethere any docs are active.
        // Doc window is a child window for server window.

        if (lpsrvr->termNo || GetWindow (lpsrvr->hwnd, GW_CHILD))
            return OLE_WAIT_FOR_RELEASE;

        // if the block queue is not empty, do not quit
        if (!IsBlockQueueEmpty(lpsrvr->hwnd))
            return OLE_WAIT_FOR_RELEASE;

    }

    if (lpsrvr->relLock)
        return OLE_WAIT_FOR_RELEASE;  // server is locked. So, delay releasing

    // Inform server app it is time to clean up and post WM_QUIT.

    (*lpsrvr->lpolesrvr->lpvtbl->Release)(lpsrvr->lpolesrvr);

    if (lpsrvr->aClass)
        GlobalDeleteAtom (lpsrvr->aClass);
    if (lpsrvr->aExe)
        GlobalDeleteAtom (lpsrvr->aExe);
    DestroyWindow (lpsrvr->hwnd);
    GlobalUnlock (hsrvr = lpsrvr->hsrvr);
    GlobalFree (hsrvr);
    return OLE_OK;
}


//TerminateClients: Call back for the enum properties.

BOOL    FAR PASCAL  TerminateClients (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hdata
){
    LPSRVR  lpsrvr;

    UNREFERENCED_PARAMETER(lpstr);

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

    // If the client already died, no terminate.
    if (IsWindowValid ((HWND)hdata)) {
        lpsrvr->termNo++;

        // irrespective of the post, incremet the count, so
        // that client does not die.

        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  (WPARAM)hwnd, (LPARAM)0);
    }
    else
        ASSERT (FALSE, "TERMINATE: Client's System chanel is missing");

    return TRUE;
}


LRESULT FAR PASCAL SrvrWndProc (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
){

    LPSRVR      lpsrvr;
    WORD        status = 0;
    HANDLE      hdata;
    OLESTATUS   retval;

    if (AddMessage (hwnd, msg, wParam, lParam, WT_SRVR))
        return 0L;

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);


    switch (msg){

       case  WM_TIMER:
            UnblockPostMsgs (hwnd, FALSE);

            // if no more blocked message empty the queue.
            if (IsBlockQueueEmpty (hwnd))
                KillTimer (hwnd, wParam);

            if (lpsrvr->bTerminate && IsBlockQueueEmpty(lpsrvr->hwnd))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);
            break;

       case WM_CREATE:
            DEBUG_OUT ("Srvr create window", 0)
            break;

       case WM_DDE_INITIATE:
            DEBUG_OUT ("Srvr: DDE init",0);
            if (lpsrvr->bTerminate){
                DEBUG_OUT ("Srvr: No action due to termination process",0)
                break;
            }

            // class is not matching, so it is not definitely for us.
            // for apps sending the EXE for initiate, do not allow if the app
            // is mutiple server.

            if (!(lpsrvr->aClass == (ATOM)(LOWORD(lParam)) ||
                  (lpsrvr->aExe == (ATOM)(LOWORD(lParam)) && IsSingleServerInstance ())))

                break;

            if (!HandleInitMsg (lpsrvr, lParam)) {
                if (!(aSysTopic == (ATOM)(HIWORD(lParam)))) {

                    // if the server window is not the right window for
                    // DDE conversation, then try with the doc windows.
                    SendMsgToChildren (hwnd, msg, wParam, lParam);

                }
                break;
            }

            // We can enterain this client. Put him in our client list
            // and acknowledge the intiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpsrvr->cClients++;
            lpsrvr->bnoRelease = FALSE;
            // add the atoms and post acknowledge

            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));

            SendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);
            break;

       case WM_DDE_EXECUTE: {
            HANDLE hData = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);

            DEBUG_OUT ("srvr: execute", 0)

            // Are we terminating
            if (lpsrvr->bTerminate) {
                DEBUG_OUT ("Srvr: sys execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (hData);
                break;
            }


            retval = SrvrExecute (hwnd, hData, (HWND)wParam);
            SET_MSG_STATUS (retval, status)

            if (!lpsrvr->bTerminate) {
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,hData);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew))
                {
                    GlobalFree (hData);
                    DDEFREE(WM_DDE_ACK,lparamNew);
                }
            }

            break;
       }

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("Srvr: DDE terminate",0)

            DeleteClient (lpsrvr->hwnd, (HWND)wParam);
            lpsrvr->cClients--;

            if (lpsrvr->bTerminate){
                if ((--lpsrvr->termNo == 0) && (IsBlockQueueEmpty (lpsrvr->hwnd)))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);

                    // if we released the server, then
                    // by the time we come here,, we have destroyed the window

            }else {
                // If client intiated the terminate. post matching terminate
                PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)hwnd, (LPARAM)0);

                // callback release tell the srvr app, it can exit if needs.
                // Inform server app it is time to clean up and post WM_QUIT.
                // only if no docs present.
#if 0
                if (lpsrvr->cClients == 0
                        && (GetWindow (lpsrvr->hwnd, GW_CHILD) == NULL)) {
#endif
                if (QueryRelease (lpsrvr)){

                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }
            }
            break;


       case WM_DDE_REQUEST: {
            ATOM aItem = GET_WM_DDE_REQUEST_ITEM(wParam,lParam);

            if (lpsrvr->bTerminate || !IsWindowValid ((HWND) wParam))
                goto RequestErr;

            if(RequestDataStd (lParam, (HANDLE FAR *)&hdata) != OLE_OK){
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,0x8000, aItem);

                // if request failed, then acknowledge with error.
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd,lparamNew))
                {
                  DDEFREE(WM_DDE_ACK,lparamNew);
RequestErr:
                  if (aItem)
                      GlobalDeleteAtom (aItem);
                }
            } else {  // post the data message and we are not asking for any
                      // acknowledge.
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_REQUEST,hdata,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, (WPARAM)hwnd, lparamNew)) {
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_REQUEST,lparamNew);
                    goto RequestErr;
                }
            }
            break;
       }

       case WM_DESTROY:
            DEBUG_OUT ("Srvr: Destroy window",0)
            break;

       default:
            DEBUG_OUT ("Srvr:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

BOOL    INTERNAL    HandleInitMsg (
    LPSRVR  lpsrvr,
    LPARAM  lParam
){


    // If it is not system or Ole, this is not the server.
    if (!((aSysTopic == (ATOM)(HIWORD(lParam))) ||
            (aOLE == (ATOM)(HIWORD(lParam)))))

        return FALSE;


    // single instance MDI accept
    if (lpsrvr->useFlags == OLE_SERVER_SINGLE)
        return TRUE;


    // this server is multiple instance. So, check for any clients or docs.
    if (!GetWindow (lpsrvr->hwnd, GW_CHILD) && !lpsrvr->cClients)
        return TRUE;

    return FALSE;

}


// AddClient: Adds the client as property to the server
// window. Key is the string generated from the window
// handle and the data is the window itself.


BOOL    INTERNAL AddClient  (
    HWND    hwnd,
    HANDLE  hkey,
    HANDLE  hdata
){
    char    buf[20];

    MapToHexStr ((LPSTR)buf, hkey);
    return SetProp (hwnd, (LPSTR)buf, hdata);

}


//DeleteClient: deletes the client from the server clients list.

BOOL    INTERNAL DeleteClient (
    HWND    hwnd,
    HANDLE  hkey
){
    char    buf[20];

    MapToHexStr ((LPSTR)buf, hkey);
    return (RemoveProp(hwnd, (LPSTR)buf)!= NULL);
}

// FindClient: Finds  whether a given client is
// in the server client list.

HANDLE  INTERNAL FindClient (
    HWND    hwnd,
    HANDLE  hkey
){

    char    buf[20];


    MapToHexStr ((LPSTR)buf, hkey);
    return GetProp (hwnd, (LPSTR)buf);
}



// SrvrExecute: takes care of the WM_DDE_EXEXCUTE for the
// server.


OLESTATUS INTERNAL SrvrExecute (
    HWND      hwnd,
    HANDLE    hdata,
    HWND      hwndClient
){
    ATOM      aCmd;
    BOOL      fActivate;

    LPSTR     lpdata = NULL;
    HANDLE    hdup   = NULL;
    OLESTATUS retval = OLE_ERROR_MEMORY;

    LPSTR     lpdocname;
    LPSTR     lptemplate;

    LPOLESERVERDOC  lpoledoc = NULL;
    LPDOC           lpdoc    = NULL;
    LPSRVR          lpsrvr;
    LPOLESERVER     lpolesrvr;
    LPSTR           lpnextarg;
    LPSTR           lpclassname;
    LPSTR           lpitemname;
    LPSTR           lpopt;
    char            buf[MAX_STR];
    WORD            wCmdType;

    // !!! this code can be lot simplified if we do the argument scanning
    // seperately and return the ptrs to the args. Rewrite later on.

    if (!(hdup = DuplicateData (hdata)))
        goto errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto errRtn;

    DEBUG_OUT (lpdata, 0)

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

    lpolesrvr = lpsrvr->lpolesrvr;

    if (*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    retval = OLE_ERROR_SYNTAX;
    // scan upto the first arg
    if (!(wCmdType = ScanCommand (lpdata, WT_SRVR, &lpdocname, &aCmd)))
        goto  errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
            retval = OLE_ERROR_PROTOCOL;
        else {
            retval =  (*lpolesrvr->lpvtbl->Execute) (lpolesrvr, hdata);
        }

        goto errRtn1;
    }

    if (aCmd == aStdExit){
        if (*lpdocname)
            goto errRtn1;

        lpsrvr->fAckExit  = TRUE;
        lpsrvr->hwndExit  = hwndClient;
        lpsrvr->hDataExit = hdata;
        retval = (*lpolesrvr->lpvtbl->Exit) (lpolesrvr);
        lpsrvr->fAckExit = FALSE;
        goto end2;
    }

    // scan the next argument.
    if (!(lpnextarg = ScanArg(lpdocname)))
        goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("docname", "itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdShowItem) {

        // first find the documnet. If the doc does not exist, then
        // blow it off.

        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        lpitemname = lpnextarg;

        if( !(lpopt = ScanArg(lpitemname)))
            goto errRtn1;

        // scan for the optional parameter
        // Optional can be only TRUE or FALSE.

        fActivate = FALSE;
        if (*lpopt) {

            if( !(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
                goto errRtn1;

            if (*lpnextarg)
                goto errRtn1;

        }


        // scan it. But, igonre the arg.
        retval = DocShowItem (lpdoc, lpitemname, !fActivate);
        goto end2;



    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdClose) {
        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        if (*lpnextarg)
            goto errRtn1;

        retval = (*lpdoc->lpoledoc->lpvtbl->Close)(lpdoc->lpoledoc);
        goto end2;
    }


    if (aCmd == aStdOpen) {
        // find if any document is already open.
        // if the doc is open, then no need to call srvr app.
        if (FindDoc (lpsrvr, lpdocname)){
            retval = OLE_OK;
            goto end1;

        }
    }

    if (aCmd == aStdCreate || aCmd == aStdCreateFromTemplate) {
        lpclassname = lpdocname;
        lpdocname   = lpnextarg;
        if( !(lpnextarg = ScanArg(lpdocname)))
            goto errRtn1;

    }

    // check whether we can create/open more than one doc.

    if ((lpsrvr->useFlags == OLE_SERVER_MULTI) &&
            GetWindow (lpsrvr->hwnd, GW_CHILD))
            goto errRtn;



    // No Doc. register the document. lpoledoc is being probed
    // for validity. So, pass some writeable ptr. It is not
    // being used to access anything yet

    if (OleRegisterServerDoc ((LHSRVR)lpsrvr, lpdocname,
        (LPOLESERVERDOC)NULL, (LHDOC FAR *)&lpdoc))
            goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdOpenDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    // Documnet does not exit.

    if(aCmd == aStdOpen) {

        retval = (*lpolesrvr->lpvtbl->Open)(lpolesrvr, (LHDOC)lpdoc,
                lpdocname, (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }
    else {
        lpdoc->fEmbed = TRUE;
    }



    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewDocument ("classname", "docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreate) {
        retval =  (*lpolesrvr->lpvtbl->Create) (lpolesrvr, (LHDOC)lpdoc,
                                    lpclassname, lpdocname,
                                    (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdEditDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////
    if (aCmd == aStdEdit){

        GlobalGetAtomName (lpsrvr->aClass, (LPSTR)buf, MAX_STR);

        retval = (*lpolesrvr->lpvtbl->Edit) (lpolesrvr, (LHDOC)lpdoc,
                                (LPSTR)buf, lpdocname,
                                (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewFormTemplate ("classname", "docname". "templatename)]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreateFromTemplate){
        lptemplate = lpnextarg;
        if(!(lpnextarg = ScanArg(lpnextarg)))
            goto errRtn;

        retval = (*lpolesrvr->lpvtbl->CreateFromTemplate)(lpolesrvr,
             (LHDOC)lpdoc, lpclassname, lpdocname, lptemplate,
             (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;

    }


    DEBUG_OUT ("Unknown command", 0);

end:

    if (retval != OLE_OK)
        goto errRtn;

    // Successful execute. remember the server app private doc handle here.

    lpdoc->lpoledoc = lpoledoc;

end1:
    // make sure that the srg string is indeed terminated by
    // NULL.
    if (*lpnextarg)
        retval = OLE_ERROR_SYNTAX;

errRtn:

   if ( retval != OLE_OK){
        // delete the oledoc structure
        if (lpdoc)
            OleRevokeServerDoc ((LHDOC)lpdoc);
   }

end2:
errRtn1:

   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   if (retval == OLE_OK)
        lpsrvr->bnoRelease = TRUE;

   return retval;
}




void SendMsgToChildren (
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
){

    hwnd = GetWindow(hwnd, GW_CHILD);
    while (hwnd) {
        SendMessage (hwnd, msg, wParam, lParam);
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
}


OLESTATUS INTERNAL   RequestDataStd (
    LPARAM      lparam,
    LPHANDLE    lphdde
){

    char    buf[MAX_STR];
    ATOM    item;
    HANDLE  hnew = NULL;

    if (!(item =  (ATOM)(HIWORD (lparam))))
        goto errRtn;

    GlobalGetAtomName (item, (LPSTR)buf, MAX_STR);

    if (item == aEditItems){
        hnew = MakeGlobal ((LPSTR)"StdHostNames\tStdDocDimensions\tStdTargetDevice");
        goto   PostData;

    }

    if (item == aProtocols) {
        hnew = MakeGlobal ((LPSTR)"Embedding\tStdFileEditing");
        goto   PostData;
    }

    if (item == aTopics) {
        hnew = MakeGlobal ((LPSTR)"Doc");
        goto   PostData;
    }

    if (item == aFormats) {
        hnew = MakeGlobal ((LPSTR)"Picture\tBitmap");
        goto   PostData;
    }

    if (item == aStatus) {
        hnew = MakeGlobal ((LPSTR)"Ready");
        goto   PostData;
    }

    // format we do not understand.
    goto errRtn;

PostData:

    // Duplicate the DDE data
    if (MakeDDEData (hnew, CF_TEXT, lphdde, TRUE)){
        // !!! why are we duplicating the atom.
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
errRtn:
    return OLE_ERROR_MEMORY;
}


BOOL INTERNAL QueryRelease (
    LPSRVR  lpsrvr
){

    HWND    hwnd;
    LPDOC   lpdoc;


    // Incase the terminate is called immediately after
    // the Std at sys level clear this.

    if (lpsrvr->bnoRelease) {
        lpsrvr->bnoRelease = FALSE;
        return FALSE;
    }


    if (lpsrvr->cClients)
        return FALSE;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // if either the server or the doc has any clients
    // return FALSE;

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);
        if (lpdoc->cClients)
            return FALSE;

        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return TRUE;

}


//IsSingleServerInstance: returns true if the app is single server app else
//false.

BOOL    INTERNAL  IsSingleServerInstance ()
{
    HWND    hwnd;
    WORD    cnt = 0;
    HANDLE  hTask;
    char    buf[MAX_STR] = "";

    hwnd  = GetWindow (GetDesktopWindow(), GW_CHILD);
    hTask = (HANDLE)ULongToPtr(GetCurrentThreadId());

    while (hwnd) 
    {
        if (hTask == GetWindowTask (hwnd)) 
        {
            if (GetClassName (hwnd, (LPSTR)buf, MAX_STR)) 
            {
                if (lstrcmp ((LPSTR)buf, SRVR_CLASS) == 0)
	                cnt++;
            }
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }

    if (cnt == 1)
        return TRUE;
    else
        return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\doc.c ===
/****************************** Module Header ******************************\
* Module Name: Doc.c Document Main module
*
* Purpose: Includes All the document communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/

#include "windows.h"
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"


extern  ATOM     cfBinary;
extern  ATOM     aStdClose;
extern  ATOM     aStdShowItem;
extern  ATOM     aStdDoVerbItem;
extern  ATOM     aStdDocName;
extern  ATOM     aTrue;
extern  ATOM     aFalse;

extern  FARPROC  lpTerminateDocClients;
extern  FARPROC  lpSendRenameMsg;
extern  FARPROC  lpFindItemWnd;
extern  FARPROC  lpEnumForTerminate;

extern  HANDLE   hdllInst;
extern  HANDLE   hddeRename;
extern  HWND     hwndRename;


extern  BOOL     fAdviseSaveDoc;

// ### Do we have to create a seperate window for each doc conversation.
// EDF thinks so.

/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL  OleRegisterServerDoc (lhsrvr, lpdocname, lpoledoc, lplhdoc)
*
* OleRegisterServerDoc: Registers the Document with the server lib.
*
* Parameters:
*       1. Server long handle(server with which the document should
*          be registered)
*       2. Document name.
*       3. Handle to the doc of the server app (private to the server app).
*       4. Ptr for returning the Doc handle of the lib (private to the lib).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRegisterServerDoc (
    LHSRVR          lhsrvr,    // handle we passed back as part of registration.
    LPCSTR          lpdocname, // document name
    LPOLESERVERDOC  lpoledoc,  // Private doc handle of the server app.
    LHDOC FAR *     lplhdoc    // where we will be passing our doc private handle
){

    LPSRVR  lpsrvr = NULL;
    LPDOC   lpdoc  = NULL;
    HANDLE  hdoc   = NULL;


    Puts ("OleRegisterServerDoc");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    // server's termination has already started.
    if (lpsrvr->bTerminate)
        return OLE_ERROR_TERMINATE;

    PROBE_READ(lpdocname);
    PROBE_WRITE(lplhdoc);

    // we are using the null from inside the server lib
    if (lpoledoc)
        PROBE_WRITE(lpoledoc);

    hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (DOC));

    if (!(hdoc && (lpdoc = (LPDOC)GlobalLock (hdoc))))
        goto errReturn;

    // set the signature, handle and the doc atom.
    lpdoc->sig[0]   = 'S';
    lpdoc->sig[1]   = 'D';
    lpdoc->hdoc     = hdoc;
    lpdoc->aDoc     = GlobalAddAtom (lpdocname);
    lpdoc->lpoledoc = lpoledoc;


    if (!(lpdoc->hwnd = CreateWindow ("DocWndClass", "Doc",
        WS_CHILD,0,0,0,0,lpsrvr->hwnd,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the struct in the window.
    SetWindowLongPtr (lpdoc->hwnd, 0, (LONG_PTR)lpdoc);
    SetWindowWord (lpdoc->hwnd, WW_LE, WC_LE);
    SetWindowLongPtr (lpdoc->hwnd, WW_HANDLE, GetWindowLongPtr(lpsrvr->hwnd, WW_HANDLE));
    *lplhdoc = (LONG_PTR)lpdoc;

    return OLE_OK;

errReturn:
    if (lpdoc){
        if (lpdoc->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpdoc->aDoc)
            GlobalDeleteAtom (lpdoc->aDoc);

        GlobalUnlock(hdoc);
    }

    if (hdoc)
        GlobalFree (hdoc);

    return OLE_ERROR_MEMORY;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServerDoc (lhdoc)
*
* OleRevokeServerDoc: Unregisters the document which has been registered.
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the document is successfully unregisterd.
*        ( It is Ok for the app to free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Doc class release entry point when the doc
*        can be released. App should wait till the Release is called
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS  FAR PASCAL  OleRevokeServerDoc (
    LHDOC   lhdoc
){
    HWND    hwndSrvr;
    LPSRVR  lpsrvr;
    HWND    hwndDoc;
    LPDOC   lpdoc;

    Puts ("OleRevokeServerDoc");

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // ### this code is very similar to the srvr code.
    // we should optimize.

    hwndDoc = lpdoc->hwnd;

    hwndSrvr = GetParent (hwndDoc);
    lpsrvr = (LPSRVR) GetWindowLongPtr (hwndSrvr, 0);
    // delete all the items(objects) for this doc
    DeleteAllItems (lpdoc->hwnd);

    // we are terminating.
    lpdoc->bTerminate = TRUE;
    lpdoc->termNo = 0;

    // send ack if Revoke is done as a result of StdClose
    if (lpdoc->fAckClose) {  // Post the acknowledge to the client
        LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK, 0x8000, lpdoc->hDataClose);

        if (!PostMessageToClient (lpdoc->hwndClose, WM_DDE_ACK, (WPARAM)lpdoc->hwnd,lparamNew))
        {
            // if the window died or post failed, delete the atom.
            GlobalFree (lpdoc->hDataClose);
            DDEFREE(WM_DDE_ACK,lparamNew);
        }
    }

    // Post termination for each of the doc clients.
    EnumProps(hwndDoc, (PROPENUMPROC)lpTerminateDocClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndDoc, TRUE);

#ifdef  WAIT_DDE
    if (lpdoc->termNo)
        WaitForTerminate((LPSRVR)lpdoc);
#endif

    return ReleaseDoc (lpdoc);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRenameServerDoc (lhdoc, lpNewName)
*
* OleRenameServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*       2. New name for document
*
* return values:
*        returns OLE_OK if the document is successfully renamed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRenameServerDoc (
    LHDOC   lhdoc,
    LPCSTR  lpNewName
){
    LPDOC       lpdoc;
    OLESTATUS   retVal = OLE_OK;
    HANDLE      hdata;
    HWND        hStdWnd;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpNewName);

    if (!(hdata = MakeGlobal (lpNewName)))
        return OLE_ERROR_MEMORY;

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = GlobalAddAtom (lpNewName);

    // if StdDocName item is present send rename to relevant clients
    if (hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))) {
        if (!MakeDDEData (hdata, cfBinary, (LPHANDLE)&hddeRename,FALSE))
            retVal = OLE_ERROR_MEMORY;
        else {
            EnumProps(hStdWnd, (PROPENUMPROC)lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);

        }
    }


    hwndRename = hStdWnd;
    // Post termination for each of the doc clients.
    EnumProps(lpdoc->hwnd, (PROPENUMPROC)lpEnumForTerminate);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (lpdoc->hwnd, TRUE);

    // If it was an embedded object, from now on it won't be
    lpdoc->fEmbed = FALSE;

    if (!hStdWnd || retVal != OLE_OK)
        GlobalFree(hdata);

    // Do link manager stuff
    return retVal;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleSavedServerDoc (lhdoc)
*
* OleSavedServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager is successfully notified
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleSavedServerDoc (
    LHDOC   lhdoc
){
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    fAdviseSaveDoc = TRUE;
    EnumChildWindows (lpdoc->hwnd, (WNDENUMPROC)lpFindItemWnd,
        MAKELONG (NULL, ITEM_SAVED));

    if (lpdoc->fEmbed && !fAdviseSaveDoc)
        return OLE_ERROR_CANT_UPDATE_CLIENT;

    return OLE_OK;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevertServerDoc (lhdoc)
*
* OleRevertServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager has been successfully informed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRevertServerDoc (
    LHDOC   lhdoc
){
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}



// TerminateDocClients: Call back for the document window for
// enumerating all the clients. Posts terminate for each of
// the clients.

BOOL    FAR PASCAL  TerminateDocClients (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hdata
){
    LPDOC   lpdoc;

    UNREFERENCED_PARAMETER(lpstr);

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);
    if (IsWindowValid ((HWND)hdata)){
        lpdoc->termNo++;
        // irrespective of the post, incremet the count, so
        // that client does not die.
        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  (WPARAM)hwnd, (LPARAM)0);
    }
    else
        ASSERT(FALSE, "TERMINATE: Client's Doc channel is missing");
    return TRUE;
}


// ReleaseDoc: If there are no more matching terminates pending
// Call the server for its release. (Server might be waiting for the
// docs to be terminated. Called thru OleRevokeServer).


int INTERNAL    ReleaseDoc (
    LPDOC      lpdoc
){
    HWND        hwndSrvr;
    HANDLE      hdoc;
    LPSRVR      lpsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT.

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // Call Release for the app to release its space.


    if (lpdoc->lpoledoc){

        (*lpdoc->lpoledoc->lpvtbl->Release) (lpdoc->lpoledoc);

    }

    if (lpdoc->aDoc) {
        GlobalDeleteAtom (lpdoc->aDoc);
        lpdoc->aDoc = (ATOM)0;
    }

    hwndSrvr = GetParent (lpdoc->hwnd);
    DestroyWindow (lpdoc->hwnd);

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwndSrvr, 0);

    // if the server is waiting for us, inform the server
    // we are done
    if (!lpsrvr->bTerminate) {
        // if we are not in terminate mode, then send advise to the server
        // if server can be revoked. raor (04/09)

        if (QueryRelease (lpsrvr)){

            (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
        }

    } else
        ReleaseSrvr (lpsrvr);

    GlobalUnlock (hdoc = lpdoc->hdoc);
    GlobalFree (hdoc);

    return OLE_OK;
}


//RevokeAllDocs : revokes all the documents attached to a given
//server.

int INTERNAL RevokeAllDocs (
    LPSRVR  lpsrvr
){

    HWND    hwnd;
    HWND    hwndnext;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // Go thru each of the child windows and revoke the corresponding
    // document. Doc windows are child windows for the server window.

    while (hwnd){
        // sequence is important
        hwndnext = GetWindow (hwnd, GW_HWNDNEXT);
        OleRevokeServerDoc ((LHDOC)GetWindowLongPtr (hwnd, 0));
        hwnd =  hwndnext;
    }
    return OLE_OK;
}



// FindDoc: Given a document, searches for the document
// in the given server document tree. returns true if the
// document is available.


LPDOC INTERNAL FindDoc (
    LPSRVR  lpsrvr,
    LPSTR   lpdocname
){
    ATOM    aDoc;
    HWND    hwnd;
    LPDOC   lpdoc;

    aDoc = (ATOM)GlobalFindAtom (lpdocname);
    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);
        if (lpdoc->aDoc == aDoc)
            return lpdoc;
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return NULL;
}



// DocWndProc: document window procedure.
// ### We might be able to merge this code with
// the server window proc.


LRESULT FAR PASCAL DocWndProc (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
){
    LPDOC       lpdoc;
    WORD        status = 0;
    BOOL	fack;
    HANDLE      hdata  = NULL;
    OLESTATUS   retval;
    LPSRVR      lpsrvr;


    if (AddMessage (hwnd, msg, wParam, lParam, (int)WT_DOC))
        return 0L;

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);

    switch (msg){


       case WM_CREATE:
            DEBUG_OUT ("doc create window", 0)
            break;

       case WM_DDE_INITIATE:

            DEBUG_OUT ("doc: DDE init",0);
            if (lpdoc->bTerminate){
                DEBUG_OUT ("doc: No action due to termination process",0)
                break;
            }

            // if we are the documnet then respond.

            if (! (lpdoc->aDoc == (ATOM)(HIWORD(lParam))))
                break;

            // We can enterain this client. Put this window in the client list
            // and acknowledge the initiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpdoc->cClients++;
            lpsrvr = (LPSRVR) GetWindowLongPtr (GetParent(lpdoc->hwnd), 0);

            lpsrvr->bnoRelease = FALSE;

            // post the acknowledge
            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));
            SendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);

            break;

       case WM_DDE_EXECUTE: {

            HANDLE hData = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);

            DEBUG_OUT ("doc: execute", 0)
            // Are we terminating
            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam)) {
                DEBUG_OUT ("doc: execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (hData);
                break;

            }

            retval = DocExecute (hwnd, hData, (HWND)wParam);
            SET_MSG_STATUS (retval, status);

#ifdef OLD
            // if we posted the terminate because of execute, do not send
            // ack.

            if (lpdoc->bTerminate) {
                // !!! We got close but, we are posting the
                // the terminate. Excel does not complain about
                // this. But powerpoint complains.
#ifdef  POWERPNT_BUG
                GlobalFree (hData);
#endif
                break;
            }
#endif
            if (!lpdoc->bTerminate) { // Post the acknowledge to the client
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK, status, hData);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew)){
                    // the window either died or post failed, delete the data
                    GlobalFree (hData);
                    DDEFREE(WM_DDE_ACK,lparamNew);
                }
            }

            break;
       }

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("doc: DDE terminate",0)

            // We do not need this client any more. Delete him from the
            // client list.

            DeleteClient (lpdoc->hwnd, (HWND)wParam);
            lpdoc->cClients--;

            if (lpdoc->bTerminate){
                lpsrvr = (LPSRVR) GetWindowLongPtr (GetParent(lpdoc->hwnd), 0);
                if (!--lpdoc->termNo)
                    // Release this Doc and may be the server also
                    // if the server is waiting to be released also.
                    ReleaseDoc (lpdoc);
            } else {
                if (lpdoc->termNo == 0){

                    // If client intiated the terminate. Post matching terminate

                    PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                                    (WPARAM)hwnd, (LPARAM)0);
                } else
                    lpdoc->termNo--;

                //Client initiated the termination. So, we shoudl take him
                // out from any of our items client lists.
                DeleteFromItemsList (lpdoc->hwnd, (HWND)wParam);

                lpsrvr = (LPSRVR)GetWindowLongPtr (GetParent (lpdoc->hwnd), 0);

                if (QueryRelease (lpsrvr)){


                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }

            }
            break;

       case WM_DESTROY:
            DEBUG_OUT ("doc: Destroy window",0)
            break;

       case WM_DDE_POKE: {
            int    iStdItem;
            LPARAM lparamNew;
            ATOM   aItem = GET_WM_DDE_POKE_ITEM(wParam,lParam);
            HANDLE hData = GET_WM_DDE_POKE_HDATA(wParam,lParam);

            DEBUG_OUT ("doc: Poke", 0)

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam)) {
                // we are getting pke message after we have posted the
                // the termination or the client got deleted.

                /*
                 * This path is valid for POKE, DATA, and ADVISE transactions
                 * only!
                 */
                FreePokeData (GET_WM_DDE_POKE_HDATA(wParam,lParam));
#ifdef OLD
                GlobalFree (GET_WM_DDE_POKE_HDATA(wParam,lParam));
#endif
                // !!! Are we supposed to delete the atoms also.
            PokeErr1:
                /*
                 * This path is valid for POKE, DATA, ADVISE and
                 * ACK transactions only!
                 */
                if (GET_WM_DDE_POKE_ITEM(wParam,lParam))
                    GlobalDeleteAtom (GET_WM_DDE_POKE_ITEM(wParam,lParam));
                DDEFREE(msg,lParam);
                break;

            }

            if (iStdItem = GetStdItemIndex (aItem))
                retval = PokeStdItems (lpdoc, (HWND)wParam, hData, iStdItem);
            else
                retval = PokeData (lpdoc, (HWND)wParam, lParam);

            SET_MSG_STATUS (retval, status);
            // !!! If the fRelease is false and the post fails
            // then we are not freeing the hdata. Are we supposed to
            lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd,lparamNew))
            {
                DDEFREE(WM_DDE_ACK,lparamNew);
                goto PokeErr1;
            }

            break;
       }

       case WM_DDE_ADVISE: {
            ATOM   aItem = GET_WM_DDE_ADVISE_ITEM(wParam, lParam);

            DEBUG_OUT ("doc: Advise", 0)

            fack = TRUE;

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam))
                goto PokeErr1;

            if (IsAdviseStdItems (aItem))
                retval = AdviseStdItems (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);
            else
                // advise data will not have any OLE_BUSY
                retval = AdviseData (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);

            SET_MSG_STATUS (retval, status);

            if (fack) {
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew))
                {
                     DDEFREE(WM_DDE_ACK,lparamNew);
                     goto PokeErr1;
                }

            }
            else if ((ATOM)(HIWORD (lParam)))
                GlobalDeleteAtom (aItem);

            break;
       }

       case WM_DDE_UNADVISE: {
            LPARAM lparamNew;
            ATOM   aItem = GET_WM_DDE_UNADVISE_ITEM(wParam, lParam);

            DEBUG_OUT ("doc: Unadvise", 0)

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam)) {
                goto PokeErr1;
            }

            retval = UnAdviseData (lpdoc, (HWND)wParam, lParam);
            SET_MSG_STATUS (retval, status);

            lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status, aItem);
            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd,lparamNew))
            {
                DDEFREE(WM_DDE_ACK,lparamNew);
            UnadviseErr:
                /*
                 * This path is valid for UNADVISE and REQUEST transaction only!
                 */
                if (GET_WM_DDE_UNADVISE_ITEM(wParam,lParam))
                    GlobalDeleteAtom (GET_WM_DDE_UNADVISE_ITEM(wParam,lParam));
                DDEFREE(msg,lParam);
                break;
            }

            break;
       }

       case WM_DDE_REQUEST: {
            LPARAM lparamNew;
            ATOM   aItem = GET_WM_DDE_REQUEST_ITEM(wParam,lParam);

            DEBUG_OUT ("doc: Request", 0)

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam))
                goto UnadviseErr;

            retval = RequestData (lpdoc, (HWND)wParam, lParam, (HANDLE FAR *)&hdata);

            if(retval == OLE_OK) { // post the data message and we are not asking for any
                                   // acknowledge.
                lparamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdata,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, (WPARAM)hwnd,
                            lparamNew)) {
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_DATA,lparamNew);
                    goto UnadviseErr;
                }
                break;
             }

             if (retval == OLE_BUSY)
                status = 0x4000;
             else
                status = 0;

             lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

             // if request failed, then acknowledge with error.
             if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew))
             {
                 DDEFREE(WM_DDE_ACK,lparamNew);
                 goto UnadviseErr;
             }

             break;
       }

       default:
            DEBUG_OUT("doc:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

//DocExecute: Interprets the execute command for the
//document conversation.


OLESTATUS INTERNAL DocExecute(
    HWND        hwnd,
    HANDLE      hdata,
    HWND        hwndClient
){

    ATOM            acmd;
    BOOL            fShow;
    BOOL            fActivate;

    HANDLE          hdup   = NULL;
    int             retval = OLE_ERROR_MEMORY;
    LPDOC           lpdoc;
    LPOLESERVERDOC  lpoledoc;
    LPCLIENT        lpclient = NULL;

    LPSTR           lpitemname;
    LPSTR           lpopt;
    LPSTR           lpnextarg;
    LPSTR           lpdata = NULL;
    LPSTR           lpverb = NULL;
    UINT            verb;
    WORD            wCmdType;

    // !!!Can we modify the string which has been passed to us
    // rather than duplicating the data. This will get some speed
    // and save some space.

    if(!(hdup = DuplicateData(hdata)))
        goto    errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto    errRtn;

    DEBUG_OUT (lpdata, 0)

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);

    lpoledoc = lpdoc->lpoledoc;

    retval = OLE_ERROR_SYNTAX;

    if(*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    // scan the command and scan upto the first arg.
    if (!(wCmdType = ScanCommand(lpdata, WT_DOC, &lpnextarg, &acmd)))
        goto errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        LPSRVR  lpsrvr;

        if (lpsrvr =  (LPSRVR) GetWindowLongPtr (GetParent (hwnd), 0)) {
            if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
                retval = OLE_ERROR_PROTOCOL;
            else {

                retval = (*lpoledoc->lpvtbl->Execute) (lpoledoc, hdata);
            }
        }

        goto errRtn;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdClose){

        // if not terminated by NULL error
        if (*lpnextarg)
            goto errRtn;

        lpdoc->fAckClose  = TRUE;
        lpdoc->hwndClose  = hwndClient;
        lpdoc->hDataClose = hdata;
        retval = (*lpoledoc->lpvtbl->Close) (lpoledoc);
        lpdoc->fAckClose  = FALSE;
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdDoVerbItem("itemname", verb, BOOL, BOOL]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdDoVerbItem){
        lpitemname = lpnextarg;

        if(!(lpverb = ScanArg(lpnextarg)))
            goto errRtn;


        if(!(lpnextarg = ScanNumArg(lpverb, (LPINT)&verb)))
            goto errRtn;

        // now scan the show BOOL

        if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fShow)))
            goto errRtn;

        fActivate = FALSE;

        // if activate BOOL is present, scan it.

        if (*lpnextarg) {
            if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fActivate)))
                goto errRtn;
        }

        if (*lpnextarg)
            goto errRtn;


        retval = DocDoVerbItem (lpdoc, lpitemname, verb, fShow, !fActivate);
        goto end;
    }





    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd != aStdShowItem)
        goto errRtn;

    lpitemname = lpnextarg;

    if(!(lpopt = ScanArg(lpitemname)))
        goto errRtn;

    // Now scan for optional parameter.

    fActivate = FALSE;

    if (*lpopt) {

        if(!(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
            goto errRtn;

        if (*lpnextarg)
            goto errRtn;


    }

    retval = DocShowItem (lpdoc, lpitemname, !fActivate);

end:
errRtn:
   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   return retval;
}

int INTERNAL   DocShowItem (
    LPDOC   lpdoc,
    LPSTR   lpitemname,
    BOOL    fAct
){
    LPCLIENT   lpclient;
    int        retval;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

    // protocol sends false for activating and TRUE for not activating.
    // for api send TRUE for avtivating and FALSE for not activating.

    return (*lpclient->lpoleobject->lpvtbl->Show)(lpclient->lpoleobject, fAct);
}


int INTERNAL   DocDoVerbItem (
    LPDOC   lpdoc,
    LPSTR   lpitemname,
    UINT    verb,
    BOOL    fShow,
    BOOL    fAct
){
    LPCLIENT   lpclient;
    int        retval = OLE_ERROR_PROTOCOL;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

    // pass TRUE to activate and False not to activate. Differnt from
    // protocol.

    retval = (*lpclient->lpoleobject->lpvtbl->DoVerb)(lpclient->lpoleobject, verb, fShow, fAct);

    return retval;
}



// FreePokeData: Frees the poked dats.
void  INTERNAL FreePokeData (
    HANDLE  hdde
){
    DDEPOKE FAR * lpdde;

    if (hdde) {
        if (lpdde = (DDEPOKE FAR *) GlobalLock (hdde)) {
            if (lpdde->cfFormat == CF_METAFILEPICT)
#ifdef _WIN64
                FreeGDIdata (*(void* _unaligned*)lpdde->Value, lpdde->cfFormat);
#else
                FreeGDIdata (*(LPHANDLE)lpdde->Value, lpdde->cfFormat);
#endif
            else
                FreeGDIdata (LongToHandle(*(LONG*)lpdde->Value), lpdde->cfFormat);
            GlobalUnlock (hdde);
        }

        GlobalFree (hdde);
    }
}



// Returns TRUE if GDI format else returns FALSE

BOOL INTERNAL FreeGDIdata (
    HANDLE          hData,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
    else if (cfFormat == CF_ENHMETAFILE)
        DeleteEnhMetaFile(hData);
    else
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (../../1990)    Designed and coded
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include <reghelp.hxx>
#include "cmacs.h"
#include <shellapi.h>

#include "ole.h"
#include "dde.h"
#include "srvr.h"

#include "strsafe.h"

#define KB_64   65536

extern ATOM    aTrue;
extern ATOM    aFalse;
extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdShowItem;
extern ATOM    aStdClose;
extern ATOM    aStdExit;
extern ATOM    aStdDoVerbItem;

extern BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// MapToHexStr: Converts  WORD to hex string.
void INTERNAL MapToHexStr (
    LPSTR       lpbuf,
    HANDLE      hdata
){
    int     i;
    char    ch;

    *lpbuf++ = '@';
    for ( i = sizeof(HANDLE)*2 - 1; i >= 0; i--) {

	ch = (char) ((((DWORD_PTR)hdata) >> (i * 4)) & 0x0000000f);
	if(ch > '9')
	    ch += 'A' - 10;
	else
	    ch += '0';

	*lpbuf++ = ch;
    }

    *lpbuf++ = '\0';

}


void INTERNAL UtilMemCpy (
    LPSTR   lpdst,
    LPCSTR  lpsrc,
    DWORD   dwCount
){
    UINT HUGE_T * hpdst;
    UINT HUGE_T * hpsrc;
    UINT FAR  * lpwDst;
    UINT FAR  * lpwSrc;
    DWORD       words;
    DWORD       bytes;

    bytes = dwCount %  MAPVALUE(2,4);
    words = dwCount >> MAPVALUE(1,2); //* we compare DWORDS
				      //* in the 32 bit version
    UNREFERENCED_PARAMETER(lpwDst);
    UNREFERENCED_PARAMETER(lpwSrc);
    {
	hpdst = (UINT HUGE_T *) lpdst;
	hpsrc = (UINT HUGE_T *) lpsrc;

	for(;words--;)
	    *hpdst++ = *hpsrc++;
			
	lpdst = (LPSTR) hpdst;
	lpsrc = (LPSTR) hpsrc;

	for(;bytes--;)
	    *lpdst++ = *lpsrc++;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE  INTERNAL    DuplicateData (
    HANDLE  hdata
){
    LPSTR   lpsrc = NULL;
    LPSTR   lpdst = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;

    if(!(lpsrc =  GlobalLock (hdata)))
	return NULL;

    DEBUG_OUT (lpsrc, 0)

    hdup = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, (size = (DWORD)GlobalSize(hdata)));

    if(!(lpdst =  GlobalLock (hdup)))
	goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);

errRtn:
    if(lpsrc)
	GlobalUnlock (hdata);

    if(lpdst)
	GlobalUnlock (hdup);

    if (err && hdup)
	GlobalFree (hdup);

    return hdup;
}


//ScanBoolArg: scans the argument which is not included in
//the quotes. These args could be only TRUE or FALSE for
//the time being. !!!The scanning routines should be
//merged and it should be generalized.

LPSTR   INTERNAL    ScanBoolArg (
    LPSTR   lpstr,
    BOOL    FAR *lpflag
){
    LPSTR   lpbool;
    ATOM    aShow;
    char    ch;

    lpbool = lpstr;

    // !!! These routines does not take care of quoted quotes.

    while((ch = *lpstr) && (!(ch == ')' || ch == ',')))
	lpstr++;

    if (ch == '\0')
       return NULL;

    *lpstr++ = '\0';       // terminate the arg by null

    // if terminated by paren, then check for end of command
    // syntax.

    // Check for the end of the command string.
    if (ch == ')') {
	if (*lpstr++ != ']')
	    return NULL;

	if (*lpstr != '\0')
	    return NULL;             //finally should be terminated by null.

    }

    aShow = GlobalFindAtom (lpbool);
    if (aShow == aTrue)
	*lpflag = TRUE;

    else {
	if (aShow ==aFalse)
	    *lpflag = FALSE;
	else
	    return NULL;;
    }
    return lpstr;
}




//ScannumArg: Checks for the syntax of num arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg and also, returns the number
//Does not take care of the last num arg in the list.

LPSTR INTERNAL ScanNumArg (
    LPSTR   lpstr,
    LPINT   lpnum
){
    WORD    val = 0;
    char    ch;

    while((ch = *lpstr++) && (ch != ',')) {
	if (ch < '0' || ch >'9')
	    return NULL;
	val += val * 10 + (ch - '0');

    }

    if(!ch)
       return NULL;

    *lpnum = val;
    return lpstr;
}




//ScanArg: Checks for the syntax of arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg or to the end of the excute string.

LPSTR INTERNAL ScanArg (
    LPSTR   lpstr
){


    // !!! These routines does not take care of quoted quotes.

    // first char should be quote.

    if (*(lpstr-1) != '\"')
	return NULL;

    while(*lpstr && *lpstr != '\"')
	lpstr++;

    if(*lpstr == '\0')
       return NULL;

    *lpstr++ = '\0';       // terminate the arg by null

    if(!(*lpstr == ',' || *lpstr == ')'))
	return NULL;


    if(*lpstr++ == ','){

	if(*lpstr == '\"')
	    return ++lpstr;
	// If it is not quote, leave the ptr on the first char
	return lpstr;
    }

    // terminated by paren
    // already skiped right paren

    // Check for the end of the command string.
    if (*lpstr++ != ']')
	return NULL;

    if(*lpstr != '\0')
	return NULL;             //finally should be terminated by null.

    return lpstr;
}

// ScanCommand: scanns the command string for the syntax
// correctness. If syntactically correct, returns the ptr
// to the first arg or to the end of the string.

WORD INTERNAL  ScanCommand (
    LPSTR       lpstr,
    UINT        wType,
    LPSTR FAR * lplpnextcmd,
    ATOM FAR *  lpAtom
){
    // !!! These routines does not take care of quoted quotes.
    // and not taking care of blanks arround the operators

    // !!! We are not allowing blanks after operators.
    // Should be allright! since this is arestricted syntax.

    char    ch;
    LPSTR   lptemp = lpstr;


    while(*lpstr && (!(*lpstr == '(' || *lpstr == ']')))
	lpstr++;

    if(*lpstr == '\0')
       return 0;

    ch = *lpstr;
    *lpstr++ = '\0';       // set the end of command

    *lpAtom = GlobalFindAtom (lptemp);

    if (!IsOleCommand (*lpAtom, wType))
	return NON_OLE_COMMAND;

    if (ch == '(') {
	ch = *lpstr++;

	if (ch == ')') {
	     if (*lpstr++ != ']')
		return 0;
	}
	else {
	    if (ch != '\"')
		return 0;
	}
	
	*lplpnextcmd = lpstr;
	return OLE_COMMAND;
    }

    // terminated by ']'

    if (*(*lplpnextcmd = lpstr)) // if no nul termination, then it is error.
	return 0;

    return OLE_COMMAND;
}


//MakeDataAtom: Creates a data atom from the item string
//and the item data otions.

ATOM INTERNAL MakeDataAtom (
    ATOM    aItem,
    int     options
){
    char    buf[MAX_STR];

    if (options == OLE_CHANGED)
	return DuplicateAtom (aItem);

    if (!aItem)
	buf[0] = '\0';
    else
    {
        if (!GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR))
            return (ATOM) 0;	 
    }

    if (options == OLE_CLOSED)
    {
        if (FAILED(StringCchCat((LPSTR)buf, sizeof(buf)/sizeof(buf[0]), (LPSTR) "/Close")))
            return (ATOM) 0;
    }
    else if (options == OLE_SAVED)
    {
        if (FAILED(StringCchCat((LPSTR)buf, sizeof(buf)/sizeof(buf[0]), (LPSTR) "/Save")))
            return (ATOM) 0;
    }

    if (buf[0])
	return GlobalAddAtom ((LPSTR)buf);
    else
	return (ATOM)0;
}

//DuplicateAtom: Duplicates an atom
ATOM INTERNAL DuplicateAtom (
    ATOM    atom
){
    char buf[MAX_STR];

    Puts ("DuplicateAtom");

    if (!atom)
	return (ATOM)0;

    if (!GlobalGetAtomName (atom, buf, MAX_STR))
        return (ATOM) 0;
    return GlobalAddAtom (buf);
}

// MakeGlobal: makes global out of strings.
// works only for << 64k

HANDLE  INTERNAL MakeGlobal (
    LPCSTR  lpstr
){

    int     len = 0;
    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    len = lstrlen (lpstr) + 1;

    hdata = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, len);
    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
	goto errRtn;


    UtilMemCpy (lpdata, lpstr, (DWORD)len);
    GlobalUnlock (hdata);
    return hdata;

errRtn:

    if (lpdata)
	GlobalUnlock (hdata);


    if (hdata)
	GlobalFree (hdata);

     return NULL;

}



BOOL INTERNAL CheckServer (
    LPSRVR  lpsrvr
){
    if (!CheckPointer(lpsrvr, WRITE_ACCESS))
	return FALSE;

    if ((lpsrvr->sig[0] == 'S') && (lpsrvr->sig[1] == 'R'))
	return TRUE;

    return FALSE;
}


BOOL INTERNAL CheckServerDoc (
    LPDOC   lpdoc
){
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
	return FALSE;

    if ((lpdoc->sig[0] == 'S') && (lpdoc->sig[1] == 'D'))
	return TRUE;

    return FALSE;
}


BOOL INTERNAL PostMessageToClientWithBlock (
    HWND    hWnd,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
){

    if (!IsWindowValid (hWnd)){
	ASSERT(FALSE, "Client's window is missing");
	return FALSE;
    }

    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
	return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}



BOOL INTERNAL PostMessageToClient (
    HWND    hWnd,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
){
    if (!IsWindowValid (hWnd)){
	ASSERT(FALSE, "Client's window is missing");
	return FALSE;
    }


    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
	return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}


BOOL    INTERNAL IsWindowValid (
    HWND    hwnd
){

#define TASK_OFFSET 0x00FA

    LPSTR   lptask;
    HANDLE  htask;

    if (!IsWindow (hwnd))
	return FALSE;

#ifdef WIN32
   UNREFERENCED_PARAMETER(lptask);
   UNREFERENCED_PARAMETER(htask);
   return TRUE;//HACK
#endif

    return FALSE;
}



BOOL INTERNAL UtilQueryProtocol (
    ATOM    aClass,
    LPSTR   lpprotocol
){
    HKEY    hKey;
    char    key[MAX_STR];
    char    class[MAX_STR];

    if (!aClass)
	return FALSE;

    if (!GlobalGetAtomName (aClass, class, MAX_STR))
	return FALSE;

    if (FAILED(StringCchCopy(key, sizeof(key)/sizeof(key[0]), class)))
        return FALSE;
    if (FAILED(StringCchCat(key, sizeof(key)/sizeof(key[0]), "\\protocol\\")))
        return FALSE;
    if (FAILED(StringCchCat(key, sizeof(key)/sizeof(key[0]), lpprotocol)))
        return FALSE;
    if (FAILED(StringCchCat(key, sizeof(key)/sizeof(key[0]), "\\server")))
        return FALSE;

    if (OpenClassesRootKeyA (key, &hKey))
	return FALSE;

    RegCloseKey (hKey);
    return TRUE;
}


BOOL INTERNAL IsOleCommand (
    ATOM    aCmd,
    UINT    wType
){
    if (wType == WT_SRVR) {
	if ((aCmd == aStdCreateFromTemplate)
		|| (aCmd == aStdCreate)
		|| (aCmd == aStdOpen)
		|| (aCmd == aStdEdit)
		|| (aCmd == aStdShowItem)
		|| (aCmd == aStdClose)
		|| (aCmd == aStdExit))
	    return TRUE;
    }
    else {
	if ((aCmd == aStdClose)
		|| (aCmd == aStdDoVerbItem)
		|| (aCmd == aStdShowItem))
	    return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\winole\server\srvrmain.c ===
/****************************** Module Header ******************************\
* Module Name: Srvrmain.c Server Main module
*
* Purpose: Includes server intialization and termination code.
*
* Created: Oct 1990.
*
* Copyright (c) 1990 - 1992  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/

#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "cmacs.h"
#include "srvr.h"

#ifndef WF_WLO
#define WF_WLO  0x8000
#endif

// ordinal number of new Win31 API IsTask
#define ORD_IsTask  320

// ordinal number of new Win31 API SetMetaFileBitsBetter
#define ORD_SetMetaFileBitsBetter   196


// public vars.

// atomes used in the systems
ATOM    aStdExit;                      // "StdExit"
ATOM    aStdCreate;                    // "StdNewDicument"
ATOM    aStdOpen;                      // "StdOpenDocument"
ATOM    aStdEdit;                      // "StdOpenDocument"
ATOM    aStdCreateFromTemplate;        // "StdNewFromTemplate"
ATOM    aStdClose;                     // "StdCloseDocument"
ATOM    aStdShowItem;                  // "StdShowItem"
ATOM    aStdDoVerbItem;                // "StddoVerbItem"
ATOM    aSysTopic;                     // "System"
ATOM    aOLE;                          // "OLE"
ATOM    aStdDocName;                   // "StdDocumentName"

ATOM    cfBinary;                      // "Binary format"
ATOM    cfNative;                      // "NativeFormat"
ATOM    cfLink;                        // "ObjectLink"
ATOM    cfOwnerLink;                   // "Ownerlink"

ATOM    aChange;                       // "Change"
ATOM    aSave;                         // "Save"
ATOM    aClose;                        // "Close"
ATOM    aProtocols;                    // "Protocols"
ATOM    aTopics;                       // "Topics"
ATOM    aFormats;                      // "Formats"
ATOM    aStatus;                       // "Status"
ATOM    aEditItems;                    // "Edit items
ATOM    aTrue;                         // "True"
ATOM    aFalse;                        // "False"





// !!! free the proc instances.
FARPROC lpSendRenameMsg;               // Call back enum props for rename
FARPROC lpSendDataMsg;                 // Call back enum props for data
FARPROC lpFindItemWnd;                 // Callback in enum props of
FARPROC lpItemCallBack;                // CallBack for object
FARPROC lpTerminateClients;            // Callback in Doc enum properties
FARPROC lpTerminateDocClients;         // Callback in Doc enum properties
FARPROC lpDeleteClientInfo;            // proc for deleteing each item client
FARPROC lpEnumForTerminate;            // proc for terminating clients not in rename list

FARPROC lpfnSetMetaFileBitsBetter = NULL;
FARPROC lpfnIsTask = NULL;

HANDLE  hdllInst;

VOID FAR PASCAL WEP(int);

#ifdef WIN32                           //WIN32
BOOL LibMain(
   HANDLE hInst,
   ULONG Reason,
   PCONTEXT Context
#endif
){
    WNDCLASS  wc;

    Puts("LibMain");

#ifdef WIN32
    UNREFERENCED_PARAMETER(Context);
    if (Reason == DLL_PROCESS_DETACH)
    {
        WEP(0);
        return TRUE;
    }
    else if (Reason != DLL_PROCESS_ATTACH)
        return TRUE;
#endif

    hdllInst = hInst;


    // !!! Put all this stuff thru soemkind of table so that we can
    // save code.

    // register all the atoms.
    aStdExit                = GlobalAddAtom ((LPSTR)"StdExit");
    aStdCreate              = GlobalAddAtom ((LPSTR)"StdNewDocument");
    aStdOpen                = GlobalAddAtom ((LPSTR)"StdOpenDocument");
    aStdEdit                = GlobalAddAtom ((LPSTR)"StdEditDocument");
    aStdCreateFromTemplate  = GlobalAddAtom ((LPSTR)"StdNewfromTemplate");

    aStdClose               = GlobalAddAtom ((LPSTR)"StdCloseDocument");
    aStdShowItem            = GlobalAddAtom ((LPSTR)"StdShowItem");
    aStdDoVerbItem          = GlobalAddAtom ((LPSTR)"StdDoVerbItem");
    aSysTopic               = GlobalAddAtom ((LPSTR)"System");
    aOLE                    = GlobalAddAtom ((LPSTR)"OLEsystem");
    aStdDocName             = GlobalAddAtom ((LPSTR)"StdDocumentName");

    aProtocols              = GlobalAddAtom ((LPSTR)"Protocols");
    aTopics                 = GlobalAddAtom ((LPSTR)"Topics");
    aFormats                = GlobalAddAtom ((LPSTR)"Formats");
    aStatus                 = GlobalAddAtom ((LPSTR)"Status");
    aEditItems              = GlobalAddAtom ((LPSTR)"EditEnvItems");

    aTrue                   = GlobalAddAtom ((LPSTR)"True");
    aFalse                  = GlobalAddAtom ((LPSTR)"False");

    aChange                 = GlobalAddAtom ((LPSTR)"Change");
    aSave                   = GlobalAddAtom ((LPSTR)"Save");
    aClose                  = GlobalAddAtom ((LPSTR)"Close");

    // create the proc instances for the required entry pts.
    lpSendRenameMsg         = (FARPROC)MakeProcInstance (SendRenameMsg, hdllInst);
    lpSendDataMsg           = (FARPROC)MakeProcInstance (SendDataMsg, hdllInst);
    lpFindItemWnd           = (FARPROC)MakeProcInstance (FindItemWnd, hdllInst);
    lpItemCallBack          = (FARPROC)MakeProcInstance (ItemCallBack, hdllInst);
    lpTerminateClients      = (FARPROC)MakeProcInstance (TerminateClients, hdllInst);
    lpTerminateDocClients   = (FARPROC)MakeProcInstance (TerminateDocClients, hdllInst);
    lpDeleteClientInfo      = (FARPROC)MakeProcInstance (DeleteClientInfo, hdllInst);
    lpEnumForTerminate      = (FARPROC)MakeProcInstance (EnumForTerminate , hdllInst);

    // register the clipboard formats
    cfNative                = (OLECLIPFORMAT)RegisterClipboardFormat("Native");
    cfBinary                = (OLECLIPFORMAT)RegisterClipboardFormat("Binary");
    cfLink                  = (OLECLIPFORMAT)RegisterClipboardFormat("ObjectLink");
    cfOwnerLink             = (OLECLIPFORMAT)RegisterClipboardFormat("OwnerLink");



    wc.style        = 0;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG_PTR) + //Ask for extra space for storing the
                                        //ptr to srvr/doc/iteminfo.
                      sizeof (WORD) +   // for LE chars
                      sizeof (UINT_PTR);    // for keeping the hDLLInst.

    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;


    // Srvr window class
    wc.lpfnWndProc  = SrvrWndProc;
    wc.lpszClassName= SRVR_CLASS;
    if (!RegisterClass(&wc))
         return 0;

    // document window class
    wc.lpfnWndProc = DocWndProc;
    wc.lpszClassName = DOC_CLASS;

    if (!RegisterClass(&wc))
        return 0;

    // Item (object) window class
    wc.lpfnWndProc = ItemWndProc;
    wc.lpszClassName = ITEM_CLASS;

    wc.cbWndExtra   = sizeof(LONG_PTR); // for items do not need extra stuff.
    if (!RegisterClass(&wc))
        return 0;

    return 1;
}


VOID APIENTRY WEP (int nParameter)
{

    Puts("LibExit");

#ifdef WIN32
    UNREFERENCED_PARAMETER(nParameter);
    DEBUG_OUT ("---L&E DLL EXIT---",0)
#endif

    // free the global atoms.
    if (aStdExit)
        GlobalDeleteAtom (aStdExit);
    if (aStdCreate)
        GlobalDeleteAtom (aStdCreate);
    if (aStdOpen)
        GlobalDeleteAtom (aStdOpen);
    if (aStdEdit)
        GlobalDeleteAtom (aStdEdit);
    if (aStdCreateFromTemplate)
        GlobalDeleteAtom (aStdCreateFromTemplate);
    if (aStdClose)
        GlobalDeleteAtom (aStdClose);
    if (aStdShowItem)
        GlobalDeleteAtom (aStdShowItem);
    if (aStdDoVerbItem)
        GlobalDeleteAtom (aStdDoVerbItem);
    if (aSysTopic)
        GlobalDeleteAtom (aSysTopic);
    if (aOLE)
        GlobalDeleteAtom (aOLE);
    if (aStdDocName)
        GlobalDeleteAtom (aStdDocName);

    if (aProtocols)
        GlobalDeleteAtom (aProtocols);
    if (aTopics)
        GlobalDeleteAtom (aTopics);
    if (aFormats)
        GlobalDeleteAtom (aFormats);
    if (aStatus)
        GlobalDeleteAtom (aStatus);
    if (aEditItems)
        GlobalDeleteAtom (aEditItems);

    if (aTrue)
        GlobalDeleteAtom (aTrue);
    if (aFalse)
        GlobalDeleteAtom (aFalse);

    if (aChange)
        GlobalDeleteAtom (aChange);
    if (aSave)
        GlobalDeleteAtom (aSave);
    if (aClose)
        GlobalDeleteAtom (aClose);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\apmbatt\i386\apmbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ApmBatt.c

Abstract:

    Control Method Battery Miniport Driver - Wacked to work on APM.

Author:

    Bryan Willman
    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#include "ApmBattp.h"
#include "ntddk.h"
#include "ntapm.h"


ULONG       ApmBattDebug     = APMBATT_ERROR;
//ULONG       ApmBattDebug     = -1;

//
// Prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

NTSTATUS
ApmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ApmBattIoctl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );


//
// Globals.  Globals are a little odd in a device driver,
// but this is an odd driver
//

//
// Vector used to call NtApm.sys (our PDO) and ask about
// current battery status
//
ULONG (*NtApmGetBatteryLevel)() = NULL;

//
// APM event notifications and SET_POWER ops will cause
// this value to be incremented.
//
ULONG   TagValue = 1;

//
// If somebody tries to claim there is more than 1 APM driver battery
// in the system, somebody somewhere is very confused.  So keep track
// and forbig this.
//
ULONG   DeviceCount = 0;

//
//
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,ApmBattQueryTag)
#pragma alloc_text(PAGE,ApmBattQueryInformation)
#pragma alloc_text(PAGE,ApmBattQueryStatus)
#pragma alloc_text(PAGE,ApmBattSetStatusNotify)
#pragma alloc_text(PAGE,ApmBattDisableStatusNotify)
#pragma alloc_text(PAGE,ApmBattOpenClose)
#pragma alloc_text(PAGE,ApmBattIoctl)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine initializes the ACPI Embedded Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    ApmBattPrint (APMBATT_TRACE, ("ApmBatt DriverEntry - Obj (%08x) Path (%08x)\n",
                                 DriverObject, RegistryPath));
    //
    // Set up the device driver entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = ApmBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = ApmBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = ApmBattOpenClose;

    DriverObject->MajorFunction[IRP_MJ_POWER]           = ApmBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = ApmBattPnpDispatch;
    DriverObject->DriverExtension->AddDevice            = ApmBattAddDevice;

    return STATUS_SUCCESS;

}


NTSTATUS
ApmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This is the routine called as a result of a Open or Close on the device

Arguments:


    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    STATUS_SUCCESS - no way to fail this puppy

--*/
{
    PAGED_CODE();

    ApmBattPrint (APMBATT_TRACE, ("ApmBattOpenClose\n"));

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}



NTSTATUS
ApmBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    Status of request

--*/
{
    NTSTATUS        Status;
    PCM_BATT        ApmBatt;


    PAGED_CODE();

    ApmBattPrint (APMBATT_TRACE, ("ApmBattIoctl\n"));

    ApmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    Status = BatteryClassIoctl (ApmBatt->Class, Irp);

    if (Status == STATUS_NOT_SUPPORTED) {
        //
        // Not for the battery, complete it
        //

        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return Status;
}



NTSTATUS
ApmBattQueryTag (
    IN  PVOID       Context,
    OUT PULONG      TagPtr
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to retrieve the batteries current tag value

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    TagPtr          - Pointer to return current tag

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    ULONG   BatteryLevel;
    UNREFERENCED_PARAMETER(Context);
    PAGED_CODE();
    ApmBattPrint ((APMBATT_TRACE | APMBATT_MINI),
                 ("ApmBattQueryTag - TagValue = %08x\n", TagValue));
    //
    // The code that catches APM event notification, and the code
    // that handles Power IRPs, will both increment the tag.
    // We simply report that.
    //

    *TagPtr = TagValue;

    //
    // Call ntapm, it will return a DWORD with the relevent data in it,
    // crack this DWORD, and fill this stuff in.
    //
    if (NtApmGetBatteryLevel) {
        BatteryLevel = NtApmGetBatteryLevel();
        if ((BatteryLevel & NTAPM_NO_BATT) || (BatteryLevel & NTAPM_NO_SYS_BATT)) {
            return STATUS_NO_SUCH_DEVICE;
        } else {
            return STATUS_SUCCESS;
        }
    } else {
        //
        // if we cannot get battery status, it's likely we don't have
        // a battery, so say we don't have one.
        //
        return STATUS_NO_SUCH_DEVICE;
    }
}



NTSTATUS
ApmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN ULONG                            AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to retrieve battery information

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

    We return invalid parameter when we can't handle a request for a
    specific level of information.  This is defined in the battery class spec.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    Level           - type of information required
    AtRate          - Used only when Level==BatteryEstimatedTime
    Buffer          - Location for the information
    BufferLength    - Length in bytes of the buffer
    ReturnedLength  - Length in bytes of the returned data

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    NTSTATUS                Status;
    PVOID                   ReturnBuffer;
    ULONG                   ReturnBufferLength;
    ULONG                   CapabilityVector = (BATTERY_SYSTEM_BATTERY | BATTERY_CAPACITY_RELATIVE);
    BATTERY_INFORMATION     bi;


    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_MINI),
                 ("ApmBattQueryInformation Level=%08xl\n", Level));

    //
    // We cannot tell (reliably/safely) if there is a battery
    // present or not, so always return what the query code tells us
    //

    ReturnBuffer = NULL;
    ReturnBufferLength = 0;
    Status = STATUS_SUCCESS;

    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:
            ApmBattPrint((APMBATT_TRACE|APMBATT_MINI), ("Batteryinformation\n"));
            RtlZeroMemory(&bi, sizeof(bi));
            bi.Capabilities = CapabilityVector;
            bi.Technology = BATTERY_SECONDARY_CHARGABLE;
            bi.DesignedCapacity = 100;
            bi.FullChargedCapacity = UNKNOWN_CAPACITY;
            ReturnBuffer = (PVOID) &bi;
            ReturnBufferLength = sizeof(bi);
            break;

        case BatteryEstimatedTime:
        case BatteryTemperature:
        case BatteryGranularityInformation:
        case BatteryDeviceName:
        case BatteryManufactureDate:
        case BatteryManufactureName:
        case BatteryUniqueID:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Done, return buffer if needed
    //
    *ReturnedLength = ReturnBufferLength;
    if (BufferLength < ReturnBufferLength) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(Status) && ReturnBuffer) {
        RtlZeroMemory (Buffer, BufferLength);                       // Clear entire user buffer
        RtlCopyMemory (Buffer, ReturnBuffer, ReturnBufferLength);   // Copy what's needed
    }
    return Status;
}



NTSTATUS
ApmBattQueryStatus (
    IN PVOID            Context,
    IN ULONG            BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to retrieve the batteries current status

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    ULONG   BatteryLevel;

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_MINI), ("ApmBattQueryStatus\n"));

    //
    // Call ntapm, it will return a DWORD with the relevent data in it,
    // crack this DWORD, and fill this stuff in.
    //
    if (NtApmGetBatteryLevel) {
        BatteryLevel = NtApmGetBatteryLevel();
        BatteryStatus->PowerState = ((BatteryLevel & NTAPM_BATTERY_STATE) >> NTAPM_BATTERY_STATE_SHIFT);
        BatteryStatus->Capacity = BatteryLevel & NTAPM_POWER_PERCENT;
        BatteryStatus->Voltage = UNKNOWN_VOLTAGE;
        BatteryStatus->Current = UNKNOWN_RATE;

        ApmBattPrint((APMBATT_MINI), ("ApmBattQueryStatus: BatteryLevel = %08lx\n", BatteryLevel));

        return STATUS_SUCCESS;

    } else {
        ApmBattPrint((APMBATT_ERROR), ("ApmBattQueryStatus: failure NtApmGetBatteryLevel == NULL\n"));
        //
        // return some "safe" values to keep from looping forever
        //
        BatteryStatus->PowerState = 0;
        BatteryStatus->Capacity = 1;
        BatteryStatus->Voltage = UNKNOWN_VOLTAGE;
        BatteryStatus->Current = UNKNOWN_RATE;
        return STATUS_UNSUCCESSFUL;
    }
}



NTSTATUS
ApmBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY Notify
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.

    The class driver will always set the notification level it needs
    after each call to BatteryClassStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    //
    // need to fill this in
    //
    ApmBattPrint (APMBATT_TRACE, ("ApmBattSetStatusNotify\n"));
    return STATUS_NOT_IMPLEMENTED;
}



NTSTATUS
ApmBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to ApmBattSetStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    //
    // need to fill this in
    //
    ApmBattPrint (APMBATT_TRACE, ("ApmBattDisableStatusNotify\n"));
    return STATUS_NOT_IMPLEMENTED;
}

VOID
ApmBattPowerNotifyHandler (
    )
/*++

Routine Description:

    NTAPM CALLBACK

    This routine fields power device notifications from the APM driver.

Arguments:


Return Value:

    None

--*/
{
    ApmBattPrint (APMBATT_TRACE, ("ApmBattPowerNotifyHandler\n"));
//    DbgBreakPoint();
    TagValue++;
    BatteryClassStatusNotify(ApmGlobalClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\apmbatt\i386\apmbattp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    apmbattp.h

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

#include <wdm.h>
#include <poclass.h>
//#include "acpiioct.h"

//
// Debug
//
#define DEBUG   1
#if DEBUG
    extern ULONG ApmBattDebug;
    #define ApmBattPrint(l,m)    if(l & ApmBattDebug) DbgPrint m
#else
    #define ApmBattPrint(l,m)
#endif

#define APMBATT_LOW          0x00000001
#define APMBATT_NOTE         0x00000002
#define APMBATT_WARN         0x00000004
#define APMBATT_ERROR_ONLY   0x00000008
#define APMBATT_ERROR        (APMBATT_ERROR_ONLY | APMBATT_WARN)
#define APMBATT_POWER        0x00000010
#define APMBATT_PNP          0x00000020
#define APMBATT_CM_EXE       0x00000040
#define APMBATT_DATA         0x00000100
#define APMBATT_TRACE        0x00000200
#define APMBATT_BIOS         0x00000400  // Show message to verify BIOS/HW functionality
#define APMBATT_MINI         0x00000800  // Show message to verify miniport retun data


#define MAX_DEVICE_NAME_LENGTH  128


//
//  These definitions are for the Technology field of the BATTERY_INFORMATION structure.
//  They probably ought to be in the poclass.h file, but they've been here
//  a whole release and nothing bad has happened, so leave them here.
//
// BATTERY_INFORMATION.Technology flags
//
#define BATTERY_PRIMARY_NOT_RECHARGABLE     0x00
#define BATTERY_SECONDARY_CHARGABLE         0x01

//
// Use the IoSkipCurrentIrpStackLocation routine because the we
// don't need to change arguments, or a completion routine
//

#define ApmBattCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }

#define GetTid() PsGetCurrentThread()

//
// Pagable device extension for control battery
//

typedef struct _CM_BATT {

    ULONG                   Type;               // This must be the first entry
                                                // as it is shared with the AC_ACAPTER

    PDEVICE_OBJECT          DeviceObject;       // Battery device object
    PDEVICE_OBJECT          Fdo;                // Functional Device Object
    PDEVICE_OBJECT          Pdo;                // Physical Device Object
    PDEVICE_OBJECT          LowerDeviceObject;  // Detected at AddDevice time
    PVOID                   Class;              // Battery Class handle

    BOOLEAN                 IsStarted;          // if non zero, the device is started
    BOOLEAN                 IsCacheValid;       // Is cached battery info currently valid?

    //
    // Selector
    //
    PVOID                   Selector;           // Selector for battery

    //
    // Battery
    //
    ULONG                   TagCount;           // Tag for next battery
    PUNICODE_STRING         DeviceName;
    USHORT                  DeviceNumber;

} CM_BATT, *PCM_BATT;

//
// Misc globals
//
extern  PVOID   ApmGlobalClass;
extern  ULONG   DeviceCount;
extern  ULONG   TagValue;
extern  ULONG   (*NtApmGetBatteryLevel)();


//
// Prototypes
//

NTSTATUS
ApmBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
ApmBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
ApmBattForwardRequest(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
ApmBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
ApmBattQueryTag (
    IN PVOID                Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
ApmBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
ApmBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
ApmBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );

NTSTATUS
ApmBattIoCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              pdoIoCompletedEvent
    );

NTSTATUS
ApmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN ULONG                            AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    );

VOID
ApmBattPowerNotifyHandler(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\ntapmdmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntapmdmp.c

Abstract:

    Dump data about whether machine is ACPI or APM, and if
    APM whether APM is usable, good, bad, etc.

Author:

    Byan M. Willman (bryanwi) 24-Aug-1998

Revision History:

--*/
#if 0
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <apmlib.h>

void
DumpApmError();

void
_CRTAPI1 main(
    int argc,
    char *argv[]
    )
{
    if (IsSystemACPI()) {
        printf("ACPI system.  APM is not relevent.\n");
        exit(0);
    }

    switch (IsApmPresent()) {

    case APM_NOT_PRESENT:
        printf("APM not detected on this system.\n");
        exit(1);
        break;

    case APM_PRESENT_BUT_NOT_USABLE:
        printf("APM detected on this system, but not usable.\n");
        DumpApmError();
        exit(2);
        break;

    case APM_ON_GOOD_LIST:
        printf("APM detected on this system, usable, on the Good bios list.\n");
        if (IsApmActive()) {
            printf("APM is active on this machine.\n");
        } else {
            printf("APM is NOT active on this machine.\n");
        }
        exit(3);
        break;

    case APM_NEUTRAL:
        printf("APM detected on this system, usable, NOT on the Good or Bad lists.\n");
        if (IsApmActive()) {
            printf("APM is active on this machine.\n");
        } else {
            printf("APM is NOT active on this machine.\n");
        }
        exit(4);
        break;

    case APM_ON_BAD_LIST:
        printf("APM detected on this system, usable, BUT on the bad bios list.\n");
        if (IsApmActive()) {
            printf("APM is active on this machine.\n");
        } else {
            printf("APM is NOT active on this machine.\n");
        }
        exit(5);
        break;

    default:
        printf("Something very strange has happened.\n");
        exit(99);
        break;
    }
}


VOID
DumpApmError()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\apmcrib.h ===
/*++

Module Name:

    apmcrib.h -

Abstract:

    prototypes that aren't in driver visible includes...

Author:


Environment:

    Kernel mode

Notes:

Revision History:

--*/


//
// NT "private" prototypes cribbed in here.  Not for use anywhere
// but in laptop.c
//
NTSTATUS
KeI386AllocateGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

VOID
KeI386Call16BitFunction (
    IN OUT PCONTEXT Regs
    );

NTSTATUS
KeI386ReleaseGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

NTSTATUS
KeI386SetGdtSelector (
    ULONG       Selector,
    PKGDTENTRY  GdtValue
    );


//
// APM constants that really belong somewhere else...
//
#define APM_SYS_STANDBY_REQUEST             (0x01)
#define APM_SYS_SUSPEND_REQUEST             (0x02)
#define APM_NORMAL_RESUME_NOTICE            (0x03)
#define APM_CRITICAL_RESUME_NOTICE          (0x04)
#define APM_BATTERY_LOW_NOTICE              (0x05)
#define APM_POWER_STATUS_CHANGE_NOTICE      (0x06)
#define APM_UPDATE_TIME_EVENT               (0x07)
#define APM_CRITICAL_SYSTEM_SUSPEND_REQUEST (0x08)
#define APM_USR_STANDBY_REQUEST             (0x09)
#define APM_USR_SUSPEND_REQUEST             (0x0a)
#define APM_STANDBY_RESUME_NOTICE           (0x0b)
#define APM_CAPABILITIES_CHANGE_NOTICE      (0x0c)

#define APM_SET_PROCESSING                  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\apm.c ===
/*++

Module Name:

    apm.c

Abstract:

    A collection of code that allows NT calls into APM.
    The code in this routine depends on data being set up in the registry

Author:

Environment:

    Kernel mode only.

Revision History:

--*/


#include "ntosp.h"
#include "zwapi.h"
#include "apmp.h"
#include "apm.h"
#include "apmcrib.h"
#include "ntapmdbg.h"
#include "ntapmlog.h"
#include "ntapmp.h"


#define MAX_SEL     30      // attempts before giving up

ULONG   ApmCallActive = 0;
ULONG   ApmCallEax = 0;
ULONG   ApmCallEbx = 0;
ULONG   ApmCallEcx = 0;

WCHAR rgzMultiFunctionAdapter[] =
    L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIndetifier[] = L"PCI";

WCHAR rgzApmConnect[]= L"\\Registry\\Machine\\Hardware\\ApmConnect";
WCHAR rgzApmConnectValue[] = L"ApmConnectValue";

APM_CONNECT     Apm;

//
// First time we get any non-recoverable error back
// from APM, record what sort of call hit it and what
// the error code was here
//
ULONG   ApmLogErrorFunction = -1L;
ULONG   ApmLogErrorCode = 0L;

ULONG ApmErrorLogSequence = 0xf3;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ApmInitializeConnection)
#endif

//
// Internal prototypes
//

BOOLEAN
ApmpBuildGdtEntry (
    IN ULONG Index,
    PKGDTENTRY GdtEntry,
    IN ULONG SegmentBase
    );


VOID
NtApmLogError(
    NTSTATUS    ErrorCode,
    UCHAR       ErrorByte
    );


NTSTATUS
ApmInitializeConnection (
    VOID
    )
/*++

Routine Description:

    Initialize data needed to call APM bios functions -- look in the
    registry to find out if this machine has had its APM capability
    detected.

    NOTE:   If you change the recognition code, change the
            code to IsApmPresent as well!

Arguments:

    None

Return Value:

    STATUS_SUCCESS if we were able to connect to the APM BIOS.

--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR Desc;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;
    PAPM_REGISTRY_INFO ApmEntry;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString, ConfigName, IdentName;
    KGDTENTRY GdtEntry;
    NTSTATUS status;
    BOOLEAN Error;
    HANDLE hMFunc, hBus, hApmConnect;
    USHORT Sel[MAX_SEL], TSel;
    UCHAR buffer [sizeof(APM_REGISTRY_INFO) + 99];
    WCHAR wstr[8];
    ULONG i, j, Count, junk;
    PWSTR p;
    USHORT  volatile    Offset;

    //
    // Look in the registery for the "APM bus" data
    //

    RtlInitUnicodeString(&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );


    status = ZwOpenKey(&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString(&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString(&IdentName, rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0; TRUE; i++) {
        RtlIntegerToUnicodeString(i, 10, &unicodeString);
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL
            );

        status = ZwOpenKey(&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is a APM entry
        //

        status = ZwQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'A' || p[1] != L'P' || p[2] != L'M' || p[3] != 0) {
            ZwClose (hBus);
            continue;
        }

        status = ZwQueryValueKey(
                    hBus,
                    &ConfigName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        Desc  = (PCM_FULL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      ValueInfo + ValueInfo->DataOffset);
        PDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      Desc->PartialResourceList.PartialDescriptors);

        if (PDesc->Type == CmResourceTypeDeviceSpecific) {
            // got it..
            ApmEntry = (PAPM_REGISTRY_INFO) (PDesc+1);
            break;
        }
    }

//DbgPrint("ApmEntry: %08lx\n", ApmEntry);
//DbgPrint("Signature: %c%c%c\n", ApmEntry->Signature[0], ApmEntry->Signature[1], ApmEntry->Signature[2]);
    if ( (ApmEntry->Signature[0] != 'A') ||
         (ApmEntry->Signature[1] != 'P') ||
         (ApmEntry->Signature[2] != 'M') )
    {
        return STATUS_UNSUCCESSFUL;
    }

//DbgPrint("ApmEntry->Valid: %0d\n", ApmEntry->Valid);
    if (ApmEntry->Valid != 1) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Apm found - initialize the connection
    //

    KeInitializeSpinLock(&Apm.CallLock);

    //
    // Allocate a bunch of selectors
    //

    for (Count=0; Count < MAX_SEL; Count++) {
        status = KeI386AllocateGdtSelectors (Sel+Count, 1);
        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    //
    // Sort the selctors via bubble sort
    //

    for (i=0; i < Count; i++) {
        for (j = i+1; j < Count; j++) {
            if (Sel[j] < Sel[i]) {
                TSel = Sel[i];
                Sel[i] = Sel[j];
                Sel[j] = TSel;
            }
        }
    }

    //
    // Now look for 3 consecutive values
    //

    for (i=0; i < Count - 3; i++) {
        if (Sel[i]+8 == Sel[i+1]  &&  Sel[i]+16 == Sel[i+2]) {
            break;
        }
    }

    if (i >= Count - 3) {
        DrDebug(APM_INFO,("APM: Could not allocate consecutive selectors\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Save the results
    //

    Apm.Selector[0] = Sel[i+0];
    Apm.Selector[1] = Sel[i+1];
    Apm.Selector[2] = Sel[i+2];
    Sel[i+0] = 0;
    Sel[i+1] = 0;
    Sel[i+2] = 0;

    //
    // Free unused selectors
    //

    for (i=0; i < Count; i++) {
        if (Sel[i]) {
            KeI386ReleaseGdtSelectors (Sel+i, 1);
        }
    }

    //
    // Initialize the selectors to use the APM bios
    //

    Error = FALSE;

    //
    // initialize 16 bit code selector
    //

    GdtEntry.LimitLow                   = 0xFFFF;
    GdtEntry.HighWord.Bytes.Flags1      = 0;
    GdtEntry.HighWord.Bytes.Flags2      = 0;
    GdtEntry.HighWord.Bits.Pres         = 1;
    GdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    GdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    GdtEntry.HighWord.Bits.Type         = 31;
    GdtEntry.HighWord.Bits.Default_Big  = 0;

    Error |= ApmpBuildGdtEntry (0, &GdtEntry, ApmEntry->Code16BitSegment);

    //
    // initialize 16 bit data selector
    //

    GdtEntry.LimitLow                   = 0xFFFF;
    GdtEntry.HighWord.Bytes.Flags1      = 0;
    GdtEntry.HighWord.Bytes.Flags2      = 0;
    GdtEntry.HighWord.Bits.Pres         = 1;
    GdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    GdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    GdtEntry.HighWord.Bits.Type         = 19;
    GdtEntry.HighWord.Bits.Default_Big  = 1;

    Error |= ApmpBuildGdtEntry (1, &GdtEntry, ApmEntry->Data16BitSegment);

    //
    // If we leave it like this, the compiler generates incorrect code!!!
    // Apm.Code16BitOffset = ApmEntry->Code16BitOffset;
    // So do this instead.
    //
    Offset = ApmEntry->Code16BitOffset;
    Apm.Code16BitOffset = (ULONG) Offset;

//DbgPrint("Apm@%08lx ApmEntry@%08lx\n", &Apm, ApmEntry);
//DbgBreakPoint();


#if 0
    //
    // to make the poweroff path in the Hal about 20 times simpler,
    // as well as make it work, pass our mappings on to the Hal, so
    // it can use them.
    //
    RtlInitUnicodeString(&unicodeString, rgzApmConnect);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status = ZwCreateKey(
                &hApmConnect,
                KEY_ALL_ACCESS,
                &objectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                &junk
                );
    RtlInitUnicodeString(&unicodeString, rgzApmConnectValue);
    if (NT_SUCCESS(status)) {
        status = ZwSetValueKey(
                    hApmConnect,
                    &unicodeString,
                    0,
                    REG_BINARY,
                    &Apm,
                    sizeof(APM_CONNECT)
                    );
        ZwClose(hApmConnect);
    }
#endif

    return Error ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
}


BOOLEAN
ApmpBuildGdtEntry (
    IN ULONG Index,
    PKGDTENTRY GdtEntry,
    IN ULONG SegmentBase
    )

/*++

Routine Description:

    Build the Gdt Entry

Arguments:

    Index           Index of entry
    GdtEntry
    SegmentBase

Return Value:

    TRUE if we encountered any error, FALSE if successful

--*/
{
    PHYSICAL_ADDRESS    PhysAddr;
    ULONG               SegBase;
    PVOID               VirtualAddress;
    ULONG               AddressSpace;
    BOOLEAN             flag;

    //
    // Convert Segment to phyiscal address
    //

    PhysAddr.LowPart  = SegmentBase << 4;
    PhysAddr.HighPart = 0;

    //
    // Translate physical address from ISA bus 0
    //

    AddressSpace = 0;
    flag = HalTranslateBusAddress (
                Isa, 0,
                PhysAddr,
                &AddressSpace,
                &PhysAddr
                );

    if (AddressSpace != 0  ||  !flag) {
        return TRUE;
    }

    //
    // Map into virtual address space
    //

    VirtualAddress = MmMapIoSpace (
                    PhysAddr,
                    0x10000,        // 64k
                    TRUE
                    );
    Apm.VirtualAddress[Index] = VirtualAddress;

    //
    // Map virtual address to selector:0 address
    //

    SegBase = (ULONG) VirtualAddress;
    GdtEntry->BaseLow               = (USHORT) (SegBase & 0xffff);
    GdtEntry->HighWord.Bits.BaseMid = (UCHAR)  (SegBase >> 16) & 0xff;
    GdtEntry->HighWord.Bits.BaseHi  = (UCHAR)  (SegBase >> 24) & 0xff;

    KeI386SetGdtSelector (Apm.Selector[Index], GdtEntry);
    return FALSE;
}


NTSTATUS
ApmFunction (
    IN ULONG      ApmFunctionCode,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx
    )
/*++

Routine Description:

    Call APM BIOS with ApmFunctionCode and appropriate arguments

Arguments:

    ApmFunctionCode     Apm function code
    Ebx                 Ebx param to APM BIOS
    Ecx                 Ecx param to APM BIOS

Return Value:

    STATUS_SUCCESS with Ebx, Ebx
    otherwise an NTSTATUS code

--*/
{
    KIRQL           OldIrql;
    ULONG           ApmStatus;
    CONTEXT         Regs;


    if (!Apm.Selector[0]) {

        //
        // Attempting to call APM BIOS without a sucessfull connection
        //

        DrDebug(APM_INFO,("APM: ApmFunction - APM not initialized\n"));
        DrDebug(APM_INFO,
            ("APM: ApmFunction failing function %x\n", ApmFunctionCode));
        return STATUS_UNSUCCESSFUL;
    }

//DbgPrint("APM: ApmFunction: %08lx Ebx: %08lx Ecx: %08lx\n", ApmFunctionCode, *Ebx, *Ecx);


    //
    // Serialize calls into the APM bios
    //
    KeAcquireSpinLock(&Apm.CallLock, &OldIrql);
    ApmCallActive += 1;

    //
    // ASM interface to call the BIOS
    //

    //
    // Fill in general registers for 16bit bios call.
    // Note: only the following registers are passed.  Specifically,
    // SS and ESP are not passed and are generated by the system.
    //

    Regs.ContextFlags = CONTEXT_INTEGER | CONTEXT_SEGMENTS;

    Regs.Eax    = ApmFunctionCode;
    Regs.Ebx    = *Ebx;
    Regs.Ecx    = *Ecx;
    Regs.Edx    = 0;
    Regs.Esi    = 0;
    Regs.Edi    = 0;
    Regs.SegGs  = 0;
    Regs.SegFs  = 0;
    Regs.SegEs  = Apm.Selector[1];
    Regs.SegDs  = Apm.Selector[1];
    Regs.SegCs  = Apm.Selector[0];
    Regs.Eip    = Apm.Code16BitOffset;
    Regs.EFlags = 0x200;    // interrupts enabled

    ApmCallEax = Regs.Eax;
    ApmCallEbx = Regs.Ebx;
    ApmCallEcx = Regs.Ecx;

    //
    // call the 16:16 bios function
    //

    KeI386Call16BitFunction (&Regs);

    ApmCallActive -= 1;

    //
    // Release serialization
    //
    KeReleaseSpinLock(&Apm.CallLock, OldIrql);

    //
    // Get the results
    //

    ApmStatus = 0;
    if (Regs.EFlags & 0x1) {        // check carry flag
        ApmStatus = (Regs.Eax >> 8) & 0xff;
    }

    *Ebx = Regs.Ebx;
    *Ecx = Regs.Ecx;

    //
    // save for debug use
    //
    if (ApmStatus) {
        if (ApmLogErrorCode != 0) {
            ApmLogErrorFunction = ApmFunctionCode;
            ApmLogErrorCode = ApmStatus;
        }
    }

    //
    // log specific errors of value to the user
    //
    if (ApmFunctionCode == APM_SET_POWER_STATE) {
        if (ApmStatus != 0)
        {
            NtApmLogError(NTAPM_SET_POWER_FAILURE, (UCHAR)ApmStatus);
        }
    }




    DrDebug(APM_INFO,("APM: ApmFunction result is %x\n", ApmStatus));
    return ApmStatus;
}


WCHAR   ApmConvArray[] = {'0', '1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',0};
VOID
NtApmLogError(
    NTSTATUS    ErrorCode,
    UCHAR       ErrorByte
    )
/*++

Routine Description:

    Report the incoming error to the event log.

Arguments:

    ErrorCode - the ntstatus type value which will match the message template
                and get reported to the user.

    ErrorByte - the 1 byte value returned by APM bios

Return Value:

    None.
--*/
{
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    PUCHAR                  p;
    PWCHAR                  pw;

    errorLogPacket = IoAllocateErrorLogEntry(
        NtApmDriverObject,
        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET)+8)
        );

    if (errorLogPacket != NULL) {
        errorLogPacket->ErrorCode = ErrorCode;
        errorLogPacket->SequenceNumber = ApmErrorLogSequence++;
        errorLogPacket->FinalStatus =  STATUS_UNSUCCESSFUL;
        errorLogPacket->UniqueErrorValue = 0;
        errorLogPacket->NumberOfStrings = 1;
        errorLogPacket->RetryCount = 0;
        errorLogPacket->MajorFunctionCode = 0;
        errorLogPacket->DeviceOffset.HighPart = 0;
        errorLogPacket->DeviceOffset.LowPart = 0;
        errorLogPacket->DumpDataSize = 0;

        //
        // why our own conversion code?  because we can't get the fine
        // RTL routines to put the data in the right sized output buffer
        //
        p = (PUCHAR) &(errorLogPacket->DumpData[0]);
        pw = (PWCHAR)p;

        pw[0] = ApmConvArray[(ULONG)((ErrorByte & 0xf0)>>4)];
        pw[1] = ApmConvArray[(ULONG)(ErrorByte & 0xf)];
        pw[2] = L'\0';

        errorLogPacket->StringOffset =
            ((PUCHAR)(&(errorLogPacket->DumpData[0]))) - ((PUCHAR)errorLogPacket);
        IoWriteErrorLogEntry(errorLogPacket);
    }


    return;
}



NTSTATUS
ApmSuspendSystem (
    VOID
    )

/*++

Routine Description:

    Suspend the system

Arguments:

    none

Return Value:

    STATUS_SUCCESS if the computer was suspended & then resumed

--*/
{
    ULONG       Ebx, Ecx;
    NTSTATUS    Status;

    //
    // Use ApmFunction to suspend machine
    //

    DrDebug(APM_L2,("APM: ApmSuspendSystem: enter\n"));
    Ebx = APM_DEVICE_ALL;
    Ecx = APM_SET_SUSPEND;
    Status = ApmFunction (APM_SET_POWER_STATE, &Ebx, &Ecx);
    DrDebug(APM_L2,("APM: ApmSuspendSystem: exit\n"));
    return Status;
}


VOID
ApmTurnOffSystem(
    VOID
    )

/*++

Routine Description:

    Turn the system off.

Arguments:

    none


--*/
{
    ULONG       Ebx, Ecx;
    NTSTATUS    Status;

    //
    // Use ApmFunction to put machine into StandBy mode
    //
    DrDebug(APM_L2,("APM: ApmTurnOffSystem: enter\n"));
    Ebx = APM_DEVICE_ALL;
    Ecx = APM_SET_OFF;
    Status = ApmFunction (APM_SET_POWER_STATE, &Ebx, &Ecx);
    DrDebug(APM_L2,("APM: ApmTurnOffSystem: exit\n"));
    return;
}

VOID
ApmInProgress(
    VOID
    )
/*++

Routine Description:

    This routine informs the BIOS to cool its jets for 5 seconds
    while we continue to operate

Arguments:

    none

Return Value:

    STATUS_SUCCESS if the computer was suspended & then resumed

--*/
{
    ULONG       Ebx, Ecx;
    NTSTATUS    Status;

    //
    // Use ApmFunction to tell BIOS to cool its heals
    //

    Ebx = APM_DEVICE_ALL;
    Ecx = APM_SET_PROCESSING;
    Status = ApmFunction (APM_SET_POWER_STATE, &Ebx, &Ecx);
    return;
}


ULONG
ApmCheckForEvent (
    VOID
    )

/*++

Routine Description:

    Poll for APM event

Arguments:

Return Value:

    We return:
        APM_DO_code from apmp.h

        APM_DO_NOTHING 0
        APM_DO_SUSPEND 1
        APM_DO_STANDBY 2
        APM_DO_FIXCLOCK 3
        APM_DO_NOTIFY  4
        APM_DO_CRITICAL_SUSPEND 5

--*/
{
    NTSTATUS    Status;
    ULONG       Ebx, Ecx;
    ULONG       returnvalue;

    //
    // Read an event.  Might get nothing.
    //

    returnvalue = APM_DO_NOTHING;

    Ebx = 0;
    Ecx = 0;
    Status = ApmFunction (APM_GET_EVENT, &Ebx, &Ecx);

    if (Status != STATUS_SUCCESS) {
        return returnvalue;
    }

    //
    // Handle APM reported event
    //

    DrDebug(APM_L2,("APM: ApmCheckForEvent, code is %d\n", Ebx));

    switch (Ebx) {

        //
        // say wer're working on it and set up for standby
        //
        case APM_SYS_STANDBY_REQUEST:
        case APM_USR_STANDBY_REQUEST:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, standby request\n"));
            ApmInProgress();
            returnvalue = APM_DO_STANDBY;
            break;

        //
        // say we're working on it and set up for suspend
        //
        case APM_SYS_SUSPEND_REQUEST:
        case APM_USR_SUSPEND_REQUEST:
        case APM_BATTERY_LOW_NOTICE:
            DrDebug(APM_L2,
                ("APM: ApmCheckForEvent, suspend or battery low\n"));
            ApmInProgress();
            returnvalue = APM_DO_SUSPEND;
            break;

        //
        // Say we're working on it, and setup for CRITICAL suspend
        //
        case APM_CRITICAL_SYSTEM_SUSPEND_REQUEST:
            DrDebug(APM_L2, ("APM: Apmcheckforevent, critical suspend\n"));
            ApmInProgress();
            returnvalue = APM_DO_CRITICAL_SUSPEND;
            break;

        //
        // ignore this because we have no idea what to do with it
        //
        case APM_CRITICAL_RESUME_NOTICE:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, critical resume\n"));
            break;


        case APM_UPDATE_TIME_EVENT:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, update time\n"));
            returnvalue = APM_DO_FIXCLOCK;
            break;

        case APM_POWER_STATUS_CHANGE_NOTICE:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, update battery\n"));
            returnvalue = APM_DO_NOTIFY;
            break;

        case APM_NORMAL_RESUME_NOTICE:
        case APM_STANDBY_RESUME_NOTICE:
        case APM_CAPABILITIES_CHANGE_NOTICE:

            //
            // ignore these because we don't care and there's nothing to do
            //

            DrDebug(APM_L2,
                ("APM: ApmCheckForEvent, non-interesting event\n"));
            break;

        default:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, out of range event\n"));
            break;
    } //switch

    return returnvalue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\apmp.h ===
/*++

Module Name:

    apmp.h

Abstract:

Author:

Revision History:

--*/


//
// APM Bios interface information
//

typedef struct _APM_CONNECT {
    KSPIN_LOCK          CallLock;
    ULONG               Code16BitOffset;
    USHORT              Selector[4];
    PVOID               VirtualAddress[4];
} APM_CONNECT, *PAPM_CONNTECT;

///
// Apm.c
//

NTSTATUS
ApmInitializeConnection (
    VOID
    );

ULONG
ApmCallBios (
    IN ULONG ApmFunctionCode,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx
    );


VOID
ApmGetBatteryStatus (
    );

#define  APM_DO_NOTHING 0
#define  APM_DO_SUSPEND 1
#define  APM_DO_STANDBY 2
#define  APM_DO_FIXCLOCK 3
#define  APM_DO_NOTIFY  4
#define  APM_DO_CRITICAL_SUSPEND 5

ULONG
ApmCheckForEvent (
    VOID
    );

NTSTATUS
ApmSuspendSystem (
    VOID
    );

NTSTATUS
ApmStandBySystem (
    VOID
    );

VOID
ApmTurnOffSystem (
    VOID
    );

NTSTATUS
ApmFunction (
    IN ULONG      ApmFunctionCode,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\apmbatt\i386\apmbpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    apmbpnp.c

Abstract:

    Control Method Battery Plug and Play support

Author:

    Ron Mosgrove

Environment:

    Kernel mode

Revision History:

--*/

#include "ApmBattp.h"
#include <initguid.h>
#include <wdmguid.h>
#include <ntapm.h>

//
// Device Names
//
PCWSTR                      ApmBattDeviceName    = L"\\Device\\ApmBattery";
//PCWSTR                      AcAdapterName       = L"\\Device\\AcAdapter";

//
// This is a special Hack as part of this general APM special hack
//
PVOID   ApmGlobalClass = NULL;

//
// Prototypes
//
NTSTATUS
ApmBattAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
ApmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

#if 0
NTSTATUS
ApmBattAddAcAdapter(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );
#endif

NTSTATUS
ApmBattCreateFdo(
    IN PDRIVER_OBJECT   DriverObject,
    IN ULONG            DeviceId,
    OUT PDEVICE_OBJECT  *NewDeviceObject
    );

NTSTATUS
ApmBattCompleteRequest(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );


NTSTATUS
ApmBattAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each ApmBatt controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{

    PAGED_CODE();


    ApmBattPrint (APMBATT_TRACE, ("ApmBattAddDevice\n"));
    ASSERT(DeviceCount == 0);

    if (DeviceCount != 0) {
        return STATUS_UNSUCCESSFUL;
    }
    DeviceCount = 1;

    ApmBattPrint ((APMBATT_TRACE | APMBATT_PNP), ("ApmBattAddDevice: Entered with pdo %x\n", Pdo));

    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //
        ApmBattPrint((APMBATT_WARN | APMBATT_PNP), ("ApmBattAddDevice: Asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;

    } else {
        //
        // This device is a control-method battery
        //
        return (ApmBattAddBattery (DriverObject, Pdo));
    }
    return STATUS_UNSUCCESSFUL;
}



NTSTATUS
ApmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )
/*++

Routine Description:

    This routine creates a functional device object for a CM battery,  and attache it
    to the physical device object for the battery.

Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT          Fdo = NULL;
    PDEVICE_OBJECT          lowerDevice = NULL;
    PCM_BATT                ApmBatt;
    NTSTATUS                Status;
    BATTERY_MINIPORT_INFO   BattInit;
    ULONG                   uniqueId;
    PNTAPM_LINK             pparms;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_PNP), ("ApmBattAddBattery: pdo %x\n", Pdo));
//DbgBreakPoint();

    uniqueId = 0;

    //
    // Create and initialize the new functional device object
    //
    Status = ApmBattCreateFdo(DriverObject, uniqueId, &Fdo);

    if (!NT_SUCCESS(Status)) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattAddBattery: error (0x%x) creating Fdo\n", Status));
        return Status;
    }

    //
    // Initialize Fdo device extension data
    //

    ApmBatt = (PCM_BATT) Fdo->DeviceExtension;
    ApmBatt->Fdo = Fdo;
    ApmBatt->Pdo = Pdo;

    //
    // Layer our FDO on top of the PDO
    //

    lowerDevice = IoAttachDeviceToDeviceStack(Fdo,Pdo);

    //
    //  No status. Do the best we can.
    //
    if (!lowerDevice) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattAddBattery: Could not attach to lower device\n"));
        return STATUS_UNSUCCESSFUL;
    }

    ApmBatt->LowerDeviceObject = lowerDevice;

    //
    //  Attach to the Class Driver
    //

    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = ApmBatt;
    BattInit.QueryTag            = ApmBattQueryTag;
    BattInit.QueryInformation    = ApmBattQueryInformation;
    BattInit.SetInformation      = NULL;                  // tbd
    BattInit.QueryStatus         = ApmBattQueryStatus;
    BattInit.SetStatusNotify     = ApmBattSetStatusNotify;
    BattInit.DisableStatusNotify = ApmBattDisableStatusNotify;

    BattInit.Pdo                 = Pdo;
    BattInit.DeviceName          = ApmBatt->DeviceName;

    Status = BatteryClassInitializeDevice (&BattInit, &ApmBatt->Class);
    ApmGlobalClass = ApmBatt->Class;

    if (!NT_SUCCESS(Status)) {
        //
        //  if we can't attach to class driver we're toast
        //
        ApmBattPrint(APMBATT_ERROR, ("ApmBattAddBattery: error (0x%x) registering with class\n", Status));
        return Status;
    }

    //
    // link up with APM driver (if we can't we're toast)
    //
    // Should be able to just call into Pdo.
    //
    // DO WORK HERE
    //
    Irp = IoAllocateIrp((CCHAR) (Pdo->StackSize+2), FALSE);
    if (!Irp) {
        return STATUS_UNSUCCESSFUL;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IrpSp->MinorFunction = 0;
    IrpSp->DeviceObject = Pdo;
    pparms = (PNTAPM_LINK) &(IrpSp->Parameters.Others);
    pparms->Signature = NTAPM_LINK_SIGNATURE;
    pparms->Version = NTAPM_LINK_VERSION;
    pparms->BattLevelPtr = (ULONG)(&(NtApmGetBatteryLevel));
    pparms->ChangeNotify = (ULONG)(&(ApmBattPowerNotifyHandler));

    IoSetCompletionRoutine(Irp, ApmBattCompleteRequest, NULL, TRUE, TRUE, TRUE);

    if (IoCallDriver(Pdo, Irp) != STATUS_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }

//DbgPrint("apmbatt: NtApmGetBatteryLevel: %08lx\n", NtApmGetBatteryLevel);

    return STATUS_SUCCESS;
}

NTSTATUS
ApmBattCompleteRequest(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Completion routine for ioctl call to apm.

Arguments:

    DeviceObject      - The target device which the request was sent

    Irp               - The irp completing

    Context           - The requestors completion routine

Return Value:


--*/
{
    IoFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
ApmBattCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    IN ULONG                DeviceId,
    OUT PDEVICE_OBJECT      *NewFdo
    )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Control Method Battery PDO.

Arguments:

    DriverObject    - a pointer to the driver object this is created under
    NewFdo          - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    PUNICODE_STRING         unicodeString;
    PDEVICE_OBJECT          Fdo;
    NTSTATUS                Status;
    PCM_BATT                ApmBatt;
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_PNP), ("ApmBattCreateFdo, Battery Id=%x\n", DeviceId));

    //
    // Allocate the UNICODE_STRING for the device name
    //

    unicodeString = ExAllocatePoolWithTag (
                        PagedPool,
                        sizeof (UNICODE_STRING) + MAX_DEVICE_NAME_LENGTH,
                        'taBC'
                        );

    if (!unicodeString) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattCreateFdo: could not allocate unicode string\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    unicodeString->MaximumLength    = MAX_DEVICE_NAME_LENGTH;
    unicodeString->Length           = 0;
    unicodeString->Buffer           = (PWCHAR) (unicodeString + 1);

    //
    // Create the PDO device name based on the battery instance
    //

    numberString.MaximumLength  = 10;
    numberString.Buffer         = &numberBuffer[0];

    RtlIntegerToUnicodeString (DeviceId, 10, &numberString);
    RtlAppendUnicodeToString  (unicodeString, (PWSTR) ApmBattDeviceName);
    RtlAppendUnicodeToString  (unicodeString, &numberString.Buffer[0]);


    Status = IoCreateDevice(
                DriverObject,
                sizeof (CM_BATT),
                unicodeString,
                FILE_DEVICE_BATTERY,
                0,
                FALSE,
                &Fdo
                );

    if (Status != STATUS_SUCCESS) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattCreateFdo: error (0x%x) creating device object\n", Status));
        ExFreePool (unicodeString);
        return(Status);
    }

    Fdo->Flags |= DO_BUFFERED_IO;
    Fdo->Flags |= DO_POWER_PAGABLE;             // Don't want power Irps at irql 2
    Fdo->Flags &= ~DO_DEVICE_INITIALIZING;
    Fdo->StackSize = 2;

    //
    // Initialize Fdo device extension data
    //

    ApmBatt = (PCM_BATT) Fdo->DeviceExtension;
    RtlZeroMemory(ApmBatt, sizeof(CM_BATT));
    ApmBatt->DeviceName      = unicodeString;
    ApmBatt->DeviceNumber    = (USHORT) DeviceId;
    ApmBatt->DeviceObject    = Fdo;
    *NewFdo = Fdo;

    ApmBattPrint((APMBATT_TRACE | APMBATT_PNP), ("ApmBattCreateFdo: Created FDO %x\n", Fdo));
    return STATUS_SUCCESS;
}



NTSTATUS
ApmBattPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            ApmBatt;
    NTSTATUS            Status;

    PAGED_CODE();

    ApmBattPrint (APMBATT_TRACE, ("ApmBattPnpDispatch\n"));

    Status = STATUS_NOT_IMPLEMENTED;

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ApmBatt = DeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    switch (irpStack->MinorFunction) {

        case IRP_MN_START_DEVICE:
                //
                // if the Add succeeded, we are actually started...
                //
                ApmBattPrint (APMBATT_PNP, ("ApmBattPnpDispatch: IRP_MN_START_DEVICE\n"));
                Status = STATUS_SUCCESS;
                Irp->IoStatus.Status = Status;
                ApmBattCallLowerDriver(Status, ApmBatt->LowerDeviceObject, Irp);
                break;


        case IRP_MN_QUERY_DEVICE_RELATIONS:
                ApmBattPrint (APMBATT_PNP, ("ApmBattPnpDispatch: IRP_MN_QUERY_DEVICE_RELATIONS - type (%d)\n",
                            irpStack->Parameters.QueryDeviceRelations.Type));
                //
                // Just pass it down
                //
                ApmBattCallLowerDriver(Status, ApmBatt->LowerDeviceObject, Irp);
                break;


        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
                Status = Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                IoCompleteRequest(Irp, 0);
                break;

        default:
                ApmBattPrint (APMBATT_PNP,
                        ("ApmBattPnpDispatch: Unimplemented minor %0x\n",
                        irpStack->MinorFunction));
                //
                // Unimplemented minor, Pass this down to ACPI
                //
                ApmBattCallLowerDriver(Status, ApmBatt->LowerDeviceObject, Irp);
                break;
    }

    return Status;
}



NTSTATUS
ApmBattPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            ApmBatt;
    NTSTATUS            Status;

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_POWER), ("ApmBattPowerDispatch\n"));

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ApmBatt = DeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    switch (irpStack->MinorFunction) {

        case IRP_MN_WAIT_WAKE:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_WAIT_WAKE\n"));
                break;

        case IRP_MN_POWER_SEQUENCE:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_POWER_SEQUENCE\n"));
                break;

        case IRP_MN_SET_POWER:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_SET_POWER\n"));
                TagValue++;
                break;

        case IRP_MN_QUERY_POWER:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_QUERY_POWER\n"));
                break;

        default:
                ApmBattPrint(APMBATT_LOW, ("ApmBattPowerDispatch: minor %d\n",
                        irpStack->MinorFunction));
                break;
    }

    //
    // What do we do with the irp?
    //
    PoStartNextPowerIrp( Irp );
    if (ApmBatt->LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        Status = PoCallDriver( ApmBatt->LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        Status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\apmpnp.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    apmpnp.c

Abstract:

    This module contains contains the plugplay calls
    needed to make ntapm.sys work.

Author:

    Bryan Willman
    Kenneth D. Ray
    Doron J. Holan

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#include "ntapmp.h"
#include "ntapmdbg.h"
#include "ntapm.h"
//#include "stdio.h"

//
// Globals
//
PDEVICE_OBJECT  NtApm_ApmBatteryPdo = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, NtApm_AddDevice)
#pragma alloc_text (PAGE, NtApm_PnP)
#pragma alloc_text (PAGE, NtApm_FDO_PnP)
#pragma alloc_text (PAGE, NtApm_PDO_PnP)
#pragma alloc_text (PAGE, NtApm_Power)
#pragma alloc_text (PAGE, NtApm_FDO_Power)
#pragma alloc_text (PAGE, NtApm_PDO_Power)
#pragma alloc_text (PAGE, NtApm_CreatePdo)
#pragma alloc_text (PAGE, NtApm_InitializePdo)
#endif

NTSTATUS
NtApm_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    BusDeviceObject - Device object representing the bus.  That to which we
                      attach a new FDO.

    DriverObject - This very self referenced driver.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    deviceData;
    UNICODE_STRING      deviceNameUni;
    PWCHAR              deviceName;
    ULONG               nameLength;

    PAGED_CODE ();

    DrDebug(PNP_INFO, ("ntapm Add Device: 0x%x\n", BusPhysicalDeviceObject));

    status = IoCreateDevice (
                    DriverObject,  // our driver object
                    sizeof (FDO_DEVICE_DATA), // device object extension size
                    NULL, // FDOs do not have names
                    FILE_DEVICE_BUS_EXTENDER,
                    0, // No special characteristics
                    TRUE, // our FDO is exclusive
                    &deviceObject); // The device object created

    if (!NT_SUCCESS (status)) {
        return status;
    }

    deviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
    RtlFillMemory (deviceData, sizeof (FDO_DEVICE_DATA), 0);

    deviceData->IsFDO = TRUE;
    deviceData->Self = deviceObject;
    deviceData->UnderlyingPDO = BusPhysicalDeviceObject;

    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    deviceData->TopOfStack = IoAttachDeviceToDeviceStack (
                                deviceObject,
                                BusPhysicalDeviceObject
                                );


    if (!deviceData->TopOfStack) {
        IoDeleteDevice(deviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    status = ApmAddHelper();

    if (!NT_SUCCESS(status)) {
        IoDetachDevice(deviceData->TopOfStack);
        IoDeleteDevice(deviceObject);
    }

    deviceObject->Flags |= DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
NtApm_FDO_PnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Pirp,
    IN PVOID            Context
    );

NTSTATUS
NtApm_PnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
Routine Description:
    Answer the plithera of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_PNP == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        DrDebug(PNP_INFO, ("ntapm PNP: Functional DO: %x IRP: %x\n", DeviceObject, Irp));

        status = NtApm_FDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PFDO_DEVICE_DATA) commonData);
    } else {
        DrDebug(PNP_INFO, ("ntapm: PNP: Physical DO: %x IRP: %x\n", DeviceObject, Irp));

        status = NtApm_PDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PPDO_DEVICE_DATA) commonData);
    }

    return status;
}

NTSTATUS
NtApm_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KIRQL       irql;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations;
    PIO_STACK_LOCATION  stack;
    ULONG       battresult;

    PAGED_CODE ();

    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (IrpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //


        DrDebug(PNP_INFO, ("ntapm: Start Device\n"));

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                NtApm_FDO_PnPComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        break;


    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (IrpStack->Parameters.QueryDeviceRelations.Type != BusRelations) {
            //
            // We don't support this
            //
            goto NtApm_FDO_PNP_DEFAULT;
        }

        //
        // In theory, APM should be fired up by now.
        // So call off into it to see if there is any sign
        // of a battery on the box.  If there is NOT, don't
        // export the PDOs for the battery objects
        //
        battresult = DoApmReportBatteryStatus();
        if (battresult & NTAPM_NO_SYS_BATT) {
            //
            // it appears that the machine does not have
            // a battery.  so don't export battery driver PDOs.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(DeviceData->TopOfStack, Irp);
        }

        DrDebug(PNP_INFO, ("ntapm: Query Relations "));

        //
        // create PDO for apm battery
        //
        if (NtApm_ApmBatteryPdo == NULL) {
            status = NtApm_CreatePdo(
                        DeviceData,
                        NTAPM_PDO_NAME_APM_BATTERY,
                        &NtApm_ApmBatteryPdo
                        );
            if (!NT_SUCCESS(status)) {
                goto NtApm_DONE;
            }
        }

        NtApm_InitializePdo(NtApm_ApmBatteryPdo, DeviceData, NTAPM_ID_APM_BATTERY);

        //
        // Tell PNP about our two child PDOs.
        //
        i = (Irp->IoStatus.Information == 0) ? 0 :
            ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

        //
        // above should be count of PDOs
        // make a new structure and our PDO to the end
        //

        //
        // Need to allocate a new relations structure and add our
        // PDOs to it.
        //
        length = sizeof(DEVICE_RELATIONS) + ((i + 1) * sizeof (PDEVICE_OBJECT));

        relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, length);

        if (relations == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto NtApm_DONE;
        }

        //
        // Copy in the device objects so far
        //
        if (i) {
            RtlCopyMemory (
                      relations->Objects,
                      ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                      i * sizeof (PDEVICE_OBJECT));
        }
        relations->Count = i + 1;

        //
        // add the apm battery PDO to the list
        //
        ObReferenceObject(NtApm_ApmBatteryPdo);
        relations->Objects[i] = NtApm_ApmBatteryPdo;

        //
        // Replace the relations structure in the IRP with the new
        // one.
        //
        if (Irp->IoStatus.Information != 0) {
            ExFreePool ((PVOID) Irp->IoStatus.Information);
        }
        Irp->IoStatus.Information = (ULONG) relations;

        //
        // Set up and pass the IRP further down the stack
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        return status;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        status = STATUS_UNSUCCESSFUL;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        Irp->IoStatus.Status = STATUS_SUCCESS;  // we're lying, it's more like noop
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver (DeviceData->TopOfStack, Irp);
        break;

NtApm_FDO_PNP_DEFAULT:
    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver (DeviceData->TopOfStack, Irp);
    }

NtApm_DONE:
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
NtApm_FDO_PnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
NtApm_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{
    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   information;
    PWCHAR                  buffer, buffer2;
    ULONG                   length, length2, i, j;
    NTSTATUS                status;
    KIRQL                   oldIrq;
    PDEVICE_RELATIONS       relations;

    PAGED_CODE ();

    status = Irp->IoStatus.Status;

    //
    // NB: since we are a bus enumerator, we have no one to whom we could
    // defer these irps.  Therefore we do not pass them down but merely
    // return them.
    //

    switch (IrpStack->MinorFunction) {
    case IRP_MN_QUERY_CAPABILITIES:

        DrDebug(PNP_INFO, ("ntapm: Query Caps \n"));

        //
        // Get the packet.
        //
        deviceCapabilities = IrpStack->Parameters.DeviceCapabilities.Capabilities;

        deviceCapabilities->UniqueID = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_ID:
        // Query the IDs of the device
        DrDebug(PNP_INFO, ("ntapm: QueryID: 0x%x\n", IrpStack->Parameters.QueryId.IdType));

        switch (IrpStack->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            // this can be the same as the hardware ids (which requires a multi
            // sz) ... we are just allocating more than enough memory
        case BusQueryHardwareIDs:
            // return a multi WCHAR (null terminated) string (null terminated)
            // array for use in matching hardare ids in inf files;
            //

            buffer = DeviceData->HardwareIDs;

            while (*(buffer++)) {
                while (*(buffer++)) {
                    ;
                }
            }
            length = (buffer - DeviceData->HardwareIDs) * sizeof (WCHAR);

            buffer = ExAllocatePool (PagedPool, length);
            if (buffer) {
                RtlCopyMemory (buffer, DeviceData->HardwareIDs, length);
                Irp->IoStatus.Information = (ULONG) buffer;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            break;

        case BusQueryInstanceID:
            //
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.
            //
            //
            // return 0000 for all devices and have the flag set to not unique
            //
            length = APM_INSTANCE_IDS_LENGTH * sizeof(WCHAR);
            buffer = ExAllocatePool(PagedPool, length);

            if (buffer != NULL) {
                RtlCopyMemory(buffer, APM_INSTANCE_IDS, length);
                Irp->IoStatus.Information = (ULONG_PTR)buffer;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            break;

        case BusQueryCompatibleIDs:
            // The generic ids for installation of this pdo.
            break;

        }
        break;

    case IRP_MN_START_DEVICE:
        DrDebug(PNP_INFO, ("ntapm: Start Device \n"));
        // Here we do what ever initialization and ``turning on'' that is
        // required to allow others to access this device.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        DrDebug(PNP_INFO, ("ntapm: remove, stop, or Q remove or Q stop\n"));
        //
        // disallow Stop or Remove, since we don't want to test
        // disengagement from APM if we don't have to
        //
        status = STATUS_UNSUCCESSFUL;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
        DrDebug(PNP_INFO, ("ntapm: Cancel Stop Device or Cancel Remove \n"));
        status = STATUS_SUCCESS;  // more like "noop" than success
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (IrpStack->Parameters.QueryDeviceRelations.Type != TargetDeviceRelation) {

            //
            // Somebody else can handle this.
            //
            break;
        }

        ASSERT(((PULONG_PTR)Irp->IoStatus.Information) == NULL);

        relations = (PDEVICE_RELATIONS) ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

        if (relations == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            Irp->IoStatus.Information = (ULONG_PTR) relations;
            relations->Count = 1;
            relations->Objects[0] = DeviceObject;
            ObReferenceObject(DeviceObject);
            status = STATUS_SUCCESS;
        }

        break;
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG: // we have no config space
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_INTERFACE: // We do not have any non IRP based interfaces.
    default:
        DrDebug(PNP_INFO, ("ntapm: PNP Not handled 0x%x\n", IrpStack->MinorFunction));
        // this is a leaf node
        // status = STATUS_NOT_IMPLEMENTED
        // For PnP requests to the PDO that we do not understand we should
        // return the IRP WITHOUT setting the status or information fields.
        // They may have already been set by a filter (eg acpi).
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
NtApm_CreatePdo (
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              PdoName,
    PDEVICE_OBJECT *    PDO
    )
{
    UNICODE_STRING      pdoUniName;
    NTSTATUS            status;

    PAGED_CODE ();
//DbgBreakPoint();

    //
    // Create the PDOs
    //
    RtlInitUnicodeString (&pdoUniName, PdoName);
    DrDebug(PNP_INFO, ("ntapm: CreatePdo: PDO Name: %ws\n", PdoName));

    status = IoCreateDevice(
                FdoData->Self->DriverObject,
                sizeof (PDO_DEVICE_DATA),
                &pdoUniName,
                FILE_DEVICE_BUS_EXTENDER,
                0,
                FALSE,
                PDO
                );
    DrDebug(PNP_L2, ("ntapm: CreatePdo: status = %08lx\n", status));

    if (!NT_SUCCESS (status)) {
        *PDO = NULL;
    }

    return status;
}

VOID
NtApm_InitializePdo(
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              Id
    )
{
    PPDO_DEVICE_DATA pdoData;

    PAGED_CODE ();

    pdoData = (PPDO_DEVICE_DATA)  Pdo->DeviceExtension;

    DrDebug(PNP_INFO, ("ntapm: pdo 0x%x, extension 0x%x\n", Pdo, pdoData));

    //
    // Initialize the rest
    //
    pdoData->IsFDO = FALSE;
    pdoData->Self =  Pdo;

    pdoData->ParentFdo = FdoData->Self;

    pdoData->HardwareIDs = Id;

    pdoData->UniqueID = 1;

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;
    Pdo->Flags |= DO_POWER_PAGABLE;

}

NTSTATUS
NtApm_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
    We do nothing special for power;

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PCOMMON_DEVICE_DATA commonData;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_POWER == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        status = NtApm_FDO_Power ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension,Irp);
    } else {
        status = NtApm_PDO_Power ((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension,Irp);
    }

    return status;
}


NTSTATUS
NtApm_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    )
{
    PIO_STACK_LOCATION  stack;

    PAGED_CODE ();

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(Data->TopOfStack, Irp);
}

NTSTATUS
NtApm_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;

    stack = IoGetCurrentIrpStackLocation (Irp);
    switch (stack->MinorFunction) {
        case IRP_MN_SET_POWER:
            if ((stack->Parameters.Power.Type == SystemPowerState)  &&
                (stack->Parameters.Power.State.SystemState == PowerSystemWorking))
            {
                //
                // system has just returned to the working state
                // assert the user is present (they must be for the APM case)
                // so that the display will light up, idle timers behave, etc.
                //
                PoSetSystemState(ES_USER_PRESENT);
            }
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_POWER:
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        default:
            status = Irp->IoStatus.Status;
            break;
    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\ntapm.c ===
/*++

Module Name:

    ntapm.c

Abstract:

    OS source for ntapm.sys

Author:


Environment:

    Kernel mode

Notes:

Revision History:

--*/



#include "ntddk.h"
#include "ntpoapi.h"
#include "string.h"
#include "ntcrib.h"
#include "ntapmdbg.h"
#include "apm.h"
#include "apmp.h"
#include "ntapmp.h"
#include <ntapm.h>
#include <poclass.h>
#include <ntapmlog.h>

//
// Global debug flag. There are 3 separate groupings, see ntapmdbg.h for
// break out.
//

ULONG   NtApmDebugFlag = 0;

ULONG   ApmWorks = 0;

WCHAR rgzApmActiveFlag[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ApmActive";
WCHAR rgzApmFlag[] =
    L"Active";

WCHAR rgzAcpiKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI";
WCHAR rgzAcpiStart[] =
    L"Start";


//
// Define driver entry routine.
//

NTSTATUS DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

NTSTATUS ApmDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
IsAcpiMachine(
    VOID
    );

ULONG   DoApmPoll();
NTSTATUS DoApmInitMachine();



VOID (*BattChangeNotify)() = NULL;


#define POLL_INTERVAL   (500)       // 500 milliseconds == 1/2 second

#define APM_POLL_MULTIPLY   (4)     // only call ApmInProgress once every 4 Poll intervals
                                    // which with current values is once every 2 seconds

#define APM_SPIN_LIMIT      (6)     // 6 spin passes, each with a call to ApmInProgress,
                                    // at APM_POLL_MULTIPLY * POLL_INTERVAL time spacing.
                                    // Current values (500, 4, 6) should yield APM bios
                                    // waiting from 12s to 17s, depending on how large
                                    // or small their value of 5s is.

volatile BOOLEAN OperationDone = FALSE;      // used to make some sync between SuspendPollThread
                                    // and ApmSleep and ApmOff work.

//
// Our own driver object.  This is rude, but this is a very weird
// and special driver.  We will pass this to our APM library to
// allow error logging to work.  Note that we don't actually have
// an active IRP around when the error occurs.
//
PDRIVER_OBJECT  NtApmDriverObject = NULL;

//
// Define the local routines used by this driver module.
//

VOID SuspendPollThread(PVOID Dummy);
VOID ApmSleep(VOID);
VOID ApmOff(VOID);



KTIMER PollTimer;



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the laptop driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS    status;
    ULONG       MajorVersion;
    ULONG       MinorVersion;


    //
    // refuse to load on machines with more than 1 cpu
    //
    if (KeNumberProcessors != 1) {
        DrDebug(SYS_INFO, ("ntapm: more than 1 cpu, ntapm will exit\n"));
        return STATUS_UNSUCCESSFUL;
    }


    //
    // refuse to load if version number is not 5.1 or 5.0
    // NOTE WELL: This is a manual version check, do NOT put a system
    //            constant in here.  This driver depends on hacks in
    //            the kernel that will someday go away...
    //
    PsGetVersion(&MajorVersion, &MinorVersion, NULL, NULL);
    if (  !
            (
                ((MajorVersion == 5) && (MinorVersion == 0)) ||
                ((MajorVersion == 5) && (MinorVersion == 1))
            )
    )
    {
        DrDebug(SYS_INFO, ("ntapm: system version number != 5.1, exit\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // refuse to load if ACPI.SYS should be running
    //
    if (IsAcpiMachine()) {
        DrDebug(SYS_INFO, ("ntapm: this is an acpi machine apm exiting\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // init the driver object
    //
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ApmDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = ApmDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ApmDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] = NtApm_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = NtApm_Power;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ApmDispatch;
    DriverObject->DriverExtension->AddDevice = NtApm_AddDevice;
    NtApmDriverObject = DriverObject;

    return STATUS_SUCCESS;
}

BOOLEAN ApmAddHelperDone = FALSE;

NTSTATUS
ApmAddHelper(
    )
/*++

Routine Description:

    We do these things in the Add routine so that we cannot fail
    and leave the Kernel/Hal/Apm chain in a corrupt state.

    This includes linking up with the Hal.

    Turns out the caller doesn't know if this work has already
    been done, so disallow doing it more than once here.

Arguments:

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UCHAR   HalTable[HAL_APM_TABLE_SIZE];
    PPM_DISPATCH_TABLE  InTable;
    HANDLE      ThreadHandle;
    HANDLE      hKey;
    NTSTATUS    status;
    ULONG       flagvalue;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString;
    ULONG       battresult;

    if (ApmAddHelperDone) {
        return STATUS_SUCCESS;
    }
    ApmAddHelperDone = TRUE;


    //
    // call ApmInitMachine so that Bios, etc, can be engaged
    // no suspends can happen before this call.
    //
    if (! NT_SUCCESS(DoApmInitMachine()) )  {
        DrDebug(SYS_INFO, ("ntapm: DoApmInitMachine failed\n"));
        return STATUS_UNSUCCESSFUL;
    }


    //
    // call the hal
    //
    InTable = (PPM_DISPATCH_TABLE)HalTable;
    InTable->Signature = HAL_APM_SIGNATURE;
    InTable->Version = HAL_APM_VERSION;

    //
    // In theory, APM should be fired up by now.
    // So call off into it to see if there is any sign
    // of a battery on the box.
    //
    // If we do not see a battery, then do NOT enable
    // S3, but do allow S4.  This keeps people's machines
    // from puking on failed S3 calls (almost always desktops)
    // while allowing auto-shutdown at the end of hibernate to work.
    //
    battresult = DoApmReportBatteryStatus();
    if (battresult & NTAPM_NO_SYS_BATT) {
        //
        // it appears that the machine does not have
        // a battery, or least APM doesn't report one.
        //
        InTable->Function[HAL_APM_SLEEP_VECTOR] = NULL;
    } else {
        InTable->Function[HAL_APM_SLEEP_VECTOR] = &ApmSleep;
    }

    InTable->Function[HAL_APM_OFF_VECTOR] = &ApmOff;

    status = HalInitPowerManagement(InTable, NULL);

    if (! NT_SUCCESS(status)) {
        DrDebug(SYS_INFO, ("ntapm: HalInitPowerManagement failed\n"));
        return STATUS_UNSUCCESSFUL;
    }


    //
    // From this point on, INIT MUST succeed, otherwise we'll leave
    // the Hal with hanging pointers.  So long as ApmSleep and ApmOff
    // are present in memory, things will be OK (though suspend may
    // not work, the box won't bugcheck.)
    //
    // init periodic timer, init suspend done event, init suspend dpc,
    // create and start poll thread
    //
    status = PsCreateSystemThread(&ThreadHandle,
                                  (ACCESS_MASK) 0L,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &SuspendPollThread,
                                  NULL
                                  );

    //
    // the create didn't work, turns out that some apm functions
    // will still work, so just keep going.
    //
    if (! NT_SUCCESS(status)) {
        DrDebug(SYS_INFO, ("ntapm: could not create thread, but continunuing\n"));
        //        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeTimerEx(&PollTimer, SynchronizationTimer);

    //
    // set a flag in the registry so that code with special hacks
    // based on apm being active can tell we're here and at least
    // nominally running
    //
    RtlInitUnicodeString(&unicodeString, rgzApmActiveFlag);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );

    status = ZwCreateKey(
                &hKey,
                KEY_WRITE,
                &objectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                NULL
                );

    RtlInitUnicodeString(&unicodeString, rgzApmFlag);
    if (NT_SUCCESS(status)) {
        flagvalue = 1;
        ZwSetValueKey(
            hKey,
            &unicodeString,
            0,
            REG_DWORD,
            &flagvalue,
            sizeof(ULONG)
            );
        ZwClose(hKey);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
ApmDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    When an application calls the Laptop driver, it comes here.
    This is NOT the dispatch point for PNP or Power calls.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID outbuffer;
    ULONG outlength;
    PFILE_OBJECT fileObject;
    ULONG   percent;
    BOOLEAN acon;
    PNTAPM_LINK pparms;
    PULONG  p;
    ULONG   t;

    UNREFERENCED_PARAMETER( DeviceObject );


    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    Irp->IoStatus.Information = 0;
    switch (irpSp->MajorFunction) {

        //
        // device control
        //
        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            //
            // Only one valid command, which is to set (or null out) the
            // the link call pointers.
            //
            if (irpSp->MinorFunction == 0) {
                pparms = (PNTAPM_LINK) &(irpSp->Parameters.Others);
                if ((pparms->Signature == NTAPM_LINK_SIGNATURE) &&
                    (pparms->Version == NTAPM_LINK_VERSION))
                {
                    t = (ULONG) (&DoApmReportBatteryStatus);
                    p = (PULONG)(pparms->BattLevelPtr);
                    *p = t;
                    BattChangeNotify = (PVOID)(pparms->ChangeNotify);
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = 0;
                }
            }
            break;

        default:
            //
            // for all other operations, including create/open and close,
            // simply report failure, no matter what the operation is
            //
            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );
    return status;
}

VOID
SuspendPollThread(
    PVOID Dummy
    )
/*++

Routine Description:

    This routine is the laptop suspend polling thread.

Arguments:

    Dummy       Ignored parameter

Return Value:

    None

--*/
{
    LARGE_INTEGER               DueTime;
    ULONG                       LocalSuspendFlag;
    ULONG                       LocalClockFlag;
    KIRQL                       OldIrql;
    POWER_ACTION                SystemAction;
    SYSTEM_POWER_STATE          MinSystemState;
    ULONG                       Flags;
    ULONG                       ApmEvent;
    ULONG                       count, count2;
    LONG                        i,  j;
    ULONG                       BatteryResult, PriorBatteryResult;
    ULONG                       BattPresentMask, PriorBattPresentMask;
    BOOLEAN                     DoANotify;

    PriorBatteryResult = BatteryResult = 0;

    //
    // Start the poll timer going, we'll wait for 1 second,
    // then POLL_INTERVAL milliseconds after that
    //

    DueTime.HighPart = 0;
    DueTime.LowPart = 10*1000*1000; // 10 million * 100nano = 1 second
    KeSetTimerEx(&PollTimer, DueTime, POLL_INTERVAL, NULL);

    while (1) {

        KeWaitForSingleObject(&PollTimer, Executive, KernelMode, TRUE, NULL);

        //
        // Call APM to poll for us
        //

        Flags = 0;  // clear all flags

        switch (DoApmPoll()) {

            case APM_DO_CRITICAL_SUSPEND:
                //
                // Here we force the Flags to have the
                // CRITICAL flag set, other than that it's the same thing
                // as for normal suspend and standby
                //
                Flags = POWER_ACTION_CRITICAL;

                /* FALL FALL FALL */

            case APM_DO_SUSPEND:
            case APM_DO_STANDBY:
                //
                // For either Suspend or Standby, call the
                // the system and tell it to suspend us
                //
                DrDebug(SYS_INFO, ("ntapm: about to call OS to suspend\n"));
                SystemAction = PowerActionSleep;
                MinSystemState = PowerSystemSleeping3;
                OperationDone = FALSE;
                ZwInitiatePowerAction(
                    SystemAction,
                    MinSystemState,
                    Flags,
                    TRUE                // async
                    );

                //
                // If we just call ZwInitiatePowerAction, most machines
                // will work, but a few get impatient and try to suspend
                // out from under us before the OS comes back round and
                // does the suspend.  So, we need to call ApmInProgress
                // every so often to make these bioses wait.
                //
                // BUT, if the system is truly wedged, or the suspend fails,
                // we don't want to spin calling ApmInProgress forever, so
                // limit the number of times we do that.  And once the
                // operation is about to happen, stop.
                //
                // Since we're not polling while we're waiting for something
                // to happen, we'll use the poll timer...
                //

                if (OperationDone) goto Done;

                ApmInProgress();
                for (count = 0; count < APM_SPIN_LIMIT; count++) {
                    for (count2 = 0; count2 < APM_POLL_MULTIPLY; count2++) {
                        KeWaitForSingleObject(&PollTimer, Executive, KernelMode, TRUE, NULL);
                    }
                    if (OperationDone) goto Done;
                    ApmInProgress();
                }

                DrDebug(SYS_INFO, ("ntapm: back from suspend\n"));
Done:
                break;

            case APM_DO_NOTIFY:
                //
                // Call out to battery driver with Notify op here
                //
                if (BattChangeNotify) {
                    //DrDebug(SYS_INFO, ("ntapm: about to make notify call\n"));
                    BattChangeNotify();
                    //DrDebug(SYS_INFO, ("ntapm: back from notify call\n"));
                    PriorBatteryResult = DoApmReportBatteryStatus();
                }
                break;

            case APM_DO_FIXCLOCK:
            case APM_DO_NOTHING:
            default:
                //
                // fixing the clock is too scary with other power
                // code doing it, so we don't do it here.
                //
                // nothing is nothing
                //
                // if we don't understand, do nothing
                // (remember, bios will force op under us if it's critical)
                //

                if (BattChangeNotify) {

                    //
                    // we hereby redefine "nothing" to be "check on the
                    // status of the bleeding battery" since not all bioses
                    // tell us what is going on in a timely fashion
                    //
                    DoANotify = FALSE;
                    BatteryResult = DoApmReportBatteryStatus();

                    if ((BatteryResult & NTAPM_ACON) !=
                        (PriorBatteryResult & NTAPM_ACON))
                    {
                        DoANotify = TRUE;
                    }

                    if ((BatteryResult & NTAPM_BATTERY_STATE) !=
                        (PriorBatteryResult & NTAPM_BATTERY_STATE))
                    {
                        DoANotify = TRUE;
                    }

                    i = BatteryResult & NTAPM_POWER_PERCENT;
                    j = PriorBatteryResult & NTAPM_POWER_PERCENT;

                    if (( (i - j) > 25 ) ||
                        ( (j - i) > 25 ))
                    {
                        DoANotify = TRUE;
                    }

                    PriorBattPresentMask = PriorBatteryResult & (NTAPM_NO_BATT | NTAPM_NO_SYS_BATT);
                    BattPresentMask = BatteryResult & (NTAPM_NO_BATT | NTAPM_NO_SYS_BATT);
                    if (BattPresentMask != PriorBattPresentMask) {
                        //
                        // battery either went or reappeared
                        //
                        DoANotify = TRUE;
                    }

                    PriorBatteryResult = BatteryResult;

                    if (DoANotify) {
                        ASSERT(BattChangeNotify);
                        BattChangeNotify();
                    }
                }

                break;

        } // switch
    } // while
}

VOID
ApmSleep(
    VOID
    )
/*++

Routine Description:

    When the OS calls the Hal's S3 vector, the hal calls us here.
    We call APM to put the box to sleep

--*/
{
    OperationDone = TRUE;
    if (ApmWorks) {

        DrDebug(SYS_L2,("ntapm: apmsleep: calling apm to sleep\n"));

        ApmSuspendSystem();

        DrDebug(SYS_L2,("ntapm: apmsleep: back from apm call\n"));

    } else {  // ApmWorks == FALSE

        DrDebug(SYS_INFO, ("ntapm: ApmSleep: no APM attached, Exit\n"));

    }
}

VOID
ApmOff(
    VOID
    )
/*++

Routine Description:

    When the OS calls the Hal's S4 or S5 routines, the hal calls us here.
    We turn the machine off.

--*/
{
    OperationDone = TRUE;
    if (ApmWorks) {

        DrDebug(SYS_L2,("ntapm: ApmOff: calling APM\n"));

        ApmTurnOffSystem();

        DrDebug(SYS_INFO,("ntapm: ApmOff: we are back from Off, uh oh!\n"));
    }
}

NTSTATUS
DoApmInitMachine(
    )
/*++

Routine Description:

    This routine makes the BIOS ready to interact with laptop.sys.
    This code works with APM.

Return Value:

    None

--*/
{
    NTSTATUS    Status;
    ULONG       Ebx, Ecx;

    DrDebug(SYS_INIT,("ApmInitMachine: enter\n"));

    Status = ApmInitializeConnection ();

    if (NT_SUCCESS(Status)) {

        DrDebug(SYS_INIT,("ApmInitMachine: Connection established!\n"));

        //
        // Note that ntdetect (2nd version) will have set apm bios
        // to min of (machine version) and (1.2)
        // (so a 1.1 bios will be set to 1.1, a 1.2 to 1.2, a 1.3 to 1.2
        //

        ApmWorks = 1;

    } else {

        DrDebug(SYS_INIT,("ApmInitMachine: No connection made!\n"));

        ApmWorks = 0;

    }

    DrDebug(SYS_INIT,("ApmInitMachine: exit\n"));
    return Status;
}

ULONG
DoApmPoll(
    )
/*++

Routine Description:

    This routine is called in the ntapm.sys polling loop to poll
    for APM events.  It returns APM_DO_NOTHING unless there is
    actually something meaningful for us to do.  (That is, things
    we don't want and/or don't understand are filtered down to
    APM_DO_NOTHING)

Return Value:

    APM event code.

--*/
{

    DrDebug(SYS_L2,("ApmPoll: enter\n"));

    if (ApmWorks) {

        return ApmCheckForEvent();

    } else { // ApmWorks == FALSE

        DrDebug(SYS_L2,("ApmPoll: no APM attachment, exit\n"));
        return APM_DO_NOTHING;

    }
}

ULONG
DoApmReportBatteryStatus()
/*++

Routine Description:

    This routine queries the BIOS/HW for the state of the power connection
    and the current battery level.

Arguments:

Return Value:

    ULONG, fields defined by NTAPM_POWER_STATE and NTAPM_POWER_PERCENT

--*/
{
    ULONG percent = 100;
    ULONG ac = 1;
    ULONG Status = 0;
    ULONG Ebx = 0;
    ULONG Ecx = 0;
    ULONG flags = 0;
    ULONG result = 0;


    DrDebug(SYS_L2,("ntapm: DoApmReportBatteryStatus: enter\n"));
    if (ApmWorks) {

        //
        // Call APM BIOS and get power status
        //

        Ebx = 1;
        Ecx = 0;
        Status = ApmFunction (APM_GET_POWER_STATUS, &Ebx, &Ecx);

        if (!NT_SUCCESS(Status)) {

            //
            // If we cannot read the power, jam in 50% and power off!
            //
            DrDebug(SYS_INFO,("ntapm: DoApmReportBatteryStatus: Can't get power!\n"));
            percent = 50;
            ac = 0;

        } else {

            //
            // Get battery/AC state -- anything but full 'on-line' means on
            // battery
            //

            ac = (Ebx & APM_LINEMASK) >> APM_LINEMASK_SHIFT;
            if (ac != APM_GET_LINE_ONLINE) {
                ac = 0;
            }
            percent = Ecx & APM_PERCENT_MASK;
        }

    } else {

        DrDebug(SYS_INFO,("ntapm: DoApmReportBatteryStatus: no APM attachment\n"));
        DrDebug(SYS_INFO,("ntapm: Return AC OFF 50% Life\n"));
        percent = 50;
        ac = FALSE;

    }

    flags = 0;
    result = 0;

    if (Ecx & APM_NO_BATT) {
        result |= NTAPM_NO_BATT;
    }

    if (Ecx & APM_NO_SYS_BATT) {
        result |= NTAPM_NO_SYS_BATT;
    }

    if ((percent == 255) || (Ecx & APM_NO_BATT) || (Ecx & APM_NO_SYS_BATT)) {
        percent = 0;
    } else if (percent > 100) {
        percent = 100;
    }

    if ((Ecx & APM_BATT_CHARGING) && (percent < 100)) {
        flags |= BATTERY_CHARGING;
    } else {
        flags |= BATTERY_DISCHARGING;
    }

    if (Ecx & APM_BATT_CRITICAL) {
        flags |= BATTERY_CRITICAL;
        percent = 1;
    }

    if (ac) {
        result |= NTAPM_ACON;
        flags |= BATTERY_POWER_ON_LINE;
    }

    result |= (flags << NTAPM_BATTERY_STATE_SHIFT);


    result |= percent;

    DrDebug(SYS_L2,("ntapm: BatteryLevel: %08lx  Percent: %d  flags: %1x  ac: %1x\n",
        result, percent, flags, ac));

    return result;
}

BOOLEAN
IsAcpiMachine(
    VOID
    )
/*++

Routine Description:

    IsAcpiMachine reports whether the OS thinks this is an ACPI
    machine or not.

Return Value:

    FALSE - this is NOT an acpi machine

    TRUE - this IS an acpi machine

--*/
{
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hKey;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)+1];
    ULONG junk;
    PULONG  pdw;
    ULONG   start;


    RtlInitUnicodeString(&unicodeString, rgzAcpiKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(&hKey, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeString, rgzAcpiStart);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = ZwQueryValueKey(
                hKey,
                &unicodeString,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        if (*pdw == 0) {
            ZwClose(hKey);
            return TRUE;
        }
    }

    ZwClose(hKey);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\ntapmdbg.h ===
/*++

Module Name:

    ntapmdbg.h

Abstract:

    Basic debug print support with granular control

Author:

Environment:

Revision History:

--*/

extern ULONG NtApmDebugFlag;

#if DBG
#define DrDebug(LEVEL,STRING) \
        do { \
            if (NtApmDebugFlag & LEVEL) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define DrDebug(x,y)
#endif

#define SYS_INFO    0x0001
#define SYS_INIT    0x0002
#define SYS_L2      0x0004

#define APM_INFO    0x0010
#define APM_L2      0x0020

#define PNP_INFO    0x0100
#define PNP_L2      0x0200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\bio\bdl\bdl.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    bdl.c

Abstract:

    This module contains the implementation for the
    Microsoft Biometric Device Library

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created May 2002 by Reid Kuhn

--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <strsafe.h>

#include <wdm.h>

#include "bdlint.h"

#ifndef FILE_DEVICE_BIOMETRIC
#define FILE_DEVICE_BIOMETRIC       0x3B
#endif
#define BDL_DRIVER_EXTENSION_ID     ((PVOID) 1)


typedef enum _IRP_ACTION 
{
    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} IRP_ACTION;


typedef struct _POWER_IRP_CONTEXT
{
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension;
    PIRP                            pIrp;
    UCHAR                           MinorFunction;      

} POWER_IRP_CONTEXT, *PPOWER_IRP_CONTEXT;


VOID BDLControlChangeDpc
(
    IN PKDPC pDpc,
    IN PVOID pvContext,
    IN PVOID pArg1,
    IN PVOID pArg2
);


/////////////////////////////////////////////////////////////////////////////////////////
//
// Forward declarations of all the PNP and Power handling functions.
//

NTSTATUS
BDLPnPStart
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp,
    PIO_STACK_LOCATION                  pStackLocation
);

NTSTATUS
BDLPnPQueryStop
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);

NTSTATUS
BDLPnPCancelStop
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);

NTSTATUS
BDLPnPStop
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);

NTSTATUS
BDLPnPQueryRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);

NTSTATUS
BDLPnPCancelRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);

NTSTATUS
BDLHandleRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);

NTSTATUS
BDLPnPRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pDeviceObject,
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);

NTSTATUS
BDLPnPSurpriseRemoval
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
);


NTSTATUS
BDLSystemQueryPower
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
);

NTSTATUS
BDLSystemSetPower
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
);

NTSTATUS
BDLDeviceQueryPower
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
);

NTSTATUS
BDLDeviceSetPower
(
    IN PDEVICE_OBJECT                   pDeviceObject,
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
);


#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, BDLDriverUnload)
#pragma alloc_text(PAGEABLE, BDLAddDevice)

//
// This is the main driver entry point
//
NTSTATUS
DriverEntry
(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
)
{
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!DriverEntry\n",
           __DATE__,
           __TIME__))

    return (STATUS_SUCCESS);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// These functions are the BDL's entry points for all the major system IRPs
//

//
// BDLDriverUnload()
//
// The driver unload routine.  This is called by the I/O system
// when the device is unloaded from memory.
//
// PARAMETERS:
// pDriverObject    Pointer to driver object created by system.
//
// RETURNS:
// STATUS_SUCCESS   If the BDLDriverUnload call succeeded
//
VOID
BDLDriverUnload
(
    IN PDRIVER_OBJECT   pDriverObject
)
{
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDriverUnload: Enter\n",
           __DATE__,
           __TIME__))

    PAGED_CODE();

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDriverUnload: Leave\n",
           __DATE__,
           __TIME__))
}


//
// BDLCreate()
//
// This routine is called by the I/O system when the device is opened
//
// PARAMETERS:
// pDeviceObject    Pointer to device object for this miniport
// pIrp             The IRP that represents this call
//
NTSTATUS
BDLCreate
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS                        status          = STATUS_SUCCESS;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension   = pDeviceObject->DeviceExtension;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCreate: Enter\n",
           __DATE__,
           __TIME__))

    status = IoAcquireRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'lCrC');

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLCreate: IoAcquireRemoveLock failed with %lx\n",
               __DATE__,
               __TIME__,
               status))
    }

    if (InterlockedCompareExchange(&(pBDLExtension->DeviceOpen), TRUE, FALSE) == FALSE)
    {
        BDLDebug(
              BDL_DEBUG_TRACE,
              ("%s %s: BDL!BDLCreate: Device opened\n",
               __DATE__,
               __TIME__))
    }
    else
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLCreate: device is already open\n",
               __DATE__,
               __TIME__))

        //
        // The device is already in use, so fail the call
        //
        status = STATUS_UNSUCCESSFUL;

        //
        // release the lock since we are failing the call
        //
        IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'lCrC');
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCreate: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


//
// BDLClose()
//
// This routine is called by the I/O system when the device is closed
//
NTSTATUS
BDLClose
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension   = pDeviceObject->DeviceExtension;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLClose: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Clean up any outstanding notification info and data handles
    //
    BDLCleanupNotificationStruct(pBDLExtension);
    BDLCleanupDataHandles(pBDLExtension);

    IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'lCrC');
    pBDLExtension->DeviceOpen = FALSE;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLClose: Leave\n",
           __DATE__,
           __TIME__))

    return (STATUS_SUCCESS);
}


//
// BDLCleanup()
//
// This routine is called when the calling application terminates
//
NTSTATUS
BDLCleanup
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension   = pDeviceObject->DeviceExtension;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCleanup: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Clean up any outstanding notification info and data handles
    //
    BDLCleanupNotificationStruct(pBDLExtension);
    BDLCleanupDataHandles(pBDLExtension);

    //
    // Cancel the notification IRP (probably don't have to do this, since the
    // system should call the cancel routine on the applications behalf.
    //
    BDLCancelGetNotificationIRP(pBDLExtension);

    //
    // Complete this IRP
    //
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCleanup: Leave\n",
           __DATE__,
           __TIME__))

    return (STATUS_SUCCESS);
}


//
// BDLDeviceControl()
//
// This routine is called when an IOCTL is made on this device
//
NTSTATUS
BDLDeviceControl
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS                        status              = STATUS_SUCCESS;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension       = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              pStack              = NULL;
    ULONG                           cbIn                = 0;
    ULONG                           cbOut               = 0;
    ULONG                           IOCTLCode           = 0;
    PVOID                           pIOBuffer           = NULL;
    ULONG                           cbOutUsed           = 0;
    KIRQL                           irql;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDeviceControl: Enter\n",
           __DATE__,
           __TIME__))  
    
    //
    // Do some checking that is valid for all IOCTLs
    //

    //
    // Acquire the remove lock and check to make sure the device wasn't removed
    //
    status = IoAcquireRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'tCoI');

    if (status != STATUS_SUCCESS)
    {
        //
        // The device has been removed, so fail the call.
        //
        pIrp->IoStatus.Information = 0;
        status = STATUS_DEVICE_REMOVED;
        goto Return;
    }
    
    KeAcquireSpinLock(&(pBDLExtension->SpinLock), &irql);

    //
    // If IO count is anything other than 0 than the device must already
    // be started so just incremement the IO count.  If it is 0, then wait
    // on the started event to make sure the device is started.
    //
    if (pBDLExtension->IoCount == 0)
    {
        KeReleaseSpinLock(&(pBDLExtension->SpinLock), irql);

        status = KeWaitForSingleObject(
                          &(pBDLExtension->DeviceStartedEvent),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

        ASSERT(status == STATUS_SUCCESS);

        KeAcquireSpinLock(&(pBDLExtension->SpinLock), &irql);
    }

    pBDLExtension->IoCount++;
    KeReleaseSpinLock(&(pBDLExtension->SpinLock), irql);

    //
    // If the device has been removed then fail the call.  This will happen
    // if the device is stopped and the IOCTL is blocked at the above
    // KeWaitForSingleObject and then the device gets removed.
    //
    if (pBDLExtension->fDeviceRemoved == TRUE) 
    {
        status = STATUS_DEVICE_REMOVED;
        goto Return;
    }

    //
    // Get the input/output buffer, buffer sizes, and control code
    //
    pStack      = IoGetCurrentIrpStackLocation(pIrp);
    cbIn        = pStack->Parameters.DeviceIoControl.InputBufferLength;
    cbOut       = pStack->Parameters.DeviceIoControl.OutputBufferLength;
    IOCTLCode   = pStack->Parameters.DeviceIoControl.IoControlCode;
    pIOBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    //
    // We must run at passive level otherwise IoCompleteRequest won't work properly
    //
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Now, do the IOCTL specific processing
    //
    switch (IOCTLCode)
    {
    case BDD_IOCTL_STARTUP:

        status = BDLIOCTL_Startup(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_SHUTDOWN:

        status = BDLIOCTL_Shutdown(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_GETDEVICEINFO:

        status = BDLIOCTL_GetDeviceInfo(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_DOCHANNEL:

        status = BDLIOCTL_DoChannel(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_GETCONTROL:

        status = BDLIOCTL_GetControl(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_SETCONTROL:

        status = BDLIOCTL_SetControl(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_CREATEHANDLEFROMDATA:

        status = BDLIOCTL_CreateHandleFromData(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_CLOSEHANDLE:

        status = BDLIOCTL_CloseHandle(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_GETDATAFROMHANDLE:

        status = BDLIOCTL_GetDataFromHandle(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_REGISTERNOTIFY:

        status = BDLIOCTL_RegisterNotify(pBDLExtension, cbIn, cbOut, pIOBuffer, &cbOutUsed);
        break;

    case BDD_IOCTL_GETNOTIFICATION:

        status = BDLIOCTL_GetNotification(pBDLExtension, cbIn, cbOut, pIOBuffer, pIrp, &cbOutUsed);
        break;

    default:

        status = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }
   
Return:

    //
    // If the IRP isn't pending, then complete it
    //
    if (status != STATUS_PENDING)
    {
        pIrp->IoStatus.Information = cbOutUsed;
        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
    
    KeAcquireSpinLock(&(pBDLExtension->SpinLock), &irql);
    pBDLExtension->IoCount--;
    KeReleaseSpinLock(&(pBDLExtension->SpinLock), irql);

    IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'tCoI');

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDeviceControl: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


//
// BDLSystemControl()
//
//
//
NTSTATUS
BDLSystemControl
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS                        status          = STATUS_SUCCESS;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension   = pDeviceObject->DeviceExtension;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemControl: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Becuase we are not a WMI provider all we have to do is pass this IRP down
    //
    IoSkipCurrentIrpStackLocation(pIrp);
    status = IoCallDriver(pBDLExtension->BdlExtenstion.pAttachedDeviceObject, pIrp);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemControl: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


//
// BDLAddDevice()
//
// This routine creates an object for the physical device specified and
// sets up the deviceExtension.
//
NTSTATUS
BDLAddDevice
(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
)
{
    NTSTATUS                        status              = STATUS_SUCCESS;
    PDEVICE_OBJECT                  pDeviceObject       = NULL;
    PBDL_DRIVER_EXTENSION           pDriverExtension    = NULL;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension       = NULL;
    BDSI_ADDDEVICE                  bdsiAddDeviceParams;
    ULONG                           i;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLAddDevice: Enter\n",
           __DATE__,
           __TIME__))

    PAGED_CODE();

    //
    // Get the driver extension
    //
    pDriverExtension = IoGetDriverObjectExtension(pDriverObject, BDL_DRIVER_EXTENSION_ID);
    ASSERT(pDriverExtension != NULL);

    //
    // Create the device object
    //
    status = IoCreateDevice(
                       pDriverObject,
                       sizeof(BDL_INTERNAL_DEVICE_EXTENSION),
                       NULL,
                       FILE_DEVICE_BIOMETRIC,
                       0,
                       TRUE,
                       &pDeviceObject);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLAddDevice: IoCreateDevice failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    pBDLExtension = pDeviceObject->DeviceExtension;
    RtlZeroMemory(pBDLExtension, sizeof(BDL_INTERNAL_DEVICE_EXTENSION));

    //
    // Attach the device to the stack
    //
    pBDLExtension->BdlExtenstion.Size = sizeof(BDL_DEVICEEXT);
    pBDLExtension->BdlExtenstion.pAttachedDeviceObject = IoAttachDeviceToDeviceStack(
                                                                   pDeviceObject,
                                                                   pPhysicalDeviceObject);

    if (pBDLExtension->BdlExtenstion.pAttachedDeviceObject == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLAddDevice: IoAttachDeviceToDeviceStack failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        status = STATUS_UNSUCCESSFUL;
        goto ErrorReturn;
    }

    status = IoRegisterDeviceInterface(
                          pPhysicalDeviceObject,
                          &BiometricDeviceGuid,
                          NULL,
                          &(pBDLExtension->SymbolicLinkName));
    ASSERT(status == STATUS_SUCCESS);

    //
    // Initialize the rest of the BDL device extension members in order
    //
    pBDLExtension->pDriverExtension = pDriverExtension;

    KeInitializeSpinLock(&(pBDLExtension->SpinLock));

    KeInitializeEvent(&(pBDLExtension->DeviceStartedEvent), NotificationEvent, FALSE);

    pBDLExtension->IoCount = 0;

    IoInitializeRemoveLock(&(pBDLExtension->RemoveLock), BDL_ULONG_TAG, 0, 20);

    pBDLExtension->DeviceOpen = FALSE;

    status = BDLGetDeviceCapabilities(pPhysicalDeviceObject, pBDLExtension);
    if (status != STATUS_SUCCESS)
    {
        goto ErrorReturn;
    }

    KeInitializeSpinLock(&(pBDLExtension->ControlChangeStruct.ISRControlChangeLock));

    KeInitializeDpc(
            &(pBDLExtension->ControlChangeStruct.DpcObject), 
            BDLControlChangeDpc, 
            pBDLExtension);

    InitializeListHead(&(pBDLExtension->ControlChangeStruct.ISRControlChangeQueue));

    for (i = 0; i < CONTROL_CHANGE_POOL_SIZE; i++) 
    {
        pBDLExtension->ControlChangeStruct.rgControlChangePool[i].fUsed = FALSE;
    }
  
    KeQueryTickCount(&(pBDLExtension->ControlChangeStruct.StartTime));
    pBDLExtension->ControlChangeStruct.NumCalls = 0;
    
    KeInitializeSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock));
    InitializeListHead(&(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue)); 
    pBDLExtension->ControlChangeStruct.pIrp = NULL;
    InitializeListHead(&(pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList));
    
    pBDLExtension->CurrentPowerState = On;

    pBDLExtension->fStartSucceeded = FALSE;

    pBDLExtension->fDeviceRemoved = FALSE;

    KeInitializeSpinLock(&(pBDLExtension->HandleListLock));
    BDLInitializeHandleList(&(pBDLExtension->HandleList));    

    //
    // finally, call the BDD's bdsiAddDevice
    //
    RtlZeroMemory(&bdsiAddDeviceParams, sizeof(bdsiAddDeviceParams));
    bdsiAddDeviceParams.Size                    = sizeof(bdsiAddDeviceParams);
    bdsiAddDeviceParams.pPhysicalDeviceObject   = pPhysicalDeviceObject;
    bdsiAddDeviceParams.pvBDDExtension          = NULL;

    status = pDriverExtension->bdsiFunctions.pfbdsiAddDevice(
                                                &(pBDLExtension->BdlExtenstion),
                                                &bdsiAddDeviceParams);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
            BDL_DEBUG_ERROR,
            ("%s %s: BDL!BDLAddDevice: bdsiAddDevice failed with %lx\n",
            __DATE__,
            __TIME__,
            status))

        status = STATUS_UNSUCCESSFUL;
        goto ErrorReturn;
    }

    pBDLExtension->BdlExtenstion.pvBDDExtension =  bdsiAddDeviceParams.pvBDDExtension;

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLAddDevice: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    if (pBDLExtension != NULL)
    {
        BDLCleanupDeviceCapabilities(pBDLExtension);

        if (pBDLExtension->BdlExtenstion.pAttachedDeviceObject)
        {
            IoDetachDevice(pBDLExtension->BdlExtenstion.pAttachedDeviceObject);
        }

        if (pBDLExtension->SymbolicLinkName.Buffer != NULL)
        {
            RtlFreeUnicodeString(&(pBDLExtension->SymbolicLinkName));
        }
    }

    if (pDeviceObject != NULL)
    {
        IoDeleteDevice(pDeviceObject);
    }

    goto Return;
}



//
// BDLPnP()
//
// This routine is called for all PnP notifications
//
NTSTATUS
BDLPnP
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension           = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              pStackLocation          = NULL;
    PDEVICE_OBJECT                  pAttachedDeviceObject   = NULL;
    BOOLEAN                         fCompleteIrp            = TRUE;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnP: Enter\n",
           __DATE__,
           __TIME__))

    pAttachedDeviceObject   = pBDLExtension->BdlExtenstion.pAttachedDeviceObject;
    pStackLocation          = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Acquire the remove lock with the 'Pnp ' tag if this is any IRP other
    // than IRP_MN_REMOVE_DEVICE.  If it is IRP_MN_REMOVE_DEVICE then acquire
    // the lock with the 'Rmv ' tag
    //
    status = IoAcquireRemoveLock(
                    &(pBDLExtension->RemoveLock), 
                    (pStackLocation->MinorFunction != IRP_MN_REMOVE_DEVICE) 
                        ? (PVOID) ' PnP' : (PVOID) ' vmR');

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnP: IRP_MN_...%lx - Device Removed!!\n",
               __DATE__,
               __TIME__,
               pStackLocation->MinorFunction))

        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        status = STATUS_DEVICE_REMOVED;
        goto Return;
    }

    
    switch (pStackLocation->MinorFunction) 
    {
    case IRP_MN_START_DEVICE:

        status = BDLPnPStart(   
                    pBDLExtension, 
                    pAttachedDeviceObject, 
                    pIrp, 
                    pStackLocation);
        
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        status = BDLPnPQueryStop(
                    pBDLExtension, 
                    pAttachedDeviceObject, 
                    pIrp);

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        status = BDLPnPCancelStop(
                    pBDLExtension, 
                    pAttachedDeviceObject, 
                    pIrp);

        break;

    case IRP_MN_STOP_DEVICE:

        status = BDLPnPStop(
                    pBDLExtension, 
                    pAttachedDeviceObject, 
                    pIrp);

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        status = BDLPnPQueryRemove(
                    pBDLExtension, 
                    pAttachedDeviceObject, 
                    pIrp);

        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        status = BDLPnPCancelRemove(
                    pBDLExtension, 
                    pAttachedDeviceObject, 
                    pIrp);

        break;

    case IRP_MN_REMOVE_DEVICE:

        status = BDLPnPRemove(
                    pBDLExtension, 
                    pDeviceObject, 
                    pAttachedDeviceObject, 
                    pIrp);

        fCompleteIrp = FALSE;

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        status = BDLPnPSurpriseRemoval(
                    pBDLExtension, 
                    pAttachedDeviceObject, 
                    pIrp);

        fCompleteIrp = FALSE;

        break;

    default:
        
        //
        // This is an Irp that is only useful for underlying drivers
        //
        BDLDebug(
              BDL_DEBUG_TRACE,
              ("%s %s: BDL!BDLPnP: IRP_MN_...%lx\n",
               __DATE__,
               __TIME__,
               pStackLocation->MinorFunction))

        IoSkipCurrentIrpStackLocation(pIrp);
        status = IoCallDriver(pAttachedDeviceObject, pIrp);
        fCompleteIrp = FALSE;

        break;
    }

    //
    // If we actually processed the IRP and didn't skip it then complete it
    //
    if (fCompleteIrp == TRUE) 
    {
        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    //
    // The BDLPnPRemove() function itself will release the remove lock since it
    // has to wait on all the other holders of the lock defore deleting the device
    // object.  So we don't call IoReleaseRemoveLock() here if this is a 
    // IRP_MN_REMOVE_DEVICE IRP
    //
    if (pStackLocation->MinorFunction != IRP_MN_REMOVE_DEVICE) 
    {
        IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) ' PnP');
    }

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnP: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


//
// BDLPower()
//
// This routine is called for all Power notifications
//
NTSTATUS
BDLPower
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension           = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              pStackLocation          = NULL;
    PDEVICE_OBJECT                  pAttachedDeviceObject   = NULL;
    BOOLEAN                         fCompleteIrp            = TRUE;
    IRP_ACTION                      IRPAction               = SkipRequest;
    PIO_COMPLETION_ROUTINE          IoCompletionRoutine     = NULL;
    POWER_IRP_CONTEXT               *pPowerIrpContext       = NULL;
          
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPower: Enter\n",
           __DATE__,
           __TIME__))

    pAttachedDeviceObject   = pBDLExtension->BdlExtenstion.pAttachedDeviceObject;
    pStackLocation          = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Acquire the remove lock 
    //
    status = IoAcquireRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'rwoP');

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPower: IRP_MN_...%lx - Device Removed!!\n",
               __DATE__,
               __TIME__,
               pStackLocation->MinorFunction))

        PoStartNextPowerIrp(pIrp);
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        status = STATUS_DEVICE_REMOVED;
        goto Return;
    }

    switch (pStackLocation->Parameters.Power.Type) 
    {
    case DevicePowerState:
        
        switch (pStackLocation->MinorFunction) 
        {
        case IRP_MN_QUERY_POWER:

            status = BDLDeviceQueryPower(
                            pBDLExtension, 
                            pStackLocation,
                            &IRPAction,
                            &IoCompletionRoutine);

            break;

        case IRP_MN_SET_POWER:

            status = BDLDeviceSetPower(
                            pDeviceObject,
                            pBDLExtension, 
                            pStackLocation,
                            &IRPAction,
                            &IoCompletionRoutine);

            break;

        default: 

            ASSERT(FALSE);
            break;

        } // switch (pStackLocation->MinorFunction) 

        break;

    case SystemPowerState: 
    
        switch (pStackLocation->MinorFunction) 
        {
        case IRP_MN_QUERY_POWER:
            
            status = BDLSystemQueryPower(
                            pBDLExtension, 
                            pStackLocation,
                            &IRPAction,
                            &IoCompletionRoutine);

            break;

        case IRP_MN_SET_POWER:
            
            status = BDLSystemSetPower(
                            pBDLExtension, 
                            pStackLocation,
                            &IRPAction,
                            &IoCompletionRoutine);

            break;

        default: 
                            
            ASSERT(FALSE);
            break;

        } // switch (pStackLocation->MinorFunction)

        break;

    default: 

        ASSERT(FALSE);
        break;

    } // switch (pStackLocation->Parameters.Power.Type)


    switch (IRPAction)
    {
    case SkipRequest:

        IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'rwoP');

        PoStartNextPowerIrp(pIrp);
        IoSkipCurrentIrpStackLocation(pIrp);
        status = PoCallDriver(pAttachedDeviceObject, pIrp);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLPower: PoCallDriver failed with %lx\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        break;

    case CompleteRequest:

        pIrp->IoStatus.Status = status;
        pIrp->IoStatus.Information = 0;

        IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'rwoP');

        PoStartNextPowerIrp(pIrp);
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        break;

    case MarkPending:

        //
        // Allocate the context struct that all the IRPs use
        //
        pPowerIrpContext = ExAllocatePoolWithTag(
                                    PagedPool, 
                                    sizeof(POWER_IRP_CONTEXT), 
                                    BDL_ULONG_TAG);

        if (pPowerIrpContext == NULL) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLPower: ExAllocatePoolWithTag failed\n",
                   __DATE__,
                   __TIME__))

            status = STATUS_NO_MEMORY;
            goto ErrorReturn;
        }

        //
        // Fill in the context struct
        //
        pPowerIrpContext->pBDLExtension = pBDLExtension;
        pPowerIrpContext->pIrp          = pIrp;  
        
        //
        // Mark the irp as pending and setup the completion routine, then call the driver
        //
        IoMarkIrpPending(pIrp);
        IoCopyCurrentIrpStackLocationToNext(pIrp);
        IoSetCompletionRoutine(pIrp, IoCompletionRoutine, pPowerIrpContext, TRUE, TRUE, TRUE);
        
        status = PoCallDriver(pDeviceObject, pIrp);
        
        ASSERT(status == STATUS_PENDING);

        if (status != STATUS_PENDING) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLPower: PoCallDriver should have returned STATUS_PENDING but returned %lx\n",
                   __DATE__,
                   __TIME__,
                   status))

            // FIX FIX
            //
            // I have no idea what can be done to recover in this case
            //
        }

        break;
        
    } // switch (IRPAction)
    

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPower: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    pIrp->IoStatus.Status = status;
    pIrp->IoStatus.Information = 0;

    IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'rwoP');

    PoStartNextPowerIrp(pIrp);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    goto Return;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// These functions are all the handlers for Power events or supporting IoCompletion
// routines for the handlers
//

VOID
BDLSystemPowerCompleted 
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK pIoStatus
)
{
    POWER_IRP_CONTEXT               *pPowerIrpContext   = (POWER_IRP_CONTEXT *) Context;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension       = pPowerIrpContext->pBDLExtension;
    PIRP                            pIrp                = pPowerIrpContext->pIrp;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemQueryPowerCompleted: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Set the status of the System Power IRP to be the return status of the 
    // Device Power IRP that was initiated by calling PoRequestPowerIrp() in 
    // BDLSystemPowerIoCompletion() 
    //
    pIrp->IoStatus.Status = pIoStatus->Status;
    pIrp->IoStatus.Information = 0;

    IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'rwoP');

    PoStartNextPowerIrp(pIrp);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    ExFreePoolWithTag(pPowerIrpContext, BDL_ULONG_TAG);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemQueryPowerCompleted: Leave\n",
           __DATE__,
           __TIME__))
}

NTSTATUS
BDLSystemPowerIoCompletion
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
)
{
    NTSTATUS                        status              = STATUS_SUCCESS;
    POWER_IRP_CONTEXT               *pPowerIrpContext   = (POWER_IRP_CONTEXT *) Context;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension       = pPowerIrpContext->pBDLExtension;
    PIO_STACK_LOCATION              pStackLocation      = IoGetCurrentIrpStackLocation(pIrp);
    POWER_STATE                     PowerState;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemQueryPowerIoCompletion: Enter\n",
           __DATE__,
           __TIME__))

    //
    // If a lower level driver failed the request then just complete the IRP
    // and return the status set by the lower level driver
    //
    if (pIrp->IoStatus.Status != STATUS_SUCCESS) 
    {
        status = pIrp->IoStatus.Status;
        
        BDLDebug(
            BDL_DEBUG_ERROR,
            ("%s %s: BDL!BDLSystemQueryPowerIoCompletion: PoRequestPowerIrp did not return STATUS_PENDING, but returned %lx\n",
            __DATE__,
            __TIME__,
            status))

        goto ErrorReturn;
    }

    //
    // Figure out what device power state to request
    //
    switch (pStackLocation->Parameters.Power.State.SystemState) 
    {
                
    case PowerSystemMaximum:
    case PowerSystemWorking:
                        
        PowerState.DeviceState = PowerDeviceD0;

        break;


    case PowerSystemSleeping1:
    case PowerSystemSleeping2:
    case PowerSystemSleeping3:

        // FIX FIX
        //
        // For now, just fall through and map these system states to the
        // PowerDeviceD3 device state.  Ultimately, these system states should
        // map to the PowerDeviceD2 device state
        //

    case PowerSystemHibernate:
    case PowerSystemShutdown:

        PowerState.DeviceState = PowerDeviceD3;

        break;

    default:

        ASSERT(FALSE);                                      
    }

    //
    // Send a query power IRP to the device and pass in a completion routine 
    // which will check to see if the device query power IRP was completed 
    // successfully or not and will then complete the system query IRP
    //
    status = PoRequestPowerIrp (
                       pDeviceObject,
                       pStackLocation->MinorFunction, 
                       PowerState,
                       BDLSystemPowerCompleted,
                       pPowerIrpContext,
                       NULL);
        
    if (status == STATUS_PENDING)
    {
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {

        pIrp->IoStatus.Status = status;
        pIrp->IoStatus.Information = 0;   

        BDLDebug(
            BDL_DEBUG_ERROR,
            ("%s %s: BDL!BDLSystemQueryPowerIoCompletion: PoRequestPowerIrp did not return STATUS_PENDING, but returned %lx\n",
            __DATE__,
            __TIME__,
            status))

        goto ErrorReturn;
    }

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemQueryPowerIoCompletion: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    //
    // The IRP isn't going to be completed in the device query IRP completion routine,
    // so we need to complete it here 
    //

    IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'rwoP');
    
    PoStartNextPowerIrp(pIrp);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    ExFreePoolWithTag(pPowerIrpContext, BDL_ULONG_TAG);
    
    goto Return;
}

NTSTATUS
BDLSystemQueryPower
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
)
{
    NTSTATUS    status  = STATUS_SUCCESS;
    KIRQL       irql;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPowerSystemQuery: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Set these output variables here just in case we mark as pending.  
    //
    *pIoCompletionRoutine = BDLSystemPowerIoCompletion;

    switch (pStackLocation->Parameters.Power.State.SystemState) 
    {
                
    case PowerSystemMaximum:
    case PowerSystemWorking:
                        
        //
        // Because we are transitioning into a working state we don't
        // need to check anything... since we can definitely make the 
        // transition.  Mark as pending and continue processing in 
        // completion routine.
        //
        *pIRPAction = MarkPending;
        break;


    case PowerSystemSleeping1:
    case PowerSystemSleeping2:
    case PowerSystemSleeping3:
    case PowerSystemHibernate:
    case PowerSystemShutdown:

        //
        // Since we are going into a low power mode or being shutdown
        // check to see if there are any outstanding IO calls
        //
        KeAcquireSpinLock(&(pBDLExtension->SpinLock), &irql);
        if (pBDLExtension->IoCount == 0) 
        {
            //
            // Block any further IOCTLs
            //     
            KeClearEvent(&(pBDLExtension->DeviceStartedEvent));

            //
            // Mark as pending and continue processing in completion routine.
            //
            *pIRPAction = MarkPending;
        } 
        else 
        {
            //
            // We can't go into sleep mode because the device is busy
            //
            status = STATUS_DEVICE_BUSY;
            *pIRPAction = CompleteRequest;
        }
        KeReleaseSpinLock(&(pBDLExtension->SpinLock), irql);

        break;

    case PowerSystemUnspecified:

        ASSERT(FALSE);

        status = STATUS_UNSUCCESSFUL;
        *pIRPAction = CompleteRequest;
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPowerSystemQuery: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}


NTSTATUS
BDLSystemSetPower
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
)
{
    NTSTATUS    status  = STATUS_SUCCESS;
    KIRQL       irql;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemSetPower: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Set the completion routing here just in case we mark as pending.  
    //
    *pIoCompletionRoutine = BDLSystemPowerIoCompletion;

    switch (pStackLocation->Parameters.Power.State.SystemState) 
    {
                
    case PowerSystemMaximum:
    case PowerSystemWorking:
                        
        //
        // If we are already in the requested state then skip the request,
        // otherwise mark as pending which will pass the IRP down and continue 
        // processing in the completion routine
        //
        if (pBDLExtension->CurrentPowerState == On) 
        {
            *pIRPAction = SkipRequest;
        }
        else
        {
            *pIRPAction = MarkPending;
        }
        
        break;


    case PowerSystemSleeping1:
    case PowerSystemSleeping2:
    case PowerSystemSleeping3:

        // FIX FIX
        // 
        // for now just fall through on these
        //

    case PowerSystemHibernate:
    case PowerSystemShutdown:

        //
        // If we are already in the requested state then skip the request,
        // otherwise mark as pending which will pass the IRP down and continue 
        // processing in the completion routine
        //
        if (pBDLExtension->CurrentPowerState == Off) 
        {
            *pIRPAction = SkipRequest;
        }
        else
        {
            *pIRPAction = MarkPending;
        }

        break;

    case PowerSystemUnspecified:

        ASSERT(FALSE);

        status = STATUS_UNSUCCESSFUL;
        *pIRPAction = CompleteRequest;
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLSystemSetPower: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);

}


NTSTATUS
BDLDevicePowerIoCompletion
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
)
{
    NTSTATUS                        status              = STATUS_SUCCESS;
    POWER_IRP_CONTEXT               *pPowerIrpContext   = (POWER_IRP_CONTEXT *) Context;
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension       = pPowerIrpContext->pBDLExtension;
    PIO_STACK_LOCATION              pStackLocation      = IoGetCurrentIrpStackLocation(pIrp);
    PBDL_DRIVER_EXTENSION           pDriverExtension    = pBDLExtension->pDriverExtension;
    BDSI_SETPOWERSTATE              bdsiSetPowerStateParams;
        
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDevicePowerIoCompletion: Enter\n",
           __DATE__,
           __TIME__))

    //
    // If this is a completion call for an IRP_MN_SET_POWER IRP, AND it is going
    // into a working state, then call the BDD, otherwise just complete the IRP 
    // since it is one of the following:
    // 1) a completion for an IRP_MN_SET_POWER IRP that is going into low power/shutdown 
    //    (in which case the BDD was already called) 
    // 2) a completion for an IRP_MN_QUERY_POWER IRP
    //
    if ((pStackLocation->MinorFunction == IRP_MN_SET_POWER) &&
        (   (pStackLocation->Parameters.Power.State.DeviceState == PowerDeviceD0) || 
            (pStackLocation->Parameters.Power.State.DeviceState == PowerDeviceMaximum)))
    {
        RtlZeroMemory(&bdsiSetPowerStateParams, sizeof(bdsiSetPowerStateParams));
        bdsiSetPowerStateParams.Size        = sizeof(bdsiSetPowerStateParams);    
        bdsiSetPowerStateParams.PowerState  = On;
                                
        status = pDriverExtension->bdsiFunctions.pfbdsiSetPowerState(
                                                    &(pBDLExtension->BdlExtenstion),
                                                    &bdsiSetPowerStateParams);

        if (status == STATUS_SUCCESS)
        {
            PoSetPowerState(
                    pDeviceObject, 
                    DevicePowerState,
                    pStackLocation->Parameters.Power.State);
        }
        else
        {
            BDLDebug(                                              
                    BDL_DEBUG_ERROR,
                    ("%s %s: BDL!BDLDevicePowerIoCompletion: pfbdsiSetPowerState failed with %lx\n",
                    __DATE__,
                    __TIME__,
                    status))
        }

        pIrp->IoStatus.Status = status;
        pIrp->IoStatus.Information = 0;
    }
    else
    {
        status = pIrp->IoStatus.Status;
    }

    IoReleaseRemoveLock(&(pBDLExtension->RemoveLock), (PVOID) 'rwoP');

    PoStartNextPowerIrp(pIrp);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    ExFreePoolWithTag(pPowerIrpContext, BDL_ULONG_TAG);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDevicePowerIoCompletion: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


NTSTATUS
BDLDeviceQueryPower
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
)
{
    NTSTATUS    status  = STATUS_SUCCESS;
    KIRQL       irql;
    
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDeviceQueryPower: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Set the completion routine here just in case we mark as pending.  
    // 
    *pIoCompletionRoutine = BDLDevicePowerIoCompletion;

    switch (pStackLocation->Parameters.Power.State.DeviceState) 
    {
    case PowerDeviceD0:
    case PowerDeviceMaximum:

        //
        // Because we are transitioning into a working state we don't
        // need to check anything... since we can definitely make the 
        // transition.  Mark as pending and continue processing in 
        // completion routine.
        //
        *pIRPAction = MarkPending;

        break;

    
    case PowerDeviceD2:
    case PowerDeviceD3:

        break;

        //
        // Since we are going into a low power mode or being shutdown
        // check to see if there are any outstanding IO calls
        //
        KeAcquireSpinLock(&(pBDLExtension->SpinLock), &irql);
        if (pBDLExtension->IoCount == 0) 
        {
            //
            // Block any further IOCTLs
            //     
            KeClearEvent(&(pBDLExtension->DeviceStartedEvent));

            //
            // Mark as pending and continue processing in completion routine.
            //
            *pIRPAction = MarkPending;
        } 
        else 
        {
            //
            // We can't go into sleep mode because the device is busy
            //
            status = STATUS_DEVICE_BUSY;
            *pIRPAction = CompleteRequest;
        }
        KeReleaseSpinLock(&(pBDLExtension->SpinLock), irql);

    
    case PowerDeviceD1:
    case PowerDeviceUnspecified:

        //
        // These states are unsupported
        //
        ASSERT(FALSE);

        status = STATUS_UNSUCCESSFUL;
        *pIRPAction = CompleteRequest;

        break;
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDeviceQueryPower: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}


NTSTATUS
BDLDeviceSetPower
(
    IN PDEVICE_OBJECT                   pDeviceObject,
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PIO_STACK_LOCATION               pStackLocation,
    OUT IRP_ACTION                      *pIRPAction,
    OUT PIO_COMPLETION_ROUTINE          *pIoCompletionRoutine
)
{
    NTSTATUS                status              = STATUS_SUCCESS;
    PBDL_DRIVER_EXTENSION   pDriverExtension    = pBDLExtension->pDriverExtension;
    BDSI_SETPOWERSTATE      bdsiSetPowerStateParams;
    
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDeviceSetPower: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Set the completion routine here just in case we mark as pending.  
    // 
    *pIoCompletionRoutine = BDLDevicePowerIoCompletion;

    switch (pStackLocation->Parameters.Power.State.DeviceState) 
    {
    case PowerDeviceD0:
    case PowerDeviceMaximum:

        //
        // If we are already in the requested state then skip the request,
        // otherwise mark as pending which will pass the IRP down and continue 
        // processing in the completion routine
        //
        if (pBDLExtension->CurrentPowerState == On) 
        {
            *pIRPAction = SkipRequest;
        }
        else
        {
            *pIRPAction = MarkPending;
        }

        break;
    
    case PowerDeviceD2:
    case PowerDeviceD3:

        //
        // If we are already in the requested state then skip the request,
        // otherwise call the BDD and tell it to power down, then mark as 
        // pending which will pass the IRP down and then complete the IRP 
        // in the completion routine
        //
        if (pBDLExtension->CurrentPowerState == Off) 
        {
            *pIRPAction = SkipRequest;
        }
        else
        {
            RtlZeroMemory(&bdsiSetPowerStateParams, sizeof(bdsiSetPowerStateParams));
            bdsiSetPowerStateParams.Size        = sizeof(bdsiSetPowerStateParams);    
            bdsiSetPowerStateParams.PowerState  = Off;
                                    
            status = pDriverExtension->bdsiFunctions.pfbdsiSetPowerState(
                                                        &(pBDLExtension->BdlExtenstion),
                                                        &bdsiSetPowerStateParams);
    
            if (status == STATUS_SUCCESS)
            {
                PoSetPowerState(
                        pDeviceObject, 
                        DevicePowerState,
                        pStackLocation->Parameters.Power.State);

                *pIRPAction = MarkPending;
            }
            else
            {
                BDLDebug(                                              
                        BDL_DEBUG_ERROR,
                        ("%s %s: BDL!BDLDeviceSetPower: pfbdsiSetPowerState failed with %lx\n",
                        __DATE__,
                        __TIME__,
                        status))

                *pIRPAction = CompleteRequest;
            }               
        }

        break;

    case PowerDeviceD1:
    case PowerDeviceUnspecified:

        //
        // These states are unsupported
        //
        ASSERT(FALSE);

        status = STATUS_UNSUCCESSFUL;
        *pIRPAction = CompleteRequest;

        break;
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLDeviceSetPower: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);

}



/////////////////////////////////////////////////////////////////////////////////////////
//
// These functions are all the handlers for PNP events
//

NTSTATUS
BDLPnPStart
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp,
    PIO_STACK_LOCATION                  pStackLocation
)
{
    NTSTATUS                    status                  = STATUS_SUCCESS;
    PBDL_DRIVER_EXTENSION       pDriverExtension        = pBDLExtension->pDriverExtension;
    BDSI_INITIALIZERESOURCES    bdsiInitializeResourcesParams;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPStartDevice: Enter\n",
           __DATE__,
           __TIME__))

    //
    // We have to call the lower level driver first when starting up
    //
    status = BDLCallLowerLevelDriverAndWait(pAttachedDeviceObject, pIrp);

    if (!NT_SUCCESS(status))
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPStartDevice: BDLCallLowerLevelDriverAndWait failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

    //
    // Call the BDD's InitializeResources function
    //
    RtlZeroMemory(&bdsiInitializeResourcesParams, sizeof(bdsiInitializeResourcesParams));
    bdsiInitializeResourcesParams.Size                          = sizeof(bdsiInitializeResourcesParams);    
    bdsiInitializeResourcesParams.pAllocatedResources           = 
            pStackLocation->Parameters.StartDevice.AllocatedResources;
    bdsiInitializeResourcesParams.pAllocatedResourcesTranslated = 
            pStackLocation->Parameters.StartDevice.AllocatedResourcesTranslated;

    status = pDriverExtension->bdsiFunctions.pfbdsiInitializeResources(
                                                &(pBDLExtension->BdlExtenstion),
                                                &bdsiInitializeResourcesParams);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPStartDevice: pfbdsiInitializeResources failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

    //
    // Save the device info
    //
    RtlCopyMemory(
        &(pBDLExtension->wszSerialNumber[0]), 
        &(bdsiInitializeResourcesParams.wszSerialNumber[0]), 
        sizeof(pBDLExtension->wszSerialNumber));
    
    pBDLExtension->HWVersionMajor   = bdsiInitializeResourcesParams.HWVersionMajor;
    pBDLExtension->HWVersionMinor   = bdsiInitializeResourcesParams.HWVersionMinor;
    pBDLExtension->HWBuildNumber    = bdsiInitializeResourcesParams.HWBuildNumber;
    pBDLExtension->BDDVersionMajor  = bdsiInitializeResourcesParams.BDDVersionMajor;
    pBDLExtension->BDDVersionMinor  = bdsiInitializeResourcesParams.BDDVersionMinor;
    pBDLExtension->BDDBuildNumber   = bdsiInitializeResourcesParams.BDDBuildNumber;

    //
    // Enable the device interface
    // 
    status = IoSetDeviceInterfaceState(&(pBDLExtension->SymbolicLinkName), TRUE);
    
    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPStartDevice: IoSetDeviceInterfaceState failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        pDriverExtension->bdsiFunctions.pfbdsiReleaseResources(&(pBDLExtension->BdlExtenstion));

        goto Return;
    }

    //
    // This is set here indicating that BDLPnPRemove() should clean up whatever was
    // inizialized during BDLPnPStart().  If this is not set then BDLPnPRemove() 
    // should only cleanup what BDLAddDevice() initialized.
    //
    pBDLExtension->fStartSucceeded = TRUE;

    //
    // We are open for business so set the device to started 
    //
    KeSetEvent(&(pBDLExtension->DeviceStartedEvent), 0, FALSE);

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPStartDevice: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


NTSTATUS
BDLPnPQueryStop
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS    status  = STATUS_SUCCESS;
    KIRQL       irql;


    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPQueryStop: Enter\n",
           __DATE__,
           __TIME__))

    KeAcquireSpinLock(&(pBDLExtension->SpinLock), &irql);
    
    //
    // Check the IO count to see if we are currently doing anything
    //
    if (pBDLExtension->IoCount > 0) 
    {
        //
        // We refuse to stop if we have pending IO
        //
        KeReleaseSpinLock(&(pBDLExtension->SpinLock), irql);
        status = STATUS_DEVICE_BUSY;
    } 
    else 
    {
        //
        // Stop processing IO requests by clearing the device started event
        //
        KeClearEvent(&(pBDLExtension->DeviceStartedEvent));

        KeReleaseSpinLock(&(pBDLExtension->SpinLock), irql);

        //
        // Send to the lower level driver
        // 
        status = BDLCallLowerLevelDriverAndWait(pAttachedDeviceObject, pIrp);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPQueryStop: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}


NTSTATUS
BDLPnPCancelStop
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS    status  = STATUS_SUCCESS;
    
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPCancelStop: Enter\n",
           __DATE__,
           __TIME__))
    
    //
    // Send to the lower level driver
    // 
    status = BDLCallLowerLevelDriverAndWait(pAttachedDeviceObject, pIrp);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPCancelStop: BDLCallLowerLevelDriverAndWait failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

    //
    // Set the device to started 
    //
    KeSetEvent(&(pBDLExtension->DeviceStartedEvent), 0, FALSE);

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPCancelStop: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}


NTSTATUS
BDLPnPStop
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS                status              = STATUS_SUCCESS;
    PBDL_DRIVER_EXTENSION   pDriverExtension    = pBDLExtension->pDriverExtension;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPStop: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Disable the device interface (and ignore possible errors)
    // 
    IoSetDeviceInterfaceState(&(pBDLExtension->SymbolicLinkName), FALSE);

    //
    // Call the BDD's ReleaseResources
    //
    status = pDriverExtension->bdsiFunctions.pfbdsiReleaseResources(&(pBDLExtension->BdlExtenstion));

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPStop: pfbdsiReleaseResources failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

    //
    // Set this here indicating the whatever was initialized during BDLPnPStart() has
    // now been cleaned up.
    //
    pBDLExtension->fStartSucceeded = FALSE;
   
    //
    // Send to the lower level driver
    // 
    status = BDLCallLowerLevelDriverAndWait(pAttachedDeviceObject, pIrp);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPStop: BDLCallLowerLevelDriverAndWait failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPStop: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}


NTSTATUS
BDLPnPQueryRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS                status              = STATUS_SUCCESS;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPQueryRemove: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Disable the interface (and ignore possible errors)
    //
    IoSetDeviceInterfaceState(&(pBDLExtension->SymbolicLinkName), FALSE);

    //
    // If someone is connected to us then fail the call. We will enable 
    // the device interface in IRP_MN_CANCEL_REMOVE_DEVICE again
    //
    if (pBDLExtension->DeviceOpen) 
    {
        status = STATUS_UNSUCCESSFUL;
        goto Return;
    }

    //
    // Send to the lower level driver
    // 
    status = BDLCallLowerLevelDriverAndWait(pAttachedDeviceObject, pIrp);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPQueryRemove: BDLCallLowerLevelDriverAndWait failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPQueryRemove: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}


NTSTATUS
BDLPnPCancelRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension, 
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS                status              = STATUS_SUCCESS;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPCancelRemove: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Send to the lower level driver first
    // 
    status = BDLCallLowerLevelDriverAndWait(pAttachedDeviceObject, pIrp);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPCancelRemove: BDLCallLowerLevelDriverAndWait failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

    //
    // Enable the interface 
    //
    status = IoSetDeviceInterfaceState(&(pBDLExtension->SymbolicLinkName), TRUE);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLPnPCancelRemove: IoSetDeviceInterfaceState failed with %lx\n",
               __DATE__,
               __TIME__,
               status))

        goto Return;
    }

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPCancelRemove: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}


NTSTATUS
BDLHandleRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS                status              = STATUS_SUCCESS;
    PBDL_DRIVER_EXTENSION   pDriverExtension    = pBDLExtension->pDriverExtension;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLHandleRemove: Enter\n",
           __DATE__,
           __TIME__))
        
    //
    // Set this event so that any outstanding IOCTLs will be released.
    // It is anti-intuitive to set the started event when the device is
    // removed, but once this event is set, and the IOCTL threads get
    // released, they will all fail when they try to acquire the remove lock.
    //
    // This handles the situation when you have a stopped device, a blocked
    // IOCTL call, and then the device is removed.
    //
    KeSetEvent(&(pBDLExtension->DeviceStartedEvent), 0, FALSE);

    //
    // Disable the interface 
    //
    IoSetDeviceInterfaceState(&(pBDLExtension->SymbolicLinkName), FALSE);

    //
    // Clean up any outstanding notification info and data handles
    //
    BDLCleanupNotificationStruct(pBDLExtension);
    BDLCleanupDataHandles(pBDLExtension);

    //
    // If the device is currently started, then stop it.
    //
    if (pBDLExtension->fStartSucceeded == TRUE) 
    {
        status = pDriverExtension->bdsiFunctions.pfbdsiReleaseResources(&(pBDLExtension->BdlExtenstion));

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(                                              
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLHandleRemove: pfbdsiReleaseResources failed with %lx\n",
                   __DATE__,
                   __TIME__,
                   status))
        }

        pBDLExtension->fStartSucceeded = FALSE;
    }

    //
    // Tell the BDD to remove the device
    //
    status = pDriverExtension->bdsiFunctions.pfbdsiRemoveDevice(&(pBDLExtension->BdlExtenstion));

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLHandleRemove: pfbdsiRemoveDevice failed with %lx\n",
               __DATE__,
               __TIME__,
               status))
    }

    //
    // Send to the lower level driver 
    // 
    IoSkipCurrentIrpStackLocation(pIrp);
    status = IoCallDriver(pAttachedDeviceObject, pIrp);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(                                              
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLHandleRemove: IoCallDriver failed with %lx\n",
               __DATE__,
               __TIME__,
               status))
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLHandleRemove: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


NTSTATUS
BDLPnPRemove
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN PDEVICE_OBJECT                   pDeviceObject,
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS    status  = STATUS_SUCCESS;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPRemove: Enter\n",
           __DATE__,
           __TIME__))

    //
    // If there was a surprise removal then we don't need to cleanup...
    // since the surprise removal already did it
    //
    if (pBDLExtension->fDeviceRemoved == FALSE) 
    {
        pBDLExtension->fDeviceRemoved = TRUE;
        BDLHandleRemove(pBDLExtension, pAttachedDeviceObject, pIrp);        
    }

    //
    // Wait until there are no more outstanding IRPs
    //
    IoReleaseRemoveLockAndWait(&(pBDLExtension->RemoveLock), (PVOID) ' vmR');

    //
    // cleanup stuff that was initialized in AddDevice
    //
    BDLCleanupDeviceCapabilities(pBDLExtension);
    IoDetachDevice(pAttachedDeviceObject);
    RtlFreeUnicodeString(&(pBDLExtension->SymbolicLinkName));

    IoDeleteDevice(pDeviceObject);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPRemove: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


NTSTATUS
BDLPnPSurpriseRemoval
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN PDEVICE_OBJECT                   pAttachedDeviceObject,
    IN PIRP                             pIrp
)
{
    NTSTATUS    status  = STATUS_SUCCESS;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPSurpriseRemoval: Enter\n",
           __DATE__,
           __TIME__))

    pBDLExtension->fDeviceRemoved = TRUE;

    //
    // Don't need to check errors, nothing we can do.
    //
    BDLHandleRemove(pBDLExtension, pAttachedDeviceObject, pIrp); 
    
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLPnPSurpriseRemoval: Leave\n",
           __DATE__,
           __TIME__))
    
    return (status);
}



/////////////////////////////////////////////////////////////////////////////////////////
//
// These functions are exported by the BDL
//

//
// bdliInitialize()
//
// Called in response to the BDD receiving its DriverEntry call.  This lets the BDL
// know that a new BDD has been loaded and allows the BDL to initialize its state so that
// it can manage the newly loaded BDD.
//
// The bdliInitialize call will set the appropriate fields in the DRIVER_OBJECT so that
// the BDL will receive all the necessary callbacks from the system for PNP events,
// Power events, and general driver functionality.  The BDL will then forward calls that
// require hardware support to the BDD that called bdliInitialize (it will do so using
// the BDDI and BDSI APIs).  A BDD must call the bdliInitialize call during its
// DriverEntry function.
//
// PARAMETERS:
// DriverObject     This must be the DRIVER_OBJECT pointer that was passed into the
//                  BDD's DriverEntry call.
// RegistryPath     This must be the UNICODE_STRING pointer that was passed into the
//                  BDD's DriverEntry call.
// pBDDIFunctions   Pointer to a  BDLI_BDDIFUNCTIONS structure that is filled in with the
//                  entry points that the BDD exports to support the BDDI API set.  The
//                  pointers themselves are copied by the BDL, as opposed to saving the
//                  pBDDIFunctions pointer, so the memory pointed to by pBDDIFunctions
//                  need not remain accessible after the bdliInitialize call.
// pBDSIFunctions   Pointer to a  BDLI_BDSIFUNCTIONS structure that is filled in with
//                  the entry points that the BDD exports to support the BDSI API set.
//                  The pointers themselves are copied by the BDL, as opposed to saving
//                  the pBDSIFunctions pointer, so the memory pointed to by
//                  pBDSIFunctions need not remain accessible after the bdliInitialize
//                  call.
// Flags            Unused.  Must be 0.
// pReserved        Unused.  Must be NULL.
//
// RETURNS:
// STATUS_SUCCESS   If the bdliInitialize call succeeded
//

NTSTATUS
bdliInitialize
(
    IN PDRIVER_OBJECT       pDriverObject,
    IN PUNICODE_STRING      RegistryPath,
    IN PBDLI_BDDIFUNCTIONS  pBDDIFunctions,
    IN PBDLI_BDSIFUNCTIONS  pBDSIFunctions,
    IN ULONG                Flags,
    IN PVOID                pReserved
)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PBDL_DRIVER_EXTENSION   pDriverExtension = NULL;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!bdliInitialize: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Initialize the Driver Object with the BDL's entry points
    //
    pDriverObject->DriverUnload                         = BDLDriverUnload;
    pDriverObject->MajorFunction[IRP_MJ_CREATE]         = BDLCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = BDLClose;
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP]        = BDLCleanup;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = BDLDeviceControl;
    pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = BDLSystemControl;
    pDriverObject->MajorFunction[IRP_MJ_PNP]            = BDLPnP;
    pDriverObject->MajorFunction[IRP_MJ_POWER]          = BDLPower;
    pDriverObject->DriverExtension->AddDevice           = BDLAddDevice;

    //
    // Allocate a slot for the BDL driver extension structure
    //
    status = IoAllocateDriverObjectExtension(
                    pDriverObject,
                    BDL_DRIVER_EXTENSION_ID,
                    sizeof(BDL_DRIVER_EXTENSION),
                    &pDriverExtension);

    if (status != STATUS_SUCCESS)
    {
        //
        // This could happen if the BDD stole our slot
        //
        if (status == STATUS_OBJECT_NAME_COLLISION )
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!bdliInitialize: The BDD stole our DriverExtension slot\n",
                   __DATE__,
                   __TIME__))
        }
        else
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!bdliInitialize: IoAllocateDriverObjectExtension failed with %lx\n",
                   __DATE__,
                   __TIME__,
                   status))
        }

        goto Return;
    }

    //
    // Initialize the driver extension structure
    //
    pDriverExtension->bddiFunctions = *pBDDIFunctions;
    pDriverExtension->bdsiFunctions = *pBDSIFunctions;

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!bdliInitialize: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


//
// bdliAlloc()
//
// Allocates memory that can be returned to the BDL.
//
// The BDD must always use this function to allocate memory that it will return to the
// BDL as an OUT parameter of a BDDI call.  Once memory has been returned to the BDL,
// it will be owned and managed exclusively by the BDL and must not be further referenced
// by the BDD.  (Each BDDI call that requires the use of bdliAlloc will note it).
//
// PARAMETERS:
// pBDLExt          Pointer to the BDL_DEVICEEXT structure that was passed into the
//                  bdsiAddDevice call.
// NumBytes         The number of bytes to allocate.
// Flags            Unused.  Must be 0.
//
// RETURNS:
// Returns a pointer to the allocated memory, or NULL if the function fails.
//

void *
bdliAlloc
(
    IN PBDL_DEVICEEXT       pBDLExt,
    IN ULONG                NumBytes,
    IN ULONG                Flags
)
{
    return (ExAllocatePoolWithTag(PagedPool, NumBytes, BDLI_ULONG_TAG));
}


//
// bdliFree()
//
// Frees memory allocated by bdliAlloc.
//
// Memory allocated by bdliAlloc is almost always passed to the BDL as a channel product
// (as a BLOCK-type item) and subsequently freed by the BDL.  However, if an error
// occurs while processing a channel, the BDD may need to call bdliFree to free memory it
// previous allocated via bdliAlloc.
//
// PARAMETERS:
// pvBlock          Block of memory passed in by the BDL.
//
// RETURNS:
// No return value.
//

void
bdliFree
(
    IN PVOID                pvBlock
)
{
    ExFreePoolWithTag(pvBlock, BDLI_ULONG_TAG);
}


//
// bdliLogError()
//
// Writes an error to the event log.
//
// Provides a simple mechanism for BDD writers to write errors to the system event log
// without the overhead of registering with the event logging subsystem.
//
// PARAMETERS:
// pObject          If the error being logged is device specific then this must be a
//                  pointer to the BDL_DEVICEEXT  structure that was passed into the
//                  bdsiAddDevice call when the device was added.  If the error being
//                  logged is a general BDD error, then this must be same DRIVER_OBJECT
//                  structure pointer that was passed into the DriverEntry call of the
//                  BDD when the driver was loaded.
// ErrorCode        Error code of the function logging the error.
// Insertion        An insertion string to be written to the event log. Your message file
//                  must have a place holder for the insertion. For example, "serial port
//                  %2 is either not available or used by another device". In this
//                  example, %2 will be replaced by the insertion string. Note that %1 is
//                  reserved for the file name.
// cDumpData        The number of bytes pointed to by pbDumpData.
// pDumpData        A data block to be displayed in the data window of the event log.
//                  This may be NULL if the caller does not wish to display any dump data.
// Flags            Unused.  Must be 0.
// pReserved        Unused.  Must be NULL.
//
// RETURNS:
// STATUS_SUCCESS   If the bdliLogError call succeeded
//

NTSTATUS
bdliLogError
(
    IN PVOID                pObject,
    IN NTSTATUS             ErrorCode,
    IN PUNICODE_STRING      Insertion,
    IN ULONG                cDumpData,
    IN PUCHAR               pDumpData,
    IN ULONG                Flags,
    IN PVOID                pReserved
)
{
    return (STATUS_SUCCESS);
}


//
// bdliControlChange()
//
// This function allows BDDs to asynchronously return the values of its controls.
//
// bdliControlChange is generally called by the BDD in response to one of its controls
// changing a value.  Specifically, it is most often used in the case of a sensor
// control that has changed from 0 to 1 indicating that a source is present and a sample
// can be taken.
//
// PARAMETERS:
// pBDLExt          Pointer to the BDL_DEVICEEXT  structure that was passed into the
//                  bdsiAddDevice call.
// ComponentId      Specifies either the Component ID of the component in which the
//                  control or the control's parent channel resides, or '0' to indicate
//                  that dwControlId refers to a device control.
// ChannelId        If dwComponentId is not '0', dwChannelId specifies either the Channel
//                  ID of the channel in which the control resides, or '0' to indicate
//                  that dwControlId refers to a component control.Ignored if
//                  dwComponentId is '0'.
// ControlId        ControlId of the changed control.
// Value            Specifies the new value for the control .
// Flags            Unused.  Must be 0.
// pReserved        Unused.  Must be NULL.

//
// RETURNS:
// STATUS_SUCCESS   If the bdliControlChange call succeeded
//

NTSTATUS
bdliControlChange
(
    IN PBDL_DEVICEEXT       pBDLExt,
    IN ULONG                ComponentId,
    IN ULONG                ChannelId,
    IN ULONG                ControlId,
    IN ULONG                Value,
    IN ULONG                Flags,
    IN PVOID                pReserved
)
{
    BDL_INTERNAL_DEVICE_EXTENSION   *pBDLExtension  = (BDL_INTERNAL_DEVICE_EXTENSION *) pBDLExt;
    ULONG                           i;
    KIRQL                           irql;
    ULONG                           TimeInSec       = 0;
    LARGE_INTEGER                   CurrentTime;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!bdliControlChange: Enter\n",
           __DATE__,
           __TIME__))

    KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ISRControlChangeLock), &irql);

    //
    // Save the current IRQ level so that when the DPC routine is executed it
    // knows what level to elevate its IRQL to when getting an item from the
    // ISRControlChangeQueue
    //
    pBDLExtension->ControlChangeStruct.ISRirql = KeGetCurrentIrql();
    
    //
    // Make sure the BDD isn't call us too often
    //
    if (pBDLExtension->ControlChangeStruct.NumCalls <= 8) 
    {
        pBDLExtension->ControlChangeStruct.NumCalls++;
    }
    else
    {
        //
        // FIX FIX - probably need to make this configurable (via registry) at some point
        //

        //
        // We have received 10 notifies, make sure it has been longer than 1 second
        //
        KeQueryTickCount(&(CurrentTime));

        TimeInSec = (ULONG) 
                ((pBDLExtension->ControlChangeStruct.StartTime.QuadPart - CurrentTime.QuadPart) *
                KeQueryTimeIncrement() / 10000000);

        if (TimeInSec == 0) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!bdliControlChange: BDD calling too often\n",
                   __DATE__,
                   __TIME__))
    
            goto Return;

        }
        else
        {
            pBDLExtension->ControlChangeStruct.NumCalls = 1;
            KeQueryTickCount(&(pBDLExtension->ControlChangeStruct.StartTime));
        }
    }

    //
    // Get a free item from the pool
    //
    for (i = 0; i < CONTROL_CHANGE_POOL_SIZE; i++) 
    {
        if (pBDLExtension->ControlChangeStruct.rgControlChangePool[i].fUsed == FALSE) 
        {
            pBDLExtension->ControlChangeStruct.rgControlChangePool[i].fUsed = TRUE;
            
            //
            // Add the item to the queue
            //
            InsertTailList(
                &(pBDLExtension->ControlChangeStruct.ISRControlChangeQueue), 
                &(pBDLExtension->ControlChangeStruct.rgControlChangePool[i].ListEntry));

            break;   
        }
    }

    if (i >= CONTROL_CHANGE_POOL_SIZE) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!bdliControlChange: No free items\n",
               __DATE__,
               __TIME__))

        goto Return;
    }
    
    pBDLExtension->ControlChangeStruct.rgControlChangePool[i].ComponentId  = ComponentId;
    pBDLExtension->ControlChangeStruct.rgControlChangePool[i].ChannelId    = ChannelId;
    pBDLExtension->ControlChangeStruct.rgControlChangePool[i].ControlId    = ControlId;
    pBDLExtension->ControlChangeStruct.rgControlChangePool[i].Value        = Value;

    //
    // Request a DPC.  In the DPC we will move this notification from the 
    // ISRControlChangeQueue to the IOCTLControlChangeQueue
    //
    KeInsertQueueDpc(&(pBDLExtension->ControlChangeStruct.DpcObject), NULL, NULL);

Return:

    KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ISRControlChangeLock), irql);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!bdliControlChange: Leave\n",
           __DATE__,
           __TIME__))

    return (STATUS_SUCCESS);
}


VOID 
BDLControlChangeDpc
(
    IN PKDPC                            pDpc,
    IN BDL_INTERNAL_DEVICE_EXTENSION   *pBDLExtension,
    IN PVOID                            pArg1,
    IN PVOID                            pArg2
)
{
    KIRQL                           oldIrql, irql;
    BDL_ISR_CONTROL_CHANGE_ITEM     *pISRControlChangeItem      = NULL;
    PLIST_ENTRY                     pISRControlChangeEntry      = NULL;
    BDL_IOCTL_CONTROL_CHANGE_ITEM   *pIOCTLControlChangeItem    = NULL;
    PLIST_ENTRY                     pIOCTLControlChangeEntry    = NULL;
    PIRP                            pIrpToComplete              = NULL;
    PUCHAR                          pv                          = NULL;  

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLControlChangeDpc: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Loop until there are no more items in the ISRControlChangeQueue
    //
    while (1) 
    {
        //
        // Allocate a new item to be added to the IOCTLControlChangeQueue
        //
        pIOCTLControlChangeItem = ExAllocatePoolWithTag(
                                        PagedPool, 
                                        sizeof(BDL_IOCTL_CONTROL_CHANGE_ITEM), 
                                        BDL_ULONG_TAG);
        
        if (pIOCTLControlChangeItem == NULL) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLControlChangeDpc: ExAllocatePoolWithTag failed\n",
                   __DATE__,
                   __TIME__))
    
            return;
        }

        //
        // Need to raise the IRQL to access the ISRControlChangeQueue
        //
        KeRaiseIrql(pBDLExtension->ControlChangeStruct.ISRirql, &oldIrql);
        KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ISRControlChangeLock), &irql);

        //
        // Check to see if the ISRControlChangeQueue has any items
        //
        if (!IsListEmpty(&(pBDLExtension->ControlChangeStruct.ISRControlChangeQueue))) 
        {
            //
            // There is at least one item, so get the head of the queue
            //
            pISRControlChangeEntry = 
                RemoveHeadList(&(pBDLExtension->ControlChangeStruct.ISRControlChangeQueue));
            
            pISRControlChangeItem = CONTAINING_RECORD(
                                            pISRControlChangeEntry, 
                                            BDL_ISR_CONTROL_CHANGE_ITEM, 
                                            ListEntry);

            pIOCTLControlChangeItem->ComponentId    = pISRControlChangeItem->ComponentId; 
            pIOCTLControlChangeItem->ChannelId      = pISRControlChangeItem->ChannelId;
            pIOCTLControlChangeItem->ControlId      = pISRControlChangeItem->ControlId;
            pIOCTLControlChangeItem->Value          = pISRControlChangeItem->Value;

            pISRControlChangeItem->fUsed = FALSE;
        }
        else
        {
            //
            // There aren't any items in ISRControlChangeQueue, so set pIOCTLControlChangeItem
            // to NULL which will indicate we are done with the loop
            //
            ExFreePoolWithTag(pIOCTLControlChangeItem, BDL_ULONG_TAG);
            pIOCTLControlChangeItem = NULL;
        }

        KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ISRControlChangeLock), irql);
        KeLowerIrql(oldIrql);

        if (pIOCTLControlChangeItem == NULL) 
        {
            break;
        }

        //
        // Add the head of the ISRControlChangeQueue to the tail of the IOCTLControlChangeQueue 
        //
        KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), &irql);
        InsertTailList(
                &(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue), 
                &(pIOCTLControlChangeItem->ListEntry));
        KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
    }

    //
    // Now, if there is an item in the IOCTLControlChangeQueue and the GetNotification IRP
    // is pending, complete the IRP with the head of the IOCTLControlChangeQueue
    //
    KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), &irql);
        
    if ((!IsListEmpty(&(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue))) &&
        (pBDLExtension->ControlChangeStruct.pIrp != NULL)) 
    {
        pIOCTLControlChangeEntry = 
            RemoveHeadList(&(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue));

        pIOCTLControlChangeItem = CONTAINING_RECORD(
                                            pIOCTLControlChangeEntry, 
                                            BDL_IOCTL_CONTROL_CHANGE_ITEM, 
                                            ListEntry);

        pIrpToComplete = pBDLExtension->ControlChangeStruct.pIrp;
        pBDLExtension->ControlChangeStruct.pIrp = NULL;
    }

    KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);

    if (pIrpToComplete != NULL) 
    {
        pv = pIrpToComplete->AssociatedIrp.SystemBuffer;

        *((ULONG *) pv) = pIOCTLControlChangeItem->ComponentId;
        pv += sizeof(ULONG);
        *((ULONG *) pv) = pIOCTLControlChangeItem->ChannelId;
        pv += sizeof(ULONG);
        *((ULONG *) pv) = pIOCTLControlChangeItem->ControlId;
        pv += sizeof(ULONG);
        *((ULONG *) pv) = pIOCTLControlChangeItem->Value;

        ExFreePoolWithTag(pIOCTLControlChangeItem, BDL_ULONG_TAG);

        pIrpToComplete->IoStatus.Information = SIZEOF_GETNOTIFICATION_OUTPUTBUFFER;
        pIrpToComplete->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(pIrpToComplete, IO_NO_INCREMENT);
    }
    
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLControlChangeDpc: Leave\n",
           __DATE__,
           __TIME__))
}


VOID 
BDLCleanupNotificationStruct
(
    IN BDL_INTERNAL_DEVICE_EXTENSION   *pBDLExtension    
)
{
    KIRQL                           OldIrql, irql;
    BDL_ISR_CONTROL_CHANGE_ITEM     *pISRControlChangeItem      = NULL;
    PLIST_ENTRY                     pISRControlChangeEntry      = NULL;
    BDL_IOCTL_CONTROL_CHANGE_ITEM   *pIOCTLControlChangeItem    = NULL;
    PLIST_ENTRY                     pIOCTLControlChangeEntry    = NULL;
    BDL_CONTROL_CHANGE_REGISTRATION *pControlChangeRegistration = NULL;
    PLIST_ENTRY                     pRegistrationListEntry      = NULL;
    BDDI_PARAMS_REGISTERNOTIFY      bddiRegisterNotifyParams;
    NTSTATUS                        status;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCleanupNotificationStruct: Enter\n",
           __DATE__,
           __TIME__))

    bddiRegisterNotifyParams.fRegister = FALSE;
    
    //
    // Clean up all the registered control changes
    //
    while (1)
    {
        //
        // Note that we must raise the irql to dispatch level because we are synchronizing
        // with a dispatch routine (BDLControlChangeDpc) that adds items to the queue at 
        // dispatch level
        //
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
        KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), &irql);

        if (IsListEmpty(&(pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList)))
        {
            //
            // the lock we are currently holding will be released below
            //
            break;
        }

        pRegistrationListEntry = 
            RemoveHeadList(&(pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList));

        KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
        KeLowerIrql(OldIrql);

        pControlChangeRegistration = CONTAINING_RECORD(
                                            pRegistrationListEntry, 
                                            BDL_CONTROL_CHANGE_REGISTRATION, 
                                            ListEntry);

        bddiRegisterNotifyParams.ComponentId    = pControlChangeRegistration->ComponentId;
        bddiRegisterNotifyParams.ChannelId      = pControlChangeRegistration->ChannelId;
        bddiRegisterNotifyParams.ControlId      = pControlChangeRegistration->ControlId;
                    
        ExFreePoolWithTag(pControlChangeRegistration, BDL_ULONG_TAG);

        //
        // Call the BDD
        //
        status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiRegisterNotify(
                                                                    &(pBDLExtension->BdlExtenstion),
                                                                    &bddiRegisterNotifyParams);
    
        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLCleanupNotificationStruct: pfbddiRegisterNotify failed with %lx\n",
                   __DATE__,
                   __TIME__,
                  status))
    
            //
            // Just continue... nothing else we can do
            //
        }
    }

    //
    // Note: we are still holding the lock at this point
    // 

    //
    // Since we know there are no registered callbacks we should be able to clear up 
    // the ISRControlChangeQueue even though we are only running at dispatch level.   
    //
    while (!IsListEmpty(&(pBDLExtension->ControlChangeStruct.ISRControlChangeQueue))) 
    {
        pISRControlChangeEntry = 
            RemoveHeadList(&(pBDLExtension->ControlChangeStruct.ISRControlChangeQueue));

        pISRControlChangeItem = CONTAINING_RECORD(
                                    pISRControlChangeEntry, 
                                    BDL_ISR_CONTROL_CHANGE_ITEM, 
                                    ListEntry);

        pISRControlChangeItem->fUsed = FALSE;       
    }
   
    //
    // Clean up IOCTLControlChangeQueue
    //
    while (!IsListEmpty(&(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue))) 
    {
        pIOCTLControlChangeEntry = 
            RemoveHeadList(&(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue));

        pIOCTLControlChangeItem = CONTAINING_RECORD(
                                    pIOCTLControlChangeEntry, 
                                    BDL_IOCTL_CONTROL_CHANGE_ITEM, 
                                    ListEntry);

        ExFreePoolWithTag(pIOCTLControlChangeItem, BDL_ULONG_TAG); 
    }

    KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
    KeLowerIrql(OldIrql);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCleanupNotificationStruct: Leave\n",
           __DATE__,
           __TIME__))
}


VOID 
BDLCleanupDataHandles
(
    IN BDL_INTERNAL_DEVICE_EXTENSION   *pBDLExtension    
)
{
    NTSTATUS                status;
    BDDI_ITEM               *pBDDIItem              = NULL;
    BDD_DATA_HANDLE         bddDataHandle;
    BDDI_PARAMS_CLOSEHANDLE bddiCloseHandleParams;
    KIRQL                   irql;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCleanupDataHandles: Enter\n",
           __DATE__,
           __TIME__))

    bddiCloseHandleParams.Size = sizeof(bddiCloseHandleParams);
                
    BDLLockHandleList(pBDLExtension, &irql);
    
    //
    // Go through each handle in the list and clean it up
    //
    while(BDLGetFirstHandle(&(pBDLExtension->HandleList), &bddDataHandle) == TRUE)
    {
        BDLRemoveHandleFromList(&(pBDLExtension->HandleList), bddDataHandle);

        pBDDIItem = (BDDI_ITEM *) bddDataHandle;

        //
        // If this is a local handle then just clean it up, otherwise call the BDD
        //
        if (pBDDIItem->Type == BIO_ITEMTYPE_BLOCK) 
        { 
            bdliFree(pBDDIItem->Data.Block.pBuffer);                       
        }
        else
        {
            bddiCloseHandleParams.hData = pBDDIItem->Data.Handle;
    
            //
            // Call the BDD
            //
            status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiCloseHandle(
                                                                        &(pBDLExtension->BdlExtenstion),
                                                                        &bddiCloseHandleParams);
        
            if (status != STATUS_SUCCESS)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLCleanupDataHandles: pfbddiCloseHandle failed with %lx\n",
                       __DATE__,
                       __TIME__,
                      status))
        
                //
                // Nothing we can do, just continue
                //
            }
        }

        ExFreePoolWithTag(pBDDIItem, BDL_ULONG_TAG);
    }
    
    BDLReleaseHandleList(pBDLExtension, irql);
    
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCleanupDataHandles: Leave\n",
           __DATE__,
           __TIME__))
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\ntcrib.h ===
/*++

Module Name:

    ntcrib.h

Abstract:

    prototypes that aren't in driver visible includes...

    Yes, we are copying prototypes here.  It would be good to
    get rid of this, but I don't know how to do it right now
    without exposing this stuff to drivers, which I don't want to do.

Author:


Environment:

    Kernel mode

Notes:

Revision History:

--*/


NTSYSAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\apm\ntapm\i386\ntapmp.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    ntapm.h

Abstract:

Author:

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <ntapmsdk.h>

#define APM_INSTANCE_IDS L"0000"
#define APM_INSTANCE_IDS_LENGTH 5


#define NTAPM_PDO_NAME_APM_BATTERY L"\\Device\\NtApm_ApmBattery"
#define NTAPM_ID_APM_BATTERY L"NTAPM\\APMBATT\0\0"


#define NTAPM_POOL_TAG (ULONG) ' MPA'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, NTAPM_POOL_TAG);



extern  PDRIVER_OBJECT  NtApmDriverObject;

//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    CHAR            Reserved[3];
    BOOLEAN         IsFDO;
    // A boolean to distringuish between PDO and FDO.
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the game ports of which this bus driver enumerates.
// (IE there is a PDO for the 201 game port).
//

typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParentFdo;
    // A back pointer to the bus

    PWCHAR      HardwareIDs;
    // An array of (zero terminated wide character strings).
    // The array itself also null terminated

    ULONG UniqueID;
    // Globally unique id in the system

} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

NTSTATUS
ApmAddHelper();

NTSTATUS
NtApm_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    );


NTSTATUS
NtApm_PnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
NtApm_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
NtApm_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
NtApm_StartFdo (
    IN  PFDO_DEVICE_DATA            FdoData,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceList,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceListTranslated
    );

NTSTATUS
NtApm_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtApm_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    );

NTSTATUS
NtApm_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    );

NTSTATUS
NtApm_CreatePdo (
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              PdoName,
    PDEVICE_OBJECT *    PDO
    );

VOID
NtApm_InitializePdo(
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              Id
    );

VOID
ApmInProgress();


ULONG
DoApmReportBatteryStatus();



//
// APM extractor values
//

//
// APM_GET_POWER_STATUS
//

//
// EBX
// BH = Ac Line Status
//
#define APM_LINEMASK            0xff00
#define APM_LINEMASK_SHIFT      8
#define APM_GET_LINE_OFFLINE    0
#define APM_GET_LINE_ONLINE     1
#define APM_GET_LINE_BACKUP     2
#define APM_GET_LINE_UNKNOWN    0xff

//
// ECX
// CL = Percentage remaining
// CH = flags
//
#define APM_PERCENT_MASK        0xff
#define APM_BATT_HIGH           0x0100
#define APM_BATT_LOW            0x0200
#define APM_BATT_CRITICAL       0x0400
#define APM_BATT_CHARGING       0x0800
#define APM_NO_BATT             0x1000
#define APM_NO_SYS_BATT         0x8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\bio\bdl\bdlint.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    bdlint.h

Abstract:

    This module contains all of the internal efinitions for the BDLmetric device
    driver library.

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created May 2002 by Reid Kuhn

--*/

#ifndef _BDLINT_
#define _BDLINT_

#include "bdl.h"

#define BDL_ULONG_TAG       ' LDB'
#define BDLI_ULONG_TAG      'ILDB'
#define BDL_LIST_ULONG_TAG  'LLDB'

#define BIO_CONTROL_FLAG_ASYNCHRONOUS   0x00000001
#define BIO_CONTROL_FLAG_READONLY       0x00000002      

#define CONTROL_CHANGE_POOL_SIZE        20
     
                                       
#define SIZEOF_DOCHANNEL_INPUTBUFFER            ((4 * sizeof(ULONG)) + sizeof(HANDLE) + sizeof(BDD_HANDLE))
#define SIZEOF_GETCONTROL_INPUTBUFFER           (sizeof(ULONG) * 3)
#define SIZEOF_SETCONTROL_INPUTBUFFER           (sizeof(ULONG) * 4)
#define SIZEOF_CREATEHANDLEFROMDATA_INPUTBUFFER (sizeof(GUID) + (sizeof(ULONG) * 2))
#define SIZEOF_CLOSEHANDLE_INPUTBUFFER          (sizeof(BDD_HANDLE))
#define SIZEOF_GETDATAFROMHANDLE_INPUTBUFFER    (sizeof(BDD_HANDLE) + sizeof(ULONG))
#define SIZEOF_REGISTERNOTIFY_INPUTBUFFER       (sizeof(ULONG) * 4)

#define SIZEOF_GETDEVICEINFO_OUTPUTBUFFER       (sizeof(WCHAR[256]) + (sizeof(ULONG) * 6)) 
#define SIZEOF_DOCHANNEL_OUTPUTBUFFER           (sizeof(ULONG) + sizeof(BDD_HANDLE))
#define SIZEOF_GETCONTROL_OUTPUTBUFFER          (sizeof(ULONG))
#define SIZEOF_CREATEHANDLEFROMDATA_OUTPUTBUFFER (sizeof(BDD_HANDLE))
#define SIZEOF_GETDATAFROMHANDLE_OUTPUTBUFFER   (sizeof(ULONG) * 2)
#define SIZEOF_GETNOTIFICATION_OUTPUTBUFFER     (sizeof(ULONG) * 4)

NTSTATUS
DriverEntry
(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
);

NTSTATUS
BDLAddDevice
(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
);

VOID
BDLDriverUnload
(
    IN PDRIVER_OBJECT   pDriverObject
);

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, BDLAddDevice)
#pragma alloc_text(PAGEABLE, BDLDriverUnload)



typedef struct _BDL_CHANNEL_SOURCE_LIST
{
    GUID                    FormatGUID;
    ULONG                   MinSources;
    ULONG                   MaxSources;
    ULONG                   Flags;

} BDL_CHANNEL_SOURCE_LIST;


typedef struct _BDL_CONTROL
{
    ULONG                   ControlId;
    INT32                   NumericMinimum;
    INT32                   NumericMaximum;
    ULONG                   NumericGranularity;
    ULONG                   NumericDivisor;
    ULONG                   Flags;

} BDL_CONTROL;


typedef struct _BDL_PRODUCT
{
    ULONG                   Flags;

} BDL_PRODUCT;


typedef struct _BDL_CHANNEL
{
    ULONG                   ChannelId;
    ULONG                   NumControls;
    BDL_CONTROL             *rgControls;
    BOOLEAN                 fCancelable;
    ULONG                   NumSourceLists;
    BDL_CHANNEL_SOURCE_LIST *rgSourceLists;
    ULONG                   NumProducts;
    BDL_PRODUCT             *rgProducts;

} BDL_CHANNEL;


typedef struct _BDL_COMPONENT
{
    ULONG                   ComponentId;
    ULONG                   NumControls;
    BDL_CONTROL             *rgControls;
    ULONG                   NumChannels;
    BDL_CHANNEL             *rgChannels;

} BDL_COMPONENT;


typedef struct _BDL_DEVICE_CAPABILITIES
{
    ULONG                   NumControls;
    BDL_CONTROL             *rgControls;
    ULONG                   NumComponents;
    BDL_COMPONENT           *rgComponents;

} BDL_DEVICE_CAPABILITIES;


typedef struct _BDL_IOCTL_CONTROL_CHANGE_ITEM
{
    ULONG                   ComponentId;
    ULONG                   ChannelId;
    ULONG                   ControlId;
    ULONG                   Value;
    LIST_ENTRY              ListEntry;

} BDL_IOCTL_CONTROL_CHANGE_ITEM;


typedef struct _BDL_ISR_CONTROL_CHANGE_ITEM
{
    ULONG                   ComponentId;
    ULONG                   ChannelId;
    ULONG                   ControlId;
    ULONG                   Value;
    LIST_ENTRY              ListEntry;
    BOOLEAN                 fUsed;

} BDL_ISR_CONTROL_CHANGE_ITEM;


typedef struct _BDL_CONTROL_CHANGE_REGISTRATION
{
    ULONG                   ComponentId;
    ULONG                   ChannelId;
    ULONG                   ControlId;
    LIST_ENTRY              ListEntry;

} BDL_CONTROL_CHANGE_REGISTRATION;


typedef struct _BDL_CONTROL_CHANGE_STRUCT
{
    //
    // This lock protects all the members of this structure that
    // are accessed at ISR IRQL (DpcObject, ISRControlChangeQueue, 
    // ISRirql, rgControlChangePool, StartTime, and NumCalls)
    //
    KSPIN_LOCK              ISRControlChangeLock;

    //
    // DPC object used for DPC request
    //
    KDPC                    DpcObject;

    //
    // This is the list that holds the control changes which are
    // generated via ISR calls and the lock which protects it
    //
    LIST_ENTRY              ISRControlChangeQueue;
    KIRQL                   ISRirql;

    //
    // Pre-allocated pool of items used in the ISRControlChangeQueue
    //
    BDL_ISR_CONTROL_CHANGE_ITEM rgControlChangePool[CONTROL_CHANGE_POOL_SIZE];

    //
    // These values are used to ensure the BDD doesn't call bdliControlChange
    // too often
    //
    LARGE_INTEGER           StartTime;
    ULONG                   NumCalls;
    
    //
    // This lock protects all the members of this structure that
    // are accessed at DISPATCH IRQL (IOCTLControlChangeQueue, pIrp, and 
    // ControlChangeRegistrationList)
    //
    KSPIN_LOCK              ControlChangeLock;

    //
    // This is the list that holds the control changes which are
    // returned when the BDD_IOCTL_GETNOTIFICATION call is made
    //
    LIST_ENTRY              IOCTLControlChangeQueue;
    
    //
    // This is the single outstanding BDD_IOCTL_GETNOTIFICATION IRP 
    // used to retrieve asynchronous control changes.
    //
    PIRP                    pIrp;

    //
    // This is the list of registered controls
    //
    LIST_ENTRY              ControlChangeRegistrationList;
    
} BDL_CONTROL_CHANGE_STRUCT;


typedef struct LIST_NODE_
{
    void            *pNext;
    BDD_DATA_HANDLE handle;

} LIST_NODE, *PLIST_NODE;


typedef struct HANDLELIST_
{
    LIST_NODE       *pHead;
    LIST_NODE       *pTail;
    ULONG           NumHandles;

} HANDLELIST, *PHANDLELIST;


typedef struct _BDL_DRIVER_EXTENSION
{
    BDLI_BDDIFUNCTIONS  bddiFunctions;
    BDLI_BDSIFUNCTIONS  bdsiFunctions;

} BDL_DRIVER_EXTENSION, *PBDL_DRIVER_EXTENSION;


typedef struct _BDL_INTERNAL_DEVICE_EXTENSION
{
    //
    // This is the portion of the BDL extension struct that
    // BDD writers have access to
    //
    BDL_DEVICEEXT           BdlExtenstion;

    //
    // The driver object for this device
    //
    PBDL_DRIVER_EXTENSION   pDriverExtension;

    //
    // Symbolic Link Name, created when the interface is registered
    //
    UNICODE_STRING          SymbolicLinkName;

    //
    // mutual exclusion for this struct
    //
    KSPIN_LOCK              SpinLock;

    //
    // Used to signal that the device is able to process requests
    //
    KEVENT                  DeviceStartedEvent;

    //
    // The current number of io-requests
    //
    ULONG                   IoCount;

    //
    // remove lock
    //
    IO_REMOVE_LOCK          RemoveLock;

    //
    // Used to signal wether the device is open or not
    //
    LONG                    DeviceOpen;

    //
    // The BDL device specific capabilities
    //
    BDL_DEVICE_CAPABILITIES DeviceCapabilities;

    //
    // Holds the following:
    // 1) queued control changes generated from ISR calls 
    // 2) queue of items to be returned via IOCTL calls
    // 3) list of controls which have been registered
    //
    BDL_CONTROL_CHANGE_STRUCT ControlChangeStruct;

    //
    // The current power state of the device
    //
    BDSI_POWERSTATE         CurrentPowerState;

    //
    // This indicates whether BDLPnPStart() completed succesfully
    //
    BOOLEAN                 fStartSucceeded;

    //
    // This indicates that there has been a surprise removal
    //
    BOOLEAN                 fDeviceRemoved;

    //
    // This is the list of outstanding BDD Handles
    //
    KSPIN_LOCK              HandleListLock;
    HANDLELIST              HandleList;

    //
    // Device info
    //
    WCHAR                   wszSerialNumber[256];
    ULONG		            HWVersionMajor;
    ULONG		            HWVersionMinor;
    ULONG		            HWBuildNumber;
    ULONG		            BDDVersionMajor;
    ULONG		            BDDVersionMinor;
    ULONG		            BDDBuildNumber;

} BDL_INTERNAL_DEVICE_EXTENSION, *PBDL_INTERNAL_DEVICE_EXTENSION;


//
// This function retrieves the device capabilities from the registry.
//
NTSTATUS
BDLGetDeviceCapabilities
(
    PDEVICE_OBJECT                  pPhysicalDeviceObject,
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension
);

//
// This function free's up the memory allocated by BDLGetDevicesCapabilities
//
VOID
BDLCleanupDeviceCapabilities
(
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension
);


//
// This function is used to call the lower lever driver when more processing
// is required after the lower level driver is done with the IRP.
//
NTSTATUS
BDLCallLowerLevelDriverAndWait
(
    IN PDEVICE_OBJECT   pAttachedDeviceObject,
    IN PIRP             pIrp
);


//
// These functions are used to manage the devices handle list
//

VOID
BDLLockHandleList
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    OUT KIRQL                           *pirql
);

VOID
BDLReleaseHandleList
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN KIRQL                            irql
);

VOID
BDLInitializeHandleList
(
    IN HANDLELIST                       *pList
);

NTSTATUS
BDLAddHandleToList
(
    IN HANDLELIST                       *pList, 
    IN BDD_DATA_HANDLE                  handle
);

BOOLEAN
BDLRemoveHandleFromList
(
    IN HANDLELIST                       *pList, 
    IN BDD_DATA_HANDLE                  handle
);

BOOLEAN
BDLGetFirstHandle
(
    IN HANDLELIST                       *pList,
    OUT BDD_DATA_HANDLE                  *phandle
);

BOOLEAN
BDLValidateHandleIsInList
(
    IN HANDLELIST                       *pList, 
    IN BDD_DATA_HANDLE                  handle
);


//
// All these functions are used for supporting BDL IOCTL calls
//

NTSTATUS
BDLIOCTL_Startup
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_Shutdown
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_GetDeviceInfo
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_DoChannel
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_GetControl
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_SetControl
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_CreateHandleFromData
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_CloseHandle
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_GetDataFromHandle
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_RegisterNotify
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
);

NTSTATUS
BDLIOCTL_GetNotification
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    IN PIRP                             pIrp,
    OUT ULONG                           *pOutputBufferUsed
);

VOID
BDLCancelGetNotificationIRP
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension 
);

VOID 
BDLCleanupNotificationStruct
(
    IN BDL_INTERNAL_DEVICE_EXTENSION   *pBDLExtension    
);

VOID 
BDLCleanupDataHandles
(
    IN BDL_INTERNAL_DEVICE_EXTENSION   *pBDLExtension    
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\bio\bdl\bdlutil.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    bdlutil.c

Abstract:

    This module contains supporting routines forthe
    Microsoft Biometric Device Library

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created May 2002 by Reid Kuhn

--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
//#include <ntddk.h>
#include <strsafe.h>

#include <wdm.h>

#include "bdlint.h"

ULONG g_DebugLevel = (BDL_DEBUG_TRACE | BDL_DEBUG_ERROR | BDL_DEBUG_ASSERT);

ULONG
BDLGetDebugLevel()
{
    return g_DebugLevel;
}


NTSTATUS
BDLCallDriverCompletionRoutine 
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PKEVENT          pEvent
)
{
    UNREFERENCED_PARAMETER (pDeviceObject);

    if (pIrp->Cancel) 
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
    } 
    else 
    {
        pIrp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    KeSetEvent (pEvent, 0, FALSE);

    return (STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
BDLCallLowerLevelDriverAndWait
(
    IN PDEVICE_OBJECT   pAttachedDeviceObject,
    IN PIRP             pIrp
)
{

    NTSTATUS    status = STATUS_SUCCESS;
    KEVENT      Event;

    //
    // Copy our stack location to the next
    //
    IoCopyCurrentIrpStackLocationToNext(pIrp);

    //
    // Initialize an event for process synchronization. The event is passed to 
    // our completion routine and will be set when the lower level driver is done
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Set up the completion routine which will just set the event when it is called
    //
    IoSetCompletionRoutine(pIrp, BDLCallDriverCompletionRoutine, &Event, TRUE, TRUE, TRUE);

    //
    // When calling the lower lever driver it is done slightly different for Power IRPs 
    // than other IRPs
    //
    if (IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_POWER) 
    {
        PoStartNextPowerIrp(pIrp);
        status = PoCallDriver(pAttachedDeviceObject, pIrp);
    } 
    else 
    {
        status = IoCallDriver(pAttachedDeviceObject, pIrp);
    }

    //
    // Wait until the lower lever driver has processed the Irp
    //
    if (status == STATUS_PENDING) 
    {
        status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

        ASSERT (STATUS_SUCCESS == status);

        status = pIrp->IoStatus.Status;
    }

    return (status);
}


//
// These functions are for managing the handle list
//

VOID
BDLLockHandleList
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    OUT KIRQL                           *pirql
)
{
    KeAcquireSpinLock(&(pBDLExtension->HandleListLock), pirql);
}


VOID
BDLReleaseHandleList
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN KIRQL                            irql
)
{
    KeReleaseSpinLock(&(pBDLExtension->HandleListLock), irql);
}


VOID
BDLInitializeHandleList
(
    IN HANDLELIST *pList
)
{
    pList->pHead = NULL;
    pList->pTail = NULL;
    pList->NumHandles = 0;
}


NTSTATUS
BDLAddHandleToList
(
    IN HANDLELIST       *pList, 
    IN BDD_DATA_HANDLE  handle
)
{
    LIST_NODE *pListNode = NULL;

#if DBG

    //
    // Make sure same handle isn't added twice
    //
    if (BDLValidateHandleIsInList(pList, handle) == TRUE) 
    {
        ASSERT(FALSE);
    }

#endif 

    if (NULL == (pListNode = (PLIST_NODE) ExAllocatePoolWithTag(
                                                PagedPool, 
                                                sizeof(LIST_NODE), 
                                                BDL_LIST_ULONG_TAG)))
    {
        return (STATUS_NO_MEMORY);
    }

    // empty list
    if (pList->pHead == NULL)
    {
        pList->pHead = pList->pTail = pListNode;
        pListNode->pNext = NULL;
    }
    else
    {
        pListNode->pNext = pList->pHead;
        pList->pHead = pListNode;
    }

    pList->NumHandles++;
    
    pListNode->handle = handle;
    
    return(STATUS_SUCCESS);
}


BOOLEAN
BDLRemoveHandleFromList
(
    IN HANDLELIST       *pList, 
    IN BDD_DATA_HANDLE  handle
)
{
    LIST_NODE *pListNodeToDelete    = pList->pHead;
    LIST_NODE *pPrevListNode        = pList->pHead;

    // empty list
    if (pListNodeToDelete == NULL)
    {
        return (FALSE);
    }

    // remove head
    if (pListNodeToDelete->handle == handle)
    {
        // one element
        if (pList->pHead == pList->pTail)
        {
            pList->pHead = pList->pTail = NULL;
        }
        else
        {
            pList->pHead = (PLIST_NODE) pListNodeToDelete->pNext;
        }
    }
    else
    {
        pListNodeToDelete = (PLIST_NODE) pListNodeToDelete->pNext;

        while ( (pListNodeToDelete != NULL) && 
                (pListNodeToDelete->handle != handle))
        {
            pPrevListNode = pListNodeToDelete;
            pListNodeToDelete = (PLIST_NODE) pListNodeToDelete->pNext;            
        }

        if (pListNodeToDelete == NULL)
        {
            return (FALSE);
        }

        pPrevListNode->pNext = pListNodeToDelete->pNext;

        // removing tail
        if (pList->pTail == pListNodeToDelete)
        {
            pList->pTail = pPrevListNode;
        }
    }

    pList->NumHandles--;

    ExFreePoolWithTag(pListNodeToDelete, BDL_LIST_ULONG_TAG);

    return (TRUE);
}

BOOLEAN
BDLGetFirstHandle
(
    IN HANDLELIST       *pList,
    OUT BDD_DATA_HANDLE *phandle
)
{
    if (pList->pHead == NULL) 
    {
        return (FALSE);
    }
    else
    {
        *phandle = pList->pHead->handle;
        return (TRUE);
    }
}

BOOLEAN
BDLValidateHandleIsInList
(
    IN HANDLELIST       *pList, 
    IN BDD_DATA_HANDLE  handle
)
{
    LIST_NODE *pListNode = pList->pHead;

    while ((pListNode != NULL) && (pListNode->handle != handle)) 
    {
        pListNode = pListNode->pNext;
    }

    if (pList->pHead != NULL)
    {
        return (FALSE);
    }
    else
    {
        return (TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\bio\bdl\bdlioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    devcaps.c

Abstract:

    This module contains the implementation for the
    Microsoft Biometric Device Library

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 2002 by Reid Kuhn

--*/

#include <winerror.h>

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <strsafe.h>

#include <wdm.h>


#include "bdlint.h"


#define PRODUCT_NOT_REQUESTED       0
#define PRODUCT_HANDLE_REQUESTED    1
#define PRODUCT_BLOCK_REQUESTED     2


NTSTATUS
BDLRegisteredCancelGetNotificationIRP
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
);

//
// Supporting functions for checking ID's
// 
//
BOOLEAN    
BDLCheckComponentId
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            ComponentId,
    OUT ULONG                           *pComponentIndex
)
{
    ULONG i;

    for (i = 0; i < pBDLExtension->DeviceCapabilities.NumComponents; i++) 
    {
        if (pBDLExtension->DeviceCapabilities.rgComponents[i].ComponentId == ComponentId) 
        {
            break;
        }
    }

    if (i >= pBDLExtension->DeviceCapabilities.NumComponents) 
    {
        return (FALSE);
    }

    *pComponentIndex = i;

    return (TRUE);
}


BOOLEAN    
BDLCheckChannelId
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            ComponentIndex,
    IN ULONG                            ChannelId,
    OUT ULONG                           *pChannelIndex
)
{
    ULONG i;

    for (i = 0; 
         i < pBDLExtension->DeviceCapabilities.rgComponents[ComponentIndex].NumChannels; 
         i++) 
    {
        if (pBDLExtension->DeviceCapabilities.rgComponents[ComponentIndex].rgChannels[i].ChannelId == 
            ChannelId) 
        {
            break;
        }
    }

    if (i >= pBDLExtension->DeviceCapabilities.rgComponents[ComponentIndex].NumChannels)
    {
        return (FALSE);
    }

    *pChannelIndex = i;

    return (TRUE);
}


BOOLEAN    
BDLCheckControlIdInArray
(
    IN BDL_CONTROL      *rgControls,
    IN ULONG            NumControls,
    IN ULONG            ControlId,
    OUT BDL_CONTROL     **ppBDLControl
)
{
    ULONG i;

    for (i = 0; i < NumControls; i++) 
    {
        if (rgControls[i].ControlId == ControlId) 
        {
            break;
        }
    }

    if (i >= NumControls)
    {
        return (FALSE);
    }

    *ppBDLControl = &(rgControls[i]);
                        
    return (TRUE);
}

BOOLEAN
BDLCheckControlId
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            ComponentId,
    IN ULONG                            ChannelId,
    IN ULONG                            ControlId,
    OUT BDL_CONTROL                     **ppBDLControl
)
{
    ULONG i, j;

    *ppBDLControl = NULL;

    //
    // If ComponentId is 0 then it is a device level control
    //
    if (ComponentId == 0) 
    {
        //
        // Check device level control ID
        //
        if (BDLCheckControlIdInArray(
                pBDLExtension->DeviceCapabilities.rgControls,
                pBDLExtension->DeviceCapabilities.NumControls,
                ControlId,
                ppBDLControl) == FALSE)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLCheckControlId: Bad Device level ControlId\n",
                   __DATE__,
                   __TIME__))
    
            return (FALSE);
        }
    }
    else
    {
        //
        // Check the ComponentId 
        //
        if (BDLCheckComponentId(pBDLExtension, ComponentId, &i) == FALSE) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLCheckControlId: Bad ComponentId\n",
                   __DATE__,
                   __TIME__))
    
            return (FALSE);
        }

        if (ChannelId == 0) 
        {
            //
            // Check Component level control ID
            //
            if (BDLCheckControlIdInArray(
                    pBDLExtension->DeviceCapabilities.rgComponents[i].rgControls,
                    pBDLExtension->DeviceCapabilities.rgComponents[i].NumControls,
                    ControlId,
                    ppBDLControl) == FALSE)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLCheckControlId: Bad Component level ControlId\n",
                       __DATE__,
                       __TIME__))
        
                return (FALSE);
            }
        }
        else
        {
            //
            // Check channel ID
            //
            if (BDLCheckChannelId(pBDLExtension, i, ChannelId, &j) == FALSE)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLCheckControlId: Bad ChannelId\n",
                       __DATE__,
                       __TIME__))
        
                return (FALSE);
            }

            //
            // Check channel level control ID
            //
            if (BDLCheckControlIdInArray(
                    pBDLExtension->DeviceCapabilities.rgComponents[i].rgChannels[j].rgControls,
                    pBDLExtension->DeviceCapabilities.rgComponents[i].rgChannels[j].NumControls,
                    ControlId,
                    ppBDLControl) == FALSE)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLCheckControlId: Bad channel level ControlId\n",
                       __DATE__,
                       __TIME__))
        
                return (FALSE);
            }
        }
    }

    return (TRUE);
}


NTSTATUS
BDLIOCTL_Startup
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
        
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_Startup: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Call the BDD
    //
    status = pBDLExtension->pDriverExtension->bdsiFunctions.pfbdsiStartup(
                                                                &(pBDLExtension->BdlExtenstion));

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_Startup: pfbdsiStartup failed with %lx\n",
               __DATE__,
               __TIME__,
              status))
    }

    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = 0;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_Startup: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


NTSTATUS
BDLIOCTL_Shutdown
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
        
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_Shutdown: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Call the BDD
    //
    status = pBDLExtension->pDriverExtension->bdsiFunctions.pfbdsiShutdown(
                                                                &(pBDLExtension->BdlExtenstion));

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_Shutdown: pfbdsiShutdown failed with %lx\n",
               __DATE__,
               __TIME__,
              status))
    }

    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = 0;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_Shutdown: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}

NTSTATUS
BDLIOCTL_GetDeviceInfo
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
    ULONG                           RequiredOutputSize      = 0;
    PUCHAR                          pv                      = pBuffer;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetDeviceInfo: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Make sure there is enough space for the return buffer
    //
    RequiredOutputSize = SIZEOF_GETDEVICEINFO_OUTPUTBUFFER;
    if (RequiredOutputSize > OutputBufferLength)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetDeviceInfo: Output buffer is too small\n",
               __DATE__,
               __TIME__))

        status = STATUS_BUFFER_TOO_SMALL;
        goto Return;
    }

    //
    // Write the device info to the output buffer
    //
    pv = pBuffer;

    RtlCopyMemory(
            pv, 
            &(pBDLExtension->wszSerialNumber[0]), 
            sizeof(pBDLExtension->wszSerialNumber));
    pv += sizeof(pBDLExtension->wszSerialNumber);

    *((ULONG *) pv) = pBDLExtension->HWVersionMajor;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pBDLExtension->HWVersionMinor;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pBDLExtension->HWBuildNumber;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pBDLExtension->BDDVersionMajor;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pBDLExtension->BDDVersionMinor;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pBDLExtension->BDDBuildNumber;
    
    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = RequiredOutputSize;

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetDeviceInfo: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}

NTSTATUS
BDLIOCTL_DoChannel
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                status                  = STATUS_SUCCESS;
    ULONG                   NumProducts             = 0;
    ULONG                   NumSourceLists          = 0;
    ULONG                   NumSources              = 0;
    PUCHAR                  pv                      = pBuffer;
    BDDI_PARAMS_DOCHANNEL   bddiDoChannelParams;
    ULONG                   i, j, x, y;
    ULONG                   ProductCreationType;
    ULONG                   RequiredInputSize       = 0;
    ULONG                   RequiredOutputSize      = 0;
    HANDLE                  hCancelEvent            = NULL;
    KIRQL                   irql;
    BOOLEAN                 fHandleListLocked       = FALSE;
    BDDI_PARAMS_CLOSEHANDLE bddiCloseHandleParams;
   
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_DoChannel: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Initialize the DoChannelParams struct
    //
    RtlZeroMemory(&bddiDoChannelParams, sizeof(bddiDoChannelParams));
    bddiDoChannelParams.Size = sizeof(bddiDoChannelParams);
    
    //
    // Make sure the input buffer is at least the minimum size (see BDDIOCTL
    // spec for details)
    //
    RequiredInputSize = SIZEOF_DOCHANNEL_INPUTBUFFER;
    if (InpuBufferLength < RequiredInputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: Bad input buffer\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // Get all of the minimum input parameters (put the ones that are used
    // in the DoChannel call directly into the DoChannelParams struct
    //
    bddiDoChannelParams.ComponentId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiDoChannelParams.ChannelId   = *((ULONG *) pv);
    pv += sizeof(ULONG);
    hCancelEvent                    = *((HANDLE *) pv);
    pv += sizeof(HANDLE);
    bddiDoChannelParams.hStateData  = *((BDD_DATA_HANDLE *) pv);
    pv += sizeof(BDD_DATA_HANDLE);
    NumProducts                     = *((ULONG *) pv);
    pv += sizeof(ULONG);
    NumSourceLists                  = *((ULONG *) pv);
    pv += sizeof(ULONG);

    //
    // Check the size of the input buffer to make sure it is large enough
    // so that we don't run off the end when getting the products array and
    // sources lists array
    //
    // Note that this only checks based on each source list being 0 length,
    // so we need to check again before getting each source list.
    //
    RequiredInputSize += (NumProducts * sizeof(ULONG)) + (NumSourceLists * sizeof(ULONG));
    if (InpuBufferLength < RequiredInputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: Bad input buffer\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // Check the size of the output buffer to make sure it is large enough
    // to accommodate the standard output + all the products 
    //
    RequiredOutputSize = SIZEOF_DOCHANNEL_OUTPUTBUFFER + (sizeof(BDD_HANDLE) * NumProducts);
    if (OutputBufferLength < RequiredOutputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: Bad input buffer\n",
               __DATE__,
               __TIME__))

        status = STATUS_BUFFER_TOO_SMALL;
        goto ErrorReturn;
    }
    
    //
    // Check the ComponentId and ChannelId
    //
    if (BDLCheckComponentId(pBDLExtension, bddiDoChannelParams.ComponentId, &i) == FALSE) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: Bad ComponentId\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if (BDLCheckChannelId(pBDLExtension, i, bddiDoChannelParams.ChannelId, &j) == FALSE)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: Bad ChannelId\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // Check to make sure the NumProducts and NumSourceLists are correct
    // 
    if (NumProducts !=
        pBDLExtension->DeviceCapabilities.rgComponents[i].rgChannels[j].NumProducts)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: Bad number of Source Lists\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if (NumSourceLists !=
        pBDLExtension->DeviceCapabilities.rgComponents[i].rgChannels[j].NumSourceLists)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: Bad number of Source Lists\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // Allocate the space for the product pointer array then get each product 
    // request type from the input block 
    //
    bddiDoChannelParams.rgpProducts = ExAllocatePoolWithTag(
                                            PagedPool, 
                                            sizeof(PBDDI_ITEM) * NumProducts, 
                                            BDL_ULONG_TAG);

    RtlZeroMemory(bddiDoChannelParams.rgpProducts, sizeof(PBDDI_ITEM) * NumProducts);

    for (x = 0; x < NumProducts; x++) 
    {
        ProductCreationType = *((ULONG *) pv);
        pv += sizeof(ULONG);

        switch (ProductCreationType) 
        {
        case PRODUCT_NOT_REQUESTED:

            bddiDoChannelParams.rgpProducts[x] = NULL;

            break;

        case PRODUCT_HANDLE_REQUESTED:

            //
            // Make sure the channel supports handle type return
            //
            if (!(BIO_ITEMTYPE_HANDLE & 
                  pBDLExtension->DeviceCapabilities.rgComponents[i].rgChannels[j].rgProducts[x].Flags)) 
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLIOCTL_DoChannel: Bad product type request\n",
                       __DATE__,
                       __TIME__))
        
                status = STATUS_INVALID_PARAMETER;
                goto ErrorReturn;

            }

            bddiDoChannelParams.rgpProducts[x] = ExAllocatePoolWithTag(
                                                        PagedPool, 
                                                        sizeof(BDDI_ITEM), 
                                                        BDL_ULONG_TAG);

            if (bddiDoChannelParams.rgpProducts[x] == NULL)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLIOCTL_DoChannel:ExAllocatePoolWithTag failed\n",
                       __DATE__,
                       __TIME__))
        
                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

            bddiDoChannelParams.rgpProducts[x]->Type = BIO_ITEMTYPE_HANDLE;
            bddiDoChannelParams.rgpProducts[x]->Data.Handle = NULL;

            break;

        case PRODUCT_BLOCK_REQUESTED:

            //
            // Make sure the channel supports handle type return
            //
            if (!(BIO_ITEMTYPE_BLOCK & 
                  pBDLExtension->DeviceCapabilities.rgComponents[i].rgChannels[j].rgProducts[x].Flags)) 
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLIOCTL_DoChannel: Bad product type request\n",
                       __DATE__,
                       __TIME__))
        
                status = STATUS_INVALID_PARAMETER;
                goto ErrorReturn;

            }

            bddiDoChannelParams.rgpProducts[x] = ExAllocatePoolWithTag(
                                                        PagedPool, 
                                                        sizeof(BDDI_ITEM), 
                                                        BDL_ULONG_TAG);

            if (bddiDoChannelParams.rgpProducts[x] == NULL)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLIOCTL_DoChannel:ExAllocatePoolWithTag failed\n",
                       __DATE__,
                       __TIME__))
        
                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

            bddiDoChannelParams.rgpProducts[x]->Type = BIO_ITEMTYPE_BLOCK;
            bddiDoChannelParams.rgpProducts[x]->Data.Block.pBuffer = NULL;
            bddiDoChannelParams.rgpProducts[x]->Data.Block.cBuffer = 0;

            break;

        default:

            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_DoChannel: Bad Product Request\n",
                   __DATE__,
                   __TIME__))

            status = STATUS_INVALID_PARAMETER;
            goto ErrorReturn;
            break;
        }
    }

    //
    // Allocate space for the source lists
    //
    bddiDoChannelParams.rgSourceLists = ExAllocatePoolWithTag(
                                            PagedPool, 
                                            sizeof(BDDI_SOURCELIST) * NumSourceLists, 
                                            BDL_ULONG_TAG);

    RtlZeroMemory(bddiDoChannelParams.rgSourceLists, sizeof(BDDI_SOURCELIST) * NumSourceLists);

    //
    // We are going to start messing with the handle list, so lock it
    //
    BDLLockHandleList(pBDLExtension, &irql);
    fHandleListLocked = TRUE;

    //
    // Get each source list from input buffer
    //
    for (x = 0; x < NumSourceLists; x++) 
    {
        NumSources = *((ULONG *) pv);
        pv += sizeof(ULONG);

        //
        // Check the size of the input buffer to make sure it is large enough
        // so that we don't run off the end when getting this source lists 
        //
        RequiredInputSize += NumSources * sizeof(BDD_HANDLE);
        if (InpuBufferLength < RequiredInputSize) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_DoChannel: Bad input buffer\n",
                   __DATE__,
                   __TIME__))
    
            status = STATUS_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        //
        // Allocate the array of sources and then get each source in the list
        //
        bddiDoChannelParams.rgSourceLists[x].rgpSources = ExAllocatePoolWithTag(
                                                            PagedPool, 
                                                            sizeof(PBDDI_ITEM) * NumSources, 
                                                            BDL_ULONG_TAG);

        if (bddiDoChannelParams.rgpProducts[x] == NULL)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_DoChannel:ExAllocatePoolWithTag failed\n",
                   __DATE__,
                   __TIME__))
    
            status = STATUS_NO_MEMORY;
            goto ErrorReturn;
        }

        bddiDoChannelParams.rgSourceLists[x].NumSources = NumSources;

        for (y = 0; y < NumSources; y++) 
        {
            bddiDoChannelParams.rgSourceLists[x].rgpSources[y] = *((BDD_HANDLE *) pv);
            pv += sizeof(BDD_HANDLE);

            if (BDLValidateHandleIsInList(
                    &(pBDLExtension->HandleList), 
                    bddiDoChannelParams.rgSourceLists[x].rgpSources[y]) == FALSE)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLIOCTL_DoChannel: Bad input handle\n",
                       __DATE__,
                       __TIME__))
        
                status = STATUS_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }        
    }
    
    //
    // If there is a cancel event then get the kernel mode event pointer 
    // from the user mode event handle
    //
    if (hCancelEvent != NULL) 
    {
        status = ObReferenceObjectByHandle(
                        hCancelEvent,
                        EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                        NULL,
                        KernelMode,
                        &(bddiDoChannelParams.CancelEvent),
                        NULL);
    
        if (status != STATUS_SUCCESS) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_DoChannel: ObReferenceObjectByHandle failed with %lx\n",
                   __DATE__,
                   __TIME__,
                  status))

            goto ErrorReturn;
        }
    }

    //
    // Call the BDD
    //
    status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiDoChannel(
                                                                &(pBDLExtension->BdlExtenstion),
                                                                &bddiDoChannelParams);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_DoChannel: pfbddiDoChannel failed with %lx\n",
               __DATE__,
               __TIME__,
              status))

        goto ErrorReturn;
    }

    //
    // Write the output data to the output buffer
    //
    pv = pBuffer;

    *((ULONG *) pv) = bddiDoChannelParams.BIOReturnCode;
    pv +=  sizeof(ULONG);
    *((BDD_DATA_HANDLE *) pv) = bddiDoChannelParams.hStateData;
    pv +=  sizeof(BDD_DATA_HANDLE);

    //
    // Add all the product handles to the output buffer and to the handle list
    //
    for (x = 0; x < NumProducts; x++) 
    {
        *((BDD_HANDLE *) pv) = bddiDoChannelParams.rgpProducts[x];
        pv +=  sizeof(BDD_HANDLE);
        
        if (bddiDoChannelParams.rgpProducts[x] != NULL) 
        {
            status = BDLAddHandleToList(
                            &(pBDLExtension->HandleList), 
                            bddiDoChannelParams.rgpProducts[x]);

            if (status != STATUS_SUCCESS)
            {
                //
                // Remove the handles that were already added to the handle list
                //
                for (y = 0; y < x; y++)
                {
                    BDLRemoveHandleFromList(
                            &(pBDLExtension->HandleList), 
                            bddiDoChannelParams.rgpProducts[y]);
                }
            
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLIOCTL_DoChannel: BDLAddHandleToList failed with %lx\n",
                       __DATE__,
                       __TIME__,
                      status))
        
                goto ErrorReturn;
            }
        }
    }

    *pOutputBufferUsed = RequiredOutputSize;
 
Return:

    if (fHandleListLocked == TRUE) 
    {
        BDLReleaseHandleList(pBDLExtension, irql);
    }

    if (bddiDoChannelParams.rgpProducts != NULL) 
    {
        ExFreePoolWithTag(bddiDoChannelParams.rgpProducts, BDL_ULONG_TAG);
    }

    if (bddiDoChannelParams.rgSourceLists != NULL) 
    {
        for (x = 0; x < NumSourceLists; x++) 
        {
            if (bddiDoChannelParams.rgSourceLists[x].rgpSources != NULL)
            {
                ExFreePoolWithTag(bddiDoChannelParams.rgSourceLists[x].rgpSources, BDL_ULONG_TAG);
            }                              
        }

        ExFreePoolWithTag(bddiDoChannelParams.rgSourceLists, BDL_ULONG_TAG);
    }

    if (bddiDoChannelParams.CancelEvent != NULL) 
    {
        ObDereferenceObject(bddiDoChannelParams.CancelEvent);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_DoChannel: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    for (x = 0; x < NumProducts; x++) 
    {
        if (bddiDoChannelParams.rgpProducts[x] != NULL) 
        {
            if (bddiDoChannelParams.rgpProducts[x]->Type == BIO_ITEMTYPE_HANDLE)
            {
                if (bddiDoChannelParams.rgpProducts[x]->Data.Handle != NULL) 
                {
                    bddiCloseHandleParams.Size = sizeof(bddiCloseHandleParams);
                    bddiCloseHandleParams.hData = bddiDoChannelParams.rgpProducts[x]->Data.Handle; 
                    pBDLExtension->pDriverExtension->bddiFunctions.pfbddiCloseHandle(
                                                                &(pBDLExtension->BdlExtenstion),
                                                                &bddiCloseHandleParams);
                }
            }
            else
            {
                if (bddiDoChannelParams.rgpProducts[x]->Data.Block.pBuffer != NULL) 
                {
                    bdliFree(bddiDoChannelParams.rgpProducts[x]->Data.Block.pBuffer);
                }
            }

            ExFreePoolWithTag(bddiDoChannelParams.rgpProducts[x], BDL_ULONG_TAG);
        }
    }

    goto Return;
}


NTSTATUS
BDLIOCTL_GetControl
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                status                  = STATUS_SUCCESS;
    ULONG                   RequiredOutputSize      = 0;
    BDDI_PARAMS_GETCONTROL  bddiGetControlParams;
    PUCHAR                  pv                      = pBuffer; 
    ULONG                   i, j;
    BDL_CONTROL             *pBDLControl             = NULL;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetControl: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Make sure the input buffer is at least the minimum size (see BDDIOCTL
    // spec for details)
    //
    if (InpuBufferLength < SIZEOF_GETCONTROL_INPUTBUFFER) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetControl: Bad input buffer size\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Make sure there is enough space for the return buffer
    //
    RequiredOutputSize = SIZEOF_GETCONTROL_OUTPUTBUFFER;
    if (RequiredOutputSize > OutputBufferLength)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetControl: Output buffer is too small\n",
               __DATE__,
               __TIME__))

        status = STATUS_BUFFER_TOO_SMALL;
        goto Return;
    }

    //
    // Initialize the BDD struct
    //
    RtlZeroMemory(&bddiGetControlParams, sizeof(bddiGetControlParams));
    bddiGetControlParams.Size = sizeof(bddiGetControlParams);

    //
    // Get the input parameters from the buffer
    //
    bddiGetControlParams.ComponentId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiGetControlParams.ChannelId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiGetControlParams.ControlId = *((ULONG *) pv);

    //
    // Check control ID
    //
    if (BDLCheckControlId(
            pBDLExtension,
            bddiGetControlParams.ComponentId,
            bddiGetControlParams.ChannelId,
            bddiGetControlParams.ControlId,
            &pBDLControl) == FALSE)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetControl: Bad ControlId\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Call the BDD
    //
    status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiGetControl(
                                                                &(pBDLExtension->BdlExtenstion),
                                                                &bddiGetControlParams);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetControl: pfbddiGetControl failed with %lx\n",
               __DATE__,
               __TIME__,
              status))

        goto Return;
    }
    
    //
    // Write the output info to the output buffer
    //
    pv = pBuffer;

    *((ULONG *) pv) = bddiGetControlParams.Value;
    pv +=  sizeof(ULONG);

    RtlCopyMemory(pv,  bddiGetControlParams.wszString, sizeof(bddiGetControlParams.wszString));

    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = RequiredOutputSize;

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetControl: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


NTSTATUS
BDLIOCTL_SetControl
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                status                  = STATUS_SUCCESS;
    BDDI_PARAMS_SETCONTROL  bddiSetControlParams;
    PUCHAR                  pv                      = pBuffer; 
    ULONG                   i, j;
    BDL_CONTROL             *pBDLControl             = NULL;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_SetControl: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Make sure the input buffer is at least the minimum size (see BDDIOCTL
    // spec for details)
    //
    if (InpuBufferLength <  SIZEOF_SETCONTROL_INPUTBUFFER) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_SetControl: Bad input buffer size\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Initialize the BDD struct
    //
    RtlZeroMemory(&bddiSetControlParams, sizeof(bddiSetControlParams));
    bddiSetControlParams.Size = sizeof(bddiSetControlParams);

    //
    // Get the input parameters from the buffer
    //
    bddiSetControlParams.ComponentId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiSetControlParams.ChannelId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiSetControlParams.ControlId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiSetControlParams.Value = *((ULONG *) pv);
    pv += sizeof(ULONG);
    RtlCopyMemory(
        &(bddiSetControlParams.wszString[0]), 
        pv, 
        sizeof(bddiSetControlParams.wszString));

    //
    // Check control ID
    //
    if (BDLCheckControlId(
            pBDLExtension,
            bddiSetControlParams.ComponentId,
            bddiSetControlParams.ChannelId,
            bddiSetControlParams.ControlId,
            &pBDLControl) == FALSE)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_SetControl: Bad ControlId\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // First make sure this isn't a read only value, then validate the 
    // actual value
    //
    if (pBDLControl->Flags & BIO_CONTROL_FLAG_READONLY)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_SetControl: trying to set a read only control\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }
    
    if ((bddiSetControlParams.Value < pBDLControl->NumericMinimum) || 
        (bddiSetControlParams.Value > pBDLControl->NumericMaximum) ||
        (((bddiSetControlParams.Value - pBDLControl->NumericMinimum) 
                % pBDLControl->NumericDivisor) != 0 ))
    {
        BDLDebug(
               BDL_DEBUG_ERROR,
               ("%s %s: BDL!BDLIOCTL_SetControl: trying to set an invalid value\n",
                __DATE__,
                __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }
    
    //
    // Call the BDD
    //
    status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiSetControl(
                                                                &(pBDLExtension->BdlExtenstion),
                                                                &bddiSetControlParams);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_SetControl: pfbddiSetControl failed with %lx\n",
               __DATE__,
               __TIME__,
              status))

        goto Return;
    }
    
    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = 0;

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_SetControl: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}

NTSTATUS
BDLIOCTL_CreateHandleFromData
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                            status                  = STATUS_SUCCESS;
    ULONG                               RequiredOutputSize      = 0;
    BDDI_PARAMS_CREATEHANDLE_FROMDATA   bddiCreateHandleFromDataParams;
    PUCHAR                              pv                      = pBuffer;
    ULONG                               RequiredInputSize       = 0;
    ULONG                               fTempHandle;
    BDDI_ITEM                           *pNewItem               = NULL;
    KIRQL                               irql;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Make sure the input buffer is at least the minimum size (see BDDIOCTL
    // spec for details)
    //
    RequiredInputSize = SIZEOF_CREATEHANDLEFROMDATA_INPUTBUFFER;
    if (InpuBufferLength <  RequiredInputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: Bad input buffer size\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // Make sure there is enough space for the return buffer
    //
    RequiredOutputSize = SIZEOF_CREATEHANDLEFROMDATA_OUTPUTBUFFER;
    if (RequiredOutputSize > OutputBufferLength)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: Output buffer is too small\n",
               __DATE__,
               __TIME__))

        status = STATUS_BUFFER_TOO_SMALL;
        goto ErrorReturn;
    }

    //
    // Initialize the BDD struct
    //
    RtlZeroMemory(&bddiCreateHandleFromDataParams, sizeof(bddiCreateHandleFromDataParams));
    bddiCreateHandleFromDataParams.Size = sizeof(bddiCreateHandleFromDataParams);

    //
    // Get the input parameters from the buffer
    //
    RtlCopyMemory(&(bddiCreateHandleFromDataParams.guidFormatId), pv, sizeof(GUID));
    pv += sizeof(GUID);
    fTempHandle = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiCreateHandleFromDataParams.cBuffer = *((ULONG *) pv);
    pv += sizeof(ULONG); 
    bddiCreateHandleFromDataParams.pBuffer = pv;

    //
    // Check to make sure size of pBuffer isn't too large
    //
    RequiredInputSize += bddiCreateHandleFromDataParams.cBuffer;
    if (InpuBufferLength < RequiredInputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: Bad input buffer size\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // Create the new item
    //
    pNewItem = ExAllocatePoolWithTag(PagedPool, sizeof(BDDI_ITEM), BDL_ULONG_TAG);

    if (pNewItem == NULL) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // If this is a temp handle then create it locally, otherwise call the BDD
    //
    if (fTempHandle) 
    { 
        pNewItem->Type = BIO_ITEMTYPE_BLOCK;
        pNewItem->Data.Block.pBuffer = bdliAlloc(
                                            &(pBDLExtension->BdlExtenstion), 
                                            bddiCreateHandleFromDataParams.cBuffer, 
                                            0);

        if (pNewItem->Data.Block.pBuffer == NULL) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: bdliAlloc failed\n",
                   __DATE__,
                   __TIME__))
    
            status = STATUS_NO_MEMORY;
            goto ErrorReturn;
        }

        pNewItem->Data.Block.cBuffer = bddiCreateHandleFromDataParams.cBuffer;

        RtlCopyMemory(
                pNewItem->Data.Block.pBuffer, 
                pv, 
                bddiCreateHandleFromDataParams.cBuffer);
    }
    else
    {
        pNewItem->Type = BIO_ITEMTYPE_HANDLE;

        //
        // Call the BDD
        //
        status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiCreateHandleFromData(
                                                                    &(pBDLExtension->BdlExtenstion),
                                                                    &bddiCreateHandleFromDataParams);
    
        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: pfbddiCreateHandleFromData failed with %lx\n",
                   __DATE__,
                   __TIME__,
                  status))
    
            goto ErrorReturn;
        }

        pNewItem->Data.Handle = bddiCreateHandleFromDataParams.hData;
    }

    //
    // Add this handle to the list
    //
    BDLLockHandleList(pBDLExtension, &irql);
    status = BDLAddHandleToList(&(pBDLExtension->HandleList), pNewItem);
    BDLReleaseHandleList(pBDLExtension, irql);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: BDLAddHandleToList failed with %lx\n",
               __DATE__,
               __TIME__,
              status))

        goto ErrorReturn;
    }
                
    //
    // Write the output info to the output buffer
    //
    pv = pBuffer;

    *((BDD_HANDLE *) pv) = pNewItem;
    
    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = RequiredOutputSize;

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_CreateHandleFromData: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    if (pNewItem != NULL) 
    {
        if ((pNewItem->Type == BIO_ITEMTYPE_BLOCK) && (pNewItem->Data.Block.pBuffer != NULL)) 
        {
            bdliFree(pNewItem->Data.Block.pBuffer);            
        }
     
        ExFreePoolWithTag(pNewItem, BDL_ULONG_TAG);
    }

    goto Return;
}

NTSTATUS
BDLIOCTL_CloseHandle
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                status                  = STATUS_SUCCESS;
    BDDI_PARAMS_CLOSEHANDLE bddiCloseHandleParams;
    ULONG                   RequiredInputSize       = 0;
    KIRQL                   irql;
    BDDI_ITEM               *pBDDIItem              = NULL;
    BOOLEAN                 fItemInList             = FALSE;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_CloseHandle: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Make sure the input buffer is at least the minimum size (see BDDIOCTL
    // spec for details)
    //
    RequiredInputSize = SIZEOF_CLOSEHANDLE_INPUTBUFFER;
    if (InpuBufferLength <  RequiredInputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_CloseHandle: Bad input buffer size\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Initialize the BDD struct
    //
    RtlZeroMemory(&bddiCloseHandleParams, sizeof(bddiCloseHandleParams));
    bddiCloseHandleParams.Size = sizeof(bddiCloseHandleParams);

    //
    // Get the input parameters from the buffer
    //
    pBDDIItem = *((BDD_HANDLE *) pBuffer); 
    
    //
    // Validate the handle is in the list
    //
    BDLLockHandleList(pBDLExtension, &irql);
    fItemInList = BDLRemoveHandleFromList(&(pBDLExtension->HandleList), pBDDIItem);
    BDLReleaseHandleList(pBDLExtension, irql);

    if (fItemInList == FALSE) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_CloseHandle: Bad handle\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }
    
    //
    // If this is a local handle then just clean it up, otherwise call the BDD
    //
    if (pBDDIItem->Type == BIO_ITEMTYPE_BLOCK) 
    { 
        bdliFree(pBDDIItem->Data.Block.pBuffer);            
    }
    else
    {
        bddiCloseHandleParams.hData = pBDDIItem->Data.Handle;

        //
        // Call the BDD
        //
        status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiCloseHandle(
                                                                    &(pBDLExtension->BdlExtenstion),
                                                                    &bddiCloseHandleParams);
    
        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_CloseHandle: pfbddiCloseHandle failed with %lx\n",
                   __DATE__,
                   __TIME__,
                  status))
    
            goto Return;
        }
    }
    
    ExFreePoolWithTag(pBDDIItem, BDL_ULONG_TAG);
                
    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = 0;

Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_CloseHandle: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}

NTSTATUS
BDLIOCTL_GetDataFromHandle
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
    ULONG                           RequiredOutputSize      = 0;
    BDDI_PARAMS_GETDATA_FROMHANDLE  bddiGetDataFromHandleParams;
    BDDI_PARAMS_CLOSEHANDLE         bddiCloseHandleParams;
    PUCHAR                          pv                      = pBuffer;
    ULONG                           RequiredInputSize       = 0;
    ULONG                           RemainingBufferSize     = 0;
    KIRQL                           irql;
    BDDI_ITEM                       *pBDDIItem              = NULL;
    BOOLEAN                         fItemInList             = FALSE;
    BOOLEAN                         fCloseHandle            = FALSE;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetDataFromHandle: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Make sure the input buffer is at least the minimum size (see BDDIOCTL
    // spec for details)
    //
    RequiredInputSize = SIZEOF_GETDATAFROMHANDLE_INPUTBUFFER;
    if (InpuBufferLength <  RequiredInputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetDataFromHandle: Bad input buffer size\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Make sure there is enough space for the return buffer
    //
    RequiredOutputSize = SIZEOF_GETDATAFROMHANDLE_OUTPUTBUFFER;
    if (RequiredOutputSize > OutputBufferLength)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetDataFromHandle: Output buffer is too small\n",
               __DATE__,
               __TIME__))

        status = STATUS_BUFFER_TOO_SMALL;
        goto Return;
    }

    //
    // Calculate the size remaining in the output buffer
    //
    RemainingBufferSize = OutputBufferLength - RequiredOutputSize;

    //
    // Initialize the BDD struct
    //
    RtlZeroMemory(&bddiGetDataFromHandleParams, sizeof(bddiGetDataFromHandleParams));
    bddiGetDataFromHandleParams.Size = sizeof(bddiGetDataFromHandleParams);

    //
    // Get the input parameters from the buffer
    //
    pBDDIItem = *((BDD_HANDLE *) pv);
    pv += sizeof(BDD_HANDLE);
    if (*((ULONG *) pv) == 1) 
    {
        fCloseHandle = TRUE;
    }
    {
        fCloseHandle = FALSE;
    }
       
    //
    // Validate the handle is in the list
    //
    BDLLockHandleList(pBDLExtension, &irql);
    if (fCloseHandle) 
    {
        fItemInList = BDLRemoveHandleFromList(&(pBDLExtension->HandleList), pBDDIItem);
    }
    else
    {
        fItemInList = BDLValidateHandleIsInList(&(pBDLExtension->HandleList), pBDDIItem);
    }
    BDLReleaseHandleList(pBDLExtension, irql);

    if (fItemInList == FALSE) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetDataFromHandle: Bad handle\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    pv = pBuffer;
    
    //
    // If this is a local handle then just hand back the data, otherwise call the BDD
    //
    if (pBDDIItem->Type == BIO_ITEMTYPE_BLOCK) 
    { 
        //
        // See if the output buffer is large enough
        //
        if (pBDDIItem->Data.Block.cBuffer > RemainingBufferSize) 
        {
            bddiGetDataFromHandleParams.pBuffer = NULL;
            bddiGetDataFromHandleParams.BIOReturnCode = BIO_BUFFER_TOO_SMALL; 
        }
        else
        {
            //
            // Set the output buffer to be the IOCTL output buffer + the offset 
            // of the other output params which preceed the output data buffer
            //
            bddiGetDataFromHandleParams.pBuffer = pv + RequiredOutputSize;

            //
            // Copy the data
            //
            RtlCopyMemory(
                    bddiGetDataFromHandleParams.pBuffer, 
                    pBDDIItem->Data.Block.pBuffer, 
                    pBDDIItem->Data.Block.cBuffer);

            bddiGetDataFromHandleParams.BIOReturnCode = ERROR_SUCCESS; 
        }

        bddiGetDataFromHandleParams.cBuffer = pBDDIItem->Data.Block.cBuffer;

        if (fCloseHandle) 
        {
            bdliFree(pBDDIItem->Data.Block.pBuffer);
        }                                    
    }
    else
    {
        bddiGetDataFromHandleParams.hData = pBDDIItem->Data.Handle;
        bddiGetDataFromHandleParams.cBuffer = RemainingBufferSize;

        if (RemainingBufferSize == 0) 
        {
            bddiGetDataFromHandleParams.pBuffer = NULL;
        }
        else
        {           
            //
            // Set the output buffer to be the IOCTL output buffer + the offset 
            // of the other output params which preceed the output data buffer
            //
            bddiGetDataFromHandleParams.pBuffer = pv + RequiredOutputSize;
        }

        //
        // Call the BDD
        //
        status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiGetDataFromHandle(
                                                                    &(pBDLExtension->BdlExtenstion),
                                                                    &bddiGetDataFromHandleParams);
    
        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_GetDataFromHandle: pfbddiCloseHandle failed with %lx\n",
                   __DATE__,
                   __TIME__,
                  status))
    
            goto Return;
        }

        if (fCloseHandle) 
        {
            RtlZeroMemory(&bddiCloseHandleParams, sizeof(bddiCloseHandleParams));
            bddiCloseHandleParams.Size = sizeof(bddiCloseHandleParams);

            bddiCloseHandleParams.hData = pBDDIItem->Data.Handle;

            //
            // Call the BDD to close the handle - don't check the return status because 
            // we really don't want to fail the operation if just closing the handle fails
            //
            pBDLExtension->pDriverExtension->bddiFunctions.pfbddiCloseHandle(
                                                                        &(pBDLExtension->BdlExtenstion),
                                                                        &bddiCloseHandleParams);
        } 
    }
    
    if (fCloseHandle)
    {
        ExFreePoolWithTag(pBDDIItem, BDL_ULONG_TAG);
    }
                   
    //
    // Write the return info to the output buffer
    //
    pv = pBuffer;

    *((ULONG *) pv) = bddiGetDataFromHandleParams.BIOReturnCode;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = bddiGetDataFromHandleParams.cBuffer;
    
    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = RequiredOutputSize;

    if (bddiGetDataFromHandleParams.pBuffer != NULL) 
    {
        *pOutputBufferUsed += bddiGetDataFromHandleParams.cBuffer;
    }
    
Return:

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetDataFromHandle: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}

NTSTATUS
BDLIOCTL_RegisterNotify
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                        status                      = STATUS_SUCCESS;
    BDDI_PARAMS_REGISTERNOTIFY      bddiRegisterNotifyParams;
    PUCHAR                          pv                          = pBuffer;
    ULONG                           RequiredInputSize           = 0;
    BDL_CONTROL                     *pBDLControl                = NULL;
    KIRQL                           irql, OldIrql;
    PLIST_ENTRY                     pRegistrationListEntry      = NULL;
    PLIST_ENTRY                     pControlChangeEntry         = NULL;
    BDL_CONTROL_CHANGE_REGISTRATION *pControlChangeRegistration = NULL;
    BDL_IOCTL_CONTROL_CHANGE_ITEM   *pControlChangeItem         = NULL;
    BOOLEAN                         fLockAcquired               = FALSE;
    BOOLEAN                         fRegistrationFound          = FALSE;
    PLIST_ENTRY                     pTemp                       = NULL;
    PIRP                            pIrpToComplete              = NULL;
        
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_RegisterNotify: Enter\n",
           __DATE__,
           __TIME__))
    
    //
    // Make sure the input buffer is at least the minimum size (see BDDIOCTL
    // spec for details)
    //
    RequiredInputSize = SIZEOF_REGISTERNOTIFY_INPUTBUFFER;
    if (InpuBufferLength <  RequiredInputSize) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_RegisterNotify: Bad input buffer size\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return; 
    }

    //
    // Initialize the BDD struct
    //
    RtlZeroMemory(&bddiRegisterNotifyParams, sizeof(bddiRegisterNotifyParams));
    bddiRegisterNotifyParams.Size = sizeof(bddiRegisterNotifyParams);

    //
    // Get the input parameters from the buffer
    //
    bddiRegisterNotifyParams.fRegister = *((ULONG *) pv) == 1;
    pv += sizeof(ULONG);
    bddiRegisterNotifyParams.ComponentId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiRegisterNotifyParams.ChannelId = *((ULONG *) pv);
    pv += sizeof(ULONG);
    bddiRegisterNotifyParams.ControlId = *((ULONG *) pv);

    //
    // Check control ID
    //
    if (BDLCheckControlId(
            pBDLExtension,
            bddiRegisterNotifyParams.ComponentId,
            bddiRegisterNotifyParams.ChannelId,
            bddiRegisterNotifyParams.ControlId,
            &pBDLControl) == FALSE)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_RegisterNotify: Bad ControlId\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;    
    }

    //
    // Make sure this is an async control
    //
    if (!(pBDLControl->Flags | BIO_CONTROL_FLAG_ASYNCHRONOUS))
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_RegisterNotify: trying to register for a non async control\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that we must raise the irql to dispatch level because we are synchronizing
    // with a dispatch routine (BDLControlChangeDpc) that adds items to the queue at 
    // dispatch level
    //
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), &irql);
    fLockAcquired = TRUE;

    //
    // Check to see if this notification registration exists (must exist for unregister, must not
    // exist for register).
    //
    pRegistrationListEntry = pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList.Flink;

    while (pRegistrationListEntry->Flink != 
           pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList.Flink) 
    {
        pControlChangeRegistration = CONTAINING_RECORD(
                                            pRegistrationListEntry, 
                                            BDL_CONTROL_CHANGE_REGISTRATION, 
                                            ListEntry);

        if ((pControlChangeRegistration->ComponentId == bddiRegisterNotifyParams.ComponentId)   &&
            (pControlChangeRegistration->ChannelId   == bddiRegisterNotifyParams.ChannelId)     &&
            (pControlChangeRegistration->ControlId   == bddiRegisterNotifyParams.ControlId))
        {
            fRegistrationFound = TRUE;

            //
            // The notification registration does exist, so if this is a register call then fail 
            //
            if (bddiRegisterNotifyParams.fRegister == TRUE)
            {
                BDLDebug(
                      BDL_DEBUG_ERROR,
                      ("%s %s: BDL!BDLIOCTL_RegisterNotify: trying to re-register\n",
                       __DATE__,
                       __TIME__))
        
                status = STATUS_INVALID_PARAMETER;
                goto Return;
            }

            //
            // Remove the notification registration from the list
            //
            RemoveEntryList(pRegistrationListEntry);
            ExFreePoolWithTag(pControlChangeRegistration, BDL_ULONG_TAG);

            //
            // Remove any pending notifications for the control which is being unregistered
            //
            pControlChangeEntry = pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue.Flink;

            while (pControlChangeEntry->Flink != 
                   pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue.Flink) 
            {
                pControlChangeItem = CONTAINING_RECORD(
                                            pControlChangeEntry, 
                                            BDL_IOCTL_CONTROL_CHANGE_ITEM, 
                                            ListEntry);

                pTemp = pControlChangeEntry;
                pControlChangeEntry = pControlChangeEntry->Flink;

                if ((pControlChangeItem->ComponentId == bddiRegisterNotifyParams.ComponentId)   &&
                    (pControlChangeItem->ChannelId   == bddiRegisterNotifyParams.ChannelId)     &&
                    (pControlChangeItem->ControlId   == bddiRegisterNotifyParams.ControlId))
                {
                    RemoveEntryList(pTemp);
                    ExFreePoolWithTag(pControlChangeItem, BDL_ULONG_TAG);
                }
            }

            //
            // If the last notification registration just got removed, then complete
            // the pending get notification IRP (if one exists) after releasing the lock.
            //
            if (IsListEmpty(&(pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList)) &&
                (pBDLExtension->ControlChangeStruct.pIrp != NULL)) 
            {
                pIrpToComplete = pBDLExtension->ControlChangeStruct.pIrp;
                pBDLExtension->ControlChangeStruct.pIrp = NULL;
            }

            break;                       
        }

        pRegistrationListEntry = pRegistrationListEntry->Flink;
    }

    //
    // If the registration was not found, and this is an unregister, return an error
    //
    if ((fRegistrationFound == FALSE) && (bddiRegisterNotifyParams.fRegister == FALSE)) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_RegisterNotify: trying to re-register\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Add the notification to the list if this is a registration
    //
    if (bddiRegisterNotifyParams.fRegister == TRUE) 
    {
        pControlChangeRegistration = ExAllocatePoolWithTag(
                                        PagedPool, 
                                        sizeof(BDL_CONTROL_CHANGE_REGISTRATION), 
                                        BDL_ULONG_TAG);
    
        if (pControlChangeRegistration == NULL) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_RegisterNotify: ExAllocatePoolWithTag failed\n",
                   __DATE__,
                   __TIME__))
        
            status = STATUS_NO_MEMORY;
            goto Return;
        }

        pControlChangeRegistration->ComponentId = bddiRegisterNotifyParams.ComponentId;
        pControlChangeRegistration->ChannelId   = bddiRegisterNotifyParams.ChannelId;
        pControlChangeRegistration->ControlId   = bddiRegisterNotifyParams.ControlId;
    
        InsertHeadList(
            &(pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList), 
            &(pControlChangeRegistration->ListEntry));
    }

    KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
    KeLowerIrql(OldIrql);
    fLockAcquired = FALSE;

    if (pIrpToComplete != NULL) 
    {
        pIrpToComplete->IoStatus.Information = 0;
        pIrpToComplete->IoStatus.Status = STATUS_NO_MORE_ENTRIES;
        IoCompleteRequest(pIrpToComplete, IO_NO_INCREMENT);
    }

    //
    // Call the BDD
    //
    status = pBDLExtension->pDriverExtension->bddiFunctions.pfbddiRegisterNotify(
                                                                &(pBDLExtension->BdlExtenstion),
                                                                &bddiRegisterNotifyParams);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_RegisterNotify: pfbddiRegisterNotify failed with %lx\n",
               __DATE__,
               __TIME__,
              status))

        //
        // FIX FIX - if this fails and it is a register then we need to remove the 
        // registration from the list of registrations... since it was already added
        // above.
        //
        ASSERT(0);

        goto Return;
    }

    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = 0;

Return:

    if (fLockAcquired == TRUE) 
    {
        KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
        KeLowerIrql(OldIrql);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_RegisterNotify: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}

NTSTATUS
BDLIOCTL_GetNotification
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION   pBDLExtension,
    IN ULONG                            InpuBufferLength,
    IN ULONG                            OutputBufferLength,
    IN PVOID                            pBuffer,
    IN PIRP                             pIrp,
    OUT ULONG                           *pOutputBufferUsed
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
    ULONG                           RequiredOutputSize      = 0;
    PUCHAR                          pv                      = pBuffer;
    KIRQL                           irql, OldIrql;
    PLIST_ENTRY                     pListEntry              = NULL;
    BDL_IOCTL_CONTROL_CHANGE_ITEM   *pControlChangeItem     = NULL;
    BOOLEAN                         fLockAcquired           = FALSE;
        
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetNotification: Enter\n",
           __DATE__,
           __TIME__))
            
    //
    // Make sure there is enough space for the return buffer
    //
    RequiredOutputSize = SIZEOF_GETNOTIFICATION_OUTPUTBUFFER;

    if (RequiredOutputSize > OutputBufferLength)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetNotification: Output buffer is too small\n",
               __DATE__,
               __TIME__))

        status = STATUS_BUFFER_TOO_SMALL;
        goto Return;
    }

    //
    // Lock the notification queue and see if there are any outstanding notifications.
    // Note that we must raise the irql to dispatch level because we are synchronizing
    // with a DPC routine (BDLControlChangeDpc) that adds items to the queue at 
    // dispatch level
    //
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), &irql);
    fLockAcquired = TRUE;

    //
    // If there is already an IRP posted then that is a bug in the BSP
    //
    if (pBDLExtension->ControlChangeStruct.pIrp != NULL) 
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLIOCTL_GetNotification: Output buffer is too small\n",
               __DATE__,
               __TIME__))

        status = STATUS_INVALID_DEVICE_STATE;
        goto Return;
    }

    if (IsListEmpty(&(pBDLExtension->ControlChangeStruct.ControlChangeRegistrationList))) 
    {
        //
        // There are no change notifications registered, so complete the IRP with the 
        // special status that indicates that
        //

        BDLDebug(
              BDL_DEBUG_TRACE,
              ("%s %s: BDL!BDLIOCTL_GetNotification: ControlChangeRegistrationList empty\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MORE_ENTRIES;
        goto Return;
    }
    else if (IsListEmpty(&(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue))) 
    {
        //
        // There are currently no control changes in the list, so just save this Irp 
        // and return STATUS_PENDING
        //

        BDLDebug(
              BDL_DEBUG_TRACE,
              ("%s %s: BDL!BDLIOCTL_GetNotification: ControlChanges empty\n",
               __DATE__,
               __TIME__))

        //
        // Set up the cancel routine for this IRP
        //
        if (IoSetCancelRoutine(pIrp, BDLRegisteredCancelGetNotificationIRP) != NULL) 
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLIOCTL_GetNotification: pCancel was not NULL\n",
                   __DATE__,
                   __TIME__))
        }

        pBDLExtension->ControlChangeStruct.pIrp = pIrp;
                                
        status = STATUS_PENDING;
        goto Return;
    }
    else
    {
        //
        // Grab the first control change item in the queue
        //
        pListEntry = RemoveHeadList(&(pBDLExtension->ControlChangeStruct.IOCTLControlChangeQueue));
        pControlChangeItem = CONTAINING_RECORD(pListEntry, BDL_IOCTL_CONTROL_CHANGE_ITEM, ListEntry);
    }

    KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
    KeLowerIrql(OldIrql);
    fLockAcquired = FALSE;

    //
    // We are here because there is currently a control change to report, so write the return 
    // info to the output buffer
    //
    pv = pBuffer;

    *((ULONG *) pv) = pControlChangeItem->ComponentId;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pControlChangeItem->ChannelId;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pControlChangeItem->ControlId;
    pv += sizeof(ULONG);
    *((ULONG *) pv) = pControlChangeItem->Value;

    //
    // Free up the change item
    //
    ExFreePoolWithTag(pControlChangeItem, BDL_ULONG_TAG);
    
    //
    // Set the number of bytes used
    //
    *pOutputBufferUsed = RequiredOutputSize;

Return:

    if (fLockAcquired) 
    {
        KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
        KeLowerIrql(OldIrql);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLIOCTL_GetNotification: Leave\n",
           __DATE__,
           __TIME__))

    return (status);
}


VOID
BDLCancelGetNotificationIRP
(
    IN PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension 
)
{
    PIRP                            pIrpToCancel    = NULL;
    KIRQL                           irql, OldIrql;
        
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCancelGetNotificationIRP: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Remove the GetNotification IRP from the the ControlChangeStruct.
    // Need to make sure the IRP is still there, since theoretically we 
    // could be trying to complete it at the same time it is cancelled.
    //
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeAcquireSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), &irql);
    
    if (pBDLExtension->ControlChangeStruct.pIrp != NULL) 
    {
        pIrpToCancel = pBDLExtension->ControlChangeStruct.pIrp;
        pBDLExtension->ControlChangeStruct.pIrp = NULL;
    }
         
    KeReleaseSpinLock(&(pBDLExtension->ControlChangeStruct.ControlChangeLock), irql);
    KeLowerIrql(OldIrql);

    //
    // Complete the GetNotification IRP as cancelled
    //
    if (pIrpToCancel != NULL) 
    {
        pIrpToCancel->IoStatus.Information = 0;
        pIrpToCancel->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(pIrpToCancel, IO_NO_INCREMENT);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLCancelGetNotificationIRP: Leave\n",
           __DATE__,
           __TIME__))
}


NTSTATUS
BDLRegisteredCancelGetNotificationIRP
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension   = pDeviceObject->DeviceExtension;
        
    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLRegisteredCancelGetNotificationIRP: Enter\n",
           __DATE__,
           __TIME__))

    ASSERT(pIrp == pBDLExtension->ControlChangeStruct.pIrp);

    //
    // Since this function is called already holding the CancelSpinLock
    // we need to release it
    //
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // Cancel the IRP
    //
    BDLCancelGetNotificationIRP(pBDLExtension);

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLRegisteredCancelGetNotificationIRP: Leave\n",
           __DATE__,
           __TIME__))

    return (STATUS_CANCELLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_drivers.ini  ddk $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\adddev.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        AddDev.c

Abstract:

        AddDevice - Create and initialize device object and attach device 
                      object to the device stack.

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this File:

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* AddDevice                                                            */
/************************************************************************/
//
// Routine Description:
//
//     Create and initialize device object and attach device 
//       object to the device stack.
//
// Arguments: 
//
//      DriverObject - pointer to Dot4Usb.sys driver object
//      Pdo          - pointer to the PDO of the device stack that
//                       we attach our device object to
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  Pdo
    )
{
    PDEVICE_OBJECT  devObj;
    NTSTATUS        status = IoCreateDevice( DriverObject,
                                             sizeof(DEVICE_EXTENSION),
                                             NULL,                    // no name
                                             FILE_DEVICE_UNKNOWN,
                                             FILE_DEVICE_SECURE_OPEN,
                                             FALSE,                   // not exclusive
                                             &devObj );

    if( NT_SUCCESS(status) ) {

        PDEVICE_OBJECT lowerDevObj = IoAttachDeviceToDeviceStack( devObj, Pdo );

        if( lowerDevObj ) {

            PDEVICE_EXTENSION devExt = (PDEVICE_EXTENSION)devObj->DeviceExtension;

            RtlZeroMemory(devExt, sizeof(DEVICE_EXTENSION));
            
            devExt->LowerDevObj = lowerDevObj;  // send IRPs to this device
            devExt->Signature1  = DOT4USBTAG;   // constant over the lifetime of object
            devExt->Signature2  = DOT4USBTAG;
            devExt->PnpState    = STATE_INITIALIZED;
            devExt->DevObj      = devObj;
            devExt->Pdo         = Pdo;
            devExt->ResetWorkItemPending=0;

            devExt->SystemPowerState = PowerSystemWorking;
            devExt->DevicePowerState = PowerDeviceD0;
            devExt->CurrentPowerIrp  = NULL;

            IoInitializeRemoveLock( &devExt->RemoveLock, 
                                    DOT4USBTAG,
                                    5,          // MaxLockedMinutes - only used on chk'd builds
                                    255 );      // HighWaterMark    - only used on chk'd builds
            
            KeInitializeSpinLock( &devExt->SpinLock );
            KeInitializeEvent( &devExt->PollIrpEvent, NotificationEvent, FALSE );
            
            devObj->Flags |= DO_DIRECT_IO;
            devObj->Flags |= ( devExt->LowerDevObj->Flags & DO_POWER_PAGABLE );
            devObj->Flags &= ~DO_DEVICE_INITIALIZING; // DO_POWER_PAGABLE must be set appropriately 
                                                      //   before clearing this bit to avoid a bugcheck

        } else {
            TR_FAIL(("AddDevice - IoAttachDeviceToDeviceStack - FAIL"));            
            status = STATUS_UNSUCCESSFUL; // for lack of a more appropriate status code
        }

    } else {
        TR_FAIL(("AddDevice - IoCreateDevice - FAIL - status= %x", status));
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\bio\inc\bdl.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    bdl.h

Abstract:

    This module contains all definitions for the biometric device driver library.

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created May 2002 by Reid Kuhn

--*/

#ifndef _BDL_
#define _BDL_

#ifdef __cplusplus
extern "C" {
#endif

#include <initguid.h>
DEFINE_GUID(BiometricDeviceGuid, 0x83970EB2, 0x86F6, 0x4F3A, 0xB5,0xF4,0xC6,0x05,0xAA,0x49,0x63,0xE1);

typedef PVOID       BDD_DATA_HANDLE;


#define BIO_BUFFER_TOO_SMALL 1L

#define BIO_ITEMTYPE_HANDLE 0x00000001
#define BIO_ITEMTYPE_BLOCK  0x00000002



//
///////////////////////////////////////////////////////////////////////////////
//
//  Device Action IOCTLs
//

#define BIO_CTL_CODE(code)        CTL_CODE(FILE_DEVICE_BIOMETRIC, \
                                            (code), \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define BDD_IOCTL_STARTUP               BIO_CTL_CODE(1)
#define BDD_IOCTL_SHUTDOWN              BIO_CTL_CODE(2)
#define BDD_IOCTL_GETDEVICEINFO         BIO_CTL_CODE(3)
#define BDD_IOCTL_DOCHANNEL             BIO_CTL_CODE(4)
#define BDD_IOCTL_GETCONTROL            BIO_CTL_CODE(5)
#define BDD_IOCTL_SETCONTROL            BIO_CTL_CODE(6)
#define BDD_IOCTL_CREATEHANDLEFROMDATA  BIO_CTL_CODE(7)
#define BDD_IOCTL_CLOSEHANDLE           BIO_CTL_CODE(8)
#define BDD_IOCTL_GETDATAFROMHANDLE     BIO_CTL_CODE(9)
#define BDD_IOCTL_REGISTERNOTIFY        BIO_CTL_CODE(10)
#define BDD_IOCTL_GETNOTIFICATION       BIO_CTL_CODE(11)


/////////////////////////////////////////////////////////////////////////////////////////
//
// These structures and typedefs are used when making BDSI calls
//

typedef struct _BDSI_ADDDEVICE
{
    IN ULONG                Size;
    IN PDEVICE_OBJECT       pPhysicalDeviceObject;
    OUT PVOID               pvBDDExtension;      

} BDSI_ADDDEVICE, *PBDSI_ADDDEVICE;


typedef struct _BDSI_INITIALIZERESOURCES
{
    IN ULONG                Size;   
    IN PCM_RESOURCE_LIST    pAllocatedResources;
    IN PCM_RESOURCE_LIST    pAllocatedResourcesTranslated;
    OUT WCHAR               wszSerialNumber[256];
    OUT ULONG		        HWVersionMajor;
    OUT ULONG		        HWVersionMinor;
    OUT ULONG		        HWBuildNumber;
    OUT ULONG		        BDDVersionMajor;
    OUT ULONG		        BDDVersionMinor;
    OUT ULONG		        BDDBuildNumber;

} BDSI_INITIALIZERESOURCES, *PBDSI_INITIALIZERESOURCES;


typedef struct _BDSI_DRIVERUNLOAD
{
    IN ULONG                Size;
    IN PIRP                 pIrp;

} BDSI_DRIVERUNLOAD, *PBDSI_DRIVERUNLOAD;


typedef enum _BDSI_POWERSTATE
{
    Off = 0,
    Low = 1,
    On  = 2

}BDSI_POWERSTATE, *PBDSI_POWERSTATE;


typedef struct _BDSI_SETPOWERSTATE
{
    IN ULONG                Size;
    IN BDSI_POWERSTATE      PowerState;

} BDSI_SETPOWERSTATE, *PBDSI_SETPOWERSTATE;



/////////////////////////////////////////////////////////////////////////////////////////
//
// These structures and typedefs are used when making BDDI calls
//

typedef struct _BDDI_ITEM
{
    ULONG Type;

    union _BDDI_ITEM_DATA
    {
        BDD_DATA_HANDLE Handle;

        struct _BDDI_ITEM_DATA_BLOCK
        {
            ULONG  cBuffer;
            PUCHAR pBuffer;
        } Block;

    } Data;

} BDDI_ITEM, *PBDDI_ITEM;

typedef PBDDI_ITEM  BDD_HANDLE;

typedef struct _BDDI_SOURCELIST
{
    ULONG                   NumSources;
    PBDDI_ITEM              *rgpSources;

} BDDI_SOURCELIST, *PBDDI_SOURCELIST;


typedef struct _BDDI_PARAMS_REGISTERNOTIFY
{
    IN ULONG                Size;
    IN BOOLEAN              fRegister;
    IN ULONG                ComponentId;
    IN ULONG            	ChannelId;
    IN ULONG                ControlId;

} BDDI_PARAMS_REGISTERNOTIFY, *PBDDI_PARAMS_REGISTERNOTIFY;


typedef struct _BDDI_PARAMS_DOCHANNEL
{
    IN ULONG                Size;
    IN ULONG                ComponentId;
    IN ULONG                ChannelId;
    IN PKEVENT              CancelEvent;
    IN BDDI_SOURCELIST      *rgSourceLists;
    IN OUT BDD_DATA_HANDLE  hStateData;
    OUT PBDDI_ITEM          *rgpProducts;
    OUT ULONG               BIOReturnCode;

} BDDI_PARAMS_DOCHANNEL, *PBDDI_PARAMS_DOCHANNEL;


typedef struct _BDDI_PARAMS_GETCONTROL
{
    IN ULONG                Size;
    IN ULONG                ComponentId;
    IN ULONG                ChannelId;
    IN ULONG                ControlId;
    OUT INT32               Value;
    OUT WCHAR               wszString[256];

} BDDI_PARAMS_GETCONTROL, *PBDDI_PARAMS_GETCONTROL;


typedef struct _BDDI_PARAMS_SETCONTROL
{
    IN ULONG                Size;
    IN ULONG                ComponentId;
    IN ULONG                ChannelId;
    IN ULONG                ControlId;
    IN INT32                Value;
    IN WCHAR                wszString[256];

} BDDI_PARAMS_SETCONTROL, *PBDDI_PARAMS_SETCONTROL;


typedef struct _BDDI_PARAMS_CREATEHANDLE_FROMDATA
{
    IN ULONG                Size;
    IN GUID                 guidFormatId;
    IN ULONG                cBuffer;
    IN PUCHAR               pBuffer;
    OUT BDD_DATA_HANDLE     hData;

} BDDI_PARAMS_CREATEHANDLE_FROMDATA, *PBDDI_PARAMS_CREATEHANDLE_FROMDATA;


typedef struct _BDDI_PARAMS_CLOSEHANDLE
{
    IN ULONG                Size;
    IN BDD_DATA_HANDLE      hData;

} BDDI_PARAMS_CLOSEHANDLE, *PBDDI_PARAMS_CLOSEHANDLE;


typedef struct _BDDI_PARAMS_GETDATA_FROMHANDLE
{
    IN ULONG                Size;
    IN BDD_DATA_HANDLE      hData;
    IN OUT ULONG            cBuffer;
    IN OUT PUCHAR           pBuffer;
    OUT ULONG               BIOReturnCode;

} BDDI_PARAMS_GETDATA_FROMHANDLE, *PBDDI_PARAMS_GETDATA_FROMHANDLE;



/////////////////////////////////////////////////////////////////////////////////////////
//
// These strucutres and typedefs are used to pass pointers to the BDD's BDDI functions
// when calling bdliInitialize
//

typedef NTSTATUS FN_BDDI_REGISTERNOTIFY (PBDL_DEVICEEXT, PBDDI_PARAMS_REGISTERNOTIFY);
typedef FN_BDDI_REGISTERNOTIFY *PFN_BDDI_REGISTERNOTIFY;

typedef NTSTATUS FN_BDDI_DOCHANNEL (PBDL_DEVICEEXT, PBDDI_PARAMS_DOCHANNEL);
typedef FN_BDDI_DOCHANNEL *PFN_BDDI_DOCHANNEL;

typedef NTSTATUS FN_BDDI_GETCONTROL (PBDL_DEVICEEXT, PBDDI_PARAMS_GETCONTROL);
typedef FN_BDDI_GETCONTROL *PFN_BDDI_GETCONTROL;

typedef NTSTATUS FN_BDDI_SETCONTROL (PBDL_DEVICEEXT, PBDDI_PARAMS_SETCONTROL);
typedef FN_BDDI_SETCONTROL *PFN_BDDI_SETCONTROL;

typedef NTSTATUS FN_BDDI_CREATEHANDLE_FROMDATA (PBDL_DEVICEEXT, PBDDI_PARAMS_CREATEHANDLE_FROMDATA);
typedef FN_BDDI_CREATEHANDLE_FROMDATA *PFN_BDDI_CREATEHANDLE_FROMDATA;

typedef NTSTATUS FN_BDDI_CLOSEHANDLE (PBDL_DEVICEEXT, PBDDI_PARAMS_CLOSEHANDLE);
typedef FN_BDDI_CLOSEHANDLE *PFN_BDDI_CLOSEHANDLE;

typedef NTSTATUS FN_BDDI_GETDATA_FROMHANDLE (PBDL_DEVICEEXT, PBDDI_PARAMS_GETDATA_FROMHANDLE);
typedef FN_BDDI_GETDATA_FROMHANDLE *PFN_BDDI_GETDATA_FROMHANDLE;

typedef struct _BDLI_BDDIFUNCTIONS
{
  ULONG Size;

  PFN_BDDI_REGISTERNOTIFY           pfbddiRegisterNotify;
  PFN_BDDI_DOCHANNEL                pfbddiDoChannel;
  PFN_BDDI_GETCONTROL               pfbddiGetControl;
  PFN_BDDI_SETCONTROL               pfbddiSetControl;
  PFN_BDDI_CREATEHANDLE_FROMDATA    pfbddiCreateHandleFromData;
  PFN_BDDI_CLOSEHANDLE              pfbddiCloseHandle;
  PFN_BDDI_GETDATA_FROMHANDLE       pfbddiGetDataFromHandle;

} BDLI_BDDIFUNCTIONS, *PBDLI_BDDIFUNCTIONS;


/////////////////////////////////////////////////////////////////////////////////////////
//
// These strucutres and typedefs are used to pass pointers to the BDD's BDSI functions
// when calling bdliInitialize
//

typedef NTSTATUS FN_BDSI_ADDDEVICE (PBDL_DEVICEEXT, PBDSI_ADDDEVICE);
typedef FN_BDSI_ADDDEVICE *PFN_BDSI_ADDDEVICE;

typedef NTSTATUS FN_BDSI_REMOVEDEVICE (PBDL_DEVICEEXT);
typedef FN_BDSI_REMOVEDEVICE *PFN_BDSI_REMOVEDEVICE;

typedef NTSTATUS FN_BDSI_INITIALIZERESOURCES (PBDL_DEVICEEXT, PBDSI_INITIALIZERESOURCES);
typedef FN_BDSI_INITIALIZERESOURCES *PFN_BDSI_INITIALIZERESOURCES;

typedef NTSTATUS FN_BDSI_RELEASERESOURCES (PBDL_DEVICEEXT);
typedef FN_BDSI_RELEASERESOURCES *PFN_BDSI_RELEASERESOURCES;

typedef NTSTATUS FN_BDSI_STARTUP (PBDL_DEVICEEXT);
typedef FN_BDSI_STARTUP *PFN_BDSI_STARTUP;

typedef NTSTATUS FN_BDSI_SHUTDOWN (PBDL_DEVICEEXT);
typedef FN_BDSI_SHUTDOWN *PFN_BDSI_SHUTDOWN;

typedef NTSTATUS FN_BDSI_DRIVERUNLOAD (PBDL_DEVICEEXT, PBDSI_DRIVERUNLOAD);
typedef FN_BDSI_DRIVERUNLOAD *PFN_BDSI_DRIVERUNLOAD;

typedef NTSTATUS FN_BDSI_SETPOWERSTATE (PBDL_DEVICEEXT, PBDSI_SETPOWERSTATE);
typedef FN_BDSI_SETPOWERSTATE *PFN_BDSI_SETPOWERSTATE;

typedef struct _BDLI_BDSIFUNCTIONS
{
  ULONG Size;

  PFN_BDSI_ADDDEVICE            pfbdsiAddDevice;
  PFN_BDSI_REMOVEDEVICE         pfbdsiRemoveDevice;
  PFN_BDSI_INITIALIZERESOURCES  pfbdsiInitializeResources;
  PFN_BDSI_RELEASERESOURCES     pfbdsiReleaseResources;
  PFN_BDSI_STARTUP              pfbdsiStartup;
  PFN_BDSI_SHUTDOWN             pfbdsiShutdown;
  PFN_BDSI_DRIVERUNLOAD         pfbdsiDriverUnload;
  PFN_BDSI_SETPOWERSTATE        pfbdsiSetPowerState;

} BDLI_BDSIFUNCTIONS, *PBDLI_BDSIFUNCTIONS;



typedef struct _BDL_DEVICEEXT
{
    //
    // size of this struct
    //
    ULONG               Size;

    //
    // The device object that we are attached to
    //
    PDEVICE_OBJECT      pAttachedDeviceObject;

    //
    // The BDD's extension
    //
    PVOID               pvBDDExtension;

} BDL_DEVICEEXT, *PBDL_DEVICEEXT;



/////////////////////////////////////////////////////////////////////////////////////////
//
// These functions are exported by the BDL
//

//
// bdliInitialize()
//
// Called in response to the BDD receiving its DriverEntry call.  This lets the BDL
// know that a new BDD has been loaded and allows the BDL to initialize its state so that
// it can manage the newly loaded BDD.
//
// The bdliInitialize call will set the appropriate fields in the DRIVER_OBJECT so that
// the BDL will receive all the necessary callbacks from the system for PNP events,
// Power events, and general driver functionality.  The BDL will then forward calls that
// require hardware support to the BDD that called bdliInitialize (it will do so using
// the BDDI and BDSI APIs).  A BDD must call the bdliInitialize call during its
// DriverEntry function.
//
// PARAMETERS:
// DriverObject     This must be the DRIVER_OBJECT pointer that was passed into the
//                  BDD's DriverEntry call.
// RegistryPath     This must be the UNICODE_STRING pointer that was passed into the
//                  BDD's DriverEntry call.
// pBDDIFunctions   Pointer to a  BDLI_BDDIFUNCTIONS structure that is filled in with the
//                  entry points that the BDD exports to support the BDDI API set.  The
//                  pointers themselves are copied by the BDL, as opposed to saving the
//                  pBDDIFunctions pointer, so the memory pointed to by pBDDIFunctions
//                  need not remain accessible after the bdliInitialize call.
// pBDSIFunctions   Pointer to a  BDLI_BDSIFUNCTIONS structure that is filled in with
//                  the entry points that the BDD exports to support the BDSI API set.
//                  The pointers themselves are copied by the BDL, as opposed to saving
//                  the pBDSIFunctions pointer, so the memory pointed to by
//                  pBDSIFunctions need not remain accessible after the bdliInitialize
//                  call.
// Flags            Unused.  Must be 0.
// pReserved        Unused.  Must be NULL.
//
// RETURNS:
// STATUS_SUCCESS   If the bdliInitialize call succeeded
//

NTSTATUS
bdliInitialize
(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING      RegistryPath,
    IN PBDLI_BDDIFUNCTIONS  pBDDIFunctions,
    IN PBDLI_BDSIFUNCTIONS  pBDSIFunctions,
    IN ULONG                Flags,
    IN PVOID                pReserved
);


//
// bdliAlloc()
//
// Allocates memory that can be returned to the BDL.
//
// The BDD must always use this function to allocate memory that it will return to the
// BDL as an OUT parameter of a BDDI call.  Once memory has been returned to the BDL,
// it will be owned and managed exclusively by the BDL and must not be further referenced
// by the BDD.  (Each BDDI call that requires the use of bdliAlloc will note it).
//
// PARAMETERS:
// pBDLExt          Pointer to the BDL_DEVICEEXT  structure that was passed into the
//                  bdsiAddDevice call.
// cBytes           The number of bytes to allocate.
// Flags            Unused.  Must be 0.
//
// RETURNS:
// Returns a pointer to the allocated memory, or NULL if the function fails.
//

void *
bdliAlloc
(
    IN PBDL_DEVICEEXT       pBDLExt,
    IN ULONG                cBytes,
    IN ULONG                Flags
);


//
// bdliFree()
//
// Frees memory allocated by bdliAlloc.
//
// Memory allocated by bdliAlloc is almost always passed to the BDL as a channel product
// (as a BLOCK-type item) and subsequently freed by the BDL.  However, if an error
// occurs while processing a channel, the BDD may need to call bdliFree to free memory it
// previous allocated via bdliAlloc.
//
// PARAMETERS:
// pvBlock          Block of memory passed in by the BDL.
//
// RETURNS:
// No return value.
//

void
bdliFree
(
    IN PVOID                pvBlock
);


//
// bdliLogError()
//
// Writes an error to the event log.
//
// Provides a simple mechanism for BDD writers to write errors to the system event log
// without the overhead of registering with the event logging subsystem.
//
// PARAMETERS:
// pObject          If the error being logged is device specific then this must be a
//                  pointer to the BDL_DEVICEEXT  structure that was passed into the
//                  bdsiAddDevice call when the device was added.  If the error being
//                  logged is a general BDD error, then this must be same DRIVER_OBJECT
//                  structure pointer that was passed into the DriverEntry call of the
//                  BDD when the driver was loaded.
// ErrorCode        Error code of the function logging the error.
// Insertion        An insertion string to be written to the event log. Your message file
//                  must have a place holder for the insertion. For example, "serial port
//                  %2 is either not available or used by another device". In this
//                  example, %2 will be replaced by the insertion string. Note that %1 is
//                  reserved for the file name.
// cDumpData        The number of bytes pointed to by pDumpData.
// pDumpData        A data block to be displayed in the data window of the event log.
//                  This may be NULL if the caller does not wish to display any dump data.
// Flags            Unused.  Must be 0.
// pReserved        Unused.  Must be NULL.
//
// RETURNS:
// STATUS_SUCCESS   If the bdliLogError call succeeded
//

NTSTATUS
bdliLogError
(
    IN PVOID                pObject,
    IN NTSTATUS             ErrorCode,
    IN PUNICODE_STRING      Insertion,
    IN ULONG                cDumpData,
    IN PUCHAR               pDumpData,
    IN ULONG                Flags,
    IN PVOID                pReserved
);


//
// bdliControlChange()
//
// This function allows BDDs to asynchronously return the values of its controls.
//
// bdliControlChange is generally called by the BDD in response to one of its controls
// changing a value.  Specifically, it is most often used in the case of a sensor
// control that has changed from 0 to 1 indicating that a source is present and a sample
// can be taken.
//
// PARAMETERS:
// pBDLExt          Pointer to the BDL_DEVICEEXT  structure that was passed into the
//                  bdsiAddDevice call.
// ComponentId      Specifies either the Component ID of the component in which the
//                  control or the control's parent channel resides, or '0' to indicate
//                  that dwControlId refers to a device control.
// ChannelId        If dwComponentId is not '0', dwChannelId specifies either the Channel
//                  ID of the channel in which the control resides, or '0' to indicate
//                  that dwControlId refers to a component control.Ignored if
//                  dwComponentId is '0'.
// ControlId        ControlId of the changed control.
// Value            Specifies the new value for the control .
// Flags            Unused.  Must be 0.
// pReserved        Unused.  Must be NULL.

//
// RETURNS:
// STATUS_SUCCESS   If the bdliControlChange call succeeded
//

NTSTATUS
bdliControlChange
(
    IN PBDL_DEVICEEXT       pBDLExt,
    IN ULONG                ComponentId,
    IN ULONG                ChannelId,
    IN ULONG                ControlId,
    IN ULONG                Value,
    IN ULONG                Flags,
    IN PVOID                pReserved
);



//
// These functions and defines can be used for debugging purposes
//

#define BDL_DEBUG_TRACE     ((ULONG) 0x00000001)
#define BDL_DEBUG_ERROR     ((ULONG) 0x00000002)
#define BDL_DEBUG_ASSERT    ((ULONG) 0x00000004)

ULONG
BDLGetDebugLevel();

#if DBG

#define BDLDebug(LEVEL, STRING) \
        { \
            if (LEVEL & BDL_DEBUG_TRACE & BDLGetDebugLevel()) \
                KdPrint(STRING); \
            if (LEVEL & BDL_DEBUG_ERROR & BDLGetDebugLevel()) \
                KdPrint(STRING);\
            if (BDLGetDebugLevel() & BDL_DEBUG_ASSERT) \
                _asm int 3 \
        }

#else

#define BDLDebug(LEVEL, STRING)

#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\bio\bdl\devcaps.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    devcaps.c

Abstract:

    This module contains the implementation for the
    Microsoft Biometric Device Library

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 2002 by Reid Kuhn

--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <strsafe.h>

#include <wdm.h>

#include "bdlint.h"


#define DEVICE_REGISTRY_PATH    L"\\Registry\\Machine\\Software\\Microsoft\\BAPI\\BSPs\\Microsoft Kernel BSP\\Devices\\"
#define PNPID_VALUE_NAME        L"PNP ID"

NTSTATUS
BDLBuildRegKeyPath
(
    PDEVICE_OBJECT                  pPhysicalDeviceObject,
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension,
    LPWSTR                          *pwszDeviceRegistryKeyName
)
{
    NTSTATUS                        status                  = STATUS_SUCCESS;
    HANDLE                          hDevInstRegyKey         = NULL;
    ULONG                           cbKeyName;
    UNICODE_STRING                  ValueName;
    KEY_VALUE_BASIC_INFORMATION     *pKeyValueInformation   = NULL;
    ULONG                           ResultLength;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLBuildRegKeyPath: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Opend the device specific registry location
    //
    status = IoOpenDeviceRegistryKey(
                    pPhysicalDeviceObject,
                    PLUGPLAY_REGKEY_DEVICE,
                    KEY_READ | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                    &hDevInstRegyKey);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLBuildRegKeyPath: IoOpenDeviceRegistryKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Query the PNP ID from the device specific registry location
    //
    RtlInitUnicodeString(&ValueName, PNPID_VALUE_NAME);

    status = ZwQueryValueKey(
                    hDevInstRegyKey,
                    &ValueName,
                    KeyValueBasicInformation,
                    NULL,
                    0,
                    &ResultLength);

    pKeyValueInformation = ExAllocatePoolWithTag(PagedPool, ResultLength, BDL_ULONG_TAG);

    if (pKeyValueInformation == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLBuildRegKeyPath: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    status = ZwQueryValueKey(
                    hDevInstRegyKey,
                    &ValueName,
                    KeyValueBasicInformation,
                    pKeyValueInformation,
                    ResultLength,
                    &ResultLength);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLBuildRegKeyPath: ZwQueryValueKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    if (pKeyValueInformation->Type != REG_SZ)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLBuildRegKeyPath: PNP ID is not a string type\n",
               __DATE__,
               __TIME__))

        ASSERT(0);
        status = STATUS_UNSUCCESSFUL;
        goto ErrorReturn;
    }

    //
    // Allocate space for the concatenatenation of the base registry name with the
    // PnP name of the current device and pass that concatenation back
    //
    cbKeyName = pKeyValueInformation->NameLength + ((wcslen(DEVICE_REGISTRY_PATH) + 1) * sizeof(WCHAR));
    *pwszDeviceRegistryKeyName = ExAllocatePoolWithTag(PagedPool, cbKeyName, BDL_ULONG_TAG);

    if (*pwszDeviceRegistryKeyName == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLBuildRegKeyPath: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    StringCbCopyW(*pwszDeviceRegistryKeyName, cbKeyName, DEVICE_REGISTRY_PATH);

    RtlCopyMemory(
        &((*pwszDeviceRegistryKeyName)[wcslen(DEVICE_REGISTRY_PATH)]),
        pKeyValueInformation->Name,
        pKeyValueInformation->NameLength);

    (*pwszDeviceRegistryKeyName)[cbKeyName / sizeof(WCHAR)] = L'\0';

Return:

    if (hDevInstRegyKey != NULL)
    {
        ZwClose(hDevInstRegyKey);
    }

    if (pKeyValueInformation != NULL)
    {
        ExFreePoolWithTag(pKeyValueInformation, BDL_ULONG_TAG);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLBuildRegKeyPath: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    goto Return;
}


NTSTATUS
BDLOpenSubkey
(
    HANDLE                          hRegKey,
    WCHAR                           *szKey,
    HANDLE                          *phSubKey
)
{
    UNICODE_STRING                  UnicodeString;
    OBJECT_ATTRIBUTES               ObjectAttributes;

    RtlInitUnicodeString(&UnicodeString, szKey);

    InitializeObjectAttributes(
                &ObjectAttributes,
                &UnicodeString,
                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                hRegKey,
                NULL);

    return (ZwOpenKey(
                phSubKey,
                KEY_READ | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                &ObjectAttributes));
}


NTSTATUS
BDLGetValue
(
    HANDLE                          hRegKey,
    ULONG                           Type,
    WCHAR                           *szValue,
    ULONG                           *pULONGValue,
    WCHAR                           **pszValue
)
{
    NTSTATUS                        status                      = STATUS_SUCCESS;
    KEY_VALUE_FULL_INFORMATION      *pKeyValueFullInformation   = NULL;
    ULONG                           ResultLength;
    UNICODE_STRING                  UnicodeString;
    ULONG                           NumChars;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetValue: Enter\n",
           __DATE__,
           __TIME__))

    RtlInitUnicodeString(&UnicodeString, szValue);

    status = ZwQueryValueKey(
                hRegKey,
                &UnicodeString,
                KeyValueFullInformation,
                NULL,
                0,
                &ResultLength);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetValue: ZwQueryValueKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    pKeyValueFullInformation = ExAllocatePoolWithTag(PagedPool, ResultLength, BDL_ULONG_TAG);

    if (pKeyValueFullInformation == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetValue: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    status = ZwQueryValueKey(
                hRegKey,
                &UnicodeString,
                KeyValueFullInformation,
                pKeyValueFullInformation,
                ResultLength,
                &ResultLength);

    if (pKeyValueFullInformation->Type != Type)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetValue: %S is not of Type %lx\n",
               __DATE__,
               __TIME__,
               szValue,
               Type))

        ASSERT(0);
        status = STATUS_UNSUCCESSFUL;
        goto ErrorReturn;
    }

    if (Type == REG_DWORD) 
    {
        *pULONGValue = *((ULONG *) 
                    (((PUCHAR) pKeyValueFullInformation) + pKeyValueFullInformation->DataOffset));

    }
    else
    {
        NumChars = pKeyValueFullInformation->DataLength / sizeof(WCHAR);

        *pszValue = ExAllocatePoolWithTag(
                        PagedPool, 
                        (NumChars + 1) * sizeof(WCHAR), 
                        BDL_ULONG_TAG);

        if (*pszValue == NULL)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetValue: ExAllocatePoolWithTag failed\n",
                   __DATE__,
                   __TIME__))
    
            status = STATUS_NO_MEMORY;
            goto ErrorReturn;
        }

        RtlCopyMemory(
                *pszValue, 
                ((PUCHAR) pKeyValueFullInformation) + pKeyValueFullInformation->DataOffset,
                pKeyValueFullInformation->DataLength);

        (*pszValue)[NumChars] = L'\0';
    }
    
Return:

    if (pKeyValueFullInformation != NULL)
    {
        ExFreePoolWithTag(pKeyValueFullInformation, BDL_ULONG_TAG);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetValue: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    goto Return;
}


NTSTATUS
BDLGetControls
(
    HANDLE                          hRegKey,
    ULONG                           *pNumControls,
    BDL_CONTROL                     **prgControls
)
{
    NTSTATUS                        status                      = STATUS_SUCCESS;
    HANDLE                          hControlsKey                = NULL;
    UNICODE_STRING                  UnicodeString;
    KEY_FULL_INFORMATION            ControlsKeyFullInfo;
    ULONG                           ReturnedSize;
    ULONG                           i;
    HANDLE                          hControlIdKey               = NULL;
    KEY_BASIC_INFORMATION           *pControlIdKeyBasicInfo     = NULL;
    ULONG                           KeyBasicInfoSize            = 0;
    ULONG                           NumericMinimum              = 0;
    ULONG                           NumericMaximum              = 0;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetControls: Enter\n",
           __DATE__,
           __TIME__))

    *pNumControls = 0;
    *prgControls = NULL;

    //
    // Open the "Controls" key so it can be used to query all subkeys and values
    //
    status = BDLOpenSubkey(hRegKey, L"Controls", &hControlsKey);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetControls: BDLOpenSubkey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Find out how many controls there are
    //
    status = ZwQueryKey(
                hControlsKey,
                KeyFullInformation,
                &ControlsKeyFullInfo,
                sizeof(ControlsKeyFullInfo),
                &ReturnedSize);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetControls: ZwQueryKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Allocate the array of controls
    //
    *prgControls = ExAllocatePoolWithTag(
                        PagedPool,
                        ControlsKeyFullInfo.SubKeys * sizeof(BDL_CONTROL),
                        BDL_ULONG_TAG);

    if (*prgControls == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetControls: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    *pNumControls = ControlsKeyFullInfo.SubKeys;
    RtlZeroMemory(*prgControls, ControlsKeyFullInfo.SubKeys * sizeof(BDL_CONTROL));

    //
    // Allocate a structure for querying key names that is large enough to hold all of them
    //
    KeyBasicInfoSize = sizeof(KEY_BASIC_INFORMATION) + ControlsKeyFullInfo.MaxNameLen;
    pControlIdKeyBasicInfo = ExAllocatePoolWithTag(
                                    PagedPool,
                                    KeyBasicInfoSize + 1,
                                    BDL_ULONG_TAG);

    if (pControlIdKeyBasicInfo == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetControls: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Loop for each Control SubKey and get the relevant info
    //
    for (i = 0; i < ControlsKeyFullInfo.SubKeys; i++)
    {
        //
        // Get the name on the <Control Id> key
        //
        status = ZwEnumerateKey(
                    hControlsKey,
                    i,
                    KeyBasicInformation,
                    pControlIdKeyBasicInfo,
                    KeyBasicInfoSize,
                    &ReturnedSize);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetControls: ZwEnumerateKey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Change the <Control ID> key string to a value
        //
        pControlIdKeyBasicInfo->Name[pControlIdKeyBasicInfo->NameLength / sizeof(WCHAR)] = L'\0';
        RtlInitUnicodeString(&UnicodeString, pControlIdKeyBasicInfo->Name);
        RtlUnicodeStringToInteger(&UnicodeString, 16, &((*prgControls)[i].ControlId));

        //
        // Open up the <Control ID> key
        //
        status = BDLOpenSubkey(hControlsKey, pControlIdKeyBasicInfo->Name, &hControlIdKey);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetControls: BDLOpenSubkey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get all the values under the key
        //
        if ((STATUS_SUCCESS != (status = BDLGetValue(
                                                hControlIdKey,
                                                REG_DWORD,
                                                L"NumericMinimum",
                                                &(NumericMinimum),
                                                NULL))) ||
            (STATUS_SUCCESS != (status = BDLGetValue(
                                                hControlIdKey,
                                                REG_DWORD,
                                                L"NumericMaximum",
                                                &(NumericMaximum),
                                                NULL))) ||
            (STATUS_SUCCESS != (status = BDLGetValue(
                                                hControlIdKey,
                                                REG_DWORD,
                                                L"NumericGranularity",
                                                &((*prgControls)[i].NumericGranularity),
                                                NULL))) ||
            (STATUS_SUCCESS != (status = BDLGetValue(
                                                hControlIdKey,
                                                REG_DWORD,
                                                L"NumericDivisor",
                                                &((*prgControls)[i].NumericDivisor),
                                                NULL))) ||
            (STATUS_SUCCESS != (status = BDLGetValue(
                                                hControlIdKey,
                                                REG_DWORD,
                                                L"Flags",
                                                &((*prgControls)[i].Flags),
                                                NULL))))
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetControls: BDLGetValue failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Convert Min and Max to 32-bit integers
        // 
        if (NumericMinimum | 0x8000000) 
        {
            (*prgControls)[i].NumericMinimum = 
                    0 - (((INT32) (((ULONG) 0xFFFFFFFF) - NumericMinimum)) + 1);
        }
        else
        {
            (*prgControls)[i].NumericMinimum = (INT32) NumericMinimum;
        }

        if (NumericMaximum | 0x8000000) 
        {
            (*prgControls)[i].NumericMaximum = 
                    0 - (((INT32) (((ULONG) 0xFFFFFFFF) - NumericMaximum)) + 1);
        }
        else
        {
            (*prgControls)[i].NumericMaximum = (INT32) NumericMaximum;
        }

        ZwClose(hControlIdKey);
        hControlIdKey = NULL;
    }

Return:

    if (hControlsKey != NULL)
    {
        ZwClose(hControlsKey);
    }

    if (hControlIdKey != NULL)
    {
        ZwClose(hControlIdKey);
    }

    if (pControlIdKeyBasicInfo != NULL)
    {
        ExFreePoolWithTag(pControlIdKeyBasicInfo, BDL_ULONG_TAG);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetControls: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    goto Return;
}


NTSTATUS
BDLGetSourceLists
(
    HANDLE                          hRegKey,
    ULONG                           *pNumSourceLists,
    BDL_CHANNEL_SOURCE_LIST         **prgSourceLists
)
{
    NTSTATUS                        status                          = STATUS_SUCCESS;
    HANDLE                          hSourcesKey                     = NULL;
    UNICODE_STRING                  UnicodeString;
    KEY_FULL_INFORMATION            SourcesKeyFullInfo;
    ULONG                           ReturnedSize;
    ULONG                           i;
    HANDLE                          hSourceListIndexKey             = NULL;
    KEY_BASIC_INFORMATION           *pSourcesListIndexKeyBasicInfo  = NULL;
    ULONG                           KeyBasicInfoSize                = 0;
    WCHAR                           *szGUID                         = NULL;                 

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetSourceLists: Enter\n",
           __DATE__,
           __TIME__))

    *pNumSourceLists = 0;
    *prgSourceLists = NULL;

    //
    // Open the "Sources" key so it can be used to query all subkeys and values
    //
    status = BDLOpenSubkey(hRegKey, L"Sources", &hSourcesKey);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetSourceLists: BDLOpenSubkey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Find out how many sources lists there are
    //
    status = ZwQueryKey(
                hSourcesKey,
                KeyFullInformation,
                &SourcesKeyFullInfo,
                sizeof(SourcesKeyFullInfo),
                &ReturnedSize);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetSourceLists: ZwQueryKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Allocate the array of sources lists
    //
    *prgSourceLists = ExAllocatePoolWithTag(
                        PagedPool,
                        SourcesKeyFullInfo.SubKeys * sizeof(BDL_CHANNEL_SOURCE_LIST),
                        BDL_ULONG_TAG);

    if (*prgSourceLists == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetSourceLists: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    *pNumSourceLists = SourcesKeyFullInfo.SubKeys;
    RtlZeroMemory(*prgSourceLists, SourcesKeyFullInfo.SubKeys * sizeof(BDL_CHANNEL_SOURCE_LIST));

    //
    // Allocate a structure for querying key names that is large enough to hold all of them
    //
    KeyBasicInfoSize = sizeof(KEY_BASIC_INFORMATION) + SourcesKeyFullInfo.MaxNameLen;
    pSourcesListIndexKeyBasicInfo = ExAllocatePoolWithTag(
                                        PagedPool,
                                        KeyBasicInfoSize + 1,
                                        BDL_ULONG_TAG);

    if (pSourcesListIndexKeyBasicInfo == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetSourceLists: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Loop for each Source List Index SubKey and get the relevant info
    //
    for (i = 0; i < SourcesKeyFullInfo.SubKeys; i++)
    {
        //
        // Get the name of the <Source List Index> key
        //
        // NOTE: This code does not ensure that the key names progress from "0" to "1"
        // to "n".  The WHQL driver validation ensures proper registry form.
        //
        status = ZwEnumerateKey(
                    hSourcesKey,
                    i,
                    KeyBasicInformation,
                    pSourcesListIndexKeyBasicInfo,
                    KeyBasicInfoSize,
                    &ReturnedSize);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetSourceLists: ZwEnumerateKey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Open up the <Source List Index> key
        //
        status = BDLOpenSubkey(
                    hSourcesKey, 
                    pSourcesListIndexKeyBasicInfo->Name, 
                    &hSourceListIndexKey);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetSourceLists: BDLOpenSubkey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get all the values under the key
        //
        if ((STATUS_SUCCESS != (status = BDLGetValue(
                                                hSourceListIndexKey,
                                                REG_SZ,
                                                L"Format",
                                                NULL,
                                                &szGUID))) ||
            (STATUS_SUCCESS != (status = BDLGetValue(
                                                hSourceListIndexKey,
                                                REG_DWORD,
                                                L"Min",
                                                &((*prgSourceLists)[i].MinSources),
                                                NULL))) ||
            (STATUS_SUCCESS != (status = BDLGetValue(
                                                hSourceListIndexKey,
                                                REG_DWORD,
                                                L"Max",
                                                &((*prgSourceLists)[i].MaxSources),
                                                NULL))) ||
            (STATUS_SUCCESS != (status = BDLGetValue(
                                                hSourceListIndexKey,
                                                REG_DWORD,
                                                L"Flags",
                                                &((*prgSourceLists)[i].Flags),
                                                NULL))))
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetSourceLists: BDLGetValue failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Convert the Format GUID string to an actual GUID         
        //
        RtlInitUnicodeString(&UnicodeString, szGUID);
        status = RtlGUIDFromString(&UnicodeString, &((*prgSourceLists)[i].FormatGUID));

        ZwClose(hSourceListIndexKey);
        hSourceListIndexKey = NULL;
    }

Return:

    if (hSourcesKey != NULL)
    {
        ZwClose(hSourcesKey);
    }

    if (hSourceListIndexKey != NULL)
    {
        ZwClose(hSourceListIndexKey);
    }

    if (pSourcesListIndexKeyBasicInfo != NULL)
    {
        ExFreePoolWithTag(pSourcesListIndexKeyBasicInfo, BDL_ULONG_TAG);
    }

    if (szGUID != NULL) 
    {
        ExFreePoolWithTag(szGUID, BDL_ULONG_TAG);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetSourceLists: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    goto Return;
}


NTSTATUS
BDLGetProducts
(
    HANDLE          hRegKey,
    ULONG           *pNumProducts,
    BDL_PRODUCT     **prgProducts
)
{
    NTSTATUS                        status                      = STATUS_SUCCESS;
    HANDLE                          hProductsKey                = NULL;
    UNICODE_STRING                  UnicodeString;
    KEY_FULL_INFORMATION            ProductsKeyFullInfo;
    ULONG                           ReturnedSize;
    ULONG                           i;
    HANDLE                          hProductIndexKey            = NULL;
    KEY_BASIC_INFORMATION           *pProductIndexKeyBasicInfo  = NULL;
    ULONG                           KeyBasicInfoSize            = 0;    

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetProducts: Enter\n",
           __DATE__,
           __TIME__))

    *pNumProducts = 0;
    *prgProducts = NULL;

    //
    // Open the "Products" key so it can be used to query all subkeys and values
    //
    status = BDLOpenSubkey(hRegKey, L"Products", &hProductsKey);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetProducts: BDLOpenSubkey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Find out how many products there are
    //
    status = ZwQueryKey(
                hProductsKey,
                KeyFullInformation,
                &ProductsKeyFullInfo,
                sizeof(ProductsKeyFullInfo),
                &ReturnedSize);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetProducts: ZwQueryKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Allocate the array of products
    //
    *prgProducts = ExAllocatePoolWithTag(
                        PagedPool,
                        ProductsKeyFullInfo.SubKeys * sizeof(BDL_PRODUCT),
                        BDL_ULONG_TAG);

    if (*prgProducts == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetProducts: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    *pNumProducts = ProductsKeyFullInfo.SubKeys;
    RtlZeroMemory(*prgProducts, ProductsKeyFullInfo.SubKeys * sizeof(BDL_PRODUCT));

    //
    // Allocate a structure for querying key names that is large enough to hold all of them
    //
    KeyBasicInfoSize = sizeof(KEY_BASIC_INFORMATION) + ProductsKeyFullInfo.MaxNameLen;
    pProductIndexKeyBasicInfo = ExAllocatePoolWithTag(
                                        PagedPool,
                                        KeyBasicInfoSize + 1,
                                        BDL_ULONG_TAG);

    if (pProductIndexKeyBasicInfo == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetProducts: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Loop for each Source List Index SubKey and get the relevant info
    //
    for (i = 0; i < ProductsKeyFullInfo.SubKeys; i++)
    {
        //
        // Get the name of the <Product Index> key
        //
        // NOTE: This code does not ensure that the key names progress from "0" to "1"
        // to "n".  The WHQL driver validation ensures proper registry form.
        //
        status = ZwEnumerateKey(
                    hProductsKey,
                    i,
                    KeyBasicInformation,
                    pProductIndexKeyBasicInfo,
                    KeyBasicInfoSize,
                    &ReturnedSize);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetProducts: ZwEnumerateKey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Open up the <Product Index> key
        //
        status = BDLOpenSubkey(
                    hProductsKey, 
                    pProductIndexKeyBasicInfo->Name, 
                    &hProductIndexKey);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetProducts: BDLOpenSubkey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get all the values under the key
        //
        if (STATUS_SUCCESS != (status = BDLGetValue(
                                                hProductIndexKey,
                                                REG_DWORD,
                                                L"Flags",
                                                &((*prgProducts)[i].Flags),
                                                NULL)))
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetProducts: BDLGetValue failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        ZwClose(hProductIndexKey);
        hProductIndexKey = NULL;
    }

Return:

    if (hProductsKey != NULL)
    {
        ZwClose(hProductsKey);
    }

    if (hProductIndexKey != NULL)
    {
        ZwClose(hProductIndexKey);
    }

    if (pProductIndexKeyBasicInfo != NULL)
    {
        ExFreePoolWithTag(pProductIndexKeyBasicInfo, BDL_ULONG_TAG);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetProducts: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    goto Return;
}


NTSTATUS
BDLGetChannels
(
    HANDLE                          hRegKey,
    ULONG                           *pNumChannels,
    BDL_CHANNEL                     **prgChannels
)
{
    NTSTATUS                        status                      = STATUS_SUCCESS;
    HANDLE                          hChannelsKey                = NULL;
    KEY_FULL_INFORMATION            ChannelsKeyFullInfo;
    UNICODE_STRING                  UnicodeString;
    ULONG                           ReturnedSize;
    ULONG                           i;
    HANDLE                          hChannelIdKey               = NULL;
    KEY_BASIC_INFORMATION           *pChannelIdKeyBasicInfo     = NULL;
    ULONG                           KeyBasicInfoSize            = 0;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetChannels: Enter\n",
           __DATE__,
           __TIME__))

    *pNumChannels = 0;
    *prgChannels = NULL;

    //
    // Open the "Channels" key so it can be used to query all subkeys and values
    //
    status = BDLOpenSubkey(hRegKey, L"Channels", &hChannelsKey);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetChannels: BDLOpenSubkey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Find out how many controls there are
    //
    status = ZwQueryKey(
                hChannelsKey,
                KeyFullInformation,
                &ChannelsKeyFullInfo,
                sizeof(ChannelsKeyFullInfo),
                &ReturnedSize);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetChannels: ZwQueryKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Allocate the array of channels
    //
    *prgChannels = ExAllocatePoolWithTag(
                            PagedPool,
                            ChannelsKeyFullInfo.SubKeys * sizeof(BDL_CHANNEL),
                            BDL_ULONG_TAG);

    if (*prgChannels == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetChannels: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    *pNumChannels = ChannelsKeyFullInfo.SubKeys;
    RtlZeroMemory(*prgChannels, ChannelsKeyFullInfo.SubKeys * sizeof(BDL_CHANNEL));

    //
    // Allocate a structure for querying key names that is large enough to hold all of them
    //
    KeyBasicInfoSize = sizeof(KEY_BASIC_INFORMATION) + ChannelsKeyFullInfo.MaxNameLen;
    pChannelIdKeyBasicInfo = ExAllocatePoolWithTag(
                                    PagedPool,
                                    KeyBasicInfoSize + 1,
                                    BDL_ULONG_TAG);

    if (pChannelIdKeyBasicInfo == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetChannels: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Loop for each Channel SubKey and get the relevant info
    //
    for (i = 0; i < ChannelsKeyFullInfo.SubKeys; i++)
    {
        //
        // Get the name on the <Channel Id> key
        //
        status = ZwEnumerateKey(
                    hChannelsKey,
                    i,
                    KeyBasicInformation,
                    pChannelIdKeyBasicInfo,
                    KeyBasicInfoSize,
                    &ReturnedSize);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetChannels: ZwEnumerateKey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Change the <Channel ID> key string to a value
        //
        pChannelIdKeyBasicInfo->Name[pChannelIdKeyBasicInfo->NameLength / sizeof(WCHAR)] = L'\0';
        RtlInitUnicodeString(&UnicodeString, pChannelIdKeyBasicInfo->Name);
        RtlUnicodeStringToInteger(&UnicodeString, 16, &((*prgChannels)[i].ChannelId));

        //
        // Open up the <Channel ID> key
        //
        status = BDLOpenSubkey(hChannelsKey, pChannelIdKeyBasicInfo->Name, &hChannelIdKey);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetChannels: BDLOpenSubkey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get the Cancelable value
        //
        status = BDLGetValue(
                    hChannelIdKey,
                    REG_DWORD,
                    L"Cancelable",
                    (ULONG *) &((*prgChannels)[i].fCancelable),
                    NULL);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetChannels: BDLGetValue failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get the channel level controls
        //
        status = BDLGetControls(
                        hChannelIdKey,
                        &((*prgChannels)[i].NumControls),
                        &((*prgChannels)[i].rgControls));

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetChannels: BDLGetControls failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get the sources lists
        //
        status = BDLGetSourceLists(
                        hChannelIdKey,
                        &((*prgChannels)[i].NumSourceLists),
                        &((*prgChannels)[i].rgSourceLists));

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetChannels: BDLGetSourceLists failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get the products
        //
        status = BDLGetProducts(
                        hChannelIdKey,
                        &((*prgChannels)[i].NumProducts),
                        &((*prgChannels)[i].rgProducts));

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetChannels: BDLGetProductss failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        ZwClose(hChannelIdKey);
        hChannelIdKey = NULL;
    }


Return:

    if (hChannelsKey != NULL)
    {
        ZwClose(hChannelsKey);
    }

    if (hChannelIdKey != NULL)
    {
        ZwClose(hChannelIdKey);
    }

    if (pChannelIdKeyBasicInfo != NULL)
    {
        ExFreePoolWithTag(pChannelIdKeyBasicInfo, BDL_ULONG_TAG);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetChannels: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    goto Return;
}


NTSTATUS
BDLGetComponents
(
    HANDLE                          hRegKey,
    ULONG                           *pNumComponents,
    BDL_COMPONENT                   **prgComponents
)
{
    NTSTATUS                        status                      = STATUS_SUCCESS;
    HANDLE                          hComponentsKey              = NULL;
    UNICODE_STRING                  UnicodeString;
    KEY_FULL_INFORMATION            ComponentsKeyFullInfo;
    ULONG                           ReturnedSize;
    ULONG                           i;
    HANDLE                          hComponentIdKey             = NULL;
    KEY_BASIC_INFORMATION           *pComponentIdKeyBasicInfo   = NULL;
    ULONG                           KeyBasicInfoSize            = 0;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetComponents: Enter\n",
           __DATE__,
           __TIME__))

    *pNumComponents = 0;
    *prgComponents = NULL;

    //
    // Open the "Components" key so it can be used to query all subkeys and values
    //
    status = BDLOpenSubkey(hRegKey, L"Components", &hComponentsKey);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetComponents: BDLOpenSubkey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Find out how many components there are
    //
    status = ZwQueryKey(
                hComponentsKey,
                KeyFullInformation,
                &ComponentsKeyFullInfo,
                sizeof(ComponentsKeyFullInfo),
                &ReturnedSize);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetComponents: ZwQueryKey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Allocate the array of components
    //
    *prgComponents = ExAllocatePoolWithTag(
                            PagedPool,
                            ComponentsKeyFullInfo.SubKeys * sizeof(BDL_COMPONENT),
                            BDL_ULONG_TAG);

    if (*prgComponents == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetComponents: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    *pNumComponents = ComponentsKeyFullInfo.SubKeys;
    RtlZeroMemory(*prgComponents, ComponentsKeyFullInfo.SubKeys * sizeof(BDL_COMPONENT));

    //
    // Allocate a structure for querying key names that is large enough to hold all of them
    //
    KeyBasicInfoSize = sizeof(KEY_BASIC_INFORMATION) + ComponentsKeyFullInfo.MaxNameLen;
    pComponentIdKeyBasicInfo = ExAllocatePoolWithTag(
                                        PagedPool,
                                        KeyBasicInfoSize + 1,
                                        BDL_ULONG_TAG);

    if (pComponentIdKeyBasicInfo == NULL)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetComponents: ExAllocatePoolWithTag failed\n",
               __DATE__,
               __TIME__))

        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Loop for each Component SubKey and get the relevant info
    //
    for (i = 0; i < ComponentsKeyFullInfo.SubKeys; i++)
    {
        //
        // Get the name on the <Component Id> key
        //
        status = ZwEnumerateKey(
                    hComponentsKey,
                    i,
                    KeyBasicInformation,
                    pComponentIdKeyBasicInfo,
                    KeyBasicInfoSize,
                    &ReturnedSize);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetComponents: ZwEnumerateKey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Change the <Component ID> key string to a value
        //
        pComponentIdKeyBasicInfo->Name[pComponentIdKeyBasicInfo->NameLength / sizeof(WCHAR)] = L'\0';
        RtlInitUnicodeString(&UnicodeString, pComponentIdKeyBasicInfo->Name);
        RtlUnicodeStringToInteger(&UnicodeString, 16, &((*prgComponents)[i].ComponentId));

        //
        // Open up the <Component ID> key
        //
        status = BDLOpenSubkey(hComponentsKey, pComponentIdKeyBasicInfo->Name, &hComponentIdKey);

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetComponents: BDLOpenSubkey failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get the component level controls
        //
        status = BDLGetControls(
                        hComponentIdKey,
                        &((*prgComponents)[i].NumControls),
                        &((*prgComponents)[i].rgControls));

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetComponents: BDLGetControls failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        //
        // Get the channels in this component
        //
        status = BDLGetChannels(
                        hComponentIdKey,
                        &((*prgComponents)[i].NumChannels),
                        &((*prgComponents)[i].rgChannels));

        if (status != STATUS_SUCCESS)
        {
            BDLDebug(
                  BDL_DEBUG_ERROR,
                  ("%s %s: BDL!BDLGetComponents: BDLGetChannels failed with %x\n",
                   __DATE__,
                   __TIME__,
                   status))

            goto ErrorReturn;
        }

        ZwClose(hComponentIdKey);
        hComponentIdKey = NULL;
    }

Return:

    if (hComponentsKey != NULL)
    {
        ZwClose(hComponentsKey);
    }

    if (hComponentIdKey != NULL)
    {
        ZwClose(hComponentIdKey);
    }

    if (pComponentIdKeyBasicInfo != NULL)
    {
        ExFreePoolWithTag(pComponentIdKeyBasicInfo, BDL_ULONG_TAG);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetControls: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    goto Return;
}


NTSTATUS
BDLGetDeviceCapabilities
(
    PDEVICE_OBJECT                  pPhysicalDeviceObject,
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension
)
{
    NTSTATUS                        status                      = STATUS_SUCCESS;
    LPWSTR                          pwszDeviceRegistryKeyName   = NULL;
    HANDLE                          hDeviceKey                  = NULL;

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetDevicesCapabilities: Enter\n",
           __DATE__,
           __TIME__))

    //
    // Build the top level registry key name
    //
    status = BDLBuildRegKeyPath(
                    pPhysicalDeviceObject,
                    pBDLExtension,
                    &pwszDeviceRegistryKeyName);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetDevicesCapabilities: BDLBuildRegKeyPath failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Open the top level device key so it can be used to query all subkeys and values
    //
    status = BDLOpenSubkey(NULL, pwszDeviceRegistryKeyName, &hDeviceKey);

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetDevicesCapabilities: BDLOpenSubkey failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Get the device level controls
    //
    status = BDLGetControls(
                hDeviceKey,
                &(pBDLExtension->DeviceCapabilities.NumControls),
                &(pBDLExtension->DeviceCapabilities.rgControls));

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetDevicesCapabilities: BDLGetControls failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

    //
    // Get the components
    //
    status = BDLGetComponents(
                hDeviceKey,
                &(pBDLExtension->DeviceCapabilities.NumComponents),
                &(pBDLExtension->DeviceCapabilities.rgComponents));

    if (status != STATUS_SUCCESS)
    {
        BDLDebug(
              BDL_DEBUG_ERROR,
              ("%s %s: BDL!BDLGetDevicesCapabilities: BDLGetControls failed with %x\n",
               __DATE__,
               __TIME__,
               status))

        goto ErrorReturn;
    }

Return:

    if (pwszDeviceRegistryKeyName != NULL)
    {
        ExFreePoolWithTag(pwszDeviceRegistryKeyName, BDL_ULONG_TAG);
    }

    if (hDeviceKey != NULL)
    {
        ZwClose(hDeviceKey);
    }

    BDLDebug(
          BDL_DEBUG_TRACE,
          ("%s %s: BDL!BDLGetDevicesCapabilities: Leave\n",
           __DATE__,
           __TIME__))

    return (status);

ErrorReturn:

    BDLCleanupDeviceCapabilities(pBDLExtension);

    goto Return;
}


VOID
BDLCleanupDeviceCapabilities
(
    PBDL_INTERNAL_DEVICE_EXTENSION  pBDLExtension
)
{
    BDL_DEVICE_CAPABILITIES *pDeviceCapabilites = &(pBDLExtension->DeviceCapabilities);
    ULONG i, j;

    //
    // Free device level control array
    //
    if (pDeviceCapabilites->rgControls != NULL)
    {
        ExFreePoolWithTag(pDeviceCapabilites->rgControls, BDL_ULONG_TAG);
        pDeviceCapabilites->rgControls = NULL;
    }

    //
    // Free component array
    //
    if (pDeviceCapabilites->rgComponents != NULL)
    {
        //
        // Free each component
        //
        for (i = 0; i < pDeviceCapabilites->NumComponents; i++)
        {
            //
            // Free component level control array
            //
            if (pDeviceCapabilites->rgComponents[i].rgControls != NULL)
            {
                ExFreePoolWithTag(pDeviceCapabilites->rgComponents[i].rgControls, BDL_ULONG_TAG);
            }

            //
            // Free channel array
            //
            if (pDeviceCapabilites->rgComponents[i].rgChannels != NULL)
            {
                //
                // Free each channel
                //
                for (j = 0; j < pDeviceCapabilites->rgComponents[i].NumChannels; j++)
                {
                    //
                    // Free channel level controls, source lists, and products
                    //
                    if (pDeviceCapabilites->rgComponents[i].rgChannels[j].rgControls != NULL)
                    {
                        ExFreePoolWithTag(
                                pDeviceCapabilites->rgComponents[i].rgChannels[j].rgControls,
                                BDL_ULONG_TAG);
                    }

                    if (pDeviceCapabilites->rgComponents[i].rgChannels[j].rgSourceLists != NULL)
                    {
                        ExFreePoolWithTag(
                                pDeviceCapabilites->rgComponents[i].rgChannels[j].rgSourceLists,
                                BDL_ULONG_TAG);
                    }

                    if (pDeviceCapabilites->rgComponents[i].rgChannels[j].rgProducts != NULL)
                    {
                        ExFreePoolWithTag(
                                pDeviceCapabilites->rgComponents[i].rgChannels[j].rgProducts,
                                BDL_ULONG_TAG);
                    }
                }

                ExFreePoolWithTag(pDeviceCapabilites->rgComponents[i].rgChannels, BDL_ULONG_TAG);
            }
        }

        ExFreePoolWithTag(pDeviceCapabilites->rgComponents, BDL_ULONG_TAG);
        pDeviceCapabilites->rgComponents = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\debug.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Debug.h

Abstract:

        Debug defines

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/


#define BREAK_ON_DRIVER_ENTRY  0x00000001
#define BREAK_ON_DRIVER_UNLOAD 0x00000002

#define TRACE_LOAD_UNLOAD      0x00000001 // DriverEntry, Unload
#define TRACE_FAIL             0x00000002 // Trace Failures/Errors
#define TRACE_FUNC_ENTER       0x00000004 // Enter Function - may include params
#define TRACE_FUNC_EXIT        0x00000008 // Exit  Function - may include return value(s)

#define TRACE_PNP1             0x00000010 // AddDevice, Start, Remove - minimal info
#define TRACE_PNP2             0x00000020
#define TRACE_PNP4             0x00000040
#define TRACE_PNP8             0x00000080 // PnP error paths

#define TRACE_USB1             0x00000100 // interface to USB
#define TRACE_USB2             0x00000200
#define TRACE_USB4             0x00000400
#define TRACE_USB8             0x00000800

#define TRACE_DOT41            0x00001000 // interface to dot4.sys loaded above us
#define TRACE_DOT42            0x00002000
#define TRACE_DOT44            0x00004000
#define TRACE_DOT48            0x00008000

#define TRACE_TMP1             0x00010000 // temp usage for development and debugging
#define TRACE_TMP2             0x00020000
#define TRACE_TMP4             0x00040000
#define TRACE_TMP8             0x00080000

#define TRACE_VERBOSE          0x80000000 // stuff that normally is too verbose

#define _DBG 1

#if _DBG
// Trace If (...condition...)
#define TR_IF(_test_, _x_) \
    if( (_test_) & gTrace ) { \
        DbgPrint("D4U: "); \
        DbgPrint _x_; \
        DbgPrint("\n"); \
    }

#define TR_LD_UNLD(_x_) TR_IF(TRACE_LOAD_UNLOAD, _x_) // DriverEntry, DriverUnload 
#define TR_FAIL(_x_)    TR_IF(TRACE_FAIL, _x_)        // Failures/Errors
#define TR_ENTER(_x_)   TR_IF(TRACE_FUNC_ENTER, _x_)
#define TR_EXIT(_x_)    TR_IF(TRACE_FUNC_EXIT, _x_)
#define TR_PNP1(_x_)    TR_IF(TRACE_PNP1, _x_)        // minimal AddDevice, Start, Remove
#define TR_PNP2(_x_)    TR_IF(TRACE_PNP2, _x_)        // verbose PnP
#define TR_PNP8(_x_)    TR_IF(TRACE_PNP8, _x_)        // error paths in PnP functions
#define TR_VERBOSE(_x_) TR_IF(TRACE_VERBOSE, _x_)     // stuff that normally is too verbose
#define TR_DOT41(_x_)   TR_IF(TRACE_DOT41, _x_)
#define TR_TMP1(_x_)    TR_IF(TRACE_TMP1, _x_)

#endif // _DBG


#define ALLOW_D4U_ASSERTS 1
#if ALLOW_D4U_ASSERTS
#define D4UAssert(_x_) ASSERT(_x_)
#else
#define D4UAssert(_x_)
#endif // ALLOW_D4U_ASSERTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\dot4usb.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        DevExt.h

Abstract:

        Defines, Globals, Structures, Enums, and Device Extension

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#ifndef _DEVEXT_H_
#define _DEVEXT_H_

//
// Defines
//

#define arraysize(p) (sizeof(p)/sizeof((p)[0])) // number of elements in an array
#define FAILURE_TIMEOUT -(30 * 10 * 1000 * 1000)// 5 seconds (in 100ns units) - used for KeWaitForSingleObject timeout
#define DOT4USBTAG (ULONG)' u4d'                // Used as PoolTag and Device Extension Signature
#define SCRATCH_BUFFER_SIZE 512                 // buffer size for reading from Interrupt pipe

#ifdef ExAllocatePool                           // use pool tagging
#undef ExAllocatePool
#define ExAllocatePool(type, size) ExAllocatePoolWithTag((type), (size), DOT4USBTAG)
#endif



//
// Globals
//

extern UNICODE_STRING gRegistryPath;  // copy of RegistryPath passed to DriverEntry - Buffer is UNICODE_NULL terminated for flexibilty
extern ULONG          gTrace;         // events to trace - see debug.h
extern ULONG          gBreak;         // events that we should break on - see debug.h



//
// Structs (other than Device Extension)
//

typedef struct _USB_RW_CONTEXT {      // Used to pass context to IRP Completion Routine
    PURB            Urb;
    BOOLEAN IsWrite;
    PDEVICE_OBJECT  DevObj;
} USB_RW_CONTEXT, *PUSB_RW_CONTEXT;



//
// Enums
//

typedef enum _USB_REQUEST_TYPE {      // Flag used to distinguish Reads from Writes in UsbReadWrite()
    UsbReadRequest  = 1,
    UsbWriteRequest = 2
} USB_REQUEST_TYPE;

typedef enum _PNP_STATE {             // PnP Device States
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,                // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
} PNP_STATE;



//
// Device Extension
//

typedef struct _DEVICE_EXTENSION {
    ULONG                        Signature1;         // extra check that devExt looks like ours - DOT4USBTAG
    PDEVICE_OBJECT               DevObj;             // back pointer to our DeviceObject
    PDEVICE_OBJECT               Pdo;                // our PDO
    PDEVICE_OBJECT               LowerDevObj;        // Device Object returned by IoAttachDeviceToDeviceStack that we send IRPs to
    PNP_STATE                    PnpState;           // PnP device state
    BOOLEAN                      IsDLConnected;      // is our datalink connected? i.e., between PARDOT3_ CONNECT and DISCONNECT?
    UCHAR                        Spare1[3];          // pad to DWORD boundary
    PKEVENT                      Dot4Event;          // datalink event - given to us by dot4.sys to signal when device data avail
    USBD_CONFIGURATION_HANDLE    ConfigHandle;       // handle for the configuration the device is currently in
    PUSB_DEVICE_DESCRIPTOR       DeviceDescriptor;   // ptr to the USB device descriptor for this device
    PUSBD_INTERFACE_INFORMATION  Interface;          // copy of the info structure returned from select_configuration or select_interface
    PUSBD_PIPE_INFORMATION       WritePipe;          // pipe for bulk writes
    PUSBD_PIPE_INFORMATION       ReadPipe;           // pipe for bulk reads
    PUSBD_PIPE_INFORMATION       InterruptPipe;      // pipe for interrupt reads
    KSPIN_LOCK                   SpinLock;           // SpinLock to protect extension data
    PIRP                         PollIrp;            // irp used for polling device interrupt pipe for device data avail
    KSPIN_LOCK                   PollIrpSpinLock;    // SpinLock used to protect changes to Polling Irp for Interrupt Pipe
    KEVENT                       PollIrpEvent;       // used by completion routine to signal that cancel of pollIrp has been detected/handled
    UCHAR                        Spare2[3];          // pad to DWORD boundary
    DEVICE_CAPABILITIES          DeviceCapabilities; // includes a table mapping system power states to device power states.
    IO_REMOVE_LOCK               RemoveLock;         // Synch mechanism to keep us from being removed while we have IRPs active
    LONG                         ResetWorkItemPending;// flag to specify if a "reset pipe" work item is pending
    ULONG                        Signature2;         // extra check that devExt looks like ours - DOT4USBTAG
    PUSB_RW_CONTEXT              InterruptContext;   // context for read on interrupt pipe
    SYSTEM_POWER_STATE           SystemPowerState;
    DEVICE_POWER_STATE           DevicePowerState;
    PIRP                         CurrentPowerIrp;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _DOT4USB_WORKITEM_CONTEXT
{
    PIO_WORKITEM ioWorkItem;
    PDEVICE_OBJECT deviceObject;
     PUSBD_PIPE_INFORMATION pPipeInfo;
    PIRP irp;

} DOT4USB_WORKITEM_CONTEXT,*PDOT4USB_WORKITEM_CONTEXT;


#endif // _DEVEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\funcdecl.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        FuncDecl.h

Abstract:

        Function Prototype Declarations

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/


//
// AddDev.c
//
NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );


//
// InitUnld.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );


//
// Ioctl.c
//
NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS
DispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );


//
// OpenClos.c
//
NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );


//
// PnP.c
//
NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
PnpDefaultHandler(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleStart(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleCancelRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleCancelStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryDeviceRelations(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryCapabilities(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleSurpriseRemoval(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
VA_PnP(
    IN PDEVICE_EXTENSION devExt,
    PIRP irp
    );

NTSTATUS
GetDeviceCapabilities(
    IN PDEVICE_EXTENSION DevExt
    );


// power.c
NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
PowerComplete(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PVOID          Context
    );


//
// Registry.c
//
NTSTATUS
RegGetDword(
    IN     PCWSTR  KeyPath,
    IN     PCWSTR  ValueName,
    IN OUT PULONG  Value
    );

NTSTATUS
RegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PCWSTR          ValueName,
    IN OUT PULONG          Value
    );


//
// ReadWrit.c
//
NTSTATUS
DispatchRead(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS
DispatchWrite(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

//
// Test.c
//
VOID
TestEventLog(
    IN PDEVICE_OBJECT DevObj
    );

//
// Usb.c
//


NTSTATUS
UsbResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    );


NTSTATUS DOT4USB_ResetWorkItem(
    IN PDEVICE_OBJECT deviceObject,
    IN PVOID Context);

NTSTATUS
UsbBuildPipeList(
    IN  PDEVICE_OBJECT DeviceObject
    );

LONG
UsbGet1284Id(
    IN PDEVICE_OBJECT DevObj,
    PVOID             Buffer,
    LONG              BufferLength
    );

NTSTATUS
UsbBulkWrite(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
UsbBulkRead(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
UsbCallUsbd(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout
    );

NTSTATUS
UsbGetDescriptor(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS
UsbConfigureDevice(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS
UsbSelectInterface(
    IN PDEVICE_OBJECT                DevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
UsbReadWrite(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    PUSBD_PIPE_INFORMATION  Pipe,
    USB_REQUEST_TYPE        RequestType
    );

NTSTATUS
UsbReadInterruptPipeLoopCompletionRoutine(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    devExt
    );

NTSTATUS
UsbStartReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    );

VOID
UsbStopReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    );

PURB
UsbBuildAsyncRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_PIPE_INFORMATION PipeHandle,
    IN BOOLEAN Read
    );

NTSTATUS
UsbAsyncReadWriteComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


//
// Util.c
//
NTSTATUS
DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CallLowerDriverSync(
    IN PDEVICE_OBJECT  DevObj,
    IN PIRP            Irp
    );

NTSTATUS
CallLowerDriverSyncCompletion(
    IN PDEVICE_OBJECT  DevObjOrNULL,
    IN PIRP            Irp,
    IN PVOID           Context
    );

//
// Wmi.c
//
NTSTATUS
DispatchWmi(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );








=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\openclos.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        OpenClos.c

Abstract:

        Dispatch routines for IRP_MJ_CREATE and IRP_MJ_CLOSE

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchCreate                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_CREATE
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the create
//      Irp    - pointer to the create IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS          status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    TR_VERBOSE(("DispatchCreate"));

    if( NT_SUCCESS(status) ) {
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - fail CREATE
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return status;
}


/************************************************************************/
/* DispatchClose                                                        */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_CLOSE
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the close
//      Irp    - pointer to the close IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS          status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    TR_VERBOSE(("DispatchClose"));

    if( NT_SUCCESS(status) ) {
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - succeed CLOSE anyway
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\initunld.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        InitUnld.c

Abstract:

        Driver globals, initialization (DriverEntry) and Unload routines

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code review w/Joby

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


//
// Globals
//
UNICODE_STRING gRegistryPath = {0,0,0}; // yes globals are automatically initialized
ULONG          gTrace        = 0;       //   to 0's, but let's be explicit.
ULONG          gBreak        = 0;


/************************************************************************/
/* DriverEntry                                                          */
/************************************************************************/
//
// Routine Description:
//
//      - Save a copy of RegistryPath in a global gRegistryPath for use 
//          throughout the lifetime of the driver load.
//
//      - Initialize DriverObject function pointer table to point to
//          our entry points.
//
//      - Initialize Debug globals gTrace and gBreak based on registry
//          settings.
//
// Arguments: 
//
//      DriverObject - pointer to Dot4Usb.sys driver object
//      RegistryPath - pointer to RegistryPath for the driver, expected
//                       to be of the form (ControlSet may vary):
//                       \REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\dot4usb
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Save a copy of RegistryPath in global gRegistryPath for use
    //   over the lifetime of the driver load.
    //   - UNICODE_NULL terminate gRegistryPath.Buffer for added flexibility.
    //   - gRegistryPath.Buffer should be freed in DriverUnload()
    //

    { // new scope for gRegistryPath initialization - begin
        USHORT newMaxLength = (USHORT)(RegistryPath->Length + sizeof(WCHAR));
        PWSTR  p            = ExAllocatePool( PagedPool, newMaxLength );
        if( p ) {
            gRegistryPath.Length        = 0;
            gRegistryPath.MaximumLength = newMaxLength;
            gRegistryPath.Buffer        = p;
            RtlCopyUnicodeString( &gRegistryPath, RegistryPath );
            gRegistryPath.Buffer[ gRegistryPath.Length/2 ] = UNICODE_NULL;
        } else {
            TR_FAIL(("DriverEntry - exit - FAIL - no Pool for gRegistryPath.Buffer"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto targetExit;
        }
    } // new scope for gRegistryPath initialization - end



    // 
    // Initialize DriverObject function pointer table to point to our entry points.
    //
    // Start by initializing dispatch table to point to our passthrough function and 
    //   then override the entry points that we actually handle.
    //

    {// new scope for index variable - begin
        ULONG  i;
        for( i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++ ) {
            DriverObject->MajorFunction[i] = DispatchPassThrough;
        }
    } // new scope for index variable - end

    DriverObject->MajorFunction[ IRP_MJ_PNP                     ] = DispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER                   ] = DispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_CREATE                  ] = DispatchCreate;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE                   ] = DispatchClose;
    DriverObject->MajorFunction[ IRP_MJ_READ                    ] = DispatchRead;
    DriverObject->MajorFunction[ IRP_MJ_WRITE                   ] = DispatchWrite;
    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL          ] = DispatchDeviceControl;
    DriverObject->MajorFunction[ IRP_MJ_INTERNAL_DEVICE_CONTROL ] = DispatchInternalDeviceControl;

    DriverObject->DriverExtension->AddDevice                      = AddDevice;
    DriverObject->DriverUnload                                    = DriverUnload;


    //
    // Get driver debug settings (gTrace, gBreak) from registry
    //
    //   Expected Key Path is of the form (ControlSet may vary):
    //
    //   \REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\dot4usb
    //
    RegGetDword( gRegistryPath.Buffer, (PCWSTR)L"gBreak", &gBreak );
    RegGetDword( gRegistryPath.Buffer, (PCWSTR)L"gTrace", &gTrace );

    TR_LD_UNLD(("DriverEntry - RegistryPath = <%wZ>", RegistryPath));
    TR_LD_UNLD(("DriverEntry - gBreak=%x", gBreak));
    TR_LD_UNLD(("DriverEntry - gTrace=%x", gTrace));


    //
    // Check if user requested a breakpoint here. A breakpoint herew is
    //   typically used so that we can insert breakpoints on other
    //   functions or change debug settings to differ from those that we
    //   just read from the registry.
    //
    if( gBreak & BREAK_ON_DRIVER_ENTRY ) {
        DbgPrint( "D4U: Breakpoint requested via registry setting - (gBreak & BREAK_ON_DRIVER_ENTRY)\n" );
        DbgBreakPoint();
    }

targetExit:
    return status;
}


/************************************************************************/
/* DriverUnload                                                         */
/************************************************************************/
//
// Routine Description:
//
//      - Free any copy of RegistryPath that might have been saved in 
//          global gRegistryPath during DriverEntry().
//
// Arguments: 
//
//      DriverObject - pointer to Dot4Usb.sys driver object
//
// Return Value:                                          
//                                                        
//      NONE
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
    UNREFERENCED_PARAMETER( DriverObject );
    TR_LD_UNLD(("DriverUnload"));
    if( gRegistryPath.Buffer ) {
        RtlFreeUnicodeString( &gRegistryPath );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\pch.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Pch.h

Abstract:

        Precompiled header

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/


#pragma warning( disable : 4115 ) // named type definition in parentheses 
#pragma warning( disable : 4127 ) // conditional expression is constant
#pragma warning( disable : 4200 ) // zero-sized array in struct/union
#pragma warning( disable : 4201 ) // nameless struct/union
#pragma warning( disable : 4214 ) // bit field types other than int
#pragma warning( disable : 4514 ) // unreferenced inline function has been removed

#include <wdm.h>

#pragma warning( disable : 4200 ) // zero-sized array in struct/union - (ntddk.h resets this to default)

#include <usbdi.h>
#include <usbdlib.h>
#include <parallel.h>
#include "d4ulog.h"
#include "dot4usb.h"
#include "funcdecl.h"
#include "debug.h"
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\pnp.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        PnP.c

Abstract:

        Plug and Play routines

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - function cleanup and documentation
        - code review

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"


NTSTATUS (*PnpDispatchTable[])(PDEVICE_EXTENSION,PIRP) = {
    PnpHandleStart,               // IRP_MN_START_DEVICE                 0x00
    PnpHandleQueryRemove,         // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    PnpHandleRemove,              // IRP_MN_REMOVE_DEVICE                0x02
    PnpHandleCancelRemove,        // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    PnpHandleStop,                // IRP_MN_STOP_DEVICE                  0x04
    PnpHandleQueryStop,           // IRP_MN_QUERY_STOP_DEVICE            0x05
    PnpHandleCancelStop,          // IRP_MN_CANCEL_STOP_DEVICE           0x06
    PnpHandleQueryDeviceRelations,// IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    PnpDefaultHandler,            // IRP_MN_QUERY_INTERFACE              0x08
    PnpHandleQueryCapabilities,   // IRP_MN_QUERY_CAPABILITIES           0x09
    PnpDefaultHandler,            // IRP_MN_QUERY_RESOURCES              0x0A
    PnpDefaultHandler,            // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    PnpDefaultHandler,            // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    PnpDefaultHandler,            // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    PnpDefaultHandler,            //   no defined IRP MN code            0x0E
    PnpDefaultHandler,            // IRP_MN_READ_CONFIG                  0x0F
    PnpDefaultHandler,            // IRP_MN_WRITE_CONFIG                 0x10
    PnpDefaultHandler,            // IRP_MN_EJECT                        0x11
    PnpDefaultHandler,            // IRP_MN_SET_LOCK                     0x12
    PnpDefaultHandler,            // IRP_MN_QUERY_ID                     0x13
    PnpDefaultHandler,            // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    PnpDefaultHandler,            // IRP_MN_QUERY_BUS_INFORMATION        0x15
    PnpDefaultHandler,            // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    PnpHandleSurpriseRemoval,     // IRP_MN_SURPRISE_REMOVAL             0x17
};


/************************************************************************/
/* DispatchPnp                                                          */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_PNP IRPs. Redirect IRPs to appropriate
//       handlers using the IRP_MN_* value as the key.
//
// Arguments: 
//
//     DevObj - pointer to DEVICE_OBJECT that is the target of the request
//     Irp    - pointer to IRP
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION  devExt = DevObj->DeviceExtension;
    NTSTATUS           status = IoAcquireRemoveLock( &devExt->RemoveLock , Irp );

    if( NT_SUCCESS( status ) ) {

        // Acquire RemoveLock succeeded
        PIO_STACK_LOCATION irpSp     = IoGetCurrentIrpStackLocation( Irp );
        ULONG              minorFunc = irpSp->MinorFunction;

        TR_VERBOSE(("DispatchPnp - RemoveLock acquired - DevObj= %x , Irp= %x", DevObj, Irp));

        //
        // Call appropriate handler based on PnP IRP_MN_xxx code
        //
        // note: Handler will complete the IRP
        //
        if( minorFunc >= arraysize(PnpDispatchTable) ) {
            status =  PnpDefaultHandler( devExt, Irp );
        } else {
            status =  PnpDispatchTable[ minorFunc ]( devExt, Irp );
        }

    } else {

        // Acquire RemoveLock failed
        TR_FAIL(("DispatchPnp - RemoveLock acquire FAILED - DevObj= %x , Irp= %x", DevObj, Irp));
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}


/************************************************************************/
/* PnpDefaultHandler                                                    */
/************************************************************************/
//
// Routine Description:
//
//     Default handler for PnP IRPs that this driver does not explicitly handle.
//
// Arguments: 
//
//     DevExt - pointer to DEVICE_EXTENSION of the DEVICE_OBJECT that is 
//                the target of the request
//     Irp    - pointer to IRP
//
// Return Value:                                          
//                                                        
//      NTSTATUS returned by IoCallDriver
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
PnpDefaultHandler(
    IN PDEVICE_EXTENSION  DevExt,
    IN PIRP               Irp
    )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation( Irp );

    TR_ENTER(("PnpDefaultHandler - IRP_MN = 0x%02x", irpSp->MinorFunction));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


/************************************************************************/
/* PnpHandleStart                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Handler for PnP IRP_MN_START_DEVICE.
//
// Arguments: 
//
//     DevExt - pointer to DEVICE_EXTENSION of the DEVICE_OBJECT that is 
//                the target of the request
//     Irp    - pointer to IRP
//
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
// Log:
//      2000-05-03 - Code Reviewed - TomGreen, JobyL, DFritz 
//                   - cleanup required - error handling incorrect, may
//                     result in driver attempting to use invalid and/or
//                     uninitialized data
//
/************************************************************************/
NTSTATUS
PnpHandleStart(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleStart"));

    DevExt->PnpState = STATE_STARTING;


    //
    // Driver stack below us must successfully start before we handle the Start IRP
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCopyCurrentIrpStackLocationToNext( Irp );
    status = CallLowerDriverSync( DevExt->DevObj, Irp );

    if( NT_SUCCESS(status) ) {

        //
        // Driver stack below us has successfully started, continue
        //

        //
        // Get a copy of the DEVICE_CAPABILITIES of the stack us and
        //   save it in our DEVICE_EXTENSION for future reference.
        //
        status = GetDeviceCapabilities( DevExt );

        if( NT_SUCCESS(status) ) {

            // get USB descriptor
            status =  UsbGetDescriptor( DevExt );
            if( !NT_SUCCESS(status) ) {
                TR_VERBOSE(("call to UsbGetDescriptor FAILED w/status = %x",status));
                status = STATUS_SUCCESS; // start anyway
            } else {
                TR_VERBOSE(("call to UsbGetDescriptor - SUCCESS"));
            }

            // Configure Device
            status =  UsbConfigureDevice( DevExt );
            if( !NT_SUCCESS(status) ) {
                TR_VERBOSE(("call to UsbConfigureDevice FAILED w/status = %x",status));
                status = STATUS_SUCCESS; // start anyway
            } else {
                TR_VERBOSE(("call to UsbConfigureDevice - SUCCESS"));
            }

            // get 1284 ID - just for kicks :-)
            {
                UCHAR Buffer[256];
                LONG  retCode;
                RtlZeroMemory(Buffer, sizeof(Buffer));
                retCode = UsbGet1284Id(DevExt->DevObj, Buffer, sizeof(Buffer)-1);
                TR_VERBOSE(("retCode = %d",retCode));
                TR_VERBOSE(("strlen  = %d", strlen((PCSTR)&Buffer[2])));
                TR_VERBOSE(("1284ID = <%s>",&Buffer[2]));
            }

            // get Pipes
            UsbBuildPipeList( DevExt->DevObj );

            // we are now STARTED
            DevExt->PnpState = STATE_STARTED;

        } else {
            DevExt->PnpState = STATE_START_FAILED;
        }
    } else {

        //
        // Driver stack below us has FAILED the Start, we fail too
        //
        DevExt->PnpState = STATE_START_FAILED;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleQueryRemove"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS status;
    KIRQL    oldIrql;

    TR_ENTER(("PnpHandleRemove"));

    DevExt->PnpState = STATE_REMOVED;

    UsbStopReadInterruptPipeLoop( DevExt->DevObj ); // stop polling Irp if any

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp);
    TR_TMP1(("PnpHandleRemove - Calling IoReleaseRemoveLockAndWait"));
    IoReleaseRemoveLockAndWait( &DevExt->RemoveLock, Irp );
    TR_TMP1(("PnpHandleRemove - Returned from IoReleaseRemoveLockAndWait"));
    IoDetachDevice( DevExt->LowerDevObj );

    // BUGBUG - verify that code in rest of driver that touches Interface
    // locks the extension while using it to prevent this function from
    // freeing the interface out from under them causing an AV
    KeAcquireSpinLock( &DevExt->SpinLock, &oldIrql );
    if( DevExt->Interface ) {
        PVOID ptr = DevExt->Interface;
        DevExt->Interface = NULL;
        KeReleaseSpinLock( &DevExt->SpinLock, oldIrql );
        ExFreePool( ptr );
    } else {
        KeReleaseSpinLock( &DevExt->SpinLock, oldIrql );
    }

    IoDeleteDevice( DevExt->DevObj );
    return status;
}


NTSTATUS
PnpHandleCancelRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleCancelRemove"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleStop"));

    if( DevExt->PnpState == STATE_STARTED ) {
        DevExt->PnpState = STATE_STOPPED;
    }
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleQueryStop"));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleCancelStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleStop"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryDeviceRelations(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleQueryDeviceRelations"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryCapabilities(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS           status;

    TR_ENTER(("PnpHandleQueryCapabilities"));

    IoCopyCurrentIrpStackLocationToNext( Irp );

    status = CallLowerDriverSync( DevExt->DevObj, Irp );

    if( NT_SUCCESS( status ) ) {
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
        irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
    }

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleSurpriseRemoval(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleSurpriseRemoval"));

    DevExt->PnpState = STATE_REMOVING;
    TR_TMP1(("PnpHandleSurpriseRemoval"));
    UsbStopReadInterruptPipeLoop( DevExt->DevObj ); // stop polling Irp if any
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
GetDeviceCapabilities(
    IN PDEVICE_EXTENSION DevExt
    )
{
    NTSTATUS status;
    PIRP     irp = IoAllocateIrp(DevExt->LowerDevObj->StackSize, FALSE);

    if( irp ) {

        PIO_STACK_LOCATION irpSp = IoGetNextIrpStackLocation( irp );

        // must initialize DeviceCapabilities before sending...
        RtlZeroMemory(  &DevExt->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
        DevExt->DeviceCapabilities.Size     = sizeof(DEVICE_CAPABILITIES);
        DevExt->DeviceCapabilities.Version  = 1;
        DevExt->DeviceCapabilities.Address  = (ULONG) -1;
        DevExt->DeviceCapabilities.UINumber = (ULONG) -1;

        // set up next irp stack location...
        irpSp->MajorFunction = IRP_MJ_PNP;
        irpSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        irpSp->Parameters.DeviceCapabilities.Capabilities = &DevExt->DeviceCapabilities;

        // required initial status
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = IoAcquireRemoveLock( &DevExt->RemoveLock, irp );
        if( NT_SUCCESS(status) ) {
            status = CallLowerDriverSync( DevExt->DevObj, irp );
            IoReleaseRemoveLock( &DevExt->RemoveLock, irp );
        } else {
            TR_VERBOSE(("We're in the process of being removed - abort"));
            status = STATUS_DELETE_PENDING;
        }

        IoFreeIrp( irp );

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\ioctl.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Ioctl.c

Abstract:

        Dispatch routines for IRP_MJ_DEVICE_CONTROL and IRP_MJ_INTERNAL_DEVICE_CONTROL

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code review

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchDeviceControl                                                */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_DEVICE_CONTROL
//       - We don't currently handle any such requests but we may do
//           so in the future. Pass any unhandled requests down the
//           stack to the device below us.
//
// Arguments: 
//
//      DevObj - pointer to DeviceObject that is the target of the request
//      Irp    - pointer to device control IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION  devExt = DevObj->DeviceExtension;
    NTSTATUS           status;
    ULONG              info = 0;

    TR_VERBOSE(("DispatchDeviceControl - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

        switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
            
        case IOCTL_PAR_QUERY_DEVICE_ID:
            // ISSUE - 000901 - DFritz - these new IOCTLs need to do parameter validation to avoid AVs
            {
                const LONG  minValidIdLength = sizeof("MFG:x;MDL:y;");
                const ULONG bufSize = 1024;
                PCHAR idBuffer = ExAllocatePool( NonPagedPool, bufSize );
                LONG idLength;
                
                if( idBuffer ) {
                    
                    RtlZeroMemory( idBuffer, bufSize );
                    
                    idLength = UsbGet1284Id( DevObj, idBuffer, bufSize-1 );
                    
                    if( idLength < minValidIdLength ) {
                        status = STATUS_UNSUCCESSFUL;
                    } else if( (ULONG)idLength >= irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        RtlZeroMemory( Irp->AssociatedIrp.SystemBuffer, idLength+1 );
                        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, idBuffer+2, idLength-2 );
                        info   = idLength - 1;
                        status = STATUS_SUCCESS;
                    }
                    
                    ExFreePool( idBuffer );
                    
                } else {
                    status = STATUS_NO_MEMORY;
                }
            }

            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = info;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

            break;
            
        case IOCTL_PAR_QUERY_RAW_DEVICE_ID:
            {
                const LONG  minValidIdLength = sizeof("MFG:x;MDL:y;");
                const ULONG bufSize = 1024;
                PCHAR idBuffer = ExAllocatePool( NonPagedPool, bufSize );
                LONG idLength;
                
                if( idBuffer ) {
                    
                    RtlZeroMemory( idBuffer, bufSize );
                    
                    idLength = UsbGet1284Id( DevObj, idBuffer, bufSize-1 );
                    
                    if( idLength < minValidIdLength ) {
                        status = STATUS_UNSUCCESSFUL;
                    } else if( (ULONG)idLength >= irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        RtlZeroMemory( Irp->AssociatedIrp.SystemBuffer, idLength+1 );
                        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, idBuffer, idLength);
                        info   = idLength + 1;
                        status = STATUS_SUCCESS;
                    }
                    
                    ExFreePool( idBuffer );
                    
                } else {
                    status = STATUS_NO_MEMORY;
                }
            }

            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = info;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

            break;
            
        case IOCTL_PAR_QUERY_DEVICE_ID_SIZE:

            {
                const LONG  minValidIdLength = sizeof("MFG:x;MDL:y;");
                const ULONG bufSize = 1024;
                PCHAR idBuffer = ExAllocatePool( NonPagedPool, bufSize );
                LONG idLength;
                
                if( idBuffer ) {
                    
                    RtlZeroMemory( idBuffer, bufSize );
                    
                    idLength = UsbGet1284Id( DevObj, idBuffer, bufSize-1 );
                    
                    if( idLength < minValidIdLength ) {
                        status = STATUS_UNSUCCESSFUL;
                    } else if( sizeof(ULONG) < irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        ++idLength; // save room for terminating NULL
                        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, &idLength, sizeof(ULONG));
                        info   = sizeof(ULONG);
                        status = STATUS_SUCCESS;
                    }
                    
                    ExFreePool( idBuffer );
                    
                } else {
                    status = STATUS_NO_MEMORY;
                }
            }

            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = info;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

            break;

        case IOCTL_PAR_QUERY_LOCATION:

            _snprintf( Irp->AssociatedIrp.SystemBuffer, 4, "USB" );
            info = 4;
            status = STATUS_SUCCESS;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

        default:

            // pass request down
            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->LowerDevObj, Irp );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

        }
            
    } else {
        // unable to acquire RemoveLock - FAIL request
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}


/************************************************************************/
/* DispatchInternalDeviceControl                                        */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_INTERNAL_DEVICE_CONTROL
//       - We expect DataLink requests from dot4.sys driver above us. Any
//           request that we don't handle is simply passed down the stack
//           to the driver below us.       
//
// Arguments: 
//
//      DevObj - pointer to DeviceObject that is the target of the request
//      Irp    - pointer to device control IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    NTSTATUS           status;
    PDEVICE_EXTENSION  devExt   = DevObj->DeviceExtension;

    TR_VERBOSE(("DispatchInternalDeviceControl - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {

        PIO_STACK_LOCATION irpSp        = IoGetCurrentIrpStackLocation( Irp );
        BOOLEAN            bCompleteIrp = FALSE;
        KIRQL              oldIrql;

        switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
            
        case IOCTL_INTERNAL_PARDOT3_CONNECT:
            
            //
            // Enter a "DataLink Connected" state with dot4.sys
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_CONNECT"));

            KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
            if( !devExt->IsDLConnected ) {
                devExt->IsDLConnected = TRUE;
                status = STATUS_SUCCESS;
            } else {
                // we believe that we are in a "datalink connected state" but obviously 
                //   dot4.sys doesn't agree - suggest investigating further if we hit
                //   this assert
                D4UAssert(FALSE);
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

            bCompleteIrp = TRUE;
            break;
            

        case IOCTL_INTERNAL_PARDOT3_RESET:
            
            //
            // This IOCTL is specific to parallel and is a NOOP for a USB connection.
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_RESET"));

            status = STATUS_SUCCESS;
            bCompleteIrp = TRUE;
            break;
            
        case IOCTL_INTERNAL_PARDOT3_DISCONNECT:
            
            //
            // Terminate the "DataLink Connected" state with dot4.sys and
            //   invalidate any Dot4Event since the event may be freed anytime
            //   after we complete this IRP.
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_DISCONNECT"));

            UsbStopReadInterruptPipeLoop( DevObj );

            KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
            devExt->Dot4Event = NULL; // invalidate dot4's event, if any, so we stop signalling dot4
            if( devExt->IsDLConnected ) {
                devExt->IsDLConnected = FALSE;
            } else {
                // we believe that we are NOT in a "datalink connected state" but obviously 
                //   dot4.sys doesn't agree - suggest investigating further if we hit
                //   this assert
                D4UAssert(FALSE);
            }
            KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

            status = STATUS_SUCCESS; // we always succeed this request since it is a disconnect
            bCompleteIrp = TRUE;
            break;
            
        case IOCTL_INTERNAL_PARDOT3_SIGNAL:
            
            //
            // dot4.sys is giving us a pointer to an Event that it owns and dot4 
            //   expects us to Signal this event whenever we detect that the device has 
            //   data available to be read. We continue signalling this event on device 
            //   data avail until we receive a disconnect IOCTL.
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_SIGNAL"));

            KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
            if( devExt->IsDLConnected ) {
                if( !devExt->Dot4Event ) {
                    // our state indicates that it is OK to receive this request
                    if( irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PKEVENT) ) {
                        status = STATUS_INVALID_PARAMETER;                
                    } else {
                        // save the pointer to the event in our device extension
                        PKEVENT Event;
                        RtlCopyMemory(&Event, Irp->AssociatedIrp.SystemBuffer, sizeof(PKEVENT));
                        devExt->Dot4Event = Event;
                        status = STATUS_SUCCESS;
                    }
                } else {
                    // we already have an event and dot4.sys sent us another one? - bad driver - AV crash likely real soon now
                    D4UAssert(FALSE);
                    status = STATUS_INVALID_DEVICE_REQUEST;
                }
            } else {
                // we're not in a datalink connected state - this is an invalid request
                D4UAssert(FALSE);
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

            if( NT_SUCCESS(status) && devExt->InterruptPipe ) {
                status = UsbStartReadInterruptPipeLoop( DevObj );
            }

            bCompleteIrp = TRUE;
            break;
            
        default :
            
            // unhandled request - pass it down the stack
            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->LowerDevObj, Irp );
            bCompleteIrp = FALSE;
            
        }
        
        if( bCompleteIrp ) {
            // we didn't pass this request down the stack, so complete it now
            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
        }

        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

    } else {
        // unable to acquire RemoveLock - we're in the process of being removed - FAIL request
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\power.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Power.c

Abstract:

        Power management functions

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code cleanup and documentation
        - code review

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"

VOID
SetPowerIrpCompletion(IN PDEVICE_OBJECT   DeviceObject,
                      IN UCHAR            MinorFunction,
                      IN POWER_STATE      PowerState,
                      IN PVOID            Context,
                      IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS
PowerD0Completion(IN PDEVICE_OBJECT   DeviceObject,
                  IN PIRP             Irp,
                  IN PVOID            Context);


NTSTATUS 
DispatchPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS                status;
    POWER_STATE             powerState;
    POWER_STATE             newState;
    POWER_STATE             oldState;
    BOOLEAN                 passRequest  = TRUE;

    TR_VERBOSE(("DispatchPower, MinorFunction = %x", (ULONG)irpSp->MinorFunction));

    //
    // Acquire RemoveLock to prevent us from being Removed
    //
    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );
    if( !NT_SUCCESS(status) ) 
    {
        // couldn't aquire RemoveLock - we're in the process of being removed - abort
        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }


    powerState = irpSp->Parameters.Power.State;

    switch (irpSp->MinorFunction) 
    {

    case IRP_MN_SET_POWER:

        switch(irpSp->Parameters.Power.Type) 
        {

        case SystemPowerState:
            // save the current system state
            devExt->SystemPowerState = powerState.SystemState;

            // map the new system state to a new device state
            if(powerState.SystemState != PowerSystemWorking)
            {
                newState.DeviceState = PowerDeviceD3;
            }
            else
            {
                newState.DeviceState = PowerDeviceD0;
            }

            if(devExt->DevicePowerState != newState.DeviceState)
            {
                // save the current power Irp for sending down later
                devExt->CurrentPowerIrp = Irp;

                // send a power Irp to set new device state
                status = PoRequestPowerIrp(devExt->Pdo,
                                           IRP_MN_SET_POWER,
                                           newState,
                                           SetPowerIrpCompletion,
                                           (PVOID) devExt,
                                           NULL);
                
                // this will get passed down in the completion routine
                passRequest  = FALSE;
            }

            break;

        case DevicePowerState:

            // Update the current device state.
            oldState.DeviceState = devExt->DevicePowerState;
            devExt->DevicePowerState = powerState.DeviceState;

            // powering up
            if(oldState.DeviceState > PowerDeviceD0 &&
               powerState.DeviceState == PowerDeviceD0)
            {
                // we need to know when this completes and our device is at the proper state
                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       PowerD0Completion,
                                       devExt,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = PoCallDriver(devExt->LowerDevObj, Irp);

                // we already passed this one down
                passRequest = FALSE;

            }
            else
            {
                // powering down, jsut set a flag and pass the request down
                if(devExt->PnpState == STATE_STARTED) 
                {
                    devExt->PnpState = STATE_SUSPENDED;
                }

                passRequest = TRUE;
            }

            break;
        }
    }


    if(passRequest)
    {
        //
        // Send the IRP down the driver stack,
        //
        IoCopyCurrentIrpStackLocationToNext( Irp );

        PoStartNextPowerIrp(Irp);

        // release lock
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

        status = PoCallDriver( devExt->LowerDevObj, Irp );        
    }

    return status;
}

VOID
SetPowerIrpCompletion(IN PDEVICE_OBJECT   DeviceObject,
                      IN UCHAR            MinorFunction,
                      IN POWER_STATE      PowerState,
                      IN PVOID            Context,
                      IN PIO_STATUS_BLOCK IoStatus)
{
    PDEVICE_EXTENSION       devExt;
    PIRP                    irp;
    NTSTATUS                ntStatus;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( MinorFunction );
    UNREFERENCED_PARAMETER( PowerState );
    UNREFERENCED_PARAMETER( IoStatus );

    devExt = (PDEVICE_EXTENSION) Context;

    // get the current power irp
    irp = devExt->CurrentPowerIrp;

    devExt->CurrentPowerIrp = NULL;

    // the requested DevicePowerState Irp has completed, so send the system power Irp down
    PoStartNextPowerIrp(irp);

    IoCopyCurrentIrpStackLocationToNext(irp);

    // mark the Irp pending
    IoMarkIrpPending(irp);

    // release the lock
    IoReleaseRemoveLock( &devExt->RemoveLock, irp );

    ntStatus = PoCallDriver(devExt->LowerDevObj, irp);
}

NTSTATUS
PowerD0Completion(IN PDEVICE_OBJECT   DeviceObject,
                  IN PIRP             Irp,
                  IN PVOID            Context)
{
    PDEVICE_EXTENSION       devExt;
    NTSTATUS                ntStatus;

    UNREFERENCED_PARAMETER( DeviceObject );

    devExt = (PDEVICE_EXTENSION) Context;

    // the device is powered up, set out state
    if(devExt->PnpState == STATE_SUSPENDED) 
    {
        devExt->PnpState = STATE_STARTED;
    }


    ntStatus = Irp->IoStatus.Status;

    // release the lock
    IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

    PoStartNextPowerIrp(Irp);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\readwrit.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        ReadWrit.c

Abstract:

        Dispatch routines for IRP_MJ_READ and IRP_MJ_WRITE

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - IoReleaseRemoveLock() calls need to be moved to USB completion routine
        - code review w/Joby

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchRead                                                         */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_READ - Validate parameters and forward
//       valid requests to USB handler.
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the request
//      Irp    - pointer to read request
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchRead(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    NTSTATUS                status;
    PUSBD_PIPE_INFORMATION  pipe;
    BOOLEAN                 bReleaseRemLockOnFail = FALSE;

    TR_VERBOSE(("DispatchRead - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );
    if( STATUS_SUCCESS != status ) {
        // couldn't aquire RemoveLock - FAIL request
        bReleaseRemLockOnFail = FALSE;
        goto targetFail;
    }

    bReleaseRemLockOnFail = TRUE; // We now have the RemoveLock

    if( !Irp->MdlAddress ) {
        // no MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }
    
    if( !MmGetMdlByteCount(Irp->MdlAddress) ) {
        // zero length MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }

    pipe = devExt->ReadPipe;
    if( !pipe ) {
        // we don't have a read pipe? - something is seriously wrong
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }

    if( UsbdPipeTypeBulk != pipe->PipeType ) {
        // our read pipe is not a bulk pipe?
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }


    //
    // If we got here we survived the sanity checks - continue processing
    //

    status = UsbReadWrite( DevObj, Irp, pipe, UsbReadRequest );
    //IoReleaseRemoveLock( &devExt->RemoveLock, Irp ); // Moved this to completion routine
    goto targetExit;

targetFail:
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    if( bReleaseRemLockOnFail ) {
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    }

targetExit:
    return status;
}


/************************************************************************/
/* DispatchWrite                                                        */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_WRITE - Validate parameters and forward
//       valid requests to USB handler.
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the request
//      Irp    - pointer to write request
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchWrite(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    NTSTATUS                status;
    PUSBD_PIPE_INFORMATION  pipe;
    BOOLEAN                 bReleaseRemLockOnFail;

    TR_VERBOSE(("DispatchWrite - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );
    if( STATUS_SUCCESS != status ) {
        // couldn't aquire RemoveLock - FAIL request
        bReleaseRemLockOnFail = FALSE;
        goto targetFail;
    }

    bReleaseRemLockOnFail = TRUE; // We now have the RemoveLock

    if( !Irp->MdlAddress ) {
        // no MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }
    
    if( !MmGetMdlByteCount(Irp->MdlAddress) ) {
        // zero length MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }

    pipe = devExt->WritePipe;
    if( !pipe ) {
        // we don't have a write pipe? - something is seriously wrong - FAIL request
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }

    if( UsbdPipeTypeBulk != pipe->PipeType ) {
        // our write pipe is not a bulk pipe? - FAIL request
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }

    //
    // If we got here we survived the sanity checks - continue processing
    //

    status = UsbReadWrite( DevObj, Irp, pipe, UsbWriteRequest );
   // IoReleaseRemoveLock( &devExt->RemoveLock, Irp ); // moved this to completion routine
    goto targetExit;

targetFail:
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    if( bReleaseRemLockOnFail ) {
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    }

targetExit:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\registry.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Registry.c

Abstract:

        Registry access utility functions

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* RegGetDword                                                          */
/************************************************************************/
//
// Routine Description:
//
//      - Read a DWORD value from the registry (with caller specified 
//          default value) given an absolute KeyPath. 
// 
//      - If we are unable to read the value from the registry for any
//          reason (e.g., no ValueName entry exists) then return the
//          default value passed into the function in *Value.
//
// Arguments: 
//
//      KeyPath   - absolute path to registry key
//      ValueName - name of the value to retrieve
//      Value     - in  - points to a default value
//                - out - points to the location for returned value
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
RegGetDword(
    IN     PCWSTR  KeyPath,
    IN     PCWSTR  ValueName,
    IN OUT PULONG  Value
    )
{
    NTSTATUS                  status;
    RTL_QUERY_REGISTRY_TABLE  paramTable[2];

    D4UAssert( KeyPath && ValueName && Value );

    RtlZeroMemory( &paramTable[0], sizeof(paramTable) );
    
    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = (PWSTR)ValueName; // cast away const
    paramTable[0].EntryContext  = Value;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = Value;
    paramTable[0].DefaultLength = sizeof(ULONG);
    
    // leave paramTable[1] as all zeros - this terminates the table
    
    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     KeyPath,
                                     &paramTable[0],
                                     NULL,
                                     NULL );

    TR_VERBOSE(("registry::RegGetDword - status = %x , *Value = %x\n", status, *Value));

    return status;
}


/************************************************************************/
/* RegGetDeviceParameterDword                                           */
/************************************************************************/
//
// Routine Description:
//
//      - Read a DWORD value from the registry (with caller specified 
//          default value) given a PDO. 
// 
//      - If we are unable to read the value from the registry for any
//          reason (e.g., no ValueName entry exists) then return the
//          default value passed into the function in *Value.
//
// Arguments: 
//
//      Pdo       - PDO for which we want to read the device parameter
//      ValueName - name of the value to retrieve
//      Value     - in  - points to a default value
//                - out - points to the location for returned value
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
RegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PCWSTR          ValueName,
    IN OUT PULONG          Value
    )
{
    NTSTATUS                 status;
    HANDLE                   hKey;

    D4UAssert( Pdo && ValueName && Value );

    status = IoOpenDeviceRegistryKey( Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hKey );

    if( NT_SUCCESS(status) ) {

        RTL_QUERY_REGISTRY_TABLE queryTable[2];

        RtlZeroMemory(&queryTable, sizeof(queryTable));
        
        queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name          = (PWSTR)ValueName; // cast away const
        queryTable[0].EntryContext  = Value;
        queryTable[0].DefaultType   = REG_DWORD;
        queryTable[0].DefaultData   = Value;
        queryTable[0].DefaultLength = sizeof(ULONG);
        
        status = RtlQueryRegistryValues( RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                         hKey,
                                         queryTable,
                                         NULL,
                                         NULL );        

        ZwClose(hKey);

        TR_VERBOSE(("registry::RegGetDeviceParameterDword - status = %x , *Value = %x\n", status, *Value));
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\usb.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Usb.c

Abstract:

        Interface USB DeviceObject below us

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"


NTSTATUS
UsbBuildPipeList(
    IN  PDEVICE_OBJECT DevObj
    )
    // Parse the interface descriptor to find the pipes that we want 
    //   to use and save pointers to those pipes in our extension for 
    //   easier access
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    PUSBD_INTERFACE_INFORMATION InterfaceDescriptor;
    ULONG i;
    KIRQL oldIrql;
    NTSTATUS status = STATUS_SUCCESS;
    
    TR_VERBOSE(("UsbBuildPipeList - enter"));

    // need to lock extension to prevent Remove handler from freeing
    // Interface out from under us causing an AV
    KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
    InterfaceDescriptor = devExt->Interface;
    if( !InterfaceDescriptor ) {
        KeReleaseSpinLock( &devExt->SpinLock, oldIrql );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetExit;
    }

    for( i=0; i<InterfaceDescriptor->NumberOfPipes; i++ ) {
        TR_VERBOSE(("about to look at endpoint with address 0x%x)",InterfaceDescriptor->Pipes[i].EndpointAddress));
        if(((InterfaceDescriptor->Pipes[i].EndpointAddress)&0x80)==0) {

            // EndPointAddress bit 7 == 0 means OUT endpoint - WritePipe
            TR_VERBOSE(("Found write pipe"));
            devExt->WritePipe = &(InterfaceDescriptor->Pipes[i]);

        } else {

            // EndPointAddress bit 7 == 1 means IN endpoint - ReadPipe
            if( InterfaceDescriptor->Pipes[i].PipeType == UsbdPipeTypeBulk ) { 
                TR_VERBOSE(("Found bulk read pipe"));
                devExt->ReadPipe = &(InterfaceDescriptor->Pipes[i]);
            } else if( InterfaceDescriptor->Pipes[i].PipeType == UsbdPipeTypeInterrupt ) { 
                TR_VERBOSE(("Found interrupt read pipe"));
                devExt->InterruptPipe = &(InterfaceDescriptor->Pipes[i]);
            }
        }
    }

    KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

targetExit:
    return status;
}


LONG
UsbGet1284Id(
    IN PDEVICE_OBJECT DevObj,
    PVOID             Buffer,
    LONG              BufferLength
    )
/*++

Routine Description:
  Requests and returns Printer 1284 Device ID

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer device.
        pIoBuffer    - pointer to IO buffer from user mode
        iLen         - Length of *pIoBuffer;




Return Value:

    Success: Length of data written to *pIoBuffer (icluding lenght field in first two bytes of data)
        Failure: -1

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    LONG iReturn = -1;
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    LARGE_INTEGER   timeOut;
    KIRQL           oldIrql;

    TR_VERBOSE(("UsbGet1284Id - enter"));

    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));

    if( !urb ) {
        iReturn = -1;
        goto targetExit;
    }

    KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
    if( !devExt->Interface ) {
        KeReleaseSpinLock( &devExt->SpinLock, oldIrql );
        iReturn = -1;
        goto targetCleanup;
    }

    UsbBuildVendorRequest( urb,
                           URB_FUNCTION_CLASS_INTERFACE, //request target
                           sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), //request len
                           USBD_TRANSFER_DIRECTION_IN|USBD_SHORT_TRANSFER_OK, //flags
                           0, //reserved bits
                           0, //request code
                           0, //wValue
                           (USHORT)(devExt->Interface->InterfaceNumber<<8), //wIndex
                           Buffer, //return buffer address
                           NULL, //mdl
                           BufferLength,  //return length
                           NULL); //link param

    KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

    timeOut.QuadPart = FAILURE_TIMEOUT;
    ntStatus = UsbCallUsbd(DevObj, urb, &timeOut);
    TR_VERBOSE(("urb->Hdr.Status=%d",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));

    if( NT_SUCCESS(ntStatus) && urb->UrbControlVendorClassRequest.TransferBufferLength > 2) {
        iReturn= (LONG)(*((unsigned char *)Buffer));
        iReturn<<=8;
        iReturn+=(LONG)(*(((unsigned char *)Buffer)+1));
        if ( iReturn > 0 && iReturn < BufferLength ) {
            *(((char *)Buffer)+iReturn)='\0';
        } else {
            iReturn = -1;
        }
    } else {
        iReturn=-1;
    }

targetCleanup:
    ExFreePool(urb);

targetExit:
    TR_VERBOSE(("UsbGet1284Id - exit w/return value = decimal %d",iReturn));
    return iReturn;
}


NTSTATUS
UsbGetDescriptor(
    IN PDEVICE_EXTENSION DevExt
    )
    // get USB descriptor
{
    NTSTATUS               status = STATUS_SUCCESS;
    PURB                   urb = ExAllocatePool(NonPagedPool, sizeof(URB));
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    ULONG                  siz;
    LARGE_INTEGER          timeOut;

    TR_VERBOSE(("UsbGetDescriptor - enter"));

    if( urb ) {
        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool,siz);
        if (deviceDescriptor) {
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_DEVICE_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         deviceDescriptor,
                                         NULL,
                                         siz,
                                         NULL);
            
            timeOut.QuadPart = FAILURE_TIMEOUT;
            status = UsbCallUsbd(DevExt->DevObj, urb, &timeOut);
        }
    } else {
        TR_VERBOSE(("UsbGetDescriptor - no pool for urb"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( NT_SUCCESS(status) ) {
        TR_VERBOSE(("Device Descriptor = %x, len %x", deviceDescriptor, urb->UrbControlDescriptorRequest.TransferBufferLength));
        TR_VERBOSE(("bLength........... 0x%x", deviceDescriptor->bLength));
        TR_VERBOSE(("bDescriptorType    0x%x", deviceDescriptor->bDescriptorType));
        TR_VERBOSE(("bcdUSB             0x%x", deviceDescriptor->bcdUSB));
        TR_VERBOSE(("bDeviceClass       0x%x", deviceDescriptor->bDeviceClass));
        TR_VERBOSE(("bDeviceSubClass....0x%x", deviceDescriptor->bDeviceSubClass));
        TR_VERBOSE(("bDeviceProtocol    0x%x", deviceDescriptor->bDeviceProtocol));
        TR_VERBOSE(("bMaxPacketSize0    0x%x", deviceDescriptor->bMaxPacketSize0));
        TR_VERBOSE(("idVendor           0x%x", deviceDescriptor->idVendor));
        TR_VERBOSE(("idProduct......... 0x%x", deviceDescriptor->idProduct));
        TR_VERBOSE(("bcdDevice          0x%x", deviceDescriptor->bcdDevice));
        TR_VERBOSE(("iManufacturer      0x%x", deviceDescriptor->iManufacturer));
        TR_VERBOSE(("iProduct           0x%x", deviceDescriptor->iProduct));
        TR_VERBOSE(("iSerialNumber..... 0x%x", deviceDescriptor->iSerialNumber));
        TR_VERBOSE(("bNumConfigurations 0x%x", deviceDescriptor->bNumConfigurations));
    }

    if( urb ) {
        ExFreePool( urb );
        urb = NULL;
    }
    if( deviceDescriptor ) {
        ExFreePool( deviceDescriptor );
        deviceDescriptor = NULL;
    }

    return status;
}

NTSTATUS
UsbConfigureDevice(
    IN PDEVICE_EXTENSION DevExt
    )
{
    NTSTATUS                      status;
    PURB                          urb;
    ULONG                         siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    LARGE_INTEGER                 timeOut;

    timeOut.QuadPart = FAILURE_TIMEOUT;
    
    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    
    if (urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR)+256;
        
get_config_descriptor_retry:
        
        configurationDescriptor = ExAllocatePool(NonPagedPool,siz);
        
        if (configurationDescriptor) {
            
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         siz,
                                         NULL);
            
            status = UsbCallUsbd(DevExt->DevObj, urb, &timeOut);
            if(!NT_SUCCESS(status)) {
                TR_VERBOSE(("Get Configuration descriptor failed"));
            } else {
                //
                // if we got some data see if it was enough.
                //
                // NOTE: we may get an error in URB because of buffer overrun
                if( ( urb->UrbControlDescriptorRequest.TransferBufferLength > 0 ) &&
                    ( configurationDescriptor->wTotalLength > siz ) ) {

                    siz = configurationDescriptor->wTotalLength;
                    ExFreePool(configurationDescriptor);
                    configurationDescriptor = NULL;
                    goto get_config_descriptor_retry;
                }
            }
            
            TR_VERBOSE(("Configuration Descriptor = %x, len %x", 
                    configurationDescriptor, urb->UrbControlDescriptorRequest.TransferBufferLength));
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
                
        ExFreePool( urb );
        
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    if( configurationDescriptor ) {
        
        //
        // We have the configuration descriptor for the configuration
        // we want.
        //
        // Now we issue the select configuration command to get
        // the  pipes associated with this configuration.
        //
        if( NT_SUCCESS(status) ) {
            TR_VERBOSE(("got a configurationDescriptor - next try to select interface"));
            status = UsbSelectInterface( DevExt->DevObj, configurationDescriptor );
        }
        ExFreePool( configurationDescriptor );
    }
    
    TR_VERBOSE(("dbgUSB2 - exit w/status = %x", status));
    
    return status;
}

NTSTATUS 
UsbSelectInterface(
    IN PDEVICE_OBJECT                DevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS status;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
    PUSBD_INTERFACE_INFORMATION Interface = NULL;
    USBD_INTERFACE_LIST_ENTRY InterfaceList[2];
    LARGE_INTEGER   timeOut;

    timeOut.QuadPart = FAILURE_TIMEOUT;

    TR_VERBOSE(("dbgUSB3 - enter"));
    
    //
    // Look for a *.*.3 interface in the ConfigurationDescriptor
    //
    interfaceDescriptor = USBD_ParseConfigurationDescriptorEx( ConfigurationDescriptor,
                                                               ConfigurationDescriptor,
                                                               -1, // InterfaceNumber   - ignore 
                                                               -1, // AlternateSetting  - ignore 
                                                               -1, // InterfaceClass    - ignore 
                                                               -1, // InterfaceSubClass - ignore  
                                                                3  // InterfaceProtocol
                                                               );
    if( !interfaceDescriptor ) {
        TR_VERBOSE(("ParseConfigurationDescriptorEx FAILED"));
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
        goto targetExit;
    }

    TR_VERBOSE(("ParseConfigurationDescriptorEx SUCCESS"));

    InterfaceList[0].InterfaceDescriptor=interfaceDescriptor;
    InterfaceList[1].InterfaceDescriptor=NULL;

    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor,InterfaceList);
    if( !urb ) {
        TR_VERBOSE(("no pool for URB - dbgUSB3"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetExit;
    }

    Interface = InterfaceList[0].Interface;

    // handle larger transfers on pipes (perf requirement by scanning)
    {
        PUSBD_INTERFACE_INFORMATION myInterface = &urb->UrbSelectConfiguration.Interface;
        ULONG i;
        ULONG pipeCount = Interface->NumberOfPipes;
        ULONG newMax = 128 * 1024 - 1;
        for( i=0 ; i < pipeCount ; ++i ) {
            myInterface->Pipes[i].MaximumTransferSize = newMax;
        }
    }

    status = UsbCallUsbd(DevObj, urb, &timeOut);

    if (NT_SUCCESS(status)) {
        
        //
        // Save the configuration handle for this device
        //
        
        devExt->ConfigHandle = urb->UrbSelectConfiguration.ConfigurationHandle;

        devExt->Interface = ExAllocatePool(NonPagedPool,Interface->Length);
        
        if( devExt->Interface ) {
            ULONG j;
            //
            // save a copy of the interface information returned
            //
            RtlCopyMemory(devExt->Interface, Interface, Interface->Length);
            
            //
            // Dump the interface to the debugger
            //
            TR_VERBOSE(("NumberOfPipes             0x%x", devExt->Interface->NumberOfPipes));
            TR_VERBOSE(("Length                    0x%x", devExt->Interface->Length));
            TR_VERBOSE(("Alt Setting               0x%x", devExt->Interface->AlternateSetting));
            TR_VERBOSE(("Interface Number          0x%x", devExt->Interface->InterfaceNumber));
            TR_VERBOSE(("Class, subclass, protocol 0x%x 0x%x 0x%x", 
                    devExt->Interface->Class, devExt->Interface->SubClass, devExt->Interface->Protocol));

            // Dump the pipe info
            for( j=0; j<Interface->NumberOfPipes; ++j ) {
                PUSBD_PIPE_INFORMATION pipeInformation;
                
                pipeInformation = &devExt->Interface->Pipes[j];
                
                TR_VERBOSE(("PipeType            0x%x", pipeInformation->PipeType));
                TR_VERBOSE(("EndpointAddress     0x%x", pipeInformation->EndpointAddress));
                TR_VERBOSE(("MaxPacketSize       0x%x", pipeInformation->MaximumPacketSize));
                TR_VERBOSE(("Interval            0x%x", pipeInformation->Interval));
                TR_VERBOSE(("Handle              0x%x", pipeInformation->PipeHandle));
                TR_VERBOSE(("MaximumTransferSize 0x%x", pipeInformation->MaximumTransferSize));
            }
            
        } else {
            TR_VERBOSE(("Alloc failed in SelectInterface"));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    if( urb ) {
        ExFreePool( urb );
    }
    
 targetExit:

    TR_VERBOSE(("dbgUSB3 exit w/status = %x", status));

    return status;
}


PURB
UsbBuildAsyncRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_PIPE_INFORMATION PipeHandle,
    IN BOOLEAN Read
    )
// return an initialized async URB, or NULL on error
{
    ULONG siz;
    PURB  urb;

    UNREFERENCED_PARAMETER( DeviceObject );

    if( NULL == Irp->MdlAddress ) {
        return NULL;
    }

    siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb = ExAllocatePool( NonPagedPool, siz );

    if( urb ) {
	RtlZeroMemory(urb, siz);
	urb->UrbBulkOrInterruptTransfer.Hdr.Length    = (USHORT) siz;
	urb->UrbBulkOrInterruptTransfer.Hdr.Function  = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.PipeHandle    = PipeHandle->PipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferFlags = Read ? USBD_TRANSFER_DIRECTION_IN : 0;

	// short packet is not treated as an error.
	urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;            
		
	// no linkage for now
	urb->UrbBulkOrInterruptTransfer.UrbLink              = NULL;

	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL    = Irp->MdlAddress;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength = MmGetMdlByteCount(Irp->MdlAddress);
    }

    return urb;
}


NTSTATUS
UsbAsyncReadWriteComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the USBPRINT device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS         status    = STATUS_SUCCESS;
    PUSB_RW_CONTEXT  rwContext = Context;
    PURB             urb;
    LONG ResetPending;
    PDOT4USB_WORKITEM_CONTEXT pResetWorkItemObj;
    PDEVICE_EXTENSION deviceExtension;

        
    deviceExtension=DeviceObject->DeviceExtension;


    if (Irp->PendingReturned) {
	IoMarkIrpPending(Irp);
    }

    urb  = rwContext->Urb;
    
    TR_VERBOSE(("UsbAsyncReadWriteComplete - enter - TransferBufferLength= %d, UrbStatus= 0x%08X",
		     urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
		     urb->UrbHeader.Status));

    status=urb->UrbHeader.Status;

    // set the length based on the TransferBufferLength value in the URB
    Irp->IoStatus.Information = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

    if((!NT_SUCCESS(status))&&(status!=STATUS_CANCELLED)&&(status!=STATUS_DEVICE_NOT_CONNECTED))
    {
        ResetPending=InterlockedCompareExchange(&deviceExtension->ResetWorkItemPending,1,0);  //Check to see if ResetWorkItem is 0, if so, set it to 1, and start a Reset
        if(!ResetPending)
        {
            pResetWorkItemObj=ExAllocatePool(NonPagedPool,sizeof(DOT4USB_WORKITEM_CONTEXT));
            if(pResetWorkItemObj)
            {
                pResetWorkItemObj->ioWorkItem=IoAllocateWorkItem(DeviceObject);
                if(pResetWorkItemObj==NULL)
                {
                    TR_FAIL(("DOT4USB.SYS: Unable to allocate IoAllocateWorkItem in ReadWrite_Complete\n"));
                    ExFreePool(pResetWorkItemObj);
                    pResetWorkItemObj=NULL;
                }
            } //if ALloc RestWorkItem OK
            else
            {
              TR_FAIL(("DOT4USB.SYS: Unable to allocate WorkItemObj in ReadWrite_Complete\n"));
            }
            if(pResetWorkItemObj)
            {
               pResetWorkItemObj->irp=Irp;
               pResetWorkItemObj->deviceObject=DeviceObject;
               if(rwContext->IsWrite)
                   pResetWorkItemObj->pPipeInfo=deviceExtension->WritePipe;
               else
                   pResetWorkItemObj->pPipeInfo=deviceExtension->ReadPipe;
               IoQueueWorkItem(pResetWorkItemObj->ioWorkItem,DOT4USB_ResetWorkItem,DelayedWorkQueue,pResetWorkItemObj);
               status=STATUS_MORE_PROCESSING_REQUIRED;
            }   //end if allocs all OK

        }   //end if not already resetting
 
    }   //end if we need to reset

    IoReleaseRemoveLock( &(deviceExtension->RemoveLock), Irp );
    ExFreePool(rwContext);
    ExFreePool(urb);

    return status;
}

NTSTATUS DOT4USB_ResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context)
{   

    PDOT4USB_WORKITEM_CONTEXT pResetWorkItemObj;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    PDEVICE_OBJECT devObj;

    UNREFERENCED_PARAMETER(deviceObject);
    TR_VERBOSE(("USBPRINT.SYS: Entering USBPRINT_ResetWorkItem\n"));
    pResetWorkItemObj=(PDOT4USB_WORKITEM_CONTEXT)Context;
    DeviceExtension=pResetWorkItemObj->deviceObject->DeviceExtension;
    ntStatus=UsbResetPipe(pResetWorkItemObj->deviceObject,pResetWorkItemObj->pPipeInfo,FALSE);
    IoCompleteRequest(pResetWorkItemObj->irp,IO_NO_INCREMENT);
    IoFreeWorkItem(pResetWorkItemObj->ioWorkItem);
    
    // save off work item device object before freeing work item
    devObj = pResetWorkItemObj->deviceObject;
    ExFreePool(pResetWorkItemObj);
    InterlockedExchange(&(DeviceExtension->ResetWorkItemPending),0);
    return ntStatus;
}




NTSTATUS
UsbReadInterruptPipeLoopCompletionRoutine(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    devExt
    )
{
    PURB                urb;
    PDEVICE_OBJECT      devObj;
    PUSB_RW_CONTEXT     context;
    PCHAR               scratchBuffer;
    KIRQL               oldIrql;
    ULONG               sizeOfUrb;
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;
    BOOLEAN             queueNewRequest;

    UNREFERENCED_PARAMETER( DevObj ); // we created this Irp via IoAllocateIrp() and we didn't reserve an IO_STACK_LOCATION
                                      //   for ourselves, so we can't use this


    if(devExt->InterruptContext)
    {
        context         = devExt->InterruptContext;         
        urb             = context->Urb;
        devObj          = context->DevObj;
        scratchBuffer   = urb->UrbBulkOrInterruptTransfer.TransferBuffer;
    }
    else
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

        // must have freed up the context stuff, so just return
    KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
    if( !Irp->Cancel && devExt->Dot4Event && NT_SUCCESS(Irp->IoStatus.Status) ) {
        queueNewRequest = TRUE;
        KeSetEvent( devExt->Dot4Event, 1, FALSE ); // signal dot4.sys that peripheral has data to be read
    } else {
        TR_TMP1(("UsbReadInterruptPipeLoopCompletionRoutine - cancel, Dot4 event gone, or bad status in irp - time to clean up"));
        if( STATUS_SUCCESS != Irp->IoStatus.Status ) {
            TR_TMP1(("UsbReadInterruptPipeLoopCompletionRoutine - IoStatus.Status = %x\n",Irp->IoStatus.Status));
        }
        queueNewRequest = FALSE;
    }
    KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

    if( queueNewRequest ) {
        // queue another read request in the interrupt pipe
        sizeOfUrb = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
        RtlZeroMemory( urb, sizeOfUrb );
        urb->UrbBulkOrInterruptTransfer.Hdr.Length           = (USHORT)sizeOfUrb;
        urb->UrbBulkOrInterruptTransfer.Hdr.Function         = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
        urb->UrbBulkOrInterruptTransfer.PipeHandle           = devExt->InterruptPipe->PipeHandle;
        urb->UrbBulkOrInterruptTransfer.TransferFlags        = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
        urb->UrbBulkOrInterruptTransfer.TransferBuffer       = scratchBuffer;
        urb->UrbBulkOrInterruptTransfer.TransferBufferLength = SCRATCH_BUFFER_SIZE;
        urb->UrbBulkOrInterruptTransfer.TransferBufferMDL    = NULL;
        urb->UrbBulkOrInterruptTransfer.UrbLink              = NULL;

        IoReuseIrp( Irp, STATUS_NOT_SUPPORTED );

        irpSp = IoGetNextIrpStackLocation( Irp );
        irpSp->MajorFunction                            = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
        irpSp->Parameters.Others.Argument1              = urb;

        IoSetCompletionRoutine( Irp, UsbReadInterruptPipeLoopCompletionRoutine, devExt, TRUE, TRUE, TRUE );

        status = IoCallDriver(devExt->LowerDevObj, Irp);

        if( !NT_SUCCESS( status ) ) {
            // bummer - Irp is in limbo - stop polling and mark Irp for cleanup
            D4UAssert(!"UsbReadInterruptPipeLoopCompletionRoutine - IoCallDriver failed");

            if(devExt->InterruptContext)
            {
                InterlockedExchangePointer(&devExt->InterruptContext, NULL);
                ExFreePool( urb );
                ExFreePool( context );
                ExFreePool( scratchBuffer );
                KeSetEvent( &devExt->PollIrpEvent, 0, FALSE ); // signal dispatch routine that it is safe to touch the Irp - including IoFreeIrp()
            }
        }

    } else {
        if(devExt->InterruptContext)
        {
            // clean up - either Irp was cancelled or we got a datalink disconnect IOCTL from dot4
            InterlockedExchangePointer(&devExt->InterruptContext, NULL);
            ExFreePool( urb );
            ExFreePool( context );
            ExFreePool( scratchBuffer );
            TR_TMP1(("UsbReadInterruptPipeLoopCompletionRoutine - signalling PollIrpEvent"));
            KeSetEvent( &devExt->PollIrpEvent, 0, FALSE ); // signal dispatch routine that it is safe to touch the Irp - including IoFreeIrp()
        }
    }

    return STATUS_MORE_PROCESSING_REQUIRED; // always
}


/************************************************************************/
/* UsbStopReadInterruptPipeLoop                                         */
/************************************************************************/
//
// Routine Description:
//
//      - Stop the polling of the device interrupt pipe started by
//          UsbStartReadInterruptPipeLoop and free the Irp.
//
//      - It is legal for devExt->PollIrp to be NULL on entry to this function.
//
//      - This function is called from the DataLink Disconnect IOCTL
//          handler, from the PnP Surprise Removal handler and from the
//          PnP Remove handler. It is safe to call this function multiple
//          times between PollIrp creations.
//
//      - This is the only function in the driver that should call
//          IoFreeIrp on devExt->PollIrp and it is the only function
//          that should change devExt->PollIrp from !NULL -> NULL
//
//      - This function will block until the PollIrp, if any, has
//          been cleaned up. The block should be for a very short
//          period of time unless there is a driver bug here or in
//          the USB stack below us.
//
// Arguments: 
//
//      DevObj - pointer to Dot4Usb.sys driver object
//                                                        
// Return Value:                                          
//                                                        
//      NONE
//                                                        
/************************************************************************/
VOID
UsbStopReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    KIRQL                      oldIrql;

    TR_VERBOSE(("UsbStopReadInterruptPipeLoop - enter"));

    //
    // We must hold this SpinLock in order to change devExt->PollIrp
    //
    KeAcquireSpinLock( &devExt->PollIrpSpinLock, &oldIrql );

    if( devExt->PollIrp ) {

        //
        // We have a PollIrp - Cancel the Irp so that the completion
        //   routine detects that it should take the Irp out of play and
        //   signal us when it is safe for us to touch the irp.
        //
        NTSTATUS       status;
        LARGE_INTEGER  timeOut;
        PIRP           irp;
        
        irp             = devExt->PollIrp;
        devExt->PollIrp = NULL;

        //
        // Safe to let go of the SpinLock - everything from here on is local to this function
        //
        KeReleaseSpinLock( &devExt->PollIrpSpinLock, oldIrql );

        //
        // Completion routine will detect that the Irp has been cancelled
        //
retryCancel:
        IoCancelIrp( irp );

        //
        // Completion routine will set PollIrpEvent when it has taken
        //   the Irp out of play and it is safe for us to touch the Irp
        //
        // 500ms (in 100ns units) - magic number chosen as "reasonable" timeout
        //
        timeOut.QuadPart = - 500 * 10 * 1000; 
        status = KeWaitForSingleObject( &devExt->PollIrpEvent, Executive, KernelMode, FALSE, &timeOut ); 

        if( STATUS_SUCCESS == status ) {
            //
            // Completion routine has signalled that we now own the irp - clean it up
            //
            IoFreeIrp( irp );

            //
            // This irp will no longer block a Remove
            //
            IoReleaseRemoveLock( &devExt->RemoveLock, irp );

        } else if( STATUS_TIMEOUT == status ) {
            //
            // Cancel and wait again - either we hit a timing window where our completion
            //   routine lost our cancel request, or the Irp is wedged in a driver somewhere
            //   below us.
            //
            goto retryCancel;

        } else {
            //
            // We specified that we were NOT alertable - but check for this condition anyway
            //
            D4UAssert(!"UsbStopReadInterruptPipeLoop - unexpected status from KeWaitForSingleObject?!?");            
            goto retryCancel;
        }

    } else {

        //
        // We don't have a PollIrp - nothing for us to clean up.
        //
        TR_VERBOSE(("UsbStopReadInterruptPipeLoop - NULL PollIrp"));
        KeReleaseSpinLock( &devExt->PollIrpSpinLock, oldIrql );

    }
}


/************************************************************************/
/* UsbStartReadInterruptPipeLoop                                        */
/************************************************************************/
//
// Routine Description:
//
//      - Create a read request (Irp) for the device's interrupt pipe. Save a
//          pointer to the Irp in our device extension for cleanup later by
//          UsbStopReadInterruptPipeLoop().
//
//      - This is the only function in the driver that should change
//          devExt->PollIrp from NULL -> !NULL
//
// Arguments: 
//
//      DevObj - pointer to Dot4Usb.sys driver object
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
UsbStartReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    )
{
    NTSTATUS                status; 
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    PUSBD_PIPE_INFORMATION  pipe;
    ULONG                   sizeOfUrb;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PURB                    urb;
    PUSB_RW_CONTEXT         context;
    PCHAR                   scratchBuffer;
    KIRQL                   oldIrql;
    
    TR_VERBOSE(("UsbStartReadInterruptPipeLoop - enter"));


    //
    // We must hold this SpinLock in order to change devExt->PollIrp
    //
    // BUGBUG - This SpinLock is protecting some code that doesn't need protection,
    //            which means that we are at Raised Irql when we don't need to be.
    //            Revisit this later to move the Acquire and Release of this SpinLock
    //            so that it only protects code that needs protection.
    //
    KeAcquireSpinLock( &devExt->PollIrpSpinLock, &oldIrql );


    //
    // Driver state machine check - we should never get two calls to this
    //   function without a cleanup (UsbStopReadInterruptPipeLoop) call in between.
    //
    D4UAssert( !devExt->PollIrp );


    //
    // Verify that we have an interrupt pipe
    //
    pipe = devExt->InterruptPipe;
    if( !pipe ) {
        TR_FAIL(("UsbStartReadInterruptPipeLoop - no interrupt pipe"));
        status = STATUS_INVALID_HANDLE;
        goto targetError;
    }


    //
    // Pipe type/look ok?
    //
    D4UAssert( UsbdPipeTypeInterrupt == pipe->PipeType && USBD_PIPE_DIRECTION_IN(pipe) );


    //
    // Allocate pool that we need for this request
    //
    sizeOfUrb = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb = ExAllocatePool( NonPagedPool, sizeOfUrb );
    if( !urb ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    context = ExAllocatePool( NonPagedPool, sizeof(USB_RW_CONTEXT) );
    if( !context ) {
        ExFreePool( urb );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    scratchBuffer = ExAllocatePool( NonPagedPool, SCRATCH_BUFFER_SIZE );
    if( !scratchBuffer ) {
        ExFreePool( urb );
        ExFreePool( context );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }


    //
    // Set up Context for completion routine
    //
    //   - We send down a pointer to our Device Object in context
    //       because we create this IRP via IoAllocateIrp and we don't
    //       reserve a stack location for ourselves, so the PDEVICE_OBJECT
    //       parameter that our completion routine receives is bogus
    //      (probably NULL)
    //
    context->Urb    = urb;
    context->DevObj = DevObj;


    //
    // Initialize URB for read on interrupt pipe
    //
    RtlZeroMemory( urb, sizeOfUrb );

    urb->UrbBulkOrInterruptTransfer.Hdr.Length           = (USHORT)sizeOfUrb;
    urb->UrbBulkOrInterruptTransfer.Hdr.Function         = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    urb->UrbBulkOrInterruptTransfer.PipeHandle           = pipe->PipeHandle;
    urb->UrbBulkOrInterruptTransfer.TransferFlags        = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
    urb->UrbBulkOrInterruptTransfer.TransferBuffer       = scratchBuffer;
    urb->UrbBulkOrInterruptTransfer.TransferBufferLength = SCRATCH_BUFFER_SIZE; // note - likely only one byte to read
    urb->UrbBulkOrInterruptTransfer.TransferBufferMDL    = NULL;
    urb->UrbBulkOrInterruptTransfer.UrbLink              = NULL;


    //
    // Allocate and set up the IRP, stack location, and completion routine
    //
    irp = IoAllocateIrp( devExt->LowerDevObj->StackSize, FALSE );
    if( !irp ) {
        ExFreePool( urb );
        ExFreePool( context );
        ExFreePool( scratchBuffer );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    irpSp                                           = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction                            = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    irpSp->Parameters.Others.Argument1              = urb;

    IoSetCompletionRoutine( irp, UsbReadInterruptPipeLoopCompletionRoutine, devExt, TRUE, TRUE, TRUE );


    //
    // This event will be SET by the completion routine when it is
    //   safe for a dispatch routine to touch this Irp
    //
    KeClearEvent( &devExt->PollIrpEvent ); 


    //
    // We're about to put the Irp in play - make sure that our device
    //   doesn't get removed while this Irp is in use
    //
    status = IoAcquireRemoveLock( &devExt->RemoveLock, irp );
    if( STATUS_SUCCESS != status ) {
        //
        // We're being removed - clean up and bail out
        //
        IoFreeIrp( irp );
        ExFreePool( urb );
        ExFreePool( context );
        ExFreePool( scratchBuffer );
        status = STATUS_DELETE_PENDING;
        goto targetError;
    }

    //
    // Save a pointer to this Irp in our extension so that UsbStopReadInterruptPipeLoop()
    //   can find it to IoFreeIrp() it later.
    //
    D4UAssert( !devExt->PollIrp );
    devExt->PollIrp = irp;

    // save interrupt context in device extension
    InterlockedExchangePointer(&devExt->InterruptContext, context);


    //
    // Kick off the first read. Subsequent reads will come from the
    //   completion routine as it reuses/bounces the IRP. The completion routine
    //   is responsible taking the Irp out of play when it detects either a termination 
    //   condition or request error. UsbStopReadInterruptPipeLoop() will clean up the
    //   Irp after the completion routine has taken the Irp out of play and signaled
    //   PollIrpEvent that it is safe to touch the Irp.
    //
    status = IoCallDriver( devExt->LowerDevObj, irp );

targetError:

    //
    // CURRENTLY... all paths to here hold the SpinLock - this should change after cleanup
    //
    KeReleaseSpinLock( &devExt->PollIrpSpinLock, oldIrql );


    // 
    // If the Irp is Pending then we have been successful
    //
    if( STATUS_PENDING == status ) {
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
UsbDeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Event
    )
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
    KeSetEvent( (PKEVENT)Event, 1, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
UsbCallUsbd(
    IN PDEVICE_OBJECT   DevObj,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout 
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceObject - pointer to the device object for this printer

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    PIRP irp;
    KEVENT event;
    PIO_STACK_LOCATION nextStack;

    TR_VERBOSE(("UsbCallUsbd - enter"));

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    if ( (irp = IoAllocateIrp(devExt->LowerDevObj->StackSize,
                              FALSE)) == NULL )
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    D4UAssert(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->Parameters.Others.Argument1 = Urb;

    IoSetCompletionRoutine(irp,
               UsbDeferIrpCompletion,
               &event,
               TRUE,
               TRUE,
               TRUE);
               
    ntStatus = IoCallDriver(devExt->LowerDevObj, irp);

    if ( ntStatus == STATUS_PENDING ) {
        status = KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,pTimeout);
        //
        // If the request timed out cancel the request
        // and wait for it to complete
        //
        if ( status == STATUS_TIMEOUT ) {
            TR_VERBOSE(("UsbCallUsbd: Cancelling IRP %x because of timeout", irp));
            IoCancelIrp(irp);
            KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
        }

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    TR_VERBOSE(("UsbCallUsbd - exit w/status=%x", ntStatus));

    return ntStatus;
}


NTSTATUS
UsbResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    )
/*++

Routine Description:

    Reset a given USB pipe.
    
    NOTES:

    This will reset the host to Data0 and should also reset the device
    to Data0 for Bulk and Interrupt pipes.

    For Iso pipes this will set the virgin state of pipe so that ASAP
    transfers begin with the current bus frame instead of the next frame
    after the last transfer occurred.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;


    TR_VERBOSE(("Entering UsbResetPipe; pipe # %x\n", Pipe));

    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {

    urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
    urb->UrbPipeRequest.PipeHandle =
        Pipe->PipeHandle;

    ntStatus = UsbCallUsbd(DeviceObject, urb, &timeOut);

    ExFreePool(urb);

    } else {
    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Memphis RESET_PIPE will send a Clear-Feature Endpoint Stall to
    // reset the data toggle of non-Iso pipes as part of a RESET_PIPE
    // request.  It does not do this for Iso pipes as Iso pipes do not use
    // the data toggle (all Iso packets are Data0).  However, we also use
    // the Clear-Feature Endpoint Stall request in our device firmware to
    // reset data buffer points inside the device so we explicitly send
    // this request to the device for Iso pipes if desired.
    //
    if (NT_SUCCESS(ntStatus) && IsoClearStall &&
    (Pipe->PipeType == UsbdPipeTypeIsochronous)) {
    
    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

    if (urb) {

        UsbBuildFeatureRequest(urb,
                   URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT,
                   USB_FEATURE_ENDPOINT_STALL,
                   Pipe->EndpointAddress,
                   NULL);

        ntStatus = UsbCallUsbd(DeviceObject, urb, &timeOut);

        ExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    }

    return ntStatus;
}


NTSTATUS
UsbReadWrite(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    PUSBD_PIPE_INFORMATION  Pipe,
    USB_REQUEST_TYPE        RequestType
    )
/*
  - Caller must verify that:
    - Irp->MdlAddress != NULL
    - Pipe != NULL
    - RequestType matches Pipe->PipeType

*/
{
    PDEVICE_EXTENSION       devExt;
    PIO_STACK_LOCATION      nextIrpSp;
    PURB                    urb;
    PUSB_RW_CONTEXT         context;
    ULONG                   sizeOfUrb  = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    NTSTATUS                status     = STATUS_SUCCESS;

    TR_VERBOSE(("UsbReadWrite - enter"));

    D4UAssert( Irp->MdlAddress ); // calling routine should catch and fail this case
    D4UAssert( Pipe );            // calling routine should catch and fail this case 

    urb = ExAllocatePool( NonPagedPool, sizeOfUrb );
    if( !urb ) {
        TR_FAIL(("UsbReadWrite - no pool for URB"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    context = ExAllocatePool( NonPagedPool, sizeof(USB_RW_CONTEXT) );
    if( !context ) {
        TR_FAIL(("UsbReadWrite - no pool for context"));
        ExFreePool( urb );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    context->Urb    = (PURB)urb;
    context->DevObj = DevObj;

    RtlZeroMemory(urb, sizeOfUrb);

    UsbBuildInterruptOrBulkTransferRequest( urb, 
                                            (USHORT)sizeOfUrb,
                                            Pipe->PipeHandle,
                                            NULL, // transferBuffer
                                            Irp->MdlAddress,
                                            MmGetMdlByteCount(Irp->MdlAddress),
                                            0,    // transfer Flags
                                            NULL );

    if( UsbReadRequest == RequestType ) {
        context->IsWrite=FALSE;
        TR_VERBOSE(("UsbReadWrite - requesttype is READ"))
        urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN;
        urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    } else {
        context->IsWrite=TRUE;
        TR_VERBOSE(("UsbReadWrite - requesttype is WRITE"))
    }

    nextIrpSp                                           = IoGetNextIrpStackLocation( Irp );
    nextIrpSp->MajorFunction                            = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpSp->Parameters.Others.Argument1              = urb;
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    
    IoSetCompletionRoutine( Irp, UsbAsyncReadWriteComplete, context, TRUE, TRUE, TRUE );
  
    devExt = DevObj->DeviceExtension;
    IoMarkIrpPending(Irp);
    status = IoCallDriver( devExt->LowerDevObj, Irp );
    status = STATUS_PENDING;


    goto targetDone;

targetError:

    Irp->IoStatus.Status      = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

targetDone:

    TR_VERBOSE(("UsbReadWrite - exit - status= %x",status));
    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\util.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Util.c

Abstract:

        Misc. Utility functions

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code review and doc
        - code review w/Joby

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchPassThrough                                                  */
/************************************************************************/
//
// Routine Description:
//
//     Default dispatch routine for IRP_MJ_xxx that we don't explicitly
//       handle. Pass the request down to the device object below us.
//
// Arguments:
//
//      DevObj - pointer to Device Object that is the target of the request
//      Irp    - pointer to request
//
// Return Value:
//
//      NTSTATUS
//
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
DispatchPassThrough(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION   devExt = DevObj->DeviceExtension;
    NTSTATUS            status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {
        // RemoveLock acquired, continue with request
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - FAIL request
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}


/************************************************************************/
/* CallLowerDriverSync                                                  */
/************************************************************************/
//
// Routine Description:
//
//     Call the driver below us synchronously. When this routine returns
//       the calling routine once again owns the IRP.
//
//     This routine acquires and holds a RemoveLock against the IRP
//       while the IRP is in the possession of drivers below us.
//
// Arguments:
//
//      DevObj - pointer to Device Object that is issuing the request
//      Irp    - pointer to request
//
// Return Value:
//
//      NTSTATUS
//
/************************************************************************/
NTSTATUS
CallLowerDriverSync(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
)
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS          status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {
        KEVENT         event;
        KeInitializeEvent( &event, NotificationEvent, FALSE );
        IoSetCompletionRoutine( Irp, CallLowerDriverSyncCompletion, &event, TRUE, TRUE, TRUE );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        if( STATUS_PENDING == status ) {
            KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
            status = Irp->IoStatus.Status;
        }
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        TR_FAIL(("util::CallLowerDriverSync - Couldn't aquire RemoveLock"));
    }

    return status;
}


/************************************************************************/
/* CallLowerDriverSyncCompletion                                        */
/************************************************************************/
//
// Routine Description:
//
//     This is the completion routine for CallLowerDriverSync() that
//       simply signals the event and stops the IRP completion from
//       unwinding so that CallLowerDriverSync() can regain ownership
//       of the IRP.
//
// Arguments:
//
//      DevObjOrNULL - Usually, this is this driver's device object.
//                       However, if this driver created the IRP, then
//                       there is no stack location in the IRP for this
//                       driver; so the kernel has no place to store the
//                       device object; ** so devObj will be NULL in
//                       this case **.
//      Irp    - pointer to request
//
// Return Value:
//
//      NTSTATUS
//
/************************************************************************/
NTSTATUS
CallLowerDriverSyncCompletion(
    IN PDEVICE_OBJECT DevObjOrNULL,
    IN PIRP           Irp,
    IN PVOID          Context
)
{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DevObjOrNULL );
    UNREFERENCED_PARAMETER( Irp );

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\makefile.inc ===
mofcomp: selSusp.bmf

selSusp.bmf: selSusp.mof
        mofcomp -B:selSusp.bmf selSusp.mof
        wmimofck selSusp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\dot4\dot4usb\test.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Test.c

Abstract:

        Test/Diagnostic/Experimentation routines - These routines are NOT
          required for the normal operation of the driver.

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


VOID
TestEventLog( 
    IN PDEVICE_OBJECT DevObj 
    )
/*
  Demonstrate Event log usage - entries are made up using unique values 
  to make it easier to determine the corresponding offsets in the event 
  log entry "Data:" section. Sample event log entry resulting from this
  call was:
  ----
    Event Type:	Information
    Event Source:	dot4usb
    Event Category:	None
    Event ID:	16
    Date:		1/17/2000
    Time:		3:04:34 PM
    User:		N/A
    Computer:	DFRITZ3DJ
    Description:
    Dot4Usb AddDevice - test event log message <ThisIsMsgForParam2> <ThisIsMsgForParam3>. 
    Data:
    0000: 00040109 00580003 00000000 40070010
    0010: 00000017 c0000022 00000005 00000000
    0020: 98762222 abcd1111 12345678 
  ----

  A recommended place to call this from is from AddDevice

*/
{
    WCHAR                msg[]  = L"ThisIsMsgForParam2\0ThisIsMsgForParam3";
    PIO_ERROR_LOG_PACKET log    = IoAllocateErrorLogEntry( DevObj, sizeof(IO_ERROR_LOG_PACKET)+sizeof(msg) );

    if( log ) {
        log->MajorFunctionCode     = (UCHAR) IRP_MJ_FLUSH_BUFFERS; // 9
        log->RetryCount            = (UCHAR) 1;
        log->DumpDataSize          = (USHORT)4;
        log->NumberOfStrings       = (USHORT)2;
        log->StringOffset          = (USHORT)sizeof(IO_ERROR_LOG_PACKET);
        log->EventCategory         = (USHORT)0;
        log->ErrorCode             = (NTSTATUS)D4U_ADDDEV; // IO_ERR_xxx - 0x40070010
        log->UniqueErrorValue      = (ULONG)0x17; // made up
        log->FinalStatus           = (NTSTATUS)STATUS_ACCESS_DENIED; // 0xC0000022 - easy to remember
        log->SequenceNumber        = (ULONG)5; // made up
        log->IoControlCode         = (ULONG)0;
        log->DeviceOffset.HighPart = 0xabcd1111;
        log->DeviceOffset.LowPart  = 0x98762222;
        log->DumpData[0]           = 0x12345678;
        RtlCopyMemory( (PCHAR)log + sizeof(IO_ERROR_LOG_PACKET), msg, sizeof(msg));
        IoWriteErrorLogEntry( log );
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\selsusp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.c

Abstract:

    This module contains code for a generic client driver that can be loaded 
    for all USB devices/child interfaces.

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSUsr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"

//
// Globals
//

GLOBALS Globals;
ULONG   DebugLevel = 3;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SS_DriverUnload)
#pragma alloc_text(PAGE, SS_DispatchCreate)
#pragma alloc_text(PAGE, SS_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //

    registryPath = &Globals.SSRegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        SSDbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SS_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = SS_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = SS_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SS_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SS_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = SS_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SS_DispatchSysCtrl;
    DriverObject->DriverUnload                         = SS_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         SS_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will clean up all resources we allocated.

Arguments:

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    SSDbgPrint(3, ("SS_DriverUnload - begins\n"));

    registryPath = &Globals.SSRegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    SSDbgPrint(3, ("SS_DriverUnload - ends\n"));

    return;
}

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    SSDbgPrint(3, ("SS_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        
        SSDbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_BUFFERED_IO;

    //
    // initialize the device state lock and set the device state
    //

    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //

    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //

    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = SSWmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("SSWmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // set the power state of the device
    //

    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    //

    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        SSWmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_GENERIC_SELECTIVE_SUSPEND, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        SSWmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // initialize DPC
    //
    KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                    DpcRoutine, 
                    deviceObject);

    //
    // initialize timer
    //
    KeInitializeTimerEx(&deviceExtension->Timer,
                        NotificationTimer);

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    SSDbgPrint(3, ("SS_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\selsusp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <ntddk.h>
#include <wmilib.h>
#include "usbdi.h"
#include "usbdlib.h"

#ifndef _SUSPEND_LOCAL_H
#define _SUSPEND_LOCAL_H

#define SSTAG (ULONG) 'SleS'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, SSTAG);

#if DBG

#define SSDbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint("@#"); \
                DbgPrint _x_; \
            }

#else

#define SSDbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING SSRegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    //Bus drivers set the appropriate values in this structure in response
    //to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    //alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables
    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    KSPIN_LOCK IdleReqStateLock;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    //
    // selective suspend model uses timers, dpcs and work item.
    //
    KTIMER Timer;

    KDPC DeferredProcCall;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;



typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\ssdevctr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"

extern GLOBALS Globals;
extern ULONG   DebugLevel;

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchCreate - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    //
    // increment OpenHandleCounts
    //
    InterlockedIncrement(&deviceExtension->OpenHandleCount);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // the device is idle if it has no open handles or pending PnP Irps
    // since we just received an open handle request, cancel idle req. if any
    //
    CancelSelectSuspend(deviceExtension);

    SSDbgPrint(3, ("SS_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchClose - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    SSDbgPrint(3, ("SS_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    info = 0;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
	
    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoIncrement(deviceExtension);

    switch(code) {

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

Return Value:

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    SSDbgPrint(0, ("SubmitIdleRequest - begins\n"));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        SSDbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitRequest_Exit;
    }

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;

        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            SSDbgPrint(1, ("cannot build idle request irp\n"));

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitRequest_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension))
        {
            //
            // IRPs created using IoBuildDeviceIoControlRequest should be
            // completed by calling IoCompleteRequest and not merely 
            // deallocated.
            //
     
            SSDbgPrint(0, ("Device is not idle\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            if(irp)
            {
                irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
                irp->IoStatus.Information = 0;

                IoCompleteRequest(irp, IO_NO_INCREMENT);
            }

            goto SubmitRequest_Exit;
        }

        SSDbgPrint(3, ("Cancel the timers\n"));

        KeCancelTimer(&DeviceExtension->Timer);

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitRequest_Exit;
        }
    }
    else {

        SSDbgPrint(0, ("Memory allocation for idleCallbackInfo failed\n"));

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitRequest_Exit:

    SSDbgPrint(0, ("SubmitIdleRequest - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    SSDbgPrint(0, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        SSDbgPrint(0, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        SSDbgPrint(3, ("IdleNotificationCallback::"));
        SSIoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        if(STATUS_PENDING == ntStatus) {

            SSDbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    
    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    SSDbgPrint(0, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    LARGE_INTEGER           dueTime;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    SSDbgPrint(0, ("IdleNotificationRequestCompete - begins\n"));

    //
    // check the Irp status
    //

    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        SSDbgPrint(0, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            SSDbgPrint(0, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            SSDbgPrint(0, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            SSDbgPrint(0, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            SSDbgPrint(0, ("STATUS_DEVICE_BUSY\n"));

            break;
        }

        //
        // if in error, issue a SetD0
        //

        SSDbgPrint(3, ("IdleNotificationRequestComplete::"));
        SSIoIncrement(DeviceExtension);

        powerState.DeviceState = PowerDeviceD0;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                          DeviceExtension, 
                          NULL);

        if(!NT_SUCCESS(ntStatus)) {
    
            SSDbgPrint(1, ("PoRequestPowerIrp failed\n"));
        }

    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    DeviceExtension->PendingIdleIrp = NULL;

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    SSDbgPrint(3, ("Set the timer to fire DPCs\n"));

    dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

    KeSetTimerEx(&DeviceExtension->Timer, 
                 dueTime,
                 IDLE_INTERVAL,                              // 5000 ms
                 &DeviceExtension->DeferredProcCall);

    SSDbgPrint(0, ("IdleNotificationRequestCompete - ends\n"));

    //
    // since we allocated the irp, we need to free it.
    // return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not touch it.
    //

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    SSDbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        SSDbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(irp) {
        
        if(IoCancelIrp(irp)) {

            SSDbgPrint(0, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            SSDbgPrint(0, ("IoCancelIrp returns FALSE\n"));
        }
    }

    SSDbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //

    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        SSDbgPrint(3, ("PoIrpCompletionFunc::"));
        SSIoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("WWIrpCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\ssdevctr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __DEV_CTRL_H
#define __DEV_CTRL_H

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\sspwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSPwr.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"

extern GLOBALS Globals;
extern ULONG DebugLevel;

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("SS_DispatchPower::"));
    SSIoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            ntStatus = HandleSystemSetPower(DeviceObject, Irp);

            break;

        case DevicePowerState:

            ntStatus = HandleDeviceSetPower(DeviceObject, Irp);

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            ntStatus = HandleSystemQueryPower(DeviceObject, Irp);

            break;

        case DevicePowerState:

            ntStatus = HandleDeviceQueryPower(DeviceObject, Irp);

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed this Irp"));
        }

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        SSDbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        SSIoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed this Irp"));
        }
        
        SSDbgPrint(3, ("SS_DispatchPower::"));
        SSIoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    //
    // Fail a query for a power state incompatible with waking up the system
    //

    if((deviceExtension->WaitWakeEnable) &&
       (systemState > deviceExtension->DeviceCapabilities.SystemWake)) {

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("HandleSystemQueryPower::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;
    }

    //
    // if querying for a lower S-state, issue a wait-wake
    //

    if(systemState > deviceExtension->SysPower) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    SSDbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    if(deviceExtension->WaitWakeEnable &&
       deviceState > deviceExtension->DeviceCapabilities.DeviceWake) {

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("HandleDeviceQueryPower::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;
    }

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("HandleDeviceQueryPower::"));
    SSIoDecrement(deviceExtension);

    SSDbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    SSDbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("SysPoCompletionRoutine::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    SSDbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        SSDbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("SendDeviceIrp::"));
        SSIoDecrement(deviceExtension);

    }

    SSDbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    SSDbgPrint(3, ("DevPoCompletionRoutine::"));
    SSIoDecrement(deviceExtension);

    ExFreePool(powerContext);

    SSDbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    SSDbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        SSDbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        SSDbgPrint(3, ("Removing power or SetD0\n"));

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //
            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                SSDbgPrint(3, ("HandleDeviceSetPower::"));
                SSIoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }

        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    SSDbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return ntStatus;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    SSDbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("FinishDevPoUpIrp::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    SSDbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SetDeviceFunctional::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    SSDbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        SSDbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    SSDbgPrint(3, ("FinishDevPoDnIrp::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            SSDbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(0, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    SSDbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke SSIoDecrement twice: once each for the S-Irp and D-Irp.
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

  Queue the Irp in the device queue

Arguments:

Return Value:

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    SSDbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    SSDbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    SSDbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    SSDbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        return STATUS_SUCCESS;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    SSDbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP Irp;

    SSDbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    SSDbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    SSDbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    SSDbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    SSDbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        SSDbgPrint(3, ("device already powered up...\n"));

        return;
    }

    SSDbgPrint(3, ("WaitWakeCallback::"));
    SSIoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    IssueWaitWake(deviceExtension);

    SSDbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\sspwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __POWER_H
#define __POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\sspnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __PNP_H
#define __PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReturnResources(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\ssusr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSUsr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _SEL_SUSPEND_USER_H
#define _SEL_SUSPEND_USER_H

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_GENERIC_SELECTIVE_SUSPEND, 
0x6068eb61, 0x98e7, 0x4c98, 0x9e, 0x20, 0x1f, 0x6, 0x82, 0x95, 0x90, 0x9a);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\sspnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"

extern ULONG DebugLevel;

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("///////////////////////////////////////////\n"));
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        CancelSelectSuspend(deviceExtension);
    }

    SSDbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::default::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    } // switch

//
// complete request 
//

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

//
// decrement count
//
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    SSDbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower drivers failed this Irp\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake outstanding flag to false.
    // and issue a wait wake.
    
    deviceExtension->FlagWWOutstanding = 0;

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);

    //
    // set timer.
    //

    dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

    KeSetTimerEx(&deviceExtension->Timer, 
                 dueTime,
                 IDLE_INTERVAL,                              // 5000 ms
                 &deviceExtension->DeferredProcCall);

    SSDbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
            			    
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            SSDbgPrint(1, ("Failed to allocate memory for deviceDescriptor"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;



    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the descriptor of the first configuration
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1,("Failed to read configuration descriptor"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    if(configurationDescriptor) {

        ExFreePool(configurationDescriptor);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION Interface;

    //
    // initialize the variables
    //

    urb = NULL;
    Interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        SSDbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        Interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<Interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            Interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        SSDbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        SSDbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        SSDbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    SSDbgPrint(3, ("CallUSBD::"));
    SSIoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    SSDbgPrint(3, ("CallUSBD::"));
    SSIoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    SSDbgPrint(3, ("HandleQueryStopDevice::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //

    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    
    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //

    ntStatus = ReturnResources(DeviceObject);

    CancelWaitWake(deviceExtension);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    ntStatus = DeconfigureDevice(DeviceObject);
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    ntStatus = CanRemoveDevice(DeviceObject, Irp);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    SSDbgPrint(3, ("HandleQueryRemoveDevice::"));
    SSIoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    CancelWaitWake(deviceExtension);

    KeCancelTimer(&deviceExtension->Timer);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }


    ReturnResources(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        CancelWaitWake(deviceExtension);

        KeCancelTimer(&deviceExtension->Timer);

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }

        ReturnResources(DeviceObject);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    SSWmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    SSDbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    SSDbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        SSDbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }
    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    SSDbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    SSDbgPrint(3, ("DpcRoutine - begins\n"));

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            SSDbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        
        SSDbgPrint(3, ("Idle event not signaled\n"));
    }

    SSDbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    SSDbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        SSDbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    SSDbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Remove and process the entries in the queue. If this routine is called
  when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
  or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
  If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
  are complete with STATUS_DELETE_PENDING

Arguments:

Return Value:

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    SSDbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY listEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    SSDbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoIncrement::%d\n", result));

    return result;
}

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReturnResources(
    IN PDEVICE_OBJECT DeviceObject
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
   //
   // Disconnect from the interrupt and unmap any I/O ports
   //

   UNREFERENCED_PARAMETER(DeviceObject);

   return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}

NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION  deviceExtension;
    KIRQL              oldIrql;
    LIST_ENTRY         cleanupList;
    PLIST_ENTRY        thisEntry, 
                       nextEntry, 
                       listHead;
    PIRP               pendingIrp;
    PIO_STACK_LOCATION pendingIrpStack, 
                       irpStack;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    InitializeListHead(&cleanupList);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoIncrement(deviceExtension);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}


BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    SSDbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\sswmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSWmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"
#include "sSWmi.h"
#include <initguid.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_SELECT_SUSPEND_DRIVER_INFORMATION 0

DEFINE_GUID (SELECT_SUSPEND_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO SSWmiGuidList[1] = { {

        &SELECT_SUSPEND_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

extern GLOBALS Globals;
extern ULONG   DebugLevel;

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (SSWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = SSWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = SSQueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = SSQueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = SSSetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = SSSetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SSQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.SSRegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    SSDbgPrint(3, ("SSQueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            SSDbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_BUFFER_TOO_SMALL;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSQueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    SSDbgPrint(3, ("SSSetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    SSDbgPrint(3, ("SSSetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\beep\beep.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    beep.h

Abstract:

    These are the structures and defines that are used in the beep driver.

Author:

    Lee A. Smith (lees) 02-Aug-1991.

Revision History:

--*/

#ifndef _BEEP_
#define _BEEP_

#include <ntddbeep.h>

//
// Define the device extension.
//

typedef struct _DEVICE_EXTENSION {

    KTIMER Timer;
    FAST_MUTEX Mutex;
    ULONG ReferenceCount;
    LONG TimerSet;
    PVOID hPagedCode;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#endif // _BEEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\drivers\wdm\usb\driver\selsusp\sswmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSWmi.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __WMI_H
#define __WMI_H

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SSQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\beep\dbg.h ===
#define BEEP_TAG         0x50454542 /* "BEEP" */

#if DBG

VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define BeepPrint(x) BeepDebugPrint x
#else
#define BeepPrint(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\beep\beep.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    Beep driver.

Author:

    Lee A. Smith (lees) 02-Aug-1991.

Environment:

    Kernel mode only.

Notes:


Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"
#include <ntddbeep.h>
#include "beep.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
BeepCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BeepCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#if DBG

VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

//
// Declare the global debug flag for this driver.
//

ULONG BeepDebug = 0;
#define BeepPrint(x) BeepDebugPrint x
#else
#define BeepPrint(x)
#endif

NTSTATUS
BeepDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BeepOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BeepClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BeepStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BeepTimeOut(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BeepUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//
// Coud page out the entire driver in DriverEntry, then page it in 
// upon receiving an open, and page it out during the close. This is
// the way the driver used to operate. There is a problem with this
// on multiproc machines, however. 
// The following sequence of events illustrates a possible bugcheck
// circumstance:
// The BeepTimeout routine decrements the TimerSet at the end of the
// routine. Immediately following this, on a different processor, the
// close routine pages out the DPC routine because the TimerSet variable
// is zero. At this point there is a window of two assembly instructions
// left in the BeepTimeout routine where a page-out would result in a 
// bugcheck.
//

#if 0
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGEBEEP, BeepDeviceControl)
#pragma alloc_text(PAGEBEEP, BeepOpen)
#pragma alloc_text(PAGEBEEP, BeepClose)
#pragma alloc_text(PAGEBEEP, BeepStartIo)
#pragma alloc_text(PAGEBEEP, BeepUnload)
#pragma alloc_text(PAGEBEEP, BeepCancel)
#pragma alloc_text(PAGEBEEP, BeepCleanup)
#endif
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the beep driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    BeepPrint((2,"\n\nBEEP-BeepInitialize: enter\n"));
    //
    // Create non-exclusive device object for beep device.
    //

    RtlInitUnicodeString(&unicodeString, DD_BEEP_DEVICE_NAME_U);

    status = IoCreateDevice(
                DriverObject,
                sizeof(DEVICE_EXTENSION),
                &unicodeString,
                FILE_DEVICE_BEEP,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &deviceObject
                );

    if (status != STATUS_SUCCESS) {
        BeepPrint((
            1,
            "BEEP-BeepInitialize: Could not create device object\n"
            ));
        return(status);
    }

    deviceObject->Flags |= DO_BUFFERED_IO;
    deviceExtension =
        (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    //
    // Initialize the timer DPC queue (we use the device object DPC) and
    // the timer itself.
    //

    IoInitializeDpcRequest(
            deviceObject,
            (PKDEFERRED_ROUTINE) BeepTimeOut
            );

    KeInitializeTimer(&deviceExtension->Timer);
    deviceExtension->TimerSet = 0;

    //
    // Initialize the fast mutex and set the reference count to zero.
    //
    ExInitializeFastMutex(&deviceExtension->Mutex);
    deviceExtension->ReferenceCount = 0;

    //
    // Set up the device driver entry points.
    //

    DriverObject->DriverStartIo = BeepStartIo;
    DriverObject->DriverUnload = BeepUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = BeepOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = BeepClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
                                             BeepDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = BeepCleanup;

#ifdef _PNP_POWER_
    //
    // The HAL is in charge of the beeping, it will take care
    // of the power management on the device
    //

    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

    BeepPrint((2,"BEEP-BeepInitialize: exit\n"));

    return(STATUS_SUCCESS);

}

VOID
BeepCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called from the I/O system when a request is cancelled.

    N.B.  The cancel spinlock is already held upon entry to this routine.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet to be cancelled.

Return Value:

    None.

--*/

{

    BeepPrint((2,"BEEP-BeepCancel: enter\n"));

    if (Irp == DeviceObject->CurrentIrp) {

        //
        // The current request is being cancelled.
        // Don't cancel the request since it is will be completed shortly.
        //

        IoReleaseCancelSpinLock(Irp->CancelIrql);
        return;
    } else {

        //
        // Cancel a request in the device queue.  Remove it from queue and
        // release the cancel spinlock.
        //

        if (TRUE != KeRemoveEntryDeviceQueue(
                        &DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry
                        )) {
            BeepPrint((
                1,
                "BEEP-BeepCancel: Irp 0x%x not in device queue?!?\n",
                Irp
                ));

            // It's not on the queue.  Assume it's being processed.
            IoReleaseCancelSpinLock(Irp->CancelIrql);
            return;
        }
        IoReleaseCancelSpinLock(Irp->CancelIrql);
    }

    //
    // Complete the request with STATUS_CANCELLED.
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepCancel: exit\n"));

    return;
}

NTSTATUS
BeepCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All queued beep requests are completed with STATUS_CANCELLED,
    and the speaker is stopped.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    KIRQL currentIrql;
    KIRQL cancelIrql;
    PKDEVICE_QUEUE_ENTRY packet;
    PIRP  currentIrp;

    BeepPrint((2,"BEEP-BeepCleanup: enter\n"));

    //
    // Raise IRQL to DISPATCH_LEVEL.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

    //
    // Complete all queued requests with STATUS_CANCELLED.
    // Run down the list of requests in the device queue.
    //

    IoAcquireCancelSpinLock(&cancelIrql);
    currentIrp = DeviceObject->CurrentIrp;
    DeviceObject->CurrentIrp = NULL;

    while (currentIrp != NULL) {

        //
        // Dequeue the next packet (IRP) from the device work queue.
        //

        packet = KeRemoveDeviceQueue(&DeviceObject->DeviceQueue);
        if (packet != NULL) {
            currentIrp =
                CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);
        } else {
            currentIrp = (PIRP) NULL;
        }

        if (!currentIrp) {
            break;
        }

        //
        // Remove the CurrentIrp from the cancellable state.
        //
        //

        IoSetCancelRoutine(currentIrp, NULL);

        //
        // Set Status to CANCELLED, release the cancel spinlock,
        // and complete the request.  Note that the IRQL is reset to
        // DISPATCH_LEVEL when we release the cancel spinlock.
        //

        currentIrp->IoStatus.Status = STATUS_CANCELLED;
        currentIrp->IoStatus.Information = 0;

        IoReleaseCancelSpinLock(cancelIrql);
        IoCompleteRequest(currentIrp, IO_NO_INCREMENT);

        IoAcquireCancelSpinLock(&cancelIrql);
    }

    IoReleaseCancelSpinLock(cancelIrql);

    //
    // Lower IRQL.
    //

    KeLowerIrql(currentIrql);

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    //
    // Call HalMakeBeep() to stop any outstanding beep.
    //
#if !defined(NO_LEGACY_DRIVERS)
    (VOID) HalMakeBeep(0);
#endif // NO_LEGACY_DRIVERS

    BeepPrint((2,"BEEP-BeepCleanup: exit\n"));

    return(STATUS_SUCCESS);

}

#if DBG
VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= BeepDebug) {

        char buffer[128];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

}
#endif

NTSTATUS
BeepDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.
    The IOCTL_BEEP_SET subfunction is processed and completed
    in this routine.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PBEEP_SET_PARAMETERS beepParameters;

    BeepPrint((2,"BEEP-BeepDeviceControl: enter\n"));

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Make a beep.  Validate the beep function parameters and return
        // status pending.
        //

        case IOCTL_BEEP_SET:
            beepParameters = (PBEEP_SET_PARAMETERS)
                (Irp->AssociatedIrp.SystemBuffer);
            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                   sizeof(BEEP_SET_PARAMETERS)) {
                status = STATUS_INVALID_PARAMETER;
            } else if ((beepParameters->Frequency != 0)
                        && (beepParameters->Duration == 0)) {
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_PENDING;
            }

            break;

        //
        // Unrecognized device control request.
        //

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // If status is pending, mark the packet pending and start the packet
    // in a cancellable state.  Otherwise, complete the request.
    //

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    if (status == STATUS_PENDING) {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, (PULONG)NULL, BeepCancel);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    BeepPrint((2,"BEEP-BeepDeviceControl: exit\n"));

    return(status);

}

NTSTATUS
BeepOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for create/open requests.
    Open requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PFAST_MUTEX mutex;

    BeepPrint((2,"BEEP-BeepOpenClose: enter\n"));

    //
    // Increment the reference count. If this is the first reference,
    // reset the driver paging.
    //
    deviceExtension = DeviceObject->DeviceExtension;
    mutex = &deviceExtension->Mutex;
    ExAcquireFastMutex(mutex);
    if (++deviceExtension->ReferenceCount == 1) {
        deviceExtension->hPagedCode = MmLockPagableCodeSection(BeepOpen);
    }
    ExReleaseFastMutex(mutex);

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepOpenClose: exit\n"));

    return(STATUS_SUCCESS);
}

NTSTATUS
BeepClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for close requests.
    Close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PFAST_MUTEX mutex;

    BeepPrint((2,"BEEP-BeepOpenClose: enter\n"));

    //
    // Decrement the reference count. If this is the last reference,
    // page the driver out
    //
    deviceExtension = DeviceObject->DeviceExtension;
    mutex = &deviceExtension->Mutex;
    ExAcquireFastMutex(mutex);
    if (--deviceExtension->ReferenceCount == 0) {

        //
        // If there is a timer queued, attempt to cancel it before paging out
        // the driver.  If we cannot cancel it, it may already be queued for
        // execution on another processor.  This is highly unlikely, so just
        // don't page out the entire driver if a timer has been set but cannot
        // be canceled.
        //

        MmUnlockPagableImageSection(deviceExtension->hPagedCode);
        if (deviceExtension->TimerSet &&
            KeCancelTimer(&deviceExtension->Timer)) {
            InterlockedDecrement(&deviceExtension->TimerSet);
        }

    }
    ExReleaseFastMutex(mutex);

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepOpenClose: exit\n"));

    return(STATUS_SUCCESS);
}

VOID
BeepStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the StartIo routine.  It is invoked to start a beep
    request.

    N.B.  Requests enter BeepStartIo in a cancellable state.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    KIRQL cancelIrql;
    PBEEP_SET_PARAMETERS beepParameters;
    LARGE_INTEGER time;
    NTSTATUS status;

    BeepPrint((2,"BEEP-BeepStartIo: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Acquire the cancel spinlock and verify that the CurrentIrp has not been
    // cancelled.
    //

    IoAcquireCancelSpinLock(&cancelIrql);
    if (Irp == NULL) {
        IoReleaseCancelSpinLock(cancelIrql);
        return;
    }

    //
    // Remove the request from the cancellable state and release the cancel
    // spinlock.
    //

    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(cancelIrql);

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Make a beep.  Call HalMakeBeep() to do the real work, and start
        // a timer that will fire when the beep duration is reached.  Finally,
        // complete the request.
        //

        case IOCTL_BEEP_SET:

            //
            // Get the beep parameters.
            //

            beepParameters = (PBEEP_SET_PARAMETERS)
                (Irp->AssociatedIrp.SystemBuffer);

            BeepPrint((
                3,
                "BEEP-BeepStartIo: frequency %x, duration %d\n",
                beepParameters->Frequency,
                beepParameters->Duration
                ));

            //
            // Cancel the current timer (if any).
            //

            if (deviceExtension->TimerSet) {
                if (KeCancelTimer(&deviceExtension->Timer)) {

                    //
                    // Timer successfully cancelled
                    //

                    InterlockedDecrement(&deviceExtension->TimerSet);

                } else {

                    //
                    // The timer has already expired and
                    // been queued, it will reset the
                    // TimerSet flag when it runs.
                    //

                }
            }

            //
            // Call the HAL to actually start the beep (synchronizes
            // access to the i8254 speaker.
            //
#if !defined(NO_LEGACY_DRIVERS)
            if (HalMakeBeep(beepParameters->Frequency)) {
#else
	    if (TRUE) {
#endif // NO_LEGACY_DRIVERS

                status = STATUS_SUCCESS;

                //
                // Set the timer so the beep will time out after
                // the user-specified number of milliseconds (converted
                // to 100ns resolution).
                //

                time.QuadPart = (LONGLONG)beepParameters->Duration * -10000;

                BeepPrint((
                    3,
                    "BEEP-BeepStartIo: negative duration in 100ns %x.%x\n",
                    time.HighPart,
                    time.LowPart
                    ));

                InterlockedIncrement(&deviceExtension->TimerSet);

                if (KeSetTimer(&deviceExtension->Timer, time,
                               &DeviceObject->Dpc)) {

                    InterlockedDecrement(&deviceExtension->TimerSet);
                }

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        //
        // Unrecognized device control request.
        //

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Start the next packet, and complete this request.
    //

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoStartNextPacket(DeviceObject, TRUE);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepStartIo: exit\n"));

    return;

}

VOID
BeepTimeOut(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the driver's timeout routine.  It is called when the beep
    duration expires.  The timer is started in StartIo.

    N.B.  The request is removed from the cancellable state prior to
    the timer start, so there is no need to check the cancellation status
    here.

Arguments:

    DeviceObject - Pointer to the device object.

    Context - Unused.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    BeepPrint((2, "BEEP-BeepTimeOut: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Stop the beep.
    //
#if !defined(NO_LEGACY_DRIVERS)
    (VOID) HalMakeBeep(0);
#endif // NO_LEGACY_DRIVERS

    //
    // Clear the TimerSet flag
    //
    InterlockedDecrement(&deviceExtension->TimerSet);

    //
    // We don't have a request at this point -- it was completed in StartIo
    // when the beep was started.  So, there's no more work to do here.
    //
    
    BeepPrint((2, "BEEP-BeepTimeOut: exit\n"));
}

VOID
BeepUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the beep driver unload routine.

Arguments:

    DriverObject - Pointer to class driver object.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;



    BeepPrint((1,"BEEP-BeepUnload: enter\n"));

    deviceObject = DriverObject->DeviceObject;
    deviceExtension = deviceObject->DeviceExtension;

    //
    // Cancel the timer.
    //

    if (deviceExtension->TimerSet) {
        if (KeCancelTimer(&deviceExtension->Timer)) {

            //
            // Timer successfully cancelled
            //

            InterlockedDecrement(&deviceExtension->TimerSet);
        } else {

            //
            // The timer has already expired and
            // been queued, it will reset the
            // TimerSet flag when it runs.
            //

        }
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(deviceObject);
    BeepPrint((1,"BEEP-BeepUnload: exit\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\beep\dbg.c ===
#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"


#if DBG
//
// Declare the global debug flag for this driver.
//

ULONG BeepDebug = 1;

VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= BeepDebug) {
        char buffer[256];
        DbgPrint("BEEP: ");
        (VOID) vsprintf(buffer, DebugMessage, ap);
        DbgPrint(buffer);
    }

    va_end(ap);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\beep\pnp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    This module contains contains the plugplay calls
    PNP / WDM BUS driver.

Author:

    Jay Senior (jsenior) 5/4/99 (ya, ya, y2k, blah)

Environment:

    Kernel mode only.

Notes:


Revision History:

    Jay Senior (jsenior) 5/4/99 - Made driver PnP

--*/

#include "beep.h"
#include "dbg.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BeepAddDevice)
#pragma alloc_text(PAGE,BeepPnP)
#endif

NTSTATUS
BeepAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    BusPhysicalDeviceObject - Device object representing the bus.  That to which
        we attach a new FDO.

    DriverObject - This very self referenced driver.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PBEEP_EXTENSION deviceExtension;
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    
    PAGED_CODE ();

    BeepPrint((3,"Entering Add Device.\n"));
    
    RtlInitUnicodeString(&unicodeString, DD_BEEP_DEVICE_NAME_U);
    //
    // Create non-exclusive device object for beep device.
    //
    status = IoCreateDevice(
                DriverObject,
                sizeof(BEEP_EXTENSION),
                &unicodeString,
                FILE_DEVICE_BEEP,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &deviceObject
                );
    
    if (!NT_SUCCESS(status)) {
        BeepPrint((1,"Could not create device object!\n"));
        return status;
    }
    
    deviceExtension =
        (PBEEP_EXTENSION)deviceObject->DeviceExtension;
    
    //
    // Initialize the timer DPC queue (we use the device object DPC) and
    // the timer itself.
    //
    
    IoInitializeDpcRequest(
            deviceObject,
            (PKDEFERRED_ROUTINE) BeepTimeOut
            );
    
    KeInitializeTimer(&deviceExtension->Timer);
    
    //
    // Initialize the fast mutex and set the reference count to zero.
    //
    ExInitializeFastMutex(&deviceExtension->Mutex);
    deviceExtension->DeviceState = PowerDeviceD0;
    deviceExtension->SystemState = PowerSystemWorking;
    
    // Set the PDO for use with PlugPlay functions
    deviceExtension->Self = deviceObject;
    deviceExtension->UnderlyingPDO = BusPhysicalDeviceObject;
        
    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    deviceExtension->TopOfStack = IoAttachDeviceToDeviceStack (
                                    deviceObject,
                                    BusPhysicalDeviceObject);

    deviceObject->Flags |= DO_BUFFERED_IO;
    
    IoInitializeRemoveLock (&deviceExtension->RemoveLock, 
                            BEEP_TAG,
                            1,
                            5); // One for pnp, one for power, one for io

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    deviceObject->Flags |= DO_POWER_PAGABLE;

    return status;
}

NTSTATUS
BeepPnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Pirp,
    IN PVOID            Context
    );

NTSTATUS
BeepPnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    PBEEP_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    KEVENT                  event;
    ULONG                   i;

    PAGED_CODE ();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_PNP == irpStack->MajorFunction);
    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //

        BeepPrint ((2,"Start Device\n"));

        if (deviceExtension->Started) {
            BeepPrint ((2,"Device already started\n"));
            status = STATUS_SUCCESS;
            break;
        }

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                BeepPnPComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (deviceExtension->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {
            deviceExtension->Started = TRUE;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //

        Irp->IoStatus.Information = 0;
        break;

    case IRP_MN_REMOVE_DEVICE:
        BeepPrint ((2, "Remove Device\n"));

        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choice but to detach and delete the device object.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //

        //
        // We will accept no new requests
        //
        ExAcquireFastMutex(&deviceExtension->Mutex);
        deviceExtension->Started = FALSE;
        ExReleaseFastMutex(&deviceExtension->Mutex);
    
        //
        // Complete any outstanding IRPs queued by the driver here.
        //
    
        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now. 
        // We don't need to check the timer, because that has been done for us
        // in close.
    
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //
        //
        // Fire and forget
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        IoCallDriver (deviceExtension->TopOfStack, Irp);

        //
        // Wait for all outstanding requests to complete
        //
        BeepPrint ((2,"Waiting for outstanding requests\n"));
        IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock,
                                   Irp);
        
        //
        // Free the associated resources
        //

        //
        // Detach from the underlying devices.
        //
        BeepPrint((3, "IoDetachDevice: 0x%x\n", deviceExtension->TopOfStack));
        IoDetachDevice (deviceExtension->TopOfStack);

        //
        // Clean up any resources here
        //
        BeepPrint((3, "IoDeleteDevice: 0x%x\n", DeviceObject));

        IoDeleteDevice(DeviceObject);

        return STATUS_SUCCESS;

    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //
        BeepPrint ((3, "PnP Default Case, minor = 0x%x.\n", irpStack->MinorFunction));

        //
        // Fire and Forget
        //
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Done, do NOT complete the IRP, it will be processed by the lower
        // device object, which will complete the IRP
        //

        status = IoCallDriver (deviceExtension->TopOfStack, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    return status;
}

NTSTATUS
BeepPnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\beep\power.c ===
#include "beep.h"
#include "dbg.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BeepPower)
#endif

VOID
BeepPowerTransitionPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
BeepPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BeepPower)
#endif

NTSTATUS
BeepPower (
    IN PDEVICE_OBJECT   DeviceObject,
    PIRP                Irp
    )
/*++
--*/
{
    PBEEP_EXTENSION     deviceExtension;
    NTSTATUS            status;
    BOOLEAN             hookit = FALSE;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;

    PAGED_CODE ();
    
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        BeepPrint((2,"Setting %s power state to %d\n",
                      ((powerType == SystemPowerState) ?  "System" : "Device"),
                      powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:

            status = Irp->IoStatus.Status = STATUS_SUCCESS;

            if (deviceExtension->DeviceState == powerState.DeviceState) {
                // Do nothing
                break;
            } else if (deviceExtension->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                PoSetPowerState (deviceExtension->Self, powerType, powerState);
                deviceExtension->DeviceState = powerState.DeviceState;
            } else {
                //
                // Powering Up
                //
                hookit = TRUE;
            }
            
            break;

        case SystemPowerState:
            if (deviceExtension->PowerQueryLock) {
                //
                // The reception of a power irp resolves the query lock.
                //
                deviceExtension->PowerQueryLock = FALSE;
            } else {
                ASSERT (deviceExtension->SystemState != powerState.SystemState);
            }

            if (deviceExtension->SystemState == powerState.SystemState) {
                status = STATUS_SUCCESS;

            } else if (deviceExtension->SystemState < powerState.SystemState) {
                //
                // Powering down
                //

                //
                // Request a D3 irp in response to this S irp.  The D3 irp must
                // completed before send this S irp down the stack.  We will send
                // the S irp down the stack when
                // BeepPowerTransitionPoRequestComplete is called.
                //

                //
                // We don't need to increment our IO count b/c we incremented it
                // at the beginning of this function and won't decrement it until
                // the S Irp completes
                // 
                IoMarkIrpPending (Irp);
                powerState.DeviceState = PowerDeviceD3;
                PoRequestPowerIrp (deviceExtension->Self,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   BeepPowerTransitionPoRequestComplete,
                                   Irp,
                                   NULL);  // no IRP
                
                return STATUS_PENDING;

            } else {
                //
                // Powering Up
                //
                
                // 
                // We must request a D irp for this S irp, but only after the S
                // irp has come back up the stack.  Hook the return of the irp
                // and request the D irp in BeepPowerComplete
                //
                hookit = TRUE;
            }
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        //
        deviceExtension->PowerQueryLock = TRUE;
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:
        break;
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    if (hookit) {
        ASSERT (STATUS_SUCCESS == status);
        IoSetCompletionRoutine (Irp,
                                BeepPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);

        PoCallDriver (deviceExtension->TopOfStack, Irp);
        return STATUS_PENDING;
    } else {
        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power
        // irp.  This can be called here, or in the completetion
        // routine, but never the less must be called.
        //
        PoStartNextPowerIrp (Irp);

        status =  PoCallDriver (deviceExtension->TopOfStack, Irp);
        
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    }

    return status;
}

VOID
BeepPowerTransitionPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  stack;
    PBEEP_EXTENSION deviceExtension;

    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (IoStatus);

    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (SystemStateIrp);

    if (DevicePowerState.DeviceState == PowerDeviceD0) {
        //
        // We are powering up (the D0 Irp just completed).  Since we sent the
        // S irp down the stack and requested the D irp on the way back up the
        // stack, just complete the S irp now
        //

        PoSetPowerState (DeviceObject,
                         stack->Parameters.Power.Type,
                         stack->Parameters.Power.State);
    
        deviceExtension->SystemState = stack->Parameters.Power.State.SystemState;

        //
        // Set the S irp's status to the status of the D irp.
        //
        SystemStateIrp->IoStatus.Status = IoStatus->Status;

        PoStartNextPowerIrp (SystemStateIrp);
        IoCompleteRequest (SystemStateIrp, IO_NO_INCREMENT);

        //
        // From BeepPower when we originally received the IRP
        //
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, SystemStateIrp);
    }
    else {
        //
        // We are powering down (the D3 Irp just completed).  Since we requested
        // the D irp before sending the S irp down the stack, we must send it 
        // down now.  We will catch the S irp on the way back up to record the 
        // S state
        //
        ASSERT (DevicePowerState.DeviceState == PowerDeviceD3);
    
        IoCopyCurrentIrpStackLocationToNext (SystemStateIrp);

        IoSetCompletionRoutine (SystemStateIrp,
                                BeepPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);
    
        PoCallDriver (deviceExtension->TopOfStack, SystemStateIrp);
    }
}

NTSTATUS
BeepPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PBEEP_EXTENSION     deviceExtension;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (Context);

    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;
    status = STATUS_SUCCESS; 

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:

            //
            // Power up complete
            //
            ASSERT (powerState.DeviceState < deviceExtension->DeviceState);
            deviceExtension->DeviceState = powerState.DeviceState;
            PoSetPowerState (deviceExtension->Self, powerType, powerState);
            break;

        case SystemPowerState:
            if (powerState.SystemState > deviceExtension->SystemState) {
                //
                // Powering Down...
                //
                // We are on the completion end of an S irp.  (The D3 power irp
                // has already been sent and completed down this stack.)  The
                // remaining thing to do is set the state in the extension, then
                // decrement the IoCount that was incremented when we first got
                // the irp (this is done at the end of this function).
                //
                deviceExtension->SystemState = powerState.SystemState;

                PoSetPowerState (deviceExtension->Self,
                                 stack->Parameters.Power.Type,
                                 stack->Parameters.Power.State);
            }
            else {
                //
                // Powering Up...
                //
                // Request a D power irp for ourself.  Do not complete this S irp
                // until the D irp has been completed.  (Completion of the S irp
                // is done in BeepPowerTransitionPoRequestComplete). 
                // Decrementing the IO count will happen in the same function.
                //
                ASSERT (powerState.SystemState < deviceExtension->SystemState);
    
                powerState.DeviceState = PowerDeviceD0;
                PoRequestPowerIrp (deviceExtension->Self,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   BeepPowerTransitionPoRequestComplete,
                                   Irp, 
                                   NULL); // no return Irp
    
                //
                // Inform the IO subsystem not to touch the irp here 
                //
                // The irp might completed by the time we get here, so call
                // PoStartNextPowerIrp in the PO irp completion function.
                //
                status = STATUS_MORE_PROCESSING_REQUIRED; 
            }
            break;
        }
        break;

    default:
        #define BEEP_UNHANDLED_MN_POWER 0x0
        ASSERT (0xBADBAD == BEEP_UNHANDLED_MN_POWER);
        #undef BEEP_UNHANDLED_MN_POWER 
        
        status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (NT_SUCCESS(status)) {
        PoStartNextPowerIrp (Irp);
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\beep\testbeep.c ===
#include "ntos.h"
#include <ntddbeep.h>

#define CANCEL


BOOLEAN test1();

int
main(
    int argc,
    char *argv[]
    )
{
    UCHAR error = FALSE;

    DbgPrint( "Test1...\n" );
    if (!test1()) {
        DbgPrint("Error:  Test 1 failed\n");
        error = TRUE;
    }
    return error;
}


VOID
BeepApc(
    PVOID BeepApcContext,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    );


BOOLEAN
test1()
{
    HANDLE FileHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatus;
    BEEP_SET_PARAMETERS BeepParameters;
#ifdef CANCEL
    IO_STATUS_BLOCK CancelStatus;
    TIME Interval;
#endif

    //
    // Open the beep device in synchronous mode.
    //

    DbgPrint( "test 1: opening beep\n");

    RtlInitString( &NameString, "\\Device\\Beep" );
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &NameString, TRUE );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - RtlAnsiStringToUnicodeString\n",Status);
        return FALSE;
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                  &UnicodeString,
                                  0,
                                  NULL,
                                  NULL
                                );
    Status = NtCreateFile( &FileHandle,
                           FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
                           &ObjectAttributes,
                           &IoStatus,
                           (PLARGE_INTEGER) NULL,
                           0L,
                           0L,
                           FILE_OPEN_IF,
                           FILE_SYNCHRONOUS_IO_ALERT,
                           (PVOID) NULL,
                           0L );

    RtlFreeUnicodeString( &UnicodeString );

    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - beep open \n",Status);
        return FALSE;
    }

    if (IoStatus.Status != STATUS_SUCCESS) {
        DbgPrint( "test 2: Wrong I/O Status value %X - beep open \n",IoStatus.Status);
        return FALSE;
    }

    if (IoStatus.Information != 0L) {
        DbgPrint( "test 1: Wrong I/O Status information value %ld - beep open \n",IoStatus.Information);
        return FALSE;
    }
    DbgPrint( "test 1: opened beep device successfully\n");

    //
    // Beep at different frequencies.
    //

    DbgPrint( "test 1: calling beep device with varying frequencies\n");

    BeepParameters.Duration = 1000;
    for (BeepParameters.Frequency = 18; BeepParameters.Frequency <= 10000;
             BeepParameters.Frequency += 100) {

        DbgPrint( "test 1: Set beep frequency %ld\n", BeepParameters.Frequency);
        Status = NtDeviceIoControlFile(FileHandle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   (PVOID) NULL,
                                   &IoStatus,
                                   IOCTL_BEEP_SET,
                                   &BeepParameters,    // input buffer
                                   sizeof(BeepParameters),
                                   NULL, // output buffer
                                   0
                                  );

        if (Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong return value %lX - beep set\n",Status);
        } else if (IoStatus.Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong I/O Status value %lX - beep set\n",IoStatus.Status);
        }

        if (IoStatus.Information != 0) {
            DbgPrint( "test 1: Wrong I/O Status information value %ld - beep set\n",IoStatus.Information);
        }

        if (BeepParameters.Duration)
            Interval.LowTime = -(BeepParameters.Duration*1000*10);
        else
            Interval.LowTime = -(10*1000*10);
        Interval.HighTime = -1;
        NtDelayExecution(FALSE, &Interval);

    } // end for
    DbgPrint("\n");

    DbgPrint( "test 1: calling beep device with varying durations\n");

    BeepParameters.Frequency = 600;
    for (BeepParameters.Duration = 0; BeepParameters.Duration <= 4000;
             BeepParameters.Duration += 100) {

        DbgPrint( "test 1: Set beep duration %ld\n", BeepParameters.Duration);
        Status = NtDeviceIoControlFile(FileHandle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   (PVOID) NULL,
                                   &IoStatus,
                                   IOCTL_BEEP_SET,
                                   &BeepParameters,    // input buffer
                                   sizeof(BeepParameters),
                                   NULL, // output buffer
                                   0
                                  );

        if (Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong return value %lX - beep set\n",Status);
        } else if (IoStatus.Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong I/O Status value %lX - beep set\n",IoStatus.Status);
        }

        if (IoStatus.Information != 0) {
            DbgPrint( "test 1: Wrong I/O Status information value %ld - beep set\n",IoStatus.Information);
        }

        if (BeepParameters.Duration)
            Interval.LowTime = -(BeepParameters.Duration*1000*10);
        else
            Interval.LowTime = -(10*1000*10);
        Interval.HighTime = -1;
        NtDelayExecution(FALSE, &Interval);

    } // end for
    DbgPrint("\n");

#ifdef CANCEL

    //
    // Now test cancellation by issuing an asynchronous beep request
    // and then cancelling the request.  Need to reopen the beep
    // device for asynchronous access.
    //

    DbgPrint("----------------- testing cancellation.\n");

    Status = NtClose( FileHandle );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %lX - beep close \n",Status);
        return FALSE;
    }

    RtlInitString( &NameString, "\\Device\\Beep" );
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &NameString, TRUE );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - RtlAnsiStringToUnicodeString\n",Status);
        return FALSE;
    }
    InitializeObjectAttributes( &ObjectAttributes,
                                  &UnicodeString,
                                  0,
                                  NULL,
                                  NULL
                                );

    Status = NtCreateFile( &FileHandle,
                           FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatus,
                           (PLARGE_INTEGER) NULL,
                           0L,
                           0L,
                           FILE_OPEN_IF,
                           0,
                           (PVOID) NULL,
                           0L );

    RtlFreeUnicodeString( &UnicodeString );

    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - beep asynch reopen\n",Status);
        return FALSE;
    }

    DbgPrint( "test 1: successfully reopened beep device for asynch access\n");

    BeepParameters.Frequency = 600;
    BeepParameters.Duration  = 60000;
    Status = NtDeviceIoControlFile(FileHandle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) BeepApc,
                                   (PVOID) NULL,
                                   &IoStatus,
                                   IOCTL_BEEP_SET,
                                   &BeepParameters,    // input buffer
                                   sizeof(BeepParameters),
                                   NULL, // output buffer
                                   0
                                  );

    if (Status != STATUS_PENDING) {
        DbgPrint( "test 1: Wrong return value %lX - beep set asynch\n",Status);
    }

    Status = NtCancelIoFile(FileHandle, &CancelStatus);

    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %lX - beep cancel\n",Status);
        return FALSE;
    }

    if (CancelStatus.Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong I/O Status value %lX - beep cancel \n",CancelStatus.Status);
    }

    DbgPrint("Successfully cancelled a request.\n");

    //
    // Delay in an alertable state, to allow the BeepApc to fire.
    //

    Interval.HighTime = -1;
    Interval.LowTime = -(10*1000*10);
    NtDelayExecution(TRUE, &Interval);

#endif // CANCEL

    //
    // Now close the beep device
    //

    DbgPrint("test 1:  closing beep device\n");

    Status = NtClose( FileHandle );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %lX - beep close \n",Status);
        return FALSE;
    }
    return TRUE;
}

VOID
BeepApc(
    PVOID BeepApcContext,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    )
{

        if (IoStatus->Status != STATUS_CANCELLED) {
            DbgPrint( "test1 APC: Expected CANCELLED, got I/O Status value %lX - beep set\n",IoStatus->Status);
        } else {
            DbgPrint("test1 APC: Request CANCELLED.\n");
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\mountmgr\kdmm\kdmm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdmm.c

Abstract:

    Mount mgr driver KD extension - based on Vert's skeleton

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/


#include "precomp.h"


#if ! defined (PGUID)
typedef GUID    *PGUID;
#endif


#define FORMATTED_GUID  ( "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")
#define FORMATTED_GUIDW (L"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")


#define DeclareStaticAnsiString(_StringName, _StringValue)					\
		static ANSI_STRING (_StringName) = {sizeof (_StringValue) - sizeof (ANSI_NULL),	\
                                                    sizeof (_StringValue),			\
                                                    _StringValue}


#define DeclareStaticUnicodeString(_StringName, _StringValue)						\
		static UNICODE_STRING (_StringName) = {sizeof (_StringValue) - sizeof (UNICODE_NULL),	\
						       sizeof (_StringValue),				\
						       _StringValue}


#define SIZEOF_ARRAY(_aBase)    (sizeof (_aBase) / sizeof ((_aBase)[0]))

#define SIZEOF_STRING(_wstring) (sizeof (_wstring) - sizeof (UNICODE_NULL))



#define	MNTMGR_KD_FLAGS_VERBOSE                         (1 <<  0)
#define MNTMGR_KD_FLAGS_SYMBOLIC_NAMES                  (1 <<  1)
#define MNTMGR_KD_FLAGS_REPLICATED_UNIQUE_IDS           (1 <<  2)
#define MNTMGR_KD_FLAGS_MOUNTPOINTS_POINTING_HERE       (1 <<  3)

#define MNTMGR_KD_FLAGS_LEGAL_FLAGS_LIST        (MNTMGR_KD_FLAGS_VERBOSE               |        \
                                                 MNTMGR_KD_FLAGS_SYMBOLIC_NAMES        |        \
                                                 MNTMGR_KD_FLAGS_REPLICATED_UNIQUE_IDS |        \
                                                 MNTMGR_KD_FLAGS_MOUNTPOINTS_POINTING_HERE)


typedef struct _DisplayOptionsMountedDeviceInformation
    {
    unsigned int ListSymbolicNames           : 1;
    unsigned int ListReplicatedUniqueIds     : 1;
    unsigned int ListMountPointsPointingHere : 1;
    } DisplayOptionsMountedDeviceInformation;

typedef struct _DisplayOptionsStandard
    {
    unsigned int Verbose  : 1;
    unsigned int Padding  :15;
    } DisplayOptionsStandard;
    


typedef struct _DisplayOptions
    {
    unsigned int Verbose  : 1;
    unsigned int Padding  :15;

    union
        {
        struct 
            {
            unsigned int ListSymbolicNames           : 1;
            unsigned int ListReplicatedUniqueIds     : 1;
            unsigned int ListMountPointsPointingHere : 1;
            };

//        DisplayOptionsMountedDeviceInformation  MountedDeviceInfo;
        };
    } DISPLAY_OPTIONS;






DeclareStaticAnsiString (CommandMounted, "mounted");
DeclareStaticAnsiString (CommandDead,    "dead");
DeclareStaticAnsiString (CommandNotify,  "notify");
DeclareStaticAnsiString (CommandLinks,   "links");
DeclareStaticAnsiString (CommandSpare,   "spare");







ULONG64 GetPointerValue       (PCHAR   String);
ULONG64 GetPointerFromAddress (ULONG64 Location);
ULONG   GetUlongValue         (PCHAR   String);
ULONG   GetUlongFromAddress   (ULONG64 Location);


BOOLEAN GetFieldValueBoolean  (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);
UCHAR   GetFieldValueUchar    (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);
ULONG   GetFieldValueUlong32  (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);
ULONG64 GetFieldValueUlong64  (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);

ULONG FormatDateAndTime       (ULONG64 ul64Time,  PCHAR pszFormattedDateAndTime, ULONG ulBufferLength);
ULONG FormatGUID              (GUID    guidValue, PCHAR pszFormattedGUID,        ULONG ulBufferLength);
ULONG FormatBytesAsGUID       (PBYTE ByteArray,   PWCHAR OutputBuffer);


ULONG ReadUnicodeString       (ULONG64 Location, PUNICODE_STRING pString,       BOOLEAN AllocateBuffer);
ULONG ReadMountdevUniqueId    (ULONG64 Location, PUNICODE_STRING pTargetString, BOOLEAN AllocateBuffer, DISPLAY_OPTIONS DisplayOptions, BOOLEAN IsRemovable);

VOID ListMountedDevices       (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions);
VOID ListDeadMountedDevices   (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions);
VOID ListChangenotifyIrps     (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions);
VOID ListSavedLinks           (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions);


ULONG DisplayMountedDeviceInformation (ULONG64 MountedDeviceInformation, DISPLAY_OPTIONS DisplayOptions);
ULONG DisplaySavedLinksInformation    (ULONG64 SavedLinksInformation,    DISPLAY_OPTIONS DisplayOptions);



//
// globals
//

EXT_API_VERSION         ApiVersion = {(VER_PRODUCTVERSION_W >> 8), 
				      (VER_PRODUCTVERSION_W & 0xff), 
				      EXT_API_VERSION_NUMBER64, 
				      0};
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;





DllInit (HANDLE hModule,
	 DWORD  dwReason,
	 DWORD  dwReserved)
    {
    switch (dwReason) 
	{
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
	}

    return TRUE;
    }




VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID CheckVersion (VOID)
    {
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) 
	{
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, 
		SavedMinorVersion, 
		(SavedMajorVersion == 0x0f) ? "Free" : "Checked" );
	}
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) 
	{
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, 
		SavedMinorVersion, 
		(SavedMajorVersion==0x0f) ? "Free" : "Checked" );
	}
#endif
    }



LPEXT_API_VERSION ExtensionApiVersion (VOID)
    {
    return &ApiVersion;
    }






DECLARE_API( dumpdb )
/*
 *   dump the mount mgr database
 */
{
    PDEVICE_EXTENSION		TargetExt;
    DEVICE_EXTENSION		LocalExt;
    PMOUNTED_DEVICE_INFORMATION	TargetDevInfo;
    PMOUNTED_DEVICE_INFORMATION	LastDevInfo;
    MOUNTED_DEVICE_INFORMATION	LocalDevInfo;
    MOUNTDEV_UNIQUE_ID		LocalUniqueId;
    PSYMBOLIC_LINK_NAME_ENTRY	TargetSymLink;
    PSYMBOLIC_LINK_NAME_ENTRY	LastSymLink;
    SYMBOLIC_LINK_NAME_ENTRY	LocalSymLink;
    WCHAR			NameBuffer[512];
    UCHAR			UniqueIdBuffer[512];
    PUCHAR			pUniqueId;

    //
    // convert address of extension in target machine
    //

    TargetExt = (PDEVICE_EXTENSION) GetExpression( args );

    if ( !TargetExt ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

#if 0
    //
    // read in extension from target machine
    //

    if ( !ReadTargetMemory((PVOID)TargetExt,
                           (PVOID)&LocalExt,
                           sizeof(DEVICE_EXTENSION))) {
        return;
    }

    TargetDevInfo = (PMOUNTED_DEVICE_INFORMATION)LocalExt.MountedDeviceList.Flink;
    LastDevInfo = (PMOUNTED_DEVICE_INFORMATION)&TargetExt->MountedDeviceList.Flink;

    while ( TargetDevInfo != LastDevInfo ) {

        if (CheckControlC()) {
            return;
        }

        if ( !ReadTargetMemory(TargetDevInfo,
                               &LocalDevInfo,
                               sizeof( MOUNTED_DEVICE_INFORMATION )))
        {
            dprintf("Problem reading mounted device info at %08X\n", TargetDevInfo );
            return;
        }

        dprintf( "Mounted Device Info @ %08X\n", TargetDevInfo );

        if ( ReadTargetMemory((PVOID)LocalDevInfo.NotificationName.Buffer,
                              (PVOID)&NameBuffer,
                              LocalDevInfo.NotificationName.Length)) {

            dprintf( "    NotificationName: %.*ws\n",
                     LocalDevInfo.NotificationName.Length/sizeof(WCHAR),
                     NameBuffer);
        } else {
            dprintf( "    NotificationName @ %08X\n", LocalDevInfo.NotificationName.Buffer );
        }

        if ( ReadTargetMemory((PVOID)LocalDevInfo.UniqueId,
                              (PVOID)&LocalUniqueId,
                              sizeof(LocalUniqueId))) {

            dprintf( "    Unique ID Length = %u bytes\n    UniqueId",
                     LocalUniqueId.UniqueIdLength);

            if ( ReadTargetMemory((PVOID)LocalDevInfo.UniqueId->UniqueId,
                                  (PVOID)UniqueIdBuffer,
                                  LocalUniqueId.UniqueIdLength)) {
                dprintf(": ");
                pUniqueId = UniqueIdBuffer;
                while ( LocalUniqueId.UniqueIdLength-- )
                    dprintf( "%02X ", *pUniqueId++ );
            } else {
                dprintf( " @ %08X", LocalDevInfo.UniqueId->UniqueId );
            }
            dprintf( "\n" );

        } else {
            dprintf( "    UniqueId @ %08X\n", LocalDevInfo.UniqueId );
        }

        if ( ReadTargetMemory((PVOID)LocalDevInfo.DeviceName.Buffer,
                              (PVOID)&NameBuffer,
                              LocalDevInfo.DeviceName.Length)) {

            dprintf( "    DeviceName: %.*ws\n",
                     LocalDevInfo.DeviceName.Length/sizeof(WCHAR),
                     NameBuffer);
        } else {
            dprintf( "    DeviceName @ %08X\n", LocalDevInfo.DeviceName.Buffer );
        }

        TargetSymLink = (PSYMBOLIC_LINK_NAME_ENTRY)LocalDevInfo.SymbolicLinkNames.Flink;
        LastSymLink = (PSYMBOLIC_LINK_NAME_ENTRY)&TargetDevInfo->SymbolicLinkNames.Flink;

        while ( TargetSymLink != LastSymLink ) {

            if (CheckControlC()) {
                return;
            }

            if ( !ReadTargetMemory(TargetSymLink,
                                   &LocalSymLink,
                                   sizeof( SYMBOLIC_LINK_NAME_ENTRY )))
            {
                dprintf("Problem reading symlink entry at %08X\n", TargetSymLink );
                return;
            }

            if ( ReadTargetMemory((PVOID)LocalSymLink.SymbolicLinkName.Buffer,
                                  (PVOID)&NameBuffer,
                                  LocalSymLink.SymbolicLinkName.Length)) {

                dprintf( "        SymbolicLinkName: %.*ws\n",
                         LocalSymLink.SymbolicLinkName.Length/sizeof(WCHAR),
                         NameBuffer);
            } else {
                dprintf( "        SymbolicLinkName @ %08X\n", LocalSymLink.SymbolicLinkName.Buffer );
            }

            dprintf( "        IsInDatabase = %s\n", LocalSymLink.IsInDatabase ? "TRUE" : "FALSE" );

            TargetSymLink = (PSYMBOLIC_LINK_NAME_ENTRY)LocalSymLink.ListEntry.Flink;
        }

        TargetDevInfo = (PMOUNTED_DEVICE_INFORMATION)LocalDevInfo.ListEntry.Flink;
    }

#endif
}




DECLARE_API( help )
    {
    dprintf ("\nMount Point Manager (MountMgr) Debug Extensions\n\n");
    dprintf ("valque <queue-head> [flags] - counts the number of entries in the queue\n");
    dprintf ("                         1    dumps address of each element in the queue\n");
    dprintf ("\n");
    dprintf ("summary             [flags] - dumps a basic summary of stuff\n");
    dprintf ("list\n");
    dprintf ("list mounted\n");
    dprintf ("list dead\n");
    dprintf ("list links\n");
    dprintf ("list notify\n");
    dprintf ("search <volumename substring>\n");
    dprintf ("format\n");
    dprintf ("format mounted\n");
    dprintf ("format dead\n");
    dprintf ("format notify\n");
    dprintf ("format link\n");
    dprintf ("dumpdb <mntmgr dev extension addr>- dump the mount mgr database\n");
    dprintf ( "      use !devobj mountpointmanager to get dev extension addr\n");
    }



DECLARE_API (summary)
    {
    ULONG64             DeviceObject;
    ULONG64             DeviceExtension;
    ULONG       	result;
    ULONG               FieldOffsetRegistryPath;
    UNICODE_STRING      RegistryPath;
    WCHAR               RegistryPathBuffer [MAX_PATH];


    RegistryPath.Length        = 0;
    RegistryPath.MaximumLength = sizeof (RegistryPathBuffer);
    RegistryPath.Buffer        = RegistryPathBuffer;


    DeviceObject    = GetPointerValue ("MountMgr!gDeviceObject");
    DeviceExtension = GetFieldValueUlong64 (DeviceObject, "DEVICE_OBJECT", "DeviceExtension");

    result = GetFieldOffset ("MountMgr!_DEVICE_EXTENSION", "RegistryPath", &FieldOffsetRegistryPath);

    ReadUnicodeString (DeviceExtension + FieldOffsetRegistryPath, &RegistryPath, FALSE);




    dprintf ("DriverObject:                   0x%016I64x\n", GetFieldValueUlong64 (DeviceExtension, "MountMgr!_DEVICE_EXTENSION", "DriverObject"));
    dprintf ("DeviceObject:                   0x%016I64x\n", DeviceObject);
    dprintf ("DeviceExtension:                0x%016I64x\n", DeviceExtension);

    dprintf ("AutomaticDriveLetterAssignment: %u\n", GetFieldValueUlong64 (DeviceExtension, "MountMgr!_DEVICE_EXTENSION", "AutomaticDriveLetterAssignment"));
    dprintf ("EpicNumber:                     %u\n", GetFieldValueUlong64 (DeviceExtension, "MountMgr!_DEVICE_EXTENSION", "EpicNumber"));
    dprintf ("SuggestedDriveLettersProcessed: %u\n", GetFieldValueUlong64 (DeviceExtension, "MountMgr!_DEVICE_EXTENSION", "SuggestedDriveLettersProcessed"));
    dprintf ("NoAutoMount:                    %u\n", GetFieldValueUlong64 (DeviceExtension, "MountMgr!_DEVICE_EXTENSION", "NoAutoMount"));


//    dprintf (": %u\n", GetFieldValueUlong64 (DeviceExtension, "MountMgr!_DEVICE_EXTENSION", ""));

    dprintf ("RegistryPath:                    %ws\n", RegistryPath.Buffer);

    return;
    }






DECLARE_API (list)
    {
    UCHAR               CommandBuffer [64];
    ULONG               Flags      = 0;
    const ULONG         LegalFlags = MNTMGR_KD_FLAGS_LEGAL_FLAGS_LIST;
    ANSI_STRING         CommandString;
    ULONG64     	DeviceObject;
    ULONG64             DeviceExtension;
    DISPLAY_OPTIONS     DisplayOptions = {0};


    DeviceObject    = GetPointerValue ("MountMgr!gDeviceObject");
    DeviceExtension = GetFieldValueUlong64 (DeviceObject, "DEVICE_OBJECT", "DeviceExtension");


    _snscanf (args, sizeof (CommandBuffer), "%s %d", CommandBuffer, &Flags);


    if ((0 != Flags) && ((Flags & LegalFlags) == 0))
	{
	dprintf("Illegal flags specified\n");
	}

    else if ('\0' == CommandBuffer [0]) 
	{
	dprintf ("Illegal command specified\n");
	}

    else
	{
	RtlInitAnsiString (&CommandString, (PCSZ) CommandBuffer);

        memset (&DisplayOptions, 0x00, sizeof (DisplayOptions));

        DisplayOptions.Verbose                     = (Flags & MNTMGR_KD_FLAGS_VERBOSE)                   ? TRUE : FALSE;
        DisplayOptions.ListSymbolicNames           = (Flags & MNTMGR_KD_FLAGS_SYMBOLIC_NAMES)            ? TRUE : FALSE;
        DisplayOptions.ListReplicatedUniqueIds     = (Flags & MNTMGR_KD_FLAGS_REPLICATED_UNIQUE_IDS)     ? TRUE : FALSE;
        DisplayOptions.ListMountPointsPointingHere = (Flags & MNTMGR_KD_FLAGS_MOUNTPOINTS_POINTING_HERE) ? TRUE : FALSE;


	if      (RtlEqualString (&CommandMounted, &CommandString, TRUE)) ListMountedDevices     (DeviceExtension, DisplayOptions);
	else if (RtlEqualString (&CommandDead,    &CommandString, TRUE)) ListDeadMountedDevices (DeviceExtension, DisplayOptions);
	else if (RtlEqualString (&CommandNotify,  &CommandString, TRUE)) ListChangenotifyIrps   (DeviceExtension, DisplayOptions); 
	else if (RtlEqualString (&CommandLinks,   &CommandString, TRUE)) ListSavedLinks         (DeviceExtension, DisplayOptions);
	else
	    {
	    dprintf ("Illegal command specified\n");
	    }
        }

    return;
    }


VOID ListMountedDevices (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions)
    {
    ULONG               result;
    LIST_ENTRY64	ListEntry;
    ULONG		FieldOffsetMountedDeviceList;
    ULONG64		MountedDevicesQueueHead;
    ULONG64		MountedDeviceInformation;



    result = GetFieldOffset ("MountMgr!_DEVICE_EXTENSION", "MountedDeviceList", &FieldOffsetMountedDeviceList);


    MountedDevicesQueueHead = DeviceExtension + FieldOffsetMountedDeviceList;


    result = ReadListEntry (MountedDevicesQueueHead, &ListEntry);


    if (ListEntry.Flink == MountedDevicesQueueHead)
	{
	dprintf ("MountedDeviceList is empty (List head @ 0x%016I64x\n", MountedDevicesQueueHead);
	}

    else
	{
	while (!CheckControlC() && (ListEntry.Flink != MountedDevicesQueueHead))
	    {
	    MountedDeviceInformation = ListEntry.Flink;

            DisplayMountedDeviceInformation (MountedDeviceInformation, DisplayOptions);


	    result = ReadListEntry (ListEntry.Flink, &ListEntry);
	    }
	}


    return;
    }



VOID ListDeadMountedDevices (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions)
    {
    ULONG               result;
    LIST_ENTRY64	ListEntry;
    ULONG		FieldOffsetDeadMountedDeviceList;
    ULONG64		DeadMountedDevicesQueueHead;
    ULONG64		MountedDeviceInformation;


    result = GetFieldOffset ("MountMgr!_DEVICE_EXTENSION", "DeadMountedDeviceList", &FieldOffsetDeadMountedDeviceList);


    DeadMountedDevicesQueueHead = DeviceExtension + FieldOffsetDeadMountedDeviceList;


    result = ReadListEntry (DeadMountedDevicesQueueHead, &ListEntry);


    if (ListEntry.Flink == DeadMountedDevicesQueueHead)
	{
	dprintf ("DeadMountedDeviceList is empty (List head @ 0x%016I64x\n", DeadMountedDevicesQueueHead);
	}

    else
	{
	while (!CheckControlC() && (ListEntry.Flink != DeadMountedDevicesQueueHead))
	    {
	    MountedDeviceInformation = ListEntry.Flink;

            DisplayMountedDeviceInformation (MountedDeviceInformation, DisplayOptions);


	    result = ReadListEntry (ListEntry.Flink, &ListEntry);
	    }
	}

    return;
    }



VOID ListChangenotifyIrps (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions)
    {
    ULONG               result;
    LIST_ENTRY64	ListEntry;
    ULONG		FieldOffsetChangeNotifyIrplList;
    ULONG               FieldOffsetIrpTailOverlayListEntry;
    ULONG64		ChangeNotifyIrpsQueueHead;
    ULONG64		MountedDeviceInformation;
    ULONG64             Irp;


    GetFieldOffset ("MountMgr!_DEVICE_EXTENSION", "ChangeNotifyIrps",       &FieldOffsetChangeNotifyIrplList);
    GetFieldOffset ("IRP",                        "Tail.Overlay.ListEntry", &FieldOffsetIrpTailOverlayListEntry);


    ChangeNotifyIrpsQueueHead = DeviceExtension + FieldOffsetChangeNotifyIrplList;


    result = ReadListEntry (ChangeNotifyIrpsQueueHead, &ListEntry);


    if (ListEntry.Flink == ChangeNotifyIrpsQueueHead)
	{
	dprintf ("ChangeNotifyIrpsList is empty (List head @ 0x%016I64x\n", ChangeNotifyIrpsQueueHead);
	}

    else
	{
        dprintf ("Change Notify Irps Queue\n");

	while (!CheckControlC() && (ListEntry.Flink != ChangeNotifyIrpsQueueHead))
	    {
            Irp = ListEntry.Flink - FieldOffsetIrpTailOverlayListEntry;

            dprintf ("    0x%016I64x\n", Irp);

	    result = ReadListEntry (ListEntry.Flink, &ListEntry);
	    }

        dprintf ("\n");
	}

    return;
    }



VOID ListSavedLinks (ULONG64 DeviceExtension, DISPLAY_OPTIONS DisplayOptions)
    {
    ULONG               result;
    LIST_ENTRY64	ListEntry;
    ULONG		FieldOffsetSavedLinksList;
    ULONG64		SavedLinksQueueHead;
    ULONG64		SavedLinksInformation;


    result = GetFieldOffset ("MountMgr!_DEVICE_EXTENSION", "SavedLinksList", &FieldOffsetSavedLinksList);


    SavedLinksQueueHead = DeviceExtension + FieldOffsetSavedLinksList;


    result = ReadListEntry (SavedLinksQueueHead, &ListEntry);


    if (ListEntry.Flink == SavedLinksQueueHead)
	{
	dprintf ("SavedLinksList is empty (List head @ 0x%016I64x\n", SavedLinksQueueHead);
	}

    else
	{
	while (!CheckControlC() && (ListEntry.Flink != SavedLinksQueueHead))
	    {
	    SavedLinksInformation = ListEntry.Flink;

            DisplaySavedLinksInformation (SavedLinksInformation, DisplayOptions);


	    result = ReadListEntry (ListEntry.Flink, &ListEntry);
	    }
	}

    return;
    }


ULONG DisplaySavedLinksInformation (ULONG64 SavedLinksInformation, DISPLAY_OPTIONS DisplayOptions)
    {
    ULONG               result;
    ULONG               FieldOffsetMountdevUniqueId;
    ULONG		FieldOffsetSymbolicLinkNamesList;
    ULONG               FieldOffsetSymbolicLinkName;
    UNICODE_STRING      MountdevUniqueId;
    UNICODE_STRING      SymbolicLinkName;
    LIST_ENTRY64	ListEntry;
    ULONG64		SymbolicLinkNamesQueueHead;
    ULONG64             SymbolicLinkNameEntry;
    ULONG64             MountdevUniqueIdLocation;


    MountdevUniqueId.Length        = 0;
    MountdevUniqueId.MaximumLength = 0;
    MountdevUniqueId.Buffer        = NULL;

    SymbolicLinkName.Length        = 0;
    SymbolicLinkName.MaximumLength = 0;
    SymbolicLinkName.Buffer        = NULL;

    result = GetFieldOffset ("MountMgr!_SAVED_LINKS_INFORMATION",  "UniqueId",          &FieldOffsetMountdevUniqueId);
    result = GetFieldOffset ("MountMgr!_SAVED_LINKS_INFORMATION",  "SymbolicLinknames", &FieldOffsetSymbolicLinkNamesList);
    result = GetFieldOffset ("MountMgr!_SYMBOLIC_LINK_NAME_ENTRY", "SymbolicLinkName",  &FieldOffsetSymbolicLinkName);

    SymbolicLinkNamesQueueHead = SavedLinksInformation + FieldOffsetSymbolicLinkNamesList;



    MountdevUniqueIdLocation = GetPointerFromAddress (SavedLinksInformation + FieldOffsetMountdevUniqueId);

    ReadMountdevUniqueId (MountdevUniqueIdLocation, &MountdevUniqueId, TRUE, DisplayOptions, FALSE);

    dprintf ("  Link Information  (0x%016I64x) %ws\n", SavedLinksInformation, MountdevUniqueId.Buffer);


    result = ReadListEntry (SymbolicLinkNamesQueueHead, &ListEntry);


    if (ListEntry.Flink == SymbolicLinkNamesQueueHead)
	{
	dprintf ("SymbolicLinkNamesList is empty (List head @ 0x%016I64x\n", SymbolicLinkNamesQueueHead);
	}

    else
	{
	while (!CheckControlC() && (ListEntry.Flink != SymbolicLinkNamesQueueHead))
	    {
	    SymbolicLinkNameEntry = ListEntry.Flink;
            

            ReadUnicodeString (SymbolicLinkNameEntry + FieldOffsetSymbolicLinkName, &SymbolicLinkName, TRUE);

            dprintf ("    Link Name  %ws\n", SymbolicLinkName.Buffer);
            dprintf ("    InDatabase %d\n",  GetFieldValueBoolean (SymbolicLinkNameEntry, 
                                                                   "MountMgr!_SYMBOLIC_LINK_NAME_ENTRY",
                                                                   "IsInDatabase"));


	    result = ReadListEntry (ListEntry.Flink, &ListEntry);
	    }
	}







    if (NULL != MountdevUniqueId.Buffer)
        {
        LocalFree (MountdevUniqueId.Buffer);
        MountdevUniqueId.Buffer = NULL;
        }


    if (NULL != SymbolicLinkName.Buffer)
        {
        LocalFree (SymbolicLinkName.Buffer);
        SymbolicLinkName.Buffer = NULL;
        }


    return (result);
    }


ULONG DisplayMountedDeviceInformation (ULONG64 MountedDeviceInformation, DISPLAY_OPTIONS DisplayOptions)
    {
    ULONG64             MountedDeviceUniqueIdLocation;
    ULONG               result;
    ULONG		FieldOffsetDeviceName;
    ULONG		FieldOffsetNotificationName;
    ULONG               FieldOffsetMountdevUniqueId;
    ULONG               FieldOffsetSymbolicLinkNamesList;
    ULONG               FieldOffsetReplicatedUniqueIdsList;
    ULONG               FieldOffsetMountPointsPointingHereList;
    ULONG               FieldOffsetMountPath;
    ULONG               FieldOffsetSymbolicLinkName;
    ULONG               FieldOffsetReplicatedMountdevUniqueId;
    ULONG               FieldOffsetDeviceInfo;

    ULONG64             SymbolicLinkNamesQueueHead;
    ULONG64             SymbolicLinkNameEntry;
    ULONG64             ReplicatedUniqueIdsQueueHead;
    ULONG64             ReplicatedUniqueIdsEntry;
    ULONG64             MountPointsPointingHereQueueHead;
    ULONG64             MountPointsPointingHereEntry;
    LIST_ENTRY64        ListEntry;
    UNICODE_STRING      DeviceName;
    UNICODE_STRING	NotificationName;
    UNICODE_STRING	SymbolicLinkName;
    UNICODE_STRING      MountPath;
    UNICODE_STRING      MountdevUniqueId;
    WCHAR               DeviceNameBuffer       [512];
    WCHAR		NotificationNameBuffer [512];
    WCHAR		SymbolicLinkNameBuffer [512];
    WCHAR		MountPathBuffer        [512];
    BOOLEAN             FlagsIsRemovable;



    DeviceName.Length              = 0;
    DeviceName.MaximumLength       = sizeof (DeviceNameBuffer);
    DeviceName.Buffer              = DeviceNameBuffer;

    NotificationName.Length        = 0;
    NotificationName.MaximumLength = sizeof (NotificationNameBuffer);
    NotificationName.Buffer        = NotificationNameBuffer;

    SymbolicLinkName.Length        = 0;
    SymbolicLinkName.MaximumLength = sizeof (SymbolicLinkNameBuffer);
    SymbolicLinkName.Buffer        = SymbolicLinkNameBuffer;

    MountPath.Length               = 0;
    MountPath.MaximumLength        = sizeof (MountPathBuffer);
    MountPath.Buffer               = MountPathBuffer;

    MountdevUniqueId.Length        = 0;
    MountdevUniqueId.MaximumLength = 0;
    MountdevUniqueId.Buffer        = NULL;




    result = GetFieldOffset ("MountMgr!_MOUNTED_DEVICE_INFORMATION", "DeviceName",              &FieldOffsetDeviceName);
    result = GetFieldOffset ("MountMgr!_MOUNTED_DEVICE_INFORMATION", "NotificationName",        &FieldOffsetNotificationName);
    result = GetFieldOffset ("MountMgr!_MOUNTED_DEVICE_INFORMATION", "UniqueId",                &FieldOffsetMountdevUniqueId);
    result = GetFieldOffset ("MountMgr!_MOUNTED_DEVICE_INFORMATION", "SymbolicLinkNames",       &FieldOffsetSymbolicLinkNamesList);
    result = GetFieldOffset ("MountMgr!_MOUNTED_DEVICE_INFORMATION", "ReplicatedUniqueIds",     &FieldOffsetReplicatedUniqueIdsList);
    result = GetFieldOffset ("MountMgr!_MOUNTED_DEVICE_INFORMATION", "MountPointsPointingHere", &FieldOffsetMountPointsPointingHereList);
    
    result = GetFieldOffset ("MountMgr!_SYMBOLIC_LINK_NAME_ENTRY",   "SymbolicLinkName",        &FieldOffsetSymbolicLinkName);

    result = GetFieldOffset ("MountMgr!_REPLICATED_UNIQUE_ID",       "UniqueId",                &FieldOffsetReplicatedMountdevUniqueId);

    result = GetFieldOffset ("MountMgr!_MOUNTMGR_MOUNT_POINT_ENTRY", "DeviceInfo",              &FieldOffsetDeviceInfo);
    result = GetFieldOffset ("MountMgr!_MOUNTMGR_MOUNT_POINT_ENTRY", "MountPath",               &FieldOffsetMountPath);
    


    MountedDeviceUniqueIdLocation = GetPointerFromAddress (MountedDeviceInformation + FieldOffsetMountdevUniqueId);


    FlagsIsRemovable = GetFieldValueBoolean (MountedDeviceInformation, 
                                             "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                             "IsRemovable");


    ReadUnicodeString    (MountedDeviceInformation + FieldOffsetDeviceName,       &DeviceName,       FALSE);
    ReadUnicodeString    (MountedDeviceInformation + FieldOffsetNotificationName, &NotificationName, FALSE);

    ReadMountdevUniqueId (MountedDeviceUniqueIdLocation,
                          &MountdevUniqueId, 
                          TRUE,
                          DisplayOptions,
                          FlagsIsRemovable);



    dprintf ("  DevInfo (0x%016I64x) %ws\n", MountedDeviceInformation, DeviceName.Buffer);
    dprintf ("      Unique Id                %ws\n", MountdevUniqueId.Buffer);


    if (DisplayOptions.Verbose)
        {
        UCHAR   SuggestedDriveLetter = GetFieldValueUchar (MountedDeviceInformation, 
                                                           "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                           "SuggestDriveLetter");


        dprintf ("      Extension                     0x%016I64x\n", GetFieldValueUlong64 (MountedDeviceInformation, 
                                                                                           "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                           "Extension"));

        dprintf ("      TargetDeviceNotificationEntry 0x%016I64x\n", GetFieldValueUlong64 (MountedDeviceInformation, 
                                                                                           "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                           "TargetDeviceNotificationEntry"));

        dprintf ("      Notification Name             %ws\n",        NotificationName.Buffer);


        if (isalpha (SuggestedDriveLetter))
            {
            dprintf ("      SuggestedDriveLetter          %u ('%c')\n", SuggestedDriveLetter, SuggestedDriveLetter);
            }

        else
            {
            dprintf ("      SuggestedDriveLetter          %u\n", SuggestedDriveLetter);
            }


        dprintf ("      KeepLinksWhenOffline          %u\n", GetFieldValueBoolean (MountedDeviceInformation, 
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "KeepLinksWhenOffline"));

        dprintf ("      NotAPdo                       %d\n", GetFieldValueBoolean (MountedDeviceInformation, 
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "NotAPdo"));

        dprintf ("      IsRemovable                   %d\n", GetFieldValueBoolean (MountedDeviceInformation, 
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "IsRemovable"));

        dprintf ("      NextDriveLetterCalled         %d\n", GetFieldValueBoolean (MountedDeviceInformation, 
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "NextDriveLetterCalled"));

        dprintf ("      ReconcileOnMounts             %d\n", GetFieldValueBoolean (MountedDeviceInformation, 
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "ReconcileOnMounts"));

        dprintf ("      HasDanglingVolumeMountPoint   %d\n", GetFieldValueBoolean (MountedDeviceInformation, 
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "HasDanglingVolumeMountPoint"));

        dprintf ("      InOfflineList                 %d\n", GetFieldValueBoolean (MountedDeviceInformation,
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "InOfflineList"));

        dprintf ("      RemoteDatabaseMigrated        %d\n", GetFieldValueBoolean (MountedDeviceInformation,
                                                                                   "MountMgr!_MOUNTED_DEVICE_INFORMATION", 
                                                                                   "RemoteDatabaseMigrated"));
        }




    if (DisplayOptions.ListSymbolicNames)
        {
        SymbolicLinkNamesQueueHead = MountedDeviceInformation + FieldOffsetSymbolicLinkNamesList;


        result = ReadListEntry (SymbolicLinkNamesQueueHead, &ListEntry);


        if (ListEntry.Flink == SymbolicLinkNamesQueueHead)
            {
            dprintf ("SymbolicLinkNamesList is empty (List head @ 0x%016I64x\n", SymbolicLinkNamesQueueHead);
            }

        else
            {
            dprintf ("      Link Name(s)\n");


            while (!CheckControlC() && (ListEntry.Flink != SymbolicLinkNamesQueueHead))
                {
                SymbolicLinkNameEntry = ListEntry.Flink;
            

                ReadUnicodeString (SymbolicLinkNameEntry + FieldOffsetSymbolicLinkName, &SymbolicLinkName, FALSE);

                dprintf ("                %s  %ws\n", 
                         GetFieldValueBoolean (SymbolicLinkNameEntry, 
                                               "MountMgr!_SYMBOLIC_LINK_NAME_ENTRY",
                                               "IsInDatabase")
                                ? "(In Database)"
                                : "             ",
                         SymbolicLinkName.Buffer);

                result = ReadListEntry (ListEntry.Flink, &ListEntry);
                }
	    }
	}




    if (DisplayOptions.ListReplicatedUniqueIds)
        {
        ReplicatedUniqueIdsQueueHead = MountedDeviceInformation + FieldOffsetReplicatedUniqueIdsList;


        result = ReadListEntry (ReplicatedUniqueIdsQueueHead, &ListEntry);


        if (ListEntry.Flink == ReplicatedUniqueIdsQueueHead)
            {
            dprintf ("ReplicatedUniqueIdsList is empty (List head @ 0x%016I64x\n", ReplicatedUniqueIdsQueueHead);
            }

        else
            {
            while (!CheckControlC() && (ListEntry.Flink != ReplicatedUniqueIdsQueueHead))
                {
                ReplicatedUniqueIdsEntry = ListEntry.Flink;

                MountedDeviceUniqueIdLocation = GetPointerFromAddress (ReplicatedUniqueIdsEntry + FieldOffsetReplicatedMountdevUniqueId);


                ReadMountdevUniqueId (MountedDeviceUniqueIdLocation,
                                      &MountdevUniqueId, 
                                      TRUE,
                                      DisplayOptions,
                                      FALSE);

                dprintf ("      Unique Id %ws\n", MountdevUniqueId.Buffer);

                LocalFree (MountdevUniqueId.Buffer);
                MountdevUniqueId.Buffer = NULL;


                result = ReadListEntry (ListEntry.Flink, &ListEntry);
                }
	    }
        }




    if (DisplayOptions.ListMountPointsPointingHere)
        {
        MountPointsPointingHereQueueHead = MountedDeviceInformation + FieldOffsetMountPointsPointingHereList;


        result = ReadListEntry (MountPointsPointingHereQueueHead, &ListEntry);


        if (ListEntry.Flink == MountPointsPointingHereQueueHead)
            {
            dprintf ("MountPointsPointingHereList is empty (List head @ 0x%016I64x\n", MountPointsPointingHereQueueHead);
            }

        else
            {
            while (!CheckControlC() && (ListEntry.Flink != MountPointsPointingHereQueueHead))
                {
                MountPointsPointingHereEntry = ListEntry.Flink;


                ReadUnicodeString (MountPointsPointingHereEntry + FieldOffsetMountPath, &MountPath, FALSE);

                dprintf ("    MountPath %ws\n", MountPath.Buffer);

// DeviceInfo

                result = ReadListEntry (ListEntry.Flink, &ListEntry);
                }
	    }
        }



    dprintf ("\n");


    if (NULL != MountdevUniqueId.Buffer)
        {
        LocalFree (MountdevUniqueId.Buffer);
        MountdevUniqueId.Buffer = NULL;
        }


    return (result);
    }



/*
**++
**
**  Routine Description:
**
**	Walk a queue and count the number of entries
**
**
**  Arguments:
**
**	args - the location of the queue to walk
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (valque) 
    {
    LIST_ENTRY64	le64ListEntry;
    ULONG64		ul64addrBaseQHead;
    ULONG64		ul64addrItemQHead;
    ULONG		ulEntryCount = 0;
    ULONG		fFlags       = 0;
    ULONG		fLegalFlags  = MNTMGR_KD_FLAGS_VERBOSE;
    DWORD		dwStatus     = 0;


    if (GetExpressionEx (args, &ul64addrBaseQHead, &args))
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}
    else
	{
	dprintf ("Trouble parsing the command line for valque\n");

	return;
	}


    dwStatus = ReadListEntry (ul64addrBaseQHead, &le64ListEntry);

    ul64addrItemQHead = le64ListEntry.Flink;


    while ((dwStatus) && (!CheckControlC ()) && (ul64addrItemQHead != ul64addrBaseQHead))
	{
	dwStatus = ReadListEntry (ul64addrItemQHead, &le64ListEntry);

	if (fFlags & fLegalFlags)
	    {
	    dprintf ("  Entry %4u: QHead 0x%016I64x, Flink 0x%016I64x, Blink 0x%016I64x\n", 
		     ulEntryCount, 
		     ul64addrItemQHead,
		     le64ListEntry.Flink, 
		     le64ListEntry.Blink);
	    }

	ulEntryCount++;

	ul64addrItemQHead = le64ListEntry.Flink;
	}


    dprintf ("  Total entries: %u\n", ulEntryCount);
	

    return ;
    }



ULONG GetUlongFromAddress (ULONG64 Location)
    {
    ULONG Value     = 0;
    ULONG BytesRead = 0;
    ULONG failed;


    failed = ReadMemory (Location, &Value, sizeof (ULONG), &BytesRead);

    if (failed || (BytesRead < sizeof (ULONG)))
	{
        dprintf ("unable to read from %08x\n", Location);
	}

    return (Value);
    }


ULONG64 GetPointerFromAddress (ULONG64 Location)
    {
    ULONG64 Value = 0;
    ULONG   bSucceeded;


    bSucceeded = ReadPointer (Location, &Value);

    if (!bSucceeded)
	{
        dprintf ("unable to read from %016p\n", Location);
	}

    return (Value);
    }


ULONG GetUlongValue (PCHAR String)
    {
    ULONG64 Location;
    ULONG   Value = 0;


    Location = GetExpression (String);

    if (0 == Location) 
	{
        dprintf ("unable to get %s\n", String);
	}
    else
	{
	Value = GetUlongFromAddress (Location);
	}

    return (Value);
    }


ULONG64 GetPointerValue (PCHAR String)
    {
    ULONG64 Location;
    ULONG64 Value = 0;


    Location = GetExpression (String);

    if (0 == Location) 
	{
        dprintf ("unable to get %s\n", String);
	}

    else 
	{
	ReadPointer (Location, &Value);
	}

    return (Value);
    }




BOOLEAN GetFieldValueBoolean (ULONG64 ul64addrStructureBase,
                              PCHAR   pchStructureType,
                              PCHAR   pchFieldname)
    {
    ULONG	ulReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ulReturnValue);

    return (ulReturnValue != 0);
    }


UCHAR GetFieldValueUchar (ULONG64 ul64addrStructureBase,
                          PCHAR   pchStructureType,
                          PCHAR   pchFieldname)
    {
    ULONG	ulReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ulReturnValue);

    return ((UCHAR) (ulReturnValue & 0xFF));
    }


ULONG GetFieldValueUlong32 (ULONG64 ul64addrStructureBase,
			    PCHAR   pchStructureType,
			    PCHAR   pchFieldname)
    {
    ULONG	ulReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ulReturnValue);

    return (ulReturnValue);
    }


ULONG64 GetFieldValueUlong64 (ULONG64 ul64addrStructureBase,
			      PCHAR   pchStructureType,
			      PCHAR   pchFieldname)
    {
    ULONG64	ul64ReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ul64ReturnValue);

    return (ul64ReturnValue);
    }



ULONG FormatDateAndTime (ULONG64 ul64Time, PCHAR pszFormattedDateAndTime, ULONG ulBufferLength)
    {
    FILETIME		ftTimeOriginal;
    FILETIME		ftTimeLocal;
    SYSTEMTIME		stTimeSystem;
    CHAR		achFormattedDateString [200];
    CHAR		achFormattedTimeString [200];
    DWORD		dwStatus   = 0;
    BOOL		bSucceeded = FALSE;
    ULARGE_INTEGER	uliConversionTemp;
    int			iReturnValue;


    uliConversionTemp.QuadPart = ul64Time;

    ftTimeOriginal.dwLowDateTime  = uliConversionTemp.LowPart;
    ftTimeOriginal.dwHighDateTime = uliConversionTemp.HighPart;


    if (0 == dwStatus)
	{
	bSucceeded = FileTimeToLocalFileTime (&ftTimeOriginal, &ftTimeLocal);

	if (!bSucceeded)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	bSucceeded = FileTimeToSystemTime (&ftTimeLocal, &stTimeSystem);

	if (!bSucceeded)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = GetDateFormat (LOCALE_USER_DEFAULT, 
				      0, 
				      &stTimeSystem, 
				      NULL, 
				      achFormattedDateString, 
				      sizeof (achFormattedDateString) / sizeof (CHAR));

	if (0 == iReturnValue)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = GetTimeFormat (LOCALE_USER_DEFAULT, 
				      0, 
				      &stTimeSystem, 
				      NULL, 
				      achFormattedTimeString, 
				      sizeof (achFormattedTimeString) / sizeof (CHAR));

	if (0 == iReturnValue)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = _snprintf (pszFormattedDateAndTime, 
				  ulBufferLength / sizeof (CHAR), 
				  "%s %s",
				  achFormattedDateString,
				  achFormattedTimeString);

	if (iReturnValue < 0)
	    {
	    dwStatus = ERROR_INSUFFICIENT_BUFFER;
	    }
	else
	    {
	    dwStatus = 0;
	    }
	}



    if (0 != dwStatus)
	{
	if (0 == ul64Time)
	    {
	    _snprintf (pszFormattedDateAndTime, 
		       ulBufferLength / sizeof (CHAR), 
		       "Date/Time not specified");
	    }
	else
	    {
	    _snprintf (pszFormattedDateAndTime, 
		       ulBufferLength / sizeof (CHAR), 
		       "Date/Time invalid");
	    }
	}



    return (dwStatus);
    }




/*
** {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} 
*/
ULONG FormatGUID (GUID guidValue, PCHAR pszFormattedGUID, ULONG ulBufferLength)
    {
    DWORD	dwStatus = 0;


    if (sizeof ("{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}") > ulBufferLength)
	{
	dwStatus = ERROR_INSUFFICIENT_BUFFER;
	}


    if (0 == dwStatus)
	{
	_snprintf (pszFormattedGUID, ulBufferLength, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
		   guidValue.Data1,
		   guidValue.Data2,
		   guidValue.Data3,
		   guidValue.Data4[0],
		   guidValue.Data4[1],
		   guidValue.Data4[2],
		   guidValue.Data4[3],
		   guidValue.Data4[4],
		   guidValue.Data4[5],
		   guidValue.Data4[6],
		   guidValue.Data4[7]);
	}


    return (dwStatus);
    }


/*
** "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
*/
ULONG FormatBytesAsGUID (PBYTE ByteArray, PWCHAR OutputBuffer)
    {
    ULONG       CharactersProcessed = 0;
    PGUID       guidValue           = (PGUID) ByteArray;


    CharactersProcessed = swprintf (OutputBuffer, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                                    guidValue->Data1,
                                    guidValue->Data2,
                                    guidValue->Data3,
                                    guidValue->Data4[0],
                                    guidValue->Data4[1],
                                    guidValue->Data4[2],
                                    guidValue->Data4[3],
                                    guidValue->Data4[4],
                                    guidValue->Data4[5],
                                    guidValue->Data4[6],
                                    guidValue->Data4[7]);

    return (CharactersProcessed);
    }


ULONG ReadUnicodeString (ULONG64 Location, PUNICODE_STRING pTargetString, BOOLEAN AllocateBuffer)
    {
    ULONG64             StringAddress;
    ULONG               StringLength;
    ULONG               StringMaximumLength;
    UNICODE_STRING      String;
    ULONG               RequiredBufferSize;
    ULONG               BytesRead;
    ULONG               bSucceeded;

    
    bSucceeded = !GetFieldData (Location,
                                "UNICODE_STRING",
                                "Length",
                                sizeof (StringLength),
                                &StringLength);

    if (bSucceeded)
        {
        bSucceeded = !GetFieldData (Location,
                                    "UNICODE_STRING",
                                    "MaximumLength",
                                    sizeof (StringMaximumLength),
                                    &StringMaximumLength);
        }


    if (bSucceeded)
        {
        bSucceeded = !GetFieldData (Location,
                                    "UNICODE_STRING",
                                    "Buffer",
                                    sizeof (StringAddress),
                                    &StringAddress);
        }



    if (bSucceeded)
        {
        RequiredBufferSize = StringMaximumLength + sizeof (UNICODE_NULL);
        }


    if (bSucceeded && (RequiredBufferSize > MAXUSHORT))
        {
        dprintf ("ReadUnicodeString: String Waaaaay too big");

        bSucceeded = FALSE;
        }


    if (bSucceeded && AllocateBuffer)
        {
        if (NULL != pTargetString->Buffer)
            {
            LocalFree (pTargetString->Buffer);

            pTargetString->Buffer        = NULL;
            pTargetString->Length        = 0;
            pTargetString->MaximumLength = 0;
            }


        pTargetString->Buffer = LocalAlloc (LPTR, RequiredBufferSize);

        if (NULL == pTargetString->Buffer)
            {
            dprintf ("ReadUnicodeString: Failed to allocate %u bytes for string buffer\n",
                     RequiredBufferSize);

            bSucceeded = FALSE;
            }

        else
            {
            pTargetString->MaximumLength = (USHORT)RequiredBufferSize;
            }
        }





    if (bSucceeded)
        {
        if (StringLength > StringMaximumLength)
            {
            dprintf ("Bad unicode string\n");
            bSucceeded = FALSE;
            }


        else if ((StringLength + sizeof (UNICODE_NULL)) > pTargetString->MaximumLength)
            {
            dprintf ("String too long for target buffer\n");
            bSucceeded = FALSE;
            }
        }


    if (bSucceeded && (0 != StringAddress))
	{
	bSucceeded = ReadMemory (StringAddress, pTargetString->Buffer, StringLength, &BytesRead);

	pTargetString->Buffer [BytesRead / sizeof (WCHAR)] = UNICODE_NULL;
	}

    return (bSucceeded);
    }


ULONG ReadMountdevUniqueId (ULONG64         Location, 
                            PUNICODE_STRING pTargetString, 
                            BOOLEAN         AllocateBuffer, 
                            DISPLAY_OPTIONS DisplayOptions, 
                            BOOLEAN         IsRemovable)
    {
    ULONG64		StringAddress;
    ULONG		BytesRead;
    ULONG               bSucceeded;
    ULONG               FieldOffsetUniqueId;
    ULONG               CharactersProcessed = 0;
    ULONG               UniqueIdBufferIndex;
    USHORT              RequiredBufferSize;
    USHORT              UniqueIdLength;
    PBYTE               UniqueIdBuffer      = NULL;
    BOOLEAN             FoundDmioUniqueId   = FALSE;
    BOOLEAN             FoundMbrSignature   = FALSE;
    BOOLEAN             FoundRemovableMedia = FALSE;


    bSucceeded = !GetFieldOffset ("MountMgr!_MOUNTDEV_UNIQUE_ID", 
                                  "UniqueId", 
                                  &FieldOffsetUniqueId);


    if (bSucceeded)
        {
        bSucceeded = !GetFieldData (Location, 
                                    "MountMgr!_MOUNTDEV_UNIQUE_ID", 
                                    "UniqueIdLength", 
                                    sizeof (UniqueIdLength), 
                                    &UniqueIdLength);
        }


    if (bSucceeded)
        {
        UniqueIdBuffer = LocalAlloc (LPTR, UniqueIdLength + sizeof (UNICODE_NULL));

        if (NULL == UniqueIdBuffer)
            {
            dprintf ("ReadMountdevUniqueId: Failed to allocate %u bytes for UniqueId buffer\n");

            bSucceeded = FALSE;
            }
        }


    if (bSucceeded)
        {
        StringAddress = Location + FieldOffsetUniqueId;

        bSucceeded = ReadMemory (StringAddress, 
                                 UniqueIdBuffer, 
                                 UniqueIdLength, 
                                 &BytesRead);

        if (!bSucceeded)
            {
            dprintf ("ReadMountdevUniqueId: Failed to read %u bytes from target address 0x%016I64x\n",
                     UniqueIdLength,
                     StringAddress);
            }

        else if (BytesRead != UniqueIdLength)
            {
            dprintf ("ReadMountdevUniqueId: Requested %u bytes from target address 0x%016I64x but got %u bytes\n",
                     UniqueIdLength,
                     StringAddress,
                     BytesRead);

            bSucceeded = FALSE;
            }
        }


    if (bSucceeded)
        {
        RequiredBufferSize = sizeof (UNICODE_NULL);

        if (DisplayOptions.Verbose)
            {
            /*
            ** Only dump the raw data if the verbose display was requested.
            **
            ** Two chars/digits per byte, two bytes per wide char and a trailing NULL
            */
            RequiredBufferSize += SIZEOF_STRING (L"    (");
            RequiredBufferSize += UniqueIdLength * 2 * sizeof (WCHAR);
            RequiredBufferSize += SIZEOF_STRING (L")");
            }


        if (IsRemovable)
            {
            /*
            ** For removable devices the string is just dumped out directly so 
            ** we just count the number of chars required.
            */
            RequiredBufferSize += UniqueIdLength;

            FoundRemovableMedia = TRUE;
            }

        else if ((0 == strncmp ("DMIO:ID:", UniqueIdBuffer, 8)) && (24 == UniqueIdLength))
            {
            /*
            ** Look for the 'DMIO:ID:' string and extend the buffer. We will need to add space
            ** for the DMIO:ID:, some spaces, some brackets and a formatted GUID 
            */
            RequiredBufferSize += SIZEOF_STRING (L"DMIO:ID:");
            RequiredBufferSize += SIZEOF_STRING (FORMATTED_GUIDW);

            FoundDmioUniqueId = TRUE;
            }
        else if (12 == UniqueIdLength)
            {
            /*
            ** This is a volume basic disk so the first 32 bits represent the disk signature
            ** and the remainder the sector offset of the host partition. To display this we
            ** need some spaces etc.
            */
            RequiredBufferSize += SIZEOF_STRING (L"DiskSignature:00112233  StartingSector:");
            RequiredBufferSize += (UniqueIdLength - 4) * 2 * sizeof (WCHAR);

            FoundMbrSignature = TRUE;
            }

        else
            {
            RequiredBufferSize += SIZEOF_STRING (L"(Cannot interpret data stream)");
            }
        }


    if (bSucceeded && AllocateBuffer)
        {
        if (NULL != pTargetString->Buffer)
            {
            LocalFree (pTargetString->Buffer);

            pTargetString->Buffer        = NULL;
            pTargetString->Length        = 0;
            pTargetString->MaximumLength = 0;
            }

        pTargetString->Buffer = LocalAlloc (LPTR, RequiredBufferSize);

        if (NULL == pTargetString->Buffer)
            {
            dprintf ("ReadMountdevUniqueId: Failed to allocate %u bytes for string buffer\n",
                     RequiredBufferSize);

            bSucceeded = FALSE;
            }

        else
            {
            pTargetString->MaximumLength = RequiredBufferSize;
            }
        }



    if (bSucceeded && (RequiredBufferSize > 0) && (pTargetString->MaximumLength < RequiredBufferSize))
        {
        dprintf ("String too long for target buffer\n");

        bSucceeded = FALSE;
        }



    if (bSucceeded)
        {
        if (FoundRemovableMedia)
            {
            CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed], 
                                             L"%*s",
                                             UniqueIdLength / sizeof (WCHAR),
                                             UniqueIdBuffer);
            }

        else if (FoundDmioUniqueId)
            {
            CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed], L"DMIO:ID:");

            CharactersProcessed += FormatBytesAsGUID (&UniqueIdBuffer [8], &pTargetString->Buffer [CharactersProcessed]);

            }

        else if (FoundMbrSignature)
            {
            CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed], 
                                             L"DiskSignature:%02X%02X%02X%02X  StartingSector:",
                                             UniqueIdBuffer [3],
                                             UniqueIdBuffer [2],
                                             UniqueIdBuffer [1],
                                             UniqueIdBuffer [0]);

            for (UniqueIdBufferIndex = UniqueIdLength - 1; UniqueIdBufferIndex > 3; UniqueIdBufferIndex--)
                {
                CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed],
                                                 L"%02X", 
                                                 UniqueIdBuffer [UniqueIdBufferIndex]);
                }
            }

        else
            {
            CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed], L"(Cannot interpret data stream)");
            }




        if (DisplayOptions.Verbose)
            {
            CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed], L"    (");


            for (UniqueIdBufferIndex = 0; UniqueIdBufferIndex < UniqueIdLength; UniqueIdBufferIndex++)
                {
                CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed],
                                                 L"%02X", 
                                                 UniqueIdBuffer [UniqueIdBufferIndex]);
                }


            CharactersProcessed += swprintf (&pTargetString->Buffer [CharactersProcessed], L")");
            }



        pTargetString->Length = (USHORT) (CharactersProcessed * sizeof (WCHAR));
        }



    if (NULL != UniqueIdBuffer)
        {
        LocalFree (UniqueIdBuffer);
        }


    return (bSucceeded);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\dummyfdo\dummyfdo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dummyfdo

Abstract

    A little driver to fool the Wise old PlugPlay system

Author:

    Kenneth Ray

Environment:

    Kernel mode only

Revision History:

--*/

#include <wdm.h>

NTSTATUS
Dummy_AddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    PDEVICE_OBJECT  device;
    IoCreateDevice (DriverObject, 0, NULL, 0, 0, FALSE, &device);
    DriverObject->DriverExtension->AddDevice = Dummy_AddDevice;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\mountmgr\mntmgr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mntmgr.h

Abstract:

    This file defines the internal data structure for the MOUNTMGR driver.

Author:

    norbertk

Revision History:

--*/

#define MOUNTED_DEVICES_KEY         L"\\Registry\\Machine\\System\\MountedDevices"
#define MOUNTED_DEVICES_OFFLINE_KEY L"\\Registry\\Machine\\System\\MountedDevices\\Offline"

typedef struct _SYMBOLIC_LINK_NAME_ENTRY {
    LIST_ENTRY      ListEntry;
    UNICODE_STRING  SymbolicLinkName;
    BOOLEAN         IsInDatabase;
} SYMBOLIC_LINK_NAME_ENTRY, *PSYMBOLIC_LINK_NAME_ENTRY;

typedef struct _REPLICATED_UNIQUE_ID {
    LIST_ENTRY          ListEntry;
    PMOUNTDEV_UNIQUE_ID UniqueId;
} REPLICATED_UNIQUE_ID, *PREPLICATED_UNIQUE_ID;


typedef struct _DEVICE_EXTENSION {

    //
    // A pointer to our own device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // A pointer to the driver object.
    //

    PDRIVER_OBJECT DriverObject;

    //
    // A linked list mounted devices.
    //

    LIST_ENTRY MountedDeviceList;

    //
    // A linked list of unresponsive mounted devices.
    //

    LIST_ENTRY DeadMountedDeviceList;

    //
    // Notification entry.
    //

    PVOID NotificationEntry;

    //
    // For synchronization.
    //

    KSEMAPHORE Mutex;

    //
    // Synchronization for the Remote databases.
    //

    KSEMAPHORE RemoteDatabaseSemaphore;

    //
    // Specifies whether or not to automatically assign drive letters.
    //

    BOOLEAN AutomaticDriveLetterAssignment;

    //
    // Change notify list.  Protect with cancel spin lock.
    //

    LIST_ENTRY ChangeNotifyIrps;

    //
    // Change notify epic number.  Protect with 'mutex'.
    //

    ULONG EpicNumber;

    //
    // A list of saved links.
    //

    LIST_ENTRY SavedLinksList;

    //
    // Indicates whether or not the suggested drive letters have been
    // processed.
    //

    BOOLEAN SuggestedDriveLettersProcessed;

    //
    // Indicates whether of not volumes should be auto-mounted if they are not
    // visible in the namespace.
    //

    BOOLEAN AutoMountPermitted;


    //
    // A thread to be used for verifying remote databases.
    //

    LIST_ENTRY WorkerQueue;
    KSEMAPHORE WorkerSemaphore;
    LONG WorkerRefCount;
    KSPIN_LOCK WorkerSpinLock;

    LIST_ENTRY UniqueIdChangeNotifyList;

    //
    // System Partition Unique Id.
    //

    PMOUNTDEV_UNIQUE_ID SystemPartitionUniqueId;

    //
    // Save the registry path.
    //

    UNICODE_STRING RegistryPath;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _MOUNTED_DEVICE_INFORMATION {
    LIST_ENTRY          ListEntry;
    LIST_ENTRY          SymbolicLinkNames;
    LIST_ENTRY          ReplicatedUniqueIds;
    LIST_ENTRY          MountPointsPointingHere;
    UNICODE_STRING      NotificationName;
    PMOUNTDEV_UNIQUE_ID UniqueId;
    UNICODE_STRING      DeviceName;
    BOOLEAN             KeepLinksWhenOffline;
    UCHAR               SuggestedDriveLetter;
    BOOLEAN             NotAPdo;
    BOOLEAN             IsRemovable;
    BOOLEAN             NextDriveLetterCalled;
    BOOLEAN             ReconcileOnMounts;
    BOOLEAN             HasDanglingVolumeMountPoint;
    BOOLEAN             InOfflineList;
    BOOLEAN             RemoteDatabaseMigrated;
    PVOID               TargetDeviceNotificationEntry;
    PDEVICE_EXTENSION   Extension;
} MOUNTED_DEVICE_INFORMATION, *PMOUNTED_DEVICE_INFORMATION;

typedef struct _SAVED_LINKS_INFORMATION {
    LIST_ENTRY          ListEntry;
    LIST_ENTRY          SymbolicLinkNames;
    PMOUNTDEV_UNIQUE_ID UniqueId;
} SAVED_LINKS_INFORMATION, *PSAVED_LINKS_INFORMATION;

typedef struct _MOUNTMGR_FILE_ENTRY {
    ULONG EntryLength;
    ULONG RefCount;
    USHORT VolumeNameOffset;
    USHORT VolumeNameLength;
    USHORT UniqueIdOffset;
    USHORT UniqueIdLength;
} MOUNTMGR_FILE_ENTRY, *PMOUNTMGR_FILE_ENTRY;

typedef struct _MOUNTMGR_MOUNT_POINT_ENTRY {
    LIST_ENTRY                  ListEntry;
    PMOUNTED_DEVICE_INFORMATION DeviceInfo;
    UNICODE_STRING              MountPath;
} MOUNTMGR_MOUNT_POINT_ENTRY, *PMOUNTMGR_MOUNT_POINT_ENTRY;

typedef struct _MOUNTMGR_DEVICE_ENTRY {
    LIST_ENTRY                  ListEntry;
    PMOUNTED_DEVICE_INFORMATION DeviceInfo;
} MOUNTMGR_DEVICE_ENTRY, *PMOUNTMGR_DEVICE_ENTRY;

typedef struct _MOUNTMGR_ONLINE_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    UNICODE_STRING  NotificationName;
} MOUNTMGR_ONLINE_CONTEXT, *PMOUNTMGR_ONLINE_CONTEXT;


typedef struct _REMOTE_DATABASE_MIGRATION_CONTEXT {
    PIO_WORKITEM                WorkItem;
    PMOUNTED_DEVICE_INFORMATION DeviceInfo;
    PKEVENT                     MigrationProcessedEvent;
    NTSTATUS                    Status;
    HANDLE                      Handle;
} REMOTE_DATABASE_MIGRATION_CONTEXT, *PREMOTE_DATABASE_MIGRATION_CONTEXT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\mountmgr\mountmgr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mountmgr.c

Abstract:

    This driver manages the kernel mode mount table that handles the level
    of indirection between the persistent dos device name for an object and
    the non-persistent nt device name for an object.

Author:

    Norbert Kusters      20-May-1997

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#define _NTSRV_

#include <ntosp.h>
#include <zwapi.h>
#include <initguid.h>
#include <ntdddisk.h>
#include <ntddvol.h>
#include <initguid.h>
#include <wdmguid.h>
#include <mountmgr.h>
#include <mountdev.h>
#include <mntmgr.h>
#include <stdio.h>
#include <ioevent.h>


// The protection on these IOCTLs have been updated. Keep the old definitions so we can send updates to 
// anyone who has yet to recompile with the new definitions.
//
#define IOCTL_MOUNTDEV_LINK_CREATED_OBSOLETE    CTL_CODE (MOUNTDEVCONTROLTYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_LINK_DELETED_OBSOLETE    CTL_CODE (MOUNTDEVCONTROLTYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define DeclareStaticUnicodeString(_StringName, _StringValue)                                                   \
                        static UNICODE_STRING (_StringName) = {sizeof (_StringValue) - sizeof (UNICODE_NULL),   \
                                                               sizeof (_StringValue),                           \
                                                               (_StringValue)}


// NOTE, this structure is here because it was not defined in NTIOAPI.H.
// This should be taken out in the future.
// This is stolen from NTFS.H

typedef struct _REPARSE_INDEX_KEY {

    //
    //  The tag of the reparse point.
    //

    ULONG FileReparseTag;

    //
    //  The file record Id where the reparse point is set.
    //

    LARGE_INTEGER FileId;

} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;



#define MAX(_a, _b)    ((_a) > (_b) ? (_a) : (_b))
#define MAX_VOLUME_PATH 100

#define IOCTL_MOUNTMGR_QUERY_POINTS_ADMIN           CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_READ_ACCESS)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
UniqueIdChangeNotifyCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           WorkItem
    );

NTSTATUS
MountMgrChangeNotify(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    );

VOID
MountMgrNotify(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ReconcileThisDatabaseWithMaster(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    );


NTSTATUS
MountMgrMountedDeviceRemoval(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     NotificationName
    );

VOID
MountMgrUnload(
    IN PDRIVER_OBJECT DriverObject
    );

ULONG
MountmgrReadNoAutoMount(
    IN  PUNICODE_STRING RegistryPath
    );

typedef struct _RECONCILE_WORK_ITEM_INFO {
    PDEVICE_EXTENSION           Extension;
    PMOUNTED_DEVICE_INFORMATION DeviceInfo;
} RECONCILE_WORK_ITEM_INFO, *PRECONCILE_WORK_ITEM_INFO;

typedef VOID (*PRECONCILE_WRKRTN) (
    IN  PVOID   WorkItem
    );

typedef struct _RECONCILE_WORK_ITEM {
    LIST_ENTRY               List;
    PIO_WORKITEM             WorkItem;
    PRECONCILE_WRKRTN        WorkerRoutine;
    PVOID                    Parameter;
    RECONCILE_WORK_ITEM_INFO WorkItemInfo;
} RECONCILE_WORK_ITEM, *PRECONCILE_WORK_ITEM;

NTSTATUS
QueueWorkItem(
    IN  PDEVICE_EXTENSION    Extension,
    IN  PRECONCILE_WORK_ITEM WorkItem,
    IN  PVOID                Parameter
    );

VOID
SendOnlineNotification(
    IN  PUNICODE_STRING     NotificationName
    );


#ifdef POOL_TAGGING
#undef ExAllocatePool

#define ExAllocatePool(_a,_b) ExAllocatePoolWithTag((_a), (_b), MOUNTMGR_TAG_MISC)

#define MOUNTMGR_TAG_MISC       'AtnM'  // MntA
#define MOUNTMGR_TAG_BUFFER     'BtnM'  // MntB

#endif

//
// Globals
//
PDEVICE_OBJECT gdeviceObject = NULL;
KEVENT UnloadEvent;
LONG Unloading = 0;

DeclareStaticUnicodeString (DeviceName,                   MOUNTMGR_DEVICE_NAME);
DeclareStaticUnicodeString (DeviceSymbolicLinkName,       L"\\DosDevices\\MountPointManager");
DeclareStaticUnicodeString (DosDevices,                   L"\\DosDevices\\");
DeclareStaticUnicodeString (DosPrefix,                    L"\\??\\");
DeclareStaticUnicodeString (GlobalPrefix,                 L"\\GLOBAL??\\");
DeclareStaticUnicodeString (VolumeNamePrefix,             L"\\??\\Volume");
DeclareStaticUnicodeString (DeviceFloppy,                 L"\\Device\\Floppy");
DeclareStaticUnicodeString (DeviceCdRom,                  L"\\Device\\CdRom");

DeclareStaticUnicodeString (VolumeSafeEventName,          L"\\Device\\VolumesSafeForWriteAccess");

DeclareStaticUnicodeString (ReparseIndexName,             L"\\$Extend\\$Reparse:$R:$INDEX_ALLOCATION");
DeclareStaticUnicodeString (RemoteDatabaseFileName,       L"\\System Volume Information\\MountPointManagerRemoteDatabase");
DeclareStaticUnicodeString (RemoteDatabaseFileNameLegacy, L"\\:$MountMgrRemoteDatabase");




#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, MountmgrReadNoAutoMount)
#pragma alloc_text(PAGE, MountMgrUnload)
#endif

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif


NTSTATUS
CreateStringWithGlobal(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING StringWithGlobal
    )

{
    UNICODE_STRING  newSource;


    if (RtlPrefixUnicodeString(&DosDevices, SymbolicLinkName, TRUE)) {

        newSource.Length        = SymbolicLinkName->Length + GlobalPrefix.Length - DosDevices.Length;
        newSource.MaximumLength = newSource.Length + sizeof(WCHAR);
        newSource.Buffer        = ExAllocatePool(PagedPool, newSource.MaximumLength);
        if (!newSource.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(newSource.Buffer, GlobalPrefix.Buffer, GlobalPrefix.Length);
        RtlCopyMemory((PCHAR) newSource.Buffer + GlobalPrefix.Length,
                      (PCHAR) SymbolicLinkName->Buffer + DosDevices.Length,
                      SymbolicLinkName->Length - DosDevices.Length);
        newSource.Buffer[newSource.Length/sizeof(WCHAR)] = 0;

    } else if (RtlPrefixUnicodeString(&DosPrefix, SymbolicLinkName, TRUE)) {

        newSource.Length        = SymbolicLinkName->Length + GlobalPrefix.Length - DosPrefix.Length;
        newSource.MaximumLength = newSource.Length + sizeof(WCHAR);
        newSource.Buffer        = ExAllocatePool(PagedPool, newSource.MaximumLength);
        if (!newSource.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(newSource.Buffer, GlobalPrefix.Buffer, GlobalPrefix.Length);
        RtlCopyMemory((PCHAR) newSource.Buffer + GlobalPrefix.Length,
                      (PCHAR) SymbolicLinkName->Buffer + DosPrefix.Length,
                      SymbolicLinkName->Length - DosPrefix.Length);
        newSource.Buffer[newSource.Length/sizeof(WCHAR)] = 0;

    } else {

        newSource = *SymbolicLinkName;
        newSource.Buffer = ExAllocatePool(PagedPool, newSource.MaximumLength);
        if (!newSource.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(newSource.Buffer, SymbolicLinkName->Buffer,
                      SymbolicLinkName->MaximumLength);
    }

    *StringWithGlobal = newSource;

    return STATUS_SUCCESS;
}

NTSTATUS
GlobalCreateSymbolicLink(
    IN  PUNICODE_STRING SymbolicLinkName,
    IN  PUNICODE_STRING DeviceName
    )

{
    NTSTATUS        status;
    UNICODE_STRING  newSource;

    status = CreateStringWithGlobal(SymbolicLinkName, &newSource);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = IoCreateSymbolicLink(&newSource, DeviceName);
    ExFreePool(newSource.Buffer);

    return status;
}

NTSTATUS
GlobalDeleteSymbolicLink(
    IN  PUNICODE_STRING SymbolicLinkName
    )

{
    NTSTATUS        status;
    UNICODE_STRING  newSource;

    status = CreateStringWithGlobal(SymbolicLinkName, &newSource);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = IoDeleteSymbolicLink(&newSource);
    ExFreePool(newSource.Buffer);

    return status;
}

NTSTATUS
QueryDeviceInformation(
    IN  PUNICODE_STRING         NotificationName,
    OUT PUNICODE_STRING         DeviceName,
    OUT PMOUNTDEV_UNIQUE_ID*    UniqueId,
    OUT PBOOLEAN                IsRemovable,
    OUT PBOOLEAN                IsRecognized,
    OUT PBOOLEAN                IsStable,
    OUT GUID*                   StableGuid,
    OUT PBOOLEAN                IsFT
    )

/*++

Routine Description:

    This routine queries device information.

Arguments:

    NotificationName    - Supplies the notification name.

    DeviceName          - Returns the device name.

    UniqueId            - Returns the unique id.

    IsRemovable         - Returns whether or not the device is removable.

    IsRecognized        - Returns whether or not this is a recognized partition
                            type.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                                status, status2;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;
    BOOLEAN                                 isRemovable;
    VOLUME_GET_GPT_ATTRIBUTES_INFORMATION   gptAttributesInfo;
    PARTITION_INFORMATION_EX                partInfo;
    KEVENT                                  event;
    PIRP                                    irp;
    IO_STATUS_BLOCK                         ioStatus;
    ULONG                                   outputSize;
    PMOUNTDEV_NAME                          output;
    PIO_STACK_LOCATION                      irpSp;
    STORAGE_DEVICE_NUMBER                   number;

    status = IoGetDeviceObjectPointer(NotificationName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    if (fileObject->FileName.Length) {
        ObDereferenceObject(fileObject);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if (fileObject->DeviceObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        isRemovable = TRUE;
    } else {
        isRemovable = FALSE;
    }

    if (IsRemovable) {
        *IsRemovable = isRemovable;
    }

    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    if (IsRecognized) {
        *IsRecognized = TRUE;

        if (!isRemovable) {
            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_VOLUME_GET_GPT_ATTRIBUTES, deviceObject, NULL, 0,
                    &gptAttributesInfo, sizeof(gptAttributesInfo), FALSE,
                    &event, &ioStatus);
            if (!irp) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);
                status = ioStatus.Status;
            }

            if (NT_SUCCESS(status)) {
                if (gptAttributesInfo.GptAttributes&
                    GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER) {

                    *IsRecognized = FALSE;
                }
            } else {
                status = STATUS_SUCCESS;
            }
        }
    }

    if (IsFT) {

        *IsFT = FALSE;

        if (!isRemovable) {

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_DISK_GET_PARTITION_INFO_EX, deviceObject, NULL, 0,
                    &partInfo, sizeof(partInfo), FALSE, &event, &ioStatus);
            if (!irp) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);
                status = ioStatus.Status;
            }

            if (NT_SUCCESS(status)) {
                if (partInfo.PartitionStyle == PARTITION_STYLE_MBR) {
                    if (IsFT && IsFTPartition(partInfo.Mbr.PartitionType)) {
                        *IsFT = TRUE;
                    }
                }
            } else {
                status = STATUS_SUCCESS;
            }
        }

        if (*IsFT) {

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_STORAGE_GET_DEVICE_NUMBER, deviceObject, NULL, 0,
                    &number, sizeof(number), FALSE, &event, &ioStatus);
            if (!irp) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);
                status = ioStatus.Status;
            }

            if (NT_SUCCESS(status)) {
                *IsFT = FALSE;
            } else {
                status = STATUS_SUCCESS;
            }
        }
    }

    if (DeviceName) {

        outputSize = sizeof(MOUNTDEV_NAME);
        output = ExAllocatePool(PagedPool, outputSize);
        if (!output) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_DEVICE_NAME, deviceObject, NULL, 0, output,
              outputSize, FALSE, &event, &ioStatus);
        if (!irp) {
            ExFreePool(output);
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (status == STATUS_BUFFER_OVERFLOW) {

            outputSize = sizeof(MOUNTDEV_NAME) + output->NameLength;
            ExFreePool(output);
            output = ExAllocatePool(PagedPool, outputSize);
            if (!output) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                  IOCTL_MOUNTDEV_QUERY_DEVICE_NAME, deviceObject, NULL, 0, output,
                  outputSize, FALSE, &event, &ioStatus);
            if (!irp) {
                ExFreePool(output);
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                status = ioStatus.Status;
            }
        }

        if (NT_SUCCESS(status)) {

            DeviceName->Length = output->NameLength;
            DeviceName->MaximumLength = output->NameLength + sizeof(WCHAR);
            DeviceName->Buffer = ExAllocatePool(PagedPool,
                                                DeviceName->MaximumLength);
            if (DeviceName->Buffer) {

                RtlCopyMemory(DeviceName->Buffer, output->Name,
                              output->NameLength);
                DeviceName->Buffer[DeviceName->Length/sizeof(WCHAR)] = 0;

            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        ExFreePool(output);
    }

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return status;
    }

    if (UniqueId) {

        outputSize = sizeof(MOUNTDEV_UNIQUE_ID);
        output = ExAllocatePool(PagedPool, outputSize);
        if (!output) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_UNIQUE_ID, deviceObject, NULL, 0, output,
              outputSize, FALSE, &event, &ioStatus);
        if (!irp) {
            ExFreePool(output);
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (status == STATUS_BUFFER_OVERFLOW) {

            outputSize = sizeof(MOUNTDEV_UNIQUE_ID) +
                         ((PMOUNTDEV_UNIQUE_ID) output)->UniqueIdLength;
            ExFreePool(output);
            output = ExAllocatePool(PagedPool, outputSize);
            if (!output) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                  IOCTL_MOUNTDEV_QUERY_UNIQUE_ID, deviceObject, NULL, 0, output,
                  outputSize, FALSE, &event, &ioStatus);
            if (!irp) {
                ExFreePool(output);
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                status = ioStatus.Status;
            }
        }

        if (!NT_SUCCESS(status)) {
            ExFreePool(output);
            if (DeviceName) {
                ExFreePool(DeviceName->Buffer);
            }
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return status;
        }

        *UniqueId = (PMOUNTDEV_UNIQUE_ID) output;
    }

    if (IsStable) {
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_STABLE_GUID, deviceObject, NULL, 0,
              StableGuid, sizeof(GUID), FALSE, &event, &ioStatus);
        if (!irp) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status2 = IoCallDriver(deviceObject, irp);
        if (status2 == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status2 = ioStatus.Status;
        }

        if (NT_SUCCESS(status2)) {
            *IsStable = TRUE;
        } else {
            *IsStable = FALSE;
        }
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);

    return status;
}

NTSTATUS
FindDeviceInfo(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PUNICODE_STRING                 DeviceName,
    IN  BOOLEAN                         IsCanonicalName,
    OUT PMOUNTED_DEVICE_INFORMATION*    DeviceInfo
    )

/*++

Routine Description:

    This routine finds the device information for the given device.

Arguments:

    Extension           - Supplies the device extension.

    DeviceName          - Supplies the name of the device.

    CanonicalizeName    - Supplies whether or not the name given is canonical.

    DeviceInfo          - Returns the device information.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING              targetName;
    NTSTATUS                    status;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    if (IsCanonicalName) {
        targetName = *DeviceName;
    } else {
        status = QueryDeviceInformation(DeviceName, &targetName, NULL, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (RtlEqualUnicodeString(&targetName, &deviceInfo->DeviceName,
                                  TRUE)) {
            break;
        }
    }

    if (!IsCanonicalName) {
        ExFreePool(targetName.Buffer);
    }

    if (l == &Extension->MountedDeviceList) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    *DeviceInfo = deviceInfo;

    return STATUS_SUCCESS;
}

NTSTATUS
QuerySuggestedLinkName(
    IN  PUNICODE_STRING NotificationName,
    OUT PUNICODE_STRING SuggestedLinkName,
    OUT PBOOLEAN        UseOnlyIfThereAreNoOtherLinks
    )

/*++

Routine Description:

    This routine queries the mounted device for a suggested link name.

Arguments:

    NotificationName                - Supplies the notification name.

    SuggestedLinkName               - Returns the suggested link name.

    UseOnlyIfThereAreNoOtherLinks   - Returns whether or not to use this name
                                        if there are other links to the device.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    PFILE_OBJECT                    fileObject;
    PDEVICE_OBJECT                  deviceObject;
    ULONG                           outputSize;
    PMOUNTDEV_SUGGESTED_LINK_NAME   output;
    KEVENT                          event;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;
    PIO_STACK_LOCATION              irpSp;

    status = IoGetDeviceObjectPointer(NotificationName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    outputSize = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
    output = ExAllocatePool(PagedPool, outputSize);
    if (!output) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(
          IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME, deviceObject, NULL, 0,
          output, outputSize, FALSE, &event, &ioStatus);
    if (!irp) {
        ExFreePool(output);
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (status == STATUS_BUFFER_OVERFLOW) {

        outputSize = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME) + output->NameLength;
        ExFreePool(output);
        output = ExAllocatePool(PagedPool, outputSize);
        if (!output) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME, deviceObject, NULL, 0,
              output, outputSize, FALSE, &event, &ioStatus);
        if (!irp) {
            ExFreePool(output);
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }
    }

    if (NT_SUCCESS(status)) {

        SuggestedLinkName->Length = output->NameLength;
        SuggestedLinkName->MaximumLength = output->NameLength + sizeof(WCHAR);
        SuggestedLinkName->Buffer = ExAllocatePool(PagedPool,
                                                   SuggestedLinkName->MaximumLength);
        if (SuggestedLinkName->Buffer) {

            RtlCopyMemory(SuggestedLinkName->Buffer, output->Name,
                          output->NameLength);
            SuggestedLinkName->Buffer[output->NameLength/sizeof(WCHAR)] = 0;

        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        *UseOnlyIfThereAreNoOtherLinks = output->UseOnlyIfThereAreNoOtherLinks;
    }

    ExFreePool(output);
    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);

    return status;
}

NTSTATUS
SymbolicLinkNamesFromUniqueIdCount(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine counts all of the occurences of the unique id in the
    registry key.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Supplies the num names count.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;
    UNICODE_STRING      string;

    if (ValueName[0] == '#' ||
        ValueType != REG_BINARY ||
        uniqueId->UniqueIdLength != ValueLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {


        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueName);
    if (!string.Length) {
        return STATUS_SUCCESS;
    }

    (*((PULONG) EntryContext))++;

    return STATUS_SUCCESS;
}

NTSTATUS
SymbolicLinkNamesFromUniqueIdQuery(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine counts all of the occurences of the unique id in the
    registry key.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Supplies the dos names array.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;
    UNICODE_STRING      string;
    PUNICODE_STRING     p;

    if (ValueName[0] == '#' ||
        ValueType != REG_BINARY ||
        uniqueId->UniqueIdLength != ValueLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueName);
    if (!string.Length) {
        return STATUS_SUCCESS;
    }

    string.Buffer = ExAllocatePool(PagedPool, string.MaximumLength);
    if (!string.Buffer) {
        return STATUS_SUCCESS;
    }
    RtlCopyMemory(string.Buffer, ValueName, string.Length);
    string.Buffer[string.Length/sizeof(WCHAR)] = 0;

    p = (PUNICODE_STRING) EntryContext;
    while (p->Length != 0) {
        p++;
    }

    *p = string;

    return STATUS_SUCCESS;
}

BOOLEAN
IsDriveLetter(
    IN  PUNICODE_STRING SymbolicLinkName
    )

{
    if (SymbolicLinkName->Length == 28 &&
        ((SymbolicLinkName->Buffer[12] >= 'A' &&
          SymbolicLinkName->Buffer[12] <= 'Z') ||
         SymbolicLinkName->Buffer[12] == 0xFF) &&
        SymbolicLinkName->Buffer[13] == ':') {

        SymbolicLinkName->Length = 24;
        if (RtlEqualUnicodeString(SymbolicLinkName, &DosDevices, TRUE)) {
            SymbolicLinkName->Length = 28;
            return TRUE;
        }
        SymbolicLinkName->Length = 28;
    }

    return FALSE;
}

NTSTATUS
CreateNewVolumeName(
    OUT PUNICODE_STRING VolumeName,
    IN  GUID*           Guid
    )

/*++

Routine Description:

    This routine creates a new name of the form \??\Volume{GUID}.

Arguments:

    VolumeName  - Returns the volume name.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS        status;
    UUID            uuid;
    UNICODE_STRING  guidString;

    if (Guid) {
        uuid = *Guid;
    } else {
        status = ExUuidCreate(&uuid);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = RtlStringFromGUID(&uuid, &guidString);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    VolumeName->MaximumLength = 98;
    VolumeName->Buffer = ExAllocatePool(PagedPool, VolumeName->MaximumLength);
    if (!VolumeName->Buffer) {
        ExFreePool(guidString.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(VolumeName, &VolumeNamePrefix);
    RtlAppendUnicodeStringToString(VolumeName, &guidString);
    VolumeName->Buffer[VolumeName->Length/sizeof(WCHAR)] = 0;

    ExFreePool(guidString.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
QuerySymbolicLinkNamesFromStorage(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo,
    IN  PUNICODE_STRING             SuggestedName,
    IN  BOOLEAN                     UseOnlyIfThereAreNoOtherLinks,
    OUT PUNICODE_STRING*            SymbolicLinkNames,
    OUT PULONG                      NumNames,
    IN  BOOLEAN                     IsStable,
    IN  GUID*                       StableGuid
    )

/*++

Routine Description:

    This routine queries the symbolic link names from storage for
    the given notification name.

Arguments:

    Extension           - Supplies the device extension.

    DeviceInfo          - Supplies the device information.

    SymbolicLinkNames   - Returns the symbolic link names.

    NumNames            - Returns the number of symbolic link names.


Return Value:

    NTSTATUS

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    BOOLEAN                     extraLink;
    NTSTATUS                    status;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = SymbolicLinkNamesFromUniqueIdCount;
    queryTable[0].EntryContext = NumNames;

    *NumNames = 0;
    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    MOUNTED_DEVICES_KEY, queryTable,
                                    DeviceInfo->UniqueId, NULL);

    if (!NT_SUCCESS(status)) {
        *NumNames = 0;
    }

    if (SuggestedName && !IsDriveLetter(SuggestedName)) {
        if (UseOnlyIfThereAreNoOtherLinks) {
            if (*NumNames == 0) {
                extraLink = TRUE;
            } else {
                extraLink = FALSE;
            }
        } else {
            extraLink = TRUE;
        }
    } else {
        extraLink = FALSE;
    }

    if (IsStable) {
        (*NumNames)++;
    }

    if (extraLink) {

        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                              SuggestedName->Buffer, REG_BINARY,
                              DeviceInfo->UniqueId->UniqueId,
                              DeviceInfo->UniqueId->UniqueIdLength);

        RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
        queryTable[0].QueryRoutine = SymbolicLinkNamesFromUniqueIdCount;
        queryTable[0].EntryContext = NumNames;

        *NumNames = 0;
        status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                        MOUNTED_DEVICES_KEY, queryTable,
                                        DeviceInfo->UniqueId, NULL);

        if (!NT_SUCCESS(status) || *NumNames == 0) {
            return STATUS_NOT_FOUND;
        }

    } else if (!*NumNames) {
        return STATUS_NOT_FOUND;
    }

    *SymbolicLinkNames = ExAllocatePool(PagedPool,
                                        *NumNames*sizeof(UNICODE_STRING));
    if (!*SymbolicLinkNames) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(*SymbolicLinkNames, *NumNames*sizeof(UNICODE_STRING));

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = SymbolicLinkNamesFromUniqueIdQuery;

    if (IsStable) {

        status = CreateNewVolumeName(&((*SymbolicLinkNames)[0]), StableGuid);
        if (!NT_SUCCESS(status)) {
            ExFreePool(*SymbolicLinkNames);
            return status;
        }

        queryTable[0].EntryContext = &((*SymbolicLinkNames)[1]);
    } else {
        queryTable[0].EntryContext = *SymbolicLinkNames;
    }

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    MOUNTED_DEVICES_KEY, queryTable,
                                    DeviceInfo->UniqueId, NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
ChangeUniqueIdRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine replaces all old unique ids with new unique ids.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the old unique id.

    EntryContext    - Supplies the new unique id.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID oldId = Context;
    PMOUNTDEV_UNIQUE_ID newId = EntryContext;

    if (ValueType != REG_BINARY || oldId->UniqueIdLength != ValueLength ||
        RtlCompareMemory(oldId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                          ValueName, ValueType, newId->UniqueId,
                          newId->UniqueIdLength);

    return STATUS_SUCCESS;
}


VOID
MigrateRemoteDatabaseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine migrates an old style remote database to the new format
    (just location change for now) on the given volume.

Arguments:

    OaRemoteDatabase       - filled in object attributes for the new remote database volume name.
    OaRemoteDatabaseLegacy - filled in object attributes for the new remote database volume name.


Return Value:

    A handle to the remote database or NULL.

--*/

    {
    NTSTATUS                            status;
    const ULONG                         copyChunkSize      = 512;
    PREMOTE_DATABASE_MIGRATION_CONTEXT  migrationContext   = Context;
    PMOUNTED_DEVICE_INFORMATION         deviceInfo         = migrationContext->DeviceInfo;
    BOOLEAN                             migrationProcessed = FALSE;
    HANDLE                              remoteDatabase     = NULL;
    HANDLE                              remoteDatabaseLegacy = NULL;
    PVOID                               buffer;
    OBJECT_ATTRIBUTES                   oa;
    OBJECT_ATTRIBUTES                   oaLegacy;
    UNICODE_STRING                      fileName;
    UNICODE_STRING                      fileNameLegacy;
    IO_STATUS_BLOCK                     ioStatus;
    LARGE_INTEGER                       fileOffset;
    ULONG                               readBytes;
    FILE_DISPOSITION_INFORMATION        DispositionInformation;



    fileName.Length              = deviceInfo->DeviceName.Length + RemoteDatabaseFileName.Length;
    fileNameLegacy.Length        = deviceInfo->DeviceName.Length + RemoteDatabaseFileNameLegacy.Length;

    fileName.MaximumLength       = fileName.Length + sizeof(WCHAR);
    fileNameLegacy.MaximumLength = fileNameLegacy.Length + sizeof(WCHAR);

    fileName.Buffer              = ExAllocatePoolWithTag (PagedPool, fileName.MaximumLength,       MOUNTMGR_TAG_BUFFER);
    fileNameLegacy.Buffer        = ExAllocatePoolWithTag (PagedPool, fileNameLegacy.MaximumLength, MOUNTMGR_TAG_BUFFER);
    buffer                       = ExAllocatePoolWithTag (PagedPool, copyChunkSize,                MOUNTMGR_TAG_BUFFER);

    status = ((NULL == buffer)          || 
              (NULL == fileName.Buffer) || 
              (NULL == fileNameLegacy.Buffer))
        ? STATUS_INSUFFICIENT_RESOURCES
        : STATUS_SUCCESS;



    if (NT_SUCCESS (status)) {

        status = RtlCreateSystemVolumeInformationFolder (&deviceInfo->DeviceName);
    }



    if (NT_SUCCESS (status)) {

        RtlCopyMemory (fileName.Buffer, 
                       deviceInfo->DeviceName.Buffer, 
                       deviceInfo->DeviceName.Length);

        RtlCopyMemory (fileNameLegacy.Buffer, 
                       deviceInfo->DeviceName.Buffer, 
                       deviceInfo->DeviceName.Length);


        RtlCopyMemory ((PCHAR) fileName.Buffer       + deviceInfo->DeviceName.Length,
                       RemoteDatabaseFileName.Buffer,
                       RemoteDatabaseFileName.Length);

        RtlCopyMemory ((PCHAR) fileNameLegacy.Buffer + deviceInfo->DeviceName.Length,
                       RemoteDatabaseFileNameLegacy.Buffer,
                       RemoteDatabaseFileNameLegacy.Length);


        fileName.Buffer       [fileName.Length       / sizeof (WCHAR)] = UNICODE_NULL;
        fileNameLegacy.Buffer [fileNameLegacy.Length / sizeof (WCHAR)] = UNICODE_NULL;


        InitializeObjectAttributes (&oa, &fileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);

        status = ZwCreateFile (&remoteDatabase, 
                               FILE_GENERIC_READ | FILE_GENERIC_WRITE, 
                               &oa,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                               0,
                               FILE_CREATE,
                               FILE_SYNCHRONOUS_IO_ALERT | FILE_NON_DIRECTORY_FILE,
                               NULL,
                               0);

        if (!NT_SUCCESS (status)) {
            remoteDatabase = NULL;
        }
    }
    


    if (NT_SUCCESS (status)) {

        InitializeObjectAttributes (&oaLegacy, &fileNameLegacy, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);

        status = ZwCreateFile (&remoteDatabaseLegacy, 
                               FILE_GENERIC_READ | FILE_GENERIC_WRITE, 
                               &oaLegacy,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                               0,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_ALERT | FILE_NON_DIRECTORY_FILE,
                               NULL,
                               0);

        if (!NT_SUCCESS (status)) {
            remoteDatabaseLegacy = NULL;
        }

        if (STATUS_OBJECT_NAME_NOT_FOUND == status) {

            /*
            ** Failing to open the old database is not considered an
            ** error. It just means that there is nothing to migrate
            ** so we are done. Other errors are real errors.
            */
            status             = STATUS_SUCCESS;
            migrationProcessed = TRUE;
        }
    }
            



    if (NT_SUCCESS (status) && !migrationProcessed) {

        /*
        ** We have a new (empty) database and an old one. If there is
        ** stuff in the old one move it over.
        */
        fileOffset.QuadPart  = 0;


        while (NT_SUCCESS (status)) {
            status = ZwReadFile (remoteDatabaseLegacy,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &ioStatus,
                                 buffer,
                                 copyChunkSize,
                                 &fileOffset,
                                 NULL);

            if (NT_SUCCESS (status)) {

                readBytes = (ULONG)ioStatus.Information;

                status = ZwWriteFile (remoteDatabase,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &ioStatus,
                                      buffer,
                                      readBytes,
                                      &fileOffset,
                                      NULL);

                fileOffset.QuadPart  += readBytes;
            }
        }



        if (STATUS_END_OF_FILE == status) {
            status = STATUS_SUCCESS;

            RtlZeroMemory (&DispositionInformation, sizeof(DispositionInformation));

            DispositionInformation.DeleteFile = TRUE;

            status = ZwSetInformationFile (remoteDatabaseLegacy,
                                           &ioStatus,
                                           &DispositionInformation,
                                           sizeof (DispositionInformation),
                                           FileDispositionInformation);

        }
    }



    if (NULL != buffer) {
        ExFreePool (buffer);
    }


    if (NULL != fileNameLegacy.Buffer) {
        ExFreePool(fileNameLegacy.Buffer);
    }


    if (NULL != fileName.Buffer) {
        ExFreePool(fileName.Buffer);
    }


    if (NULL != remoteDatabaseLegacy) {
        ZwClose (remoteDatabaseLegacy);
    }


    if (NT_SUCCESS (status)) {

        deviceInfo->RemoteDatabaseMigrated = TRUE;

    } else if (NULL != remoteDatabase) {

        ZwClose (remoteDatabase);
        remoteDatabase = NULL;
    }



    IoFreeWorkItem (migrationContext->WorkItem);

    migrationContext->WorkItem = NULL;
    migrationContext->Status   = status;
    migrationContext->Handle   = remoteDatabase;

    KeSetEvent (migrationContext->MigrationProcessedEvent, 0, FALSE);

    return;
}


NTSTATUS
MigrateRemoteDatabase (
    IN  PMOUNTED_DEVICE_INFORMATION     DeviceInfo,
    OUT PHANDLE                         RemoteDatabaseHandle
    )

/*++

Routine Description:

    This routine invokes MigrateRemoteDatabaseWorker() using a work item
    to migrate the legacy style remote database to the new replacement form.


Arguments:

    DeviceInfo                  - device information

    RemoteDatabaseHandle        - returns the handle to the opened remote database


Return Value:

    NTSTATUS

--*/

    {
    NTSTATUS                           status           = STATUS_SUCCESS;
    PREMOTE_DATABASE_MIGRATION_CONTEXT migrationContext = NULL;
    KEVENT                             migrationProcessed;


    KeInitializeEvent (&migrationProcessed, NotificationEvent, FALSE);

    migrationContext = ExAllocatePool (NonPagedPool, 
                                       sizeof (REMOTE_DATABASE_MIGRATION_CONTEXT));


    if (NULL == migrationContext) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }



    if (NT_SUCCESS (status)) {
        RtlZeroMemory (migrationContext, sizeof (*migrationContext));

        migrationContext->MigrationProcessedEvent = &migrationProcessed;
        migrationContext->DeviceInfo              = DeviceInfo;
        migrationContext->WorkItem                = IoAllocateWorkItem (DeviceInfo->Extension->DeviceObject);

        if (NULL == migrationContext->WorkItem) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    if (NT_SUCCESS (status)) {
        IoQueueWorkItem (migrationContext->WorkItem, 
                         MigrateRemoteDatabaseWorker, 
                         DelayedWorkQueue,
                         migrationContext);

        KeWaitForSingleObject (&migrationProcessed, Executive, KernelMode, FALSE, NULL);

        status = migrationContext->Status;
    }


    *RemoteDatabaseHandle = (NT_SUCCESS (status))
                             ? migrationContext->Handle
                             : NULL;


    if (NULL != migrationContext) {
        ExFreePool (migrationContext);
    }


    return (status);
    }


HANDLE
OpenRemoteDatabase(
    IN  PMOUNTED_DEVICE_INFORMATION     DeviceInfo,
    IN  BOOLEAN                         Create
    )

/*++

Routine Description:

    This routine opens the remote database on the given volume.

Arguments:

    DeviceInfo  - Supplies the device information.

    Create      - Supplies whether or not to create.

Return Value:

    A handle to the remote database or NULL.

--*/

{
    UNICODE_STRING      fileName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status         = STATUS_SUCCESS;
    HANDLE              remoteDatabase = NULL;
    IO_STATUS_BLOCK     ioStatus;
    BOOLEAN             attemptFileOpenIf;


    fileName.Length        = DeviceInfo->DeviceName.Length + RemoteDatabaseFileName.Length;
    fileName.MaximumLength = fileName.Length + sizeof(WCHAR);
    fileName.Buffer        = ExAllocatePool (PagedPool, fileName.MaximumLength);

    if (NULL == fileName.Buffer) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }



    if (NT_SUCCESS (status)) {

        RtlCopyMemory (fileName.Buffer, 
                       DeviceInfo->DeviceName.Buffer, 
                       DeviceInfo->DeviceName.Length);

        RtlCopyMemory ((PCHAR) fileName.Buffer + DeviceInfo->DeviceName.Length,
                       RemoteDatabaseFileName.Buffer,
                       RemoteDatabaseFileName.Length);

        fileName.Buffer [fileName.Length / sizeof (WCHAR)] = UNICODE_NULL;


        InitializeObjectAttributes(&oa, &fileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);


        /*
        ** If we have already migrated the database then we can
        ** attempt the create here if asked to do so
        */
        attemptFileOpenIf = Create && DeviceInfo->RemoteDatabaseMigrated;

        /*
        ** Create the remote database file. If we fail to create the 
        ** file because the SystemVolumeInformation folder is not present,
        ** this is the case after formatting the volume, then
        ** MigrateRemoteDatabase will run and create the folder.
        */
        status = ZwCreateFile (&remoteDatabase, 
                               FILE_GENERIC_READ | FILE_GENERIC_WRITE, 
                               &oa,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                               0,
                               attemptFileOpenIf ? FILE_OPEN_IF : FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_ALERT | FILE_NON_DIRECTORY_FILE,
                               NULL,
                               0);


        if (Create               && 
            !NT_SUCCESS (status)  ) {

            /*
            ** This call will attempt to create the SystemVolumeInformation 
            ** folder, if it doesn't exist, before creating the DB file.
            */
            status = MigrateRemoteDatabase (DeviceInfo, &remoteDatabase);
        }
    }



    if (NULL != fileName.Buffer) {
        ExFreePool(fileName.Buffer);
    }
    

    return (remoteDatabase);
}

ULONG
GetRemoteDatabaseSize(
    IN  HANDLE  RemoteDatabaseHandle
    )

/*++

Routine Description:

    This routine returns the length of the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

Return Value:

    The length of the remote database or 0.

--*/

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    FILE_STANDARD_INFORMATION   info;

    status = ZwQueryInformationFile(RemoteDatabaseHandle, &ioStatus, &info,
                                    sizeof(info), FileStandardInformation);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    return info.EndOfFile.LowPart;
}

VOID
CloseRemoteDatabase(
    IN  HANDLE  RemoteDatabaseHandle
    )

/*++

Routine Description:

    This routine closes the given remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

Return Value:

    None.

--*/

{
    ULONG                           fileLength;
    FILE_DISPOSITION_INFORMATION    disp;
    IO_STATUS_BLOCK                 ioStatus;

    fileLength = GetRemoteDatabaseSize(RemoteDatabaseHandle);
    if (!fileLength) {
        disp.DeleteFile = TRUE;
        ZwSetInformationFile(RemoteDatabaseHandle, &ioStatus, &disp,
                             sizeof(disp), FileDispositionInformation);
    }

    ZwClose(RemoteDatabaseHandle);
}

NTSTATUS
TruncateRemoteDatabase(
    IN  HANDLE  RemoteDatabaseHandle,
    IN  ULONG   FileOffset
    )

/*++

Routine Description:

    This routine truncates the remote database at the given file offset.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

Return Value:

    NTSTATUS

--*/

{
    FILE_END_OF_FILE_INFORMATION    endOfFileInfo;
    FILE_ALLOCATION_INFORMATION     allocationInfo;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 ioStatus;

    endOfFileInfo.EndOfFile.QuadPart = FileOffset;
    allocationInfo.AllocationSize.QuadPart = FileOffset;

    status = ZwSetInformationFile(RemoteDatabaseHandle, &ioStatus,
                                  &endOfFileInfo, sizeof(endOfFileInfo),
                                  FileEndOfFileInformation);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwSetInformationFile(RemoteDatabaseHandle, &ioStatus,
                                  &allocationInfo, sizeof(allocationInfo),
                                  FileAllocationInformation);

    return status;
}

PMOUNTMGR_FILE_ENTRY
GetRemoteDatabaseEntry(
    IN  HANDLE  RemoteDatabaseHandle,
    IN  ULONG   FileOffset
    )

/*++

Routine Description:

    This routine gets the next database entry.  This routine fixes
    corruption as it finds it.  The memory returned from this routine
    must be freed with ExFreePool.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

Return Value:

    A pointer to the next remote database entry.

--*/

{
    LARGE_INTEGER           offset;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;
    ULONG                   size;
    PMOUNTMGR_FILE_ENTRY    entry;
    ULONG                   len1, len2, len;

    offset.QuadPart = FileOffset;
    status = ZwReadFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                        &size, sizeof(size), &offset, NULL);
    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    if (!size) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        return NULL;
    }

    entry = ExAllocatePool(PagedPool, size);
    if (!entry) {
        return NULL;
    }

    status = ZwReadFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                        entry, size, &offset, NULL);
    if (!NT_SUCCESS(status)) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    if (ioStatus.Information < size) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    if (size < sizeof(MOUNTMGR_FILE_ENTRY)) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    len1 = entry->VolumeNameOffset + entry->VolumeNameLength;
    len2 = entry->UniqueIdOffset + entry->UniqueIdLength;
    len = len1 > len2 ? len1 : len2;

    if (len > size) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    return entry;
}

NTSTATUS
WriteRemoteDatabaseEntry(
    IN  HANDLE                  RemoteDatabaseHandle,
    IN  ULONG                   FileOffset,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine write the given database entry at the given file offset
    to the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

    DatabaseEntry           - Supplies the database entry.

Return Value:

    NTSTATUS

--*/

{
    LARGE_INTEGER   offset;
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    offset.QuadPart = FileOffset;
    status = ZwWriteFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                         DatabaseEntry, DatabaseEntry->EntryLength,
                         &offset, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (ioStatus.Information < DatabaseEntry->EntryLength) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

NTSTATUS
DeleteRemoteDatabaseEntry(
    IN  HANDLE  RemoteDatabaseHandle,
    IN  ULONG   FileOffset
    )

/*++

Routine Description:

    This routine deletes the database entry at the given file offset
    in the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

Return Value:

    NTSTATUS

--*/

{
    ULONG                   fileSize;
    PMOUNTMGR_FILE_ENTRY    entry;
    LARGE_INTEGER           offset;
    ULONG                   size;
    PVOID                   buffer;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;

    fileSize = GetRemoteDatabaseSize(RemoteDatabaseHandle);
    if (!fileSize) {
        return STATUS_INVALID_PARAMETER;
    }

    entry = GetRemoteDatabaseEntry(RemoteDatabaseHandle, FileOffset);
    if (!entry) {
        return STATUS_INVALID_PARAMETER;
    }

    if (FileOffset + entry->EntryLength >= fileSize) {
        ExFreePool(entry);
        return TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
    }

    size = fileSize - FileOffset - entry->EntryLength;
    buffer = ExAllocatePool(PagedPool, size);
    if (!buffer) {
        ExFreePool(entry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset.QuadPart = FileOffset + entry->EntryLength;
    ExFreePool(entry);

    status = ZwReadFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                        buffer, size, &offset, NULL);
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return status;
    }

    if (ioStatus.Information < size) {
        ExFreePool(buffer);
        return STATUS_INVALID_PARAMETER;
    }

    status = TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return status;
    }

    offset.QuadPart = FileOffset;
    status = ZwWriteFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                         buffer, size, &offset, NULL);

    ExFreePool(buffer);

    return status;
}

NTSTATUS
AddRemoteDatabaseEntry(
    IN  HANDLE                  RemoteDatabaseHandle,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine adds a new database entry to the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    DatabaseEntry           - Supplies the database entry.

Return Value:

    NTSTATUS

--*/

{
    ULONG           fileSize;
    LARGE_INTEGER   offset;
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    fileSize = GetRemoteDatabaseSize(RemoteDatabaseHandle);
    offset.QuadPart = fileSize;
    status = ZwWriteFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                         DatabaseEntry, DatabaseEntry->EntryLength, &offset,
                         NULL);

    return status;
}

VOID
ChangeRemoteDatabaseUniqueId(
    IN  PMOUNTED_DEVICE_INFORMATION     DeviceInfo,
    IN  PMOUNTDEV_UNIQUE_ID             OldUniqueId,
    IN  PMOUNTDEV_UNIQUE_ID             NewUniqueId
    )

/*++

Routine Description:

    This routine changes the unique id in the remote database.

Arguments:

    DeviceInfo          - Supplies the device information.

    OldUniqueId         - Supplies the old unique id.

    NewUniqueId         - Supplies the new unique id.

Return Value:

    None.

--*/

{
    HANDLE                  h;
    ULONG                   offset, newSize;
    PMOUNTMGR_FILE_ENTRY    databaseEntry, newDatabaseEntry;
    NTSTATUS                status;

    h = OpenRemoteDatabase(DeviceInfo, FALSE);
    if (!h) {
        return;
    }

    offset = 0;
    for (;;) {

        databaseEntry = GetRemoteDatabaseEntry(h, offset);
        if (!databaseEntry) {
            break;
        }

        if (databaseEntry->UniqueIdLength != OldUniqueId->UniqueIdLength ||
            RtlCompareMemory(OldUniqueId->UniqueId,
                             (PCHAR) databaseEntry +
                             databaseEntry->UniqueIdOffset,
                             databaseEntry->UniqueIdLength) !=
                             databaseEntry->UniqueIdLength) {

            offset += databaseEntry->EntryLength;
            ExFreePool(databaseEntry);
            continue;
        }

        newSize = databaseEntry->EntryLength + NewUniqueId->UniqueIdLength -
                  OldUniqueId->UniqueIdLength;

        newDatabaseEntry = ExAllocatePool(PagedPool, newSize);
        if (!newDatabaseEntry) {
            offset += databaseEntry->EntryLength;
            ExFreePool(databaseEntry);
            continue;
        }

        newDatabaseEntry->EntryLength = newSize;
        newDatabaseEntry->RefCount = databaseEntry->RefCount;
        newDatabaseEntry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
        newDatabaseEntry->VolumeNameLength = databaseEntry->VolumeNameLength;
        newDatabaseEntry->UniqueIdOffset = newDatabaseEntry->VolumeNameOffset +
                                           newDatabaseEntry->VolumeNameLength;
        newDatabaseEntry->UniqueIdLength = NewUniqueId->UniqueIdLength;

        RtlCopyMemory((PCHAR) newDatabaseEntry +
                      newDatabaseEntry->VolumeNameOffset,
                      (PCHAR) databaseEntry + databaseEntry->VolumeNameOffset,
                      newDatabaseEntry->VolumeNameLength);
        RtlCopyMemory((PCHAR) newDatabaseEntry +
                      newDatabaseEntry->UniqueIdOffset,
                      NewUniqueId->UniqueId, newDatabaseEntry->UniqueIdLength);

        status = DeleteRemoteDatabaseEntry(h, offset);
        if (!NT_SUCCESS(status)) {
            ExFreePool(databaseEntry);
            ExFreePool(newDatabaseEntry);
            break;
        }

        status = AddRemoteDatabaseEntry(h, newDatabaseEntry);
        if (!NT_SUCCESS(status)) {
            ExFreePool(databaseEntry);
            ExFreePool(newDatabaseEntry);
            break;
        }

        ExFreePool(newDatabaseEntry);
        ExFreePool(databaseEntry);
    }

    CloseRemoteDatabase(h);
}

NTSTATUS
WaitForRemoteDatabaseSemaphore(
    IN  PDEVICE_EXTENSION   Extension
    )

{
    LARGE_INTEGER   timeout;
    NTSTATUS        status;

    timeout.QuadPart = -10*1000*1000*10;
    status = KeWaitForSingleObject(&Extension->RemoteDatabaseSemaphore,
                                   Executive, KernelMode, FALSE, &timeout);
    if (status == STATUS_TIMEOUT) {
        status = STATUS_IO_TIMEOUT;
    }

    return status;
}

VOID
ReleaseRemoteDatabaseSemaphore(
    IN  PDEVICE_EXTENSION   Extension
    )

{
    KeReleaseSemaphore(&Extension->RemoteDatabaseSemaphore, IO_NO_INCREMENT,
                       1, FALSE);
}

VOID
MountMgrUniqueIdChangeRoutine(
    IN  PVOID               Context,
    IN  PMOUNTDEV_UNIQUE_ID OldUniqueId,
    IN  PMOUNTDEV_UNIQUE_ID NewUniqueId
    )

/*++

Routine Description:

    This routine is called from a mounted device to notify of a unique
    id change.

Arguments:

    MountedDevice                   - Supplies the mounted device.

    MountMgrUniqueIdChangeRoutine   - Supplies the id change routine.

    Context                         - Supplies the context for this routine.

Return Value:

    None.

--*/

{
    NTSTATUS                    status;
    PDEVICE_EXTENSION           extension = Context;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PVOID                       p;
    BOOLEAN                     changedIds;

    status = WaitForRemoteDatabaseSemaphore(extension);

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = ChangeUniqueIdRoutine;
    queryTable[0].EntryContext = NewUniqueId;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, OldUniqueId, NULL);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);
        if (OldUniqueId->UniqueIdLength !=
            deviceInfo->UniqueId->UniqueIdLength) {

            continue;
        }

        if (RtlCompareMemory(OldUniqueId->UniqueId,
                             deviceInfo->UniqueId->UniqueId,
                             OldUniqueId->UniqueIdLength) !=
                             OldUniqueId->UniqueIdLength) {

            continue;
        }

        break;
    }

    if (l == &extension->MountedDeviceList) {
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        if (NT_SUCCESS(status)) {
            ReleaseRemoteDatabaseSemaphore(extension);
        }
        return;
    }

    if (!NT_SUCCESS(status)) {
        ReconcileThisDatabaseWithMaster(extension, deviceInfo);
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        return;
    }

    p = ExAllocatePool(PagedPool, NewUniqueId->UniqueIdLength +
                       sizeof(MOUNTDEV_UNIQUE_ID));
    if (!p) {
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(extension);
        return;
    }
    ExFreePool(deviceInfo->UniqueId);
    deviceInfo->UniqueId = p;

    deviceInfo->UniqueId->UniqueIdLength = NewUniqueId->UniqueIdLength;
    RtlCopyMemory(deviceInfo->UniqueId->UniqueId,
                  NewUniqueId->UniqueId, NewUniqueId->UniqueIdLength);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        changedIds = FALSE;
        for (ll = deviceInfo->ReplicatedUniqueIds.Flink;
             ll != &deviceInfo->ReplicatedUniqueIds; ll = ll->Flink) {

            replUniqueId = CONTAINING_RECORD(ll, REPLICATED_UNIQUE_ID,
                                             ListEntry);

            if (replUniqueId->UniqueId->UniqueIdLength !=
                OldUniqueId->UniqueIdLength) {

                continue;
            }

            if (RtlCompareMemory(replUniqueId->UniqueId->UniqueId,
                                 OldUniqueId->UniqueId,
                                 OldUniqueId->UniqueIdLength) !=
                                 OldUniqueId->UniqueIdLength) {

                continue;
            }

            p = ExAllocatePool(PagedPool, NewUniqueId->UniqueIdLength +
                               sizeof(MOUNTDEV_UNIQUE_ID));
            if (!p) {
                continue;
            }

            changedIds = TRUE;

            ExFreePool(replUniqueId->UniqueId);
            replUniqueId->UniqueId = p;

            replUniqueId->UniqueId->UniqueIdLength =
                    NewUniqueId->UniqueIdLength;
            RtlCopyMemory(replUniqueId->UniqueId->UniqueId,
                          NewUniqueId->UniqueId, NewUniqueId->UniqueIdLength);
        }

        if (changedIds) {
            ChangeRemoteDatabaseUniqueId(deviceInfo, OldUniqueId, NewUniqueId);
        }
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
    ReleaseRemoteDatabaseSemaphore(extension);
}

VOID
SendLinkCreated(
    IN  PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine alerts the mounted device that one of its links has
    been created

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name being deleted.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject      = NULL;
    ULONG               inputSize         = sizeof(USHORT) + SymbolicLinkName->Length;
    PMOUNTDEV_NAME      input             = NULL;
    BOOLEAN             objectsReferenced = FALSE;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;


    status = IoGetDeviceObjectPointer (SymbolicLinkName, 
                                       FILE_READ_ATTRIBUTES,
                                       &fileObject,
                                       &deviceObject);
    
    if (NT_SUCCESS (status)) {

        deviceObject = IoGetAttachedDeviceReference (fileObject->DeviceObject);

        objectsReferenced = TRUE;


        input = ExAllocatePool (PagedPool, inputSize);

        if (!input) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }



    if (NT_SUCCESS (status)) {
        input->NameLength = SymbolicLinkName->Length;

        RtlCopyMemory (input->Name,
                       SymbolicLinkName->Buffer,
                       SymbolicLinkName->Length);



        /*
        ** First send the notification using the standard IOCTL. When
        ** that's done we'll send another using the obsolete IOCTL for
        ** all those third parties who have yet to recompile.
        */
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest (IOCTL_MOUNTDEV_LINK_CREATED,
                                             deviceObject,
                                             input,
                                             inputSize,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &ioStatus);

        if (NULL != irp) {

            irpSp = IoGetNextIrpStackLocation (irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver (deviceObject, irp);

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
            }
        }



        /*
        ** Now the 'obsolete' non-protected IOCTL
        */
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest (IOCTL_MOUNTDEV_LINK_CREATED_OBSOLETE,
                                             deviceObject,
                                             input,
                                             inputSize,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &ioStatus);

        if (NULL != irp) {

            irpSp = IoGetNextIrpStackLocation (irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver (deviceObject, irp);

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
            }
        }
    }



    if (NULL != input) {
        ExFreePool (input);
    }

    if (objectsReferenced) {
        ObDereferenceObject (deviceObject);
        ObDereferenceObject (fileObject);
    }


    return;
}

VOID
CreateNoDriveLetterEntry(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine creates a "no drive letter" entry for the given device.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    UUID                uuid;
    UNICODE_STRING      guidString;
    PWSTR               valueName;

    status = ExUuidCreate(&uuid);
    if (!NT_SUCCESS(status)) {
        return;
    }

    status = RtlStringFromGUID(&uuid, &guidString);
    if (!NT_SUCCESS(status)) {
        return;
    }

    valueName = ExAllocatePool(PagedPool, guidString.Length + 2*sizeof(WCHAR));
    if (!valueName) {
        ExFreePool(guidString.Buffer);
        return;
    }

    valueName[0] = '#';
    RtlCopyMemory(&valueName[1], guidString.Buffer, guidString.Length);
    valueName[1 + guidString.Length/sizeof(WCHAR)] = 0;
    ExFreePool(guidString.Buffer);

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                          valueName, REG_BINARY, UniqueId->UniqueId,
                          UniqueId->UniqueIdLength);

    ExFreePool(valueName);
}

NTSTATUS
CreateNewDriveLetterName(
    OUT PUNICODE_STRING     DriveLetterName,
    IN  PUNICODE_STRING     TargetName,
    IN  UCHAR               SuggestedDriveLetter,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine creates a new name of the form \DosDevices\D:.

Arguments:

    DriveLetterName         - Returns the drive letter name.

    TargetName              - Supplies the target object.

    SuggestedDriveLetter    - Supplies the suggested drive letter.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                status;
    UCHAR                   driveLetter;

    DriveLetterName->MaximumLength = 30;
    DriveLetterName->Buffer = ExAllocatePool(PagedPool,
                                             DriveLetterName->MaximumLength);
    if (!DriveLetterName->Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(DriveLetterName, &DosDevices);

    DriveLetterName->Length = 28;
    DriveLetterName->Buffer[14] = 0;
    DriveLetterName->Buffer[13] = ':';

    if (SuggestedDriveLetter == 0xFF) {
        CreateNoDriveLetterEntry(UniqueId);
        ExFreePool(DriveLetterName->Buffer);
        return STATUS_UNSUCCESSFUL;
    } else if (SuggestedDriveLetter) {
        DriveLetterName->Buffer[12] = SuggestedDriveLetter;
        status = GlobalCreateSymbolicLink(DriveLetterName, TargetName);
        if (NT_SUCCESS(status)) {
            return status;
        }
    }

    if (RtlPrefixUnicodeString(&DeviceFloppy, TargetName, TRUE)) {
        driveLetter = 'A';
    } else if (RtlPrefixUnicodeString(&DeviceCdRom, TargetName, TRUE)) {
        driveLetter = 'D';
    } else {
        driveLetter = 'C';
    }

    for (; driveLetter <= 'Z'; driveLetter++) {
        DriveLetterName->Buffer[12] = driveLetter;

        status = GlobalCreateSymbolicLink(DriveLetterName, TargetName);
        if (NT_SUCCESS(status)) {
            return status;
        }
    }

    ExFreePool(DriveLetterName->Buffer);

    return status;
}

NTSTATUS
CheckForNoDriveLetterEntry(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine checks for the presence of the "no drive letter" entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Returns whether or not there is a "no drive letter" entry.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;

    if (ValueName[0] != '#' || ValueType != REG_BINARY ||
        ValueLength != uniqueId->UniqueIdLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    *((PBOOLEAN) EntryContext) = TRUE;

    return STATUS_SUCCESS;
}

BOOLEAN
HasNoDriveLetterEntry(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine determines whether or not the given device has an
    entry indicating that it should not receice a drive letter.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    FALSE   - The device does not have a "no drive letter" entry.

    TRUE    - The device has a "no drive letter" entry.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    BOOLEAN                     hasNoDriveLetterEntry;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = CheckForNoDriveLetterEntry;
    queryTable[0].EntryContext = &hasNoDriveLetterEntry;

    hasNoDriveLetterEntry = FALSE;
    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);

    return hasNoDriveLetterEntry;
}

typedef struct _CHANGE_NOTIFY_WORK_ITEM {
    LIST_ENTRY          List; // Chained to the extension via this for unload
    PIO_WORKITEM        WorkItem;
    PDEVICE_EXTENSION   Extension;
    PIRP                Irp;
    PVOID               SystemBuffer;
    PFILE_OBJECT        FileObject;
    PKEVENT             Event;
    UNICODE_STRING      DeviceName;
    ULONG               OutputSize;
    CCHAR               StackSize;
} CHANGE_NOTIFY_WORK_ITEM, *PCHANGE_NOTIFY_WORK_ITEM;

VOID
RemoveWorkItem(
    IN  PCHANGE_NOTIFY_WORK_ITEM    WorkItem
    )
/*++

Routine Description:

    This routine removes a work item if its still chained to the device extension and frees it if needed or
    wakes up the waiter if unload is trying to cancel these operations.

Arguments:

    WorkItem    - Supplies the work item.

Return Value:

    None.

--*/
{
    KeWaitForSingleObject(&WorkItem->Extension->Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    if (WorkItem->Event == NULL) {
        RemoveEntryList (&WorkItem->List);

        KeReleaseSemaphore(&WorkItem->Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        IoFreeIrp(WorkItem->Irp);
        ExFreePool(WorkItem->DeviceName.Buffer);
        ExFreePool(WorkItem->SystemBuffer);
        ExFreePool(WorkItem);
    } else {
        KeReleaseSemaphore(&WorkItem->Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        KeSetEvent(WorkItem->Event, 0, FALSE);
    }
}

VOID
IssueUniqueIdChangeNotifyWorker(
    IN  PCHANGE_NOTIFY_WORK_ITEM    WorkItem,
    IN  PMOUNTDEV_UNIQUE_ID         UniqueId
    )

/*++

Routine Description:

    This routine issues a change notify request to the given mounted device.

Arguments:

    WorkItem    - Supplies the work item.

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    ULONG               inputSize;
    PIO_STACK_LOCATION  irpSp;

    status = IoGetDeviceObjectPointer(&WorkItem->DeviceName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        RemoveWorkItem (WorkItem);
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    WorkItem->FileObject = fileObject;

    irp = WorkItem->Irp;
    IoInitializeIrp(irp, IoSizeOfIrp(WorkItem->StackSize),
                    WorkItem->StackSize);

    //
    // IoCancelIrp could have been called by the unload code and the cancel flag over written by the call
    // above. To handle this case we check the work item to see if the event address has been set up.
    // We do this with an interlocked sequence (that does nothing) to make sure the ordering is preserved.
    // We don't want the read of the pointer field to be earlier than the IRP initializing code above.
    //
    if (InterlockedCompareExchangePointer (&WorkItem->Event, NULL, NULL) != NULL) {
        ObDereferenceObject(fileObject);
        ObDereferenceObject(deviceObject);
        RemoveWorkItem (WorkItem);
        return;
    }

    irp->AssociatedIrp.SystemBuffer = WorkItem->SystemBuffer;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    inputSize = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
                UniqueId->UniqueIdLength;

    RtlCopyMemory(irp->AssociatedIrp.SystemBuffer, UniqueId, inputSize);

    irpSp = IoGetNextIrpStackLocation(irp);


    irpSp->Parameters.DeviceIoControl.InputBufferLength  = inputSize;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = WorkItem->OutputSize;
    irpSp->Parameters.DeviceIoControl.IoControlCode      = 
            IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer   = NULL;
    irpSp->MajorFunction                                 = IRP_MJ_DEVICE_CONTROL;
    irpSp->DeviceObject                                  = deviceObject;

    status = IoSetCompletionRoutineEx (WorkItem->Extension->DeviceObject,
                                       irp,
                                       UniqueIdChangeNotifyCompletion,
                                       WorkItem,
                                       TRUE,
                                       TRUE,
                                       TRUE);
    if (!NT_SUCCESS (status)) {
        ObDereferenceObject(fileObject);
        ObDereferenceObject(deviceObject);
        RemoveWorkItem (WorkItem);
        return;
    }

    IoCallDriver(deviceObject, irp);

    ObDereferenceObject(fileObject);
    ObDereferenceObject(deviceObject);
}

VOID
UniqueIdChangeNotifyWorker(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PVOID          WorkItem
    )

/*++

Routine Description:

    This routine updates the unique id in the database with the new version.

Arguments:

    DeviceObject - Device object
    WorkItem     - Supplies the work item.

Return Value:

    None.

--*/

{
    PCHANGE_NOTIFY_WORK_ITEM                    workItem = WorkItem;
    PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT    output;
    PMOUNTDEV_UNIQUE_ID                         oldUniqueId, newUniqueId;

    if (!NT_SUCCESS(workItem->Irp->IoStatus.Status)) {
        RemoveWorkItem (WorkItem);
        return;
    }

    output = workItem->Irp->AssociatedIrp.SystemBuffer;

    oldUniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                                 output->OldUniqueIdLength);
    if (!oldUniqueId) {
        RemoveWorkItem (WorkItem);
        return;
    }

    oldUniqueId->UniqueIdLength = output->OldUniqueIdLength;
    RtlCopyMemory(oldUniqueId->UniqueId, (PCHAR) output +
                  output->OldUniqueIdOffset, oldUniqueId->UniqueIdLength);

    newUniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                                 output->NewUniqueIdLength);
    if (!newUniqueId) {
        ExFreePool(oldUniqueId);
        RemoveWorkItem (WorkItem);
        return;
    }

    newUniqueId->UniqueIdLength = output->NewUniqueIdLength;
    RtlCopyMemory(newUniqueId->UniqueId, (PCHAR) output +
                  output->NewUniqueIdOffset, newUniqueId->UniqueIdLength);

    MountMgrUniqueIdChangeRoutine(workItem->Extension, oldUniqueId,
                                  newUniqueId);

    IssueUniqueIdChangeNotifyWorker(workItem, newUniqueId);

    ExFreePool(newUniqueId);
    ExFreePool(oldUniqueId);
}

VOID
IssueUniqueIdChangeNotify(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     DeviceName,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine issues a change notify request to the given mounted device.

Arguments:

    Extension   - Supplies the device extension.

    DeviceName  - Supplies a name for the device.

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    NTSTATUS                    status;
    PFILE_OBJECT                fileObject;
    PDEVICE_OBJECT              deviceObject;
    PCHANGE_NOTIFY_WORK_ITEM    workItem;
    ULONG                       outputSize;
    PVOID                       output;
    PIRP                        irp;
    PIO_STACK_LOCATION          irpSp;

    status = IoGetDeviceObjectPointer(DeviceName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    ObDereferenceObject(fileObject);

    workItem = ExAllocatePool(NonPagedPool, sizeof(CHANGE_NOTIFY_WORK_ITEM));
    if (!workItem) {
        ObDereferenceObject(deviceObject);
        return;
    }
    workItem->Event = NULL;
    workItem->WorkItem = IoAllocateWorkItem (Extension->DeviceObject);
    if (workItem->WorkItem == NULL) {
        ObDereferenceObject(deviceObject);
        ExFreePool(workItem);
        return;
    }

    workItem->Extension = Extension;
    workItem->StackSize = deviceObject->StackSize;
    workItem->Irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    ObDereferenceObject(deviceObject);
    if (!workItem->Irp) {
        IoFreeWorkItem (workItem->WorkItem);
        ExFreePool(workItem);
        return;
    }

    outputSize = sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT) + 1024;
    output = ExAllocatePool(NonPagedPool, outputSize);
    if (!output) {
        IoFreeIrp(workItem->Irp);
        IoFreeWorkItem (workItem->WorkItem);
        ExFreePool(workItem);
        return;
    }

    workItem->DeviceName.Length = DeviceName->Length;
    workItem->DeviceName.MaximumLength = workItem->DeviceName.Length +
                                         sizeof(WCHAR);
    workItem->DeviceName.Buffer = ExAllocatePool(NonPagedPool,
                                  workItem->DeviceName.MaximumLength);
    if (!workItem->DeviceName.Buffer) {
        ExFreePool(output);
        IoFreeIrp(workItem->Irp);
        IoFreeWorkItem (workItem->WorkItem);
        ExFreePool(workItem);
        return;
    }

    RtlCopyMemory(workItem->DeviceName.Buffer, DeviceName->Buffer,
                  DeviceName->Length);
    workItem->DeviceName.Buffer[DeviceName->Length/sizeof(WCHAR)] = 0;

    workItem->SystemBuffer = output;
    workItem->OutputSize = outputSize;

    KeWaitForSingleObject(&Extension->Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    InsertTailList (&Extension->UniqueIdChangeNotifyList, &workItem->List);

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    IssueUniqueIdChangeNotifyWorker(workItem, UniqueId);
}

NTSTATUS
QueryVolumeName(
    IN      HANDLE          Handle,
    IN      PLONGLONG       FileReference,
    IN      PUNICODE_STRING DirectoryName,
    IN OUT  PUNICODE_STRING VolumeName,
    OUT     PUNICODE_STRING PathName
    )

/*++

Routine Description:

    This routine returns the volume name contained in the reparse point
    at FileReference.

Arguments:

    Handle          - Supplies a handle to the volume containing the file
                      reference.

    FileReference   - Supplies the file reference.

    VolumeName      - Returns the volume name.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    OBJECT_ATTRIBUTES       oa;
    NTSTATUS                status;
    HANDLE                  h;
    IO_STATUS_BLOCK         ioStatus;
    UNICODE_STRING          fileId;
    PREPARSE_DATA_BUFFER    reparse;
    ULONG                   nameInfoSize;
    PFILE_NAME_INFORMATION  nameInfo;

    if (DirectoryName) {

        InitializeObjectAttributes(&oa, DirectoryName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0,
                                   0);

        status = ZwOpenFile(
            &h, 
            FILE_READ_ATTRIBUTES | SYNCHRONIZE, 
            &oa,
            &ioStatus, 
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
            FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT
            );

    } else {
        fileId.Length = sizeof(LONGLONG);
        fileId.MaximumLength = fileId.Length;
        fileId.Buffer = (PWSTR) FileReference;

        InitializeObjectAttributes(&oa, &fileId, OBJ_KERNEL_HANDLE, Handle, NULL);

        status = ZwOpenFile(
            &h, 
            FILE_READ_ATTRIBUTES | SYNCHRONIZE, 
            &oa,
            &ioStatus, 
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
            FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT 
                                    | FILE_SYNCHRONOUS_IO_NONALERT
            );
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    reparse = ExAllocatePool(PagedPool, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        ZwClose(h);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                             FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                             MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!NT_SUCCESS(status)) {
        ExFreePool(reparse);
        ZwClose(h);
        return status;
    }

    if (reparse->MountPointReparseBuffer.SubstituteNameLength + sizeof(WCHAR) >
        VolumeName->MaximumLength) {

        ExFreePool(reparse);
        ZwClose(h);
        return STATUS_BUFFER_TOO_SMALL;
    }

    VolumeName->Length = reparse->MountPointReparseBuffer.SubstituteNameLength;
    RtlCopyMemory(VolumeName->Buffer,
                  (PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                  reparse->MountPointReparseBuffer.SubstituteNameOffset,
                  VolumeName->Length);

    ExFreePool(reparse);

    if (VolumeName->Buffer[VolumeName->Length/sizeof(WCHAR) - 1] != '\\') {
        ZwClose(h);
        return STATUS_INVALID_PARAMETER;
    }

    VolumeName->Length -= sizeof(WCHAR);
    VolumeName->Buffer[VolumeName->Length/sizeof(WCHAR)] = 0;

    if (!MOUNTMGR_IS_NT_VOLUME_NAME(VolumeName)) {
        ZwClose(h);
        return STATUS_INVALID_PARAMETER;
    }

    nameInfoSize = sizeof(FILE_NAME_INFORMATION);
    nameInfo = ExAllocatePool(PagedPool, nameInfoSize);
    if (!nameInfo) {
        ZwClose(h);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwQueryInformationFile(h, &ioStatus, nameInfo, nameInfoSize,
                                    FileNameInformation);
    if (status == STATUS_BUFFER_OVERFLOW) {
        nameInfoSize = sizeof(FILE_NAME_INFORMATION) +
                       nameInfo->FileNameLength;
        ExFreePool(nameInfo);
        nameInfo = ExAllocatePool(PagedPool, nameInfoSize);
        if (!nameInfo) {
            ZwClose(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = ZwQueryInformationFile(h, &ioStatus, nameInfo, nameInfoSize,
                                        FileNameInformation);
    }

    ZwClose(h);

    if (!NT_SUCCESS(status)) {
        ExFreePool(nameInfo);
        return status;
    }

    PathName->Length = (USHORT) nameInfo->FileNameLength;
    PathName->MaximumLength = PathName->Length + sizeof(WCHAR);
    PathName->Buffer = ExAllocatePool(PagedPool, PathName->MaximumLength);
    if (!PathName->Buffer) {
        ExFreePool(nameInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(PathName->Buffer, nameInfo->FileName, PathName->Length);
    PathName->Buffer[PathName->Length/sizeof(WCHAR)] = 0;

    ExFreePool(nameInfo);

    return STATUS_SUCCESS;
}

NTSTATUS
QueryUniqueIdQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId;

    if (ValueLength >= 0x10000) {
        return STATUS_SUCCESS;
    }

    uniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                              ValueLength);
    if (!uniqueId) {
        return STATUS_SUCCESS;
    }

    uniqueId->UniqueIdLength = (USHORT) ValueLength;
    RtlCopyMemory(uniqueId->UniqueId, ValueData, ValueLength);

    *((PMOUNTDEV_UNIQUE_ID*) Context) = uniqueId;

    return STATUS_SUCCESS;
}

NTSTATUS
QueryUniqueIdFromMaster(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PUNICODE_STRING         VolumeName,
    OUT PMOUNTDEV_UNIQUE_ID*    UniqueId
    )

/*++

Routine Description:

    This routine queries the unique id from the master database.

Arguments:

    VolumeName  - Supplies the volume name.

    UniqueId    - Returns the unique id.

Return Value:

    NTSTATUS

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = QueryUniqueIdQueryRoutine;
    queryTable[0].Name = VolumeName->Buffer;

    *UniqueId = NULL;
    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);

    if (!(*UniqueId)) {
        status = FindDeviceInfo(Extension, VolumeName, FALSE, &deviceInfo);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        *UniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                                   deviceInfo->UniqueId->UniqueIdLength);
        if (!*UniqueId) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        (*UniqueId)->UniqueIdLength = deviceInfo->UniqueId->UniqueIdLength;
        RtlCopyMemory((*UniqueId)->UniqueId, deviceInfo->UniqueId->UniqueId,
                      deviceInfo->UniqueId->UniqueIdLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
DeleteDriveLetterRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine deletes the "no drive letter" entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;
    UNICODE_STRING      string;

    if (ValueType != REG_BINARY ||
        ValueLength != uniqueId->UniqueIdLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueName);
    if (IsDriveLetter(&string)) {
        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               ValueName);
    }

    return STATUS_SUCCESS;
}

VOID
DeleteRegistryDriveLetter(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine checks the current database to see if the given unique
    id already has a drive letter.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    FALSE   - The given unique id does not already have a drive letter.

    TRUE    - The given unique id already has a drive letter.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = DeleteDriveLetterRoutine;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);
}

BOOLEAN
HasDriveLetter(
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

/*++

Routine Description:

    This routine computes whether or not the given device has a drive letter.

Arguments:

    DeviceInfo  - Supplies the device information.

Return Value:

    FALSE   - This device does not have a drive letter.

    TRUE    - This device does have a drive letter.

--*/

{
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symEntry;

    for (l = DeviceInfo->SymbolicLinkNames.Flink;
         l != &DeviceInfo->SymbolicLinkNames; l = l->Flink) {

        symEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY, ListEntry);
        if (symEntry->IsInDatabase &&
            IsDriveLetter(&symEntry->SymbolicLinkName)) {

            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
DeleteNoDriveLetterEntryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine deletes the "no drive letter" entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;

    if (ValueName[0] != '#' || ValueType != REG_BINARY ||
        ValueLength != uniqueId->UniqueIdLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           ValueName);

    return STATUS_SUCCESS;
}

VOID
DeleteNoDriveLetterEntry(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine deletes the "no drive letter" entry for the given device.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = DeleteNoDriveLetterEntryRoutine;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);
}

VOID
MountMgrNotifyNameChange(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     DeviceName,
    IN  BOOLEAN             CheckForPdo
    )

/*++

Routine Description:

    This routine performs a target notification on 'DeviceName' to alert
    of a name change on the device.

Arguments:

    Extension   - Supplies the device extension.

    DeviceName  - Supplies the device name.

    CheckForPdo - Supplies whether or not there needs to be a check for PDO
                    status.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                         l;
    PMOUNTED_DEVICE_INFORMATION         deviceInfo;
    NTSTATUS                            status;
    PFILE_OBJECT                        fileObject;
    PDEVICE_OBJECT                      deviceObject;
    KEVENT                              event;
    PIRP                                irp;
    IO_STATUS_BLOCK                     ioStatus;
    PIO_STACK_LOCATION                  irpSp;
    PDEVICE_RELATIONS                   deviceRelations;
    TARGET_DEVICE_CUSTOM_NOTIFICATION   notification;

    if (CheckForPdo) {
        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);

            if (!RtlCompareUnicodeString(DeviceName, &deviceInfo->DeviceName,
                                         TRUE)) {

                break;
            }
        }

        if (l == &Extension->MountedDeviceList || deviceInfo->NotAPdo) {
            return;
        }
    }

    status = IoGetDeviceObjectPointer(DeviceName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(0, deviceObject, NULL, 0, NULL,
                                        0, FALSE, &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp->Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);

    if (!NT_SUCCESS(status)) {
        return;
    }

    deviceRelations = (PDEVICE_RELATIONS) ioStatus.Information;
    if (deviceRelations->Count < 1) {
        ExFreePool(deviceRelations);
        return;
    }

    deviceObject = deviceRelations->Objects[0];
    ExFreePool(deviceRelations);

    notification.Version = 1;
    notification.Size = (USHORT)
                        FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION,
                                     CustomDataBuffer);
    RtlCopyMemory(&notification.Event, &GUID_IO_VOLUME_NAME_CHANGE,
                  sizeof(GUID_IO_VOLUME_NAME_CHANGE));
    notification.FileObject = NULL;
    notification.NameBufferOffset = -1;

    IoReportTargetDeviceChangeAsynchronous(deviceObject, &notification, NULL,
                                           NULL);

    ObDereferenceObject(deviceObject);
}

VOID
SendOnlineNotificationWorker(
    IN  PVOID   Context
    )

{
    PMOUNTMGR_ONLINE_CONTEXT    context = Context;

    SendOnlineNotification(&context->NotificationName);
    ExFreePool(context->NotificationName.Buffer);
    ExFreePool(context);
}

VOID
PostOnlineNotification(
    IN  PUNICODE_STRING NotificationName
    )

{
    PMOUNTMGR_ONLINE_CONTEXT    context;

    context = ExAllocatePool(NonPagedPool, sizeof(MOUNTMGR_ONLINE_CONTEXT));
    if (!context) {
        return;
    }

    ExInitializeWorkItem(&context->WorkItem, SendOnlineNotificationWorker,
                         context);
    context->NotificationName.Length = NotificationName->Length;
    context->NotificationName.MaximumLength =
            context->NotificationName.Length + sizeof(WCHAR);
    context->NotificationName.Buffer = ExAllocatePool(NonPagedPool,
            context->NotificationName.MaximumLength);
    if (!context->NotificationName.Buffer) {
        ExFreePool(context);
        return;
    }

    RtlCopyMemory(context->NotificationName.Buffer, NotificationName->Buffer,
                  context->NotificationName.Length);
    context->NotificationName.Buffer[
            context->NotificationName.Length/sizeof(WCHAR)] = 0;

    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

NTSTATUS
MountMgrCreatePointWorker(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     SymbolicLinkName,
    IN  PUNICODE_STRING     DeviceName
    )

/*++

Routine Description:

    This routine creates a mount point.

Arguments:

    Extension           - Supplies the device extension.

    SymbolicLinkName    - Supplies the symbolic link name.

    DeviceName          - Supplies the device name.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING                  symbolicLinkName, deviceName;
    NTSTATUS                        status;
    UNICODE_STRING                  targetName;
    PMOUNTDEV_UNIQUE_ID             uniqueId;
    PWSTR                           symName;
    PLIST_ENTRY                     l;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo, d;
    PSYMBOLIC_LINK_NAME_ENTRY       symlinkEntry;

    symbolicLinkName = *SymbolicLinkName;
    deviceName = *DeviceName;

    status = QueryDeviceInformation(&deviceName, &targetName, NULL, NULL,
                                    NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (!RtlCompareUnicodeString(&targetName, &deviceInfo->DeviceName,
                                     TRUE)) {

            break;
        }
    }

    symName = ExAllocatePool(PagedPool, symbolicLinkName.Length +
                                        sizeof(WCHAR));
    if (!symName) {
        ExFreePool(targetName.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(symName, symbolicLinkName.Buffer,
                  symbolicLinkName.Length);
    symName[symbolicLinkName.Length/sizeof(WCHAR)] = 0;

    symbolicLinkName.Buffer = symName;
    symbolicLinkName.MaximumLength += sizeof(WCHAR);

    if (l == &Extension->MountedDeviceList) {

        status = QueryDeviceInformation(&deviceName, NULL, &uniqueId, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            ExFreePool(symName);
            ExFreePool(targetName.Buffer);
            return status;
        }

        status = GlobalCreateSymbolicLink(&symbolicLinkName, &targetName);
        if (!NT_SUCCESS(status)) {
            ExFreePool(uniqueId);
            ExFreePool(symName);
            ExFreePool(targetName.Buffer);
            return status;
        }

        if (IsDriveLetter(&symbolicLinkName)) {
            DeleteRegistryDriveLetter(uniqueId);
        }

        status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       MOUNTED_DEVICES_KEY,
                                       symName, REG_BINARY, uniqueId->UniqueId,
                                       uniqueId->UniqueIdLength);

        ExFreePool(uniqueId);
        ExFreePool(symName);
        ExFreePool(targetName.Buffer);

        return status;
    }

    if (IsDriveLetter(&symbolicLinkName) && HasDriveLetter(deviceInfo)) {
        ExFreePool(symName);
        ExFreePool(targetName.Buffer);
        return STATUS_INVALID_PARAMETER;
    }

    status = GlobalCreateSymbolicLink(&symbolicLinkName, &targetName);
    ExFreePool(targetName.Buffer);
    if (!NT_SUCCESS(status)) {
        ExFreePool(symName);
        return status;
    }

    uniqueId = deviceInfo->UniqueId;
    status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                   MOUNTED_DEVICES_KEY,
                                   symName, REG_BINARY, uniqueId->UniqueId,
                                   uniqueId->UniqueIdLength);

    if (!NT_SUCCESS(status)) {
        GlobalDeleteSymbolicLink(&symbolicLinkName);
        ExFreePool(symName);
        return status;
    }

    symlinkEntry = ExAllocatePool(PagedPool, sizeof(SYMBOLIC_LINK_NAME_ENTRY));
    if (!symlinkEntry) {
        GlobalDeleteSymbolicLink(&symbolicLinkName);
        ExFreePool(symName);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    symlinkEntry->SymbolicLinkName.Length = symbolicLinkName.Length;
    symlinkEntry->SymbolicLinkName.MaximumLength =
            symlinkEntry->SymbolicLinkName.Length + sizeof(WCHAR);
    symlinkEntry->SymbolicLinkName.Buffer =
            ExAllocatePool(PagedPool,
                           symlinkEntry->SymbolicLinkName.MaximumLength);
    if (!symlinkEntry->SymbolicLinkName.Buffer) {
        ExFreePool(symlinkEntry);
        GlobalDeleteSymbolicLink(&symbolicLinkName);
        ExFreePool(symName);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(symlinkEntry->SymbolicLinkName.Buffer,
                  symbolicLinkName.Buffer, symbolicLinkName.Length);
    symlinkEntry->SymbolicLinkName.Buffer[
            symlinkEntry->SymbolicLinkName.Length/sizeof(WCHAR)] = 0;
    symlinkEntry->IsInDatabase = TRUE;

    InsertTailList(&deviceInfo->SymbolicLinkNames, &symlinkEntry->ListEntry);

    SendLinkCreated(&symlinkEntry->SymbolicLinkName);

    if (IsDriveLetter(&symbolicLinkName)) {
        DeleteNoDriveLetterEntry(uniqueId);
        if (!deviceInfo->InOfflineList) {
            PostOnlineNotification(&deviceInfo->NotificationName);
        }
    }

    if (MOUNTMGR_IS_NT_VOLUME_NAME(&symbolicLinkName) &&
        Extension->AutomaticDriveLetterAssignment) {

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (d->HasDanglingVolumeMountPoint) {
                ReconcileThisDatabaseWithMaster(Extension, d);
            }
        }
    }

    ExFreePool(symName);

    MountMgrNotify(Extension);

    if (!deviceInfo->NotAPdo) {
        MountMgrNotifyNameChange(Extension, DeviceName, FALSE);
    }

    return status;
}

NTSTATUS
WriteUniqueIdToMaster(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine writes the unique id to the master database.

Arguments:

    Extension       - Supplies the device extension.

    DatabaseEntry   - Supplies the database entry.

    DeviceName      - Supplies the device name.

Return Value:

    NTSTATUS

--*/

{
    PWSTR                       name;
    NTSTATUS                    status;
    UNICODE_STRING              symName;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    name = ExAllocatePool(PagedPool, DatabaseEntry->VolumeNameLength +
                          sizeof(WCHAR));
    if (!name) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(name, (PCHAR) DatabaseEntry +
                  DatabaseEntry->VolumeNameOffset,
                  DatabaseEntry->VolumeNameLength);
    name[DatabaseEntry->VolumeNameLength/sizeof(WCHAR)] = 0;

    status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                                   name, REG_BINARY, (PCHAR) DatabaseEntry +
                                   DatabaseEntry->UniqueIdOffset,
                                   DatabaseEntry->UniqueIdLength);

    ExFreePool(name);

    symName.Length = symName.MaximumLength = DatabaseEntry->VolumeNameLength;
    symName.Buffer = (PWSTR) ((PCHAR) DatabaseEntry +
                              DatabaseEntry->VolumeNameOffset);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (DatabaseEntry->UniqueIdLength ==
            deviceInfo->UniqueId->UniqueIdLength &&
            RtlCompareMemory((PCHAR) DatabaseEntry +
                             DatabaseEntry->UniqueIdOffset,
                             deviceInfo->UniqueId->UniqueId,
                             DatabaseEntry->UniqueIdLength) ==
                             DatabaseEntry->UniqueIdLength) {

            break;
        }
    }

    if (l != &Extension->MountedDeviceList) {
        MountMgrCreatePointWorker(Extension, &symName,
                                  &deviceInfo->DeviceName);
    }

    return status;
}

VOID
UpdateReplicatedUniqueIds(
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo,
    IN  PMOUNTMGR_FILE_ENTRY        DatabaseEntry
    )

/*++

Routine Description:

    This routine updates the list of replicated unique ids in the device info.

Arguments:

    DeviceInfo      - Supplies the device information.

    DatabaseEntry   - Supplies the database entry.

Return Value:

    None.

--*/

{
    PLIST_ENTRY             l;
    PREPLICATED_UNIQUE_ID   replUniqueId;

    for (l = DeviceInfo->ReplicatedUniqueIds.Flink;
         l != &DeviceInfo->ReplicatedUniqueIds; l = l->Flink) {

        replUniqueId = CONTAINING_RECORD(l, REPLICATED_UNIQUE_ID, ListEntry);

        if (replUniqueId->UniqueId->UniqueIdLength ==
            DatabaseEntry->UniqueIdLength &&
            RtlCompareMemory(replUniqueId->UniqueId->UniqueId,
                             (PCHAR) DatabaseEntry +
                             DatabaseEntry->UniqueIdOffset,
                             replUniqueId->UniqueId->UniqueIdLength) ==
                             replUniqueId->UniqueId->UniqueIdLength) {

            break;
        }
    }

    if (l != &DeviceInfo->ReplicatedUniqueIds) {
        return;
    }

    replUniqueId = ExAllocatePool(PagedPool, sizeof(REPLICATED_UNIQUE_ID));
    if (!replUniqueId) {
        return;
    }

    replUniqueId->UniqueId = ExAllocatePool(PagedPool,
                                            sizeof(MOUNTDEV_UNIQUE_ID) +
                                            DatabaseEntry->UniqueIdLength);
    if (!replUniqueId->UniqueId) {
        ExFreePool(replUniqueId);
        return;
    }

    replUniqueId->UniqueId->UniqueIdLength = DatabaseEntry->UniqueIdLength;
    RtlCopyMemory(replUniqueId->UniqueId->UniqueId, (PCHAR) DatabaseEntry +
                  DatabaseEntry->UniqueIdOffset,
                  replUniqueId->UniqueId->UniqueIdLength);

    InsertTailList(&DeviceInfo->ReplicatedUniqueIds, &replUniqueId->ListEntry);
}

BOOLEAN
IsUniqueIdPresent(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine checks to see if the given unique id exists in the system.

Arguments:

    Extension       - Supplies the device extension.

    DatabaseEntry   - Supplies the database entry.

Return Value:

    FALSE   - The unique id is not in the system.

    TRUE    - The unique id is in the system.

--*/

{
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (DatabaseEntry->UniqueIdLength ==
            deviceInfo->UniqueId->UniqueIdLength &&
            RtlCompareMemory((PCHAR) DatabaseEntry +
                             DatabaseEntry->UniqueIdOffset,
                             deviceInfo->UniqueId->UniqueId,
                             DatabaseEntry->UniqueIdLength) ==
                             DatabaseEntry->UniqueIdLength) {

            return TRUE;
        }
    }

    return FALSE;
}

VOID
ReconcileThisDatabaseWithMasterWorker(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine reconciles the remote database with the master database.

Arguments:

    WorkItem    - Supplies the device information.

Return Value:

    None.

--*/

{
    PRECONCILE_WORK_ITEM_INFO       workItem = WorkItem;
    PDEVICE_EXTENSION               Extension;
    PMOUNTED_DEVICE_INFORMATION     DeviceInfo;
    PLIST_ENTRY                     l, ll, s;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo;
    HANDLE                          remoteDatabaseHandle, indexHandle, junctionHandle;
    UNICODE_STRING                  indexName, pathName;
    OBJECT_ATTRIBUTES               oa;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 ioStatus;
    FILE_REPARSE_POINT_INFORMATION  reparseInfo, previousReparseInfo;
    ULONG                           offset;
    PMOUNTMGR_FILE_ENTRY            entry;
    WCHAR                           volumeNameBuffer[MAX_VOLUME_PATH];
    UNICODE_STRING                  volumeName, otherVolumeName;
    BOOLEAN                         restartScan;
    PMOUNTDEV_UNIQUE_ID             uniqueId;
    ULONG                           entryLength;
    REPARSE_INDEX_KEY               reparseKey;
    UNICODE_STRING                  reparseName;
    PMOUNTMGR_MOUNT_POINT_ENTRY     mountPointEntry;
    BOOLEAN                         actualDanglesFound;

    Extension = workItem->Extension;
    DeviceInfo = workItem->DeviceInfo;

    if (Unloading) {
        return;
    }

    status = WaitForRemoteDatabaseSemaphore(Extension);
    if (!NT_SUCCESS(status)) {
        ASSERT(FALSE);
        return;
    }

    if (Unloading) {
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo == DeviceInfo) {
            break;
        }
    }

    if (l == &Extension->MountedDeviceList) {
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    if (DeviceInfo->IsRemovable) {
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    DeviceInfo->ReconcileOnMounts = TRUE;
    DeviceInfo->HasDanglingVolumeMountPoint = TRUE;
    actualDanglesFound = FALSE;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        for (ll = deviceInfo->MountPointsPointingHere.Flink;
             ll != &deviceInfo->MountPointsPointingHere; ll = ll->Flink) {

            mountPointEntry = CONTAINING_RECORD(ll, MOUNTMGR_MOUNT_POINT_ENTRY,
                                                ListEntry);
            if (mountPointEntry->DeviceInfo == DeviceInfo) {
                s = ll->Blink;
                RemoveEntryList(ll);
                ExFreePool(mountPointEntry->MountPath.Buffer);
                ExFreePool(mountPointEntry);
                ll = s;
            }
        }
    }

    remoteDatabaseHandle = OpenRemoteDatabase(DeviceInfo, FALSE);

    indexName.Length = DeviceInfo->DeviceName.Length +
                       ReparseIndexName.Length;
    indexName.MaximumLength = indexName.Length + sizeof(WCHAR);
    indexName.Buffer = ExAllocatePool(PagedPool, indexName.MaximumLength);
    if (!indexName.Buffer) {
        if (remoteDatabaseHandle) {
            CloseRemoteDatabase(remoteDatabaseHandle);
        }
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    RtlCopyMemory(indexName.Buffer, DeviceInfo->DeviceName.Buffer,
                  DeviceInfo->DeviceName.Length);
    RtlCopyMemory((PCHAR) indexName.Buffer + DeviceInfo->DeviceName.Length,
                  ReparseIndexName.Buffer, ReparseIndexName.Length);
    indexName.Buffer[indexName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &indexName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwOpenFile(&indexHandle, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    ExFreePool(indexName.Buffer);
    if (!NT_SUCCESS(status)) {
        if (remoteDatabaseHandle) {
            TruncateRemoteDatabase(remoteDatabaseHandle, 0);
            CloseRemoteDatabase(remoteDatabaseHandle);
        }
        DeviceInfo->HasDanglingVolumeMountPoint = FALSE;
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    RtlZeroMemory(&reparseKey, sizeof(reparseKey));
    reparseKey.FileReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    reparseName.Length = reparseName.MaximumLength = sizeof(reparseKey);
    reparseName.Buffer = (PWCHAR) &reparseKey;
    status = ZwQueryDirectoryFile(indexHandle, NULL, NULL, NULL, &ioStatus,
                                  &reparseInfo, sizeof(reparseInfo),
                                  FileReparsePointInformation, TRUE,
                                  &reparseName, FALSE);
    if (!NT_SUCCESS(status)) {
        ZwClose(indexHandle);
        if (remoteDatabaseHandle) {
            TruncateRemoteDatabase(remoteDatabaseHandle, 0);
            CloseRemoteDatabase(remoteDatabaseHandle);
        }
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    if (!remoteDatabaseHandle) {
        remoteDatabaseHandle = OpenRemoteDatabase(DeviceInfo, TRUE);

        if (!remoteDatabaseHandle) {
            ZwClose(indexHandle);
            KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            ReleaseRemoteDatabaseSemaphore(Extension);
            return;
        }
    }

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    offset = 0;
    for (;;) {

        entry = GetRemoteDatabaseEntry(remoteDatabaseHandle, offset);
        if (!entry) {
            break;
        }

        entry->RefCount = 0;
        status = WriteRemoteDatabaseEntry(remoteDatabaseHandle, offset, entry);
        if (!NT_SUCCESS(status)) {
            ExFreePool(entry);
            ZwClose(indexHandle);
            CloseRemoteDatabase(remoteDatabaseHandle);
            ReleaseRemoteDatabaseSemaphore(Extension);
            return;
        }

        offset += entry->EntryLength;
        ExFreePool(entry);
    }

    volumeName.MaximumLength = MAX_VOLUME_PATH*sizeof(WCHAR);
    volumeName.Length = 0;
    volumeName.Buffer = volumeNameBuffer;

    restartScan = TRUE;
    for (;;) {

        previousReparseInfo = reparseInfo;

        status = ZwQueryDirectoryFile(indexHandle, NULL, NULL, NULL, &ioStatus,
                                      &reparseInfo, sizeof(reparseInfo),
                                      FileReparsePointInformation, TRUE,
                                      restartScan ? &reparseName : NULL,
                                      restartScan);
        if (restartScan) {
            restartScan = FALSE;
        } else {
            if (previousReparseInfo.FileReference ==
                reparseInfo.FileReference &&
                previousReparseInfo.Tag == reparseInfo.Tag) {

                break;
            }
        }

        if (!NT_SUCCESS(status) || Unloading) {
            break;
        }

        if (reparseInfo.Tag != IO_REPARSE_TAG_MOUNT_POINT) {
            break;
        }

        status = QueryVolumeName(indexHandle, &reparseInfo.FileReference, NULL,
                                 &volumeName, &pathName);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        offset = 0;
        for (;;) {

            entry = GetRemoteDatabaseEntry(remoteDatabaseHandle, offset);
            if (!entry) {
                break;
            }

            otherVolumeName.Length = otherVolumeName.MaximumLength =
                    entry->VolumeNameLength;
            otherVolumeName.Buffer = (PWSTR) ((PCHAR) entry +
                    entry->VolumeNameOffset);

            if (RtlEqualUnicodeString(&otherVolumeName, &volumeName, TRUE)) {
                break;
            }

            offset += entry->EntryLength;
            ExFreePool(entry);
        }

        if (!entry) {

            KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);
            status = QueryUniqueIdFromMaster(Extension, &volumeName, &uniqueId);
            KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

            if (!NT_SUCCESS(status)) {
                goto BuildMountPointGraph;
            }

            entryLength = sizeof(MOUNTMGR_FILE_ENTRY) +
                          volumeName.Length + uniqueId->UniqueIdLength;
            entry = ExAllocatePool(PagedPool, entryLength);
            if (!entry) {
                ExFreePool(uniqueId);
                goto BuildMountPointGraph;
            }

            entry->EntryLength = entryLength;
            entry->RefCount = 1;
            entry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
            entry->VolumeNameLength = volumeName.Length;
            entry->UniqueIdOffset = entry->VolumeNameOffset +
                                    entry->VolumeNameLength;
            entry->UniqueIdLength = uniqueId->UniqueIdLength;

            RtlCopyMemory((PCHAR) entry + entry->VolumeNameOffset,
                          volumeName.Buffer, entry->VolumeNameLength);
            RtlCopyMemory((PCHAR) entry + entry->UniqueIdOffset,
                          uniqueId->UniqueId, entry->UniqueIdLength);

            status = AddRemoteDatabaseEntry(remoteDatabaseHandle, entry);

            ExFreePool(entry);
            ExFreePool(uniqueId);

            if (!NT_SUCCESS(status)) {
                ExFreePool(pathName.Buffer);
                ZwClose(indexHandle);
                CloseRemoteDatabase(remoteDatabaseHandle);
                ReleaseRemoteDatabaseSemaphore(Extension);
                return;
            }

            goto BuildMountPointGraph;
        }

        if (entry->RefCount) {

            entry->RefCount++;
            status = WriteRemoteDatabaseEntry(remoteDatabaseHandle, offset,
                                              entry);

            if (!NT_SUCCESS(status)) {
                ExFreePool(entry);
                ExFreePool(pathName.Buffer);
                ZwClose(indexHandle);
                CloseRemoteDatabase(remoteDatabaseHandle);
                ReleaseRemoteDatabaseSemaphore(Extension);
                return;
            }

        } else {

            KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);

            status = QueryUniqueIdFromMaster(Extension, &volumeName, &uniqueId);

            if (NT_SUCCESS(status)) {

                if (uniqueId->UniqueIdLength == entry->UniqueIdLength &&
                    RtlCompareMemory(uniqueId->UniqueId,
                                     (PCHAR) entry + entry->UniqueIdOffset,
                                     entry->UniqueIdLength) ==
                                     entry->UniqueIdLength) {

                    entry->RefCount++;
                    status = WriteRemoteDatabaseEntry(remoteDatabaseHandle,
                                                      offset, entry);

                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                } else if (IsUniqueIdPresent(Extension, entry)) {

                    status = WriteUniqueIdToMaster(Extension, entry);
                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                    entry->RefCount++;
                    status = WriteRemoteDatabaseEntry(remoteDatabaseHandle,
                                                      offset, entry);

                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                } else {

                    status = DeleteRemoteDatabaseEntry(remoteDatabaseHandle,
                                                       offset);
                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                    ExFreePool(entry);

                    entryLength = sizeof(MOUNTMGR_FILE_ENTRY) +
                                  volumeName.Length + uniqueId->UniqueIdLength;
                    entry = ExAllocatePool(PagedPool, entryLength);
                    if (!entry) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                    entry->EntryLength = entryLength;
                    entry->RefCount = 1;
                    entry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
                    entry->VolumeNameLength = volumeName.Length;
                    entry->UniqueIdOffset = entry->VolumeNameOffset +
                                            entry->VolumeNameLength;
                    entry->UniqueIdLength = uniqueId->UniqueIdLength;

                    RtlCopyMemory((PCHAR) entry + entry->VolumeNameOffset,
                                  volumeName.Buffer, entry->VolumeNameLength);
                    RtlCopyMemory((PCHAR) entry + entry->UniqueIdOffset,
                                  uniqueId->UniqueId, entry->UniqueIdLength);

                    status = AddRemoteDatabaseEntry(remoteDatabaseHandle,
                                                    entry);
                    if (!NT_SUCCESS(status)) {
                        ExFreePool(entry);
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }
                }

                ExFreePool(uniqueId);

            } else {
                status = WriteUniqueIdToMaster(Extension, entry);
                if (!NT_SUCCESS(status)) {
                    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                       1, FALSE);
                    ExFreePool(entry);
                    ExFreePool(pathName.Buffer);
                    ZwClose(indexHandle);
                    CloseRemoteDatabase(remoteDatabaseHandle);
                    ReleaseRemoteDatabaseSemaphore(Extension);
                    return;
                }

                entry->RefCount++;
                status = WriteRemoteDatabaseEntry(remoteDatabaseHandle, offset,
                                                  entry);

                if (!NT_SUCCESS(status)) {
                    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                       1, FALSE);
                    ExFreePool(entry);
                    ExFreePool(pathName.Buffer);
                    ZwClose(indexHandle);
                    CloseRemoteDatabase(remoteDatabaseHandle);
                    ReleaseRemoteDatabaseSemaphore(Extension);
                    return;
                }
            }

            KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        }

        ExFreePool(entry);

BuildMountPointGraph:

        KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode,
                              FALSE, NULL);

        status = FindDeviceInfo(Extension, &volumeName, FALSE, &deviceInfo);
        if (NT_SUCCESS(status)) {

            mountPointEntry = (PMOUNTMGR_MOUNT_POINT_ENTRY)
                              ExAllocatePool(PagedPool,
                                             sizeof(MOUNTMGR_MOUNT_POINT_ENTRY));
            if (mountPointEntry) {
                InsertTailList(&deviceInfo->MountPointsPointingHere,
                               &mountPointEntry->ListEntry);
                mountPointEntry->DeviceInfo = DeviceInfo;
                mountPointEntry->MountPath = pathName;
            } else {
                ExFreePool(pathName.Buffer);
            }

            if (!deviceInfo->InOfflineList) {
                PostOnlineNotification(&deviceInfo->NotificationName);
            }
        } else {
            actualDanglesFound = TRUE;
            ExFreePool(pathName.Buffer);
        }

        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
    }

    ZwClose(indexHandle);

    KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo == DeviceInfo) {
            break;
        }
    }

    if (l == &Extension->MountedDeviceList) {
        deviceInfo = NULL;
    }

    offset = 0;
    for (;;) {

        entry = GetRemoteDatabaseEntry(remoteDatabaseHandle, offset);
        if (!entry) {
            break;
        }

        if (!entry->RefCount) {
            status = DeleteRemoteDatabaseEntry(remoteDatabaseHandle, offset);
            if (!NT_SUCCESS(status)) {
                ExFreePool(entry);
                KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1,
                                   FALSE);
                CloseRemoteDatabase(remoteDatabaseHandle);
                ReleaseRemoteDatabaseSemaphore(Extension);
                return;
            }

            ExFreePool(entry);
            continue;
        }

        if (deviceInfo) {
            UpdateReplicatedUniqueIds(deviceInfo, entry);
        }

        offset += entry->EntryLength;
        ExFreePool(entry);
    }

    if (deviceInfo && !actualDanglesFound) {
        DeviceInfo->HasDanglingVolumeMountPoint = FALSE;
    }

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    CloseRemoteDatabase(remoteDatabaseHandle);
    ReleaseRemoteDatabaseSemaphore(Extension);
}

VOID
ReconcileThisDatabaseWithMaster(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

/*++

Routine Description:

    This routine reconciles the remote database with the master database.

Arguments:

    DeviceInfo  - Supplies the device information.

Return Value:

    None.

--*/

{
    PRECONCILE_WORK_ITEM    workItem;

    if (DeviceInfo->IsRemovable) {
        return;
    }

    workItem = ExAllocatePool(NonPagedPool,
                              sizeof(RECONCILE_WORK_ITEM));
    if (!workItem) {
        return;
    }

    workItem->WorkItem = IoAllocateWorkItem(Extension->DeviceObject);
    if (workItem->WorkItem == NULL) {
        ExFreePool (workItem);
        return;
    }

    workItem->WorkerRoutine = ReconcileThisDatabaseWithMasterWorker;
    workItem->WorkItemInfo.Extension = Extension;
    workItem->WorkItemInfo.DeviceInfo = DeviceInfo;

    QueueWorkItem(Extension, workItem, &workItem->WorkItemInfo);
}

NTSTATUS
DeleteFromLocalDatabaseRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;

    if (uniqueId->UniqueIdLength == ValueLength &&
        RtlCompareMemory(uniqueId->UniqueId,
                         ValueData, ValueLength) == ValueLength) {

        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               ValueName);
    }

    return STATUS_SUCCESS;
}

VOID
DeleteFromLocalDatabase(
    IN  PUNICODE_STRING     SymbolicLinkName,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine makes sure that the given symbolic link names exists in the
    local database and that its unique id is equal to the one given.  If these
    two conditions are true then this local database entry is deleted.

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name.

    UniqueId            - Supplies the unique id.

Return Value:

    None.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = DeleteFromLocalDatabaseRoutine;
    queryTable[0].Name = SymbolicLinkName->Buffer;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);
}

PSAVED_LINKS_INFORMATION
RemoveSavedLinks(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine finds and removed the given unique id from the saved links
    list.

Arguments:

    Extension   - Supplies the device extension.

    UniqueId    - Supplies the unique id.

Return Value:

    The removed saved links list or NULL.

--*/

{
    PLIST_ENTRY                 l;
    PSAVED_LINKS_INFORMATION    savedLinks;

    for (l = Extension->SavedLinksList.Flink;
         l != &Extension->SavedLinksList; l = l->Flink) {

        savedLinks = CONTAINING_RECORD(l, SAVED_LINKS_INFORMATION, ListEntry);
        if (savedLinks->UniqueId->UniqueIdLength != UniqueId->UniqueIdLength) {
            continue;
        }

        if (RtlCompareMemory(savedLinks->UniqueId->UniqueId,
                             UniqueId->UniqueId, UniqueId->UniqueIdLength) ==
            UniqueId->UniqueIdLength) {

            break;
        }
    }

    if (l == &Extension->SavedLinksList) {
        return NULL;
    }

    RemoveEntryList(l);

    return savedLinks;
}

BOOLEAN
RedirectSavedLink(
    IN  PSAVED_LINKS_INFORMATION    SavedLinks,
    IN  PUNICODE_STRING             SymbolicLinkName,
    IN  PUNICODE_STRING             DeviceName
    )

/*++

Routine Description:

    This routine attempts to redirect the given link to the given device name
    if this link is in the saved links list.  When this is done, the
    symbolic link entry is removed from the saved links list.

Arguments:


Return Value:

    FALSE   - The link was not successfully redirected.

    TRUE    - The link was successfully redirected.

--*/

{
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;

    for (l = SavedLinks->SymbolicLinkNames.Flink;
         l != &SavedLinks->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        if (RtlEqualUnicodeString(SymbolicLinkName,
                                  &symlinkEntry->SymbolicLinkName, TRUE)) {

            break;
        }
    }

    if (l == &SavedLinks->SymbolicLinkNames) {
        return FALSE;
    }

    // NOTE There is a small window here where the drive letter could be
    // taken away.  This is the best we can do without more support from OB.

    GlobalDeleteSymbolicLink(SymbolicLinkName);
    GlobalCreateSymbolicLink(SymbolicLinkName, DeviceName);

    ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
    ExFreePool(symlinkEntry);
    RemoveEntryList(l);

    return TRUE;
}

BOOLEAN
IsOffline(
    IN  PUNICODE_STRING     SymbolicLinkName
    )

/*++

Routine Description:

    This routine checks to see if the given name has been marked to be
    an offline volume.

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name.

Return Value:

    FALSE   - This volume is not marked for offline.

    TRUE    - This volume is marked for offline.

--*/

{
    ULONG                       zero, offline;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = SymbolicLinkName->Buffer;
    queryTable[0].EntryContext = &offline;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    MOUNTED_DEVICES_OFFLINE_KEY, queryTable,
                                    NULL, NULL);
    if (!NT_SUCCESS(status)) {
        offline = 0;
    }

    return offline ? TRUE : FALSE;
}

VOID
SendOnlineNotification(
    IN  PUNICODE_STRING     NotificationName
    )

/*++

Routine Description:

    This routine sends an ONLINE notification to the given device.

Arguments:

    NotificationName    - Supplies the notification name.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;

    status = IoGetDeviceObjectPointer(NotificationName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_VOLUME_ONLINE, deviceObject,
                                        NULL, 0, NULL, 0, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);
}

NTSTATUS
MountMgrTargetDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   DeviceInfo
    )

/*++

Routine Description:

    This routine processes target device notifications.

Arguments:

    NotificationStructure    - Supplies the notification structure.

    DeviceInfo               - Supplies the device information.

Return Value:

    None.

--*/

{
    PTARGET_DEVICE_REMOVAL_NOTIFICATION     notification = NotificationStructure;
    PMOUNTED_DEVICE_INFORMATION             deviceInfo = DeviceInfo;
    PDEVICE_EXTENSION                       extension = deviceInfo->Extension;

    if (IsEqualGUID(&notification->Event,
                    &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        MountMgrMountedDeviceRemoval(extension, &deviceInfo->NotificationName);
        return STATUS_SUCCESS;
    }

    if (IsEqualGUID(&notification->Event, &GUID_IO_VOLUME_MOUNT) &&
        deviceInfo->ReconcileOnMounts) {

        deviceInfo->ReconcileOnMounts = FALSE;
        ReconcileThisDatabaseWithMaster(extension, deviceInfo);
        return STATUS_SUCCESS;
    }

    return STATUS_SUCCESS;
}

VOID
RegisterForTargetDeviceNotification(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

/*++

Routine Description:

    This routine registers for target device notification so that the
    symbolic link to a device interface can be removed in a timely manner.

Arguments:

    Extension   - Supplies the device extension.

    DeviceInfo  - Supplies the device information.

Return Value:

    None.

--*/

{
    NTSTATUS                                status;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;

    status = IoGetDeviceObjectPointer(&DeviceInfo->DeviceName,
                                      FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }

    status = IoRegisterPlugPlayNotification(
                EventCategoryTargetDeviceChange, 0, fileObject,
                Extension->DriverObject, MountMgrTargetDeviceNotification,
                DeviceInfo, &DeviceInfo->TargetDeviceNotificationEntry);

    if (!NT_SUCCESS(status)) {
        DeviceInfo->TargetDeviceNotificationEntry = NULL;
    }

    ObDereferenceObject(fileObject);
}

VOID
MountMgrFreeDeadDeviceInfo(
    PMOUNTED_DEVICE_INFORMATION deviceInfo
    )
{
    ExFreePool(deviceInfo->NotificationName.Buffer);
    ExFreePool(deviceInfo);
}

VOID
MountMgrFreeSavedLink(
    PSAVED_LINKS_INFORMATION                savedLinks
    )
{
    PLIST_ENTRY                             l;
    PSYMBOLIC_LINK_NAME_ENTRY               symlinkEntry;

    while (!IsListEmpty(&savedLinks->SymbolicLinkNames)) {
        l = RemoveHeadList(&savedLinks->SymbolicLinkNames);
        symlinkEntry = CONTAINING_RECORD(l,
                                         SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);
        GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
        ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
        ExFreePool(symlinkEntry);
    }
    ExFreePool(savedLinks->UniqueId);
    ExFreePool(savedLinks);
}

NTSTATUS
MountMgrMountedDeviceArrival(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     NotificationName,
    IN  BOOLEAN             NotAPdo
    )

{
    PDEVICE_EXTENSION           extension = Extension;
    PMOUNTED_DEVICE_INFORMATION deviceInfo, d;
    NTSTATUS                    status;
    UNICODE_STRING              targetName, otherTargetName;
    PMOUNTDEV_UNIQUE_ID         uniqueId, uniqueIdCopy;
    BOOLEAN                     isRecognized, sendOnline;
    UNICODE_STRING              suggestedName;
    BOOLEAN                     useOnlyIfThereAreNoOtherLinks;
    PUNICODE_STRING             symbolicLinkNames;
    ULONG                       numNames, i, allocSize;
    BOOLEAN                     hasDriveLetter, offline, isStable, isFT;
    BOOLEAN                     hasVolumeName, isLinkPreset;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    UNICODE_STRING              volumeName;
    UNICODE_STRING              driveLetterName;
    PSAVED_LINKS_INFORMATION    savedLinks;
    PLIST_ENTRY                 l;
    GUID                        stableGuid;

    deviceInfo = ExAllocatePool(PagedPool,
                                sizeof(MOUNTED_DEVICE_INFORMATION));
    if (!deviceInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceInfo, sizeof(MOUNTED_DEVICE_INFORMATION));

    InitializeListHead(&deviceInfo->SymbolicLinkNames);
    InitializeListHead(&deviceInfo->ReplicatedUniqueIds);
    InitializeListHead(&deviceInfo->MountPointsPointingHere);

    deviceInfo->NotificationName.Length =
            NotificationName->Length;
    deviceInfo->NotificationName.MaximumLength =
            deviceInfo->NotificationName.Length + sizeof(WCHAR);
    deviceInfo->NotificationName.Buffer =
            ExAllocatePool(PagedPool,
                           deviceInfo->NotificationName.MaximumLength);
    if (!deviceInfo->NotificationName.Buffer) {
        ExFreePool(deviceInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(deviceInfo->NotificationName.Buffer,
                  NotificationName->Buffer,
                  deviceInfo->NotificationName.Length);
    deviceInfo->NotificationName.Buffer[
            deviceInfo->NotificationName.Length/sizeof(WCHAR)] = 0;
    deviceInfo->NotAPdo = NotAPdo;
    deviceInfo->Extension = extension;

    status = QueryDeviceInformation(NotificationName,
                                    &targetName, &uniqueId,
                                    &deviceInfo->IsRemovable, &isRecognized,
                                    &isStable, &stableGuid, &isFT);
    if (!NT_SUCCESS(status)) {

        KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                              FALSE, NULL);

        for (l = extension->DeadMountedDeviceList.Flink;
             l != &extension->DeadMountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (RtlEqualUnicodeString(&deviceInfo->NotificationName,
                                      &d->NotificationName, TRUE)) {

                break;
            }
        }

        if (l == &extension->DeadMountedDeviceList) {
            InsertTailList(&extension->DeadMountedDeviceList,
                           &deviceInfo->ListEntry);
        } else {
            MountMgrFreeDeadDeviceInfo (deviceInfo);
        }

        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        return status;
    }

    deviceInfo->UniqueId = uniqueId;
    deviceInfo->DeviceName = targetName;
    deviceInfo->KeepLinksWhenOffline = FALSE;

    if (extension->SystemPartitionUniqueId &&
        uniqueId->UniqueIdLength ==
        extension->SystemPartitionUniqueId->UniqueIdLength &&
        RtlCompareMemory(uniqueId->UniqueId,
                         extension->SystemPartitionUniqueId->UniqueId,
                         uniqueId->UniqueIdLength) ==
                         uniqueId->UniqueIdLength) {

        IoSetSystemPartition(&targetName);
    }

    status = QuerySuggestedLinkName(&deviceInfo->NotificationName,
                                    &suggestedName,
                                    &useOnlyIfThereAreNoOtherLinks);
    if (!NT_SUCCESS(status)) {
        suggestedName.Buffer = NULL;
    }

    if (suggestedName.Buffer && IsDriveLetter(&suggestedName)) {
        deviceInfo->SuggestedDriveLetter = (UCHAR)
                                           suggestedName.Buffer[12];
    } else {
        deviceInfo->SuggestedDriveLetter = 0;
    }

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
        if (!RtlCompareUnicodeString(&d->DeviceName, &targetName, TRUE)) {
            break;
        }
    }

    if (l != &extension->MountedDeviceList) {
        if (suggestedName.Buffer) {
            ExFreePool(suggestedName.Buffer);
        }
        ExFreePool(uniqueId);
        ExFreePool(targetName.Buffer);
        ExFreePool(deviceInfo->NotificationName.Buffer);
        ExFreePool(deviceInfo);
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    status = QuerySymbolicLinkNamesFromStorage(extension,
             deviceInfo, suggestedName.Buffer ? &suggestedName : NULL,
             useOnlyIfThereAreNoOtherLinks, &symbolicLinkNames, &numNames,
             isStable, &stableGuid);

    if (suggestedName.Buffer) {
        ExFreePool(suggestedName.Buffer);
    }

    if (!NT_SUCCESS(status)) {
        symbolicLinkNames = NULL;
        numNames = 0;
        status = STATUS_SUCCESS;
    }

    savedLinks = RemoveSavedLinks(extension, uniqueId);

    hasDriveLetter = FALSE;
    offline = FALSE;
    hasVolumeName = FALSE;
    for (i = 0; i < numNames; i++) {

        if (MOUNTMGR_IS_VOLUME_NAME(&symbolicLinkNames[i])) {
            hasVolumeName = TRUE;
        } else if (IsDriveLetter(&symbolicLinkNames[i])) {
            if (hasDriveLetter) {
                DeleteFromLocalDatabase(&symbolicLinkNames[i], uniqueId);
                continue;
            }
            hasDriveLetter = TRUE;
        }

        status = GlobalCreateSymbolicLink(&symbolicLinkNames[i], &targetName);
        if (!NT_SUCCESS(status)) {
            isLinkPreset = TRUE;
            if (!savedLinks ||
                !RedirectSavedLink(savedLinks, &symbolicLinkNames[i],
                                   &targetName)) {

                status = QueryDeviceInformation(&symbolicLinkNames[i],
                                                &otherTargetName, NULL, NULL,
                                                NULL, NULL, NULL, NULL);
                if (!NT_SUCCESS(status)) {
                    isLinkPreset = FALSE;
                }

                if (isLinkPreset &&
                    !RtlEqualUnicodeString(&targetName, &otherTargetName,
                                           TRUE)) {

                    isLinkPreset = FALSE;
                }

                if (NT_SUCCESS(status)) {
                    ExFreePool(otherTargetName.Buffer);
                }
            }

            if (!isLinkPreset) {
                if (IsDriveLetter(&symbolicLinkNames[i])) {
                    hasDriveLetter = FALSE;
                    DeleteFromLocalDatabase(&symbolicLinkNames[i], uniqueId);
                }

                ExFreePool(symbolicLinkNames[i].Buffer);
                continue;
            }
        }

        if (IsOffline(&symbolicLinkNames[i])) {
            offline = TRUE;
        }

        symlinkEntry = ExAllocatePool(PagedPool,
                                      sizeof(SYMBOLIC_LINK_NAME_ENTRY));
        if (!symlinkEntry) {
            GlobalDeleteSymbolicLink(&symbolicLinkNames[i]);
            ExFreePool(symbolicLinkNames[i].Buffer);
            continue;
        }

        symlinkEntry->SymbolicLinkName = symbolicLinkNames[i];
        symlinkEntry->IsInDatabase = TRUE;

        InsertTailList(&deviceInfo->SymbolicLinkNames,
                       &symlinkEntry->ListEntry);
    }

    for (l = deviceInfo->SymbolicLinkNames.Flink;
         l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);
        SendLinkCreated(&symlinkEntry->SymbolicLinkName);
    }

    if (savedLinks) {
        MountMgrFreeSavedLink (savedLinks);
    }

    if (!hasVolumeName) {
        status = CreateNewVolumeName(&volumeName, NULL);
        if (NT_SUCCESS(status)) {
            RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                    MOUNTED_DEVICES_KEY, volumeName.Buffer, REG_BINARY,
                    uniqueId->UniqueId, uniqueId->UniqueIdLength);

            GlobalCreateSymbolicLink(&volumeName, &targetName);

            symlinkEntry = ExAllocatePool(PagedPool,
                                          sizeof(SYMBOLIC_LINK_NAME_ENTRY));
            if (symlinkEntry) {
                symlinkEntry->SymbolicLinkName = volumeName;
                symlinkEntry->IsInDatabase = TRUE;
                InsertTailList(&deviceInfo->SymbolicLinkNames,
                               &symlinkEntry->ListEntry);
                SendLinkCreated(&volumeName);
            } else {
                ExFreePool(volumeName.Buffer);
            }
        }
    }

    if (hasDriveLetter) {
        deviceInfo->SuggestedDriveLetter = 0;
    }

    if (!hasDriveLetter && 
        (extension->AutoMountPermitted || deviceInfo->IsRemovable)  &&
        extension->AutomaticDriveLetterAssignment &&
        (isRecognized || deviceInfo->SuggestedDriveLetter) &&
        !HasNoDriveLetterEntry(uniqueId)) {

        status = CreateNewDriveLetterName(&driveLetterName, &targetName,
                                          deviceInfo->SuggestedDriveLetter,
                                          uniqueId);
        if (NT_SUCCESS(status)) {
            RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                    MOUNTED_DEVICES_KEY, driveLetterName.Buffer,
                    REG_BINARY, uniqueId->UniqueId,
                    uniqueId->UniqueIdLength);

            symlinkEntry = ExAllocatePool(PagedPool,
                                          sizeof(SYMBOLIC_LINK_NAME_ENTRY));
            if (symlinkEntry) {
                symlinkEntry->SymbolicLinkName = driveLetterName;
                symlinkEntry->IsInDatabase = TRUE;
                InsertTailList(&deviceInfo->SymbolicLinkNames,
                               &symlinkEntry->ListEntry);
                SendLinkCreated(&driveLetterName);
            } else {
                ExFreePool(driveLetterName.Buffer);
            }
        } else {
            CreateNoDriveLetterEntry(uniqueId);
        }
    }

    if (!NotAPdo) {
        RegisterForTargetDeviceNotification(extension, deviceInfo);
    }

    InsertTailList(&extension->MountedDeviceList, &deviceInfo->ListEntry);

    allocSize = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
                uniqueId->UniqueIdLength;
    uniqueIdCopy = ExAllocatePool(PagedPool, allocSize);
    if (uniqueIdCopy) {
        RtlCopyMemory(uniqueIdCopy, uniqueId, allocSize);
    }

    if (offline || isFT) {
        deviceInfo->InOfflineList = TRUE;
    }

    if (extension->AutoMountPermitted || hasDriveLetter) {
        if (deviceInfo->InOfflineList) {
            sendOnline = FALSE;
        } else {
            sendOnline = TRUE;
        }
    } else {
        sendOnline = FALSE;
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    if (sendOnline) {
        SendOnlineNotification(NotificationName);
    }

    if (symbolicLinkNames) {
        ExFreePool(symbolicLinkNames);
    }

    if (uniqueIdCopy) {
        IssueUniqueIdChangeNotify(extension, NotificationName,
                                  uniqueIdCopy);
        ExFreePool(uniqueIdCopy);
    }

    if (extension->AutomaticDriveLetterAssignment) {
        KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                              FALSE, NULL);

        ReconcileThisDatabaseWithMaster(extension, deviceInfo);

        for (l = extension->MountedDeviceList.Flink;
             l != &extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (d->HasDanglingVolumeMountPoint) {
                ReconcileThisDatabaseWithMaster(extension, d);
            }
        }

        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
    }

    return STATUS_SUCCESS;
}

VOID
MountMgrFreeMountedDeviceInfo(
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

{

    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    while (!IsListEmpty(&DeviceInfo->SymbolicLinkNames)) {

        l = RemoveHeadList(&DeviceInfo->SymbolicLinkNames);
        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
        ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
        ExFreePool(symlinkEntry);
    }

    while (!IsListEmpty(&DeviceInfo->ReplicatedUniqueIds)) {

        l = RemoveHeadList(&DeviceInfo->ReplicatedUniqueIds);
        replUniqueId = CONTAINING_RECORD(l, REPLICATED_UNIQUE_ID,
                                         ListEntry);

        ExFreePool(replUniqueId->UniqueId);
        ExFreePool(replUniqueId);
    }

    while (!IsListEmpty(&DeviceInfo->MountPointsPointingHere)) {

        l = RemoveHeadList(&DeviceInfo->MountPointsPointingHere);
        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);
        ExFreePool(mountPointEntry->MountPath.Buffer);
        ExFreePool(mountPointEntry);
    }

    ExFreePool(DeviceInfo->NotificationName.Buffer);

    if (!DeviceInfo->KeepLinksWhenOffline) {
        ExFreePool(DeviceInfo->UniqueId);
    }

    ExFreePool(DeviceInfo->DeviceName.Buffer);

    if (DeviceInfo->TargetDeviceNotificationEntry) {
        IoUnregisterPlugPlayNotification(
                DeviceInfo->TargetDeviceNotificationEntry);
    }

    ExFreePool(DeviceInfo);
}

NTSTATUS
MountMgrMountedDeviceRemoval(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     NotificationName
    )

{
    PDEVICE_EXTENSION           extension = Extension;
    PMOUNTED_DEVICE_INFORMATION deviceInfo, d;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    PLIST_ENTRY                 l, ll, s;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PSAVED_LINKS_INFORMATION    savedLinks;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);
        if (!RtlCompareUnicodeString(&deviceInfo->NotificationName,
                                     NotificationName, TRUE)) {
            break;
        }
    }

    if (l != &extension->MountedDeviceList) {

        if (deviceInfo->KeepLinksWhenOffline) {
            savedLinks = ExAllocatePool(PagedPool,
                                        sizeof(SAVED_LINKS_INFORMATION));
            if (!savedLinks) {
                deviceInfo->KeepLinksWhenOffline = FALSE;
            }
        }

        if (deviceInfo->KeepLinksWhenOffline) {

            InsertTailList(&extension->SavedLinksList,
                           &savedLinks->ListEntry);
            InitializeListHead(&savedLinks->SymbolicLinkNames);
            savedLinks->UniqueId = deviceInfo->UniqueId;

            while (!IsListEmpty(&deviceInfo->SymbolicLinkNames)) {

                ll = RemoveHeadList(&deviceInfo->SymbolicLinkNames);
                symlinkEntry = CONTAINING_RECORD(ll,
                                                 SYMBOLIC_LINK_NAME_ENTRY,
                                                 ListEntry);

                if (symlinkEntry->IsInDatabase) {
                    InsertTailList(&savedLinks->SymbolicLinkNames, ll);
                } else {
                    GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
                    ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
                    ExFreePool(symlinkEntry);
                }
            }
        } else {

            while (!IsListEmpty(&deviceInfo->SymbolicLinkNames)) {

                ll = RemoveHeadList(&deviceInfo->SymbolicLinkNames);
                symlinkEntry = CONTAINING_RECORD(ll,
                                                 SYMBOLIC_LINK_NAME_ENTRY,
                                                 ListEntry);

                GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
                ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
                ExFreePool(symlinkEntry);
            }
        }

        while (!IsListEmpty(&deviceInfo->ReplicatedUniqueIds)) {

            ll = RemoveHeadList(&deviceInfo->ReplicatedUniqueIds);
            replUniqueId = CONTAINING_RECORD(ll, REPLICATED_UNIQUE_ID,
                                             ListEntry);

            ExFreePool(replUniqueId->UniqueId);
            ExFreePool(replUniqueId);
        }

        while (!IsListEmpty(&deviceInfo->MountPointsPointingHere)) {

            ll = RemoveHeadList(&deviceInfo->MountPointsPointingHere);
            mountPointEntry = CONTAINING_RECORD(ll, MOUNTMGR_MOUNT_POINT_ENTRY,
                                                ListEntry);

            mountPointEntry->DeviceInfo->HasDanglingVolumeMountPoint = TRUE;

            ExFreePool(mountPointEntry->MountPath.Buffer);
            ExFreePool(mountPointEntry);
        }

        RemoveEntryList(l);

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);

            for (ll = d->MountPointsPointingHere.Flink;
                 ll != &d->MountPointsPointingHere; ll = ll->Flink) {

                mountPointEntry = CONTAINING_RECORD(ll, MOUNTMGR_MOUNT_POINT_ENTRY,
                                                    ListEntry);
                if (mountPointEntry->DeviceInfo == deviceInfo) {
                    s = ll->Blink;
                    RemoveEntryList(ll);
                    ExFreePool(mountPointEntry->MountPath.Buffer);
                    ExFreePool(mountPointEntry);
                    ll = s;
                }
            }
        }

        ExFreePool(deviceInfo->NotificationName.Buffer);

        if (!deviceInfo->KeepLinksWhenOffline) {
            ExFreePool(deviceInfo->UniqueId);
        }

        ExFreePool(deviceInfo->DeviceName.Buffer);

        if (deviceInfo->TargetDeviceNotificationEntry) {
            IoUnregisterPlugPlayNotification(
                    deviceInfo->TargetDeviceNotificationEntry);
        }

        ExFreePool(deviceInfo);

    } else {

        for (l = extension->DeadMountedDeviceList.Flink;
             l != &extension->DeadMountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);
            if (!RtlCompareUnicodeString(&deviceInfo->NotificationName,
                                         NotificationName, TRUE)) {
                break;
            }
        }

        if (l != &extension->DeadMountedDeviceList) {
            RemoveEntryList(l);
            MountMgrFreeDeadDeviceInfo (deviceInfo);
        }
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrMountedDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   Extension
    )

/*++

Routine Description:

    This routine is called whenever a volume comes or goes.

Arguments:

    NotificationStructure   - Supplies the notification structure.

    Extension               - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   notification = NotificationStructure;
    PDEVICE_EXTENSION                       extension = Extension;
    BOOLEAN                                 oldHardErrorMode;
    NTSTATUS                                status;

    oldHardErrorMode = PsGetThreadHardErrorsAreDisabled(PsGetCurrentThread());
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),TRUE);

    if (IsEqualGUID(&notification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        status = MountMgrMountedDeviceArrival(extension,
                                              notification->SymbolicLinkName,
                                              FALSE);

    } else if (IsEqualGUID(&notification->Event,
                           &GUID_DEVICE_INTERFACE_REMOVAL)) {

        status = MountMgrMountedDeviceRemoval(extension,
                                              notification->SymbolicLinkName);

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),oldHardErrorMode);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrCreateClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a create or close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    if (irpSp->MajorFunction == IRP_MJ_CREATE) {
        if (irpSp->Parameters.Create.Options&FILE_DIRECTORY_FILE) {
            status = STATUS_NOT_A_DIRECTORY;
        } else {
            status = STATUS_SUCCESS;
        }
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
MountMgrCreatePoint(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine creates a mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_CREATE_POINT_INPUT    input = Irp->AssociatedIrp.SystemBuffer;
    ULONG                           len1, len2, len;
    UNICODE_STRING                  symbolicLinkName, deviceName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_CREATE_POINT_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    len1 = input->DeviceNameOffset + input->DeviceNameLength;
    len2 = input->SymbolicLinkNameOffset + input->SymbolicLinkNameLength;
    len = len1 > len2 ? len1 : len2;

    if (len > irpSp->Parameters.DeviceIoControl.InputBufferLength) {
        return STATUS_INVALID_PARAMETER;
    }

    symbolicLinkName.Length = symbolicLinkName.MaximumLength =
            input->SymbolicLinkNameLength;
    symbolicLinkName.Buffer = (PWSTR) ((PCHAR) input +
                                       input->SymbolicLinkNameOffset);
    deviceName.Length = deviceName.MaximumLength = input->DeviceNameLength;
    deviceName.Buffer = (PWSTR) ((PCHAR) input + input->DeviceNameOffset);

    return MountMgrCreatePointWorker(Extension, &symbolicLinkName, &deviceName);
}

NTSTATUS
QueryPointsFromSymbolicLinkName(
    IN      PDEVICE_EXTENSION   Extension,
    IN      PUNICODE_STRING     SymbolicLinkName,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries the mount point information from the
    symbolic link name.

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name.

    Irp                 - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              deviceName;
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY   symEntry;
    ULONG                       len;
    PIO_STACK_LOCATION          irpSp;
    PMOUNTMGR_MOUNT_POINTS      output;

    status = QueryDeviceInformation(SymbolicLinkName, &deviceName, NULL, NULL,
                                    NULL, NULL, NULL, NULL);
    if (NT_SUCCESS(status)) {

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);

            if (!RtlCompareUnicodeString(&deviceName, &deviceInfo->DeviceName,
                                         TRUE)) {

                break;
            }
        }

        ExFreePool(deviceName.Buffer);

        if (l == &Extension->MountedDeviceList) {
            return STATUS_INVALID_PARAMETER;
        }

        for (l = deviceInfo->SymbolicLinkNames.Flink;
             l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

            symEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY, ListEntry);
            if (RtlEqualUnicodeString(SymbolicLinkName,
                                      &symEntry->SymbolicLinkName, TRUE)) {

                break;
            }
        }

        if (l == &deviceInfo->SymbolicLinkNames) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);

            for (ll = deviceInfo->SymbolicLinkNames.Flink;
                 ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

                symEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);
                if (RtlEqualUnicodeString(SymbolicLinkName,
                                          &symEntry->SymbolicLinkName, TRUE)) {

                    break;
                }
            }

            if (ll != &deviceInfo->SymbolicLinkNames) {
                break;
            }
        }

        if (l == &Extension->MountedDeviceList) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    len = sizeof(MOUNTMGR_MOUNT_POINTS) + symEntry->SymbolicLinkName.Length +
          deviceInfo->DeviceName.Length + deviceInfo->UniqueId->UniqueIdLength;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    output = Irp->AssociatedIrp.SystemBuffer;
    output->Size = len;
    output->NumberOfMountPoints = 1;
    Irp->IoStatus.Information = len;

    if (len > irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
        Irp->IoStatus.Information = sizeof(MOUNTMGR_MOUNT_POINTS);
        return STATUS_BUFFER_OVERFLOW;
    }

    output->MountPoints[0].SymbolicLinkNameOffset =
            sizeof(MOUNTMGR_MOUNT_POINTS);
    output->MountPoints[0].SymbolicLinkNameLength =
            symEntry->SymbolicLinkName.Length;

    if (symEntry->IsInDatabase) {
        output->MountPoints[0].UniqueIdOffset =
                output->MountPoints[0].SymbolicLinkNameOffset +
                output->MountPoints[0].SymbolicLinkNameLength;
        output->MountPoints[0].UniqueIdLength =
                deviceInfo->UniqueId->UniqueIdLength;
    } else {
        output->MountPoints[0].UniqueIdOffset = 0;
        output->MountPoints[0].UniqueIdLength = 0;
    }

    output->MountPoints[0].DeviceNameOffset =
            output->MountPoints[0].SymbolicLinkNameOffset +
            output->MountPoints[0].SymbolicLinkNameLength +
            output->MountPoints[0].UniqueIdLength;
    output->MountPoints[0].DeviceNameLength = deviceInfo->DeviceName.Length;

    RtlCopyMemory((PCHAR) output +
                  output->MountPoints[0].SymbolicLinkNameOffset,
                  symEntry->SymbolicLinkName.Buffer,
                  output->MountPoints[0].SymbolicLinkNameLength);

    if (symEntry->IsInDatabase) {
        RtlCopyMemory((PCHAR) output + output->MountPoints[0].UniqueIdOffset,
                      deviceInfo->UniqueId->UniqueId,
                      output->MountPoints[0].UniqueIdLength);
    }

    RtlCopyMemory((PCHAR) output + output->MountPoints[0].DeviceNameOffset,
                  deviceInfo->DeviceName.Buffer,
                  output->MountPoints[0].DeviceNameLength);

    return STATUS_SUCCESS;
}

NTSTATUS
QueryPointsFromMemory(
    IN      PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      PMOUNTDEV_UNIQUE_ID UniqueId,
    IN      PUNICODE_STRING     DeviceName
    )

/*++

Routine Description:

    This routine queries the points for the given unique id or device name.

Arguments:

    Extension           - Supplies the device extension.

    Irp                 - Supplies the I/O request packet.

    UniqueId            - Supplies the unique id.

    DeviceName          - Supplies the device name.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              targetName;
    ULONG                       numPoints, size;
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    PIO_STACK_LOCATION          irpSp;
    PMOUNTMGR_MOUNT_POINTS      output;
    ULONG                       offset, uOffset, dOffset;
    USHORT                      uLen, dLen;

    if (DeviceName) {
        status = QueryDeviceInformation(DeviceName, &targetName, NULL, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    numPoints = 0;
    size = 0;
    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (UniqueId) {

            if (UniqueId->UniqueIdLength ==
                deviceInfo->UniqueId->UniqueIdLength) {

                if (RtlCompareMemory(UniqueId->UniqueId,
                                     deviceInfo->UniqueId->UniqueId,
                                     UniqueId->UniqueIdLength) !=
                    UniqueId->UniqueIdLength) {

                    continue;
                }

            } else {
                continue;
            }

        } else if (DeviceName) {

            if (!RtlEqualUnicodeString(&targetName, &deviceInfo->DeviceName,
                                       TRUE)) {

                continue;
            }
        }

        size += deviceInfo->UniqueId->UniqueIdLength;
        size += deviceInfo->DeviceName.Length;

        for (ll = deviceInfo->SymbolicLinkNames.Flink;
             ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

            symlinkEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);

            numPoints++;
            size += symlinkEntry->SymbolicLinkName.Length;
        }

        if (UniqueId || DeviceName) {
            break;
        }
    }

    if (UniqueId || DeviceName) {
        if (l == &Extension->MountedDeviceList) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    output = Irp->AssociatedIrp.SystemBuffer;
    output->Size = FIELD_OFFSET(MOUNTMGR_MOUNT_POINTS, MountPoints) +
                   numPoints*sizeof(MOUNTMGR_MOUNT_POINT) + size;
    output->NumberOfMountPoints = numPoints;
    Irp->IoStatus.Information = output->Size;

    if (output->Size > irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
        Irp->IoStatus.Information = sizeof(MOUNTMGR_MOUNT_POINTS);
        if (DeviceName) {
            ExFreePool(targetName.Buffer);
        }
        return STATUS_BUFFER_OVERFLOW;
    }

    numPoints = 0;
    offset = output->Size - size;
    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (UniqueId) {

            if (UniqueId->UniqueIdLength ==
                deviceInfo->UniqueId->UniqueIdLength) {

                if (RtlCompareMemory(UniqueId->UniqueId,
                                     deviceInfo->UniqueId->UniqueId,
                                     UniqueId->UniqueIdLength) !=
                    UniqueId->UniqueIdLength) {

                    continue;
                }

            } else {
                continue;
            }

        } else if (DeviceName) {

            if (!RtlEqualUnicodeString(&targetName, &deviceInfo->DeviceName,
                                       TRUE)) {

                continue;
            }
        }

        uOffset = offset;
        uLen = deviceInfo->UniqueId->UniqueIdLength;
        dOffset = uOffset + uLen;
        dLen = deviceInfo->DeviceName.Length;
        offset += uLen + dLen;

        RtlCopyMemory((PCHAR) output + uOffset, deviceInfo->UniqueId->UniqueId,
                      uLen);
        RtlCopyMemory((PCHAR) output + dOffset, deviceInfo->DeviceName.Buffer,
                      dLen);

        for (ll = deviceInfo->SymbolicLinkNames.Flink;
             ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

            symlinkEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);

            output->MountPoints[numPoints].SymbolicLinkNameOffset = offset;
            output->MountPoints[numPoints].SymbolicLinkNameLength =
                    symlinkEntry->SymbolicLinkName.Length;

            if (symlinkEntry->IsInDatabase) {
                output->MountPoints[numPoints].UniqueIdOffset = uOffset;
                output->MountPoints[numPoints].UniqueIdLength = uLen;
            } else {
                output->MountPoints[numPoints].UniqueIdOffset = 0;
                output->MountPoints[numPoints].UniqueIdLength = 0;
            }

            output->MountPoints[numPoints].DeviceNameOffset = dOffset;
            output->MountPoints[numPoints].DeviceNameLength = dLen;

            RtlCopyMemory((PCHAR) output + offset,
                          symlinkEntry->SymbolicLinkName.Buffer,
                          symlinkEntry->SymbolicLinkName.Length);

            offset += symlinkEntry->SymbolicLinkName.Length;
            numPoints++;
        }

        if (UniqueId || DeviceName) {
            break;
        }
    }

    if (DeviceName) {
        ExFreePool(targetName.Buffer);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryPoints(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries a range of mount points.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_MOUNT_POINT   input;
    LONGLONG                len1, len2, len3, len;
    UNICODE_STRING          name;
    NTSTATUS                status;
    PMOUNTDEV_UNIQUE_ID     id;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_MOUNT_POINT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = Irp->AssociatedIrp.SystemBuffer;
    if (!input->SymbolicLinkNameLength) {
        input->SymbolicLinkNameOffset = 0;
    }
    if (!input->UniqueIdLength) {
        input->UniqueIdOffset = 0;
    }
    if (!input->DeviceNameLength) {
        input->DeviceNameOffset = 0;
    }

    if ((input->SymbolicLinkNameOffset&1) ||
        (input->SymbolicLinkNameLength&1) ||
        (input->UniqueIdOffset&1) ||
        (input->UniqueIdLength&1) ||
        (input->DeviceNameOffset&1) ||
        (input->DeviceNameLength&1)) {

        return STATUS_INVALID_PARAMETER;
    }

    len1 = (LONGLONG) input->SymbolicLinkNameOffset +
                      input->SymbolicLinkNameLength;
    len2 = (LONGLONG) input->UniqueIdOffset + input->UniqueIdLength;
    len3 = (LONGLONG) input->DeviceNameOffset + input->DeviceNameLength;
    len = len1 > len2 ? len1 : len2;
    len = len > len3 ? len : len3;
    if (len > irpSp->Parameters.DeviceIoControl.InputBufferLength) {
        return STATUS_INVALID_PARAMETER;
    }
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTMGR_MOUNT_POINTS)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->SymbolicLinkNameLength) {

        if (input->SymbolicLinkNameLength > 0xF000) {
            return STATUS_INVALID_PARAMETER;
        }

        name.Length = input->SymbolicLinkNameLength;
        name.MaximumLength = name.Length + sizeof(WCHAR);
        name.Buffer = ExAllocatePool(PagedPool, name.MaximumLength);
        if (!name.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(name.Buffer,
                      (PCHAR) input + input->SymbolicLinkNameOffset,
                      name.Length);
        name.Buffer[name.Length/sizeof(WCHAR)] = 0;

        status = QueryPointsFromSymbolicLinkName(Extension, &name, Irp);

        ExFreePool(name.Buffer);

    } else if (input->UniqueIdLength) {

        id = ExAllocatePool(PagedPool, input->UniqueIdLength + sizeof(USHORT));
        if (!id) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        id->UniqueIdLength = input->UniqueIdLength;
        RtlCopyMemory(id->UniqueId, (PCHAR) input + input->UniqueIdOffset,
                      input->UniqueIdLength);

        status = QueryPointsFromMemory(Extension, Irp, id, NULL);

        ExFreePool(id);

    } else if (input->DeviceNameLength) {

        if (input->DeviceNameLength > 0xF000) {
            return STATUS_INVALID_PARAMETER;
        }

        name.Length = input->DeviceNameLength;
        name.MaximumLength = name.Length + sizeof(WCHAR);
        name.Buffer = ExAllocatePool(PagedPool, name.MaximumLength);
        if (!name.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(name.Buffer, (PCHAR) input + input->DeviceNameOffset,
                      name.Length);
        name.Buffer[name.Length/sizeof(WCHAR)] = 0;

        status = QueryPointsFromMemory(Extension, Irp, NULL, &name);

        ExFreePool(name.Buffer);

    } else {
        status = QueryPointsFromMemory(Extension, Irp, NULL, NULL);
    }

    return status;
}

VOID
SendLinkDeleted(
    IN  PUNICODE_STRING DeviceName,
    IN  PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine alerts the mounted device that one of its links is
    being deleted.

Arguments:

    DeviceName  - Supplies the device name.

    SymbolicLinkName    - Supplies the symbolic link name being deleted.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject      = NULL;
    ULONG               inputSize         = sizeof(USHORT) + SymbolicLinkName->Length;
    PMOUNTDEV_NAME      input             = NULL;
    BOOLEAN             objectsReferenced = FALSE;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;


    status = IoGetDeviceObjectPointer (DeviceName, 
                                       FILE_READ_ATTRIBUTES,
                                       &fileObject,
                                       &deviceObject);
    
    if (NT_SUCCESS (status)) {

        deviceObject = IoGetAttachedDeviceReference (fileObject->DeviceObject);

        objectsReferenced = TRUE;


        input = ExAllocatePool (PagedPool, inputSize);

        if (NULL == input) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }



    if (NT_SUCCESS (status)) {
        input->NameLength = SymbolicLinkName->Length;

        RtlCopyMemory (input->Name,
                       SymbolicLinkName->Buffer,
                       SymbolicLinkName->Length);



        /*
        ** First send the notification using the standard IOCTL. When
        ** that's done we'll send another using the obsolete IOCTL for
        ** all those third parties who have yet to recompile.
        */
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest (IOCTL_MOUNTDEV_LINK_DELETED,
                                             deviceObject,
                                             input,
                                             inputSize,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &ioStatus);

        if (NULL != irp) {

            irpSp = IoGetNextIrpStackLocation (irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver (deviceObject, irp);

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
            }
        }



        /*
        ** Now the 'obsolete' non-protected IOCTL
        */
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest (IOCTL_MOUNTDEV_LINK_DELETED_OBSOLETE,
                                             deviceObject,
                                             input,
                                             inputSize,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &ioStatus);

        if (NULL != irp) {

            irpSp = IoGetNextIrpStackLocation (irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver (deviceObject, irp);

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
            }
        }
    }



    if (NULL != input) {
        ExFreePool (input);
    }

    if (objectsReferenced) {
        ObDereferenceObject (deviceObject);
        ObDereferenceObject (fileObject);
    }


    return;
}

VOID
DeleteSymbolicLinkNameFromMemory(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     SymbolicLinkName,
    IN  BOOLEAN             DbOnly
    )

/*++

Routine Description:

    This routine deletes the given symbolic link name from memory.

Arguments:

    Extension           - Supplies the device extension.

    SymbolicLinkName    - Supplies the symbolic link name.

    DbOnly              - Supplies whether or not this is DBONLY.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        for (ll = deviceInfo->SymbolicLinkNames.Flink;
             ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

            symlinkEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);

            if (!RtlCompareUnicodeString(SymbolicLinkName,
                                         &symlinkEntry->SymbolicLinkName,
                                         TRUE)) {

                if (DbOnly) {
                    symlinkEntry->IsInDatabase = FALSE;
                } else {

                    SendLinkDeleted(&deviceInfo->NotificationName,
                                    SymbolicLinkName);

                    RemoveEntryList(ll);
                    ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
                    ExFreePool(symlinkEntry);
                }
                return;
            }
        }
    }
}

NTSTATUS
MountMgrDeletePoints(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine creates a mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_MOUNT_POINT   point;
    BOOLEAN                 singlePoint;
    NTSTATUS                status;
    PMOUNTMGR_MOUNT_POINTS  points;
    ULONG                   i;
    UNICODE_STRING          symbolicLinkName;
    PMOUNTDEV_UNIQUE_ID     uniqueId;
    UNICODE_STRING          deviceName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_MOUNT_POINT)) {

        return STATUS_INVALID_PARAMETER;
    }

    point = Irp->AssociatedIrp.SystemBuffer;
    if (point->SymbolicLinkNameOffset && point->SymbolicLinkNameLength) {
        singlePoint = TRUE;
    } else {
        singlePoint = FALSE;
    }

    status = MountMgrQueryPoints(Extension, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    points = Irp->AssociatedIrp.SystemBuffer;
    for (i = 0; i < points->NumberOfMountPoints; i++) {

        symbolicLinkName.Length = points->MountPoints[i].SymbolicLinkNameLength;
        symbolicLinkName.MaximumLength = symbolicLinkName.Length + sizeof(WCHAR);
        symbolicLinkName.Buffer = ExAllocatePool(PagedPool,
                                                 symbolicLinkName.MaximumLength);
        if (!symbolicLinkName.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(symbolicLinkName.Buffer,
                      (PCHAR) points +
                      points->MountPoints[i].SymbolicLinkNameOffset,
                      symbolicLinkName.Length);

        symbolicLinkName.Buffer[symbolicLinkName.Length/sizeof(WCHAR)] = 0;

        if (singlePoint && IsDriveLetter(&symbolicLinkName)) {
            uniqueId = ExAllocatePool(PagedPool,
                                      points->MountPoints[i].UniqueIdLength +
                                      sizeof(MOUNTDEV_UNIQUE_ID));
            if (uniqueId) {
                uniqueId->UniqueIdLength =
                        points->MountPoints[i].UniqueIdLength;
                RtlCopyMemory(uniqueId->UniqueId, (PCHAR) points +
                              points->MountPoints[i].UniqueIdOffset,
                              uniqueId->UniqueIdLength);

                CreateNoDriveLetterEntry(uniqueId);

                ExFreePool(uniqueId);
            }
        }

        if (i == 0 && !singlePoint) {
            uniqueId = ExAllocatePool(PagedPool,
                                      points->MountPoints[i].UniqueIdLength +
                                      sizeof(MOUNTDEV_UNIQUE_ID));
            if (uniqueId) {
                uniqueId->UniqueIdLength =
                        points->MountPoints[i].UniqueIdLength;
                RtlCopyMemory(uniqueId->UniqueId, (PCHAR) points +
                              points->MountPoints[i].UniqueIdOffset,
                              uniqueId->UniqueIdLength);

                DeleteNoDriveLetterEntry(uniqueId);

                ExFreePool(uniqueId);
            }
        }

        GlobalDeleteSymbolicLink(&symbolicLinkName);
        DeleteSymbolicLinkNameFromMemory(Extension, &symbolicLinkName, FALSE);

        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               symbolicLinkName.Buffer);

        ExFreePool(symbolicLinkName.Buffer);

        deviceName.Length = points->MountPoints[i].DeviceNameLength;
        deviceName.MaximumLength = deviceName.Length;
        deviceName.Buffer = (PWCHAR) ((PCHAR) points +
                                      points->MountPoints[i].DeviceNameOffset);

        MountMgrNotifyNameChange(Extension, &deviceName, TRUE);
    }

    MountMgrNotify(Extension);

    return status;
}

NTSTATUS
MountMgrDeletePointsDbOnly(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine deletes mount points from the database.  It does not
    delete the symbolic links or the in memory representation.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                status;
    PMOUNTMGR_MOUNT_POINTS  points;
    ULONG                   i;
    UNICODE_STRING          symbolicLinkName;
    PMOUNTDEV_UNIQUE_ID     uniqueId;

    status = MountMgrQueryPoints(Extension, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    points = Irp->AssociatedIrp.SystemBuffer;
    for (i = 0; i < points->NumberOfMountPoints; i++) {

        symbolicLinkName.Length = points->MountPoints[i].SymbolicLinkNameLength;
        symbolicLinkName.MaximumLength = symbolicLinkName.Length + sizeof(WCHAR);
        symbolicLinkName.Buffer = ExAllocatePool(PagedPool,
                                                 symbolicLinkName.MaximumLength);
        if (!symbolicLinkName.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(symbolicLinkName.Buffer,
                      (PCHAR) points +
                      points->MountPoints[i].SymbolicLinkNameOffset,
                      symbolicLinkName.Length);

        symbolicLinkName.Buffer[symbolicLinkName.Length/sizeof(WCHAR)] = 0;

        if (points->NumberOfMountPoints == 1 &&
            IsDriveLetter(&symbolicLinkName)) {

            uniqueId = ExAllocatePool(PagedPool,
                                      points->MountPoints[i].UniqueIdLength +
                                      sizeof(MOUNTDEV_UNIQUE_ID));
            if (uniqueId) {
                uniqueId->UniqueIdLength =
                        points->MountPoints[i].UniqueIdLength;
                RtlCopyMemory(uniqueId->UniqueId, (PCHAR) points +
                              points->MountPoints[i].UniqueIdOffset,
                              uniqueId->UniqueIdLength);

                CreateNoDriveLetterEntry(uniqueId);

                ExFreePool(uniqueId);
            }
        }

        DeleteSymbolicLinkNameFromMemory(Extension, &symbolicLinkName, TRUE);

        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               symbolicLinkName.Buffer);

        ExFreePool(symbolicLinkName.Buffer);
    }

    return status;
}

VOID
ProcessSuggestedDriveLetters(
    IN OUT  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine processes the saved suggested drive letters.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    UNICODE_STRING              symbolicLinkName;
    WCHAR                       symNameBuffer[30];

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo->SuggestedDriveLetter == 0xFF) {

            if (!HasDriveLetter(deviceInfo) &&
                !HasNoDriveLetterEntry(deviceInfo->UniqueId)) {

                CreateNoDriveLetterEntry(deviceInfo->UniqueId);
            }

            deviceInfo->SuggestedDriveLetter = 0;

        } else if (deviceInfo->SuggestedDriveLetter &&
                   !HasNoDriveLetterEntry(deviceInfo->UniqueId)) {

            symbolicLinkName.Length = symbolicLinkName.MaximumLength = 28;
            symbolicLinkName.Buffer = symNameBuffer;
            RtlCopyMemory(symbolicLinkName.Buffer, L"\\DosDevices\\", 24);
            symbolicLinkName.Buffer[12] = deviceInfo->SuggestedDriveLetter;
            symbolicLinkName.Buffer[13] = ':';

            MountMgrCreatePointWorker(Extension, &symbolicLinkName,
                                      &deviceInfo->DeviceName);
        }
    }
}

BOOLEAN
IsFtVolume(
    IN  PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine checks to see if the given volume is an FT volume.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    FALSE   - This is not an FT volume.

    TRUE    - This is an FT volume.

--*/

{
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject, checkObject;
    KEVENT                  event;
    PIRP                    irp;
    PARTITION_INFORMATION   partInfo;
    IO_STATUS_BLOCK         ioStatus;

    status = IoGetDeviceObjectPointer(DeviceName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }
    checkObject = fileObject->DeviceObject;
    deviceObject = IoGetAttachedDeviceReference(checkObject);

    if (checkObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return FALSE;
    }

    ObDereferenceObject(fileObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        deviceObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        return FALSE;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    if (IsFTPartition(partInfo.PartitionType)) {
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
MountMgrNextDriveLetterWorker(
    IN OUT  PDEVICE_EXTENSION                   Extension,
    IN      PUNICODE_STRING                     DeviceName,
    OUT     PMOUNTMGR_DRIVE_LETTER_INFORMATION  DriveLetterInfo
    )

{
    UNICODE_STRING                      deviceName = *DeviceName;
    PMOUNTMGR_DRIVE_LETTER_INFORMATION  output = DriveLetterInfo;
    UNICODE_STRING                      targetName;
    NTSTATUS                            status;
    BOOLEAN                             isRecognized, isRemovable;
    PLIST_ENTRY                         l;
    PMOUNTED_DEVICE_INFORMATION         deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY           symlinkEntry;
    UNICODE_STRING                      symbolicLinkName;
    WCHAR                               symNameBuffer[30];
    UCHAR                               startDriveLetterName;
    PMOUNTDEV_UNIQUE_ID                 uniqueId;

    if (!Extension->SuggestedDriveLettersProcessed) {
        ProcessSuggestedDriveLetters(Extension);
        Extension->SuggestedDriveLettersProcessed = TRUE;
    }

    status = QueryDeviceInformation(&deviceName, &targetName, NULL,
                                    &isRemovable, &isRecognized, NULL, NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (!RtlCompareUnicodeString(&targetName, &deviceInfo->DeviceName,
                                     TRUE)) {

            break;
        }
    }

    if (l == &Extension->MountedDeviceList) {
        ExFreePool(targetName.Buffer);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    deviceInfo->NextDriveLetterCalled = TRUE;

    output->DriveLetterWasAssigned = TRUE;

    for (l = deviceInfo->SymbolicLinkNames.Flink;
         l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        if (IsDriveLetter(&symlinkEntry->SymbolicLinkName) &&
            symlinkEntry->IsInDatabase) {

            output->DriveLetterWasAssigned = FALSE;
            output->CurrentDriveLetter =
                    (UCHAR) symlinkEntry->SymbolicLinkName.Buffer[12];
            break;
        }
    }

    if (l == &deviceInfo->SymbolicLinkNames &&
        (!isRecognized || HasNoDriveLetterEntry(deviceInfo->UniqueId))) {

        output->DriveLetterWasAssigned = FALSE;
        output->CurrentDriveLetter = 0;
        ExFreePool(targetName.Buffer);
        return STATUS_SUCCESS;
    }

    if (!Extension->AutoMountPermitted && !isRemovable) {
        if (output->DriveLetterWasAssigned) {
            output->DriveLetterWasAssigned = FALSE;
            output->CurrentDriveLetter = 0;
        }
        ExFreePool(targetName.Buffer);
        return STATUS_SUCCESS;
    }

    if (!output->DriveLetterWasAssigned) {
        ExFreePool(targetName.Buffer);
        return STATUS_SUCCESS;
    }

    if (RtlPrefixUnicodeString(&DeviceFloppy, &targetName, TRUE)) {
        startDriveLetterName = 'A';
    } else if (RtlPrefixUnicodeString(&DeviceCdRom, &targetName, TRUE)) {
        startDriveLetterName = 'D';
    } else {
        startDriveLetterName = 'C';
    }

    ASSERT(deviceInfo->SuggestedDriveLetter != 0xFF);

    if (!deviceInfo->SuggestedDriveLetter &&
        IsFtVolume(&deviceInfo->DeviceName)) {

        output->DriveLetterWasAssigned = FALSE;
        output->CurrentDriveLetter = 0;
        ExFreePool(targetName.Buffer);
        return STATUS_SUCCESS;
    }

    symbolicLinkName.Length = symbolicLinkName.MaximumLength = 28;
    symbolicLinkName.Buffer = symNameBuffer;
    RtlCopyMemory(symbolicLinkName.Buffer, DosDevices.Buffer, 24);
    symbolicLinkName.Buffer[13] = ':';

    if (deviceInfo->SuggestedDriveLetter) {
        output->CurrentDriveLetter = deviceInfo->SuggestedDriveLetter;
        symbolicLinkName.Buffer[12] = output->CurrentDriveLetter;
        status = MountMgrCreatePointWorker(Extension, &symbolicLinkName,
                                           &targetName);
        if (NT_SUCCESS(status)) {
            ExFreePool(targetName.Buffer);
            return STATUS_SUCCESS;
        }
    }

    for (output->CurrentDriveLetter = startDriveLetterName;
         output->CurrentDriveLetter <= 'Z';
         output->CurrentDriveLetter++) {

        symbolicLinkName.Buffer[12] = output->CurrentDriveLetter;
        status = MountMgrCreatePointWorker(Extension, &symbolicLinkName,
                                           &targetName);
        if (NT_SUCCESS(status)) {
            break;
        }
    }

    if (output->CurrentDriveLetter > 'Z') {
        output->CurrentDriveLetter = 0;
        output->DriveLetterWasAssigned = FALSE;
        status = QueryDeviceInformation(&targetName, NULL, &uniqueId,
                                        NULL, NULL, NULL, NULL, NULL);
        if (NT_SUCCESS(status)) {
            CreateNoDriveLetterEntry(uniqueId);
            ExFreePool(uniqueId);
        }
    }

    ExFreePool(targetName.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrNextDriveLetter(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine gives the next available drive letter to the given device
    unless the device already has a drive letter or the device has a flag
    specifying that it should not receive a drive letter.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_DRIVE_LETTER_TARGET       input;
    UNICODE_STRING                      deviceName;
    NTSTATUS                            status;
    MOUNTMGR_DRIVE_LETTER_INFORMATION   driveLetterInfo;
    PMOUNTMGR_DRIVE_LETTER_INFORMATION  output;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_DRIVE_LETTER_TARGET) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTMGR_DRIVE_LETTER_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = Irp->AssociatedIrp.SystemBuffer;
    if (input->DeviceNameLength +
        (ULONG) FIELD_OFFSET(MOUNTMGR_DRIVE_LETTER_TARGET, DeviceName) >
        irpSp->Parameters.DeviceIoControl.InputBufferLength) {

        return STATUS_INVALID_PARAMETER;
    }

    deviceName.MaximumLength = deviceName.Length = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = MountMgrNextDriveLetterWorker(Extension, &deviceName,
                                           &driveLetterInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    output = Irp->AssociatedIrp.SystemBuffer;
    *output = driveLetterInfo;

    Irp->IoStatus.Information = sizeof(MOUNTMGR_DRIVE_LETTER_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrVolumeMountPointChanged(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      NTSTATUS            ResultOfWaitForDatabase,
    OUT     PUNICODE_STRING     SourceVolume,
    OUT     PUNICODE_STRING     MountPath,
    OUT     PUNICODE_STRING     TargetVolume
    )

{
    PIO_STACK_LOCATION              irpSp  = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_VOLUME_MOUNT_POINT    input  = Irp->AssociatedIrp.SystemBuffer;
    OBJECT_ATTRIBUTES               oa;
    NTSTATUS                        status = STATUS_SUCCESS;
    HANDLE                          h      = NULL;
    IO_STATUS_BLOCK                 ioStatus;
    PFILE_OBJECT                    fileObject;
    UNICODE_STRING                  deviceName;
    UNICODE_STRING                  sourceVolumeName;
    FILE_FS_DEVICE_INFORMATION      fsDeviceInformation;
    OBJECT_NAME_INFORMATION         tempObjectNameInfo;
    PFILE_NAME_INFORMATION          fileNameInformation    = NULL;
    POBJECT_NAME_INFORMATION        objectNameInformation  = NULL;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo             = NULL;
    BOOLEAN                         fileObjectReferenced   = FALSE;
    ULONG                           returnedLength         = 0;
    ULONG                           allocationSize;
    

    deviceName.Buffer = NULL;


    if ((irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (MOUNTMGR_VOLUME_MOUNT_POINT)) ||
        (irpSp->Parameters.DeviceIoControl.InputBufferLength < 
                        (ULONG) MAX (input->SourceVolumeNameOffset + input->SourceVolumeNameLength,
                                     input->TargetVolumeNameOffset + input->TargetVolumeNameLength))) {
        status = STATUS_INVALID_PARAMETER;
    }


    if (NT_SUCCESS (status)) {
        sourceVolumeName.Length        = input->SourceVolumeNameLength;
        sourceVolumeName.MaximumLength = input->SourceVolumeNameLength;
        sourceVolumeName.Buffer        = (PWSTR) ((PCHAR) input + input->SourceVolumeNameOffset);

        InitializeObjectAttributes (&oa,
                                    &sourceVolumeName,
                                    OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
                                    0,
                                    0);

        status = ZwOpenFile (&h,
                             FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                             &oa,
                             &ioStatus,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT);


        if (!NT_SUCCESS (status)) {
            h = NULL;
        }
    }


    if (NT_SUCCESS (status)) {
        status = ZwQueryVolumeInformationFile (h,
                                               &ioStatus,
                                               &fsDeviceInformation,
                                               sizeof (fsDeviceInformation),
                                               FileFsDeviceInformation);
    }


    if (NT_SUCCESS (status) &&
        (!((FILE_DEVICE_DISK         == fsDeviceInformation.DeviceType) ||
           (FILE_DEVICE_VIRTUAL_DISK == fsDeviceInformation.DeviceType)) ||
        ((FILE_REMOVABLE_MEDIA | FILE_REMOTE_DEVICE) & fsDeviceInformation.Characteristics))) {
        /*
        ** If the device is 
        **      not a disk or virtual disk
        **      a remote file
        **      based on removable media,
        **
        ** then we are going to dis-allow the operation.
        */
        status = STATUS_INVALID_PARAMETER;
    }


    if (NT_SUCCESS (status)) {
        status = ObReferenceObjectByHandle (h, 
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID*) &fileObject,
                                            NULL);

        fileObjectReferenced = NT_SUCCESS (status);
    }



    if (NT_SUCCESS (status)) {

        allocationSize      = sizeof (FILE_NAME_INFORMATION);
        fileNameInformation = ExAllocatePool (PagedPool, allocationSize);

        status = (NULL == fileNameInformation) ? STATUS_INSUFFICIENT_RESOURCES : STATUS_SUCCESS;
        }


    if (NT_SUCCESS (status)) {

        status = ZwQueryInformationFile (h,
                                         &ioStatus,
                                         fileNameInformation,
                                         allocationSize,
                                         FileNameInformation);

        if (STATUS_BUFFER_OVERFLOW == status) {

            allocationSize = sizeof (FILE_NAME_INFORMATION) + fileNameInformation->FileNameLength; 

            ExFreePool (fileNameInformation);

            fileNameInformation = ExAllocatePool (PagedPool, allocationSize);

            status = (NULL == fileNameInformation) ? STATUS_INSUFFICIENT_RESOURCES : STATUS_SUCCESS;
        }
    }



    if (NT_SUCCESS (status)) {
        status = ZwQueryInformationFile (h,
                                         &ioStatus,
                                         fileNameInformation,
                                         allocationSize,
                                         FileNameInformation);
    }



    if (NT_SUCCESS (status)) {

        objectNameInformation = &tempObjectNameInfo;
        allocationSize        = sizeof (tempObjectNameInfo);

        status = ObQueryNameString (fileObject->DeviceObject,
                                    objectNameInformation,
                                    allocationSize,
                                    &returnedLength);

        if (STATUS_INFO_LENGTH_MISMATCH == status) {

            allocationSize = returnedLength;
        
            objectNameInformation = ExAllocatePool (PagedPool, allocationSize);

            status = (NULL == objectNameInformation) ? STATUS_INSUFFICIENT_RESOURCES : STATUS_SUCCESS;
        }
    }



    if (NT_SUCCESS (status)) {
        status = ObQueryNameString (fileObject->DeviceObject,
                                    objectNameInformation,
                                    allocationSize,
                                    &returnedLength);
    }



    if (NT_SUCCESS (status)) {
        status = QueryDeviceInformation (&objectNameInformation->Name,
                                         SourceVolume,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL);
    }



    if (NT_SUCCESS (status)) {
        TargetVolume->Length        = input->TargetVolumeNameLength;
        TargetVolume->MaximumLength = input->TargetVolumeNameLength;
        TargetVolume->Buffer        = (PWSTR) ((PCHAR) input + input->TargetVolumeNameOffset);

        status = QueryDeviceInformation (TargetVolume,
                                         &deviceName,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL);
    }



    if (NT_SUCCESS (status)) {
        MountPath->Length        = (USHORT) fileNameInformation->FileNameLength;
        MountPath->MaximumLength = (USHORT) fileNameInformation->FileNameLength;
        MountPath->Buffer        = (PVOID)  fileNameInformation;

        RtlMoveMemory (fileNameInformation, fileNameInformation->FileName, MountPath->Length);
        fileNameInformation = NULL;

        MountMgrNotify (Extension);
        MountMgrNotifyNameChange (Extension, &deviceName, TRUE);

        if (!NT_SUCCESS (ResultOfWaitForDatabase)) {
            status = FindDeviceInfo (Extension, 
                                     SourceVolume,
                                     FALSE,
                                     &deviceInfo);

            if (NT_SUCCESS(status)) {
                ReconcileThisDatabaseWithMaster (Extension, deviceInfo);
            } else {
                status = STATUS_PENDING;
            }
        }
    }



    if (NULL != deviceName.Buffer) {
        ExFreePool (deviceName.Buffer); 
    }

    if ((NULL                != objectNameInformation) &&
        (&tempObjectNameInfo != objectNameInformation)) {
        ExFreePool (objectNameInformation);
    }

    if (NULL != fileNameInformation) {
        ExFreePool (fileNameInformation); 
    }

    if (fileObjectReferenced) {
        ObDereferenceObject (fileObject); 
    }

    if (NULL != h) {
        ZwClose (h); 
    }

    return (status);
}

NTSTATUS
MountMgrQuerySymbolicLink(
    IN      PUNICODE_STRING SourceOfLink,
    IN OUT  PUNICODE_STRING TargetOfLink
    )

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;

    InitializeObjectAttributes(&oa, SourceOfLink, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwOpenSymbolicLinkObject(&handle, GENERIC_READ, &oa);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwQuerySymbolicLinkObject(handle, TargetOfLink, NULL);
    ZwClose(handle);

    if (NT_SUCCESS(status)) {
        if (TargetOfLink->Length > 1*sizeof(WCHAR) &&
            TargetOfLink->Buffer[TargetOfLink->Length/sizeof(WCHAR) - 1] ==
            '\\') {

            TargetOfLink->Length -= sizeof(WCHAR);
            TargetOfLink->Buffer[TargetOfLink->Length/sizeof(WCHAR)] = 0;
        }
    }

    return status;
}

NTSTATUS
MountMgrVolumeMountPointCreated(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      NTSTATUS            ResultOfWaitForDatabase
    )

/*++

Routine Description:

    This routine alerts that mount manager that a volume mount point has
    been created so that the mount manager can replicate the database entry
    for the given mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              sourceVolume, mountPath, targetVolume, v, p;
    PMOUNTED_DEVICE_INFORMATION sourceDeviceInfo, targetDeviceInfo;
    HANDLE                      h;
    ULONG                       offset;
    BOOLEAN                     entryFound;
    PMOUNTMGR_FILE_ENTRY        databaseEntry;
    UNICODE_STRING              otherTargetVolumeName;
    PMOUNTDEV_UNIQUE_ID         uniqueId;
    ULONG                       size;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    v.MaximumLength = MAX_VOLUME_PATH*sizeof(WCHAR);
    v.Length = 0;
    v.Buffer = ExAllocatePool (PagedPool, v.MaximumLength);

    if (NULL == v.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    status = MountMgrVolumeMountPointChanged(Extension, Irp,
                                             ResultOfWaitForDatabase,
                                             &sourceVolume, &mountPath,
                                             &targetVolume);
    if (status == STATUS_PENDING) {
        ExFreePool (v.Buffer);
        ExFreePool (sourceVolume.Buffer);
        ExFreePool (mountPath.Buffer);
        return STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool (v.Buffer);
        return status;
    }

    status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                            &sourceDeviceInfo);
    if (!NT_SUCCESS(status)) {

        status = QueryVolumeName(NULL, NULL, &sourceVolume, &v, &p);
        if (NT_SUCCESS(status)) {
            ExFreePool(p.Buffer);
        } else {
            status = MountMgrQuerySymbolicLink(&sourceVolume, &v);
            if (!NT_SUCCESS(status)) {
                ExFreePool (v.Buffer);
                ExFreePool (sourceVolume.Buffer);
                ExFreePool (mountPath.Buffer);
                return status;
            }
        }

        ExFreePool (sourceVolume.Buffer);
        sourceVolume = v;

        status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                                &sourceDeviceInfo);
        if (!NT_SUCCESS(status)) {
            ExFreePool (sourceVolume.Buffer);
            ExFreePool (mountPath.Buffer);
            return status;
        }
    }


    ExFreePool (sourceVolume.Buffer);


    status = FindDeviceInfo(Extension, &targetVolume, FALSE,
                            &targetDeviceInfo);
    if (!NT_SUCCESS(status)) {
        ExFreePool (mountPath.Buffer);
        return status;
    }

    if (!targetDeviceInfo->InOfflineList) {
        PostOnlineNotification(&targetDeviceInfo->NotificationName);
    }

    h = OpenRemoteDatabase(sourceDeviceInfo, TRUE);
    if (!h) {
        ExFreePool (mountPath.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset = 0;
    entryFound = FALSE;
    for (;;) {

        databaseEntry = GetRemoteDatabaseEntry(h, offset);
        if (!databaseEntry) {
            break;
        }

        otherTargetVolumeName.Length = otherTargetVolumeName.MaximumLength =
                databaseEntry->VolumeNameLength;
        otherTargetVolumeName.Buffer = (PWSTR) ((PCHAR) databaseEntry +
                                       databaseEntry->VolumeNameOffset);

        if (RtlEqualUnicodeString(&targetVolume, &otherTargetVolumeName,
                                  TRUE)) {

            entryFound = TRUE;
            break;
        }

        offset += databaseEntry->EntryLength;
        ExFreePool(databaseEntry);
    }

    if (entryFound) {

        databaseEntry->RefCount++;
        status = WriteRemoteDatabaseEntry(h, offset, databaseEntry);
        ExFreePool(databaseEntry);

    } else {

        status = QueryDeviceInformation(&targetVolume, NULL, &uniqueId, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            ExFreePool (mountPath.Buffer);
            CloseRemoteDatabase(h);
            return status;
        }

        size = sizeof(MOUNTMGR_FILE_ENTRY) + targetVolume.Length +
               uniqueId->UniqueIdLength;

        databaseEntry = ExAllocatePool(PagedPool, size);
        if (!databaseEntry) {
            ExFreePool(uniqueId);
            ExFreePool (mountPath.Buffer);
            CloseRemoteDatabase(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        databaseEntry->EntryLength = size;
        databaseEntry->RefCount = 1;
        databaseEntry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
        databaseEntry->VolumeNameLength = targetVolume.Length;
        databaseEntry->UniqueIdOffset = databaseEntry->VolumeNameOffset +
                                        databaseEntry->VolumeNameLength;
        databaseEntry->UniqueIdLength = uniqueId->UniqueIdLength;

        RtlCopyMemory((PCHAR) databaseEntry + databaseEntry->VolumeNameOffset,
                      targetVolume.Buffer, databaseEntry->VolumeNameLength);
        RtlCopyMemory((PCHAR) databaseEntry + databaseEntry->UniqueIdOffset,
                      uniqueId->UniqueId, databaseEntry->UniqueIdLength);

        status = AddRemoteDatabaseEntry(h, databaseEntry);

        ExFreePool(databaseEntry);

        if (!NT_SUCCESS(status)) {
            ExFreePool(uniqueId);
            ExFreePool (mountPath.Buffer);
            CloseRemoteDatabase(h);
            return status;
        }

        replUniqueId = ExAllocatePool(PagedPool, sizeof(REPLICATED_UNIQUE_ID));
        if (!replUniqueId) {
            ExFreePool(uniqueId);
            CloseRemoteDatabase(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        replUniqueId->UniqueId = uniqueId;

        InsertTailList(&sourceDeviceInfo->ReplicatedUniqueIds,
                       &replUniqueId->ListEntry);
    }

    CloseRemoteDatabase(h);

    if (!NT_SUCCESS(status)) {
        ExFreePool (mountPath.Buffer);
        return status;
    }

    mountPointEntry = (PMOUNTMGR_MOUNT_POINT_ENTRY)
                      ExAllocatePool(PagedPool,
                                     sizeof(MOUNTMGR_MOUNT_POINT_ENTRY));
    if (!mountPointEntry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mountPointEntry->MountPath.Length = mountPath.Length;
    mountPointEntry->MountPath.MaximumLength = mountPath.Length +
                                               sizeof(WCHAR);
    mountPointEntry->MountPath.Buffer =
            ExAllocatePool(PagedPool,
                           mountPointEntry->MountPath.MaximumLength);
    if (!mountPointEntry->MountPath.Buffer) {
        ExFreePool(mountPointEntry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(mountPointEntry->MountPath.Buffer,
                  mountPath.Buffer, mountPath.Length);
    mountPointEntry->MountPath.Buffer[mountPath.Length/sizeof(WCHAR)] = 0;

    mountPointEntry->DeviceInfo = sourceDeviceInfo;
    InsertTailList(&targetDeviceInfo->MountPointsPointingHere,
                   &mountPointEntry->ListEntry);

    ExFreePool (mountPath.Buffer);
    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrVolumeMountPointDeleted(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      NTSTATUS            ResultOfWaitForDatabase
    )

/*++

Routine Description:

    This routine alerts that mount manager that a volume mount point has
    been created so that the mount manager can replicate the database entry
    for the given mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              sourceVolume, mountPath, targetVolume, v, p;
    PMOUNTED_DEVICE_INFORMATION sourceDeviceInfo, targetDeviceInfo;
    HANDLE                      h;
    ULONG                       offset;
    BOOLEAN                     entryFound;
    PMOUNTMGR_FILE_ENTRY        databaseEntry;
    UNICODE_STRING              otherTargetVolumeName;
    PLIST_ENTRY                 l;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;


    v.MaximumLength = MAX_VOLUME_PATH*sizeof(WCHAR);
    v.Length = 0;
    v.Buffer = ExAllocatePool (PagedPool, v.MaximumLength);

    if (NULL == v.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    status = MountMgrVolumeMountPointChanged(Extension, Irp,
                                             ResultOfWaitForDatabase,
                                             &sourceVolume, &mountPath,
                                             &targetVolume);
    if (status == STATUS_PENDING) {
        ExFreePool (v.Buffer);
        ExFreePool (sourceVolume.Buffer);
        ExFreePool (mountPath.Buffer);
        return STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool (v.Buffer);
        return status;
    }

    status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                            &sourceDeviceInfo);
    if (!NT_SUCCESS(status)) {

        status = QueryVolumeName(NULL, NULL, &sourceVolume, &v, &p);
        if (NT_SUCCESS(status)) {
            ExFreePool(p.Buffer);
        } else {
            status = MountMgrQuerySymbolicLink(&sourceVolume, &v);
            if (!NT_SUCCESS(status)) {
                ExFreePool (v.Buffer);
                ExFreePool (sourceVolume.Buffer);
                ExFreePool (mountPath.Buffer);
                return status;
            }
        }

        ExFreePool (sourceVolume.Buffer);
        sourceVolume = v;

        status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                                &sourceDeviceInfo);
        if (!NT_SUCCESS(status)) {
            ExFreePool (sourceVolume.Buffer);
            ExFreePool (mountPath.Buffer);
            return status;
        }
    }

    ExFreePool (sourceVolume.Buffer);


    status = FindDeviceInfo(Extension, &targetVolume, FALSE,
                            &targetDeviceInfo);
    if (!NT_SUCCESS(status)) {
        ExFreePool (mountPath.Buffer);
        return status;
    }

    h = OpenRemoteDatabase(sourceDeviceInfo, TRUE);
    if (!h) {
        ExFreePool (mountPath.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset = 0;
    entryFound = FALSE;
    for (;;) {

        databaseEntry = GetRemoteDatabaseEntry(h, offset);
        if (!databaseEntry) {
            break;
        }

        otherTargetVolumeName.Length = otherTargetVolumeName.MaximumLength =
                databaseEntry->VolumeNameLength;
        otherTargetVolumeName.Buffer = (PWSTR) ((PCHAR) databaseEntry +
                                       databaseEntry->VolumeNameOffset);

        if (RtlEqualUnicodeString(&targetVolume, &otherTargetVolumeName,
                                  TRUE)) {

            entryFound = TRUE;
            break;
        }

        offset += databaseEntry->EntryLength;
        ExFreePool(databaseEntry);
    }

    if (!entryFound) {
        ExFreePool (mountPath.Buffer);
        CloseRemoteDatabase(h);
        return STATUS_INVALID_PARAMETER;
    }

    databaseEntry->RefCount--;
    if (databaseEntry->RefCount) {
        status = WriteRemoteDatabaseEntry(h, offset, databaseEntry);
    } else {
        status = DeleteRemoteDatabaseEntry(h, offset);
        if (!NT_SUCCESS(status)) {
            ExFreePool(databaseEntry);
            ExFreePool (mountPath.Buffer);
            CloseRemoteDatabase(h);
            return status;
        }

        for (l = sourceDeviceInfo->ReplicatedUniqueIds.Flink;
             l != &sourceDeviceInfo->ReplicatedUniqueIds; l = l->Flink) {

            replUniqueId = CONTAINING_RECORD(l, REPLICATED_UNIQUE_ID,
                                             ListEntry);

            if (replUniqueId->UniqueId->UniqueIdLength ==
                databaseEntry->UniqueIdLength &&
                RtlCompareMemory(replUniqueId->UniqueId->UniqueId,
                                 (PCHAR) databaseEntry +
                                 databaseEntry->UniqueIdOffset,
                                 databaseEntry->UniqueIdLength) ==
                                 databaseEntry->UniqueIdLength) {

                break;
            }
        }

        if (l == &sourceDeviceInfo->ReplicatedUniqueIds) {
            ExFreePool(databaseEntry);
            ExFreePool (mountPath.Buffer);
            CloseRemoteDatabase(h);
            return STATUS_UNSUCCESSFUL;
        }

        RemoveEntryList(l);
        ExFreePool(replUniqueId->UniqueId);
        ExFreePool(replUniqueId);
    }

    ExFreePool(databaseEntry);
    CloseRemoteDatabase(h);

    if (!NT_SUCCESS(status)) {
        ExFreePool (mountPath.Buffer);
        return status;
    }

    for (l = targetDeviceInfo->MountPointsPointingHere.Flink;
         l != &targetDeviceInfo->MountPointsPointingHere; l = l->Flink) {

        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        if (mountPointEntry->DeviceInfo == sourceDeviceInfo &&
            RtlEqualUnicodeString(&mountPointEntry->MountPath,
                                  &mountPath, TRUE)) {

            RemoveEntryList(l);
            ExFreePool(mountPointEntry->MountPath.Buffer);
            ExFreePool(mountPointEntry);
            break;
        }
    }

    ExFreePool (mountPath.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrKeepLinksWhenOffline(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets up the internal data structure to remember to keep
    the symbolic links for the given device even when the device goes offline.
    Then when the device becomes on-line again, it is guaranteed that these
    links will be available and not taken by some other device.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME       input = Irp->AssociatedIrp.SystemBuffer;
    ULONG                       size;
    UNICODE_STRING              deviceName;
    NTSTATUS                    status;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    size = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
           input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < size) {
        return STATUS_INVALID_PARAMETER;
    }

    deviceName.Length = deviceName.MaximumLength = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = FindDeviceInfo(Extension, &deviceName, FALSE, &deviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    deviceInfo->KeepLinksWhenOffline = TRUE;

    return STATUS_SUCCESS;
}

VOID
ReconcileAllDatabasesWithMaster(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine goes through all of the devices known to the MOUNTMGR and
    reconciles their database with the master database.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo->IsRemovable) {
            continue;
        }

        ReconcileThisDatabaseWithMaster(Extension, deviceInfo);
    }
}

NTSTATUS
MountMgrCheckUnprocessedVolumes(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets up the internal data structure to remember to keep
    the symbolic links for the given device even when the device goes offline.
    Then when the device becomes on-line again, it is guaranteed that these
    links will be available and not taken by some other device.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status = STATUS_SUCCESS;
    LIST_ENTRY                  q;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    NTSTATUS                    status2;

    if (IsListEmpty(&Extension->DeadMountedDeviceList)) {
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    q = Extension->DeadMountedDeviceList;
    InitializeListHead(&Extension->DeadMountedDeviceList);

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    q.Blink->Flink = &q;
    q.Flink->Blink = &q;

    while (!IsListEmpty(&q)) {

        l = RemoveHeadList(&q);

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        status2 = MountMgrMountedDeviceArrival(Extension,
                                               &deviceInfo->NotificationName,
                                               deviceInfo->NotAPdo);
        MountMgrFreeDeadDeviceInfo (deviceInfo);

        if (NT_SUCCESS(status)) {
            status = status2;
        }
    }

    return status;
}

NTSTATUS
MountMgrVolumeArrivalNotification(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine performs the same actions as though PNP had notified
    the mount manager of a new volume arrival.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME       input = Irp->AssociatedIrp.SystemBuffer;
    ULONG                       size;
    UNICODE_STRING              deviceName;
    BOOLEAN                     oldHardErrorMode;
    NTSTATUS                    status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    size = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
           input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < size) {
        return STATUS_INVALID_PARAMETER;
    }

    deviceName.Length = deviceName.MaximumLength = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    oldHardErrorMode = PsGetThreadHardErrorsAreDisabled(PsGetCurrentThread());
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),TRUE);

    status = MountMgrMountedDeviceArrival(Extension, &deviceName, TRUE);

    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),oldHardErrorMode);

    return status;
}

NTSTATUS
MountMgrQuerySystemVolumeNameQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the system volume name.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PUNICODE_STRING systemVolumeName = Context;
    UNICODE_STRING  string;

    if (ValueType != REG_SZ) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueData);

    systemVolumeName->Length = string.Length;
    systemVolumeName->MaximumLength = systemVolumeName->Length + sizeof(WCHAR);
    systemVolumeName->Buffer = ExAllocatePool(PagedPool,
                                              systemVolumeName->MaximumLength);
    if (!systemVolumeName->Buffer) {
        return STATUS_SUCCESS;
    }

    RtlCopyMemory(systemVolumeName->Buffer, ValueData,
                  systemVolumeName->Length);
    systemVolumeName->Buffer[systemVolumeName->Length/sizeof(WCHAR)] = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQuerySystemVolumeName(
    OUT PUNICODE_STRING SystemVolumeName
    )

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = MountMgrQuerySystemVolumeNameQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"SystemPartition";

    SystemVolumeName->Buffer = NULL;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\Setup",
                           queryTable, SystemVolumeName, NULL);

    if (!SystemVolumeName->Buffer) {
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

VOID
MountMgrAssignDriveLetters(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine is invoked after IoAssignDriveLetters has run.  It goes
    through all of the mounted devices and checks to see whether or not they
    need to get a drive letter.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    NTSTATUS                            status;
    UNICODE_STRING                      systemVolumeName;
    PLIST_ENTRY                         l;
    PMOUNTED_DEVICE_INFORMATION         deviceInfo;
    MOUNTMGR_DRIVE_LETTER_INFORMATION   driveLetterInfo;

    status = MountMgrQuerySystemVolumeName(&systemVolumeName);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);
        if (!deviceInfo->NextDriveLetterCalled) {
            MountMgrNextDriveLetterWorker(Extension, &deviceInfo->DeviceName,
                                          &driveLetterInfo);
        }
        if (NT_SUCCESS(status) &&
            RtlEqualUnicodeString(&systemVolumeName, &deviceInfo->DeviceName,
                                  TRUE)) {

            Extension->SystemPartitionUniqueId =
                    ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                    deviceInfo->UniqueId->UniqueIdLength);
            if (Extension->SystemPartitionUniqueId) {
                Extension->SystemPartitionUniqueId->UniqueIdLength =
                        deviceInfo->UniqueId->UniqueIdLength;
                RtlCopyMemory(Extension->SystemPartitionUniqueId->UniqueId,
                              deviceInfo->UniqueId->UniqueId,
                              deviceInfo->UniqueId->UniqueIdLength);
            }

            if (!Extension->AutoMountPermitted) {
                Extension->AutoMountPermitted = TRUE;
                MountMgrNextDriveLetterWorker(Extension,
                                              &deviceInfo->DeviceName,
                                              &driveLetterInfo);
                Extension->AutoMountPermitted = FALSE;
            }
        }
    }

    if (NT_SUCCESS(status)) {
        ExFreePool(systemVolumeName.Buffer);
    }
}

NTSTATUS
MountMgrValidateBackPointer(
    IN  PMOUNTMGR_MOUNT_POINT_ENTRY MountPointEntry,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo,
    OUT PBOOLEAN                    InvalidBackPointer
    )

{
    UNICODE_STRING              reparseName, volumeName;
    OBJECT_ATTRIBUTES           oa;
    NTSTATUS                    status;
    HANDLE                      h;
    IO_STATUS_BLOCK             ioStatus;
    PREPARSE_DATA_BUFFER        reparse;
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;

    reparseName.Length = MountPointEntry->DeviceInfo->DeviceName.Length +
                         sizeof(WCHAR) + MountPointEntry->MountPath.Length;
    reparseName.MaximumLength = reparseName.Length + sizeof(WCHAR);
    reparseName.Buffer = ExAllocatePool(PagedPool, reparseName.MaximumLength);
    if (!reparseName.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(reparseName.Buffer,
                  MountPointEntry->DeviceInfo->DeviceName.Buffer,
                  MountPointEntry->DeviceInfo->DeviceName.Length);
    reparseName.Length = MountPointEntry->DeviceInfo->DeviceName.Length;
    reparseName.Buffer[reparseName.Length/sizeof(WCHAR)] = '\\';
    reparseName.Length += sizeof(WCHAR);
    RtlCopyMemory((PCHAR) reparseName.Buffer + reparseName.Length,
                  MountPointEntry->MountPath.Buffer,
                  MountPointEntry->MountPath.Length);
    reparseName.Length += MountPointEntry->MountPath.Length;
    reparseName.Buffer[reparseName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &reparseName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwOpenFile(
            &h, 
            FILE_READ_ATTRIBUTES | SYNCHRONIZE, 
            &oa, 
            &ioStatus,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT
            );
    ExFreePool(reparseName.Buffer);
    if (!NT_SUCCESS(status)) {
        *InvalidBackPointer = TRUE;
        return STATUS_SUCCESS;
    }

    reparse = ExAllocatePool(PagedPool, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        ZwClose(h);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                             FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                             MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    ZwClose(h);
    if (!NT_SUCCESS(status)) {
        *InvalidBackPointer = TRUE;
        ExFreePool(reparse);
        return STATUS_SUCCESS;
    }

    volumeName.MaximumLength = volumeName.Length =
            reparse->MountPointReparseBuffer.SubstituteNameLength;
    volumeName.Buffer = (PWCHAR)
                        ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                        reparse->MountPointReparseBuffer.SubstituteNameOffset);
    if (!MOUNTMGR_IS_NT_VOLUME_NAME_WB(&volumeName)) {
        ExFreePool(reparse);
        *InvalidBackPointer = TRUE;
        return STATUS_SUCCESS;
    }

    volumeName.Length -= sizeof(WCHAR);

    for (l = DeviceInfo->SymbolicLinkNames.Flink;
         l != &DeviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        if (RtlEqualUnicodeString(&volumeName, &symlinkEntry->SymbolicLinkName,
                                  TRUE)) {

            ExFreePool(reparse);
            return STATUS_SUCCESS;
        }
    }

    ExFreePool(reparse);
    *InvalidBackPointer = TRUE;
    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryVolumePaths(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PMOUNTED_DEVICE_INFORMATION     DeviceInfo,
    IN  PLIST_ENTRY                     DeviceInfoList,
    OUT PMOUNTMGR_VOLUME_PATHS*         VolumePaths,
    OUT PMOUNTED_DEVICE_INFORMATION*    ReconcileThisDeviceInfo
    )

{
    PLIST_ENTRY                 l;
    PMOUNTMGR_DEVICE_ENTRY      entry;
    ULONG                       MultiSzLength;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    ULONG                       numPoints, i, j, k;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;
    PMOUNTMGR_VOLUME_PATHS*     childVolumePaths;
    NTSTATUS                    status;
    PMOUNTMGR_VOLUME_PATHS      volumePaths;
    LIST_ENTRY                  deviceInfoList;
    BOOLEAN                     invalidBackPointer;

    MultiSzLength = sizeof(WCHAR);

    for (l = DeviceInfo->SymbolicLinkNames.Flink;
         l != &DeviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);
        if (MOUNTMGR_IS_DRIVE_LETTER(&symlinkEntry->SymbolicLinkName) &&
            symlinkEntry->IsInDatabase) {

            MultiSzLength += 3*sizeof(WCHAR);
            break;
        }
    }

    if (l == &DeviceInfo->SymbolicLinkNames) {
        symlinkEntry = NULL;
    }

    for (l = DeviceInfoList->Flink; l != DeviceInfoList; l = l->Flink) {

        entry = CONTAINING_RECORD(l, MOUNTMGR_DEVICE_ENTRY, ListEntry);

        if (entry->DeviceInfo == DeviceInfo) {
            volumePaths = ExAllocatePool(PagedPool,
                          FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                          MultiSzLength);
            if (!volumePaths) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            volumePaths->MultiSzLength = MultiSzLength;
            if (symlinkEntry) {
                volumePaths->MultiSz[0] =
                        symlinkEntry->SymbolicLinkName.Buffer[12];
                volumePaths->MultiSz[1] = ':';
                volumePaths->MultiSz[2] = 0;
                volumePaths->MultiSz[3] = 0;
            } else {
                volumePaths->MultiSz[0] = 0;
            }

            *VolumePaths = volumePaths;

            return STATUS_SUCCESS;
        }
    }

    entry = ExAllocatePool(PagedPool, sizeof(MOUNTMGR_DEVICE_ENTRY));
    if (!entry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    entry->DeviceInfo = DeviceInfo;
    InsertTailList(DeviceInfoList, &entry->ListEntry);

    numPoints = 0;
    for (l = DeviceInfo->MountPointsPointingHere.Flink;
         l != &DeviceInfo->MountPointsPointingHere; l = l->Flink) {

        numPoints++;
    }

    if (numPoints) {
        childVolumePaths = ExAllocatePool(PagedPool,
                                          numPoints*sizeof(PMOUNTMGR_VOLUME_PATHS));
        if (!childVolumePaths) {
            RemoveEntryList(&entry->ListEntry);
            ExFreePool(entry);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        childVolumePaths = NULL;
    }

    i = 0;
    for (l = DeviceInfo->MountPointsPointingHere.Flink;
         l != &DeviceInfo->MountPointsPointingHere; l = l->Flink, i++) {

        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        invalidBackPointer = FALSE;
        status = MountMgrValidateBackPointer(mountPointEntry, DeviceInfo,
                                             &invalidBackPointer);
        if (invalidBackPointer) {
            *ReconcileThisDeviceInfo = mountPointEntry->DeviceInfo;
            status = STATUS_UNSUCCESSFUL;
        }

        if (!NT_SUCCESS(status)) {
            for (j = 0; j < i; j++) {
                ExFreePool(childVolumePaths[j]);
            }
            ExFreePool(childVolumePaths);
            RemoveEntryList(&entry->ListEntry);
            ExFreePool(entry);
            return status;
        }

        status = MountMgrQueryVolumePaths(Extension,
                                          mountPointEntry->DeviceInfo,
                                          DeviceInfoList,
                                          &childVolumePaths[i],
                                          ReconcileThisDeviceInfo);
        if (!NT_SUCCESS(status)) {
            for (j = 0; j < i; j++) {
                ExFreePool(childVolumePaths[j]);
            }
            ExFreePool(childVolumePaths);
            RemoveEntryList(&entry->ListEntry);
            ExFreePool(entry);
            return status;
        }

        k = 0;
        for (j = 0; j < childVolumePaths[i]->MultiSzLength/sizeof(WCHAR) - 1;
             j++) {

            if (!childVolumePaths[i]->MultiSz[j]) {
                k++;
            }
        }

        MultiSzLength += k*mountPointEntry->MountPath.Length +
                         childVolumePaths[i]->MultiSzLength - sizeof(WCHAR);
    }

    volumePaths = ExAllocatePool(PagedPool,
                  FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                  MultiSzLength);
    if (!volumePaths) {
        for (i = 0; i < numPoints; i++) {
            ExFreePool(childVolumePaths[i]);
        }
        if (childVolumePaths) {
            ExFreePool(childVolumePaths);
        }
        RemoveEntryList(&entry->ListEntry);
        ExFreePool(entry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    volumePaths->MultiSzLength = MultiSzLength;

    j = 0;
    if (symlinkEntry) {
        volumePaths->MultiSz[j++] = symlinkEntry->SymbolicLinkName.Buffer[12];
        volumePaths->MultiSz[j++] = ':';
        volumePaths->MultiSz[j++] = 0;
    }

    i = 0;
    for (l = DeviceInfo->MountPointsPointingHere.Flink;
         l != &DeviceInfo->MountPointsPointingHere; l = l->Flink, i++) {

        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        for (k = 0; k < childVolumePaths[i]->MultiSzLength/sizeof(WCHAR) - 1;
             k++) {

            if (childVolumePaths[i]->MultiSz[k]) {
                volumePaths->MultiSz[j++] = childVolumePaths[i]->MultiSz[k];
            } else {
                RtlCopyMemory(&volumePaths->MultiSz[j],
                              mountPointEntry->MountPath.Buffer,
                              mountPointEntry->MountPath.Length);
                j += mountPointEntry->MountPath.Length/sizeof(WCHAR);
                volumePaths->MultiSz[j++] = 0;
            }
        }

        ExFreePool(childVolumePaths[i]);
    }
    volumePaths->MultiSz[j] = 0;

    if (childVolumePaths) {
        ExFreePool(childVolumePaths);
    }

    RemoveEntryList(&entry->ListEntry);
    ExFreePool(entry);

    *VolumePaths = volumePaths;

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryDosVolumePaths(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME           input = (PMOUNTMGR_TARGET_NAME) Irp->AssociatedIrp.SystemBuffer;
    PMOUNTMGR_VOLUME_PATHS          output = (PMOUNTMGR_VOLUME_PATHS) Irp->AssociatedIrp.SystemBuffer;
    ULONG                           len, i;
    UNICODE_STRING                  deviceName;
    NTSTATUS                        status;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo, reconcileThisDeviceInfo, d;
    PMOUNTMGR_VOLUME_PATHS          volumePaths;
    LIST_ENTRY                      deviceInfoList;
    RECONCILE_WORK_ITEM_INFO        workItemInfo;
    PLIST_ENTRY                     l;
    BOOLEAN                         assertNameChange;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->DeviceNameLength&1) {
        return STATUS_INVALID_PARAMETER;
    }

    len = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
          input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < len) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz)) {

        return STATUS_INVALID_PARAMETER;
    }

    deviceName.MaximumLength = deviceName.Length = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = FindDeviceInfo(Extension, &deviceName, FALSE, &deviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    assertNameChange = FALSE;
    for (i = 0; i < 1000; i++) {
        InitializeListHead(&deviceInfoList);
        reconcileThisDeviceInfo = NULL;
        status = MountMgrQueryVolumePaths(Extension, deviceInfo,
                                          &deviceInfoList, &volumePaths,
                                          &reconcileThisDeviceInfo);
        if (NT_SUCCESS(status)) {
            break;
        }

        if (!reconcileThisDeviceInfo) {
            return status;
        }

        if (!deviceInfo->NotAPdo) {
            assertNameChange = TRUE;
        }

        workItemInfo.Extension = Extension;
        workItemInfo.DeviceInfo = reconcileThisDeviceInfo;
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        ReconcileThisDatabaseWithMasterWorker(&workItemInfo);

        KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode,
                              FALSE, NULL);

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (d == deviceInfo) {
                break;
            }
        }

        if (l == &Extension->MountedDeviceList) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (assertNameChange) {
        MountMgrNotifyNameChange(Extension, &deviceName, FALSE);
    }

    output->MultiSzLength = volumePaths->MultiSzLength;
    Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                                output->MultiSzLength;

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        ExFreePool(volumePaths);
        Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS,
                                                 MultiSz);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->MultiSz, volumePaths->MultiSz,
                  output->MultiSzLength);

    ExFreePool(volumePaths);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryDosVolumePath(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME       input = (PMOUNTMGR_TARGET_NAME) Irp->AssociatedIrp.SystemBuffer;
    PMOUNTMGR_VOLUME_PATHS      output = (PMOUNTMGR_VOLUME_PATHS) Irp->AssociatedIrp.SystemBuffer;
    ULONG                       len, i;
    UNICODE_STRING              deviceName;
    NTSTATUS                    status;
    PMOUNTED_DEVICE_INFORMATION deviceInfo, origDeviceInfo;
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    UNICODE_STRING              path, oldPath;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->DeviceNameLength&1) {
        return STATUS_INVALID_PARAMETER;
    }

    len = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
          input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < len) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz)) {

        return STATUS_INVALID_PARAMETER;
    }

    deviceName.MaximumLength = deviceName.Length = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = FindDeviceInfo(Extension, &deviceName, FALSE, &deviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    origDeviceInfo = deviceInfo;

    path.Length = path.MaximumLength = 0;
    path.Buffer = NULL;

    for (i = 0; i < 1000; i++) {

        for (l = deviceInfo->SymbolicLinkNames.Flink;
             l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

            symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);
            if (MOUNTMGR_IS_DRIVE_LETTER(&symlinkEntry->SymbolicLinkName) &&
                symlinkEntry->IsInDatabase) {

                break;
            }
        }

        if (l != &deviceInfo->SymbolicLinkNames) {
            oldPath = path;
            path.Length += 2*sizeof(WCHAR);
            path.MaximumLength = path.Length;
            path.Buffer = ExAllocatePool(PagedPool, path.MaximumLength);
            if (!path.Buffer) {
                if (oldPath.Buffer) {
                    ExFreePool(oldPath.Buffer);
                }
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            path.Buffer[0] = symlinkEntry->SymbolicLinkName.Buffer[12];
            path.Buffer[1] = ':';

            if (oldPath.Buffer) {
                RtlCopyMemory(&path.Buffer[2], oldPath.Buffer, oldPath.Length);
                ExFreePool(oldPath.Buffer);
            }
            break;
        }

        if (IsListEmpty(&deviceInfo->MountPointsPointingHere)) {
            break;
        }

        l = deviceInfo->MountPointsPointingHere.Flink;
        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        oldPath = path;
        path.Length += mountPointEntry->MountPath.Length;
        path.MaximumLength = path.Length;
        path.Buffer = ExAllocatePool(PagedPool, path.MaximumLength);
        if (!path.Buffer) {
            if (oldPath.Buffer) {
                ExFreePool(oldPath.Buffer);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(path.Buffer, mountPointEntry->MountPath.Buffer,
                      mountPointEntry->MountPath.Length);

        if (oldPath.Buffer) {
            RtlCopyMemory(
                &path.Buffer[mountPointEntry->MountPath.Length/sizeof(WCHAR)],
                oldPath.Buffer, oldPath.Length);
            ExFreePool(oldPath.Buffer);
        }

        deviceInfo = mountPointEntry->DeviceInfo;
    }

    if (path.Length < 2*sizeof(WCHAR) || path.Buffer[1] != ':') {

        if (path.Buffer) {
            ExFreePool(path.Buffer);
        }

        deviceInfo = origDeviceInfo;

        for (l = deviceInfo->SymbolicLinkNames.Flink;
             l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

            symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);
            if (MOUNTMGR_IS_VOLUME_NAME(&symlinkEntry->SymbolicLinkName)) {
                break;
            }
        }

        if (l != &deviceInfo->SymbolicLinkNames) {
            path.Length = path.MaximumLength =
                    symlinkEntry->SymbolicLinkName.Length;
            path.Buffer = ExAllocatePool(PagedPool, path.MaximumLength);
            if (!path.Buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory(path.Buffer, symlinkEntry->SymbolicLinkName.Buffer,
                          path.Length);
            path.Buffer[1] = '\\';
        }
    }

    output->MultiSzLength = path.Length + 2*sizeof(WCHAR);
    Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                                output->MultiSzLength;
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        ExFreePool(path.Buffer);
        Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS,
                                                 MultiSz);
        return STATUS_BUFFER_OVERFLOW;
    }

    if (path.Length) {
        RtlCopyMemory(output->MultiSz, path.Buffer, path.Length);
    }

    if (path.Buffer) {
        ExFreePool(path.Buffer);
    }

    output->MultiSz[path.Length/sizeof(WCHAR)] = 0;
    output->MultiSz[path.Length/sizeof(WCHAR) + 1] = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
MountmgrWriteNoAutoMount(
    IN  PDEVICE_EXTENSION   Extension
    )

{
    ULONG   NoAutoMount = !Extension->AutoMountPermitted;

    return RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                 Extension->RegistryPath.Buffer,
                                 L"NoAutoMount", REG_DWORD,
                                 &NoAutoMount, sizeof(NoAutoMount));
}

NTSTATUS
ScrubRegistryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Extension,
    IN  PVOID   EntriesDeleted
    )

{
    PDEVICE_EXTENSION           extension = Extension;
    PBOOLEAN                    entriesDeleted = EntriesDeleted;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    NTSTATUS                    status;

    if (ValueType != REG_BINARY) {
        return STATUS_SUCCESS;
    }

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo->UniqueId &&
            deviceInfo->UniqueId->UniqueIdLength == ValueLength &&
            RtlCompareMemory(deviceInfo->UniqueId->UniqueId,
                             ValueData, ValueLength) == ValueLength) {

            return STATUS_SUCCESS;
        }
    }

    status = RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                    MOUNTED_DEVICES_KEY, ValueName);
    if (!NT_SUCCESS(status)) {
        *entriesDeleted = FALSE;
        return status;
    }

    *entriesDeleted = TRUE;

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
MountMgrScrubRegistry(
    IN  PDEVICE_EXTENSION   Extension
    )

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    BOOLEAN                     entriesDeleted;
    NTSTATUS                    status;

    for (;;) {

        RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
        queryTable[0].QueryRoutine = ScrubRegistryRoutine;
        queryTable[0].EntryContext = &entriesDeleted;
        entriesDeleted = FALSE;

        status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                        MOUNTED_DEVICES_KEY, queryTable,
                                        Extension, NULL);
        if (!entriesDeleted) {
            break;
        }
    }

    return status;
}

NTSTATUS
MountMgrQueryAutoMount(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    NTSTATUS                    status = STATUS_SUCCESS;
    PIO_STACK_LOCATION          irpSp  = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_QUERY_AUTO_MOUNT  output = (PMOUNTMGR_QUERY_AUTO_MOUNT) Irp->AssociatedIrp.SystemBuffer;


    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (MOUNTMGR_QUERY_AUTO_MOUNT)) {
        status = STATUS_INVALID_PARAMETER;
    }


    if (NT_SUCCESS (status)) {
        output->CurrentState = (Extension->AutoMountPermitted) ? Enabled : Disabled;
        Irp->IoStatus.Information = sizeof (MOUNTMGR_QUERY_AUTO_MOUNT);
    } else {
        Irp->IoStatus.Information = 0;
    }


    return (status);
}

NTSTATUS
MountMgrSetAutoMount(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    NTSTATUS                    status = STATUS_SUCCESS;
    PIO_STACK_LOCATION          irpSp  = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_SET_AUTO_MOUNT    input  = (PMOUNTMGR_SET_AUTO_MOUNT) Irp->AssociatedIrp.SystemBuffer;


    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(MOUNTMGR_QUERY_AUTO_MOUNT)) {
        status = STATUS_INVALID_PARAMETER;
    }


    if (NT_SUCCESS (status) && ((Enabled == input->NewState) != Extension->AutoMountPermitted)) {
        //
        // Only write to the registry if we are actually changing
        // the state, otherwise just return.
        //
        Extension->AutoMountPermitted = (Enabled == input->NewState);
        status = MountmgrWriteNoAutoMount (Extension);
    }


    Irp->IoStatus.Information = 0;

    return (status);
}

NTSTATUS
MountMgrDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a device io control request.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                        status, status2;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo;

    Irp->IoStatus.Information = 0;

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_MOUNTMGR_CREATE_POINT:
            status = MountMgrCreatePoint(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_QUERY_POINTS_ADMIN:
        case IOCTL_MOUNTMGR_QUERY_POINTS:
            status = MountMgrQueryPoints(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_DELETE_POINTS:
            status = MountMgrDeletePoints(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY:
            status = MountMgrDeletePointsDbOnly(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER:
            status = MountMgrNextDriveLetter(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS:
            extension->AutomaticDriveLetterAssignment = TRUE;
            MountMgrAssignDriveLetters(extension);
            ReconcileAllDatabasesWithMaster(extension);
            status = STATUS_SUCCESS;
            break;

        case IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED:
            KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            status2 = WaitForRemoteDatabaseSemaphore(extension);
            KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);
            status = MountMgrVolumeMountPointCreated(extension, Irp, status2);
            if (NT_SUCCESS(status2)) {
                ReleaseRemoteDatabaseSemaphore(extension);
            }
            break;

        case IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED:
            KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            status2 = WaitForRemoteDatabaseSemaphore(extension);
            KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);
            status = MountMgrVolumeMountPointDeleted(extension, Irp, status2);
            if (NT_SUCCESS(status2)) {
                ReleaseRemoteDatabaseSemaphore(extension);
            }
            break;

        case IOCTL_MOUNTMGR_CHANGE_NOTIFY:
            status = MountMgrChangeNotify(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE:
            status = MountMgrKeepLinksWhenOffline(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES:
            status = MountMgrCheckUnprocessedVolumes(extension, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION:
            KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            status = MountMgrVolumeArrivalNotification(extension, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH:
            status = MountMgrQueryDosVolumePath(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS:
            status = MountMgrQueryDosVolumePaths(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_SCRUB_REGISTRY:
            status = MountMgrScrubRegistry(extension);
            break;

        case IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT:
            status = MountMgrQueryAutoMount(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_SET_AUTO_MOUNT:
            status = MountMgrSetAutoMount(extension, Irp);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

VOID
WorkerThread(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PVOID          Extension
    )

/*++

Routine Description:

    This is a worker thread to process work queue items.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION    extension = Extension;
    OBJECT_ATTRIBUTES    oa;
    KEVENT               event;
    LARGE_INTEGER        timeout;
    ULONG                i;
    NTSTATUS             status;
    HANDLE               volumeSafeEvent;
    KIRQL                irql;
    PLIST_ENTRY          l;
    PRECONCILE_WORK_ITEM queueItem;

    InitializeObjectAttributes(&oa, &VolumeSafeEventName,
                               OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    timeout.QuadPart = -10*1000*1000;   // 1 second

    for (i = 0; i < 1000; i++) {
        if (Unloading) {
            i = 999;
            continue;
        }

        status = ZwOpenEvent(&volumeSafeEvent, EVENT_ALL_ACCESS, &oa);
        if (NT_SUCCESS(status)) {
            break;
        }
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &timeout);
    }

    if (i < 1000) {
        for (;;) {
            status = ZwWaitForSingleObject(volumeSafeEvent, FALSE, &timeout);
            if (status != STATUS_TIMEOUT || Unloading) {
                break;
            }
        }
        ZwClose(volumeSafeEvent);
    }

    for (;;) {

        KeWaitForSingleObject(&extension->WorkerSemaphore,
                              Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&extension->WorkerSpinLock, &irql);
        if (IsListEmpty(&extension->WorkerQueue)) {
            KeReleaseSpinLock(&extension->WorkerSpinLock, irql);
            InterlockedDecrement(&extension->WorkerRefCount);
            KeSetEvent(&UnloadEvent, 0, FALSE);
            break;
        }
        l = RemoveHeadList(&extension->WorkerQueue);
        KeReleaseSpinLock(&extension->WorkerSpinLock, irql);

        queueItem = CONTAINING_RECORD(l, RECONCILE_WORK_ITEM, List);
        queueItem->WorkerRoutine(queueItem->Parameter);
        IoFreeWorkItem(queueItem->WorkItem);
        ExFreePool(queueItem);
        if (InterlockedDecrement(&extension->WorkerRefCount) < 0) {
            break;
        }
    }
}

NTSTATUS
QueueWorkItem(
    IN  PDEVICE_EXTENSION    Extension,
    IN  PRECONCILE_WORK_ITEM WorkItem,
    IN  PVOID                Parameter
    )

/*++

Routine Description:

    This routine queues the given work item to the worker thread and if
    necessary starts the worker thread.

Arguments:

    Extension   - Supplies the device extension.

    WorkItem    - Supplies the work item to be queued.

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    KIRQL               irql;

    WorkItem->Parameter = Parameter;
    if (!InterlockedIncrement(&Extension->WorkerRefCount)) {
        IoQueueWorkItem(WorkItem->WorkItem, WorkerThread, DelayedWorkQueue,
                        Extension);
    }

    KeAcquireSpinLock(&Extension->WorkerSpinLock, &irql);
    InsertTailList(&Extension->WorkerQueue, &WorkItem->List);
    KeReleaseSpinLock(&Extension->WorkerSpinLock, irql);

    KeReleaseSemaphore(&Extension->WorkerSemaphore, 0, 1, FALSE);

    return STATUS_SUCCESS;
}

VOID
MountMgrNotify(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine completes all of the change notify irps in the queue.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    LIST_ENTRY                      q;
    KIRQL                           irql;
    PLIST_ENTRY                     p;
    PIRP                            irp;
    PMOUNTMGR_CHANGE_NOTIFY_INFO    output;

    Extension->EpicNumber++;

    InitializeListHead(&q);
    IoAcquireCancelSpinLock(&irql);
    while (!IsListEmpty(&Extension->ChangeNotifyIrps)) {
        p = RemoveHeadList(&Extension->ChangeNotifyIrps);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        IoSetCancelRoutine(irp, NULL);
        InsertTailList(&q, p);
    }
    IoReleaseCancelSpinLock(irql);

    while (!IsListEmpty(&q)) {
        p = RemoveHeadList(&q);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        output = irp->AssociatedIrp.SystemBuffer;
        output->EpicNumber = Extension->EpicNumber;
        irp->IoStatus.Information = sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

VOID
MountMgrCancel(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called on when the given IRP is cancelled.  It
    will dequeue this IRP off the work queue and complete the
    request as CANCELLED.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IRP.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
MountMgrChangeNotify(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns when the current Epic number is different than
    the one given.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_CHANGE_NOTIFY_INFO    input;
    KIRQL                           irql;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = Irp->AssociatedIrp.SystemBuffer;
    if (input->EpicNumber != Extension->EpicNumber) {
        input->EpicNumber = Extension->EpicNumber;
        Irp->IoStatus.Information = sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO);
        return STATUS_SUCCESS;
    }

    IoAcquireCancelSpinLock(&irql);
    if (Irp->Cancel) {
        IoReleaseCancelSpinLock(irql);
        return STATUS_CANCELLED;
    }

    InsertTailList(&Extension->ChangeNotifyIrps, &Irp->Tail.Overlay.ListEntry);
    IoMarkIrpPending(Irp);
    IoSetCancelRoutine(Irp, MountMgrCancel);
    IoReleaseCancelSpinLock(irql);

    return STATUS_PENDING;
}

NTSTATUS
UniqueIdChangeNotifyCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           WorkItem
    )

/*++

Routine Description:

    Completion routine for a change notify.

Arguments:

    DeviceObject    - Not used.

    Irp             - Supplies the IRP.

    Extension       - Supplies the work item.


Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PCHANGE_NOTIFY_WORK_ITEM    workItem = WorkItem;

    IoQueueWorkItem(workItem->WorkItem, UniqueIdChangeNotifyWorker, DelayedWorkQueue, workItem);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
MountMgrCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine cancels all of the IRPs currently queued on
    the given device.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the cleanup IRP.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PDEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT        file = irpSp->FileObject;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;

    IoAcquireCancelSpinLock(&irql);

    for (;;) {

        for (l = Extension->ChangeNotifyIrps.Flink;
             l != &Extension->ChangeNotifyIrps; l = l->Flink) {

            irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
            if (IoGetCurrentIrpStackLocation(irp)->FileObject == file) {
                break;
            }
        }

        if (l == &Extension->ChangeNotifyIrps) {
            break;
        }

        irp->Cancel = TRUE;
        irp->CancelIrql = irql;
        irp->CancelRoutine = NULL;
        MountMgrCancel(DeviceObject, irp);

        IoAcquireCancelSpinLock(&irql);
    }

    IoReleaseCancelSpinLock(irql);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrShutdown(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

{
    PDEVICE_EXTENSION   extension = DeviceObject->DeviceExtension;

    InterlockedExchange(&Unloading, TRUE);
    KeInitializeEvent(&UnloadEvent, NotificationEvent, FALSE);
    if (InterlockedIncrement(&extension->WorkerRefCount) > 0) {
        KeReleaseSemaphore(&extension->WorkerSemaphore, 0, 1, FALSE);
        KeWaitForSingleObject(&UnloadEvent, Executive, KernelMode, FALSE,
                              NULL);
    } else {
        InterlockedDecrement(&extension->WorkerRefCount);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

ULONG
MountmgrReadNoAutoMount(
    IN  PUNICODE_STRING RegistryPath
    )

{
    ULONG                       zero, r;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"NoAutoMount";
    queryTable[0].EntryContext = &r;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    RegistryPath->Buffer, queryTable, NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {
        r = zero;
    }

    return r;
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the entry point for the driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   extension;

    RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY);

    status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                            &DeviceName, FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    DriverObject->DriverUnload = MountMgrUnload;

    extension = deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(DEVICE_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->DriverObject = DriverObject;
    InitializeListHead(&extension->MountedDeviceList);
    InitializeListHead(&extension->DeadMountedDeviceList);
    KeInitializeSemaphore(&extension->Mutex, 1, 1);
    KeInitializeSemaphore(&extension->RemoteDatabaseSemaphore, 1, 1);
    InitializeListHead(&extension->ChangeNotifyIrps);
    extension->EpicNumber = 1;
    InitializeListHead(&extension->SavedLinksList);
    InitializeListHead(&extension->WorkerQueue);
    KeInitializeSemaphore(&extension->WorkerSemaphore, 0, MAXLONG);
    extension->WorkerRefCount = -1;
    KeInitializeSpinLock(&extension->WorkerSpinLock);
    InitializeListHead(&extension->UniqueIdChangeNotifyList);

    extension->RegistryPath.Length = RegistryPath->Length;
    extension->RegistryPath.MaximumLength = extension->RegistryPath.Length +
                                            sizeof(WCHAR);
    extension->RegistryPath.Buffer = ExAllocatePool(PagedPool,
                                     extension->RegistryPath.MaximumLength);
    if (!extension->RegistryPath.Buffer) {
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory(extension->RegistryPath.Buffer, RegistryPath->Buffer,
                  RegistryPath->Length);
    extension->RegistryPath.Buffer[RegistryPath->Length/sizeof(WCHAR)] = 0;
    extension->AutoMountPermitted = !MountmgrReadNoAutoMount(&extension->RegistryPath);

    GlobalCreateSymbolicLink(&DeviceSymbolicLinkName, &DeviceName);

    status = IoRegisterPlugPlayNotification(
             EventCategoryDeviceInterfaceChange,
             PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
             (PVOID) &MOUNTDEV_MOUNTED_DEVICE_GUID, DriverObject,
             MountMgrMountedDeviceNotification, extension,
             &extension->NotificationEntry);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(deviceObject);
        return status;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = MountMgrCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = MountMgrCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MountMgrDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = MountMgrCleanup;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = MountMgrShutdown;
    gdeviceObject = deviceObject;

    status = IoRegisterShutdownNotification(gdeviceObject);
    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(deviceObject);
        return status;
    }

    return STATUS_SUCCESS;
}

VOID
MountMgrUnload(
    PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Driver unload routine.

Arguments:

    DeviceObject    - Supplies the driver object.

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION           extension;
    UNICODE_STRING              symbolicLinkName;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSAVED_LINKS_INFORMATION    savedLinks;
    PCHANGE_NOTIFY_WORK_ITEM    WorkItem;

    IoUnregisterShutdownNotification(gdeviceObject);

    extension = gdeviceObject->DeviceExtension;

    if (extension->RegistryPath.Buffer) {
        ExFreePool(extension->RegistryPath.Buffer);
        extension->RegistryPath.Buffer = NULL;
    }

    //
    // See if the worker is active
    //
    InterlockedExchange(&Unloading, TRUE);
    KeInitializeEvent (&UnloadEvent, NotificationEvent, FALSE);
    if (InterlockedIncrement(&extension->WorkerRefCount) > 0) {
        KeReleaseSemaphore(&extension->WorkerSemaphore, 0, 1, FALSE);
        KeWaitForSingleObject(&UnloadEvent, Executive, KernelMode, FALSE,
                              NULL);
    } else {
        InterlockedDecrement(&extension->WorkerRefCount);
    }

    IoUnregisterPlugPlayNotification(extension->NotificationEntry);

    KeWaitForSingleObject(&extension->Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    while (!IsListEmpty (&extension->DeadMountedDeviceList)) {

        l = RemoveHeadList (&extension->DeadMountedDeviceList);
        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);

        MountMgrFreeDeadDeviceInfo (deviceInfo);
    }

    while (!IsListEmpty (&extension->MountedDeviceList)) {

        l = RemoveHeadList (&extension->MountedDeviceList);
        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);

        MountMgrFreeMountedDeviceInfo (deviceInfo);
    }

    while (!IsListEmpty (&extension->SavedLinksList)) {

        l = RemoveHeadList (&extension->SavedLinksList);
        savedLinks = CONTAINING_RECORD(l, SAVED_LINKS_INFORMATION, ListEntry);

        MountMgrFreeSavedLink (savedLinks);
    }

    while (!IsListEmpty (&extension->UniqueIdChangeNotifyList)) {
        l = RemoveHeadList (&extension->UniqueIdChangeNotifyList);
        WorkItem = CONTAINING_RECORD(l, CHANGE_NOTIFY_WORK_ITEM, List);
        KeResetEvent (&UnloadEvent);

        InterlockedExchangePointer (&WorkItem->Event, &UnloadEvent);
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        IoCancelIrp (WorkItem->Irp);

        KeWaitForSingleObject (&UnloadEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        IoFreeIrp(WorkItem->Irp);
        ExFreePool(WorkItem->DeviceName.Buffer);
        ExFreePool(WorkItem->SystemBuffer);
        ExFreePool(WorkItem);
        KeWaitForSingleObject(&extension->Mutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    if (extension->SystemPartitionUniqueId) {
        ExFreePool(extension->SystemPartitionUniqueId);
        extension->SystemPartitionUniqueId = NULL;
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);


    GlobalDeleteSymbolicLink(&DeviceSymbolicLinkName);

    IoDeleteDevice (gdeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\mountmgr\kdmm\precomp.h ===
#define KDEXTMODE

#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <windows.h>

#include <ntosp.h>


#include <initguid.h>
#include <ntdddisk.h>
#include <ntddvol.h>
#include <initguid.h>
#include <wdmguid.h>

//#include <winsock2.h>
//#include <imagehlp.h>
//#include <memory.h>


#include <stdio.h>
#include <stdlib.h>
#include <string.h>



#include <mountdev.h>
#include "mountmgr.h"
#include "mntmgr.h"


//
// We're 64 bit aware

#define KDEXT_64BIT


#include <wdbgexts.h>

#define _DRIVER

#define KDBG_EXT

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\mountmgr\kdmm\makefile.inc ===
kdmm.def: kdmm.src
    $(TARGET_CPP) /EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(C_DEFINES) kdmm.src > kdmm.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftbreak\ftbreak.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR               driveName[7];
    HANDLE              h;
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId;

    if (argc != 2) {
        printf("usage: %s <diskId>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);

    printf("Breaking %I64X...\n", diskId);

    b = FtBreakLogicalDisk(diskId);

    if (b) {
        printf("Logical disk broken.\n");
    } else {
        printf("Break failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\filters\null\nls.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    nls.c

Abstract:

    This module contains the code that implements the Synchronous NULL device
    driver.

Author:

    Darryl E. Havens (darrylh) 22-May-1989

Environment:

    Kernel mode

Notes:

    This device driver is built into the NT operating system.

Revision History:


--*/

#include "ntddk.h"
#include "string.h"

//
// Define driver entry routine.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// Define the local routines used by this driver module.
//

static
NTSTATUS
NlsDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

static
NTSTATUS
NlsQueryFileInformation(
    OUT PVOID Buffer,
    IN OUT PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    );

static
BOOLEAN
NlsRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

static
BOOLEAN
NlsWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID 
NlsUnload ( 
    IN PDRIVER_OBJECT DriverObject 
    );
 

//
// Global variables
//
PDEVICE_OBJECT gDeviceObject = NULL;

//
// Fast I/O dispatch block
//
FAST_IO_DISPATCH NlsFastIoDispatch =
{
    sizeof (FAST_IO_DISPATCH), // SizeOfFastIoDispatch
    NULL,                      // FastIoCheckIfPossible
    NlsRead,                   // FastIoRead
    NlsWrite,                  // FastIoWrite
    NULL,                      // FastIoQueryBasicInfo
    NULL,                      // FastIoQueryStandardInfo
    NULL,                      // FastIoLock
    NULL,                      // FastIoUnlockSingle
    NULL,                      // FastIoUnlockAll
    NULL,                      // FastIoUnlockAllByKey
    NULL                       // FastIoDeviceControl
};

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, NlsDispatch)
#pragma alloc_text(PAGE, NlsQueryFileInformation)
#pragma alloc_text(PAGE, NlsRead)
#pragma alloc_text(PAGE, NlsWrite)
#pragma alloc_text(PAGE, NlsUnload)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the synchronous NULL device driver.
    This routine creates the device object for the NullS device and performs
    all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    //
    // Mark the entire driver as pagable.
    //

    MmPageEntireDriver ((PVOID)DriverEntry);

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &nameString, L"\\Device\\Null" );
    status = IoCreateDevice( DriverObject,
                             0,
                             &nameString,
                             FILE_DEVICE_NULL,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &deviceObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    DriverObject->DriverUnload = NlsUnload;

#ifdef _PNP_POWER_
    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

    //
    // Setting the following flag changes the timing of how many I/O's per
    // second can be accomplished by going through the NULL device driver
    // from being simply getting in and out of the driver, to getting in and
    // out with the overhead of building an MDL, probing and locking buffers,
    // unlocking the pages, and deallocating the MDL.  This flag should only
    // be set for performance testing.
    //

//  deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the driver object with this device driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_READ]   = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE]  = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL] = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]  = NlsDispatch;

    //
    // Setup fast IO
    //
    DriverObject->FastIoDispatch = &NlsFastIoDispatch;
    //
    // Save device object for unload
    //
    gDeviceObject = deviceObject;

    return STATUS_SUCCESS;
}

static
NTSTATUS
NlsDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the synchronous NULL device
    driver.  It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID buffer;
    ULONG length;
    PFILE_OBJECT fileObject;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (irpSp->MajorFunction) {

        //
        // For both create/open and close operations, simply set the information
        // field of the I/O status block and complete the request.
        //

        case IRP_MJ_CREATE:
        case IRP_MJ_CLOSE:
            fileObject = irpSp->FileObject;
            if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
                fileObject->PrivateCacheMap = (PVOID) 1;
            }
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;
            break;

        //
        // For read operations, set the information field of the I/O status
        // block, set an end-of-file status, and complete the request.
        //

        case IRP_MJ_READ:
            Irp->IoStatus.Status = STATUS_END_OF_FILE;
            Irp->IoStatus.Information = 0;
            break;

        //
        // For write operations, set the information field of the I/O status
        // block to the number of bytes which were supposed to have been written
        // to the file and complete the request.
        //

        case IRP_MJ_WRITE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = irpSp->Parameters.Write.Length;
            break;

        case IRP_MJ_LOCK_CONTROL:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_QUERY_INFORMATION:
            buffer = Irp->AssociatedIrp.SystemBuffer;
            length = irpSp->Parameters.QueryFile.Length;
            Irp->IoStatus.Status = NlsQueryFileInformation( buffer,
                                                            &length,
                                                            irpSp->Parameters.QueryFile.FileInformationClass );
            Irp->IoStatus.Information = length;
            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );
    return status;
}

static
NTSTATUS
NlsQueryFileInformation(
    OUT PVOID Buffer,
    IN PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine queries information about the opened file and returns the
    information in the specified buffer provided that the buffer is large
    enough and the specified type of information about the file is supported
    by this device driver.

    Information about files supported by this driver are:

        o   FileStandardInformation

Arguments:

    Buffer - Supplies a pointer to the buffer in which to return the
        information.

    Length - Supplies the length of the buffer on input and the length of
        the data actually written on output.

    InformationClass - Supplies the information class that is being queried.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    PFILE_STANDARD_INFORMATION standardBuffer;

    PAGED_CODE();

    //
    // Switch on the type of information that the caller would like to query
    // about the file.
    //

    switch (InformationClass) {

        case FileStandardInformation:

            //
            // Return the standard information about the file.
            //

            standardBuffer = (PFILE_STANDARD_INFORMATION) Buffer;
            *Length = (ULONG) sizeof( FILE_STANDARD_INFORMATION );
            standardBuffer->NumberOfLinks = 1;
            standardBuffer->DeletePending = FALSE;
            standardBuffer->AllocationSize.LowPart = 0;
            standardBuffer->AllocationSize.HighPart = 0;
            standardBuffer->Directory = FALSE;
            standardBuffer->EndOfFile.LowPart = 0;
            standardBuffer->EndOfFile.HighPart = 0;
            break;

        default:

            //
            // An invalid (or unsupported) information class has been queried
            // for the file.  Return the appropriate status.
            //

            return STATUS_INVALID_INFO_CLASS;

    }

    return STATUS_SUCCESS;
}

static
BOOLEAN
NlsRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is the Fast I/O Read routine for the NULL device driver.  It simply
    indicates that the read path was successfully taken, but that the end of
    the file has been reached.

Arguments:

    FileObject - File object representing the open instance to this device.

    FileOffset - Offset from which to begin the read.

    Length - Length of the read to be performed.

    Wait - Indicates whether or not the caller can wait.

    LockKey - Specifies the key for any lock contention that may be encountered.

    Buffer - Address of the buffer in which to return the data read.

    IoStatus - Supplies the I/O status block into which the final status is to
        be returned.

Return Value:

    The function value is TRUE, meaning that the fast I/O path was taken.

--*/

{
    PAGED_CODE();

    //
    // Simply indicate that the read operation worked, but the end of the file
    // was encountered.
    //

    IoStatus->Status = STATUS_END_OF_FILE;
    IoStatus->Information = 0;
    return TRUE;
}

static
BOOLEAN
NlsWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is the Fast I/O Write routine for the NULL device driver.  It simply
    indicates that the write path was successfully taken, and that all of the
    data was written to the device.

Arguments:

    FileObject - File object representing the open instance to this device.

    FileOffset - Offset from which to begin the read.

    Length - Length of the write to be performed.

    Wait - Indicates whether or not the caller can wait.

    LockKey - Specifies the key for any lock contention that may be encountered.

    Buffer - Address of the buffer containing the data to be written.

    IoStatus - Supplies the I/O status block into which the final status is to
        be returned.

Return Value:

    The function value is TRUE, meaning that the fast I/O path was taken.

--*/

{
    PAGED_CODE();

    //
    // Simply return TRUE, indicating that the fast I/O path was taken, and
    // that the write operation worked.
    //

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = Length;
    return TRUE;
}

VOID 
NlsUnload ( 
    IN PDRIVER_OBJECT DriverObject 
    )
{
    UNICODE_STRING us;

    RtlInitUnicodeString (&us, L"\\??\\NUL"); // Created by SMSS
    IoDeleteSymbolicLink (&us);

    IoDeleteDevice (gDeviceObject);
    gDeviceObject = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftinit\ftinit.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId;

    if (argc < 2) {
        printf("usage: %s <diskId> [init-orphans]\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);
    printf("Initializing %I64X...\n", diskId);

    b = FtInitializeLogicalDisk(diskId, argc > 2 ? TRUE : FALSE);

    if (b) {
        printf("Initialize started.\n");
    } else {
        printf("Initialize failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftlink\ftlink.c ===
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    UCHAR               driveLetter;
    FT_LOGICAL_DISK_ID  diskId;
    BOOL                b;

    if (argc != 3 || argv[1][1] != ':') {
        printf("usage: %s <drive:> <DiskId>\n", argv[0]);
        return;
    }

    driveLetter = (UCHAR)toupper(argv[1][0]);
    sscanf(argv[2], "%I64X", &diskId);

    printf("Creating a symbolic link from %c: to %I64X\n", driveLetter, diskId);

    b = FtSetStickyDriveLetter(diskId, driveLetter);

    if (b) {
        printf("Symbolic link created.\n");
    } else {
        printf("Symbolic link create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftmirror\ftmirror.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_MIRROR_SET_CONFIGURATION_INFORMATION config;
    int                                     i;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      diskId[2], newDiskId;
    LONGLONG                                memberSize, zeroMemberSize;

    if (argc != 3) {
        printf("usage: %s <diskId1> <diskId2>\n", argv[0]);
        return;
    }

    config.MemberSize = MAXLONGLONG;

    printf("Creating a mirror set for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);

        b = FtQueryLogicalDiskInformation(diskId[i - 1], NULL, &memberSize,
                                          0, NULL, NULL, 0, NULL, 0, NULL);
        if (!b) {
            printf("Could not query disk info, error = %d\n", GetLastError());
            return;
        }

        if (memberSize < config.MemberSize) {
            config.MemberSize = memberSize;
        }

        if (i == 1) {
            zeroMemberSize = memberSize;
        }
    }
    printf(" ...\n");

    if (memberSize < zeroMemberSize) {
        printf("First member too big.\n");
        return;
    }

    b = FtCreateLogicalDisk(FtMirrorSet, 2, diskId, sizeof(config), &config,
                            &newDiskId);

    if (b) {
        printf("Mirror %I64X created.\n", newDiskId);
    } else {
        printf("Mirror create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftonline\ftonline.c ===
#include <windows.h>
#include <stdio.h>
#include <winioctl.h>
#include <ntddvol.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR   driveName[7];
    HANDLE  h;
    BOOL    b;
    DWORD   bytes;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = argv[1][0];
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFileW(driveName, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, INVALID_HANDLE_VALUE);

    if (h == INVALID_HANDLE_VALUE) {
        printf("Open of drive %c: failed with %d\n", argv[1][0], GetLastError());
        return;
    }

    b = DeviceIoControl(h, IOCTL_VOLUME_ONLINE, NULL, 0, NULL, 0, &bytes,
                        NULL);
    if (b) {
        printf("Online succeeded.\n");
    } else {
        printf("Online failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftextend\ftextend.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    TCHAR                   dosDriveName[10];
    HANDLE                  h;
    BOOL                    b;
    PARTITION_INFORMATION   partInfo;
    DWORD                   bytes;
    DISK_GEOMETRY           geometry;
    LONGLONG                newSectors;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    if (argv[1][1] != ':' || argv[1][2] != 0) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    wsprintf(dosDriveName, TEXT("\\\\.\\%c:"), argv[1][0]);

    h = CreateFile(dosDriveName, GENERIC_READ,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        printf("Can't open, failed with %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                        &partInfo, sizeof(partInfo), &bytes, NULL);
    if (!b) {
        printf("Can't read partition info, failed with %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
                        &geometry, sizeof(geometry), &bytes, NULL);
    if (!b) {
        printf("Can't read geometry info, failed with %d\n", GetLastError());
        return;
    }

    newSectors = partInfo.PartitionLength.QuadPart/geometry.BytesPerSector;

    b = DeviceIoControl(h, FSCTL_EXTEND_VOLUME, &newSectors, sizeof(newSectors),
                        NULL, 0, &bytes, NULL);

    if (b) {
        printf("File system extended successfully.\n");
    } else {
        printf("File system extension failed.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftpart\ftpart.c ===
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                                   driveName[7];
    HANDLE                                  h;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      newDiskId;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = argv[1][0];
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFileW(driveName, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, INVALID_HANDLE_VALUE);

    if (h == INVALID_HANDLE_VALUE) {
        printf("Open of drive %c: failed with %d\n", argv[1][0], GetLastError());
        return;
    }

    b = FtCreatePartitionLogicalDisk(h, &newDiskId);
    CloseHandle(h);

    if (b) {
        printf("Partition created with logical disk id %I64X\n", newDiskId);
    } else {
        printf("Partition create failed with %d\n", GetLastError());
    }

    FtSetStickyDriveLetter(newDiskId, (UCHAR) toupper(argv[1][0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftorphan\ftorphan.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_LOGICAL_DISK_ID  diskId;
    int                 memberNumber;
    BOOL                b;

    if (argc != 3) {
        printf("usage: %s <diskId> <memberNumber>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);
    sscanf(argv[2], "%d", &memberNumber);

    printf("Orphaning member %d on %I64X...\n", memberNumber, diskId);

    b = FtOrphanLogicalDiskMember(diskId, (WORD) memberNumber);

    if (b) {
        printf("Member orphaned.\n");
    } else {
        printf("Orphaning failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftredist\ftredist.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_LOGICAL_DISK_ID                          diskId[2], newDiskId;
    ULONG                                       weight1, weight2;
    FT_REDISTRIBUTION_CONFIGURATION_INFORMATION configInfo;
    BOOL                                        b;
    LONGLONG                                    volsize1, volsize2, newSize, rowSize, numRows, tmp;
    INT                                         d;
    CHAR                                        c;

    if (argc != 5) {
        printf("usage: %s <diskId1> <diskId2> <width1> <width2>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId[0]);
    sscanf(argv[2], "%I64X", &diskId[1]);
    sscanf(argv[3], "%d", &weight1);
    sscanf(argv[4], "%d", &weight2);

    if (weight1 >= 0x10000 || weight2 >= 0x10000) {
        printf("Weight too large.\n");
        return;
    }

    printf("Redistributing data on disk %I64X with disk %I64X\n",
           diskId[0], diskId[1]);
    printf("Weightings are %d for first disk and %d for second disk.\n",
           weight1, weight2);

    configInfo.StripeSize = 0x10000;
    configInfo.FirstMemberWidth = (USHORT) weight1;
    configInfo.SecondMemberWidth = (USHORT) weight2;

    b = FtQueryLogicalDiskInformation(diskId[0], NULL, &volsize1,
                                      0, NULL, NULL, 0, NULL, 0, NULL);
    if (!b) {
        printf("Invalid disk id.\n");
        return;
    }
    b = FtQueryLogicalDiskInformation(diskId[1], NULL, &volsize2,
                                      0, NULL, NULL, 0, NULL, 0, NULL);
    if (!b) {
        printf("Invalid disk id.\n");
        return;
    }

    printf("Total disk size before redistribution = %I64d\n", volsize1);

    rowSize = configInfo.StripeSize*(configInfo.FirstMemberWidth +
                                     configInfo.SecondMemberWidth);

    numRows = volsize1/(configInfo.StripeSize*configInfo.FirstMemberWidth);
    tmp = volsize2/(configInfo.StripeSize*configInfo.SecondMemberWidth);
    if (tmp < numRows) {
        numRows = tmp;
    }

    newSize = numRows*rowSize;

    printf("Total disk size after redistribution = %I64d\n", newSize);
    printf("Disk space wasted by redistribution = %I64d\n",
           volsize1 + volsize2 - newSize);

    if (newSize < volsize1) {
        printf("New size less than existing size.\n");
        return;
    }

    printf("\nPress <CTRL-C> to cancel operation...");

    c = getchar();

    printf("\nCreating redistribution...\n");

    b = FtCreateLogicalDisk(FtRedistribution, 2, diskId,
                            sizeof(configInfo), &configInfo, &newDiskId);

    if (b) {
        printf("Redistribution %I64X created.\n", newDiskId);
    } else {
        printf("Redistribution create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftstate\ftstate.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void
PrintOutDiskInfo(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  WORD                Indent
    )

{
    BOOL                                            b;
    LONGLONG                                        volumeSize;
    FT_LOGICAL_DISK_TYPE                            diskType;
    FT_LOGICAL_DISK_ID                              members[100];
    WORD                                            numMembers;
    PCHAR                                           diskTypeString;
    WORD                                            i;
    CHAR                                            stateInfo[100];
    CHAR                                            configInfo[100];
    PFT_MIRROR_AND_SWP_STATE_INFORMATION            stripeState;
    PFT_PARTITION_CONFIGURATION_INFORMATION         partConfig;
    PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION    redistConfig;
    PFT_REDISTRIBUTION_STATE_INFORMATION            redistState;

    if (!LogicalDiskId) {
        for (i = 0; i < Indent; i++) {
            printf(" ");
        }
        printf("Disk not found.\n\n");
        return;
    }

    b = FtQueryLogicalDiskInformation(LogicalDiskId, &diskType, &volumeSize,
                                      100, members, &numMembers, 100,
                                      configInfo, 100, stateInfo);
    if (!b) {
        printf("Failure retrieving disk info, %d\n", GetLastError());
        return;
    }

    for (i = 0; i < Indent; i++) {
        printf(" ");
    }

    switch (diskType) {

        case FtPartition:
            diskTypeString = "FtPartition";
            partConfig = (PFT_PARTITION_CONFIGURATION_INFORMATION)
                         configInfo;
            printf("Disk %I64X is an %s on disk %d at offset %I64X\n",
                   LogicalDiskId, diskTypeString, partConfig->DiskNumber,
                   partConfig->ByteOffset);
            break;

        case FtVolumeSet:
            diskTypeString = "FtVolumeSet";
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            break;

        case FtStripeSet:
            diskTypeString = "FtStripeSet";
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            break;

        case FtMirrorSet:
            diskTypeString = "FtMirrorSet";
            stripeState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) stateInfo;
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            for (i = 0; i < Indent; i++) {
                printf(" ");
            }
            switch (stripeState->UnhealthyMemberState) {
                case FtMemberHealthy:
                    printf("Mirror set is healthy.\n");
                    break;

                case FtMemberRegenerating:
                    printf("Mirror set is regenerating member %d\n",
                           stripeState->UnhealthyMemberNumber);
                    break;

                case FtMemberOrphaned:
                    printf("Mirror set has orphaned member %d\n",
                           stripeState->UnhealthyMemberNumber);
                    break;

            }
            break;

        case FtStripeSetWithParity:
            diskTypeString = "FtStripeSetWithParity";
            stripeState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) stateInfo;
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            for (i = 0; i < Indent; i++) {
                printf(" ");
            }
            if (stripeState->IsInitializing) {
                printf("Stripe set with parity is initializing parity.\n");
            } else {
                switch (stripeState->UnhealthyMemberState) {
                    case FtMemberHealthy:
                        printf("Stripe set with parity is healthy.\n");
                        break;

                    case FtMemberRegenerating:
                        printf("Stripe set with parity is regenerating member %d\n",
                               stripeState->UnhealthyMemberNumber);
                        break;

                    case FtMemberOrphaned:
                        printf("Stripe set with parity has orphaned member %d\n",
                               stripeState->UnhealthyMemberNumber);
                        break;

                }
            }
            break;

        case FtRedistribution:
            diskTypeString = "FtRedistribution";
            redistConfig = (PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION) configInfo;
            redistState = (PFT_REDISTRIBUTION_STATE_INFORMATION) stateInfo;
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            for (i = 0; i < Indent; i++) {
                printf(" ");
            }
            printf("Widths = (%d, %d), Bytes redistributed = %I64d\n",
                   redistConfig->FirstMemberWidth,
                   redistConfig->SecondMemberWidth,
                   redistState->BytesRedistributed);
            break;

    }

    for (i = 0; i < Indent; i++) {
        printf(" ");
    }

    printf("Disk size = %I64d\n\n", volumeSize);

    for (i = 0; i < numMembers; i++) {
        PrintOutDiskInfo(members[i], (WORD) (Indent + 4));
    }
}

void __cdecl
main(
    int argc,
    char** argv
    )

{
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId[100];
    DWORD               numDisks, i;
    UCHAR               driveLetter;
    WORD                l;

    b = FtEnumerateLogicalDisks(100, diskId, &numDisks);
    if (!b) {
        printf("Could not enumerate disks %d\n", GetLastError());
        return;
    }

    for (i = 0; i < numDisks; i++) {
        b = FtQueryStickyDriveLetter(diskId[i], &driveLetter);
        if (b && driveLetter) {
            printf("%c:\n", driveLetter);
        }
        PrintOutDiskInfo(diskId[i], 0);
        printf("\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftswp\ftswp.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION config;
    int                                                 i;
    BOOL                                                b;
    FT_LOGICAL_DISK_ID                                  diskId[100], newDiskId;
    LONGLONG                                            memberSize;

    if (argc < 4) {
        printf("usage: %s <diskId1> <diskId2> <diskId3>...\n", argv[0]);
        return;
    }

    config.MemberSize = MAXLONGLONG;

    printf("Creating a stripe set with parity for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);

        b = FtQueryLogicalDiskInformation(diskId[i - 1], NULL, &memberSize,
                                          0, NULL, NULL, 0, NULL, 0, NULL);
        if (!b) {
            printf("Could not query disk info, error = %d\n", GetLastError());
            return;
        }

        if (memberSize < config.MemberSize) {
            config.MemberSize = memberSize;
        }
    }
    printf(" ...\n");

    config.StripeSize = 0x10000;

    b = FtCreateLogicalDisk(FtStripeSetWithParity, (WORD) (argc - 1), diskId,
                            sizeof(config), &config, &newDiskId);

    if (b) {
        printf("Stripe set with parity %I64X created.\n", newDiskId);
    } else {
        printf("Stripe set with parity create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftregen\ftregen.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId, newMemberDiskId, newDiskId;
    int                 memberNumber;

    if (argc != 4) {
        printf("usage: %s <diskId> <memberNumber> <newMemberId>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);
    sscanf(argv[2], "%d", &memberNumber);
    sscanf(argv[3], "%I64X", &newMemberDiskId);

    printf("Regenerating member %d of %I64X with %I64X...\n",
           memberNumber, diskId, newMemberDiskId);

    b = FtReplaceLogicalDiskMember(diskId, (WORD) memberNumber,
                                   newMemberDiskId, &newDiskId);

    if (b) {
        printf("Regenerate started on disk %I64X\n", newDiskId);
    } else {
        printf("Regenerate failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftstripe\ftstripe.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    int                                     i;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      diskId[100], newDiskId;
    FT_STRIPE_SET_CONFIGURATION_INFORMATION configInfo;

    if (argc < 3) {
        printf("usage: %s <diskId1> <diskId2> ...\n", argv[0]);
        return;
    }

    printf("Creating a stripe for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);
    }
    printf(" ...\n");

    configInfo.StripeSize = 0x10000;

    b = FtCreateLogicalDisk(FtStripeSet, (WORD) (argc - 1), diskId,
                            sizeof(configInfo), &configInfo, &newDiskId);

    if (b) {
        printf("Stripe %I64X created.\n", newDiskId);
    } else {
        printf("Stripe create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftszchk\ftszchk.c ===
/*++

Copyright (C) 2001 Microsoft Corporation

Module Name:

    ftszchk.c

Abstract:

    This utility checks the disks on a Windows NT 4.0 system looking for those
    that cannot be converted to dynamic after upgrading the system to Windows
    2000. The main reason why a disk cannot be converted to dynamic is the lack
    of 1MB free space at the end of the disk.

Author:

    Cristian G. Teodorescu (cristiat) 29-Jan-2002
    
Environment:

    User mode.
  
Notes:

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <winioctl.h>
#include <ntddvol.h>

#define PRIVATE_REGION_SIZE 0x100000    // 1MB

#define SECTOR  0x200

#define MESSAGE "The ftszchk.exe utility wrote this sector" 

void
PrintUsage(
    IN char*    ProgramName
    )
{
    printf("usage: %s [disk_number]\n", ProgramName);
}


BOOLEAN
AccessSector(
    IN  HANDLE      Handle,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine tries to access the given disk sector.

Arguments:

    Handle  - Supplies the disk handle.

    Offset  - Supplies the offset of the sector.

Return Value:

    TRUE if the sector is accessible.

--*/

{
    LARGE_INTEGER   pointer;
    DWORD           err;
    CHAR            saveBuffer[SECTOR];
    CHAR            buffer[SECTOR];
    BOOL            b;
    DWORD           bytes;
    
    //
    // Save the old content of the sector.
    //
    
    pointer.QuadPart = Offset;
    pointer.LowPart = SetFilePointer(Handle, pointer.LowPart, 
                                     &pointer.HighPart, FILE_BEGIN);
    err = GetLastError();
    if (pointer.LowPart == INVALID_SET_FILE_POINTER && err != NO_ERROR) {
        return FALSE;
    }
    
    memset(saveBuffer, 0, SECTOR);
    b = ReadFile(Handle, saveBuffer, SECTOR, &bytes, NULL);
    if (!b || bytes != SECTOR) {
        return FALSE;
    }

    //
    // Write the sector.
    //
    
    pointer.QuadPart = Offset;
    pointer.LowPart = SetFilePointer(Handle, pointer.LowPart, 
                                     &pointer.HighPart, FILE_BEGIN);
    err = GetLastError();
    if (pointer.LowPart == INVALID_SET_FILE_POINTER && err != NO_ERROR) {
        return FALSE;
    }

    memset(buffer, 0, SECTOR);
    sprintf(buffer, MESSAGE);
    b = WriteFile(Handle, buffer, SECTOR, &bytes, NULL);
    if (!b || bytes != SECTOR) {
        return FALSE;
    }

    //
    // Read the sector and compare the result with what we've wrriten.
    //
    
    pointer.QuadPart = Offset;
    pointer.LowPart = SetFilePointer(Handle, pointer.LowPart, 
                                     &pointer.HighPart, FILE_BEGIN);
    err = GetLastError();
    if (pointer.LowPart == INVALID_SET_FILE_POINTER && err != NO_ERROR) {
        return FALSE;
    }

    memset(buffer, 0, SECTOR);
    b = ReadFile(Handle, buffer, SECTOR, &bytes, NULL);
    if (!b || bytes != SECTOR) {
        return FALSE;
    }

    if (memcmp(buffer, MESSAGE, strlen(MESSAGE))) {
        return FALSE;
    }

    //
    // Try to restore the old content of the sector.
    //

    pointer.QuadPart = Offset;
    pointer.LowPart = SetFilePointer(Handle, pointer.LowPart, 
                                     &pointer.HighPart, FILE_BEGIN);
    err = GetLastError();
    if (pointer.LowPart == INVALID_SET_FILE_POINTER && err != NO_ERROR) {
        return TRUE;
    }

    WriteFile(Handle, saveBuffer, SECTOR, &bytes, NULL);
    return TRUE;
}


BOOLEAN
ProcessDisk(
    IN  ULONG       DiskNumber,
    OUT PBOOLEAN    ContainsFT
    )

/*++

Routine Description:

    This routine checks whether the given disk can be converted to dynamic or
    not.

Arguments:

    DiskNumber  - Supplies the disk NT device number.

    ContainsFT  - Returns TRUE if the disk contains FT partitions.

Return Value:

    FALSE if opening the disk failed with ERROR_FILE_NOT_FOUND. TRUE otherwise.

--*/

{
    WCHAR                       diskDevice[64];
    HANDLE                      h;
    DISK_GEOMETRY               geometry;
    ULONG                       layoutSize;
    PDRIVE_LAYOUT_INFORMATION   layout;
    PPARTITION_INFORMATION      partition;
    ULONG                       i;
    BOOL                        b;
    DWORD                       bytes;
    DWORD                       err;
    UCHAR                       type;
    BOOLEAN                     ft = FALSE, dynamic = FALSE;
    LONGLONG                    lastEnd, end, privateEnd, geoSize, ioOffset;
    
    *ContainsFT = FALSE;
    
    //
    // Get a handle to the disk
    //
    
    swprintf(diskDevice, L"\\\\.\\PHYSICALDRIVE%lu", DiskNumber);
    
    h = CreateFileW(diskDevice, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, 
                    NULL, OPEN_EXISTING, 0, NULL);
    if (h == INVALID_HANDLE_VALUE) {
        err = GetLastError();
        if (err == ERROR_FILE_NOT_FOUND) {
            return FALSE;
        }

        printf("Disk%3lu: The disk was inaccessible due to error %lu.\n", 
               DiskNumber, err);
        return TRUE;
    }

    printf("Disk%3lu: ", DiskNumber);
    
    //
    // Get the drive geometry
    //

    b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry,
                        sizeof(geometry), &bytes, NULL);
    if (!b) {
        printf("The disk geometry was inaccessible due to error %lu.\n", 
               GetLastError());
        CloseHandle(h);
        return TRUE;
    }

    //
    // Get the drive layout
    //
    
    layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry) +
                 128 * sizeof(PARTITION_INFORMATION);
    layout = (PDRIVE_LAYOUT_INFORMATION) LocalAlloc(LMEM_ZEROINIT, layoutSize);
    if (!layout) {
        printf("The disk was inaccessible due to memory allocation error.\n");
        CloseHandle(h);
        return TRUE;
    }
    
    while (TRUE) {        
        b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, layout, 
                            layoutSize, &bytes, NULL);
        if (b) {
            break;
        }

        err = GetLastError();
        LocalFree(layout);

        if (err != ERROR_INSUFFICIENT_BUFFER) {
            printf("The disk partition table was inaccessible due to error %lu.\n", 
                    err);
            CloseHandle(h);
            return TRUE;
        }

        layoutSize += 64 * sizeof(PARTITION_INFORMATION);
        layout = (PDRIVE_LAYOUT_INFORMATION) LocalAlloc(LMEM_ZEROINIT, 
                                                        layoutSize);
        if (!layout) {
            printf("The disk was inaccessible due to memory allocation error.\n");
            CloseHandle(h);
            return TRUE;
        }
    }
    
    //
    // Scan the partition table. Look for FT partitions or dynamic partitions.
    // Find the last partititon end offset.
    //

    lastEnd = 0;
    
    for (i = 0; i < layout->PartitionCount; i++) {
        partition = &layout->PartitionEntry[i];
        type = partition->PartitionType;

        if (type == 0 || IsContainerPartition(type)) {
            continue;
        }

        if (type == PARTITION_LDM) {
            dynamic = TRUE;
        }

        if (IsFTPartition(type)) {
            ft = TRUE;
        }

        end = partition->StartingOffset.QuadPart + 
              partition->PartitionLength.QuadPart;
        if (end > lastEnd) {
            lastEnd = end;
        }
    }    
    
    LocalFree(layout);

    if (ft) {
        printf("NT 4.0 basic volumes present. ");
    } 

    *ContainsFT = ft;

    //
    // Dell ships LDM on Windows NT 4.0. Make sure we don't touch dynamic disks.
    //
    
    if (dynamic) {
        printf("The disk is a dynamic disk.\n");
        CloseHandle(h);
        return TRUE;
    }

    //
    // Only disks with 512 bytes/sector can be converted to dynamic
    //

    if (geometry.BytesPerSector != SECTOR) {
        printf("The disk does not have a 512 sector size and cannot be converted to a dynamic disk.\n");
        CloseHandle(h);
        return TRUE;
    }
        
    //
    // Check whether there is enough space left at the end of the disk to 
    // convert it to dynamic. 
    //
    // Given there is no way to get the real size of the disk in Windows NT 4.0
    // we use the following algorithm:
    //
    // 1. Get the geometric size.
    // 2. Add one MB (the size of the LDM private region) to the last 
    //    partition end offset.
    // 3. If the result is within the geometric size STOP. The disk is large
    //    enough to be converted.
    // 4. Try to access the sector that ends at the offset calculated at step 2.
    //    If the access succeeds STOP. The disk is large enough to be converted.
    // 5. Try to access some more sectors at higher offsets. If one of them
    //    succeeds STOP. The disk is large enough to be converted.
    // 6. If all attempts failed the disk is probably not large enough to be 
    //    converted.
    //

    geoSize = geometry.Cylinders.QuadPart * geometry.TracksPerCylinder * 
              geometry.SectorsPerTrack * geometry.BytesPerSector;
    privateEnd = lastEnd + PRIVATE_REGION_SIZE;

    if (privateEnd > geoSize) {
        ioOffset = privateEnd - SECTOR;
        for (i = 0; i < 4; i++) {
            if (AccessSector(h, ioOffset)) {
                break;
            }
            ioOffset += 0x1000;
        }
        if (i == 4) {
            printf("The disk does not have enough free space to be converted to a dynamic disk.\n");
            CloseHandle(h);
            return TRUE;
        } 
    }
    
    printf("The disk may be converted to a dynamic disk.\n");
    CloseHandle(h);
    return TRUE;
}


void __cdecl
main(
    int argc,
    char** argv
    )
{
    ULONG   diskNumber;
    BOOLEAN found;
    BOOLEAN ft, ftall = FALSE;
    UINT    i;
    
    if (argc > 2) {
        PrintUsage(argv[0]);
        return;
    }

    if (argc == 2) {
        if (sscanf(argv[1], "%lu", &diskNumber) != 1) {
            PrintUsage(argv[0]);
            return;
        }

        found = ProcessDisk(diskNumber, &ftall);
        if (!found) {
            printf("Disk%3lu: The system cannot find the disk specified.\n", 
                   diskNumber);
        }

        return;
    }

    //
    // Scan all disks starting with disk 0. Stop the search after 20 
    // consecutive FILE_NOT_FOUND failures to open the disks.
    //
    
    for (diskNumber = 0, i = 0; i < 20; diskNumber++) {
        found = ProcessDisk(diskNumber, &ft);
        if (!found) {
            i++;            
        } else {
            i = 0;
            if (ft) {
                ftall = TRUE;
            }
        }
    }

    if (ftall) {
        printf("\nIMPORTANT: The utility detected NT 4.0 basic volumes in your system. These volumes might include volume sets, stripe sets, mirror sets and stripe sets with parity. Make sure these volumes are in healthy status before upgrading the operating system to Windows 2000.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\ftvolset\ftvolset.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    int                                     i;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      diskId[100], newDiskId;

    if (argc < 3) {
        printf("usage: %s <diskId1> <diskId2> ...\n", argv[0]);
        return;
    }

    printf("Creating a volume set for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);
    }
    printf(" ...\n");

    b = FtCreateLogicalDisk(FtVolumeSet, (WORD) (argc - 1), diskId,
                            0, NULL, &newDiskId);

    if (b) {
        printf("Volume set %I64X created.\n", newDiskId);
    } else {
        printf("Volume set create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\lib\ftapi.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ftapi.c

Abstract:

    This implements the FT API services.

Author:

    Norbert Kusters      16-May-1995

Notes:

Revision History:

--*/

#include <windows.h>
#include <winioctl.h>
#include <ntddft2.h>
#include <ftapi.h>

BOOL
FtCreatePartitionLogicalDisk(
    IN  HANDLE              PartitionHandle,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

/*++

Routine Description:

    This routine creates a new logical disk from a single partition.

Arguments:

    PartitionHandle     - Supplies a handle to the partition.

    NewLogicalDiskId    - Returns the new logical disk id.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    BOOL                                    b;
    FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT output;
    DWORD                                   bytes;

    b = DeviceIoControl(PartitionHandle, FT_CREATE_PARTITION_LOGICAL_DISK,
                        NULL, 0, &output, sizeof(output),
                        &bytes, NULL);

    *NewLogicalDiskId = output.NewLogicalDiskId;

    return b;
}

BOOL
FtCreateLogicalDisk(
    IN  FT_LOGICAL_DISK_TYPE    LogicalDiskType,
    IN  WORD                    NumberOfMembers,
    IN  PFT_LOGICAL_DISK_ID     RootLogicalDiskIds,
    IN  WORD                    ConfigurationInformationSize,
    IN  PVOID                   ConfigurationInformation,
    OUT PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    )

/*++

Routine Description:

    This routine creates a new logical disk.

Arguments:

    LogicalDiskType                 - Supplies the logical disk type.

    NumberOfMembers                 - Supplies the number of members.

    RootLogicalDiskIds              - Supplies the array of members.

    ConfigurationInformationSize    - Supplies the number of bytes in the
                                        configuration information.

    ConfigurationInformation        - Supplies the configuration information.

    NewLogicalDiskId                - Returns the new logical disk id.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                          h;
    DWORD                           inputBufferSize;
    PFT_CREATE_LOGICAL_DISK_INPUT   input;
    FT_CREATE_LOGICAL_DISK_OUTPUT   output;
    WORD                            i;
    BOOL                            b;
    DWORD                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    inputBufferSize = FIELD_OFFSET(FT_CREATE_LOGICAL_DISK_INPUT, MemberArray) +
                      NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                      ConfigurationInformationSize;
    input = (PFT_CREATE_LOGICAL_DISK_INPUT) LocalAlloc(0, inputBufferSize);
    if (!input) {
        CloseHandle(h);
        return FALSE;
    }

    input->LogicalDiskType = LogicalDiskType;
    input->NumberOfMembers = NumberOfMembers;
    input->ConfigurationInformationSize = ConfigurationInformationSize;
    for (i = 0; i < NumberOfMembers; i++) {
        input->MemberArray[i] = RootLogicalDiskIds[i];
    }
    CopyMemory(&input->MemberArray[i], ConfigurationInformation,
               ConfigurationInformationSize);

    b = DeviceIoControl(h, FT_CREATE_LOGICAL_DISK, input,
                        inputBufferSize, &output, sizeof(output),
                        &bytes, NULL);

    *NewLogicalDiskId = output.NewLogicalDiskId;

    LocalFree(input);

    CloseHandle(h);

    return b;
}

BOOL
FtInitializeLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    IN  BOOL                RegenerateOrphans
    )

/*++

Routine Description:

    This routine initializes the given root logical disk.

Arguments:

    RootLogicalDiskId   - Supplies the root logical disk id to initialize.

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphans.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                              h;
    FT_INITIALIZE_LOGICAL_DISK_INPUT    input;
    BOOL                                b;
    DWORD                               bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;
    input.RegenerateOrphans = (RegenerateOrphans != FALSE);

    b = DeviceIoControl(h, FT_INITIALIZE_LOGICAL_DISK, &input, sizeof(input),
                        NULL, 0, &bytes, NULL);

    CloseHandle(h);

    return b;
}

BOOL
FtBreakLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId
    )

/*++

Routine Description:

    This routine breaks a given logical disk into its constituents.

Arguments:

    RootLogicalDiskId   - Supplies the root logical disk id to break.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                          h;
    FT_BREAK_LOGICAL_DISK_INPUT     input;
    BOOL                            b;
    DWORD                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;

    b = DeviceIoControl(h, FT_BREAK_LOGICAL_DISK, &input, sizeof(input), NULL,
                        0, &bytes, NULL);

    CloseHandle(h);

    return b;
}

BOOL
FtEnumerateLogicalDisks(
    IN  DWORD               ArraySize,
    OUT PFT_LOGICAL_DISK_ID RootLogicalDiskIds,         /* OPTIONAL */
    OUT PDWORD              NumberOfRootLogicalDiskIds
    )

/*++

Routine Description:

    This routine enumerates all of the root logical disk ids in the system.
    If the 'RootLogicalDiskIds' is not present then this routine just returns
    the number of root logical disk ids in 'NumberOfRootLogicalDiskIds'.

Arguments:

    ArraySize                   - Supplies the number of root logical disk ids that
                                    the given array can hold.

    RootLogicalDiskIds          - Returns an array of root logical disk ids.

    NumberOfRootLogicalDiskIds  - Returns the number of root logical disk ids.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                              h;
    DWORD                               outputSize;
    PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT  poutput;
    BOOL                                b;
    DWORD                               bytes;
    DWORD                               i;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    outputSize = sizeof(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT);
    if (RootLogicalDiskIds) {
        outputSize += ArraySize*sizeof(FT_LOGICAL_DISK_ID);
    }

    poutput = LocalAlloc(0, outputSize);
    if (!poutput) {
        CloseHandle(h);
        return FALSE;
    }

    b = DeviceIoControl(h, FT_ENUMERATE_LOGICAL_DISKS, NULL, 0, poutput,
                        outputSize, &bytes, NULL);
    CloseHandle(h);

    *NumberOfRootLogicalDiskIds = poutput->NumberOfRootLogicalDisks;

    if (!b) {
        if (GetLastError() == ERROR_MORE_DATA && !RootLogicalDiskIds) {
            return TRUE;
        }
        LocalFree(poutput);
        return b;
    }

    if (RootLogicalDiskIds &&
        *NumberOfRootLogicalDiskIds <= ArraySize) {

        for (i = 0; i < *NumberOfRootLogicalDiskIds; i++) {
            RootLogicalDiskIds[i] = poutput->RootLogicalDiskIds[i];
        }
    }

    LocalFree(poutput);

    return b;
}

BOOL
FtQueryLogicalDiskInformation(
    IN  FT_LOGICAL_DISK_ID      LogicalDiskId,
    OUT PFT_LOGICAL_DISK_TYPE   LogicalDiskType,                /* OPTIONAL */
    OUT PLONGLONG               VolumeSize,                     /* OPTIONAL */
    IN  WORD                    MembersArraySize,
    OUT PFT_LOGICAL_DISK_ID     Members,                        /* OPTIONAL */
    OUT PWORD                   NumberOfMembers,                /* OPTIONAL */
    IN  WORD                    ConfigurationInformationSize,
    OUT PVOID                   ConfigurationInformation,       /* OPTIONAL */
    IN  WORD                    StateInformationSize,
    OUT PVOID                   StateInformation                /* OPTIONAL */
    )

/*++

Routine Description:

    This routine returns information for the given logical disk.

Arguments:

    LogicalDiskId                   - Supplies the logical disk id.

    LogicalDiskType                 - Returns the logical disk type.

    VolumeSize                      - Returns the size of the volume.

    MembersArraySize                - Supplies the size of the members array.

    Members                         - Returns the members of the logical disk.

    NumberOfMembers                 - Returns the number of members for this
                                        logical disk.

    ConfigurationInformationSize    - Supplies the configuration information
                                        size.

    ConfigurationInformation        - Returns the configuration information.

    StateInformationSize            - Supplies the state information size.

    StateInformation                - Returns the state information.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                      h;
    FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT     input;
    DWORD                                       outputSize;
    PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT   output;
    BOOL                                        b;
    DWORD                                       bytes;
    DWORD                                       i;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;
    outputSize = sizeof(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT);
    output = LocalAlloc(0, outputSize);
    if (!output) {
        CloseHandle(h);
        return FALSE;
    }

    b = DeviceIoControl(h, FT_QUERY_LOGICAL_DISK_INFORMATION, &input,
                        sizeof(input), output, outputSize, &bytes, NULL);
    if (!b && GetLastError() != ERROR_MORE_DATA) {
        LocalFree(output);
        CloseHandle(h);
        return FALSE;
    }

    outputSize = FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                              MemberArray) +
                 output->NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                 output->ConfigurationInformationSize +
                 output->StateInformationSize;
    LocalFree(output);
    output = LocalAlloc(0, outputSize);
    if (!output) {
        CloseHandle(h);
        return FALSE;
    }

    b = DeviceIoControl(h, FT_QUERY_LOGICAL_DISK_INFORMATION, &input,
                        sizeof(input), output, outputSize, &bytes, NULL);
    CloseHandle(h);
    if (!b) {
        return FALSE;
    }

    if (LogicalDiskType) {
        *LogicalDiskType = output->LogicalDiskType;
    }

    if (VolumeSize) {
        *VolumeSize = output->VolumeSize;
    }

    if (Members) {
        if (output->NumberOfMembers > MembersArraySize) {
            LocalFree(output);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }

        for (i = 0; i < output->NumberOfMembers; i++) {
            Members[i] = output->MemberArray[i];
        }
    }

    if (NumberOfMembers) {
        *NumberOfMembers = output->NumberOfMembers;
    }

    if (ConfigurationInformation) {
        if (ConfigurationInformationSize <
            output->ConfigurationInformationSize) {

            LocalFree(output);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }

        CopyMemory(ConfigurationInformation,
                   &output->MemberArray[output->NumberOfMembers],
                   output->ConfigurationInformationSize);
    }

    if (StateInformation) {
        if (StateInformationSize < output->StateInformationSize) {
            LocalFree(output);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }

        CopyMemory(StateInformation,
                   (PCHAR) &output->MemberArray[output->NumberOfMembers] +
                   output->ConfigurationInformationSize,
                   output->StateInformationSize);
    }

    LocalFree(output);
    return TRUE;
}

BOOL
FtOrphanLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  WORD                MemberNumberToOrphan
    )

/*++

Routine Description:

    This routine orphans a member of a logical disk.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    MemberNumberToOrphan    - Supplies the member number to orphan.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                              h;
    FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT input;
    BOOL                                b;
    DWORD                               bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;
    input.MemberNumberToOrphan = MemberNumberToOrphan;

    b = DeviceIoControl(h, FT_ORPHAN_LOGICAL_DISK_MEMBER, &input,
                        sizeof(input), NULL, 0, &bytes, NULL);
    CloseHandle(h);

    return b;
}

BOOL
FtReplaceLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  WORD                MemberNumberToReplace,
    IN  FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId            /* OPTIONAL */
    )

/*++

Routine Description:

    This routine replaces a member of a logical disk.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    MemberNumberToReplace   - Supplies the member number to replace.

    NewMemberLogicalDiskId  - Supplies the new member.

    NewLogicalDiskId        - Returns the new logical disk id for the disk set
                                that contains the replaced member.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                  h;
    FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT    input;
    FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT   output;
    BOOL                                    b;
    DWORD                                   bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;
    input.MemberNumberToReplace = MemberNumberToReplace;
    input.NewMemberLogicalDiskId = NewMemberLogicalDiskId;

    b = DeviceIoControl(h, FT_REPLACE_LOGICAL_DISK_MEMBER, &input,
                        sizeof(input), &output, sizeof(output), &bytes, NULL);
    CloseHandle(h);

    if (NewLogicalDiskId) {
        *NewLogicalDiskId = output.NewLogicalDiskId;
    }

    return b;
}

BOOL
FtQueryLogicalDiskId(
    IN  HANDLE              RootLogicalDiskHandle,
    OUT PFT_LOGICAL_DISK_ID RootLogicalDiskId
    )

/*++

Routine Description:

    This routine returns the root logical disk id for a given disk.

Arguments:

    RootLogicalDiskHandle   - Supplies a handle to a logical disk.

    RootLogicalDiskId       - Returns a logical disk id for the given logical
                                disk.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    BOOL                            b;
    FT_QUERY_LOGICAL_DISK_ID_OUTPUT output;
    DWORD                           bytes;

    b = DeviceIoControl(RootLogicalDiskHandle, FT_QUERY_LOGICAL_DISK_ID,
                        NULL, 0, &output, sizeof(output), &bytes, NULL);

    *RootLogicalDiskId = output.RootLogicalDiskId;

    return b;
}

BOOL
FtQueryStickyDriveLetter(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    OUT PUCHAR              DriveLetter
    )

/*++

Routine Description:

    This routine queries the sticky drive letter for the given disk id.

Arguments:

    RootLogicalDiskId   - Supplies the logical disk id.

    DriveLetter         - Returns the sticky drive letter.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                          h;
    FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT    input;
    FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT   output;
    BOOL                                            b;
    DWORD                                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;

    b = DeviceIoControl(h, FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK, &input,
                        sizeof(input), &output, sizeof(output), &bytes, NULL);
    CloseHandle(h);

    *DriveLetter = output.DriveLetter;

    return b;
}

BOOL
FtSetStickyDriveLetter(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    IN  UCHAR               DriveLetter
    )

/*++

Routine Description:

    This routine sets the sticky drive letter for the given disk id.

Arguments:

    RootLogicalDiskId   - Supplies the logical disk id.

    DriveLetter         - Supplies the sticky drive letter.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                      h;
    FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT  input;
    BOOL                                        b;
    DWORD                                       bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;
    input.DriveLetter = DriveLetter;

    b = DeviceIoControl(h, FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK, &input,
                        sizeof(input), NULL, 0, &bytes, NULL);
    CloseHandle(h);

    return b;
}

BOOL
FtChangeNotify(
    )

/*++

Routine Description:

    This routine returns when a change to the FT configuration occurrs.

Arguments:

    None.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                      h;
    BOOL                                        b;
    DWORD                                       bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = DeviceIoControl(h, FT_CHANGE_NOTIFY, NULL, 0, NULL, 0, &bytes, NULL);
    CloseHandle(h);

    return b;
}

BOOL
FtStopSyncOperations(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId
    )

/*++

Routine Description:

    This routine stops all sync operations on the logical disk.

Arguments:

    RootLogicalDiskId   - Supplies the root logical disk id.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                          h;
    FT_STOP_SYNC_OPERATIONS_INPUT   input;
    BOOL                            b;
    DWORD                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;

    b = DeviceIoControl(h, FT_STOP_SYNC_OPERATIONS, &input, sizeof(input),
                        NULL, 0, &bytes, NULL);

    CloseHandle(h);

    return b;
}

BOOL
FtCheckIo(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PBOOL               IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not enough members of the given logical
    disk are online so that IO is possible on all parts of the volume.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    IsIoOk          - Returns whether or not IO is possible on the entire
                        logical disk.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE              h;
    FT_CHECK_IO_INPUT   input;
    FT_CHECK_IO_OUTPUT  output;
    BOOL                b;
    DWORD               bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;

    b = DeviceIoControl(h, FT_CHECK_IO, &input, sizeof(input), &output,
                        sizeof(output), &bytes, NULL);
    CloseHandle(h);

    *IsIoOk = output.IsIoOk;

    return b;
}

BOOL
FtCheckDriver(
    OUT PBOOL   IsDriverLoaded
    )

/*++

Routine Description:

    This routine returns whether or not the FTDISK driver is loaded.

Arguments:

    IsDriverLoaded  - Returns whether or not the driver is loaded.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE  h;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            *IsDriverLoaded = FALSE;
            return TRUE;
        }
        return FALSE;
    }

    CloseHandle(h);

    *IsDriverLoaded = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\lib\ftapint.c ===
#include <nt.h>
#include <ntrtl.h>
#include <ntddft2.h>
#include <ftapi.h>


HANDLE
FtOpenPartition(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine opens the given logical disk.

Arguments:

    Signature   - Supplies the disk signature.

    Offset      - Supplies the partition offset.

Return Value:

    INVALID_HANDLE_VALUE    - Failure.

    Otherwise               - A handle to the given disk.

--*/

{
    UNICODE_STRING                                  string;
    OBJECT_ATTRIBUTES                               oa;
    NTSTATUS                                        status;
    HANDLE                                          handle;
    IO_STATUS_BLOCK                                 ioStatus;
    FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT     input;
    ULONG                                           outputSize;
    FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT    output[200];

    RtlInitUnicodeString(&string, L"\\Device\\FtControl");
    InitializeObjectAttributes(&oa, &string, OBJ_CASE_INSENSITIVE, 0, 0);
    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        return (HANDLE) -1;
    }

    input.Signature = Signature;
    input.Offset = Offset;
    outputSize = 200*sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT);
    status = NtDeviceIoControlFile(handle, 0, NULL, NULL, &ioStatus,
                                   FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION,
                                   &input, sizeof(input), output, outputSize);
    NtClose(handle);
    if (!NT_SUCCESS(status)) {
        return (HANDLE) -1;
    }

    string.MaximumLength = string.Length =
            output[0].NumberOfCharactersInNtDeviceName*sizeof(WCHAR);
    string.Buffer = output[0].NtDeviceName;

    InitializeObjectAttributes(&oa, &string, OBJ_CASE_INSENSITIVE, 0, 0);
    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        return (HANDLE) -1;
    }

    return handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ftapi\lib\parttype.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    parttype.c

Abstract:

    This module contains a routine used to determine the correct
    partition type to use for a partition.

Author:

    Ted Miller (tedm) 5 Feb 1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <parttype.h>

NTSTATUS
GeneratePartitionType(
    IN  LPCWSTR NtDevicePath,               OPTIONAL
    IN  HANDLE DeviceHandle,                OPTIONAL
    IN  ULONGLONG StartSector,
    IN  ULONGLONG SectorCount,
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  ULONG Reserved,
    OUT PUCHAR Type
    )

/*++

Routine Description:

    This routine determines the proper partition type to be used for a new
    partition.

Arguments:

    NtDevicePath - supplies the NT-style path of the disk device where the
        partition is to be created, such as \Device\Harddisk1\Partition0.
        If not specified, DeviceHandle must be.

    DeviceHandle - Supplies a handle to the disk device where the partition
        will be. The caller should have opened the drive for at least
        FILE_READ_DATA and FILE_READ_ATTRIBUTES access. Ignored if
        NtDevicePath is specified.

    StartOffset - supplies the 0-based start sector for the partition.

    SectorCount - supplies the number of sectors to be in the partition.

    PartitionClass - supplies a value indicating the intended use of the
        partition.

        GenPartitionClassExtended - indicates that the partition will be
            a "container" partition using the standard extended partition
            architecture. The returned type will be PARTITION_EXTENDED (5)
            or PARTITION_XINT13_EXTENDED (f), depending on placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionClassFat12Or16 - indicates that the partition will be
            used for a 12 or 16 bit FAT volume. The returned type will be
            PARTITION_FAT_12 (1), PARTITION_FAT_16 (4), PARTITION_HUGE (6),
            or PARTITION_XINT13 (e), depending on size and placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionClassFat32 - indicates that the partition will be used
            for a FAT32 volume. The returned type will be PARTITION_FAT32 (b)
            or PARTITION_FAT32_XINT13 (c), depending on placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionNonFat - indicates that the partition will be used for
            a non-FAT volume. The returned type will be PARTITION_IFS (7).
            It is advisable to call this routine even for type 7 partitions
            since in the future additional partition types could be returned
            in this case.

    Flags - Supplies flags that further control operation of this routine.

        GENPARTTYPE_DISALLOW_XINT13 - disallow extended int13 partition types.
            If this flag is set, PARTITION_FAT32_XINT13 (c),
            PARTITION_XINT13 (e), and PARTITION_XINT13_EXTENDED (f) will not
            be returned as the partition type to be used. Not valid with
            GENPARTTYPE_FORCE_XINT13.

        GENPARTTYPE_FORCE_XINT13 - forces use of extended int13 partition types
            even if not necessary for the partition being created. Not valid
            with GENPARTTYPE_DISALLOW_XINT13.

    Reserved - reserved, must be 0.

    Type - if this routine succeeds, this value receives the partition type
        to be used for the partition.

Return Value:

    NT Status code indicating outcome. If NO_ERROR, Type is filled in with
    the resulting partition type to be used.

--*/

{
    NTSTATUS Status;
    DISK_GEOMETRY Geometry;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Validate parameters.
    //
    if((Flags & GENPARTTYPE_DISALLOW_XINT13) && (Flags & GENPARTTYPE_FORCE_XINT13)) {
        return(STATUS_INVALID_PARAMETER_5);
    }

    if(PartitionClass >= GenPartitionClassMax) {
        return(STATUS_INVALID_PARAMETER_4);
    }

    if(Reserved) {
        return(STATUS_INVALID_PARAMETER_6);
    }

    if(!SectorCount) {
        return(STATUS_INVALID_PARAMETER_3);
    }

    //
    // Open the device if the caller specified a device path.
    // Otherwise just use the handle the caller passed in.
    //
    if(NtDevicePath) {
        Status = pOpenDevice(NtDevicePath,&DeviceHandle);
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    //
    // Get drive geometry for the device.
    //
    Status = NtDeviceIoControlFile(
                DeviceHandle,
                NULL,NULL,NULL,     // synchronous io
                &IoStatusBlock,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,0,             // no input buffer
                &Geometry,
                sizeof(DISK_GEOMETRY)
                );

    if(NtDevicePath) {
        NtClose(DeviceHandle);
    }

    if(NT_SUCCESS(Status)) {
        //
        // Call the worker routine to do the work.
        //
        Status = GeneratePartitionTypeWorker(
                    StartSector,
                    SectorCount,
                    PartitionClass,
                    Flags,
                    &Geometry,
                    Type
                    );
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\devdesc\devdesc.h ===
#ifndef __DEVDESC_H__
#define __DEVDESC_H__

typedef struct {
    INTERFACE_TYPE     InterfaceType;
    ULONG              InterfaceNumber;
    CONFIGURATION_TYPE ControllerType;
    ULONG              ControllerNumber;
    CONFIGURATION_TYPE PeripheralType;
    ULONG              PeripheralNumber;
} HWDESC_INFO, *PHWDESC_INFO;


NTSTATUS
LinkDeviceToDescription(
    IN PUNICODE_STRING     RegistryPath,
    IN PUNICODE_STRING     DeviceName,
    IN INTERFACE_TYPE      BusType,
    IN ULONG               BusNumber,
    IN CONFIGURATION_TYPE  ControllerType,
    IN ULONG               ControllerNumber,
    IN CONFIGURATION_TYPE  PeripheralType,
    IN ULONG               PeripheralNumber
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\inc\volmgr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    volmgr.h

Abstract:

    This file defines the services supplied by the volume managers.

Author:

    norbertk

Revision History:

--*/

#ifndef _VOLMGR_
#define _VOLMGR_

#include <volmgrx.h>

#define IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED             CTL_CODE(VOLMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED             CTL_CODE(VOLMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED            CTL_CODE(VOLMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES   CTL_CODE(VOLMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_ARRIVED      CTL_CODE(VOLMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_REMOVED      CTL_CODE(VOLMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION        CTL_CODE(VOLMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION       CTL_CODE(VOLMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED             CTL_CODE(VOLMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT       CTL_CODE(VOLMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE               CTL_CODE(VOLMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Input structure for IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED,
// IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED,
// IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES,
// IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION,
// IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION, and
// IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED.
//

typedef struct _VOLMGR_PARTITION_INFORMATION {
    PDEVICE_OBJECT  PartitionDeviceObject;
    PDEVICE_OBJECT  WholeDiskPdo;
} VOLMGR_PARTITION_INFORMATION, *PVOLMGR_PARTITION_INFORMATION;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED.
//

typedef struct _VOLMGR_WHOLE_DISK_INFORMATION {
    PDEVICE_OBJECT  WholeDiskPdo;
} VOLMGR_WHOLE_DISK_INFORMATION, *PVOLMGR_WHOLE_DISK_INFORMATION;

//
// Output structure for IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES.
//

typedef struct _VOLMGR_DEPENDANT_VOLUMES_INFORMATION {
    PDEVICE_RELATIONS   DependantVolumeReferences;
} VOLMGR_DEPENDANT_VOLUMES_INFORMATION, *PVOLMGR_DEPENDANT_VOLUMES_INFORMATION;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_ARRIVED and
// IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_REMOVED.
//

typedef struct _VOLMGR_LEGACY_PARTITION_INFORMATION {
    PDEVICE_OBJECT  LegacyWholeDiskDeviceObject;
    ULONG           DiskNumber;
    ULONG           PartitionNumber;
} VOLMGR_LEGACY_PARTITION_INFORMATION, *PVOLMGR_LEGACY_PARTITION_INFORMATION;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT
//

typedef
NTSTATUS
(*PPMWMICOUNTERENABLE) (
    IN OUT PVOID* CounterContext
    );

typedef
BOOLEAN
(*PPMWMICOUNTERDISABLE) (
    IN PVOID* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    );

typedef
VOID
(*PPMWMICOUNTERIOSTART) (
    IN PVOID CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    );

typedef
VOID
(*PPMWMICOUNTERIOCOMPLETE) (
    IN PVOID CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    );

typedef
VOID
(*PPMWMICOUNTERQUERY) (
    IN PVOID CounterContext,
    IN OUT PDISK_PERFORMANCE CounterBuffer,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    );

typedef struct _PMWMICOUNTERLIB_CONTEXT {
    PPMWMICOUNTERENABLE     PmWmiCounterEnable;
    PPMWMICOUNTERDISABLE    PmWmiCounterDisable;
    PPMWMICOUNTERIOSTART    PmWmiCounterIoStart;
    PPMWMICOUNTERIOCOMPLETE PmWmiCounterIoComplete;
    PPMWMICOUNTERQUERY      PmWmiCounterQuery;
} PMWMICOUNTERLIB_CONTEXT, *PPMWMICOUNTERLIB_CONTEXT;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE
//

typedef struct _VOLMGR_POWER_STATE {
    PDEVICE_OBJECT      PartitionDeviceObject;
    PDEVICE_OBJECT      WholeDiskPdo;
    DEVICE_POWER_STATE  PowerState;
} VOLMGR_POWER_STATE, *PVOLMGR_POWER_STATE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\devdesc\devdesc.c ===
#include <ntddk.h>

#include "devdesc.h"

#ifdef PNP_IDENTIFY

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,LinkDeviceToDescription)
#endif

NTSTATUS
LinkDeviceToDescription(
    IN PUNICODE_STRING     RegistryPath,
    IN PUNICODE_STRING     DeviceName,
    IN INTERFACE_TYPE      BusType,
    IN ULONG               BusNumber,
    IN CONFIGURATION_TYPE  ControllerType,
    IN ULONG               ControllerNumber,
    IN CONFIGURATION_TYPE  PeripheralType,
    IN ULONG               PeripheralNumber
    )
{
    //
    // This routine will create a volatile "Description" key under the
    // drivers service key. It will store values of the following form
    // in that key:
    //
    // \\Device\\PointerPortX:REG_BINARY:...
    // \\Device\\KeyboardPortX:REG_BINARY:...
    //
    // Where the binary data is six ULONG values (passed as parameters
    // to this routine) that describe the physical location of the device.
    //

    NTSTATUS            Status = STATUS_SUCCESS;
    HANDLE              ServiceKey = NULL, DescriptionKey = NULL;
    UNICODE_STRING      RegString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    ULONG               disposition;
    HWDESC_INFO         HwDescInfo;

    HwDescInfo.InterfaceType    = BusType;
    HwDescInfo.InterfaceNumber  = BusNumber;
    HwDescInfo.ControllerType   = ControllerType;
    HwDescInfo.ControllerNumber = ControllerNumber;
    HwDescInfo.PeripheralType   = PeripheralType;
    HwDescInfo.PeripheralNumber = PeripheralNumber;


    //
    // Open the service subkey
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&ServiceKey,
                       KEY_WRITE,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // Create a volatile Description subkey under the service subkey
    //
    RtlInitUnicodeString(&RegString, L"Description");

    InitializeObjectAttributes(&ObjectAttributes,
                               &RegString,
                               OBJ_CASE_INSENSITIVE,
                               ServiceKey,
                               NULL);

    Status = ZwCreateKey(&DescriptionKey,
                         KEY_ALL_ACCESS,
                         &ObjectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         REG_OPTION_VOLATILE,
                         &disposition);

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // The description data is stored under a REG_BINARY value (name
    // is the DeviceName passed in as a parameter)
    //
    Status = ZwSetValueKey(DescriptionKey,
                           DeviceName,
                           0,
                           REG_BINARY,
                           &HwDescInfo,
                           sizeof(HwDescInfo));


    Clean0:

    if (DescriptionKey) {
        ZwClose(DescriptionKey);
    }

    if (ServiceKey) {
        ZwClose(ServiceKey);
    }

    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\inc\volmgrx.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    volmgrx.h

Abstract:

    This file defines the public services supplied by the volume managers.

Author:

    norbertk

Revision History:

--*/

#ifndef _VOLMGRX_
#define _VOLMGRX_

#define VOLMGRCONTROLTYPE   ((ULONG) 'v')

#define IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES   CTL_CODE(VOLMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Output structure for IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES
//

typedef struct _VOLMGR_HIDDEN_VOLUMES {
    ULONG   MultiSzLength;
    WCHAR   MultiSz[1];
} VOLMGR_HIDDEN_VOLUMES, *PVOLMGR_HIDDEN_VOLUMES;

//
// Volume managers should report this GUID in IoRegisterDeviceInterface.
//

DEFINE_GUID(VOLMGR_VOLUME_MANAGER_GUID, 0x53f5630e, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\inc\portlib.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    portlib.h

Abstract:

    Contains all structure and routine definitions for storage port driver
    library.

Author:

    John Strange (JohnStra)

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef _PASSTHRU_H_
#define _PASSTHRU_H_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

typedef struct _PORT_PASSTHROUGH_INFO {
    PDEVICE_OBJECT       Pdo;
    PSCSI_PASS_THROUGH   SrbControl;
    PIRP                 RequestIrp;
    PVOID                Buffer;
    PVOID                SrbBuffer;
    ULONG                BufferOffset;
    ULONG                Length;
#if defined (_WIN64)
    PSCSI_PASS_THROUGH32 SrbControl32;
    SCSI_PASS_THROUGH    SrbControl64;
#endif
    UCHAR                MajorCode;
} PORT_PASSTHROUGH_INFO, *PPORT_PASSTHROUGH_INFO;


typedef struct _PORT_ADAPTER_REGISTRY_VALUES {
    ULONG MaxLuCount;
    ULONG EnableDebugging;
    ULONG SrbFlags;
    PHYSICAL_ADDRESS MinimumCommonBufferBase;
    PHYSICAL_ADDRESS MaximumCommonBufferBase;
    ULONG NumberOfRequests;
    ULONG InquiryTimeout;
    ULONG ResetHoldTime;
    ULONG UncachedExtAlignment;
    BOOLEAN CreateInitiatorLU;
    BOOLEAN DisableTaggedQueueing;
    BOOLEAN DisableMultipleLu;
    ULONG AdapterNumber;
    ULONG BusNumber;
    PVOID Parameter;
    PACCESS_RANGE AccessRanges;
    UNICODE_STRING RegistryPath;
    PORT_CONFIGURATION_INFORMATION PortConfig;
}PORT_ADAPTER_REGISTRY_VALUES, *PPORT_ADAPTER_REGISTRY_VALUES;


//
// registry parameters
//


#define MAXIMUM_LOGICAL_UNIT                0x00001
#define INITIATOR_TARGET_ID                 0x00002
#define SCSI_DEBUG                          0x00004
#define BREAK_POINT_ON_ENTRY                0x00008
#define DISABLE_SYNCHRONOUS_TRANSFERS       0x00010
#define DISABLE_DISCONNECTS                 0x00020
#define DISABLE_TAGGED_QUEUING              0x00040
#define DISABLE_MULTIPLE_REQUESTS           0x00080
#define MAXIMUM_UCX_ADDRESS                 0x00100
#define MINIMUM_UCX_ADDRESS                 0x00200
#define DRIVER_PARAMETERS                   0x00400
#define MAXIMUM_SG_LIST                     0x00800
#define NUMBER_OF_REQUESTS                  0x01000
#define RESOURCE_LIST                       0x02000
#define CONFIGURATION_DATA                  0x04000
#define UNCACHED_EXT_ALIGNMENT              0x08000
#define INQUIRY_TIMEOUT                     0x10000
#define RESET_HOLD_TIME                     0x20000
#define CREATE_INITIATOR_LU                 0x40000


//
// Uninitialized flag value.
//

#define PORT_UNINITIALIZED_VALUE ((ULONG) ~0)


//
// Define PORT maximum configuration parameters.
//

#define PORT_MAXIMUM_LOGICAL_UNITS 8
#define PORT_MINIMUM_PHYSICAL_BREAKS  16
#define PORT_MAXIMUM_PHYSICAL_BREAKS 255
#define MAX_UNCACHED_EXT_ALIGNMENT 16
#define MIN_UNCACHED_EXT_ALIGNMENT 3
#define MAX_TIMEOUT_VALUE 60
#define MAX_RESET_HOLD_TIME 60


//
// Define the mimimum and maximum number of srb extensions which will be allocated.
//

#define MINIMUM_EXTENSIONS        16
#define MAXIMUM_EXTENSIONS       255


//
// This routine verifies that the supplied IRP contains a valid
// SCSI_PASS_THROUGH structure and returns a pointer to a SCSI_PASS_THROUGH
// structure witch the caller may use.  If necessary, the routine will marshal
// the contents of the structure from 32-bit to 64-bit format.  If the caller
// makes any changes to the contents of the SCSI_PASS_THROUGH structure, it
// must call PortPassThroughCleanup in case the structure needs to be marshaled
// back to its original format.
//
NTSTATUS
PortGetPassThrough(
    IN OUT PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PIRP Irp,
    IN BOOLEAN Direct
    );

//
// This routine should be called after processing a passthrough request.  The
// routine will perform any necessary cleanup and it will ensure that any
// changes made to the SCSI_PASS_THROUGH structure are marshaled back to the
// original format if necessary.
//
VOID
PortPassThroughCleanup(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo
    );

//
// This routine performs validation checks on the input and output buffers
// supplied by the caller and performs all the required initialization
// in preperation for proper handling of a SCSI passthrough request.
//
NTSTATUS
PortPassThroughInitialize(
    IN OUT PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PIRP Irp,
    IN PIO_SCSI_CAPABILITIES Capabilities,
    IN PDEVICE_OBJECT Pdo,
    IN BOOLEAN Direct
    );

//
// This routine initialize a caller-supplied SRB for dispatching.
//
NTSTATUS
PortPassThroughInitializeSrb(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIRP Irp,
    IN ULONG SrbFlags,
    IN PVOID SenseBuffer
    );

//
// This routine offers a turn-key passthrough solution.  The caller must
// have called PortGetPassThrough to initialize a pointer to the
// SCSI_PASS_THROUGH structure and obtained a pointer to the PDO to which
// the passthrough request is to be dispatched.  This routine does the rest.
//
NTSTATUS
PortSendPassThrough(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp,
    IN BOOLEAN Direct,
    IN ULONG SrbFlags,
    IN PIO_SCSI_CAPABILITIES Capabilities
    );

//
// This routine will safely set the SCSI address in the SCSI_PASS_THROUGH
// structure of the supplied IRP.
//
NTSTATUS
PortSetPassThroughAddress(
    IN PIRP Irp,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

VOID
PortPassThroughMarshalResults(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIRP RequestIrp,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN BOOLEAN Direct
    );

NTSTATUS
PortGetMPIODeviceList(
    IN PUNICODE_STRING RegistryPath,
    OUT PUNICODE_STRING MPIODeviceList
    );

BOOLEAN
PortIsDeviceMPIOSupported(
    IN PUNICODE_STRING DeviceList,
    IN PUCHAR VendorId,
    IN PUCHAR ProductId
    );

NTSTATUS
PortGetPassThroughAddress(
    IN  PIRP Irp,
    OUT PUCHAR PathId,
    OUT PUCHAR TargetId,
    OUT PUCHAR Lun
    );

//
// Bugcheck Callback support structures and routines.
//

typedef struct _KBUGCHECK_DATA {
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParameter1;
    ULONG_PTR BugCheckParameter2;
    ULONG_PTR BugCheckParameter3;
    ULONG_PTR BugCheckParameter4;
} KBUGCHECK_DATA, *PKBUGCHECK_DATA;

typedef
(*PPORT_BUGCHECK_CALLBACK_ROUTINE)(
    IN PKBUGCHECK_DATA BugcheckData,
    IN PVOID BugcheckBuffer,
    IN ULONG BugcheckBufferSize,
    IN PULONG BugcheckBufferUsed
    );

typedef const GUID* PCGUID;


//
// Registry access support routines.
//

NTSTATUS
PortRegisterBugcheckCallback(
    IN PCGUID BugcheckDataGuid,
    IN PPORT_BUGCHECK_CALLBACK_ROUTINE BugcheckRoutine
    );

NTSTATUS
PortDeregisterBugcheckCallback(
    IN PCGUID BugcheckDataGuid
    );
    

HANDLE
PortOpenDeviceKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber
    );

VOID
PortGetDriverParameters(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    OUT PVOID * DriverParameters
    );

VOID
PortGetLinkTimeoutValue(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    OUT PULONG LinkTimeoutValue
    );

VOID
PortGetDiskTimeoutValue(
    OUT PULONG DiskTimeout
    );
    
VOID
PortFreeDriverParameters(
    IN PVOID DriverParameters
    );

VOID
PortGetRegistrySettings(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    IN PPORT_ADAPTER_REGISTRY_VALUES Context,
    IN ULONG Fields
    );


//
// This structure describes the information needed by the registry routine library
// to handle the memory allocations and frees for the miniport.
//
typedef struct _PORT_REGISTRY_INFO {

    //
    // Size, in bytes, of the structure.
    // 
    ULONG Size;

    //
    // Not used currently, but if multiple buffers are allowed, link them here.
    // 
    LIST_ENTRY ListEntry;

    //
    // G.P. SpinLock
    // 
    KSPIN_LOCK SpinLock;

    //
    // The miniport's registry buffer.
    // 
    PUCHAR Buffer;

    //
    // The allocated length of the buffer.
    //
    ULONG AllocatedLength;

    //
    // The size currently being used.
    //
    ULONG CurrentLength;

    //
    // Used to pass around what the buffer should be for the current
    // operation.
    //
    ULONG LengthNeeded;

    //
    // Offset into the Buffer that should be used for the 
    // current operation.
    //
    ULONG Offset;

    //
    // Various state bits. See below for defines.
    //
    ULONG Flags;

    //
    // Used to pass status back and forth between
    // the portlib calling routine and the registry
    // callback.
    //
    NTSTATUS InternalStatus;

} PORT_REGISTRY_INFO, *PPORT_REGISTRY_INFO;


NTSTATUS
PortMiniportRegistryInitialize(
    IN OUT PPORT_REGISTRY_INFO PortContext
    );

VOID
PortMiniportRegistryDestroy(
    IN PPORT_REGISTRY_INFO PortContext
    );

NTSTATUS
PortAllocateRegistryBuffer(
    IN PPORT_REGISTRY_INFO PortContext
    );

NTSTATUS
PortFreeRegistryBuffer(
    IN PPORT_REGISTRY_INFO PortContext
    );

NTSTATUS
PortBuildRegKeyName(
    IN PUNICODE_STRING RegistryPath,
    IN OUT PUNICODE_STRING KeyName,
    IN ULONG PortNumber, 
    IN ULONG Global
    );

NTSTATUS
PortAsciiToUnicode(
    IN PUCHAR AsciiString,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
PortRegistryRead(
    IN PUNICODE_STRING RegistryKeyName,
    IN PUNICODE_STRING ValueName,
    IN ULONG Type,
    IN PPORT_REGISTRY_INFO PortContext
    );

NTSTATUS
PortRegistryWrite(
    IN PUNICODE_STRING RegistryKeyName,
    IN PUNICODE_STRING ValueName,
    IN ULONG Type,
    IN PPORT_REGISTRY_INFO PortContext
    );

VOID
PortReadRegistrySettings(
    IN HANDLE Key,
    IN PPORT_ADAPTER_REGISTRY_VALUES Context,
    IN ULONG Fields
    );
    
NTSTATUS
PortCreateKeyEx(
    IN HANDLE Key,
    IN ULONG CreateOptions,
    OUT PHANDLE NewKeyBuffer, OPTIONAL
    IN PCWSTR Format,
    ...
    );

//
// Additional data type for the Type parameter in PortSetValueKey.
//

#define PORT_REG_ANSI_STRING        (0x07232002)

NTSTATUS
PortSetValueKey(
    IN HANDLE KeyHandle,
    IN PCWSTR ValueName,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );


//
// SCSI DEVIC TYPE structure.
//

typedef struct _SCSI_DEVICE_TYPE {

    //
    // String specifying the device name, e.g., "Disk", "Sequential", etc.
    //
    
    PCSTR Name;

    //
    // The generic device name for this device, e.g., "GenDisk",
    // "GenPrinter", etc.
    //

    PCSTR GenericName;

    //
    // Name of the device as stored in the SCSI DeviceMap.
    //
    
    PCWSTR DeviceMap;

    //
    // Is this a storage device?
    //

    BOOLEAN IsStorage;

} SCSI_DEVICE_TYPE, *PSCSI_DEVICE_TYPE;

typedef const SCSI_DEVICE_TYPE* PCSCSI_DEVICE_TYPE;

typedef GUID* PGUID;

PCSCSI_DEVICE_TYPE
PortGetDeviceType(
    IN ULONG DeviceType
    );

NTSTATUS
PortOpenMapKey(
    OUT PHANDLE DeviceMapKey
    );
    
NTSTATUS
PortMapBuildAdapterEntry(
    IN HANDLE DeviceMapKey,
    IN ULONG PortNumber,
    IN ULONG InterruptLevel,
    IN ULONG IoAddress,
    IN ULONG Dma64BitAddresses,
    IN PUNICODE_STRING DriverName,
    IN PGUID BusType, OPTIONAL
    OUT PHANDLE AdapterKey OPTIONAL
    );

NTSTATUS
PortMapBuildBusEntry(
    IN HANDLE AdapterKey,
    IN ULONG BusId,
    IN ULONG InitiatorId,
    OUT PHANDLE BusKeyBuffer OPTIONAL
    );


NTSTATUS
PortMapBuildTargetEntry(
    IN HANDLE BusKey,
    IN ULONG TargetId,
    OUT PHANDLE TargetKey OPTIONAL
    );

NTSTATUS
PortMapBuildLunEntry(
    IN HANDLE TargetKey,
    IN ULONG Lun,
    IN PINQUIRYDATA InquiryData,
    IN PANSI_STRING SerialNumber, OPTIONAL
    PVOID DeviceId,
    IN ULONG DeviceIdLength,
    OUT PHANDLE LunKeyBuffer OPTIONAL
    );

NTSTATUS
PortMapDeleteAdapterEntry(
    IN ULONG PortId
    );
    
NTSTATUS
PortMapDeleteLunEntry(
    IN ULONG PortId,
    IN ULONG BusId,
    IN ULONG TargetId,
    IN ULONG Lun
    );


typedef struct _INTERNAL_WAIT_CONTEXT_BLOCK {
    ULONG Flags;
    PMDL Mdl;
    PMDL DmaMdl;
    PVOID MapRegisterBase;
    PVOID CurrentVa;
    ULONG Length;
    ULONG NumberOfMapRegisters;
    union {
        struct {
            WAIT_CONTEXT_BLOCK Wcb;
            PDRIVER_LIST_CONTROL DriverExecutionRoutine;
            PVOID DriverContext;
            PIRP CurrentIrp;
            PADAPTER_OBJECT AdapterObject;
            BOOLEAN WriteToDevice;
        };
            
        SCATTER_GATHER_LIST ScatterGather;
    };

} INTERNAL_WAIT_CONTEXT_BLOCK, *PINTERNAL_WAIT_CONTEXT_BLOCK;

    
#ifdef __cplusplus
}


#endif  // __cplusplus
#endif //_PASSTHRU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\kbdhid\creatcls.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module contains the code for IRP_MJ_CREATE and IRP_MJ_CLOSE
    and IRP_MJ_DEVICE_CONTROL

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include "kbdhid.h"
NTSTATUS
KbdHid_CreateComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
KbdHid_Create (
   IN PDEVICE_OBJECT DeviceObject, // the kbdhid device object
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for create/open requests.  This request
    completes successfully, unless the filename's length is non-zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION  irpSp  = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data = NULL;
    KEVENT              event;

    Print(DBG_CC_TRACE, ("DispatchCreate: Enter.\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Determine if request is trying to open a subdirectory of the
    // given device object.  This is not allowed.
    //
    if (0 != irpSp->FileObject->FileName.Length) {
        Print(DBG_CC_ERROR, ("ERROR: Create Access Denied.\n"));

        status = STATUS_ACCESS_DENIED;
        goto KbdHid_CreateReject;
    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        goto KbdHid_CreateReject;
    }

    ExAcquireFastMutex (&data->CreateCloseMutex);

    if (NULL == data->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: enable before connect!\n"));
        status = STATUS_UNSUCCESSFUL;
    } else {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                KbdHid_CreateComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (data->TopOfStack, Irp);

        KeWaitForSingleObject(&event,
                              Executive, // Waiting for reason of a driver
                              KernelMode, // Waiting in kernel mode
                              FALSE, // No allert
                              NULL); // No timeout

        if (NT_SUCCESS (status)) {
            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS (status)) {
            InterlockedIncrement(&data->EnableCount);
            if (NULL == data->ReadFile &&
                (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA)) {
                //
                // We want to start the read pump.
                //
                Print (DBG_IOCTL_INFO, ("Enabling Keyboard \n"));

                data->ReadFile = irpSp->FileObject;

                KeResetEvent (&data->ReadCompleteEvent);

                data->ReadInterlock = KBDHID_END_READ;

                // Acquire another time for the read irp.
                IoAcquireRemoveLock (&data->RemoveLock, data->ReadIrp);
                data->ReadIrp->IoStatus.Status = STATUS_SUCCESS;
                status = KbdHid_StartRead (data);

                if (STATUS_PENDING == status) {
                    status = STATUS_SUCCESS;
                } else if (!NT_SUCCESS(status)) {
                    //
                    // Set it back to NULL so that a future open tries again.
                    // Read should not fail if open passed. ASSERT!
                    //
                    ASSERT(NT_SUCCESS(status));
                    data->ReadFile = NULL;
                }
            }

            ASSERT (data->EnableCount < 100);
            ASSERT (0 < data->EnableCount);
        }
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;

KbdHid_CreateReject:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;
}

NTSTATUS
KbdHid_Close (
   IN PDEVICE_OBJECT DeviceObject, // the kbdhid device object
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for close requests.  This request
    completes successfully, unless the file name length is zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION   data;
    PIO_STACK_LOCATION  stack;
    LARGE_INTEGER       time;

    Print(DBG_CC_TRACE, ("DispatchClose: Enter\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    ExAcquireFastMutex (&data->CreateCloseMutex);

    ASSERT (data->EnableCount < 100);
    ASSERT (0 < data->EnableCount);

    if (0 == InterlockedDecrement(&data->EnableCount)) {
        Print (DBG_IOCTL_INFO, ("Disabling Keyboard \n"));
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );

        if (IoCancelIrp (data->ReadIrp)) {
            KeWaitForSingleObject (&data->ReadCompleteEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL
                                   );
        }

//        ASSERT (NULL != data->ReadFile);
//        ASSERT (data->ReadFile == stack->FileObject);

        time = data->AutoRepeatDelay;
        KeCancelTimer (&data->AutoRepeatTimer);
#if KEYBOARD_HW_CHATTERY_FIX
        KeCancelTimer (&data->InitiateStartReadTimer);
        //
        // NB the time is a negative (relative) number;
        //
        if (data->InitiateStartReadDelay.QuadPart < time.QuadPart) {
            time = data->InitiateStartReadDelay;
        }
#endif // KEYBOARD_HW_CHATTERY_FIX

        time.QuadPart *= 2;
        KeDelayExecutionThread (KernelMode, FALSE, &time);

        data->ReadFile = NULL;
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);

    IoSkipCurrentIrpStackLocation (Irp);
    Print(DBG_CC_TRACE, ("DispatchClose: Exit \n"));
    return IoCallDriver (data->TopOfStack, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\kbdhid\mapusage.c ===
/*++

Copyright (c) 1998    Microsoft Corporation

Module Name:

    MAPUSAGE.C

Abstract:

    Code for using registry usage mapping information
    (for broken HID keyboards that return incorrect usages)
    to fix usages on the fly.

    INF example:
    ------------
    The following line in the device instance's AddReg section
    of an inf for a keyboard 
    will create a key resulting in the usage value
    0x0203 being mapped to 0x0115 :

    HKR,UsageMappings,0203,,0115

Environment:

    Kernel mode

Revision History:

    Nov-98 : created by Ervin Peretz

--*/

#include "kbdhid.h"
#include <hidclass.h>



VOID LoadKeyboardUsageMappingList(PDEVICE_EXTENSION devExt)
{
    NTSTATUS status;
    HANDLE hRegDriver;
    UsageMappingList *mapList = NULL;
    KIRQL oldIrql;


    /*
     *  Open the driver registry key
     *  ( HKLM/System/CurrentControlSet/Control/Class/<GUID>/<#n> )
     */
    status = IoOpenDeviceRegistryKey(   devExt->PDO, 
                                        PLUGPLAY_REGKEY_DRIVER, 
                                        KEY_READ, 
                                        &hRegDriver);
    if (NT_SUCCESS(status)){
        UNICODE_STRING usageMappingsKeyName;
        HANDLE hRegUsageMappings;

        /*
         *  See if the Usage Mappings subkey exists.
         */
        RtlInitUnicodeString(&usageMappingsKeyName, L"UsageMappings"); 
        status = OpenSubkey(    &hRegUsageMappings,
                                hRegDriver,
                                &usageMappingsKeyName,
                                KEY_READ);

        if (NT_SUCCESS(status)){

            /*
             *  The registry DOES contain usage mappings
             *  for this keyboard.
             */
            UsageMappingList *mapListEntry, *lastMapListEntry = NULL;
            ULONG keyIndex = 0;

            /*
             *  The key value information struct is variable-length.
             *  The actual length is equal to:
             *      the length of the base PKEY_VALUE_FULL_INFORMATION struct +
             *      the length of the name of the key (4 wide chars) + 
             *      the length of the value (4 wchars + terminator = 5 wchars).
             */
            UCHAR keyValueBytes[sizeof(KEY_VALUE_FULL_INFORMATION)+4*sizeof(WCHAR)+5*sizeof(WCHAR)];
            PKEY_VALUE_FULL_INFORMATION keyValueInfo = (PKEY_VALUE_FULL_INFORMATION)keyValueBytes;
            ULONG actualLen;

            do {
                status = ZwEnumerateValueKey(
                            hRegUsageMappings,
                            keyIndex,
                            KeyValueFullInformation,
                            keyValueInfo,
                            sizeof(keyValueBytes),
                            &actualLen); 
                if (NT_SUCCESS(status)){
                    
                    /*
                     *  Add this usage mapping to the mapping list.
                     */
                    USHORT sourceUsage, mappedUsage;
                    PWCHAR valuePtr;
                    WCHAR nameBuf[5];
                    WCHAR valueBuf[5];

                    if(keyValueInfo->Type == REG_SZ &&
                       keyValueInfo->DataLength == (4+1)*sizeof(WCHAR) &&
                       keyValueInfo->NameLength <= (4+1)*sizeof(WCHAR))
                    {

                        /*
                         *  keyValueInfo->Name is not NULL-terminated.
                         *  So copy it into a buffer and null-terminate.
                         */

                        memcpy(nameBuf, keyValueInfo->Name, 4*sizeof(WCHAR));
                        nameBuf[4] = L'\0';
                    
                        valuePtr = (PWCHAR)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset);
                        memcpy(valueBuf, valuePtr, 4*sizeof(WCHAR));
                        valueBuf[4] = L'\0';

                        sourceUsage = (USHORT)LAtoX(nameBuf);
                        mappedUsage = (USHORT)LAtoX(valueBuf);
                    }

                    /*
                     *  Create and queue a new map list entry.
                     */
                    mapListEntry = ExAllocatePool(NonPagedPool, sizeof(UsageMappingList));
                    if (mapListEntry){
                        mapListEntry->sourceUsage = sourceUsage;
                        mapListEntry->mappedUsage = mappedUsage;
                        mapListEntry->next = NULL;
                        if (lastMapListEntry){
                            lastMapListEntry->next = mapListEntry;
                            lastMapListEntry = mapListEntry;
                        }
                        else {
                            mapList = lastMapListEntry = mapListEntry;
                        }
                    }
                    else {
                        ASSERT(!(PVOID)"mem alloc failed");
                        break;
                    }

                    keyIndex++;
                }
            } while (NT_SUCCESS(status));


            ZwClose(hRegUsageMappings);
        }

        ZwClose(hRegDriver);
    }

    KeAcquireSpinLock(&devExt->usageMappingSpinLock, &oldIrql);
    devExt->usageMapping = mapList;
    KeReleaseSpinLock(&devExt->usageMappingSpinLock, oldIrql);

}


VOID FreeKeyboardUsageMappingList(PDEVICE_EXTENSION devExt)
{
    UsageMappingList *mapList;
    KIRQL oldIrql;

    KeAcquireSpinLock(&devExt->usageMappingSpinLock, &oldIrql);

    mapList = devExt->usageMapping;
    devExt->usageMapping = NULL;

    KeReleaseSpinLock(&devExt->usageMappingSpinLock, oldIrql);

    while (mapList){
        UsageMappingList *thisEntry = mapList;
        mapList = thisEntry->next;
        ExFreePool(thisEntry);
    }

}


USHORT MapUsage(PDEVICE_EXTENSION devExt, USHORT kbdUsage)
{
    UsageMappingList *mapList;
    KIRQL oldIrql;


    KeAcquireSpinLock(&devExt->usageMappingSpinLock, &oldIrql);

    mapList = devExt->usageMapping;
    while (mapList){
        if (mapList->sourceUsage == kbdUsage){
            kbdUsage = mapList->mappedUsage;
            break;
        }
        else {
            mapList = mapList->next;
        }
    }

    KeReleaseSpinLock(&devExt->usageMappingSpinLock, oldIrql);

    return kbdUsage;
}


NTSTATUS OpenSubkey(    OUT PHANDLE Handle,
                        IN HANDLE BaseHandle,
                        IN PUNICODE_STRING KeyName,
                        IN ACCESS_MASK DesiredAccess
                   )
{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenKey(Handle, DesiredAccess, &objectAttributes);

    return status;
}





ULONG LAtoX(PWCHAR wHexString)
/*++

Routine Description:

      Convert a hex string (without the '0x' prefix) to a ULONG.

Arguments:

    wHexString - null-terminated wide-char hex string 
                 (with no "0x" prefix)

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    for (i = 0; wHexString[i]; i++){
        if ((wHexString[i] >= L'0') && (wHexString[i] <= L'9')){
            result *= 0x10;
            result += (wHexString[i] - L'0');
        }
        else if ((wHexString[i] >= L'a') && (wHexString[i] <= L'f')){
            result *= 0x10;
            result += (wHexString[i] - L'a' + 0x0a);
        }
        else if ((wHexString[i] >= L'A') && (wHexString[i] <= L'F')){
            result *= 0x10;
            result += (wHexString[i] - L'A' + 0x0a);
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\kbdhid\pnp.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hid.c

Abstract:

    This module contains the code for translating HID reports to keyboard
    reports.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

//
// For this module only we set the INITGUID macro before including wdm and
// hidclass.h  This not only declares the guids but also initializes them.
//

#include "kbdhid.h"
#include "hidclass.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,KbdHid_CallHidClass)
#pragma alloc_text(PAGE,KbdHid_AddDevice)
#pragma alloc_text(PAGE,KbdHid_StartDevice)
#pragma alloc_text(PAGE,KbdHid_PnP)
#endif

NTSTATUS
KbdHid_CallHidClass(
    IN PDEVICE_EXTENSION    Data,
    IN ULONG          Ioctl,
    PVOID             InputBuffer,
    ULONG             InputBufferLength,
    PVOID             OutputBuffer,
    ULONG             OutputBufferLength
    )
/*++

Routine Description:

   Make a *synchronous* request of the HID class driver

Arguments:

    Ioctl              - Value of the IOCTL request.

    InputBuffer        - Buffer to be sent to the HID class driver.

    InputBufferLength  - Size of buffer to be sent to the HID class driver.

    OutputBuffer       - Buffer for received data from the HID class driver.

    OutputBufferLength - Size of receive buffer from the HID class.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            status = STATUS_SUCCESS;

    PAGED_CODE ();

    Print(DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));

    //
    // issue a synchronous request
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
                            Ioctl,
                            Data->TopOfStack,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            FALSE, // External
                            &event,
                            &ioStatus);

    if (NULL == irp) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    status = IoCallDriver(Data->TopOfStack, irp);

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                     &event,
                     Executive, // wait reason
                     KernelMode,
                     FALSE,     // we are not alertable
                     NULL);     // No time out !!!!
    }

    if (NT_SUCCESS (status)) {
        status = ioStatus.Status;
    }

    Print(DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));
    return status;
}

NTSTATUS
KbdHid_QueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}




NTSTATUS
KbdHid_AddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data;
    PDEVICE_OBJECT      device;
    POWER_STATE         state;

    PAGED_CODE ();


    Print (DBG_PNP_TRACE, ("enter Add Device \n"));

    status = IoCreateDevice(Driver,
                            sizeof(DEVICE_EXTENSION),
                            NULL, // no name for this Filter DO
                            FILE_DEVICE_KEYBOARD,
                            0,
                            FALSE,
                            &device);

    if (!NT_SUCCESS (status)) {
        return(status);
    }

    data = (PDEVICE_EXTENSION) device->DeviceExtension;

    //
    // Initialize the fields.
    //
    data->TopOfStack = IoAttachDeviceToDeviceStack (device, PDO);
    if (data->TopOfStack == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(Driver,
                                    (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = KBDHID_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }
    
    ASSERT (data->TopOfStack);

    data->Self = device;
    data->Started = FALSE;
    data->Initialized = FALSE;
    data->UnitId = (USHORT) InterlockedIncrement (&Globals.UnitId);
    data->PDO = PDO;

    KeInitializeSpinLock(&data->usageMappingSpinLock);

    data->ReadIrp = IoAllocateIrp (data->TopOfStack->StackSize, FALSE);
    // Initializiation happens automatically.
    if (NULL == data->ReadIrp) {
        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (device);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent (&data->ReadCompleteEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent (&data->ReadSentEvent, NotificationEvent, TRUE);
    IoInitializeRemoveLock (&data->RemoveLock, KBDHID_POOL_TAG, 1,  10);
    data->ReadFile = NULL;
    ExInitializeFastMutex (&data->CreateCloseMutex);

    data->InputData.UnitId = data->UnitId;
    data->InputData.MakeCode = 0;
    data->InputData.Flags = 0;

    data->ScanState   = Normal;
    //
    // Initialize the keyboard attributes structure.  This information is
    // queried via IOCTL_KEYBOARD_QUERY_ATTRIBUTES. [DAN]
    //
    data->Attributes.KeyboardIdentifier.Type = HID_KEYBOARD_IDENTIFIER_TYPE;
    data->Attributes.KeyboardIdentifier.Subtype = 0;
    data->IdEx.Type = HID_KEYBOARD_IDENTIFIER_TYPE;
    data->IdEx.Subtype = 0;
    data->Attributes.KeyboardMode = HID_KEYBOARD_SCAN_CODE_SET;
    data->Attributes.NumberOfFunctionKeys = HID_KEYBOARD_NUMBER_OF_FUNCTION_KEYS;
    data->Attributes.NumberOfIndicators = HID_KEYBOARD_NUMBER_OF_INDICATORS;
    data->Attributes.NumberOfKeysTotal = HID_KEYBOARD_NUMBER_OF_KEYS_TOTAL;
    data->Attributes.InputDataQueueLength = 1;
    data->Attributes.KeyRepeatMinimum.UnitId = data->UnitId;
    data->Attributes.KeyRepeatMinimum.Rate = HID_KEYBOARD_TYPEMATIC_RATE_MINIMUM;
    data->Attributes.KeyRepeatMinimum.Delay = HID_KEYBOARD_TYPEMATIC_DELAY_MINIMUM;
    data->Attributes.KeyRepeatMaximum.UnitId = data->UnitId;
    data->Attributes.KeyRepeatMaximum.Rate = HID_KEYBOARD_TYPEMATIC_RATE_MAXIMUM;
    data->Attributes.KeyRepeatMaximum.Delay = HID_KEYBOARD_TYPEMATIC_DELAY_MAXIMUM;

    //
    // Initialize the keyboard indicators structure. [DAN]
    //
    data->Indicators.UnitId   = data->UnitId;
    data->Indicators.LedFlags = 0;

    //
    // Initialize the keyboard typematic info structure. [DAN]
    //
    data->Typematic.UnitId = data->UnitId;
    data->Typematic.Rate   = HID_KEYBOARD_TYPEMATIC_RATE_DEFAULT;
    data->Typematic.Delay  = HID_KEYBOARD_TYPEMATIC_DELAY_DEFAULT;

    //
    // Initialize private typematic information. [DAN]
    //
    KeInitializeDpc (&data->AutoRepeatDPC, KbdHid_AutoRepeat, data);
    KeInitializeTimer (&data->AutoRepeatTimer);
    data->AutoRepeatRate = 1000 / HID_KEYBOARD_TYPEMATIC_RATE_DEFAULT;    //ms
    data->AutoRepeatDelay.LowPart = -HID_KEYBOARD_TYPEMATIC_DELAY_DEFAULT * 10000;
    //100ns
    data->AutoRepeatDelay.HighPart = -1;



#if KEYBOARD_HW_CHATTERY_FIX // [DAN]
    //
    // Initialize StartRead-initiator DPC.
    //
    KeInitializeDpc (&data->InitiateStartReadDPC,
                     KbdHid_InitiateStartRead,
                     data);
    KeInitializeTimer (&data->InitiateStartReadTimer);
    data->InitiateStartReadDelay.QuadPart = -DEFAULT_START_READ_DELAY;
    data->InitiateStartReadUserNotified = FALSE;
#endif

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState (device, DevicePowerState, state);

    data->WmiLibInfo.GuidCount = sizeof (KbdHid_WmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);

    data->WmiLibInfo.GuidList = KbdHid_WmiGuidList;
    data->WmiLibInfo.QueryWmiRegInfo = KbdHid_QueryWmiRegInfo;
    data->WmiLibInfo.QueryWmiDataBlock = KbdHid_QueryWmiDataBlock;
    data->WmiLibInfo.SetWmiDataBlock = KbdHid_SetWmiDataBlock;
    data->WmiLibInfo.SetWmiDataItem = KbdHid_SetWmiDataItem;
    data->WmiLibInfo.ExecuteWmiMethod = NULL;
    data->WmiLibInfo.WmiFunctionControl = NULL;

    device->Flags |= DO_POWER_PAGABLE;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
KbdHid_StartDevice (
    IN PDEVICE_EXTENSION    Data
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    HIDP_CAPS                  caps; // the capabilities of the found hid device
    HID_COLLECTION_INFORMATION info;
    NTSTATUS                   status = STATUS_SUCCESS;
    PHIDP_PREPARSED_DATA       preparsedData = NULL;
    PHID_EXTENSION             hid = NULL;
    ULONG                      length, usageListLength, inputBufferLength;
    ULONG                      maxUsages;
    PCHAR                      buffer;
    HANDLE                     devInstRegKey;
    ULONG                      tmp;

    PAGED_CODE ();

    Print (DBG_PNP_TRACE, ("enter START Device \n"));

    //
    // Check the registry for any usage mapping information
    // for this particular keyboard.
    //
    // Note: Need to call this after devnode created
    //       (after START_DEVICE completes).
    //       For raw devices, this will fail on the first start
    //       (b/c devnode not there yet)
    //       but succeed on the second start.
    //
    LoadKeyboardUsageMappingList (Data);

    //
    // Retrieve the capabilities of this hid device
    // IOCTL_HID_GET_COLLECTION_INFORMATION fills in HID_COLLECTION_INFORMATION.
    // we are interested in the Descriptor Size, which tells us how big a
    // buffer to allocate for the preparsed data.
    //
    if (!NT_SUCCESS (status = KbdHid_CallHidClass (
                                        Data,
                                        IOCTL_HID_GET_COLLECTION_INFORMATION,
                                        0, 0, // no input
                                        &info, sizeof (info)))) {
        goto KbdHid_StartDeviceReject;
    }

    //
    // Allocate memory to hold the preparsed data.
    //
    preparsedData = (PHIDP_PREPARSED_DATA)
                    ExAllocatePool (NonPagedPool, info.DescriptorSize);

    if (!preparsedData) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_StartDeviceReject;
    }

    //
    // Retrieve that information.
    //

    if (!NT_SUCCESS (status = KbdHid_CallHidClass (
                                       Data,
                                       IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                       0, 0, // no input
                                       preparsedData, info.DescriptorSize))) {
        goto KbdHid_StartDeviceReject;
    }

    //
    // Call the parser to determine the capabilites of this HID device.
    //

    if (!NT_SUCCESS (status = HidP_GetCaps (preparsedData, &caps))) {
        goto KbdHid_StartDeviceReject;
    }


    //
    // Set the number of buttons for this keyboard.
    // Note: we are actually reading here the total number of independant
    // chanels on the device.  But that should be satisfactory for a keyboard.
    //

    Data->Attributes.NumberOfKeysTotal = caps.NumberInputDataIndices;

    //
    // look for any device parameters.
    //
    status = IoOpenDeviceRegistryKey (Data->PDO,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &devInstRegKey);

    if (NT_SUCCESS (status)) {
        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_TYPE_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.KeyboardIdentifier.Type = (UCHAR) tmp;
            Data->IdEx.Type = tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_SUBTYPE_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.KeyboardIdentifier.Subtype = (UCHAR) tmp;
            Data->IdEx.Subtype = tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_NUMBER_TOTAL_KEYS_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.NumberOfKeysTotal = (USHORT) tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_NUMBER_FUNCTION_KEYS_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.NumberOfFunctionKeys = (USHORT) tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_NUMBER_INDICATORS_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.NumberOfIndicators = (USHORT) tmp;
        }

        ZwClose (devInstRegKey);

        if (!NT_SUCCESS (status)) {
            status = STATUS_SUCCESS;
        }
    }

    //
    // Note: here we might also want to check the button and value capabilities
    // of the device as well.
    //
    // Then let's use it.
    //

    //
    // a buffer length to allow an Input buffer, output buffer, feature buffer,
    // and the total number of usages that can be returned from a read packet.
    //

    maxUsages = HidP_MaxUsageListLength (
                           HidP_Input,
                           HID_USAGE_PAGE_KEYBOARD,
                           preparsedData);

    //
    // Create space in the device extension for the buffer storage when working
    // with this HID device.
    //
    // We need four buffers to hold the button codes (length returned from
    // HidP_MaxUsageListLength) this will hold the current list of usages,
    // the previous list of usages, the ``Make'' and the ``Break'' lists.
    // We also need a place to put the input, output, and feature report
    // buffers.
    //

    if (maxUsages > (MAXULONG / sizeof(USAGE_AND_PAGE) )) {
        status = STATUS_UNSUCCESSFUL;
        goto KbdHid_StartDeviceReject;
    }

    usageListLength = ALIGNPTRLEN(maxUsages * sizeof (USAGE_AND_PAGE));
    inputBufferLength = ALIGNPTRLEN(caps.InputReportByteLength);
    
    if ((MAXULONG - inputBufferLength < sizeof(HID_EXTENSION)) ||
        ((MAXULONG - inputBufferLength - sizeof(HID_EXTENSION))/ 6 < usageListLength)) {
        
        status = STATUS_UNSUCCESSFUL;
        goto KbdHid_StartDeviceReject;
        
    }

    length = (6 * usageListLength)
           + inputBufferLength
           + sizeof (HID_EXTENSION);

    Data->HidExtension = hid = ExAllocatePool (NonPagedPool, length);

    if (!hid) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_StartDeviceReject;
    }

    RtlZeroMemory (hid, length);

    //
    // Initialize the fields.
    //
    hid->Ppd = preparsedData;
    hid->Caps = caps;
    hid->MaxUsages = maxUsages;
    // hid->ModifierState.ul = 0;

    hid->InputBuffer = buffer = hid->Buffer;
    hid->PreviousUsageList =  (PUSAGE_AND_PAGE) (buffer += inputBufferLength);
    hid->CurrentUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->BreakUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->MakeUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->OldMakeUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->ScrapBreakUsageList = (PUSAGE_AND_PAGE) (buffer + usageListLength);

    //
    // Create the MDLs
    // HidClass uses direct IO so you need MDLs
    //

    hid->InputMdl = IoAllocateMdl (hid->InputBuffer,   // The virtual address
                                   caps.InputReportByteLength, // length
                                   FALSE,  // No associated IRP => not secondary
                                   FALSE,  // No quota charge
                                   0);     // No associated IRP
    if (NULL == hid->InputMdl) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_StartDeviceReject;
    }
    MmBuildMdlForNonPagedPool (hid->InputMdl);  // Build this MDL.

    return status;

KbdHid_StartDeviceReject:
    if (preparsedData) {
        // no need to set hid->Ppd to NULL becuase we will be freeing it as well
        ExFreePool (preparsedData);
    }
    if (hid) {
        if (hid->InputMdl) {
            IoFreeMdl (hid->InputMdl);
        }
        ExFreePool (hid);
        Data->HidExtension = NULL;
    }

    return status;
}

NTSTATUS
KbdHid_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   data;
    PHID_EXTENSION      hid;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    ULONG               i, j;
    PDEVICE_EXTENSION * classDataList;
    LARGE_INTEGER       time;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    hid = data->HidExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT (FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    Print(DBG_PNP_TRACE, ("PNP: Minor code = %x.", stack->MinorFunction));
    
    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        if (data->Started) {
            Print(DBG_PNP_INFO, ("PNP: Device already started." ));
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            break;
        }

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&data->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                KbdHid_PnPComplete,
                                data,
                                TRUE,
                                TRUE,
                                TRUE); // No need for Cancel

        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = IoCallDriver (data->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &data->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            if (!data->Initialized) {
                status = KbdHid_StartDevice (data);
                if (NT_SUCCESS (status)) {
                    IoWMIRegistrationControl(DeviceObject,
                                             WMIREG_ACTION_REGISTER
                                             );
                    
                    data->Started = TRUE;
                    data->Initialized = TRUE;
                }
            } else {
                data->Started = TRUE;
            }
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        if (data->Started) {
            //
            // Do what ever
            //
        }

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //

        //
        // Stop Device touching the hardware MouStopDevice(data, TRUE);
        //
        data->Started = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!usbData->Removed);
        Print (DBG_PNP_TRACE, ("enter RemoveDevice \n"));

        IoWMIRegistrationControl(data->Self,
                                 WMIREG_ACTION_DEREGISTER
                                 );

        if (data->Started) {
            // Stop the device without touching the hardware.
            // MouStopDevice(data, FALSE);
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device could be GONE so we cannot send it any non-
        // PNP IRPS.
        //

        time = data->AutoRepeatDelay;

        KeCancelTimer (&data->AutoRepeatTimer);
#if KEYBOARD_HW_CHATTERY_FIX
        KeCancelTimer (&data->InitiateStartReadTimer);
        //
        // NB the time is a negative (relative) number;
        //
        if (data->InitiateStartReadDelay.QuadPart < time.QuadPart) {
            time = data->InitiateStartReadDelay;
        }
#endif

        KeDelayExecutionThread (KernelMode, FALSE, &time);

        //
        // Cancel our read IRP.  [DAN]
        // Note - waiting is only really necessary on 98, where pnp doesn't
        // make sure all handles are closed before sending the remove.
        //
        data->ShuttingDown = TRUE;
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
        IoCancelIrp (data->ReadIrp);

        //
        // Send on the remove IRP
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);

        //
        // Wait for the remove lock to free.
        //
        IoReleaseRemoveLockAndWait (&data->RemoveLock, Irp);

        //
        // Free the associated memory.
        //
        IoFreeIrp (data->ReadIrp);

        if (hid) {
            //
            // If we are removed without being started then we will have
            // no hid extension
            //
            ExFreePool (hid->Ppd);
            IoFreeMdl (hid->InputMdl);
            ExFreePool (hid);
        }

        FreeKeyboardUsageMappingList(data);

        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (data->Self);
        return status;

    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        //
        // These IRPs have to have their status changed from 
        // STATUS_NOT_SUPPORTED b4 passing them down.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
    
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}


NTSTATUS
KbdHid_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PDEVICE_EXTENSION   data;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    data = (PDEVICE_EXTENSION) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&data->StartEvent, 0, FALSE);

            //
            // Take the IRP back so that we can continue using it during
            // the IRP_MN_START_DEVICE dispatch routine.
            // NB: we will have to call IoCompleteRequest
            //
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
KbdHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    Print(DBG_POWER_TRACE, ("Power Enter." ));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Print(DBG_POWER_INFO, ("Power Setting %s state to %d\n",
                               ((powerType == SystemPowerState) ? "System"
                                                                : "Device"),
                               powerState.SystemState));
        break;

    case IRP_MN_QUERY_POWER:
        Print (DBG_POWER_INFO, ("Power query %s status to %d\n",
                                ((powerType == SystemPowerState) ? "System"
                                                                 : "Device"),
                                powerState.SystemState));
        break;

    default:
        Print (DBG_POWER_ERROR, ("Power minor (0x%x) no known\n",
                                 stack->MinorFunction));
    }

    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);
    status = PoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\kbdhid\kbdhid.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    KBDHID.C

Abstract:

    This module contains the init code for the i8042 to hid converter.

    Note: This is NOT a WDM driver, since it cannot run as a HID mapper on
    Memphis (Memphis requires that the keyboard to HID mapper be a VXD) and
    since it uses Event logs, which are not part of WDM 1.0

Environment:

    Kernel mode

Revision History:

    Nov-96 : created by Kenneth D. Ray
    Jan-97 : Dan Markarian : Made work
    May-97 : Kenneth D. Ray : reconstructed as PnP filter for Keyboard class

--*/

#include "kbdhid.h"
#include "hidclass.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out). [DAN]
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,KbdHid_Unload)
#endif

GLOBALS Globals;

NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:

   Installable driver initialization entry point.

Arguments:

   DriverObject - pointer to the driver object

   RegistryPath - pointer to a unicode string representing the path
                  to driver-specific key in the registry

Return Value:

   NT status code

--*/
{
    NTSTATUS        status       = STATUS_SUCCESS;
    PUNICODE_STRING registryPath = &Globals.RegistryPath;

    Print (DBG_SS_TRACE, ("entering DriverEntry\n"));
    Print (DBG_SS_INFO, ("Keyboard to hid mapper\n"));

    RtlZeroMemory (&Globals, sizeof (GLOBALS));

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //
    registryPath->MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length = RegistryPath->Length;
    registryPath->Buffer = ExAllocatePool(
                              PagedPool,
                              registryPath->MaximumLength
                              );

    if (!registryPath->Buffer) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate pool for registry path."));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryReject;
    }

    RtlZeroMemory (registryPath->Buffer, registryPath->MaximumLength);

    RtlMoveMemory (registryPath->Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->Length);

    //
    // Set up the device driver entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]              = KbdHid_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]               = KbdHid_Close;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]=KbdHid_IOCTL;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]      = KbdHid_PassThrough;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]       = KbdHid_Flush;
    DriverObject->MajorFunction[IRP_MJ_PNP]                 = KbdHid_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]               = KbdHid_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]      = KbdHid_SystemControl;
    DriverObject->DriverUnload                              = KbdHid_Unload;
    DriverObject->DriverExtension->AddDevice                = KbdHid_AddDevice;

    Print (DBG_SS_TRACE, ("exit DriverEntry (0x%x) \n", status));

    return status;

DriverEntryReject:

    if (registryPath->Buffer) {
        ExFreePool (registryPath->Buffer);
    }
    return status;
}

NTSTATUS
KbdHid_PassThrough (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
/*++

Routine Description:
    Pass the irp on through


--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;

    data = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}

VOID
KbdHid_Unload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources, etc.

Arguments:

   DriverObject - pointer to a driver object

Return Value:

   None

--*/
{
    PAGED_CODE ();

    ASSERT (NULL == Driver->DeviceObject);

    Print (DBG_SS_INFO, ("Unload \n"));

    //
    // Free resources in device extension.
    //
    ExFreePool (Globals.RegistryPath.Buffer);

    return;
}

NTSTATUS
KbdHid_Flush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Respond to flush requests from the mouse class driver.  Currently does
    nothing but pass IRP down to next lower driver.   This routine expects
    the current IRQL to be < DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION  data;
    NTSTATUS           status;
    PIO_STACK_LOCATION stack;

    Print (DBG_CALL_INFO, ("Flush \n"));

    TRAP();

    //
    // Get a pointer to the device extension.
    //
    data = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Send the flush request down to the HID class driver, one for each
    // of our mouse device context structures.
    //

    IoCopyCurrentIrpStackLocationToNext (Irp);
    stack = IoGetNextIrpStackLocation (Irp);

    stack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    stack->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_FLUSH_QUEUE;

    //
    // Fire and forget
    //
    status = IoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}


NTSTATUS
KbdHid_IOCTL (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Respond to queries from the mouse class driver.

    The IOCTLs for DISABLE, ENABLE, and QUERY_ATTRIBUTES, expect the current
    IRQL to be < DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      stack;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       data;
    ULONG                   length;
    PKEYBOARD_INDICATOR_TRANSLATION translation;
    BOOLEAN                 completeIt = TRUE;

    data = DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;
    stack = IoGetCurrentIrpStackLocation (Irp);

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT (data->Started ||
            (IOCTL_INTERNAL_KEYBOARD_CONNECT ==
             stack->Parameters.DeviceIoControl.IoControlCode));

    switch (stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // Connect a keyboard class device driver to the port driver.
        //

        Print (DBG_IOCTL_TRACE, ("enter Connect \n"));

        //
        // Connect a mouse class device driver to the filter driver.
        // Only allow one connection.
        //
        if (NULL != data->ConnectData.ClassService) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Multiple connects \n"));
            TRAP ();
            status = STATUS_SHARING_VIOLATION;
            break;

        } else if (stack->Parameters.DeviceIoControl.InputBufferLength <
                   sizeof(CONNECT_DATA)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Invalid connect parameter size. \n"));
            TRAP ();
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        data->ConnectData = *(PCONNECT_DATA)
                        stack->Parameters.DeviceIoControl.Type3InputBuffer;

        status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:
        //
        // Disconnect a keyboard class device driver from the port driver.
        //
        Print (DBG_IOCTL_TRACE, ("Disconnect \n"));

        //
        // Not implemented.
        //
        // To implement, code the following:
        // ---------------------------------
        // o ENSURE that we are NOT enabled (mouHidDeviceExt->EnableCount);
        //   o If we are, then (a) return STATUS_UNSUCCESSFUL, or
        //                     (b) disable all devices immediately; see
        //                         DISABLE IOCTL call for necessary code.
        // o SYNCHRONIZE with the mouse read completion routine (must
        //   protect the callback pointer from being dereferenced when
        //   it becomes null).  Note that no mechanism currently exists
        //   for this.
        // o CLEAR the connection parameters in the device extension;
        //   ie. mouHidDeviceExt->MouClassObject   = NULL;
        //       mouHidDeviceExt->MouClassCallback = NULL;
        // o RELEASE the synchronizing lock.
        // o RETURN STATUS_SUCCESS.
        //

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_INTERNAL_KEYBOARD_ENABLE:
        //
        // Enable keyboard interrupts which really means start the ping pong
        // down to hid class.
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: PnP => use create not enable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    case IOCTL_INTERNAL_KEYBOARD_DISABLE:
        //
        // Disable keyboard interrupts which really means stop the ping pongs
        // down to hid class.
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: PnP => use close not Disable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
        //
        // Query the keyboard attributes.  First check for adequate buffer
        // length.  Then, copy the keyboard attributes from the first device
        // context to the output buffer. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Query Attributes \n"));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_ATTRIBUTES)) {

            Print (DBG_IOCTL_ERROR,
                     ("ERROR: Query Attributes buffer too small \n"));
            status = STATUS_BUFFER_TOO_SMALL;
        } else {

            //
            // Copy the keyboard attributes to the buffer.
            //

            *(PKEYBOARD_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                data->Attributes;

            Irp->IoStatus.Information = sizeof (KEYBOARD_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
        //
        // Query the scan code to indicator-light mapping. Validate the
        // parameters, and copy the indicator mapping information from
        // the static translation list to the SystemBuffer.
        //
        Print (DBG_IOCTL_TRACE, ("Query Indicator Translation \n"));

        length = sizeof(KEYBOARD_INDICATOR_TRANSLATION)
            + (sizeof(INDICATOR_LIST)
            * (HID_KEYBOARD_NUMBER_OF_INDICATORS - 1));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength < length) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Copy the indicator mapping information to the system
        // buffer.
        //

        translation = ((PKEYBOARD_INDICATOR_TRANSLATION)
                       Irp->AssociatedIrp.SystemBuffer);

        translation->NumberOfIndicatorKeys = HID_KEYBOARD_NUMBER_OF_INDICATORS;
        RtlMoveMemory(translation->IndicatorList,
                      (PCHAR) IndicatorList,
                      length - FIELD_OFFSET (KEYBOARD_INDICATOR_TRANSLATION,
                                             IndicatorList));

        Irp->IoStatus.Information = length;
        status = STATUS_SUCCESS;

        break;

    case IOCTL_KEYBOARD_QUERY_INDICATORS:
        //
        // Query the keyboard indicators.  Validate the parameters, and
        // copy the indicator information from the device context to
        // the SystemBuffer. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Query Indicators \n"));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Copy the keyboard indicators to the buffer.
        //
        //
        // Don't bother to synchronize access to the device context
        // KeyboardIndicators field while copying it. We don't care
        // if another process is setting the LEDs.
        //

        // Copy the keyboard indicators to the buffer.
        *(PKEYBOARD_INDICATOR_PARAMETERS) Irp->AssociatedIrp.SystemBuffer =
            data->Indicators;

        Irp->IoStatus.Information = sizeof(KEYBOARD_INDICATOR_PARAMETERS);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_KEYBOARD_SET_INDICATORS:
        //
        // Set the keyboard indicators for all known device contexts. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Set Indicators \n"));

        if (stack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Set Indicators size!\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = KbdHid_SetLedIndicators (
                     data,
                     (PKEYBOARD_INDICATOR_PARAMETERS) Irp->AssociatedIrp.SystemBuffer,
                     Irp);

        completeIt = FALSE;

        break;

    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
        //
        // Query the current keyboard typematic rate and delay.  Validate
        // the parameters, and copy the typematic information from the port
        // device extension to the SystemBuffer. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Query Typematic \n"));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: query typematic size!\n"));
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Copy the keyboard typematic info to the buffer.
        //

        //
        // Don't bother to synchronize access to the device context
        // KeyboardTypematic field while copying it.  We don't care
        // if another process is setting the typematic info.
        //

        *(PKEYBOARD_TYPEMATIC_PARAMETERS) Irp->AssociatedIrp.SystemBuffer =
            data->Typematic;

        Irp->IoStatus.Information = sizeof(KEYBOARD_TYPEMATIC_PARAMETERS);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_KEYBOARD_SET_TYPEMATIC:
        //
        // Set the keyboard typematic rate and delay for all known device
        // contexts. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Set Typematic \n"));

        if (stack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Set Typematic size\n"));
            status = STATUS_INVALID_PARAMETER;
            break;

        }

#define NewTypematic ((PKEYBOARD_TYPEMATIC_PARAMETERS) \
                      Irp->AssociatedIrp.SystemBuffer)

        if ((NewTypematic->Rate == 0) && (NewTypematic->Delay == 0)) {
            break;
        }

        if ((NewTypematic->Rate  < data->Attributes.KeyRepeatMinimum.Rate) ||
            (NewTypematic->Rate  > data->Attributes.KeyRepeatMaximum.Rate) ||
            (NewTypematic->Delay < data->Attributes.KeyRepeatMinimum.Delay) ||
             (NewTypematic->Delay > data->Attributes.KeyRepeatMaximum.Delay)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Set Typematic range\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        Print (DBG_IOCTL_INFO,
                 ("Set Typematic Rate: %d Delay: %d\n",
                  NewTypematic->Rate,
                  NewTypematic->Delay));

        //
        // Don't bother to synchronize access to the device context
        // KeyboardTypematic field while copying it.  We don't care
        // if another thread is reading the typematic info.
        //
        // Note the only danger here is in setting the 64-bit integer
        // "AutoRepeatDelay" in two non-atomic statements.   However,
        // we are safe since we never set "HighPart" to anything but
        // -1.
        //
        data->Typematic = *NewTypematic;

        data->AutoRepeatRate = 1000 / NewTypematic->Rate;           // ms
        data->AutoRepeatDelay.LowPart = -NewTypematic->Delay*10000; // 100ns
        data->AutoRepeatDelay.HighPart = -1;
        break;

#undef NewTypematic

    default:
        Print (DBG_IOCTL_ERROR,
                 ("ERROR: unknown IOCTL: 0x%x \n",
                  stack->Parameters.DeviceIoControl.IoControlCode));
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    if (completeIt) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    Print (DBG_IOCTL_TRACE, ("IOCTL exit (%x)\n", status));
    return status;
}

NTSTATUS
KbdHid_SetLedIndicatorsComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PIO_STACK_LOCATION  stack;
    PDEVICE_EXTENSION   data;

    stack = IoGetCurrentIrpStackLocation (Irp);
    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (Irp->PendingReturned) {
        IoMarkIrpPending (Irp);
    }

    IoFreeMdl (Irp->MdlAddress);
    Irp->MdlAddress = (PMDL) stack->Parameters.Others.Argument4;

    ExFreePool (Context);

    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return STATUS_SUCCESS;
}

NTSTATUS
KbdHid_SetLedIndicators (
    PDEVICE_EXTENSION               Data,
    PKEYBOARD_INDICATOR_PARAMETERS  NewIndicators,
    PIRP                            Irp
    )
/*++

Routine Description:

    Set the LED indicators of the supplied keyboard device context.

Arguments:

    Data       - Pointer to the driver device extension.

    Parameters - Pointer to the keyboard indicators to set/unset.

    Irp        - An Irp to use for setting these parameters

Return Value:

    STATUS_SUCCESS on success, STATUS_PENDING if operation is still pending,
    or otherwise an NTSTATUS error code on an error.

--*/
{
    PIO_STACK_LOCATION nextStack;
    PIO_STACK_LOCATION curStack;
    NTSTATUS           status         = STATUS_SUCCESS;
    USAGE              usageBuffer [4]; // only 4 known usages hardcoded below
    ULONG              usageBufferLen = 0;
    PCHAR              outputBuffer = 0;
    PMDL               outputMdl = 0;
    PHID_EXTENSION     hid = Data->HidExtension;

    status = IoAcquireRemoveLock (&Data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    if (0 == hid->Caps.OutputReportByteLength) {
        //
        // This device has no LEDs, now while that is strange it is not really
        // an error.  HID keyboards can have any LEDs that they want, including
        // none.
        //
        status = STATUS_SUCCESS;
        goto KbdHid_SetIndicatorsReject;
    }

    outputBuffer = ExAllocatePool (NonPagedPool,
                                   hid->Caps.OutputReportByteLength);

    if (NULL == outputBuffer) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_SetIndicatorsReject;
    }

    outputMdl = IoAllocateMdl (outputBuffer,   // The virtual address
                               hid->Caps.OutputReportByteLength, // length of the MDL
                               FALSE,  // No associated IRP -> not secondary
                               FALSE,  // No quota charge
                               0);     // No associated IRP

    if (NULL == outputMdl) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_SetIndicatorsReject;
    }

    MmBuildMdlForNonPagedPool (outputMdl);  // Build this MDL.

    //
    // Zero the output report packet.
    //
    RtlZeroMemory(outputBuffer, hid->Caps.OutputReportByteLength);

    //
    // Setup the usage list of LEDs.
    //
    if (NewIndicators->LedFlags & KEYBOARD_KANA_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_KANA;
    }
    if (NewIndicators->LedFlags & KEYBOARD_CAPS_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_CAPS_LOCK;
    }
    if (NewIndicators->LedFlags & KEYBOARD_NUM_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_NUM_LOCK;
    }
    if (NewIndicators->LedFlags & KEYBOARD_SCROLL_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_SCROLL_LOCK;
    }

    if (usageBufferLen == 0) {
        ASSERT((NewIndicators->LedFlags & (KEYBOARD_KANA_LOCK_ON |
                                           KEYBOARD_CAPS_LOCK_ON |
                                           KEYBOARD_NUM_LOCK_ON |
                                           KEYBOARD_SCROLL_LOCK_ON)) == 0);
        //
        // In order to fix led setting on a multiple collection keyboard, we
        // have to initialize the output report to make sure we get the correct
        // collection id. This is for the case where we are going from one
        // led on to all leds off. If not initialized, we'll get a report with no
        // collection id at the beginning.
        //
        usageBuffer[0] = HID_USAGE_LED_SCROLL_LOCK; // arbitirary led
        usageBufferLen = 1;

        HidP_UnsetUsages(HidP_Output,
                         HID_USAGE_PAGE_LED,
                         0,
                         usageBuffer,
                         &usageBufferLen,
                         hid->Ppd,
                         outputBuffer,
                         hid->Caps.OutputReportByteLength);

    }
    else {
        //
        // Set the usages in the output report.
        //
        HidP_SetUsages(HidP_Output,
                       HID_USAGE_PAGE_LED,
                       0,
                       usageBuffer,
                       &usageBufferLen,
                       hid->Ppd,
                       outputBuffer,
                       hid->Caps.OutputReportByteLength);
    }

    //
    // Obtain a pointer to the next IRP stack location.
    //
    nextStack = IoGetNextIrpStackLocation (Irp);
    curStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT(nextStack != NULL);

    //
    // Set up our write to HIDCLASS.
    //
    curStack->Parameters.Others.Argument4 = (PVOID) Irp->MdlAddress;
    Irp->MdlAddress = outputMdl;

    IoCopyCurrentIrpStackLocationToNext (Irp);
    nextStack->MajorFunction           = IRP_MJ_WRITE;
    nextStack->Parameters.Write.Length = hid->Caps.OutputReportByteLength;
    nextStack->Parameters.Write.Key    = 0;
    nextStack->Parameters.Write.ByteOffset.QuadPart = 0;

    //
    // Hook a completion routine to be called when the request completes.
    //

    IoSetCompletionRoutine (Irp,
                            KbdHid_SetLedIndicatorsComplete,
                            outputBuffer,
                            TRUE,
                            TRUE,
                            TRUE);
    //
    // Call the next driver.
    //
    status = IoCallDriver(Data->TopOfStack, Irp);

    //
    // Return status.
    //
    return status;

KbdHid_SetIndicatorsReject:

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    if (NULL != outputBuffer) {
        ExFreePool (outputBuffer);
    }
    if (NULL != outputMdl) {
        IoFreeMdl (outputMdl);
    }
    IoReleaseRemoveLock (&Data->RemoveLock, Irp);
    return status;
}

VOID
KbdHid_LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN NTSTATUS       ErrorCode,
   IN PWSTR          ErrorInsertionString OPTIONAL)
/*++

[DAN]

Routine Description:

    Logs an error to the system.

Arguments:

    DriverObject - Pointer to driver object reporting the error.

    ErrorCode    - Indicates the type of error, system or driver-defined.

    ErrorInsertionString - Null-terminated Unicode string inserted into error
                           description, as defined by error code.  Must be no
                           no longer than 50 characters.

Return Value:

    None.

--*/
{
   ULONG                errorInsertionStringSize = 0;
   PIO_ERROR_LOG_PACKET errorLogEntry;
   ULONG                errorLogEntrySize;                  // [including null]
   PWCHAR               pWChar;

   if (ErrorInsertionString) {
      for (pWChar = ErrorInsertionString; *pWChar; pWChar++) {
         errorInsertionStringSize += sizeof(WCHAR);
      }
      errorInsertionStringSize += sizeof(UNICODE_NULL);
   }

   errorLogEntrySize = sizeof(IO_ERROR_LOG_PACKET) + errorInsertionStringSize;

   //
   // Log an error.
   //
   if (errorLogEntrySize <= ERROR_LOG_MAXIMUM_SIZE) {

      errorLogEntry = IoAllocateErrorLogEntry(DriverObject,
                                              (UCHAR)errorLogEntrySize);

      if (errorLogEntry != NULL) {

         RtlZeroMemory(errorLogEntry, errorLogEntrySize);

         errorLogEntry->ErrorCode       = ErrorCode;
         errorLogEntry->FinalStatus     = ErrorCode;
         errorLogEntry->NumberOfStrings = (ErrorInsertionString) ? 1 : 0;

         if (ErrorInsertionString) {
           RtlCopyMemory(errorLogEntry->DumpData,
                         ErrorInsertionString,
                         errorInsertionStringSize);
         }

         IoWriteErrorLogEntry(errorLogEntry);
      }
   }

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\kbdhid\kbdhid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    KBDHID.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements this sample client driver.

    Note: This is not a WDM driver as it will not run on Memphis (you need a
    vxd mapper to do keyboards for Memphis) and it uses event logs

Environment:

    Kernel mode

Revision History:

    Nov-96 : created by Kenneth D. Ray

--*/

#ifndef _KBDHID_H
#define _KBDHID_H

#include "ntddk.h"
#include "hidusage.h"
#include "hidpi.h"
#include "ntddkbd.h"
#include "kbdmou.h"
#include "kbdhidm.h"
#include "wmilib.h"

//
// Sometimes we allocate a bunch of structures together and need to split the
// allocation among these different structures. Use this macro to get the
// lengths of the different structures aligned properly
// 
#if defined(_WIN64)
// Round the 
#define ALIGNPTRLEN(x) ((x + 0x7) >> 3) << 3
#else // defined(_WIN64)
#define ALIGNPTRLEN(x) x
#endif // defined(_WIN64)

//
// allow a device parameter in the dev node to override the reported keyboard
// type, with a value of this name.
//
#define KEYBOARD_TYPE_OVERRIDE L"KeyboardTypeOverride"
#define KEYBOARD_SUBTYPE_OVERRIDE L"KeyboardSubtypeOverride"
#define KEYBOARD_NUMBER_TOTAL_KEYS_OVERRIDE L"KeyboardNumberTotalKeysOverride"
#define KEYBOARD_NUMBER_FUNCTION_KEYS_OVERRIDE L"KeyboardNumberFunctionKeysOverride"
#define KEYBOARD_NUMBER_INDICATORS_OVERRIDE L"KeyboardNumberIndicatorsOverride"

//
// Only allocate with a pool tag.  Remember that NT and 95 are little endian
// systmes.
//
#define KBDHID_POOL_TAG (ULONG) 'lCdH'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, KBDHID_POOL_TAG);

//
// Registry ProblemFlags masks. [DAN]
//
#define PROBLEM_CHATTERY_KEYBOARD 0x00000001

#define KEYBOARD_HW_CHATTERY_FIX 1 // [DAN]

#if KEYBOARD_HW_CHATTERY_FIX // [DAN]
  //
  // Delay between StartRead calls for chattery keyboards.
  //
  // Note that the StartRead delay for chattery keyboards must be no greater
  // than KEYBOARD_TYPEMATIC_DELAY_MINIMUM milliseconds (250), otherwise the
  // keys on the keyboard will auto-repeat unexpectedly.
  //
  // 50ms will satisfy 212 words/minute (one word = 5 keystrokes), the world's
  // fastest typing speed as recorded in the 23rd Guiness Book of World Record.
  //
  #define DEFAULT_START_READ_DELAY (50 * 10000) // 50 miliseconds.
#endif

//
// Declarations. [DAN]
//

#define HID_KEYBOARD_NUMBER_OF_FUNCTION_KEYS 12  // 12 "known" func-key usages
#define HID_KEYBOARD_NUMBER_OF_KEYS_TOTAL    101 // 101 "known" key usages
#define HID_KEYBOARD_IDENTIFIER_TYPE         81

//
// Flags to indicate whether read completed synchronously or asynchronously
//
#define KBDHID_START_READ     0x01
#define KBDHID_END_READ       0x02
#define KBDHID_IMMEDIATE_READ 0x03

//
// Statically allocate the (known) scancode-to-indicator-light mapping.
// This information is returned by the
// IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION device control request.
//

#define HID_KEYBOARD_NUMBER_OF_INDICATORS              3

//
// Default keyboard scan code mode (lifted from I8042PRT.H). [DAN]
//

#define HID_KEYBOARD_SCAN_CODE_SET 0x01

//
// Minimum, maximum, and default values for keyboard typematic rate and delay
// (lifted from I8042PRT.H).  [DAN]
//

#define HID_KEYBOARD_TYPEMATIC_RATE_MINIMUM     2
#define HID_KEYBOARD_TYPEMATIC_RATE_MAXIMUM    30
#define HID_KEYBOARD_TYPEMATIC_RATE_DEFAULT    30
#define HID_KEYBOARD_TYPEMATIC_DELAY_MINIMUM  250
#define HID_KEYBOARD_TYPEMATIC_DELAY_MAXIMUM 1000
#define HID_KEYBOARD_TYPEMATIC_DELAY_DEFAULT  250

static const INDICATOR_LIST IndicatorList[HID_KEYBOARD_NUMBER_OF_INDICATORS] = {
        {0x3A, KEYBOARD_CAPS_LOCK_ON},
        {0x45, KEYBOARD_NUM_LOCK_ON},
        {0x46, KEYBOARD_SCROLL_LOCK_ON}
};

//
// Debugging levels
//

#define DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define DBG_SS_NOISE               0x00000001
#define DBG_SS_TRACE               0x00000002
#define DBG_SS_INFO                0x00000004
#define DBG_SS_ERROR               0x00000008

#define DBG_CALL_MASK              0x000000F0
#define DBG_CALL_NOISE             0x00000010
#define DBG_CALL_TRACE             0x00000020
#define DBG_CALL_INFO              0x00000040
#define DBG_CALL_ERROR             0x00000080

#define DBG_IOCTL_MASK             0x00000F00
#define DBG_IOCTL_NOISE            0x00000100
#define DBG_IOCTL_TRACE            0x00000200
#define DBG_IOCTL_INFO             0x00000400
#define DBG_IOCTL_ERROR            0x00000800

#define DBG_READ_MASK              0x0000F000
#define DBG_READ_NOISE             0x00001000
#define DBG_READ_TRACE             0x00002000
#define DBG_READ_INFO              0x00004000
#define DBG_READ_ERROR             0x00008000

#define DBG_CREATE_CLOSE_MASK      0x000F0000
#define DBG_CC_NOISE               0x00010000
#define DBG_CC_TRACE               0x00020000
#define DBG_CC_INFO                0x00040000
#define DBG_CC_ERROR               0x00080000

#define DBG_POWER_MASK             0x00F00000
#define DBG_POWER_NOISE            0x00100000
#define DBG_POWER_TRACE            0x00200000
#define DBG_POWER_INFO             0x00400000
#define DBG_POWER_ERROR            0x00800000

#define DBG_PNP_MASK               0x0F000000
#define DBG_PNP_NOISE              0x01000000
#define DBG_PNP_TRACE              0x02000000
#define DBG_PNP_INFO               0x04000000
#define DBG_PNP_ERROR              0x08000000

#define DBG_CANCEL_MASK            0xF0000000
#define DBG_CANCEL_NOISE           0x10000000
#define DBG_CANCEL_TRACE           0x20000000
#define DBG_CANCEL_INFO            0x40000000
#define DBG_CANCEL_ERROR           0x80000000

#define DEFAULT_DEBUG_OUTPUT_LEVEL 0x88888888

#if DBG

#define Print(_l_, _x_) \
            if (Globals.DebugLevel & (_l_)) { \
               DbgPrint ("KbdHid: "); \
               DbgPrint _x_; \
            }
#define TRAP() DbgBreakPoint()

#else
#define Print(_l_,_x_)
#define TRAP()
#endif

#define MAX(_A_,_B_) (((_A_) < (_B_)) ? (_B_) : (_A_))
#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))


//
// Define the keyboard scan code input states.
//
typedef enum _KEYBOARD_SCAN_STATE {
    Normal,
    GotE0,
    GotE1
} KEYBOARD_SCAN_STATE;

//
// Structures;
//
typedef struct _GLOBALS {
#if DBG
    //
    // The level of trace output sent to the debugger. See HidCli_KdPrint above.
    //
    ULONG               DebugLevel;
#endif

    //
    // Pointer to this driver's null-terminated registry path.
    //
    UNICODE_STRING      RegistryPath;

    //
    // Unit ID given to the keyboard class driver
    //
    ULONG               UnitId;

} GLOBALS;

extern GLOBALS Globals;


/*
 *  The UsageMappingList is used to keep track of mappings
 *  from incorrect to correct usage values (for broken keyboards).
 */
typedef struct UsageMappingList {
    USHORT sourceUsage, mappedUsage;
    struct UsageMappingList *next;
} UsageMappingList;


typedef struct _DEVICE_EXTENSION
{
    //
    // A back pointer to the device extension.
    //
    PDEVICE_OBJECT      Self;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT      TopOfStack;

    //
    // "THE PDO"  (ejected by Hidclass)
    //
    PDEVICE_OBJECT      PDO;

    //
    // Flag indicating permission to send callbacks to the mouse class driver.
    //
    LONG                EnableCount;

    //
    // Read interlock value to protect us from running out of stack space
    //
    ULONG               ReadInterlock;

    //
    // Event used to synchronize the completion of the read irp and the close irp
    //
    KEVENT              ReadCompleteEvent;

    //
    // Event used to indicate that a read irp has been sent and is now cancelable.
    //
    KEVENT              ReadSentEvent;

    //
    // Has the device been taken out from under us?
    // Has it been started?
    //
    BOOLEAN             Started;
    BOOLEAN             ShuttingDown;
    BOOLEAN             Initialized;
    USHORT              UnitId;
    
    // Make this look like mouhid.h
    ULONG               Reserved;


    //
    // Write and Feature Irps get passed straight down, but read Irps do not.
    // For this reason we keep around a read Irp, which we created.
    //
    PIRP                ReadIrp;

    //
    // A pointer to the HID extension.
    //
    struct _HID_EXTENSION * HidExtension;

    //
    // Flags indicating problems with the keyboard HID device (such as
    // a chattery keyboard). [DAN]
    //
    ULONG                ProblemFlags;

    //
    // A file pointer to be used for reading
    //
    PFILE_OBJECT        ReadFile;

    //
    // Pointer to the mouse class device object and callback routine
    // above us, Used as the first parameter and the  MouseClassCallback().
    // routine itself.
    //
    CONNECT_DATA        ConnectData;

    //
    // Remove Lock object to project IRP_MN_REMOVE_DEVICE
    //
    IO_REMOVE_LOCK      RemoveLock;

    //
    // A fast mutex to prevent Create from trouncing close, as one starts the
    // read loop and the other shuts it down.
    //
    FAST_MUTEX          CreateCloseMutex;

    //
    // An event to halt the deletion of a device until it is ready to go.
    //
    KEVENT              StartEvent;

    //
    // A place to store a single data packet so that we might hand it to the
    // keyclass driver.
    //
    KEYBOARD_INPUT_DATA InputData;
    KEYBOARD_SCAN_STATE ScanState;

    //
    // The attributes of this keyboard port [DAN]
    //
    KEYBOARD_ATTRIBUTES Attributes;

    //
    // The extended ID attributes of this keyboard port
    //
    KEYBOARD_ID_EX IdEx;

    //
    // The current state of the indicator lights [DAN]
    //
    KEYBOARD_INDICATOR_PARAMETERS   Indicators;

    //
    // The typematic parameters [DAN]
    //
    KEYBOARD_TYPEMATIC_PARAMETERS   Typematic;

    //
    // A timer DPC to do the autorepeat.
    //
    KDPC                AutoRepeatDPC;
    KTIMER              AutoRepeatTimer;
    LARGE_INTEGER       AutoRepeatDelay;
    LONG                AutoRepeatRate;

#if KEYBOARD_HW_CHATTERY_FIX
    // Added new DPC routine to schedule intermittent StartReads.
    KDPC                InitiateStartReadDPC;
    KTIMER              InitiateStartReadTimer;
    LARGE_INTEGER       InitiateStartReadDelay;
    BOOLEAN             InitiateStartReadUserNotified;
#endif

    //
    // An attachment point for the global list o devices
    //
    LIST_ENTRY          Link;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    UsageMappingList *usageMapping;
    KSPIN_LOCK usageMappingSpinLock;

} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

typedef struct _HID_EXTENSION {
    //
    // The preparsed data associated with this hid device.
    //
    PHIDP_PREPARSED_DATA Ppd;

    //
    // The capabilities of this hid device
    //
    HIDP_CAPS           Caps;

    //
    // The maximum number of usages that can be returned from a single read
    // report.
    ULONG               MaxUsages;

    //
    // A place to keep the modifier keys.  Used by the parser to translate from
    // usages to i8042 codes.
    //
    HIDP_KEYBOARD_MODIFIER_STATE ModifierState;

    //
    // We need a place to put the current packet, being retreived or sent for
    // input, output, or feature.
    // In addition to a place to put the usages (keys pressed) returned from the
    // keyboard, and a place to put the new strokes from the keyboard.
    //
    // Global buffers mean, of course, we cannot have overlapping read
    // requests.
    //
    // Pointers into the buffer contained below.
    PCHAR                InputBuffer;
    PUSAGE_AND_PAGE      PreviousUsageList;
    PUSAGE_AND_PAGE      CurrentUsageList;
    PUSAGE_AND_PAGE      BreakUsageList;
    PUSAGE_AND_PAGE      MakeUsageList;
    PUSAGE_AND_PAGE      OldMakeUsageList;
    PUSAGE_AND_PAGE      ScrapBreakUsageList;

    //
    // An MDL describing the below contained buffer.
    //
    PMDL                 InputMdl;

    //
    // A buffer to hold an Input packet, Output packet, the Maximum Usages
    // posible from a single hid packet, and
    //
    CHAR                 Buffer[];
} HID_EXTENSION, * PHID_EXTENSION;

//
// Prototypes
//
VOID
KbdHid_AutoRepeat (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    );

#if KEYBOARD_HW_CHATTERY_FIX
VOID
KbdHid_InitiateStartRead (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    );
#endif

NTSTATUS
KbdHid_StartRead (
    PDEVICE_EXTENSION   Data
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
KbdHid_AddDevice (
    IN PDRIVER_OBJECT    KbdHidDriver, // The kbd Driver object.
    IN PDEVICE_OBJECT    PDO
    );


NTSTATUS
KbdHid_Close (
   IN PDEVICE_OBJECT    DeviceObject,
   IN PIRP              Irp
   );

NTSTATUS
KbdHid_Create (
   IN PDEVICE_OBJECT    DeviceObject,
   IN PIRP              Irp
   );

NTSTATUS
KbdHid_SetLedIndicators (
    PDEVICE_EXTENSION               Data,
    PKEYBOARD_INDICATOR_PARAMETERS  Parameters,
    PIRP                            Irp
    );

NTSTATUS
KbdHid_CallHidClass(
    IN PDEVICE_EXTENSION    Data,
    IN ULONG          Ioctl,
    PVOID             InputBuffer,
    ULONG             InputBufferLength,
    PVOID             OutputBuffer,
    ULONG             OutputBufferLength
    );

BOOLEAN
KbdHid_InsertCodesIntoQueue (
   PDEVICE_EXTENSION    Data,
   PCHAR                NewCodes,
   ULONG                Length
   );

VOID
KbdHid_LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN NTSTATUS       ErrorCode,
   IN PWSTR          ErrorInsertionString OPTIONAL
   );

NTSTATUS
KbdHid_StartDevice (
    IN PDEVICE_EXTENSION    Data
    );

NTSTATUS
KbdHid_PnP (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
KbdHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
KbdHid_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
KbdHid_Unload(
   IN PDRIVER_OBJECT Driver
   );

NTSTATUS
KbdHid_IOCTL (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
KbdHid_Flush (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdHid_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdHid_PassThrough (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);

NTSTATUS
KbdHid_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
KbdHid_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
KbdHid_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
KbdHid_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
KbdHid_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

VOID LoadKeyboardUsageMappingList(PDEVICE_EXTENSION devExt);
VOID FreeKeyboardUsageMappingList(PDEVICE_EXTENSION devExt);
USHORT MapUsage(PDEVICE_EXTENSION devExt, USHORT kbdUsage);
NTSTATUS OpenSubkey(OUT PHANDLE Handle, IN HANDLE BaseHandle, IN PUNICODE_STRING KeyName, IN ACCESS_MASK DesiredAccess);
ULONG LAtoX(PWCHAR wHexString);

extern WMIGUIDREGINFO KbdHid_WmiGuidList[2];

#endif // _KBDHID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\kbdhid\read.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code for translating HID reports to keyboard
    reports.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <stdio.h>
#include "kbdhid.h"

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

#define KbdHid_RestartTimer(HidDevice)           \
    KeSetTimerEx (&(HidDevice)->AutoRepeatTimer, \
                   (HidDevice)->AutoRepeatDelay, \
                   (HidDevice)->AutoRepeatRate,  \
                  &(HidDevice)->AutoRepeatDPC);

#define KbdHid_CancelTimer(HidDevice) \
    KeCancelTimer (&(HidDevice)->AutoRepeatTimer);



NTSTATUS
KbdHid_ReadComplete (
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp,
    IN PDEVICE_EXTENSION    Data  // (PVOID Context)
    )
/*++
Routine Description:
   The read Completetion routine.

   The read came in.
   (a) Find the Buttons (usages) that are currently down
   (b) Diff to find the buttons that went up, and those that went down.
   (c) Convert the ups and downs to i8042 scan codes.
   (d) Swap the Previous Usage List and the Current Usage List.
   (d) If there are keys still down then we need to:
      (1) send another read to HidClass to wait for those keys to come back up
      (2) reset the autotimer.
--*/
{                                     
    ULONG           newUsages;
    NTSTATUS        status;
    PUSAGE_AND_PAGE usageList;
    PHID_EXTENSION  hid;
    KIRQL           oldirq;
    ULONG           i;
    PUSAGE_AND_PAGE usage;
    BOOLEAN         rollover;
    BOOLEAN         startRead;

    rollover = FALSE;
    status = Irp->IoStatus.Status;
    hid = Data->HidExtension;

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (KBDHID_START_READ !=
        InterlockedCompareExchange(&Data->ReadInterlock,
                                   KBDHID_IMMEDIATE_READ,
                                   KBDHID_START_READ));

    if (Data->EnableCount == 0) {
        goto SetEventAndBreak;
    }

    switch (status) {
    case STATUS_SUCCESS:
        //
        // Hopefully this means that the data found in the buffer of the
        // context contains a single hid packet read from the device.
        //
        ASSERT (Irp->IoStatus.Information == hid->Caps.InputReportByteLength);

        //
        // Find the current usages
        //

        newUsages = hid->MaxUsages;

        status = HidP_GetUsagesEx (
                     HidP_Input,
                     0, // Not interested in link collections
                     hid->CurrentUsageList,
                     &newUsages,
                     hid->Ppd,
                     hid->InputBuffer,
                     hid->Caps.InputReportByteLength);

        //
        // If the SysRq button is the only button down then
        // break.  This is to behave like the i8042prt driver, we clearly
        // have far less of an advantage since we have gone through MANY
        // drivers before we received the data, but let's check it anyway.
        //
        if ((1 == newUsages) &&
            (HID_USAGE_PAGE_KEYBOARD == hid->CurrentUsageList->UsagePage) &&
            (HID_USAGE_KEYBOARD_PRINT_SCREEN == hid->CurrentUsageList->Usage) &&
            (**((PUCHAR *)&KdDebuggerEnabled))) {
                DbgBreakPointWithStatus(DBG_STATUS_SYSRQ);
        }

        for (i = 0, usage = hid->CurrentUsageList;
             i < hid->MaxUsages;
             i++, usage++) {

            if (HID_USAGE_PAGE_KEYBOARD != hid->CurrentUsageList->UsagePage) {
                continue;
            }

            //
            // If this is a broken keyboard, map the usage
            // to the correct value.
            //
            usage->Usage = MapUsage(Data, usage->Usage);

            //
            // If this packet contains the Rollover key then the packet should be
            // ignored.
            //
            if (HID_USAGE_KEYBOARD_ROLLOVER == usage->Usage) {
                rollover = TRUE;
                break;
            }
            if (0 == usage->Usage) {
                break;
            }
        }

        if (!rollover) {
            USAGE_AND_PAGE  zero = {0,0};
            
            //
            // First, check whether the keyboard is repeating keys in hardware.
            // If it is, then we'll ignore this package. To do this, diff the 
            // current and the previous usages. If the resulting make and break
            // usage lists have nothing in them, then ignore this package.
            //
            HidP_UsageAndPageListDifference (hid->PreviousUsageList,
                                             hid->CurrentUsageList,
                                             hid->ScrapBreakUsageList,
                                             hid->OldMakeUsageList,
                                             hid->MaxUsages);

            if (HidP_IsSameUsageAndPage(hid->OldMakeUsageList[0], zero) &&
                HidP_IsSameUsageAndPage(hid->ScrapBreakUsageList[0], zero)) {
                //
                // No new keys. The keyboard is trying 
                // to perform repeating in hardware.
                //
                goto Kbdhid_ReadComplete_Done;
            }

            //
            // Save the make usages temporarily
            //
            RtlCopyMemory(hid->OldMakeUsageList,
                          hid->MakeUsageList,
                          hid->MaxUsages * sizeof(USAGE_AND_PAGE));

            //
            // Diff the current and the previous usages
            //
            status = HidP_UsageAndPageListDifference (hid->PreviousUsageList,
                                                      hid->CurrentUsageList,
                                                      hid->BreakUsageList,
                                                      hid->MakeUsageList,
                                                      hid->MaxUsages);

            //
            // Convert the ups into scan codes and add to the ring buffer.
            // Convert the downs.
            //
            HidP_TranslateUsageAndPagesToI8042ScanCodes (hid->BreakUsageList,
                                                         hid->MaxUsages,
                                                         HidP_Keyboard_Break,
                                                         &hid->ModifierState,
                                                         KbdHid_InsertCodesIntoQueue,
                                                         Data);

            if (!HidP_IsSameUsageAndPage(hid->CurrentUsageList[0], zero) &&
                HidP_IsSameUsageAndPage(hid->MakeUsageList[0], zero)) {
                //
                // There are no new downs, but there may be some old ones
                // kicking around. We don't want to get rid of keys that are
                // still repeating.
                //
                HidP_UsageAndPageListDifference (hid->BreakUsageList,
                                                 hid->OldMakeUsageList,
                                                 hid->ScrapBreakUsageList,
                                                 hid->MakeUsageList,
                                                 hid->MaxUsages);
            } else {
                //
                // Only refresh the downs when there are new ones to add
                //
                HidP_TranslateUsageAndPagesToI8042ScanCodes (hid->MakeUsageList,
                                                             hid->MaxUsages,
                                                             HidP_Keyboard_Make,
                                                             &hid->ModifierState,
                                                             KbdHid_InsertCodesIntoQueue,
                                                             Data);
            }

            //
            // Swap previous with next.
            //
            usageList = hid->PreviousUsageList;
            hid->PreviousUsageList = hid->CurrentUsageList;
            hid->CurrentUsageList = usageList;

#if KEYBOARD_HW_CHATTERY_FIX
            //
            // [DAN]
            // Chattery Keyboard H/W Workaround -
            //    Only call StartRead() if this was a meaningful packet  (ie. it
            //    had a make or a break), otherwise "schedule" the StartRead for
            //    a later time.  Notify tester that this is a chattery keyboard.
            //
            if ((0 < newUsages) &&
                (0 == hid->BreakUsageList->Usage) &&
                (0 == hid->MakeUsageList->Usage)) {

                if (FALSE == Data->InitiateStartReadUserNotified) {
                    Data->InitiateStartReadUserNotified = TRUE;
                    DbgPrint("*****\n***** "
                             "CHATTERY   KEYBOARD : "
                             "Keyboard is sending useless reports.  "
                             "Tell 'em to fix it.\n*****\n"
                             );

                    Data->ProblemFlags |= PROBLEM_CHATTERY_KEYBOARD;

                    //
                    // log the problem.
                    //
                   
                    KbdHid_LogError(Data->Self->DriverObject,
                                    KBDHID_CHATTERY_KEYBOARD,
                                    NULL);
                }

                if (!Data->ShuttingDown &&
                    startRead) {
                    KeSetTimerEx(&Data->InitiateStartReadTimer,
                                 Data->InitiateStartReadDelay,
                                 0,
                                 &Data->InitiateStartReadDPC);
                }
                startRead = FALSE;
                IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);

                KbdHid_CancelTimer (Data);

                break;
            } else
#endif

            if (0 < newUsages) {
                //
                // Reset the auto repeat timer.
                //
                KbdHid_RestartTimer (Data);
            } else {
                KbdHid_CancelTimer (Data);
            }
        }

        //
        // Get the next packet from Hid Class.
        // Hid class has its own buffer so we do not need ping pong irps.
        //
        break;

    case STATUS_PRIVILEGE_NOT_HELD:
        //
        // The create didn't succeed
        //
    case STATUS_CANCELLED:
        //
        // The read IRP was cancelled.  Do not send any more read IRPs.
        //
    case STATUS_DELETE_PENDING:
    case STATUS_DEVICE_NOT_CONNECTED:
        //
        // The HID class device object is being deleted.  We will soon
        // receive Plug 'n Play notification of this device's removal,
        // if we have not received it already.
        //
SetEventAndBreak:
        if (startRead) {
            KeSetEvent (&Data->ReadCompleteEvent, 0, FALSE);
            IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
            startRead = FALSE;
        }
        break;

    default:
        //
        // We don't expect any other error codes.
        //
        TRAP();

   }

Kbdhid_ReadComplete_Done:
    //
    // Initiate the next read request to the HID class driver.
    //
    if (startRead) {
        Print(DBG_READ_TRACE, ("calling StartRead directly\n"));
        KbdHid_StartRead (Data);
    } else {
        Print(DBG_READ_TRACE, ("StartRead will loop\n"));
    }
   
    return STATUS_MORE_PROCESSING_REQUIRED;
#undef hidDevice
}

BOOLEAN
KbdHid_InsertCodesIntoQueue (
   PDEVICE_EXTENSION    Data,
   PCHAR                NewCodes,
   ULONG                Length
   )
/*++

[DAN]

RoutineDescription:
    Given a pointer to some i8042 Codes and the length of those codes.
    send those codes to KbdClass via KbdClassCallback.

    This routine is transmits the supplied I8042 scancodes to the keyboard
    class driver via a callback routine. This function was supplied in our
    call to HidP_TranslateUsagesToI8042ScanCodes.

Arguments:

    HidDevice - Pointer to the device context.

    NewCodes  - Pointer to the I8042 scancodes.

    Length    - Number of I8042 scancodes.

Return Value:

    Always returns TRUE.

--*/
{
    KIRQL                 oldIrql;
    ULONG                 index;
    PKEYBOARD_INPUT_DATA  input;
    PHID_EXTENSION        hid;
    ULONG                 inputDataConsumed;
    UCHAR                 scanCode;
    KEYBOARD_SCAN_STATE * scanState;

    hid         = Data->HidExtension;
    input       = &Data->InputData;
    scanState   = &Data->ScanState;

    for (index = 0; index < Length; index++, NewCodes++) {
        scanCode = *NewCodes;

        if (scanCode == (UCHAR) 0xFF) {
            Print (DBG_READ_TRACE, ("OVERRUN\n"));
            input->MakeCode = KEYBOARD_OVERRUN_MAKE_CODE;
            input->Flags = 0;
            *scanState = Normal;
        } else {

            switch (*scanState) {
            case Normal:

                if (scanCode == (UCHAR) 0xE0) {
                    input->Flags |= KEY_E0;
                    *scanState = GotE0;
                    break;
                } else if (scanCode == (UCHAR) 0xE1) {
                    input->Flags |= KEY_E1;
                    *scanState = GotE1;
                    break;
                }

                //
                // Fall through to the GotE0/GotE1 case for the rest of the
                // Normal case.
                //

            case GotE0:
            case GotE1:

                if (scanCode > 0x7F) {
                    //
                    // Got a break code.  Strip the high bit off
                    // to get the associated make code and set flags
                    // to indicate a break code.
                    //
                    input->MakeCode = scanCode & 0x7F;
                    input->Flags |= KEY_BREAK;
                } else {
                    //
                    // Got a make code.
                    //
                    input->MakeCode = scanCode;
                }

                //
                // Reset the state to Normal.
                //
                *scanState = Normal;
                break;

            default:

                ASSERT(FALSE);
                break;
            }

            //
            // In the Normal state, if the keyboard device is enabled,
            // add the data to the InputData queue and queue the ISR DPC.
            //
            if (*scanState == Normal) {

                if (Data->EnableCount) {

                    //
                    // Leave the remaining mouse input data fields as they were
                    // initialized (on the device's creation).  This includes:
                    //  o  UnitID
                    //  o  ExtraInformation
                    //
                    // Now send the data up to the keyboard class driver via
                    // our callback.
                    //
                    //
                    // Synchronization issue: it's not a big deal if .Enabled
                    // is set FALSE after the condition above, but before the
                    // callback below, so long as the .KbdClassCallback field
                    // is not nulled. This is guaranteed since the disconnect
                    // IOCTL is not implemented yet.
                    //
                    // Keyboard class callback assumes we are running at
                    // DISPATCH level, however this IoCompletion routine
                    // can be running <= DISPATCH. Raise the IRQL before
                    // calling the callback. [13.1]
                    //
                    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

                    //
                    // Call the callback.
                    //
                    (*(PSERVICE_CALLBACK_ROUTINE)
                     Data->ConnectData.ClassService) (
                            Data->ConnectData.ClassDeviceObject,
                            input,
                            input + 1,  // (one data element)
                            &inputDataConsumed);

                    //
                    // Restore the previous IRQL right away.
                    //
                    KeLowerIrql(oldIrql);

                    ASSERT (1 == inputDataConsumed);
                }

                //
                // Reset the input state.
                //
                input->Flags = 0;
            }
        }
    }

    return TRUE;
}

NTSTATUS
KbdHid_StartRead (
    PDEVICE_EXTENSION   Data
    )
/*++

Routine Description:

    Initiates a read to the HID class driver.

    Note that the routine does not verify that the device context is in the
    OperationPending state, but simply assumes it.

    Note the IoCount must be incremented before entering into this read loop.

Arguments:

    HidDeviceContext - Device context structure describing the HID device.

Return Value:

    NTSTATUS result code from IoCallDriver().

--*/
{
    PIRP                irp = Data->ReadIrp;
    NTSTATUS            status = irp->IoStatus.Status;
    PIO_STACK_LOCATION  stack;
    PHID_EXTENSION      hid;
    LONG                oldInterlock;

    Print (DBG_READ_TRACE, ("Start Read: Ente\n"));

    hid = Data->HidExtension;

    //
    // start this read.
    //

    while (1) {
        oldInterlock = InterlockedExchange(&Data->ReadInterlock,
                                           KBDHID_START_READ);
    
        //
        // END_READ should be the only value here!!!  If not, the state machine
        // of the interlock has been broken
        //
        ASSERT(oldInterlock == KBDHID_END_READ);
    
        if (NT_SUCCESS(status)) {
            //
            // Set the stack location for the Hid stack.
            // Remember to get the file pointer correct.
            // NOTE: we do not have any of the cool thread stuff set.
            //       therefore we need to make sure that we cut this IRP off
            //       at the knees when it returns. (STATUS_MORE_PROCESSING_REQUIRED)
            //
            // Note also that Hid class does direct IO.
            //
            IoReuseIrp (irp, STATUS_SUCCESS);
        
            irp->MdlAddress = hid->InputMdl;
        
            ASSERT (NULL != Data->ReadFile);
        
            stack = IoGetNextIrpStackLocation (irp);
            stack->Parameters.Read.Length = hid->Caps.InputReportByteLength;
            stack->Parameters.Read.Key = 0;
            stack->Parameters.Read.ByteOffset.QuadPart = 0;
            stack->MajorFunction = IRP_MJ_READ;
            stack->FileObject = Data->ReadFile;
        
            //
            // Hook a completion routine for when the device completes.
            //
        
            IoSetCompletionRoutine (irp,
                                    KbdHid_ReadComplete,
                                    Data,
                                    TRUE,
                                    TRUE,
                                    TRUE);
        
            //
            // Unset the fact that the read has been sent. Synchoronizing 
            // with remove and close code. Remove portion (data->Shuttingdown) 
            // only really relevant on 9X.
            //
            KeResetEvent(&Data->ReadSentEvent);
        
            if (!Data->EnableCount || Data->ShuttingDown) {
                IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
                status = Data->ShuttingDown ? STATUS_DELETE_PENDING : STATUS_UNSUCCESSFUL;
                KeSetEvent (&Data->ReadSentEvent, 0, FALSE);
                break;
            } else {
                status = IoCallDriver (Data->TopOfStack, irp);
            }
            KeSetEvent (&Data->ReadSentEvent, 0, FALSE);
            
            if (KBDHID_IMMEDIATE_READ != InterlockedExchange(&Data->ReadInterlock,
                                                             KBDHID_END_READ)) {
                //
                // The read is asynch, will call SerialMouseStartRead from the
                // completion routine
                //
                Print(DBG_READ_TRACE, ("read is pending\n"));
                break;
            } else {
                //
                // The read was synchronous (probably bytes in the buffer).  The
                // completion routine will not call SerialMouseStartRead, so we 
                // just loop here.  This is to prevent us from running out of stack
                // space if always call StartRead from the completion routine
                //
                Print(DBG_READ_TRACE, ("read is looping\n"));
            }
        } else if (status == STATUS_PRIVILEGE_NOT_HELD ||
                   status == STATUS_CANCELLED ||
                   status == STATUS_DELETE_PENDING ||
                   status == STATUS_DEVICE_NOT_CONNECTED) {
            //
            // The HID class device object is being deleted.  We will soon
            // receive Plug 'n Play notification of this device's removal,
            // if we have not received it already.
            //
            KeSetEvent (&Data->ReadCompleteEvent, 0, FALSE);
            IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
            break;
        } else {
            //
            // BUGBUG what shall we do with errors?
            //
            //
            // Panic
            //
            TRAP();
        }
    }

    return status;
}


VOID
KbdHid_AutoRepeat (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    )
/*++
Routine Description:
   The auto repeat time has gone off.  We should therefore duplicate the
   keystrokes that are currently down, by signalling them all going up,
   and then signaling them all going down.
   Afterwards we need to reset the timer to the repeat rate.

Arguments:
   DeferredContext is set to the HID_DEVICE structure.

--*/
{
    PUSAGE_AND_PAGE    previous;

    previous = Data->HidExtension->MakeUsageList; // PreviousUsageList;
    //
    // We really do not protect the previous list
    // But in order for the Previous list to be touched (written to),
    // the completion routine must fire, swap current with previous,
    // and the HIDCLASS must start writing on the list.
    // So we don't worry about this for now.
    //

    //
    // simulate a repeated key-down
    //
    HidP_TranslateUsageAndPagesToI8042ScanCodes (
                previous,
                Data->HidExtension->MaxUsages,
                HidP_Keyboard_Make,
                &Data->HidExtension->ModifierState,
                KbdHid_InsertCodesIntoQueue,
                Data);
}


#if KEYBOARD_HW_CHATTERY_FIX  // [DAN]

VOID
KbdHid_InitiateStartRead (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    )
{
    IoAcquireRemoveLock (&Data->RemoveLock, Data->ReadIrp);
    KbdHid_StartRead(Data);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\kbdhid\wmi.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    WMI.C

Abstract:

    This module contains the init code for the i8042 to hid converter.

Environment:

    Kernel mode

Revision History:

    Jan-98 : created by Kenneth D. Ray

--*/


#include <initguid.h>
#include "kbdhid.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,KbdHid_SystemControl)
#pragma alloc_text(PAGE,KbdHid_SetWmiDataItem)
#pragma alloc_text(PAGE,KbdHid_SetWmiDataBlock)
#pragma alloc_text(PAGE,KbdHid_QueryWmiDataBlock)
#pragma alloc_text(PAGE,KbdHid_QueryWmiRegInfo)
#endif

#define WMI_PORT_DRIVER_INFORMATION 0
#define WMI_PORT_EXTENDED_ID        1

WMIGUIDREGINFO KbdHid_WmiGuidList[2] =
{
    {
        &MSKeyboard_PortInformation_GUID, 1, 0 // Keyboard Port driver information
    },
    {
        &MSKeyboard_ExtendedID_GUID, 1, 0      // Keyboard extended ID information
    },
};

NTSTATUS
KbdHid_SystemControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }        
    }
    
    return(status);
}

//
// WMI System Call back functions
//

NTSTATUS
KbdHid_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION    deviceExtension;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:
    case WMI_PORT_EXTENDED_ID:

        status = STATUS_WMI_READ_ONLY;
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KbdHid_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:
    case WMI_PORT_EXTENDED_ID:

        status = STATUS_WMI_READ_ONLY;
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
KbdHid_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION           deviceExtension;
    KEYBOARD_PORT_WMI_STD_DATA  data;
    NTSTATUS    status;
    ULONG       size = 0;

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:

        size = sizeof (data);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&data,
                      size
                      );
                     
        data.ConnectorType = KEYBOARD_PORT_WMI_STD_USB;
        data.DataQueueSize = deviceExtension->Attributes.InputDataQueueLength;
        data.ErrorCount = 0;
        data.FunctionKeys = deviceExtension->Attributes.NumberOfFunctionKeys;
        data.Indicators = deviceExtension->Attributes.NumberOfIndicators;

        * (PKEYBOARD_PORT_WMI_STD_DATA) Buffer = data;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;

        break;

    case WMI_PORT_EXTENDED_ID:
        size = sizeof(KEYBOARD_ID_EX);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        *(PKEYBOARD_ID_EX) Buffer = deviceExtension->IdEx;

        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KbdHid_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
        
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\mouhid\read.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code for translating HID input reports to mouse
    reports, and read initiation and completion code for requests sent to the
    HID class driver.  This module is part of the HID Mouse Filter Driver.

Environment:

    Kernel mode only.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian

--*/

#include "mouhid.h"


//
// Private definitions.
//
#define MAX_MOUSE_BUTTONS 5

USHORT HidP_TranslateUsageToUpFlag[MAX_MOUSE_BUTTONS+1] = { 0,
                                         MOUSE_BUTTON_1_UP,
                                         MOUSE_BUTTON_2_UP,
                                         MOUSE_BUTTON_3_UP,
                                         MOUSE_BUTTON_4_UP,
                                         MOUSE_BUTTON_5_UP };

USHORT HidP_TranslateUsageToDownFlag[MAX_MOUSE_BUTTONS+1] = { 0,
                                         MOUSE_BUTTON_1_DOWN,
                                         MOUSE_BUTTON_2_DOWN,
                                         MOUSE_BUTTON_3_DOWN,
                                         MOUSE_BUTTON_4_DOWN,
                                         MOUSE_BUTTON_5_DOWN };

NTSTATUS
MouHid_ReadComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    Data  // (PVOID Context)
    )
/*++

Routine Description:

    This routine is the read IRP completion routine.  It is called when the
    HIDCLASS driver satisfies (or rejects) the IRP request we sent it.  The
    read report is analysed, and a MOUSE_INPUT_DATA structure is built
    and sent to the mouse class driver via a callback routine.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

    Context - Pointer to the device context structure describing the HID device.


Return Value:

    NTSTATUS result code.

--*/
{
    LONG            axisMotion;
    ULONG           i;
    ULONG           inputDataConsumed;
    PHID_EXTENSION  hid;
    ULONG           numUsages;
    KIRQL           oldIrql;
    BOOLEAN         returnToIdleState  = FALSE;
    NTSTATUS        status;
    PUSAGE          usageList;
    BOOLEAN         updateProblemFlags = FALSE;
    ULONGLONG       scratch;
    BOOLEAN         startRead;

    Print (DBG_READ_TRACE, ("ReadComplete: Enter."));

    //
    // Obtain the current status of the IRP.
    //
    status = Irp->IoStatus.Status;

    //
    // Get a pointer to the device extension.
    //
    hid = Data->HidExtension;

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (MOUHID_START_READ !=
        InterlockedCompareExchange(&Data->ReadInterlock,
                                   MOUHID_IMMEDIATE_READ,
                                   MOUHID_START_READ));

    if (Data->EnableCount == 0) {
        goto SetEventAndBreak;
    }

    //
    // Determine if the IRP request was successful.
    //
    switch (status) {
    case STATUS_SUCCESS:
        //
        // The buffer of the context now contains a single HID packet read
        // from the device.  Verify this.
        //
        ASSERT (Irp->IoStatus.Information == hid->Caps.InputReportByteLength);

        //
        // Clear previous button state (data / flags).
        //
        Data->InputData.ButtonData  = 0;
        Data->InputData.ButtonFlags = 0;

        //
        // Clear last X,Y motion, in case a call to Hidp_GetUsageValue or
        // Hidp_GetScaledUsageValue fails.
        //
        Data->InputData.LastX = 0;
        Data->InputData.LastY = 0;

        //
        // Obtain the current button usages.
        //
        numUsages = hid->MaxUsages;

        if (NT_SUCCESS(HidP_GetUsages (
                           HidP_Input,
                           HID_USAGE_PAGE_BUTTON,
                           0,          // link collection irrelevant
                           hid->CurrentUsageList,
                           &numUsages, // max usages in, num usages out
                           hid->Ppd,
                           hid->InputBuffer,
                           hid->Caps.InputReportByteLength))) {
            //
            // Determine the differences between the current and the previous
            // usages.  The very first previous usage list buffer is properly
            // initialized at creation (all zeros).
            //
            if (NT_SUCCESS(HidP_UsageListDifference (hid->PreviousUsageList,
                                                     hid->CurrentUsageList,
                                                     hid->BreakUsageList,
                                                     hid->MakeUsageList,
                                                     hid->MaxUsages))) {
                //
                // Determine which buttons went down and set the appropriate
                // flags in the mouse report.
                //
                usageList = hid->MakeUsageList;
                for ( i = 0;
                      i < hid->MaxUsages && *usageList;
                      i++, usageList++ ) {

                    if (*usageList <= MAX_MOUSE_BUTTONS) {
                        Data->InputData.ButtonFlags |=
                            HidP_TranslateUsageToDownFlag[*usageList];
                    }
                    //
                    // else there are more buttons on this mouse then we have
                    // translation flags for the Raw input user thread
                    //
                }

                //
                // Determine which buttons went up and set the appropriate
                // flags in the mouse report.
                //
                usageList = hid->BreakUsageList;
                for ( i = 0;
                      i < hid->MaxUsages && *usageList;
                      i++, usageList++ ) {

                    if (*usageList <= MAX_MOUSE_BUTTONS) {
                        Data->InputData.ButtonFlags |=
                                     HidP_TranslateUsageToUpFlag[*usageList];
                    }
                }

                //
                // Swap the previous usage list pointer with the current.
                //
                usageList = hid->PreviousUsageList;
                hid->PreviousUsageList = hid->CurrentUsageList;
                hid->CurrentUsageList  = usageList;
            }
        }

        //
        // Type of processing for X,Y,Z values depends on whether these values
        // have a bad physical minimum or maximum. If they do, we use routines
        // that do not depend on physical min/max.
        //

        //
        // Determine the current X position and save it in the mouse report.
        //
        if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_X)) {
            status = HidP_GetScaledUsageValue(
                         HidP_Input,
                         HID_USAGE_PAGE_GENERIC,
                         0,
                         HID_USAGE_GENERIC_X,
                         &Data->InputData.LastX,
                         hid->Ppd,
                         hid->InputBuffer,
                         hid->Caps.InputReportByteLength);

            //
            // Bad physical minimum/maximum detected, set flag so that we
            // process usage value differently in the future.
            //
            if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
                Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_X;
                updateProblemFlags = TRUE;
                //
                // Correct the MaxX value;
                //
                hid->MaxX = (1 << (hid->BitSize.X - 1)) - 1;
            }
        }

        if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_X) {

            axisMotion = 0;

            HidP_GetUsageValue(HidP_Input,
                               HID_USAGE_PAGE_GENERIC,
                               0,
                               HID_USAGE_GENERIC_X,
                               (PULONG) &axisMotion,
                               hid->Ppd,
                               hid->InputBuffer,
                               hid->Caps.InputReportByteLength);

            // Sign extend the value manually.
            Data->InputData.LastX
               = axisMotion | ((axisMotion & (hid->MaxX + 1)) ? (~hid->MaxX)
                                                              : 0);
        }

        if (hid->IsAbsolute && hid->MaxX) {
            //
            // We need to scale this value from the physical max
            //
            scratch = ((LONGLONG)(Data->InputData.LastX) *
                       MOUHID_RIUT_ABSOLUTE_POINTER_MAX) /
                       hid->MaxX;
            Data->InputData.LastX = (LONG) scratch;
        }

        //
        // Determine the current Y position and save it in the mouse report.
        //
        if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Y)) {
           status = HidP_GetScaledUsageValue(
                     HidP_Input,
                     HID_USAGE_PAGE_GENERIC,
                     0,
                     HID_USAGE_GENERIC_Y,
                     &Data->InputData.LastY,
                     hid->Ppd,
                     hid->InputBuffer,
                     hid->Caps.InputReportByteLength);
           //
           // Bad physical minimum/maximum detected, set flag so that we
           // process usage value differently in the future.
           //
           if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
               Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_Y;
               updateProblemFlags = TRUE;
               //
               // Correct the MaxY value;
               //
               hid->MaxY = (1 << (hid->BitSize.Y - 1)) - 1;
           }
        }

        if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Y) {

           axisMotion = 0;

           HidP_GetUsageValue(HidP_Input,
                              HID_USAGE_PAGE_GENERIC,
                              0,
                              HID_USAGE_GENERIC_Y,
                              &axisMotion,
                              hid->Ppd,
                              hid->InputBuffer,
                              hid->Caps.InputReportByteLength);

           // Sign extend the value manually.
           Data->InputData.LastY
              = axisMotion | ((axisMotion & (hid->MaxY + 1)) ? (~hid->MaxY)
                                                             :  0);
        }

        if (hid->IsAbsolute) {
            //
            // We need to scale this value from the physical max
            //
            scratch = ((LONGLONG)(Data->InputData.LastY) *
                       MOUHID_RIUT_ABSOLUTE_POINTER_MAX) /
                       hid->MaxY;

            Data->InputData.LastY = (LONG) scratch;
        }

        //
        // Determine the current Z position (wheel).
        //
        if (FALSE == hid->HasNoWheelUsage) {

            axisMotion = 0;

            if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z)) {
               status = HidP_GetScaledUsageValue(
                         HidP_Input,
                         HID_USAGE_PAGE_GENERIC,
                         0,
                         HID_USAGE_GENERIC_WHEEL,
                         &axisMotion,
                         hid->Ppd,
                         hid->InputBuffer,
                         hid->Caps.InputReportByteLength);

               //
               // If wheel usage not detected, set flag so that we do not
               // process wheel usages in the future.
               //
               if (HIDP_STATUS_USAGE_NOT_FOUND == status) {
                   hid->HasNoWheelUsage = TRUE;
               }

               //
               // If bad physical minimum/maximum detected, set flag so that
               // we process usage value differently in the future.
               //
               if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
                   Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_Z;
                   updateProblemFlags = TRUE;
               }
            }

            if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z) {
                HidP_GetUsageValue(HidP_Input,
                                   HID_USAGE_PAGE_GENERIC,
                                   0,
                                   HID_USAGE_GENERIC_WHEEL,
                                   &axisMotion,
                                   hid->Ppd,
                                   hid->InputBuffer,
                                   hid->Caps.InputReportByteLength);

                // Sign extend the value manually.
                axisMotion
                    = axisMotion
                    | (axisMotion & (1 << (hid->BitSize.Z - 1))
                       ? (0L - (1 << (hid->BitSize.Z - 1)))
                       : 0);
            }

            //
            // Encode the Z position information into the MOUSE_INPUT_DATA
            // structure same way that the Magellan wheel mouse does.
            //
            if (0 == axisMotion) {
                Data->InputData.ButtonData = 0;
            } else {

                //
                // Unlike PS/2 wheel mice, we don't need to sign flip the wheel
                // data (unless it is an early prototype non spec compliant
                // device)
                //
                axisMotion *= Data->WheelScalingFactor; 
                Data->InputData.ButtonData = Data->FlipFlop ? 
                    (USHORT) -axisMotion : (USHORT) axisMotion;
                Data->InputData.ButtonFlags |= MOUSE_WHEEL;
            }

        } else if (FALSE == hid->HasNoZUsage) {
            //
            // If there is no Wheel usage then there might be a "z" usage on
            // this mouse.  Check that.
            //

            axisMotion = 0;

            if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z)) {
               status = HidP_GetScaledUsageValue(
                         HidP_Input,
                         HID_USAGE_PAGE_GENERIC,
                         0,
                         HID_USAGE_GENERIC_Z,
                         &axisMotion,
                         hid->Ppd,
                         hid->InputBuffer,
                         hid->Caps.InputReportByteLength);

               //
               // If wheel usage not detected, set flag so that we do not
               // process wheel usages in the future.
               //
               if (HIDP_STATUS_USAGE_NOT_FOUND == status) {
                   hid->HasNoZUsage = TRUE;
               }

               //
               // If bad physical minimum/maximum detected, set flag so that
               // we process usage value differently in the future.
               //
               if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
                   Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_Z;
                   updateProblemFlags = TRUE;
               }
            }

            if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z) {
                HidP_GetUsageValue(HidP_Input,
                                   HID_USAGE_PAGE_GENERIC,
                                   0,
                                   HID_USAGE_GENERIC_Z,
                                   &axisMotion,
                                   hid->Ppd,
                                   hid->InputBuffer,
                                   hid->Caps.InputReportByteLength);

                // Sign extend the value manually.
                axisMotion
                    = axisMotion
                    | (axisMotion & (1 << (hid->BitSize.Z - 1))
                       ? (0L - (1 << (hid->BitSize.Z - 1)))
                       : 0);
            }

            //
            // Encode the Z position information into the MOUSE_INPUT_DATA
            // structure the same way that the Magellan wheel mouse does.
            //
            if (0 == axisMotion) {
                Data->InputData.ButtonData = 0;
            } else {

                //
                // Unlike PS/2 wheel mice, we don't need to sign flip the wheel
                // data (unless it is an early prototype non spec compliant
                // device)
                //
                axisMotion *= Data->WheelScalingFactor; 
                Data->InputData.ButtonData = Data->FlipFlop ? 
                    (USHORT) -axisMotion : (USHORT) axisMotion;
                Data->InputData.ButtonFlags |= MOUSE_WHEEL;
            }

        }

        //
        // Leave the remaining mouse input data fields as they were
        // initialized (on the device's creation).  This includes:
        //  o  UnitID       o  RawButtons
        //  o  Flags        o  ExtraInformation
        //
        // Now send the data up to the mouse class driver via our callback.
        //
        if (Data->EnableCount)
        {
            //
            // Synchronization issue -  it's not a big deal if .Enabled is set
            // FALSE after the condition above, but before the callback below,
            // so long as the .MouClassCallback field is not nulled.   This is
            // guaranteed since the disconnect IOCTL is not implemented yet.
            //
            // Mouse class callback assumes we are running at DISPATCH level,
            // however this IoCompletion routine can be running <= DISPATCH.
            // Raise the IRQL before calling the callback. [13.1]
            //
            KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

            //
            // Call the callback.
            //
            (*(PSERVICE_CALLBACK_ROUTINE)
             Data->ConnectData.ClassService) (
                            Data->ConnectData.ClassDeviceObject,
                            &Data->InputData,
                            &Data->InputData + 1,  // (one data element)
                            &inputDataConsumed);

            //
            // Restore the previous IRQL right away.
            //
            KeLowerIrql(oldIrql);

            ASSERT (1 == inputDataConsumed);
        }

        //
        // Update ProblemFlags value in registry and log error on bad physical
        // minimum/maximum.
        //
        if (updateProblemFlags) {

            MouHid_LogError(Data->Self->DriverObject,
                            MOUHID_INVALID_PHYSICAL_MIN_MAX,
                            NULL);
        }
        
        //
        // If MouHid_StartRead() fails,  it will be handled appropriately
        // in the completion routine.  Exit this routine without touching
        // HidDeviceContext.
        //

        break;

    case STATUS_PRIVILEGE_NOT_HELD:
        //
        // The create didn't succeed
        //
    case STATUS_CANCELLED:
        //
        // The read IRP was cancelled.  Do not send any more read IRPs.
        //

    case STATUS_DELETE_PENDING:
    case STATUS_DEVICE_NOT_CONNECTED:
        //
        // The HID class device object is being deleted.  We will soon
        // receive Plug 'n Play notification of this device's removal,
        // if we have not received it already.
        //
SetEventAndBreak:
        KeSetEvent (&Data->ReadCompleteEvent, 0, FALSE);
        IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
        startRead = FALSE;
        break;

    default:
        //
        // We don't expect any other error codes.
        //
        TRAP();

    }

    //
    // Initiate the next read request to the HID class driver.
    //
    if (startRead) {
        Print(DBG_READ_TRACE, ("calling StartRead directly\n"));
        MouHid_StartRead (Data);
    } else {
        Print(DBG_READ_TRACE, ("StartRead will loop\n"));
    }
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MouHid_StartRead (
    IN PDEVICE_EXTENSION Data
    )
/*++

Routine Description:

    Initiates a read to the HID class driver.

    Note that the routine does not verify that the device context is in the
    OperationPending state, but simply assumes it.

    Note the IoCount must be incremented before entering into this read loop.
    
Arguments:

    HidDeviceContext - Device context structure describing the HID device.

Return Value:

    NTSTATUS result code from IoCallDriver().

--*/
{
    PIRP                irp;
    NTSTATUS           status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    PHID_EXTENSION      hid;
    LONG                oldInterlock;

    Print (DBG_READ_TRACE, ("Start Read: Ente\n"));

    hid = Data->HidExtension;

    //
    // start this read.
    //

    irp = Data->ReadIrp;

    while (1) {
        oldInterlock = InterlockedExchange(&Data->ReadInterlock,
                                           MOUHID_START_READ);
    
        //
        // END_READ should be the only value here!!!  If not, the state machine
        // of the interlock has been broken
        //
        ASSERT(oldInterlock == MOUHID_END_READ);
    
        //
        // Set the stack location for the Hid stack.
        // Remember to get the file pointer correct.
        // NOTE: we do not have any of the cool thread stuff set.
        //       therefore we need to make sure that we cut this IRP off
        //       at the knees when it returns. (STATUS_MORE_PROCESSING_REQUIRED)
        //
        // Note also that Hid class does direct IO.
        //
    
        IoReuseIrp (irp, STATUS_SUCCESS);
    
        irp->MdlAddress = hid->InputMdl;
    
        ASSERT (NULL != Data->ReadFile);
    
        stack = IoGetNextIrpStackLocation (irp);
        stack->Parameters.Read.Length = hid->Caps.InputReportByteLength;
        stack->Parameters.Read.Key = 0;
        stack->Parameters.Read.ByteOffset.QuadPart = 0;
        stack->MajorFunction = IRP_MJ_READ;
        stack->FileObject = Data->ReadFile;
        
        //
        // Hook a completion routine for when the device completes.
        //
        IoSetCompletionRoutine (irp,
                                MouHid_ReadComplete,
                                Data,
                                TRUE,
                                TRUE,
                                TRUE);
        
        //
        // Unset the fact that the read has been sent. Synchoronizing 
        // with remove and close code. Remove portion (data->Shuttingdown) 
        // only really relevant on 9X.
        //
        KeResetEvent(&Data->ReadSentEvent);
    
        if (!Data->EnableCount || Data->ShuttingDown) {
            IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
            status = Data->ShuttingDown ? STATUS_DELETE_PENDING : STATUS_UNSUCCESSFUL;
            KeSetEvent (&Data->ReadSentEvent, 0, FALSE);
            break;
        } else {
            status = IoCallDriver (Data->TopOfStack, irp);
        }
        KeSetEvent (&Data->ReadSentEvent, 0, FALSE);

        if (MOUHID_IMMEDIATE_READ != InterlockedExchange(&Data->ReadInterlock,
                                                         MOUHID_END_READ)) {
            //
            // The read is asynch, will call SerialMouseStartRead from the
            // completion routine
            //
            Print(DBG_READ_TRACE, ("read is pending\n"));
            break;
        } else {
            //
            // The read was synchronous (probably bytes in the buffer).  The
            // completion routine will not call SerialMouseStartRead, so we 
            // just loop here.  This is to prevent us from running out of stack
            // space if always call StartRead from the completion routine
            //
            Print(DBG_READ_TRACE, ("read is looping\n"));
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\mouhid\pnp.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains plug & play code for the HID Mouse Filter Driver,
    including code for the creation and removal of HID mouse device contexts.

Environment:

    Kernel & user mode.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian

--*/

//
// For this module only we set the INITGUID macro before including wdm.h and
// hidclass.h.   This not only declares the GUIDs but also initializes them.
//

#include "mouhid.h"
#include "hidclass.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MouHid_CallHidClass)
#pragma alloc_text(PAGE,MouHid_AddDevice)
#pragma alloc_text(PAGE,MouHid_StartDevice)
#pragma alloc_text(PAGE,MouHid_PnP)
#endif

NTSTATUS
MouHid_CallHidClass(
    IN     PDEVICE_EXTENSION    Data,
    IN     ULONG        Ioctl,
    IN     PVOID        InputBuffer,
    IN     ULONG        InputBufferLength,
    IN OUT PVOID        OutputBuffer,
    IN     ULONG        OutputBufferLength
    )
/*++

Routine Description:

   Make a *synchronous* request of the HID class driver

Arguments:

    Ioctl              - Value of the IOCTL request.

    InputBuffer        - Buffer to be sent to the HID class driver.

    InputBufferLength  - Size of buffer to be sent to the HID class driver.

    OutputBuffer       - Buffer for received data from the HID class driver.

    OutputBufferLength - Size of receive buffer from the HID class.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    KEVENT             event;
    IO_STATUS_BLOCK    ioStatus;
    PIRP               irp;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS           status = STATUS_SUCCESS;

    PAGED_CODE ();

    Print (DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));

    //
    // Prepare to issue a synchronous request.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
                            Ioctl,
                            Data->TopOfStack,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            FALSE,              // external IOCTL
                            &event,
                            &ioStatus);

    if (irp == NULL) {
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    status = IoCallDriver(Data->TopOfStack, irp);

    if (status == STATUS_PENDING) {

       status = KeWaitForSingleObject(
                     &event,
                     Executive,    // wait reason
                     KernelMode,
                     FALSE,        // not alertable
                     NULL);        // no time out
    }

    if (NT_SUCCESS (status)) {
        status = ioStatus.Status;
    }

    Print (DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));
    return status;
}


NTSTATUS
MouHid_QueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}



NTSTATUS
MouHid_AddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data;
    PDEVICE_OBJECT      device;
    HANDLE              devInstRegKey;
    ULONG               tmp = 0;
    POWER_STATE         state;

    PAGED_CODE ();


    Print (DBG_PNP_TRACE, ("enter Add Device \n"));

    status = IoCreateDevice(Driver,
                            sizeof(DEVICE_EXTENSION),
                            NULL, // no name for this Filter DO
                            FILE_DEVICE_MOUSE,
                            0,
                            FALSE,
                            &device);

    if (!NT_SUCCESS (status)) {
        return( status );
    }

    data = (PDEVICE_EXTENSION) device->DeviceExtension;

    //
    // Initialize the fields.
    //
    data->TopOfStack = IoAttachDeviceToDeviceStack (device, PDO);
    if (data->TopOfStack == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(Driver,
                                    (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = MOUHID_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }
    
    ASSERT (data->TopOfStack);

    data->Self = device;
    data->Started = FALSE;
    data->Initialized = FALSE;
    data->UnitId = (USHORT) InterlockedIncrement (&Globals.UnitId);
    data->PDO = PDO;
    data->ReadIrp = IoAllocateIrp (data->TopOfStack->StackSize, FALSE);
    // Initializiation happens automatically.
    if (NULL == data->ReadIrp) {
        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (device);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent (&data->ReadCompleteEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent (&data->ReadSentEvent, NotificationEvent, TRUE);
    IoInitializeRemoveLock (&data->RemoveLock, MOUHID_POOL_TAG, 1, 10);
    data->ReadFile = NULL;
    ExInitializeFastMutex (&data->CreateCloseMutex);

    data->InputData.UnitId = data->UnitId;

    //
    // Initialize the mouse attributes.
    //
    data->Attributes.MouseIdentifier = MOUSE_HID_HARDWARE;
    data->Attributes.SampleRate      = 0;
    data->Attributes.InputDataQueueLength = 2;

    //
    // Find device specific parameters for this hid mouse device.
    //

    if (NT_SUCCESS (status)) {
        status = IoOpenDeviceRegistryKey (PDO,
                                          PLUGPLAY_REGKEY_DEVICE,
                                          STANDARD_RIGHTS_ALL,
                                          &devInstRegKey);

        data->FlipFlop = FALSE;

        if (NT_SUCCESS (status)) {
            status = MouHid_QueryDeviceKey (devInstRegKey,
                                            FLIP_FLOP_WHEEL,
                                            &tmp,
                                            sizeof (tmp));
            if (NT_SUCCESS (status)) {
                data->FlipFlop = (BOOLEAN) tmp;
            }
            status = MouHid_QueryDeviceKey (devInstRegKey,
                                            SCALING_FACTOR_WHEEL,
                                            &tmp,
                                            sizeof (tmp));
            if (NT_SUCCESS (status)) {
                data->WheelScalingFactor = (ULONG) tmp;
            } else {
                data->WheelScalingFactor = 120;
            }
            ZwClose (devInstRegKey);
        }
        status = STATUS_SUCCESS;
    }

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState (device, DevicePowerState, state);

    data->WmiLibInfo.GuidCount = sizeof (MouHid_WmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
    ASSERT (1 == data->WmiLibInfo.GuidCount);
    data->WmiLibInfo.GuidList = MouHid_WmiGuidList;
    data->WmiLibInfo.QueryWmiRegInfo = MouHid_QueryWmiRegInfo;
    data->WmiLibInfo.QueryWmiDataBlock = MouHid_QueryWmiDataBlock;
    data->WmiLibInfo.SetWmiDataBlock = MouHid_SetWmiDataBlock;
    data->WmiLibInfo.SetWmiDataItem = MouHid_SetWmiDataItem;
    data->WmiLibInfo.ExecuteWmiMethod = NULL;
    data->WmiLibInfo.WmiFunctionControl = NULL;

    device->Flags |= DO_POWER_PAGABLE;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
MouHid_StartDevice (
    IN PDEVICE_EXTENSION    Data
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    HIDP_CAPS                  caps; // the capabilities of the found hid device
    HID_COLLECTION_INFORMATION info;
    NTSTATUS                   status = STATUS_SUCCESS;
    PHIDP_PREPARSED_DATA       preparsedData = NULL;
    PHID_EXTENSION             hid = NULL;
    ULONG                      length, inputBufferLength, usageListLength;
    USHORT                     maxUsages;
    PCHAR                      buffer;
    USHORT                     slength;
    HIDP_VALUE_CAPS            valueCaps;

    PAGED_CODE ();

    Print (DBG_PNP_TRACE, ("enter START Device \n"));

    //
    // Retrieve the capabilities of this hid device
    // IOCTL_HID_GET_COLLECTION_INFORMATION fills in HID_COLLECTION_INFORMATION.
    // we are interested in the Descriptor Size, which tells us how big a
    // buffer to allocate for the preparsed data.
    //
    if (!NT_SUCCESS (status = MouHid_CallHidClass (
                                        Data,
                                        IOCTL_HID_GET_COLLECTION_INFORMATION,
                                        0, 0, // no input
                                        &info, sizeof (info)))) {
        goto MouHid_StartDeviceReject;
    }

    //
    // Allocate memory to hold the preparsed data.
    //
    preparsedData = (PHIDP_PREPARSED_DATA)
                    ExAllocatePool (NonPagedPool, info.DescriptorSize);

    if (!preparsedData) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto MouHid_StartDeviceReject;
    }

    //
    // Retrieve that information.
    //

    if (!NT_SUCCESS (status = MouHid_CallHidClass (
                                       Data,
                                       IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                       0, 0, // no input
                                       preparsedData, info.DescriptorSize))) {
        goto MouHid_StartDeviceReject;
    }

    //
    // Call the parser to determine the capabilites of this HID device.
    //

    if (!NT_SUCCESS (status = HidP_GetCaps (preparsedData, &caps))) {
        goto MouHid_StartDeviceReject;
    }

    //
    // Is this the thing we want?
    //
    // In this particular case we are looking for a keyboard.
    //
    if (    (HID_USAGE_PAGE_GENERIC  == caps.UsagePage) &&
            (   (HID_USAGE_GENERIC_MOUSE == caps.Usage) ||
                (   (HID_USAGE_GENERIC_POINTER == caps.Usage) &&
                    (!Globals.UseOnlyMice)))) {
        ;

    } else {
        //
        // Someone made an INF blunder!
        //
        ASSERT (    (HID_USAGE_PAGE_GENERIC  == caps.UsagePage) &&
                    (   (HID_USAGE_GENERIC_MOUSE == caps.Usage) ||
                        (   (HID_USAGE_GENERIC_POINTER == caps.Usage) &&
                            (!Globals.UseOnlyMice))));

        status = STATUS_UNSUCCESSFUL;

        goto MouHid_StartDeviceReject;
    }

    //
    // Note: here we might also want to check the button and value capabilities
    // of the device as well.
    //
    // Then let's use it.
    //

    //
    // a buffer length to allow an Input buffer, output buffer, feature buffer,
    // and the total number of usages that can be returned from a read packet.
    //

    maxUsages = (USHORT)  HidP_MaxUsageListLength (HidP_Input,
                                                   HID_USAGE_PAGE_BUTTON,
                                                   preparsedData);

    //
    // Create space in the device extension for the buffer storage when working
    // with this HID device.
    //
    // We need four buffers to hold the button codes (length returned from
    // HidP_MaxUsageListLength) this will hold the current list of usages,
    // the previous list of usages, the ``Make'' and the ``Break'' lists.
    // We also need a place to put the input, output, and feature report
    // buffers.
    //

    if (maxUsages > (MAXULONG / sizeof(USAGE) )) {
        status = STATUS_UNSUCCESSFUL;
        goto MouHid_StartDeviceReject;
    }

    usageListLength = ALIGNPTRLEN(maxUsages * sizeof (USAGE));
    inputBufferLength = ALIGNPTRLEN(caps.InputReportByteLength);
    

    if ((MAXULONG - inputBufferLength < sizeof(HID_EXTENSION)) ||
        ((MAXULONG - inputBufferLength - sizeof(HID_EXTENSION))/ 4 < usageListLength)) {
        status = STATUS_UNSUCCESSFUL;
        goto MouHid_StartDeviceReject;
    }

    length = (4 * usageListLength)
           + inputBufferLength
           + sizeof (HID_EXTENSION);

    Data->HidExtension = hid = ExAllocatePool (NonPagedPool, length);

    if (!hid) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto MouHid_StartDeviceReject;
    }

    RtlZeroMemory (hid, length);

    //
    // Initialize the fields.
    //
    hid->Ppd = preparsedData;
    hid->Caps = caps;
    hid->MaxUsages = maxUsages;

    Data->Attributes.NumberOfButtons = (USHORT) maxUsages;


    hid->InputBuffer = buffer = hid->Buffer;
    hid->PreviousUsageList =  (PUSAGE) (buffer += inputBufferLength);
    hid->CurrentUsageList = (PUSAGE) (buffer += usageListLength);
    hid->BreakUsageList = (PUSAGE) (buffer += usageListLength);
    hid->MakeUsageList = (PUSAGE) (buffer + usageListLength);

    //
    // Create the MDLs
    // HidClass uses direct IO so you need MDLs
    //

    hid->InputMdl = IoAllocateMdl (hid->InputBuffer,   // The virtual address
                                   caps.InputReportByteLength, // length
                                   FALSE,  // No associated IRP => not secondary
                                   FALSE,  // No quota charge
                                   0);     // No associated IRP
    if (NULL == hid->InputMdl) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto MouHid_StartDeviceReject;
    }
    MmBuildMdlForNonPagedPool (hid->InputMdl);  // Build this MDL.

    //
    // Determine if X,Y,Z values are absolute or relative for this device.
    // Only check X axis (assume Y,Z are the same -- we have no choice but
    // to make this assumption since the MOUSE_INPUT_DATA structure does
    // not accomodate mixed absolute/relative position fields).
    //
    slength = 1;
    if (!NT_SUCCESS (status = HidP_GetSpecificValueCaps(
                                       HidP_Input,
                                       HID_USAGE_PAGE_GENERIC,
                                       0,
                                       HID_USAGE_GENERIC_X,
                                       &valueCaps,
                                       &slength,
                                       preparsedData) ) ) {
        goto MouHid_StartDeviceReject;
    }

    ASSERT (1 == slength);

    if (valueCaps.IsAbsolute) {
        if ((HID_USAGE_GENERIC_POINTER == caps.Usage) &&
            (Globals.TreatAbsolutePointerAsAbsolute)) {
            //
            // All pointers that declare themselfs as Absolute should be
            // treated as such, regardless of the TreatAbsoluteAsRelative flag
            //
            Data->InputData.Flags = MOUSE_MOVE_ABSOLUTE;
            hid->IsAbsolute = TRUE;

        } else if (Globals.TreatAbsoluteAsRelative) {
            //
            // Here we have overriden the HID descriptors absolute flag.
            // We will treat this as a relative device even though it claims
            // to be an absolute device.
            //
            Data->InputData.Flags = MOUSE_MOVE_RELATIVE;
            hid->IsAbsolute = FALSE;

            //
            // Report the problem with this mouse's report descriptor and
            // report it to the user.
            //
            Data->ProblemFlags |= PROBLEM_BAD_ABSOLUTE_FLAG_X_Y;

            MouHid_LogError(Data->Self->DriverObject,
                            MOUHID_INVALID_ABSOLUTE_AXES,
                            NULL);
        } else {
            //
            // No switches with which to play.  Do what seems natural
            //
            Data->InputData.Flags = MOUSE_MOVE_ABSOLUTE;
            hid->IsAbsolute = TRUE;
        }

    } else {
        Data->InputData.Flags = MOUSE_MOVE_RELATIVE;
        hid->IsAbsolute = FALSE;
    }

    //
    // Determine X axis usage value's bit size.
    //
    hid->BitSize.X = valueCaps.BitSize;
    hid->MaxX = valueCaps.PhysicalMax;
    hid->MaxX = (hid->MaxX) ? (hid->MaxX) : ((1 << (hid->BitSize.X - 1)) - 1);


    //
    // Determine Y axis usage value's bit size.
    //
    slength = 1;
    if (!NT_SUCCESS (status = HidP_GetSpecificValueCaps(
                                       HidP_Input,
                                       HID_USAGE_PAGE_GENERIC,
                                       0,
                                       HID_USAGE_GENERIC_Y,
                                       &valueCaps,
                                       &slength,
                                       preparsedData) ) ) {
        goto MouHid_StartDeviceReject;
    }
    ASSERT (1 == slength);

    hid->BitSize.Y = valueCaps.BitSize;
    hid->MaxY = valueCaps.PhysicalMax;
    hid->MaxY = (hid->MaxY) ? (hid->MaxY) : ((1 << (hid->BitSize.Y - 1)) - 1);

    //
    // Initialize wheel usage not-detected flag to false (determined later).
    //
    hid->HasNoWheelUsage = FALSE;
    hid->HasNoZUsage = FALSE;

    //
    // Determine Z axis usage value's bit size (if this is a wheel mouse).
    // Note that a Z axis may not exist, so we handle this case differently.
    //

    slength = 1;
    if (NT_SUCCESS (HidP_GetSpecificValueCaps(
                                       HidP_Input,
                                       HID_USAGE_PAGE_GENERIC,
                                       0,
                                       HID_USAGE_GENERIC_WHEEL,
                                       &valueCaps,
                                       &slength,
                                       preparsedData) ) && slength == 1) {
        hid->BitSize.Z = valueCaps.BitSize;
        Data->Attributes.MouseIdentifier = WHEELMOUSE_HID_HARDWARE;
    } else {
        // hid->HasNoWheelUsage = TRUE;

        slength = 1;
        if (NT_SUCCESS (HidP_GetSpecificValueCaps(
                                           HidP_Input,
                                           HID_USAGE_PAGE_GENERIC,
                                           0,
                                           HID_USAGE_GENERIC_Z,
                                           &valueCaps,
                                           &slength,
                                           preparsedData) ) && slength == 1) {
            hid->BitSize.Z = valueCaps.BitSize;
            Data->Attributes.MouseIdentifier = WHEELMOUSE_HID_HARDWARE;
        } else {
            // hid->HasNoZUsage = TRUE;
            hid->BitSize.Z = 0;
        }
    }

    //
    // We are done.  Return peacefully.
    //
    return status;

MouHid_StartDeviceReject:
    if (preparsedData) {
        // no need to set hid->Ppd to NULL becuase we will be freeing it as well
        ExFreePool (preparsedData);
    }
    if (hid) {
        if (hid->InputMdl) {
            IoFreeMdl (hid->InputMdl);
        }
        ExFreePool (hid);
        Data->HidExtension = NULL;
    }
    return status;
}

NTSTATUS
MouHid_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   data;
    PHID_EXTENSION      hid;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    ULONG               i, j;
    LONG                ioCount;
    PDEVICE_EXTENSION * classDataList;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    hid = data->HidExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT (FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    Print(DBG_PNP_TRACE, ("PNP: Minor code = %x.", stack->MinorFunction));
    
    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        if (data->Started) {
            Print(DBG_PNP_INFO, ("PNP: Device already started." ));
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            break;
        }

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&data->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                MouHid_PnPComplete,
                                data,
                                TRUE,
                                TRUE,
                                TRUE); // No need for Cancel

        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = IoCallDriver (data->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &data->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            if (!data->Initialized) {
                status = MouHid_StartDevice (data);
                if (NT_SUCCESS (status)) {
                    IoWMIRegistrationControl(DeviceObject,
                                             WMIREG_ACTION_REGISTER
                                             );
                
                    data->Started = TRUE;
                    data->Initialized = TRUE;
                }
            } else {
                data->Started = TRUE;
            }                        
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        if (data->Started) {
            //
            // Do what ever
            //
        }

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //

        //
        // Stop Device touching the hardware MouStopDevice(data, TRUE);
        //
        data->Started = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!usbData->Removed);
        Print (DBG_PNP_TRACE, ("enter RemoveDevice \n"));

        IoWMIRegistrationControl(data->Self,
                                 WMIREG_ACTION_DEREGISTER
                                 );

        if (data->Started) {
            // Stop the device without touching the hardware.
            // MouStopDevice(data, FALSE);
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device could be GONE so we cannot send it any non-
        // PNP IRPS.
        //


        //
        // Cancel our read IRP.  [DAN]
        // Note - waiting is only really necessary on 98, where pnp doesn't 
        // make sure all handles are closed before sending the remove.
        //
        data->ShuttingDown = TRUE;
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
        IoCancelIrp(data->ReadIrp);

        //
        // Send on the remove IRP
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);

        //
        // Wait for the remove lock to free.
        //
        IoReleaseRemoveLockAndWait (&data->RemoveLock, Irp);

        //
        // Free the associated memory.
        //
        IoFreeIrp (data->ReadIrp);

        if (hid) {
            //
            // If we are removed without being started then we will have
            // no hid extension
            //
            ExFreePool (hid->Ppd);
            IoFreeMdl (hid->InputMdl);
            ExFreePool (hid);
        }

        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (data->Self);
        return status;

    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        //
        // These IRPs have to have their status changed from 
        // STATUS_NOT_SUPPORTED b4 passing them down.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
    
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}


NTSTATUS
MouHid_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PDEVICE_EXTENSION   data;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    data = (PDEVICE_EXTENSION) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&data->StartEvent, 0, FALSE);

            //
            // Take the IRP back so that we can continue using it during
            // the IRP_MN_START_DEVICE dispatch routine.
            // NB: we will have to call IoCompleteRequest
            //
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
MouHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    Print(DBG_POWER_TRACE, ("Power Enter." ));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Print(DBG_POWER_INFO, ("Power Setting %s state to %d\n",
                               ((powerType == SystemPowerState) ? "System"
                                                                : "Device"),
                               powerState.SystemState));
        break;

    case IRP_MN_QUERY_POWER:
        Print (DBG_POWER_INFO, ("Power query %s status to %d\n",
                                ((powerType == SystemPowerState) ? "System"
                                                                 : "Device"),
                                powerState.SystemState));
        break;

    default:
        Print (DBG_POWER_ERROR, ("Power minor (0x%x) no known\n",
                                 stack->MinorFunction));
    }

    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);
    status = PoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\mouhid\creatcls.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    creatcls.c

Abstract:

    This module contains the code for IRP_MJ_CREATE and IRP_MJ_CLOSE dispatch
    functions for the HID Mouse Filter Driver.

Environment:

    Kernel mode only.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian
    May-97 : Kenneth D. Ray converted to PnP filter
--*/

#include "mouhid.h"
NTSTATUS
MouHid_CreateComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MouHid_Create (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for create/open requests.  This request
    completes successfully, unless the filename's length is non-zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION  irpSp  = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data = NULL;
    KEVENT              event;

    Print (DBG_CC_TRACE, ("DispatchCreate: Enter.\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Determine if request is trying to open a subdirectory of the
    // given device object.  This is not allowed.
    //
    if (0 != irpSp->FileObject->FileName.Length) {
        Print(DBG_CC_ERROR, ("ERROR: Create Access Denied.\n"));

        status = STATUS_ACCESS_DENIED;
        goto MouHid_CreateReject;
    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        goto MouHid_CreateReject;
    }

    ExAcquireFastMutex (&data->CreateCloseMutex);

    if (NULL == data->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: enable before connect!\n"));
        status = STATUS_UNSUCCESSFUL;
    } else {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                MouHid_CreateComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (data->TopOfStack, Irp);

        KeWaitForSingleObject(&event,
                              Executive, // Waiting for reason of a driver
                              KernelMode, // Waiting in kernel mode
                              FALSE, // No allert
                              NULL); // No timeout

        if (NT_SUCCESS (status)) {
            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS (status)) {
            InterlockedIncrement(&data->EnableCount);
            if (NULL == data->ReadFile &&
                (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA)) {
                //
                // We want to start the read pump.
                //
                Print (DBG_IOCTL_INFO, ("Enabling Mouse \n"));

                data->ReadFile = irpSp->FileObject;

                KeResetEvent (&data->ReadCompleteEvent);

                data->ReadInterlock = MOUHID_END_READ;

                // Acquire another time for the read irp.
                IoAcquireRemoveLock (&data->RemoveLock, data->ReadIrp);
                data->ReadIrp->IoStatus.Status = STATUS_SUCCESS;
                status = MouHid_StartRead (data);

                if (STATUS_PENDING == status) {
                    status = STATUS_SUCCESS;
                } else if (!NT_SUCCESS(status)) {
                    //
                    // Set it back to NULL so that a future open tries again
                    // Read should not fail if open passed. ASSERT!
                    //
                    ASSERT(NT_SUCCESS(status));
                    data->ReadFile = NULL;
                }
            }

            ASSERT (data->EnableCount < 100);
            ASSERT (0 < data->EnableCount);
        }
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;

MouHid_CreateReject:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;
}

NTSTATUS
MouHid_Close (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for close requests.  This request
    completes successfully, unless the file name length is zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION   data;
    PIO_STACK_LOCATION  stack;


    Print(DBG_CC_TRACE, ("DispatchClose: Enter\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    ExAcquireFastMutex (&data->CreateCloseMutex);

    ASSERT (data->EnableCount < 100);
    ASSERT (0 < data->EnableCount);

    if (0 == InterlockedDecrement(&data->EnableCount)) {
        Print (DBG_IOCTL_INFO, ("Disabling Mouse \n"));
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );

        if (IoCancelIrp (data->ReadIrp)) {
            KeWaitForSingleObject (&data->ReadCompleteEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL
                                   );
        }

//        ASSERT (NULL != data->ReadFile);
//        ASSERT (data->ReadFile == stack->FileObject);

        data->ReadFile = NULL;
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);

    IoSkipCurrentIrpStackLocation (Irp);
    Print(DBG_CC_TRACE, ("DispatchClose: Exit \n"));
    return IoCallDriver (data->TopOfStack, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\hidport\mouhid\mouhid.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    mouhid.c

Abstract:

    This module contains the code for the DriverEntry, Unload, IRP_MJ_FLUSH,
    and IRP_MJ_INTERNAL_DEVICE_CONTROL dispatch functions for the HID Mouse
    Filter Driver.

    Note: This is NOT a WDM driver, since it cannot run as a HID mapper on
    Memphis (Memphis requires that the mouse to HID mapper be a VXD) and since
    it uses EVent logs, which are not part of WDM 1.0.

Environment:

    Kernel mode only.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian
    May-1197 :  Kenneth D. Ray : Rewritten as PnP filter for Mouse Class

Notes:

    - IOCTL_INTERNAL_MOUSE_DISCONNECT has not been implemented.  It's not
      needed until the class unload routine is implemented. Right now,
      we don't want to allow the mouse class driver to unload.

    - Powerfail not implemented.

--*/

#include "mouhid.h"
#include "hidclass.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,MouHid_GetRegistryParameters)
#pragma alloc_text(PAGE,MouHid_Unload)
#endif

GLOBALS Globals;

NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT DriverObject,
 