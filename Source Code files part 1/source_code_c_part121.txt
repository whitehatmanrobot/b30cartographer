 Vcb - This is the Vcb for the volume being defragged.

    FileOffset - This is the offset where the truncation may begin.

Return Value:

    BOOLEAN - TRUE if there is an acceptable candidate for truncation at the end of
        the file FALSE otherwise.

--*/

{
    ULONG FinalIndex;
    ULONG BaseIndex;
    ULONG ThisIndex;

    RTL_BITMAP Bitmap;
    PULONG BitmapBuffer;

    BOOLEAN StuffAdded = FALSE;
    BOOLEAN MftTailFound = FALSE;
    PBCB BitmapBcb = NULL;

    PAGED_CODE();

    //
    //  Use a try-finally to facilite cleanup.
    //

    try {

        //
        //  Find the page and range of the last page of the Mft bitmap.
        //

        FinalIndex = (ULONG)Int64ShraMod32(Vcb->MftScb->Header.FileSize.QuadPart, Vcb->MftShift) - 1;

        BaseIndex = FinalIndex & ~(BITS_PER_PAGE - 1);

        Bitmap.SizeOfBitMap = FinalIndex - BaseIndex + 1;

        //
        //  Pin this page.  If the last bit is not clear then return immediately.
        //

        NtfsMapStream( IrpContext,
                       Vcb->MftBitmapScb,
                       (LONGLONG)(BaseIndex / 8),
                       (Bitmap.SizeOfBitMap + 7) / 8,
                       &BitmapBcb,
                       &BitmapBuffer );

        RtlInitializeBitMap( &Bitmap, BitmapBuffer, Bitmap.SizeOfBitMap );

        StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                Vcb->MftScb,
                                                BaseIndex,
                                                &Bitmap );

        //
        //  If the last bit isn't clear then there is nothing we can do.
        //

        if (RtlCheckBit( &Bitmap, Bitmap.SizeOfBitMap - 1 ) == 1) {

            try_return( NOTHING );
        }

        //
        //  Find the final free run of the page.
        //

        RtlFindLastBackwardRunClear( &Bitmap, Bitmap.SizeOfBitMap - 1, &ThisIndex );

        //
        //  This Index is a relative value.  Adjust by the page offset.
        //

        ThisIndex += BaseIndex;

        //
        //  Round up the index to a trucate/extend granularity value.
        //

        ThisIndex += Vcb->MftHoleMask;
        ThisIndex &= Vcb->MftHoleInverseMask;

        if (ThisIndex <= FinalIndex) {

            //
            //  Convert this value to a file offset and return it to our caller.
            //

            *FileOffset = LlBytesFromFileRecords( Vcb, ThisIndex );

            MftTailFound = TRUE;
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFindMftFreeTail );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }
        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return MftTailFound;
}


//
//  Local support routine
//

VOID
NtfsAllocateBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN BOOLEAN FromCachedRuns
    )

/*++

Routine Description:

    This routine allocates clusters in the bitmap within the specified range.

Arguments:

    Vcb - Supplies the vcb used in this operation

    StartingLcn - Supplies the starting Lcn index within the bitmap to
        start allocating (i.e., setting to 1).

    ClusterCount - Supplies the number of bits to set to 1 within the
        bitmap.

    FromCachedRuns - Indicates the clusters came from cached information.  Allows
        us to handle the case where the cached runs are corrupt.

Return Value:

    None.

--*/

{
    LCN BaseLcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    ULONG BitOffset;
    ULONG BitsToSet;

    BITMAP_RANGE BitmapRange;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateBitmapRun\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64x\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %016I64x\n", ClusterCount) );

    BitmapBcb = NULL;

    try {

        //
        //  While the cluster count is greater than zero then we
        //  will loop through reading in a page in the bitmap
        //  setting bits, and then updating cluster count,
        //  and starting lcn
        //

        while (ClusterCount > 0) {

            //
            //  Read in the base containing the starting lcn this will return
            //  a base lcn for the start of the bitmap
            //

            NtfsPinPageInBitmap( IrpContext, Vcb, StartingLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            //
            //  Compute the bit offset within the bitmap of the first bit
            //  we are to set, and also compute the number of bits we need to
            //  set, which is the minimum of the cluster count and the
            //  number of bits left in the bitmap from BitOffset.
            //

            BitOffset = (ULONG)(StartingLcn - BaseLcn);

            if (ClusterCount <= (Bitmap.SizeOfBitMap - BitOffset)) {

                BitsToSet = (ULONG)ClusterCount;

            } else {

                BitsToSet = Bitmap.SizeOfBitMap - BitOffset;
            }

            //
            //  We can only make this check if it is not restart, because we have
            //  no idea whether the update is applied or not.  Raise corrupt if
            //  already set to prevent cross-links.
            //

#ifdef NTFS_CHECK_BITMAP
            if ((Vcb->BitmapCopy != NULL) &&
                !NtfsCheckBitmap( Vcb,
                                  (ULONG) BaseLcn + BitOffset,
                                  BitsToSet,
                                  FALSE )) {

                NtfsBadBitmapCopy( IrpContext, (ULONG) BaseLcn + BitOffset, BitsToSet );
            }
#endif

            //
            //  We hit an unexpected bit set in the bitmap.  The assumption here is that
            //  we got the bit from the cached run information.  If so then simply remove
            //  these clusters from the cached run information.
            //

            if (!RtlAreBitsClear( &Bitmap, BitOffset, BitsToSet )) {

                if (FromCachedRuns) {

                    //
                    //  Clear out the lists.
                    //

#ifdef NTFS_CHECK_CACHED_RUNS
                    ASSERT( FALSE );
#endif
                    NtfsReinitializeCachedRuns( &Vcb->CachedRuns );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                ASSERTMSG("Cannot set bits that are not clear ", FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now log this change as well.
            //

            BitmapRange.BitMapOffset = BitOffset;
            BitmapRange.NumberOfBits = BitsToSet;

            (VOID)
            NtfsWriteLog( IrpContext,
                          Vcb->BitmapScb,
                          BitmapBcb,
                          SetBitsInNonresidentBitMap,
                          &BitmapRange,
                          sizeof(BITMAP_RANGE),
                          ClearBitsInNonresidentBitMap,
                          &BitmapRange,
                          sizeof(BITMAP_RANGE),
                          Int64ShraMod32( BaseLcn, 3 ),
                          0,
                          0,
                          Bitmap.SizeOfBitMap >> 3 );

            //
            //  Now that we've logged the change go ahead and remove it from the
            //  free run Mcb.  Do it after it appears in a log record so that
            //  it won't be allocated to another file.
            //

            (VOID)NtfsAddCachedRun( IrpContext,
                                    Vcb,
                                    StartingLcn,
                                    BitsToSet,
                                    RunStateAllocated );

            //
            //  Now set the bits by calling the same routine used at restart.
            //

            NtfsRestartSetBitsInBitMap( IrpContext,
                                        &Bitmap,
                                        BitOffset,
                                        BitsToSet );

#ifdef NTFS_CHECK_BITMAP
            if (Vcb->BitmapCopy != NULL) {

                ULONG BitmapPage;
                ULONG StartBit;

                BitmapPage = ((ULONG) (BaseLcn + BitOffset)) / (PAGE_SIZE * 8);
                StartBit = ((ULONG) (BaseLcn + BitOffset)) & ((PAGE_SIZE * 8) - 1);

                RtlSetBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitsToSet );
            }
#endif

            //
            // Unpin the Bcb now before possibly looping back.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Now decrement the cluster count and increment the starting lcn accordling
            //

            ClusterCount -= BitsToSet;
            StartingLcn += BitsToSet;
        }

    } finally {

        DebugUnwind( NtfsAllocateBitmapRun );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsAllocateBitmapRun -> VOID\n") );

    return;
}


VOID
NtfsRestartSetBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    )

/*++

Routine Description:

    This routine is common to normal operation and restart, and sets a range of
    bits within a single page (as determined by the system which wrote the log
    record) of the volume bitmap.

Arguments:

    Bitmap - The bit map structure in which to set the bits

    BitMapOffset - Bit offset to set

    NumberOfBits - Number of bits to set

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    //
    //  Now set the bits and mark the bcb dirty.
    //

    RtlSetBits( Bitmap, BitMapOffset, NumberOfBits );
}


//
//  Local support routine
//

VOID
NtfsFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN OUT PLONGLONG ClusterCount
    )

/*++

Routine Description:

    This routine frees clusters in the bitmap within the specified range.

Arguments:

    Vcb - Supplies the vcb used in this operation

    StartingLcn - Supplies the starting Lcn index within the bitmap to
        start freeing (i.e., setting to 0).

    ClusterCount - On entry supplies the number of bits to set to 0 within the
        bitmap.  On exit contains the number of bits left to insert.  This is
        used in the error case to correct the recently deallocated bitmap.

Return Value:

    None.

--*/

{
    LCN BaseLcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    ULONG BitOffset;
    ULONG BitsToClear;

    BITMAP_RANGE BitmapRange;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFreeBitmapRun\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %016I64x\n", *ClusterCount) );

    BitmapBcb = NULL;

    try {

        //
        //  Keep track of how volatile the bitmap package is.
        //

        Vcb->ClustersRecentlyFreed += *ClusterCount;

        if (*ClusterCount > Vcb->CachedRuns.LongestFreedRun) {

            Vcb->CachedRuns.LongestFreedRun = *ClusterCount;
        }

        //
        //  While the cluster count is greater than zero then we
        //  will loop through reading in a page in the bitmap
        //  clearing bits, and then updating cluster count,
        //  and starting lcn
        //

        while (*ClusterCount > 0) {

            //
            //  Read in the base containing the starting lcn this will return
            //  a base lcn for the start of the bitmap
            //

            NtfsPinPageInBitmap( IrpContext, Vcb, StartingLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            //
            //  Compute the bit offset within the bitmap of the first bit
            //  we are to clear, and also compute the number of bits we need to
            //  clear, which is the minimum of the cluster count and the
            //  number of bits left in the bitmap from BitOffset.
            //

            BitOffset = (ULONG)(StartingLcn - BaseLcn);

            if (*ClusterCount <= Bitmap.SizeOfBitMap - BitOffset) {

                BitsToClear = (ULONG)(*ClusterCount);

            } else {

                BitsToClear = Bitmap.SizeOfBitMap - BitOffset;
            }

            //
            //  We can only make this check if it is not restart, because we have
            //  no idea whether the update is applied or not.  Raise corrupt if
            //  these bits aren't set.
            //

#ifdef NTFS_CHECK_BITMAP
            if ((Vcb->BitmapCopy != NULL) &&
                !NtfsCheckBitmap( Vcb,
                                  (ULONG) BaseLcn + BitOffset,
                                  BitsToClear,
                                  TRUE )) {

                NtfsBadBitmapCopy( IrpContext, (ULONG) BaseLcn + BitOffset, BitsToClear );
            }
#endif

            //
            //  Check if the bits are incorrectly clear.
            //

            if (!RtlAreBitsSet( &Bitmap, BitOffset, BitsToClear )) {

                //
                //  Correct thing to do is to ignore the error since the bits are already clear.
                //

                NOTHING;

            //
            //  Don't log if the bits are already correct.  Otherwise we could set them in the
            //  abort path.
            //

            } else {

                //
                //  Now log this change as well.
                //

                BitmapRange.BitMapOffset = BitOffset;
                BitmapRange.NumberOfBits = BitsToClear;

                (VOID)
                NtfsWriteLog( IrpContext,
                              Vcb->BitmapScb,
                              BitmapBcb,
                              ClearBitsInNonresidentBitMap,
                              &BitmapRange,
                              sizeof(BITMAP_RANGE),
                              SetBitsInNonresidentBitMap,
                              &BitmapRange,
                              sizeof(BITMAP_RANGE),
                              Int64ShraMod32( BaseLcn, 3 ),
                              0,
                              0,
                              Bitmap.SizeOfBitMap >> 3 );


                //
                //  Now clear the bits by calling the same routine used at restart.
                //

                NtfsRestartClearBitsInBitMap( IrpContext,
                                              &Bitmap,
                                              BitOffset,
                                              BitsToClear );

#ifdef NTFS_CHECK_BITMAP
                if (Vcb->BitmapCopy != NULL) {

                    ULONG BitmapPage;
                    ULONG StartBit;

                    BitmapPage = ((ULONG) (BaseLcn + BitOffset)) / (PAGE_SIZE * 8);
                    StartBit = ((ULONG) (BaseLcn + BitOffset)) & ((PAGE_SIZE * 8) - 1);

                    RtlClearBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitsToClear );
                }
#endif
            }

            //
            // Unpin the Bcb now before possibly looping back.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Now decrement the cluster count and increment the starting lcn accordling
            //

            *ClusterCount -= BitsToClear;
            StartingLcn += BitsToClear;
        }

    } finally {

        DebugUnwind( NtfsFreeBitmapRun );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsFreeBitmapRun -> VOID\n") );

    return;
}


VOID
NtfsRestartClearBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    )

/*++

Routine Description:

    This routine is common to normal operation and restart, and clears a range of
    bits within a single page (as determined by the system which wrote the log
    record) of the volume bitmap.

Arguments:

    Bitmap - Bitmap structure in which to clear the bits

    BitMapOffset - Bit offset to clear

    NumberOfBits - Number of bits to clear

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    //
    //  Now clear the bits and mark the bcb dirty.
    //

    RtlClearBits( Bitmap, BitMapOffset, NumberOfBits );
}


//
//  Local support routine
//

BOOLEAN
NtfsFindFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG NumberToFind,
    IN LCN StartingSearchHint,
    IN BOOLEAN ReturnAnyLength,
    IN BOOLEAN IgnoreMftZone,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    )

/*++

Routine Description:

    This routine searches the bitmap for free clusters based on the
    hint, and number needed.  This routine is actually pretty dumb in
    that it doesn't try for the best fit, we'll assume the caching worked
    and already would have given us a good fit.

Arguments:

    Vcb - Supplies the vcb used in this operation

    NumberToFind - Supplies the number of clusters that we would
        really like to find

    StartingSearchHint - Supplies an Lcn to start the search from

    ReturnAnyLength - If TRUE then we are more interested in finding
        a run which begins with the StartingSearchHint rather than
        one which matches the length of the run.  Case in point is when
        we are trying to append to an existing file (the Mft is a
        critical case).

    ReturnedLcn - Recieves the Lcn of the free run of clusters that
        we were able to find

    IgnoreMftZone - If TRUE then don't adjust the request around the Mft zone.

    ClusterCountFound - Receives the number of clusters in this run

Return Value:

    BOOLEAN - TRUE if clusters allocated from zone.  FALSE otherwise.

--*/

{
    RTL_BITMAP Bitmap;
    PVOID BitmapBuffer;

    PBCB BitmapBcb;

    BOOLEAN AllocatedFromZone = FALSE;

    BOOLEAN StuffAdded;

    ULONG Count;
    ULONG RequestedCount;
    ULONG FoundCount;

    //
    //  As we walk through the bitmap pages we need to remember
    //  exactly where we are in the bitmap stream.  We walk through
    //  the volume bitmap a page at a time but the current bitmap
    //  contained within the current page but may not be the full
    //  page.
    //
    //      Lcn - Lcn used to find the bitmap page to pin.  This Lcn
    //          will lie within the page to pin.
    //
    //      BaseLcn - Bit offset of the start of the current bitmap in
    //          the bitmap stream.
    //
    //      LcnFromHint - Bit offset of the start of the page after
    //          the page which contains the StartingSearchHint.
    //
    //      BitOffset - Offset of found bits from the beginning
    //          of the current bitmap.
    //

    LCN Lcn = StartingSearchHint;
    LCN BaseLcn;
    LCN LcnFromHint;
    ULONG BitOffset;
    ULONG StartIndex;

    RTL_BITMAP_RUN RunArray[16];
    ULONG RunArrayIndex;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFindFreeBitmapRun\n") );
    DebugTrace( 0, Dbg, ("NumberToFind       = %016I64x\n", NumberToFind) );
    DebugTrace( 0, Dbg, ("StartingSearchHint = %016I64x\n", StartingSearchHint) );

    BitmapBcb = NULL;
    StuffAdded = FALSE;

    try {

        //
        //  First trim the number of clusters that we are being asked
        //  for to fit in a ulong
        //

        if (NumberToFind > MAXULONG) {

            RequestedCount = Count = MAXULONG;

        } else {

            RequestedCount = Count = (ULONG)NumberToFind;
        }

        //
        //  Let's not go past the end of the volume.
        //

        if (Lcn < Vcb->TotalClusters) {

            //
            //  Now read in the first bitmap based on the search hint, this will return
            //  a base lcn that we can use to compute the real bit off for our hint.  We also
            //  must bias the bitmap by whatever has been recently deallocated.
            //

            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &BaseLcn, &Bitmap, &BitmapBcb );

            LcnFromHint = BaseLcn + Bitmap.SizeOfBitMap;

            StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );
            BitmapBuffer = Bitmap.Buffer;

            //
            //  We don't want to look in the Mft zone if it is at the beginning
            //  of this page unless our caller told us to skip any zone checks.  Adjust the
            //  bitmap so we skip this range.
            //

            if (!IgnoreMftZone &&
                (BaseLcn < Vcb->MftZoneEnd) && (Lcn > Vcb->MftZoneEnd)) {

                //
                //  Find the number of bits to swallow.  We know this will
                //  a multible of bytes since the Mft zone end is always
                //  on a ulong boundary.
                //

                BitOffset = (ULONG) (Vcb->MftZoneEnd - BaseLcn);

                //
                //  Adjust the bitmap size and buffer to skip this initial
                //  range in the Mft zone.
                //

                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer, BitOffset / 8 );
                Bitmap.SizeOfBitMap -= BitOffset;

                BaseLcn = Vcb->MftZoneEnd;
            }

            //
            //  The bit offset is from the base of this bitmap to our starting Lcn.
            //

            BitOffset = (ULONG)(Lcn - BaseLcn);

            //
            //  Now search the bitmap for a clear number of bits based on our hint
            //  If we the returned bitoffset is not -1 then we have a hit.
            //

            if (ReturnAnyLength) {

                //
                //  We'd like to find a contiguous run.  If we don't then go back and
                //  ask for a longer run.
                //

                StartIndex = RtlFindClearBits( &Bitmap, 1, BitOffset );

                if ((StartIndex != -1) &&
                    (StartIndex != BitOffset)) {

                    BitOffset = RtlFindClearBits( &Bitmap, Count, BitOffset );

                } else {

                    BitOffset = StartIndex;
                }

                //
                //  We didn't find a contiguous length
                //


            } else {

                BitOffset = RtlFindClearBits( &Bitmap, Count, BitOffset );
            }

            if (BitOffset != -1) {

                //
                //  We found a run.  If the starting Lcn is our input hint AND
                //  we will accept any length then walk forward in the bitmap
                //  and find the real length of the run.
                //

                *ReturnedLcn = BitOffset + BaseLcn;

                if (ReturnAnyLength &&
                    (*ReturnedLcn == StartingSearchHint)) {

                    Count = 0;

                    while (TRUE) {


                        FoundCount = RtlFindNextForwardRunClear( &Bitmap,
                                                                 BitOffset,
                                                                 &StartIndex );

                        //
                        //  Verify that we found something and that the offset
                        //  begins with out start hint.
                        //

                        if (FoundCount &&
                            (BitOffset == StartIndex)) {

                            Count += FoundCount;

                            if (Count >= RequestedCount) {

                                Count = RequestedCount;
                                break;
                            }

                        } else {

                            break;
                        }

                        //
                        //  Break out if we found enough or the run doesn't
                        //  extend to the end of the bitmap or we are at
                        //  the last page of the bitmap.
                        //

                        if ((StartIndex + FoundCount != Bitmap.SizeOfBitMap) ||
                            (BaseLcn + Bitmap.SizeOfBitMap >= Vcb->TotalClusters)) {

                            break;
                        }

                        Lcn = BaseLcn + Bitmap.SizeOfBitMap;

                        if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }

                        NtfsUnpinBcb( IrpContext, &BitmapBcb );
                        NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &BaseLcn, &Bitmap, &BitmapBcb );
                        ASSERTMSG("Math wrong for bits per page of bitmap", (Lcn == BaseLcn));

                        StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );
                        BitmapBuffer = Bitmap.Buffer;
                        BitOffset = 0;
                    }
                }

                *ClusterCountFound = Count;

                //
                //  While we have the bitmap let's grab some long runs
                //

                RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

                if (RunArrayIndex > 0) {

                    NtfsAddCachedRunMult( IrpContext,
                                          Vcb,
                                          BaseLcn,
                                          RunArray,
                                          RunArrayIndex );
                }

                leave;
            }

            //
            //  Well the first try didn't succeed so now just grab the longest free run in the
            //  current bitmap, and while we're at it will populate the cached run information
            //

            RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

            if (RunArrayIndex > 0) {

                USHORT LocalOffset;

                *ReturnedLcn = RunArray[0].StartingIndex + BaseLcn;
                *ClusterCountFound = RunArray[0].NumberOfBits;

                //
                //  There is no point in adding a free run for a range that is
                //  about to be consumed, although it won't affect correctness.
                //

                if (*ClusterCountFound > NumberToFind) {

                    //
                    //  Trim off the part of the free run that will be
                    //  consumed by the caller.
                    //

                    RunArray[0].StartingIndex += (ULONG)NumberToFind;
                    RunArray[0].NumberOfBits -= (ULONG)NumberToFind;
                    LocalOffset = 0;

                    //
                    //  Only return the requested amount to the caller.
                    //

                    *ClusterCountFound = NumberToFind;
                } else {

                    //
                    //  Skip the first entry since the caller will use all of
                    //  it.
                    //

                    LocalOffset = 1;
                }
                if (RunArrayIndex > LocalOffset) {

                    NtfsAddCachedRunMult( IrpContext,
                                          Vcb,
                                          BaseLcn,
                                          RunArray + LocalOffset,
                                          RunArrayIndex - LocalOffset );
                }

                leave;
            }

            //
            //  Well the current bitmap is full so now simply scan the disk looking
            //  for anything that is free, starting with the next bitmap.
            //  And again bias the bitmap with recently deallocated clusters.
            //  We won't even bother looking for the longest free runs we'll take
            //  whatever we can get.
            //

            if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }
            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            Lcn = BaseLcn + Bitmap.SizeOfBitMap;

            //
            //  If this is the Mft then scan from the current point to volume end,
            //  then back to the beginning.
            //

            if (IgnoreMftZone) {

                //
                //  Look in the following ranges.  Break out if we find anything.
                //
                //      - Current point to end of volume
                //      - Start of volume to current
                //

                if (NtfsScanBitmapRange( IrpContext,
                                         Vcb,
                                         Lcn,
                                         Vcb->TotalClusters,
                                         NumberToFind,
                                         ReturnedLcn,
                                         ClusterCountFound )) {

                    if ((*ReturnedLcn < Vcb->MftZoneEnd) &&
                        (*ReturnedLcn >= Vcb->MftZoneStart)) {

                        AllocatedFromZone = TRUE;
                    }
                    leave;
                }

                if (NtfsScanBitmapRange( IrpContext,
                                         Vcb,
                                         0,
                                         Lcn,
                                         NumberToFind,
                                         ReturnedLcn,
                                         ClusterCountFound )) {

                    if ((*ReturnedLcn < Vcb->MftZoneEnd) &&
                        (*ReturnedLcn >= Vcb->MftZoneStart)) {

                        AllocatedFromZone = TRUE;
                    }
                    leave;
                }

                //
                //  No luck.
                //

                *ClusterCountFound = 0;
                leave;
            }
        }

        //
        //  Check if we are starting before the Mft zone.
        //

        if (Lcn < Vcb->MftZoneStart) {

            //
            //  Look in the following ranges.  Break out if we find anything.
            //
            //      - Current point to Zone start
            //      - Zone end to end of volume
            //      - Start of volume to current
            //

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Lcn,
                                     Vcb->MftZoneStart,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Vcb->MftZoneEnd,
                                     Vcb->TotalClusters,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     0,
                                     Lcn,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }

        //
        //  Check if we are beyond the Mft zone.
        //

        } else if (Lcn > Vcb->MftZoneEnd) {

            //
            //  Look in the following ranges.  Break out if we find anything.
            //
            //      - Current point to end of volume
            //      - Start of volume to Zone start
            //      - Zone end to current point.
            //

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Lcn,
                                     Vcb->TotalClusters,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     0,
                                     Vcb->MftZoneStart,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Vcb->MftZoneEnd,
                                     Lcn,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

        //
        //  We are starting within the zone.  Skip over the zone to check it last.
        //

        } else {

            //
            //  Look in the following ranges.  Break out if we find anything.
            //
            //      - End of zone to end of volume
            //      - Start of volume to start of zone
            //

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Vcb->MftZoneEnd,
                                     Vcb->TotalClusters,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     0,
                                     Vcb->MftZoneStart,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }
        }

        //
        //  We didn't find anything.  Let's examine the zone explicitly.
        //

        if (NtfsScanBitmapRange( IrpContext,
                                 Vcb,
                                 Vcb->MftZoneStart,
                                 Vcb->MftZoneEnd,
                                 NumberToFind,
                                 ReturnedLcn,
                                 ClusterCountFound )) {

            AllocatedFromZone = TRUE;
            leave;
        }

        //
        //  No luck.
        //

        *ClusterCountFound = 0;

    } finally {

        DebugUnwind( NtfsFindFreeBitmapRun );

        if (StuffAdded) { NtfsFreePool( BitmapBuffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( 0, Dbg, ("ReturnedLcn <- %016I64x\n", *ReturnedLcn) );
    DebugTrace( 0, Dbg, ("ClusterCountFound <- %016I64x\n", *ClusterCountFound) );
    DebugTrace( -1, Dbg, ("NtfsFindFreeBitmapRun -> VOID\n") );

    return AllocatedFromZone;
}


//
//  Local support routine
//

BOOLEAN
NtfsScanBitmapRange (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartLcn,
    IN LCN BeyondLcn,
    IN LONGLONG NumberToFind,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    )

/*++

Routine Description:

    This routine will scan a range of the bitmap looking for a free run.
    It is called when we need to limit the bits we are willing to consider
    at a time, typically to skip over the Mft zone.

Arguments:

    Vcb - Volume being scanned.

    StartLcn - First Lcn in the bitmap to consider.

    BeyondLcn - First Lcn in the bitmap past the range we want to consider.

    NumberToFind - Supplies the number of clusters that we would
        really like to find

    ReturnedLcn - Start of free range if found.

    ClusterCountFound - Length of free range if found.

Return Value:

    BOOLEAN - TRUE if a bitmap range was found.  FALSE otherwise.

--*/

{
    BOOLEAN FreeRangeFound = FALSE;
    RTL_BITMAP Bitmap;
    PVOID BitmapBuffer;
    ULONG BitOffset;

    PBCB BitmapBcb = NULL;

    BOOLEAN StuffAdded = FALSE;
    LCN BaseLcn;

    RTL_BITMAP_RUN RunArray[16];
    ULONG RunArrayIndex;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanBitmapRange...\n") );

    //
    //  The end Lcn might be beyond the end of the bitmap.
    //

    if (BeyondLcn > Vcb->TotalClusters) {

        BeyondLcn = Vcb->TotalClusters;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now search the rest of the bitmap starting with right after the mft zone
        //  followed by the mft zone (or the beginning of the disk).  Again take whatever
        //  we can get and not bother with the longest runs.
        //

        while (StartLcn < BeyondLcn) {

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, StartLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );
            BitmapBuffer = Bitmap.Buffer;

            //
            //  Check if we don't want to use the entire page.
            //

            if ((BaseLcn + Bitmap.SizeOfBitMap) > BeyondLcn) {

                Bitmap.SizeOfBitMap = (ULONG) (BeyondLcn - BaseLcn);
            }

            //
            //  Now adjust the starting Lcn if not at the beginning
            //  of the bitmap page.  We know this will be a multiple
            //  of bytes since the MftZoneEnd is always on a ulong
            //  boundary in the bitmap.
            //

            if (BaseLcn != StartLcn) {

                BitOffset = (ULONG) (StartLcn - BaseLcn);

                Bitmap.SizeOfBitMap -= BitOffset;
                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer, BitOffset / 8 );

                BaseLcn = StartLcn;
            }

            RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

            if (RunArrayIndex > 0) {

                USHORT LocalOffset;

                *ReturnedLcn = RunArray[0].StartingIndex + BaseLcn;
                *ClusterCountFound = RunArray[0].NumberOfBits;
                FreeRangeFound = TRUE;

                //
                //  There is no point in adding a free run for a range that is
                //  about to be consumed, although it won't affect correctness.
                //

                if (*ClusterCountFound > NumberToFind) {

                    //
                    //  Trim off the part of the free run that will be
                    //  consumed by the caller.
                    //

                    RunArray[0].StartingIndex += (ULONG)NumberToFind;
                    RunArray[0].NumberOfBits -= (ULONG)NumberToFind;
                    LocalOffset = 0;
                } else {

                    //
                    //  Skip the first entry since the caller will use all of
                    //  it.
                    //

                    LocalOffset = 1;
                }
                if (RunArrayIndex > LocalOffset) {

                    NtfsAddCachedRunMult( IrpContext,
                                          Vcb,
                                          BaseLcn,
                                          RunArray + LocalOffset,
                                          RunArrayIndex - LocalOffset );
                }

                leave;
            }

            StartLcn = BaseLcn + Bitmap.SizeOfBitMap;

            if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }
        }

    } finally {

        DebugUnwind( NtfsScanBitmapRange );

        if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }
        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        DebugTrace( -1, Dbg, ("NtfsScanBitmapRange -> %08lx\n", FreeRangeFound) );
    }

    return FreeRangeFound;
}


//
//  Local support routine
//

BOOLEAN
NtfsAddRecentlyDeallocated (
    IN PVCB Vcb,
    IN LCN StartingBitmapLcn,
    IN OUT PRTL_BITMAP Bitmap
    )

/*++

Routine Description:

    This routine will modify the input bitmap by removing from it
    any clusters that are in the recently deallocated mcb.  If we
    do add stuff then we will not modify the bitmap buffer itself but
    will allocate a new copy for the bitmap.

    We will always protect the boot sector on the disk by marking the
    first 8K as allocated.  This will prevent us from overwriting the
    boot sector if the volume becomes corrupted.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    StartingBitmapLcn - Supplies the Starting Lcn of the bitmap

    Bitmap - Supplies the bitmap being modified

Return Value:

    BOOLEAN - TRUE if the bitmap has been modified and FALSE
        otherwise.

--*/

{
    BOOLEAN Results;
    PVOID NewBuffer;


    LCN EndingBitmapLcn;

    PLARGE_MCB Mcb;

    ULONG i;
    VCN StartingVcn;
    LCN StartingLcn;
    LCN EndingLcn;
    LONGLONG ClusterCount;
    PDEALLOCATED_CLUSTERS DeallocatedClusters;

    ULONG StartingBit;
    ULONG EndingBit;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddRecentlyDeallocated...\n") );

    //
    //  Until shown otherwise we will assume that we haven't updated anything
    //

    Results = FALSE;

    //
    //  If this is the first page of the bitmap then mark the first 8K as
    //  allocated.  This will prevent us from accidentally allocating out
    //  of the boot sector even if the bitmap is corrupt.
    //

    if ((StartingBitmapLcn == 0) &&
        !RtlAreBitsSet( Bitmap, 0, ClustersFromBytes( Vcb, 0x2000 ))) {

        NewBuffer = NtfsAllocatePool(PagedPool, (Bitmap->SizeOfBitMap+7)/8 );
        RtlCopyMemory( NewBuffer, Bitmap->Buffer, (Bitmap->SizeOfBitMap+7)/8 );
        Bitmap->Buffer = NewBuffer;

        Results = TRUE;

        //
        //  Now mark the bits as allocated.
        //

        RtlSetBits( Bitmap, 0, ClustersFromBytes( Vcb, 0x2000 ));
    }

    //
    //  Now compute the ending bitmap lcn for the bitmap
    //

    EndingBitmapLcn = StartingBitmapLcn + (Bitmap->SizeOfBitMap - 1);

    //
    //  For every run in the recently deallocated mcb we will check if it is real and
    //  then check if the run in contained in the bitmap.
    //
    //  There are really six cases to consider:
    //
    //         StartingBitmapLcn                   EndingBitmapLcn
    //                  +=================================+
    //
    //
    //   1 -------+ EndingLcn
    //
    //   2                                           StartingLcn +--------
    //
    //   3 -------------------+ EndingLcn
    //
    //   4                                StartingLcn +-------------------------
    //
    //   5 ---------------------------------------------------------------
    //
    //   6            EndingLcn +-------------------+ StartingLcn
    //
    //
    //      1. EndingLcn is before StartingBitmapLcn which means we haven't
    //         reached the bitmap yet.
    //
    //      2. StartingLcn is after EndingBitmapLcn which means we've gone
    //         beyond the bitmap
    //
    //      3, 4, 5, 6.  There is some overlap between the bitmap and
    //         the run.
    //

    DeallocatedClusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Flink;
    do {

        //
        //  Skip this Mcb if it has no entries.
        //

        if (DeallocatedClusters->ClusterCount != 0) {

            Mcb = &DeallocatedClusters->Mcb;

            for (i = 0; FsRtlGetNextLargeMcbEntry( Mcb, i, &StartingVcn, &StartingLcn, &ClusterCount ); i += 1) {

                if (StartingVcn == StartingLcn) {

                    //
                    //  Compute the ending lcn as the starting lcn minus cluster count plus 1.
                    //

                    EndingLcn = (StartingLcn + ClusterCount) - 1;

                    //
                    //  Check if we haven't reached the bitmap yet.
                    //

                    if (EndingLcn < StartingBitmapLcn) {

                        NOTHING;

                    //
                    //  Check if we've gone beyond the bitmap
                    //

                    } else if (EndingBitmapLcn < StartingLcn) {

                        break;

                    //
                    //  Otherwise we overlap with the bitmap in some way
                    //

                    } else {

                        //
                        //  First check if we have never set bit in the bitmap.  and if so then
                        //  now is the time to make an private copy of the bitmap buffer
                        //

                        if (Results == FALSE) {

                            NewBuffer = NtfsAllocatePool(PagedPool, (Bitmap->SizeOfBitMap+7)/8 );
                            RtlCopyMemory( NewBuffer, Bitmap->Buffer, (Bitmap->SizeOfBitMap+7)/8 );
                            Bitmap->Buffer = NewBuffer;

                            Results = TRUE;
                        }

                        //
                        //  Now compute the begining and ending bit that we need to set in the bitmap
                        //

                        StartingBit = (StartingLcn < StartingBitmapLcn ?
                                       0 :
                                       (ULONG)(StartingLcn - StartingBitmapLcn));

                        EndingBit = (EndingLcn > EndingBitmapLcn ?
                                     Bitmap->SizeOfBitMap - 1 :
                                     (ULONG)(EndingLcn - StartingBitmapLcn));

                        //
                        //  And set those bits
                        //

                        RtlSetBits( Bitmap, StartingBit, EndingBit - StartingBit + 1 );
                    }
                }
            }
        }

        DeallocatedClusters = (PDEALLOCATED_CLUSTERS)DeallocatedClusters->Link.Flink;

    } while (&DeallocatedClusters->Link != &Vcb->DeallocatedClusterListHead );

    DebugTrace( -1, Dbg, ("NtfsAddRecentlyDeallocated -> %08lx\n", Results) );

    return Results;
}


//
//  Local support routine
//

VOID
NtfsMapOrPinPageInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    IN OUT PRTL_BITMAP Bitmap,
    OUT PBCB *BitmapBcb,
    IN BOOLEAN AlsoPinData
    )

/*++

Routine Description:

    This routine reads in a single page of the bitmap file and returns
    an initialized bitmap variable for that page

Arguments:

    Vcb - Supplies the vcb used in this operation

    Lcn - Supplies the Lcn index in the bitmap that we want to read in
        In other words, this routine reads in the bitmap page containing
        the lcn index

    StartingLcn - Receives the base lcn index of the bitmap that we've
        just read in.

    Bitmap - Receives an initialized bitmap.  The memory for the bitmap
        header must be supplied by the caller

    BitmapBcb - Receives the Bcb for the bitmap buffer

    AlsoPinData - Indicates if this routine should also pin the page
        in memory, used if we need to modify the page

Return Value:

    None.

--*/

{
    ULONG BitmapSize;
    PVOID Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapOrPinPageInBitmap\n") );
    DebugTrace( 0, Dbg, ("Lcn = %016I64x\n", Lcn) );

    //
    //  Compute the starting lcn index of the page we're after
    //

    *StartingLcn = Lcn & ~(BITS_PER_PAGE-1);

    //
    //  Compute how many bits there are in the page we need to read
    //

    BitmapSize = (ULONG)(Vcb->TotalClusters - *StartingLcn);

    if (BitmapSize > BITS_PER_PAGE) {

        BitmapSize = BITS_PER_PAGE;
    }

    //
    //  Now either Pin or Map the bitmap page, we will add 7 to the bitmap
    //  size before dividing it by 8.  That way we will ensure we get the last
    //  byte read in.  For example a bitmap size of 1 through 8 reads in 1 byte
    //

    if (AlsoPinData) {

        NtfsPinStream( IrpContext,
                       Vcb->BitmapScb,
                       Int64ShraMod32( *StartingLcn, 3 ),
                       (BitmapSize+7)/8,
                       BitmapBcb,
                       &Buffer );

    } else {

        NtfsMapStream( IrpContext,
                       Vcb->BitmapScb,
                       Int64ShraMod32( *StartingLcn, 3 ),
                       (BitmapSize+7)/8,
                       BitmapBcb,
                       &Buffer );
    }

    //
    //  And initialize the bitmap
    //

    RtlInitializeBitMap( Bitmap, Buffer, BitmapSize );

    DebugTrace( 0, Dbg, ("StartingLcn <- %016I64x\n", *StartingLcn) );
    DebugTrace( -1, Dbg, ("NtfsMapOrPinPageInBitmap -> VOID\n") );

    return;
}


BOOLEAN
NtfsAddCachedRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN NTFS_RUN_STATE RunState
    )

/*++

Routine Description:

    This procedure adds a new run to the cached free space
    bitmap information.

Arguments:

    Vcb - Supplies the vcb for this operation

    StartingLcn - Supplies the lcn for the run being added

    ClusterCount - Supplies the number of clusters in the run being added

    RunState - Supplies the state of the run being added.  This state
        must be either free or allocated.

Return Value:

    BOOLEAN - TRUE if more entries can be added to the list, FALSE otherwise.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddCachedRun\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64x\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %016I64x\n", ClusterCount) );

    //
    //  Based on whether we are adding a free or allocated run we
    //  setup or local variables to a point to the right
    //  vcb variables
    //

    if (RunState == RunStateFree) {

        //
        //  We better not be setting Lcn 0 free.
        //

        if (StartingLcn == 0) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  Sanity check that we aren't adding bits beyond the end of the
        //  bitmap.
        //

        ASSERT( StartingLcn + ClusterCount <= Vcb->TotalClusters );

        NtfsInsertCachedLcn( &Vcb->CachedRuns,
                             StartingLcn,
                             ClusterCount );

    } else {

        //
        //  Now remove the run from the cached runs because it can potentially already be
        //  there.
        //

        NtfsRemoveCachedLcn( &Vcb->CachedRuns,
                             StartingLcn,
                             ClusterCount );
    }

    DebugTrace( -1, Dbg, ("NtfsAddCachedRun -> VOID\n") );

    return ((Vcb->CachedRuns.Avail - Vcb->CachedRuns.Used + Vcb->CachedRuns.DelLcnCount) > 0);
}

#if 0

VOID
NtfsMakeSpaceCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN StartingLcn,
    IN RTL_BITMAP_RUN *RunArray,
    IN ULONG RunCount,
    IN PUSHORT LcnSorted OPTIONAL
    )

/*++

Routine Description:

    This procedure attempts to make space in the Lcn-sorted array for RunCount
    new entries in the given Lcn range.  This routine will not delete any
    existing entries to create the space because we don't know at this time
    how many will actually end up being inserted into the list.  They may not
    be inserted because their run lengths are too small relative to the
    entries already in the list.  This call is used because it is more
    efficient to create space once for all the entries than to do so
    individually.  In effect, this routine moves windows of deleted entries
    to the desired Lcn position.

Arguments:

    CachedRuns - Pointer to a cached run structure.

    StartingLcn - Supplies the base Lcn for the runs being added

    RunArray - The bit position and length of each of the free runs.
        The array will be sorted according to length.

    RunCount - Supplies the number of runs being added

    LcnSorted - An optional array of RunCount indices that gives the Lcn
        sort order.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMakeSpaceCachedLcn\n") );

    DebugTrace( -1, Dbg, ("NtfsMakeSpaceCachedLcn -> VOID\n") );

    return;
}
#endif /* 0 */


VOID
NtfsAddCachedRunMult (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN PRTL_BITMAP_RUN RunArray,
    IN ULONG RunCount
    )

/*++

Routine Description:

    This procedure adds multiple new runs to the cached free space
    bitmap information.  It is assumed that the new runs fall
    in a close range of Lcn values.  As a rule, these runs come from
    a single page of the bitmap.

Arguments:

    Vcb - Supplies the vcb for this operation

    StartingLcn - Supplies the base Lcn for the runs being added

    RunArray - The bit position and length of each of the free runs.
        The array will be sorted according to length.

    RunCount - Supplies the number of runs being added

Return Value:

    None.

--*/

{
    USHORT Index1;
    PUSHORT LcnSorted = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddCachedRunMult\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64x\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("RunArray = %08lx\n", RunArray) );
    DebugTrace( 0, Dbg, ("RunCount = %08lx\n", RunCount) );

#if 0

    //
    //  Sort the entries by Lcn.  It is often the case that at startup we are
    //  adding entries that will all fall at the end of the Lcn-sorted list.
    //  However, if the entries are not added in Lcn-sorted order there will
    //  likely be some moving around of entries in the Lcn-sorted list that
    //  could be avoided.
    //

    LcnSorted = NtfsAllocatePoolNoRaise( PagedPool, sizeof( USHORT ) * RunCount );
    if (LcnSorted != NULL) {

        USHORT Index2;

        //
        //  Bubble sort the elements.
        //

        for (Index1 = 1, LcnSorted[0] = 0;
             Index1 < RunCount;
             Index1 += 1) {

            for (Index2 = 0; Index2 < Index1; Index2 += 1) {

                if (RunArray[Index1].StartingIndex < RunArray[LcnSorted[Index2]].StartingIndex) {

                    //
                    //  Move the entries from Index2 through Index1 - 1 to the
                    //  right to make space for the current entry.
                    //

                    RtlMoveMemory( LcnSorted + Index2 + 1,
                                   LcnSorted + Index2,
                                   sizeof( USHORT ) * (Index1 - Index2) );
                    break;
                }
            }

            //
            //  Write the index into the correctly sorted location.
            //

            LcnSorted[Index2] = Index1;
        }
    }

    //
    //  Make space in the Lcn-sorted array for these new entries.
    //  This is done in advance because it is more efficient to create
    //  space once for all the entries than to do so individually.
    //  The following routine will not delete any existing entries to
    //  create the space because we don't know at this time how many will
    //  actually end up being inserted into the list.  They may not be
    //  inserted because their run lengths are too small relative to the
    //  entries already in the list.
    //

    NtfsMakeSpaceCachedLcn( &Vcb->CachedRuns,
                            StartingLcn,
                            RunArray,
                            RunCount,
                            LcnSorted );
#endif /* 0 */

    //
    //  Insert the new entries.
    //

    for (Index1 = 0; Index1 < RunCount; Index1 += 1) {

        //
        //  If not sorted then do the generic insert.  The gain for the sorted case
        //  that we won't have to do a memory copy for entries we just inserted.
        //

        if (LcnSorted != NULL) {

            (VOID) NtfsAddCachedRun( IrpContext,
                                     Vcb,
                                     StartingLcn + RunArray[ LcnSorted[ Index1 ]].StartingIndex,
                                     (LONGLONG)RunArray[ LcnSorted[ Index1 ]].NumberOfBits,
                                     RunStateFree );
        } else {

            (VOID) NtfsAddCachedRun( IrpContext,
                                     Vcb,
                                     StartingLcn + RunArray[ Index1 ].StartingIndex,
                                     (LONGLONG)RunArray[ Index1 ].NumberOfBits,
                                     RunStateFree );
        }
    }

    if (LcnSorted != NULL) {

        NtfsFreePool( LcnSorted );
    }

    DebugTrace( -1, Dbg, ("NtfsAddCachedRunMult -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsReadAheadCachedBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn
    )

/*++

Routine Description:

    This routine does a read ahead of the bitmap into the cached bitmap
    starting at the specified starting lcn.

Arguments:

    Vcb - Supplies the vcb to use in this operation

    StartingLcn - Supplies the starting lcn to use in this read ahead
        operation.

Return Value:

    None.

--*/

{
    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    BOOLEAN StuffAdded;

    LCN BaseLcn;
    ULONG Index;
    LONGLONG Size;

    RTL_BITMAP_RUN RunArray[16];
    ULONG RunArrayIndex;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadAheadCachedBitmap\n") );
    DebugTrace( 0, Dbg, ("StartingLcn = %016I64x\n", StartingLcn) );

    BitmapBcb = NULL;
    StuffAdded = FALSE;

    try {

        //
        //  Check if the lcn index is already in the cached runs info and if it is then
        //  our read ahead is done.
        //

        if (NtfsLookupCachedLcn( &Vcb->CachedRuns,
                                 StartingLcn,
                                 &BaseLcn,
                                 &BaseLcn,
                                 NULL )) {

            try_return( NOTHING );
        }

        //
        //  Map in the page containing the starting lcn and compute the bit index for the
        //  starting lcn within the bitmap.  And bias the bitmap with recently deallocated
        //  clusters.
        //

        NtfsMapPageInBitmap( IrpContext, Vcb, StartingLcn, &BaseLcn, &Bitmap, &BitmapBcb );

        StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );

        Index = (ULONG)(StartingLcn - BaseLcn);

        //
        //  Now if the index is clear then we can build up the hint at the starting index, we
        //  scan through the bitmap checking the size of the run and then adding the free run
        //  to the cached free space mcb
        //

        if (RtlCheckBit( &Bitmap, Index ) == 0) {

            Size = RtlFindNextForwardRunClear( &Bitmap, Index, &Index );

            (VOID) NtfsAddCachedRun( IrpContext, Vcb, StartingLcn, (LONGLONG)Size, RunStateFree );
        }

        //
        //  While we have the bitmap loaded we will scan it for a few longest runs
        //

        RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

        if (RunArrayIndex > 0) {

            NtfsAddCachedRunMult( IrpContext,
                                  Vcb,
                                  BaseLcn,
                                  RunArray,
                                  RunArrayIndex );
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsReadAheadCachedBitmap );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsReadAheadCachedBitmap -> VOID\n") );

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsGetNextHoleToFill (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PVCN VcnToFill,
    OUT PLONGLONG ClusterCountToFill,
    OUT PLCN PrecedingLcn
    )

/*++

Routine Description:

    This routine takes a specified range within an mcb and returns the to
    caller the first run that is not allocated to any lcn within the range

Arguments:

    Mcb - Supplies the mcb to use in this operation

    StartingVcn - Supplies the starting vcn to search from

    EndingVcn - Supplies the ending vcn to search to

    VcnToFill - Receives the first Vcn within the range that is unallocated

    ClusterCountToFill - Receives the size of the free run

    PrecedingLcn - Receives the Lcn of the allocated cluster preceding the
        free run.  If the free run starts at Vcn 0 then the preceding lcn
        is -1.

Return Value:

    BOOLEAN - TRUE if there is another hole to fill and FALSE otherwise

--*/

{
    BOOLEAN Result;
    BOOLEAN McbHit;
    LCN Lcn;
    LONGLONG MaximumRunSize;

    LONGLONG LlTemp1;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetNextHoleToFill\n") );
    DebugTrace( 0, Dbg, ("StartingVcn = %016I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("EndingVcn   = %016I64x\n", EndingVcn) );

    //
    //  We'll first assume that there is not a hole to fill unless
    //  the following loop finds one to fill
    //

    Result = FALSE;

    for (*VcnToFill = StartingVcn;
         *VcnToFill <= EndingVcn;
         *VcnToFill += *ClusterCountToFill) {

        //
        //  Check if the hole is already filled and it so then do nothing but loop back up
        //  to the top of our loop and try again
        //

        if ((McbHit = NtfsLookupNtfsMcbEntry( Mcb, *VcnToFill, &Lcn, ClusterCountToFill, NULL, NULL, NULL, NULL )) &&
            (Lcn != UNUSED_LCN)) {

            NOTHING;

        } else {

            //
            //  We have a hole to fill so now compute the maximum size hole that
            //  we are allowed to fill and then check if we got an miss on the lookup
            //  and need to set cluster count or if the size we got back is too large
            //

            MaximumRunSize = (EndingVcn - *VcnToFill) + 1;

            if (!McbHit || (*ClusterCountToFill > MaximumRunSize)) {

                *ClusterCountToFill = MaximumRunSize;
            }

            //
            //  Now set the preceding lcn to either -1 if there isn't a preceding vcn or
            //  set it to the lcn of the preceding vcn
            //

            if (*VcnToFill == 0) {

                *PrecedingLcn = UNUSED_LCN;

            } else {

                LlTemp1 = *VcnToFill - 1;

                if (!NtfsLookupNtfsMcbEntry( Mcb, LlTemp1, PrecedingLcn, NULL, NULL, NULL, NULL, NULL )) {

                    *PrecedingLcn = UNUSED_LCN;
                }
            }

            //
            //  We found a hole so set our result to TRUE and break out of the loop
            //

            Result = TRUE;

            break;
        }
    }

    DebugTrace( 0, Dbg, ("VcnToFill <- %016I64x\n", *VcnToFill) );
    DebugTrace( 0, Dbg, ("ClusterCountToFill <- %016I64x\n", *ClusterCountToFill) );
    DebugTrace( 0, Dbg, ("PrecedingLcn <- %016I64x\n", *PrecedingLcn) );
    DebugTrace( -1, Dbg, ("NtfsGetNextHoleToFill -> %08lx\n", Result) );

    return Result;
}


//
//  Local support routine
//

LONGLONG
NtfsScanMcbForRealClusterCount (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    )

/*++

Routine Description:

    This routine scans the input mcb within the specified range and returns
    to the caller the exact number of clusters that a really free (i.e.,
    not mapped to any Lcn) within the range.

Arguments:

    Mcb - Supplies the Mcb used in this operation

    StartingVcn - Supplies the starting vcn to search from

    EndingVcn - Supplies the ending vcn to search to

Return Value:

    LONGLONG - Returns the number of unassigned clusters from
        StartingVcn to EndingVcn inclusive within the mcb.

--*/

{
    LONGLONG FreeCount;
    VCN Vcn;
    LCN Lcn;
    LONGLONG RunSize;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanMcbForRealClusterCount\n") );
    DebugTrace( 0, Dbg, ("StartingVcn = %016I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("EndingVcn   = %016I64x\n", EndingVcn) );

    //
    //  First compute free count as if the entire run is already unallocated
    //  and the in the following loop we march through the mcb looking for
    //  actual allocation and decrementing the free count appropriately
    //

    FreeCount = (EndingVcn - StartingVcn) + 1;

    for (Vcn = StartingVcn; Vcn <= EndingVcn; Vcn = Vcn + RunSize) {

        //
        //  Lookup the mcb entry and if we get back false then we're overrun
        //  the mcb and therefore nothing else above it can be allocated.
        //

        if (!NtfsLookupNtfsMcbEntry( Mcb, Vcn, &Lcn, &RunSize, NULL, NULL, NULL, NULL )) {

            break;
        }

        //
        //  If the lcn we got back is not -1 then this run is actually already
        //  allocated, so first check if the run size puts us over the ending
        //  vcn and adjust as necessary and then decrement the free count
        //  by the run size
        //

        if (Lcn != UNUSED_LCN) {

            if (RunSize > ((EndingVcn - Vcn) + 1)) {

                RunSize = (EndingVcn - Vcn) + 1;
            }

            FreeCount = FreeCount - RunSize;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsScanMcbForRealClusterCount -> %016I64x\n", FreeCount) );

    return FreeCount;
}


//
//  Local support routine, only defined with ntfs debug version
//

#ifdef NTFSDBG

ULONG
NtfsDumpCachedMcbInformation (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine dumps out the cached bitmap information

Arguments:

    Vcb - Supplies the Vcb used by this operation

Return Value:

    ULONG - 1.

--*/

{
    DbgPrint("Dump BitMpSup Information, Vcb@ %08lx\n", Vcb);

    DbgPrint("TotalCluster: %016I64x\n", Vcb->TotalClusters);
    DbgPrint("FreeClusters: %016I64x\n", Vcb->FreeClusters);

    return 1;
}

#endif // NTFSDBG


//
//  The rest of this module implements the record allocation routines
//


VOID
NtfsInitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB DataScb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute,
    IN ULONG BytesPerRecord,
    IN ULONG ExtendGranularity,
    IN ULONG TruncateGranularity,
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    )

/*++

Routine Description:

    This routine initializes the record allocation context used for
    allocating and deallocating fixed sized records from a data stream.

    Note that the bitmap attribute size must always be at least a multiple
    of 32 bits.  However the data scb does not need to contain that many
    records.  If in the course of allocating a new record we discover that
    the data scb is too small we will then add allocation to the data scb.

Arguments:

    DataScb - Supplies the Scb representing the data stream that is being
        divided into fixed sized records with each bit in the bitmap corresponding
        to one record in the data stream

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  The attribute can either be resident or nonresident
        and this routine will handle both cases properly.

    BytesPerRecord - Supplies the size of the homogenous records that
        that the data stream is being divided into.

    ExtendGranularity - Supplies the number of records (i.e., allocation units
        to extend the data scb by each time).

    TruncateGranularity - Supplies the number of records to use when truncating
        the data scb.  That is if the end of the data stream contains the
        specified number of free records then we truncate.

    RecordAllocationContext - Supplies the memory for an context record that is
        utilized by this record allocation routines.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeRecordHeader;
    RTL_BITMAP Bitmap;

    ULONG ClearLength;
    ULONG ClearIndex;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( DataScb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeRecordAllocation\n") );

    ASSERT( BytesPerRecord * ExtendGranularity >= DataScb->Vcb->BytesPerCluster );
    ASSERT( BytesPerRecord * TruncateGranularity >= DataScb->Vcb->BytesPerCluster );

    //
    //  First zero out the context record except for the data scb.
    //

    RtlZeroMemory( &RecordAllocationContext->BitmapScb,
                   sizeof(RECORD_ALLOCATION_CONTEXT) -
                   FIELD_OFFSET( RECORD_ALLOCATION_CONTEXT, BitmapScb ));

    //
    //  And then set the fields in the context record that do not depend on
    //  whether the bitmap attribute is resident or not
    //

    RecordAllocationContext->DataScb = DataScb;
    RecordAllocationContext->BytesPerRecord = BytesPerRecord;
    RecordAllocationContext->ExtendGranularity = ExtendGranularity;
    RecordAllocationContext->TruncateGranularity = TruncateGranularity;

    //
    //  Set up our hint fields.
    //

    RecordAllocationContext->LowestDeallocatedIndex = MAXULONG;

    if (DataScb == DataScb->Vcb->MftScb) {

        RecordAllocationContext->StartingHint = FIRST_USER_FILE_NUMBER;

    } else {

        RecordAllocationContext->StartingHint = 0;
    }

    //
    //  Now get a reference to the bitmap record header and then take two
    //  different paths depending if the bitmap attribute is resident or not
    //

    AttributeRecordHeader = NtfsFoundAttribute(BitmapAttribute);

    if (NtfsIsAttributeResident(AttributeRecordHeader)) {

        ASSERTMSG("bitmap must be multiple quadwords", AttributeRecordHeader->Form.Resident.ValueLength % 8 == 0);

        //
        //  For a resident bitmap attribute the bitmap scb field is null and we
        //  set the bitmap size from the value length.  Also we will initialize
        //  our local bitmap variable and determine the number of free bits
        //  current available.
        //
        //

        RecordAllocationContext->BitmapScb = NULL;

        RecordAllocationContext->CurrentBitmapSize = 8 * AttributeRecordHeader->Form.Resident.ValueLength;

        RtlInitializeBitMap( &Bitmap,
                             (PULONG)NtfsAttributeValue( AttributeRecordHeader ),
                             RecordAllocationContext->CurrentBitmapSize );

        RecordAllocationContext->NumberOfFreeBits = RtlNumberOfClearBits( &Bitmap );

        ClearLength = RtlFindLastBackwardRunClear( &Bitmap,
                                                   RecordAllocationContext->CurrentBitmapSize - 1,
                                                   &ClearIndex );

    } else {

        UNICODE_STRING BitmapName;

        BOOLEAN ReturnedExistingScb;
        PBCB BitmapBcb;
        PVOID BitmapBuffer;

        ASSERTMSG("bitmap must be multiple quadwords", ((ULONG)AttributeRecordHeader->Form.Nonresident.FileSize) % 8 == 0);

        //
        //  For a non resident bitmap attribute we better have been given the
        //  record header for the first part and not somthing that has spilled
        //  into multiple segment records
        //

        ASSERT( AttributeRecordHeader->Form.Nonresident.LowestVcn == 0 );

        BitmapBcb = NULL;

        try {

            ULONG StartingByte;

            ULONG BitsThisPage;
            ULONG BytesThisPage;
            ULONG RemainingBytes;

            ULONG ThisClearIndex;
            ULONG ThisClearLength;

            //
            //  Create the bitmap scb for the bitmap attribute
            //

            BitmapName.MaximumLength =
                BitmapName.Length = AttributeRecordHeader->NameLength * sizeof( WCHAR );
            BitmapName.Buffer = Add2Ptr(AttributeRecordHeader, AttributeRecordHeader->NameOffset);

            RecordAllocationContext->BitmapScb = NtfsCreateScb( IrpContext,
                                                                DataScb->Fcb,
                                                                AttributeRecordHeader->TypeCode,
                                                                &BitmapName,
                                                                FALSE,
                                                                &ReturnedExistingScb );

            //
            //  Now determine the bitmap size, for now we'll only take bitmap attributes that are
            //  no more than 16 pages large.
            //

            RecordAllocationContext->CurrentBitmapSize = 8 * ((ULONG)AttributeRecordHeader->Form.Nonresident.FileSize);

            //
            //  Create the stream file if not present.
            //

            if (RecordAllocationContext->BitmapScb->FileObject == NULL) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   RecordAllocationContext->BitmapScb,
                                                   TRUE,
                                                   &NtfsInternalUseFile[INITIALIZERECORDALLOCATION_FILE_NUMBER] );
            }

            //
            //  Walk through each page of the bitmap and compute the number of set
            //  bits and the last set bit in the bitmap.
            //

            RecordAllocationContext->NumberOfFreeBits = 0;
            RemainingBytes = (ULONG) AttributeRecordHeader->Form.Nonresident.FileSize;
            StartingByte = 0;
            ClearLength = 0;

            while (TRUE) {

                BytesThisPage = RemainingBytes;

                if (RemainingBytes > PAGE_SIZE) {

                    BytesThisPage = PAGE_SIZE;
                }

                BitsThisPage = BytesThisPage * 8;

                //
                //  Now map the bitmap data, initialize our local bitmap variable and
                //  calculate the number of free bits currently available
                //

                NtfsUnpinBcb( IrpContext, &BitmapBcb );

                NtfsMapStream( IrpContext,
                               RecordAllocationContext->BitmapScb,
                               (LONGLONG)StartingByte,
                               BytesThisPage,
                               &BitmapBcb,
                               &BitmapBuffer );

                RtlInitializeBitMap( &Bitmap,
                                     BitmapBuffer,
                                     BitsThisPage );

                RecordAllocationContext->NumberOfFreeBits += RtlNumberOfClearBits( &Bitmap );

                //
                //  We are interested in remembering the last set bit in this bitmap.
                //  If the bitmap ends with a clear run then the last set bit is
                //  immediately prior to this clear run.  We need to check each page
                //  as we go through the bitmap to see if a clear run ends at the end
                //  of the current page.
                //

                ThisClearLength = RtlFindLastBackwardRunClear( &Bitmap,
                                                               BitsThisPage - 1,
                                                               &ThisClearIndex );

                //
                //  If there is a run and it ends at the end of the page then
                //  either combine with a previous run or remember that this is the
                //  start of the run.
                //

                if ((ThisClearLength != 0) &&
                    ((ThisClearLength + ThisClearIndex) == BitsThisPage)) {

                    //
                    //  If this is the entire page and the previous page ended
                    //  with a clear run then just extend that run.
                    //

                    if ((ThisClearIndex == 0) && (ClearLength != 0)) {

                        ClearLength += ThisClearLength;

                    //
                    //  Otherwise this is a new clear run.  Bias the starting index
                    //  by the bit offset of this page.
                    //

                    } else {

                        ClearLength = ThisClearLength;
                        ClearIndex = ThisClearIndex + (StartingByte * 8);
                    }

                //
                //  This page does not end with a clear run.
                //

                } else {

                    ClearLength = 0;
                }

                //
                //  If we are not at the end of the bitmap then update our
                //  counters.
                //

                if (RemainingBytes != BytesThisPage) {

                    StartingByte += PAGE_SIZE;
                    RemainingBytes -= PAGE_SIZE;

                } else {

                    break;
                }
            }

        } finally {

            DebugUnwind( NtfsInitializeRecordAllocation );

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
        }
    }

    //
    //  With ClearLength and ClearIndex we can now deduce the last set bit in the
    //  bitmap
    //

    if ((ClearLength != 0) && ((ClearLength + ClearIndex) == RecordAllocationContext->CurrentBitmapSize)) {

        RecordAllocationContext->IndexOfLastSetBit = ClearIndex - 1;

    } else {

        RecordAllocationContext->IndexOfLastSetBit = RecordAllocationContext->CurrentBitmapSize - 1;
    }

    DebugTrace( -1, Dbg, ("NtfsInitializeRecordAllocation -> VOID\n") );

    return;
}


VOID
NtfsUninitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    )

/*++

Routine Description:

    This routine is used to uninitialize the record allocation context.

Arguments:

    RecordAllocationContext - Supplies the record allocation context being
        decommissioned.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUninitializeRecordAllocation\n") );

    //
    //  And then for safe measure zero out the entire record except for the
    //  the data Scb.
    //

    RtlZeroMemory( &RecordAllocationContext->BitmapScb,
                   sizeof(RECORD_ALLOCATION_CONTEXT) -
                   FIELD_OFFSET( RECORD_ALLOCATION_CONTEXT, BitmapScb ));

    DebugTrace( -1, Dbg, ("NtfsUninitializeRecordAllocation -> VOID\n") );

    return;
}


ULONG
NtfsAllocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine is used to allocate a new record for the specified record
    allocation context.

    It will return the index of a free record in the data scb as denoted by
    the bitmap attribute.  If necessary this routine will extend the bitmap
    attribute size (including spilling over to the nonresident case), and
    extend the data scb size.

    On return the record is zeroed.

Arguments:

    RecordAllocationContext - Supplies the record allocation context used
        in this operation

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    ULONG - Returns the index of the record just allocated, zero based.

--*/

{
    PSCB DataScb;
    LONGLONG DataOffset;

    LONGLONG ClusterCount;

    ULONG BytesPerRecord;
    ULONG ExtendGranularity;
    ULONG TruncateGranularity;

    PULONG CurrentBitmapSize;
    PULONG NumberOfFreeBits;

    PSCB BitmapScb;
    PBCB BitmapBcb;
    RTL_BITMAP Bitmap;
    PUCHAR BitmapBuffer;
    ULONG BitmapOffset;
    ULONG BitmapIndex;
    ULONG BitmapSizeInBytes;
    ULONG BitmapCurrentOffset = 0;
    ULONG BitmapSizeInPages;

    BOOLEAN StuffAdded = FALSE;
    BOOLEAN Rescan;

    ULONG Hint;

    PVCB Vcb;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = RecordAllocationContext->DataScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        //
        //  Remember some values for convenience.
        //

        BytesPerRecord = RecordAllocationContext->BytesPerRecord;
        ExtendGranularity = RecordAllocationContext->ExtendGranularity;
        TruncateGranularity = RecordAllocationContext->TruncateGranularity;

        Vcb = DataScb->Vcb;

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        if ((RecordAllocationContext->BitmapScb == NULL) &&
            !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

            NtfsUninitializeRecordAllocation( IrpContext,
                                              RecordAllocationContext );

            RecordAllocationContext->CurrentBitmapSize = MAXULONG;
        }

        //
        //  Reinitialize the record context structure if necessary.
        //

        if (RecordAllocationContext->CurrentBitmapSize == MAXULONG) {

            NtfsInitializeRecordAllocation( IrpContext,
                                            DataScb,
                                            BitmapAttribute,
                                            BytesPerRecord,
                                            ExtendGranularity,
                                            TruncateGranularity,
                                            RecordAllocationContext );
        }

        BitmapScb = RecordAllocationContext->BitmapScb;
        CurrentBitmapSize = &RecordAllocationContext->CurrentBitmapSize;
        NumberOfFreeBits = &RecordAllocationContext->NumberOfFreeBits;

        BitmapSizeInBytes = *CurrentBitmapSize / 8;

        Hint = RecordAllocationContext->StartingHint;

        //
        //  We will do different operations based on whether the bitmap is resident or nonresident
        //  The first case we will handle is the resident bitmap.
        //

        if (BitmapScb == NULL) {

            BOOLEAN SizeExtended = FALSE;
            UCHAR NewByte;

            //
            //  Now now initialize the local bitmap variable and hunt for that free bit
            //

            BitmapBuffer = (PUCHAR) NtfsAttributeValue( NtfsFoundAttribute( BitmapAttribute ));

            RtlInitializeBitMap( &Bitmap,
                                 (PULONG)BitmapBuffer,
                                 *CurrentBitmapSize );

            StuffAdded = NtfsAddDeallocatedRecords( Vcb, DataScb, 0, &Bitmap );

            BitmapIndex = RtlFindClearBits( &Bitmap, 1, Hint );

            //
            //  Check if we have found a free record that can be allocated,  If not then extend
            //  the size of the bitmap by 64 bits, and set the index to the bit first bit
            //  of the extension we just added
            //

            if (BitmapIndex == 0xffffffff) {

                union {
                    QUAD Quad;
                    UCHAR Uchar[ sizeof(QUAD) ];
                } ZeroQuadWord;

                *(PLARGE_INTEGER)&(ZeroQuadWord.Uchar)[0] = Li0;

                NtfsChangeAttributeValue( IrpContext,
                                          DataScb->Fcb,
                                          BitmapSizeInBytes,
                                          &(ZeroQuadWord.Uchar)[0],
                                          sizeof( QUAD ),
                                          TRUE,
                                          TRUE,
                                          FALSE,
                                          TRUE,
                                          BitmapAttribute );

                BitmapIndex = *CurrentBitmapSize;
                *CurrentBitmapSize += BITMAP_EXTEND_GRANULARITY;
                *NumberOfFreeBits += BITMAP_EXTEND_GRANULARITY;

                BitmapSizeInBytes += (BITMAP_EXTEND_GRANULARITY / 8);

                SizeExtended = TRUE;

                //
                //  We now know that the byte value we should start with is 0
                //  We cannot safely access the bitmap attribute any more because
                //  it may have moved.
                //

                NewByte = 0;

            } else {

                //
                //  Capture the current value of the byte for the index if we
                //  are not extending.  Notice that we always take this from the
                //  unbiased original bitmap.
                //

                NewByte = BitmapBuffer[ BitmapIndex / 8 ];
            }

            //
            //  Check if we made the Bitmap go non-resident and if so then
            //  we will reinitialize the record allocation context and fall through
            //  to the non-resident case
            //

            if (SizeExtended && !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  RecordAllocationContext );

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                TruncateGranularity,
                                                RecordAllocationContext );

                BitmapScb = RecordAllocationContext->BitmapScb;

                ASSERT( BitmapScb != NULL );

                //
                //  Snapshot the bitmap in case we modify it later on - we automatically
                //  snapped the data scb when we acquired it above
                //

                NtfsSnapshotScb( IrpContext, BitmapScb );

            } else {

                //
                //  Index is now the free bit so set the bit in the bitmap and also change
                //  the byte containing the bit in the attribute.  Be careful to set the
                //  bit in the byte from the *original* bitmap, and not the one we merged
                //  the recently-deallocated bits with.
                //

                ASSERT( !FlagOn( NewByte, BitMask[BitmapIndex % 8]) );

                SetFlag( NewByte, BitMask[BitmapIndex % 8] );

                NtfsChangeAttributeValue( IrpContext,
                                          DataScb->Fcb,
                                          BitmapIndex / 8,
                                          &NewByte,
                                          1,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          BitmapAttribute );
            }

        } else {

            //
            //  Snapshot the bitmap in case we modify it later on - we automatically
            //  snapped the data scb when we acquired it above
            //

            NtfsSnapshotScb( IrpContext, BitmapScb );
        }

        //
        //  Use a loop here to handle the extreme case where extending the allocation
        //  of the volume bitmap causes us to renter this routine recursively.
        //  In that case the top level guy will fail expecting the first bit to
        //  be available in the added clusters.  Instead we will return to the
        //  top of this loop after extending the bitmap and just do our normal
        //  scan.
        //

        while (BitmapScb != NULL) {

            ULONG SizeToPin;
            ULONG HoleIndex;

            BitmapBcb = NULL;
            Rescan = FALSE;
            HoleIndex = 0;

            try {

                if (!FlagOn( BitmapScb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, BitmapScb, NULL );
                }

                //
                //  Snapshot the Scb values in case we change any of them.
                //

                NtfsSnapshotScb( IrpContext, BitmapScb );

                //
                //  Create the stream file if not present.
                //

                if (BitmapScb->FileObject == NULL) {

                    NtfsCreateInternalAttributeStream( IrpContext,
                                                       BitmapScb,
                                                       FALSE,
                                                       &NtfsInternalUseFile[DEALLOCATERECORD_FILE_NUMBER] );
                }

                //
                //  Remember the starting offset for the page containing the hint.
                //

                BitmapCurrentOffset = (Hint / 8) & ~(PAGE_SIZE - 1);
                Hint &= (BITS_PER_PAGE - 1);

                BitmapSizeInPages = (ULONG) ROUND_TO_PAGES( BitmapSizeInBytes );

                //
                //  Loop for the size of the bitmap plus one page, so that we will
                //  retry the initial page once starting from a hint offset of 0.
                //

                for (BitmapOffset = 0;
                     BitmapOffset <= BitmapSizeInPages;
                     BitmapOffset += PAGE_SIZE, BitmapCurrentOffset += PAGE_SIZE) {

                    ULONG LocalHint;

                    //
                    //  If our current position is past the end of the bitmap
                    //  then go to the beginning of the bitmap.
                    //

                    if (BitmapCurrentOffset >= BitmapSizeInBytes) {

                        BitmapCurrentOffset = 0;
                    }

                    //
                    //  If this is the Mft and there are more than the system
                    //  files in the first cluster of the Mft then move past
                    //  the first cluster.
                    //

                    if ((BitmapCurrentOffset == 0) &&
                        (DataScb == Vcb->MftScb) &&
                        (Vcb->FileRecordsPerCluster > FIRST_USER_FILE_NUMBER) &&
                        (Hint < Vcb->FileRecordsPerCluster)) {

                        Hint = Vcb->FileRecordsPerCluster;
                    }

                    //
                    //  Calculate the size to read from this point to the end of
                    //  bitmap, or a page, whichever is less.
                    //

                    SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

                    if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

                    //
                    //  Unpin any Bcb from a previous loop.
                    //

                    if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                    NtfsUnpinBcb( IrpContext, &BitmapBcb );

                    //
                    //  Read the desired bitmap page.
                    //

                    NtfsPinStream( IrpContext,
                                   BitmapScb,
                                   (LONGLONG)BitmapCurrentOffset,
                                   SizeToPin,
                                   &BitmapBcb,
                                   &BitmapBuffer );

                    //
                    //  Initialize the bitmap and search for a free bit.
                    //

                    RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToPin * 8 );

                    StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                            DataScb,
                                                            BitmapCurrentOffset * 8,
                                                            &Bitmap );

                    //
                    //  We make a loop here to test whether the index found is
                    //  within an Mft hole.  We will always use a hole last.
                    //

                    LocalHint = Hint;

                    while (TRUE) {

                        BitmapIndex = RtlFindClearBits( &Bitmap, 1, LocalHint );

                        //
                        //  If this is the Mft Scb then check if this is a hole.
                        //

                        if ((BitmapIndex != 0xffffffff) &&
                            (DataScb == Vcb->MftScb)) {

                            ULONG ThisIndex;
                            ULONG HoleCount;

                            ThisIndex = BitmapIndex + (BitmapCurrentOffset * 8);

                            if (NtfsIsMftIndexInHole( IrpContext,
                                                      Vcb,
                                                      ThisIndex,
                                                      &HoleCount )) {

                                //
                                //  There is a hole.  Save this index if we haven't
                                //  already saved one.  If we can't find an index
                                //  not part of a hole we will use this instead of
                                //  extending the file.
                                //

                                if (HoleIndex == 0) {

                                    HoleIndex = ThisIndex;
                                }

                                //
                                //  Now update the hint and try this page again
                                //  unless the reaches to the end of the page.
                                //

                                if (BitmapIndex + HoleCount < SizeToPin * 8) {

                                    //
                                    //  Bias the bitmap with these Mft holes
                                    //  so the bitmap package doesn't see
                                    //  them if it rescans from the
                                    //  start of the page.
                                    //

                                    if (!StuffAdded) {

                                        PVOID NewBuffer;

                                        NewBuffer = NtfsAllocatePool(PagedPool, SizeToPin );
                                        RtlCopyMemory( NewBuffer, Bitmap.Buffer, SizeToPin );
                                        Bitmap.Buffer = NewBuffer;
                                        StuffAdded = TRUE;
                                    }

                                    RtlSetBits( &Bitmap,
                                                BitmapIndex,
                                                HoleCount );

                                    LocalHint = BitmapIndex + HoleCount;
                                    continue;
                                }

                                //
                                //  Store a -1 in Index to show we don't have
                                //  anything yet.
                                //

                                BitmapIndex = 0xffffffff;
                            }
                        }

                        break;
                    }

                    //
                    //  If we found something, then leave the loop.
                    //

                    if (BitmapIndex != 0xffffffff) {

                        break;
                    }

                    //
                    //  If we get here, we could not find anything in the page of
                    //  the hint, so clear out the page offset from the hint.
                    //

                    Hint = 0;
                }

                //
                //  Now check if we have located a record that can be allocated,  If not then extend
                //  the size of the bitmap by 64 bits.
                //

                if (BitmapIndex == 0xffffffff) {

                    //
                    //  Cleanup from previous loop.
                    //

                    if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                    NtfsUnpinBcb( IrpContext, &BitmapBcb );

                    //
                    //  If we have a hole index it means that we found a free record but
                    //  it exists in a hole.  Let's go back to this page and set up
                    //  to fill in the hole.  We will do an unsafe test of the
                    //  defrag permitted flag.  This is OK here because once set it
                    //  will only go to the non-set state in order to halt
                    //  future defragging.
                    //

                    if ((HoleIndex != 0) && FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED )) {

                        //
                        //  Start by filling this hole.
                        //

                        NtfsCheckRecordStackUsage( IrpContext );
                        NtfsFillMftHole( IrpContext, Vcb, HoleIndex );

                        //
                        //  Since filling the Mft hole may cause us to allocate
                        //  a bit we will go back to the start of the routine
                        //  and scan starting from the hole we just filled in.
                        //

                        Hint = HoleIndex;
                        Rescan = TRUE;
                        try_return( NOTHING );

                    } else {

                        //
                        //  Allocate the first bit past the end of the bitmap.
                        //

                        BitmapIndex = *CurrentBitmapSize & (BITS_PER_PAGE - 1);

                        //
                        //  Now advance the sizes and calculate the size in bytes to
                        //  read.
                        //

                        *CurrentBitmapSize += BITMAP_EXTEND_GRANULARITY;
                        *NumberOfFreeBits += BITMAP_EXTEND_GRANULARITY;

                        //
                        //  Calculate the size to read from this point to the end of
                        //  bitmap.
                        //

                        BitmapSizeInBytes += BITMAP_EXTEND_GRANULARITY / 8;

                        BitmapCurrentOffset = BitmapScb->Header.FileSize.LowPart & ~(PAGE_SIZE - 1);

                        SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

                        //
                        //  Check for allocation first.
                        //

                        if (BitmapScb->Header.AllocationSize.LowPart < BitmapSizeInBytes) {

                            //
                            //  Calculate number of clusters to next page boundary, and allocate
                            //  that much.
                            //

                            ClusterCount = ((BitmapSizeInBytes + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));

                            ClusterCount = LlClustersFromBytes( Vcb,
                                                                ((ULONG) ClusterCount - BitmapScb->Header.AllocationSize.LowPart) );

                            NtfsCheckRecordStackUsage( IrpContext );
                            NtfsAddAllocation( IrpContext,
                                               BitmapScb->FileObject,
                                               BitmapScb,
                                               LlClustersFromBytes( Vcb,
                                                                    BitmapScb->Header.AllocationSize.QuadPart ),
                                               ClusterCount,
                                               FALSE,
                                               NULL );
                        }

                        //
                        //  Tell the cache manager about the new file size.
                        //

                        BitmapScb->Header.FileSize.QuadPart = BitmapSizeInBytes;

                        CcSetFileSizes( BitmapScb->FileObject,
                                        (PCC_FILE_SIZES)&BitmapScb->Header.AllocationSize );

                        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                        //
                        //  Read the desired bitmap page.
                        //

                        NtfsPinStream( IrpContext,
                                       BitmapScb,
                                       (LONGLONG) BitmapCurrentOffset,
                                       SizeToPin,
                                       &BitmapBcb,
                                       &BitmapBuffer );

                        //
                        //  If we have just moved to the next page of the bitmap then
                        //  set this page dirty so it doesn't leave memory while we
                        //  twiddle valid data length.  Otherwise it will be reread after
                        //  we advance valid data and we will get garbage data from the
                        //  disk.
                        //

                        if (FlagOn( BitmapSizeInBytes, PAGE_SIZE - 1 ) <= BITMAP_EXTEND_GRANULARITY / 8) {

                            *((volatile ULONG *) BitmapBuffer) = *((PULONG) BitmapBuffer);
                            CcSetDirtyPinnedData( BitmapBcb, NULL );
                        }

                        //
                        //  Initialize the bitmap.
                        //

                        RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToPin * 8 );

                        //
                        //  Now look up a free bit in this page.  We don't trust
                        //  the index we already had since growing the MftBitmap
                        //  allocation may have caused another bit in the bitmap
                        //  to be set.
                        //

                        BitmapIndex = RtlFindClearBits( &Bitmap, 1, BitmapIndex );

                        //
                        //  Update the ValidDataLength, now that we have read (and possibly
                        //  zeroed) the page.
                        //

                        BitmapScb->Header.ValidDataLength.QuadPart = BitmapSizeInBytes;

                        NtfsWriteFileSizes( IrpContext,
                                            BitmapScb,
                                            &BitmapScb->Header.ValidDataLength.QuadPart,
                                            TRUE,
                                            TRUE,
                                            TRUE );
                    }
                }

                //
                //  We can only make this check if it is not restart, because we have
                //  no idea whether the update is applied or not.  Raise corrupt if
                //  the bits are not clear to prevent double allocation.
                //

                if (!RtlAreBitsClear( &Bitmap, BitmapIndex, 1 )) {

                    ASSERTMSG("Cannot set bits that are not clear ", FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  Set the bit by calling the same routine used at restart.
                //  But first check if we should revert back to the orginal bitmap
                //  buffer.
                //

                if (StuffAdded) {

                    NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE;

                    Bitmap.Buffer = (PULONG) BitmapBuffer;
                }

                //
                //  Now log this change as well.
                //

                {
                    BITMAP_RANGE BitmapRange;

                    BitmapRange.BitMapOffset = BitmapIndex;
                    BitmapRange.NumberOfBits = 1;

                    (VOID) NtfsWriteLog( IrpContext,
                                         BitmapScb,
                                         BitmapBcb,
                                         SetBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         ClearBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         BitmapCurrentOffset,
                                         0,
                                         0,
                                         SizeToPin );

                    NtfsRestartSetBitsInBitMap( IrpContext,
                                                &Bitmap,
                                                BitmapIndex,
                                                1 );
                }

            try_exit:  NOTHING;
            } finally {

                DebugUnwind( NtfsAllocateRecord );

                //
                //  Reinitialize the context on any error.
                //

                if (AbnormalTermination()) {
                    RecordAllocationContext->CurrentBitmapSize = MAXULONG;
                }

                if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                NtfsUnpinBcb( IrpContext, &BitmapBcb );
            }

            //
            //  If we added Mft allocation then go to the top of the loop.
            //

            if (Rescan) { continue; }

            //
            //  The Index at this point is actually relative, so convert it to absolute
            //  before rejoining common code.
            //

            BitmapIndex += (BitmapCurrentOffset * 8);

            //
            //  Always break out in the normal case.
            //

            break;
        }

        //
        //  Now that we've located an index we can subtract the number of free bits in the bitmap
        //

        *NumberOfFreeBits -= 1;

        //
        //  Check if we need to extend the data stream.
        //

        DataOffset = UInt32x32To64( BitmapIndex + 1, BytesPerRecord );

        //
        //  Now check if we are extending the file.  We update the file size and
        //  valid data now.
        //

        if (DataOffset > DataScb->Header.FileSize.QuadPart) {

            //
            //  Check for allocation first.
            //

            if (DataOffset > DataScb->Header.AllocationSize.QuadPart) {

                //
                //  We want to allocate up to the next extend granularity
                //  boundary.
                //

                ClusterCount = UInt32x32To64( (BitmapIndex + ExtendGranularity) & ~(ExtendGranularity - 1),
                                              BytesPerRecord );

                ClusterCount -= DataScb->Header.AllocationSize.QuadPart;
                ClusterCount = LlClustersFromBytesTruncate( Vcb, ClusterCount );

                NtfsCheckRecordStackUsage( IrpContext );
                NtfsAddAllocation( IrpContext,
                                   DataScb->FileObject,
                                   DataScb,
                                   LlClustersFromBytes( Vcb,
                                                        DataScb->Header.AllocationSize.QuadPart ),
                                   ClusterCount,
                                   FALSE,
                                   NULL );
            }

            DataScb->Header.FileSize.QuadPart = DataOffset;
            DataScb->Header.ValidDataLength.QuadPart = DataOffset;

            NtfsWriteFileSizes( IrpContext,
                                DataScb,
                                &DataScb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );

            //
            //  Tell the cache manager about the new file size.
            //

            CcSetFileSizes( DataScb->FileObject,
                            (PCC_FILE_SIZES)&DataScb->Header.AllocationSize );

        //
        //  If we didn't extend the file then we have used a free file record in the file.
        //  Update our bookeeping count for free file records.
        //

        } else if (DataScb == Vcb->MftScb) {

            DataScb->ScbType.Mft.FreeRecordChange -= 1;
            Vcb->MftFreeRecords -= 1;
        }

        //
        //  Now determine if we extended the index of the last set bit
        //

        if ((LONG)BitmapIndex > RecordAllocationContext->IndexOfLastSetBit) {

            RecordAllocationContext->IndexOfLastSetBit = BitmapIndex;
        }

        NtfsReleaseScb( IrpContext, DataScb );

    } finally {

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }
    }

    //
    //  Update our hint with this value.
    //

    RecordAllocationContext->StartingHint = BitmapIndex;

    //
    //  We shouldn't allocate within the same byte as the reserved index for
    //  the Mft.
    //

    ASSERT( (DataScb != DataScb->Vcb->MftScb) ||
            ((BitmapIndex & ~7) != (DataScb->ScbType.Mft.ReservedIndex & ~7)) );

    DebugTrace( -1, Dbg, ("NtfsAllocateRecord -> %08lx\n", BitmapIndex) );

    return BitmapIndex;
}


VOID
NtfsDeallocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine is used to deallocate a record from the specified record
    allocation context.

    If necessary this routine will also shrink the bitmap attribute and
    the data scb (according to the truncation granularity used to initialize
    the allocation context).

Arguments:

    RecordAllocationContext - Supplies the record allocation context used
        in this operation

    Index - Supplies the index of the record to deallocate, zero based.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    None.

--*/

{
    PSCB DataScb;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace( +1, Dbg, ("NtfsDeallocateRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = RecordAllocationContext->DataScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        PVCB Vcb;
        PSCB BitmapScb;

        RTL_BITMAP Bitmap;

        PLONG IndexOfLastSetBit;
        ULONG BytesPerRecord;
        ULONG TruncateGranularity;

        ULONG ClearIndex;
        ULONG BitmapOffset = 0;

        Vcb = DataScb->Vcb;

        {
            ULONG ExtendGranularity;

            //
            //  Remember the current values in the record context structure.
            //

            BytesPerRecord = RecordAllocationContext->BytesPerRecord;
            TruncateGranularity = RecordAllocationContext->TruncateGranularity;
            ExtendGranularity = RecordAllocationContext->ExtendGranularity;

            //
            //  See if someone made the bitmap nonresident, and we still think
            //  it is resident.  If so, we must uninitialize and insure reinitialization
            //  below.
            //

            if ((RecordAllocationContext->BitmapScb == NULL)
                && !NtfsIsAttributeResident(NtfsFoundAttribute(BitmapAttribute))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  RecordAllocationContext );

                RecordAllocationContext->CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (RecordAllocationContext->CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                TruncateGranularity,
                                                RecordAllocationContext );
            }
        }

        BitmapScb = RecordAllocationContext->BitmapScb;
        IndexOfLastSetBit = &RecordAllocationContext->IndexOfLastSetBit;

        //
        //  We will do different operations based on whether the bitmap is resident or nonresident
        //  The first case will handle the resident bitmap
        //

        if (BitmapScb == NULL) {

            UCHAR NewByte;

            //
            //  Initialize the local bitmap
            //

            RtlInitializeBitMap( &Bitmap,
                                 (PULONG)NtfsAttributeValue( NtfsFoundAttribute( BitmapAttribute )),
                                 RecordAllocationContext->CurrentBitmapSize );

            //
            //  And clear the indicated bit, and also change the byte containing the bit in the
            //  attribute
            //

            NewByte = ((PUCHAR)Bitmap.Buffer)[ Index / 8 ];

            ASSERT( FlagOn( NewByte, BitMask[Index % 8]) );

            ClearFlag( NewByte, BitMask[Index % 8] );

            NtfsChangeAttributeValue( IrpContext,
                                      DataScb->Fcb,
                                      Index / 8,
                                      &NewByte,
                                      1,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      BitmapAttribute );

            //
            //  Now if the bit set just cleared is the same as the index for the last set bit
            //  then we must compute a new last set bit
            //

            if (Index == (ULONG)*IndexOfLastSetBit) {

                RtlFindLastBackwardRunClear( &Bitmap, Index, &ClearIndex );
            }

        } else {

            PBCB BitmapBcb = NULL;

            try {

                ULONG RelativeIndex;
                ULONG SizeToPin;

                PVOID BitmapBuffer;

                //
                //  Snapshot the Scb values in case we change any of them.
                //

                if (!FlagOn( BitmapScb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, BitmapScb, NULL );
                }

                NtfsSnapshotScb( IrpContext, BitmapScb );

                //
                //  Create the stream file if not present.
                //

                if (BitmapScb->FileObject == NULL) {

                    NtfsCreateInternalAttributeStream( IrpContext,
                                                       BitmapScb,
                                                       FALSE,
                                                       &NtfsInternalUseFile[DEALLOCATERECORD_FILE_NUMBER] );
                }

                //
                //  Calculate offset and relative index of the bit we will deallocate,
                //  from the nearest page boundary.
                //

                BitmapOffset = Index /8 & ~(PAGE_SIZE - 1);
                RelativeIndex = Index & (BITS_PER_PAGE - 1);

                //
                //  Calculate the size to read from this point to the end of
                //  bitmap.
                //

                SizeToPin = (RecordAllocationContext->CurrentBitmapSize / 8) - BitmapOffset;

                if (SizeToPin > PAGE_SIZE) {

                    SizeToPin = PAGE_SIZE;
                }

                NtfsPinStream( IrpContext,
                               BitmapScb,
                               BitmapOffset,
                               SizeToPin,
                               &BitmapBcb,
                               &BitmapBuffer );

                RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToPin * 8 );

                //
                //  We can only make this check if it is not restart, because we have
                //  no idea whether the update is applied or not.  Raise corrupt if
                //  we are trying to clear bits which aren't set.
                //

                if (!RtlAreBitsSet( &Bitmap, RelativeIndex, 1 )) {

                    ASSERTMSG("Cannot clear bits that are not set ", FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  Now log this change as well.
                //

                {
                    BITMAP_RANGE BitmapRange;

                    BitmapRange.BitMapOffset = RelativeIndex;
                    BitmapRange.NumberOfBits = 1;

                    (VOID) NtfsWriteLog( IrpContext,
                                         BitmapScb,
                                         BitmapBcb,
                                         ClearBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         SetBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         BitmapOffset,
                                         0,
                                         0,
                                         SizeToPin );
                }

                //
                //  Clear the bit by calling the same routine used at restart.
                //

                NtfsRestartClearBitsInBitMap( IrpContext,
                                              &Bitmap,
                                              RelativeIndex,
                                              1 );

                //
                //  Now if the bit set just cleared is the same as the index for the last set bit
                //  then we must compute a new last set bit
                //

                if (Index == (ULONG)*IndexOfLastSetBit) {

                    ULONG ClearLength;

                    ClearLength = RtlFindLastBackwardRunClear( &Bitmap, RelativeIndex, &ClearIndex );

                    //
                    //  If the last page of the bitmap is clear, then loop to
                    //  find the first set bit in the previous page(s).
                    //  When we reach the first page then we exit.  The ClearBit
                    //  value will be 0.
                    //

                    while ((ClearLength == (RelativeIndex + 1)) &&
                           (BitmapOffset != 0)) {

                        BitmapOffset -= PAGE_SIZE;
                        RelativeIndex = BITS_PER_PAGE - 1;

                        NtfsUnpinBcb( IrpContext, &BitmapBcb );


                        NtfsMapStream( IrpContext,
                                       BitmapScb,
                                       BitmapOffset,
                                       PAGE_SIZE,
                                       &BitmapBcb,
                                       &BitmapBuffer );

                        RtlInitializeBitMap( &Bitmap, BitmapBuffer, BITS_PER_PAGE );

                        ClearLength = RtlFindLastBackwardRunClear( &Bitmap, RelativeIndex, &ClearIndex );
                    }
                }

            } finally {

                DebugUnwind( NtfsDeallocateRecord );

                NtfsUnpinBcb( IrpContext, &BitmapBcb );
            }
        }

        RecordAllocationContext->NumberOfFreeBits += 1;

        //
        //  Now decide if we need to truncate the allocation.  First check if we need to
        //  set the last set bit index and then check if the new last set bit index is
        //  small enough that we should now truncate the allocation.  We will truncate
        //  if the last set bit index plus the trucate granularity is smaller than
        //  the current number of records in the data scb.
        //
        //  ****    For now, we will not truncate the Mft, since we do not synchronize
        //          reads and writes, and a truncate can collide with the Lazy Writer.
        //

        if (Index == (ULONG)*IndexOfLastSetBit) {

            *IndexOfLastSetBit = ClearIndex - 1 + (BitmapOffset * 8);

            if ((DataScb != Vcb->MftScb) &&
                (DataScb->Header.AllocationSize.QuadPart >
                   Int32x32To64( *IndexOfLastSetBit + 1 + TruncateGranularity, BytesPerRecord ))) {

                VCN StartingVcn;
                LONGLONG EndOfIndexOffset;
                LONGLONG TruncatePoint;

                //
                //  We can get into a situation where there is so much extra allocation that
                //  we can't delete it without overflowing the log file.  We can't perform
                //  checkpoints in this path so we will forget about truncating in
                //  this path unless this is the first truncate of the data scb.  We
                //  only deallocate a small piece of the allocation.
                //

                TruncatePoint =
                EndOfIndexOffset = Int32x32To64( *IndexOfLastSetBit + 1, BytesPerRecord );

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL )) {

                    //
                    //  Use a fudge factor of 8 to allow for the overused bits in
                    //  the snapshot allocation field.
                    //

                    if (DataScb->Header.AllocationSize.QuadPart + 8 >= DataScb->ScbSnapshot->AllocationSize) {

                        TruncatePoint = DataScb->Header.AllocationSize.QuadPart - (MAXIMUM_RUNS_AT_ONCE * Vcb->BytesPerCluster);

                        if (TruncatePoint < EndOfIndexOffset) {

                            TruncatePoint = EndOfIndexOffset;
                        }

                    } else {

                        TruncatePoint = DataScb->Header.AllocationSize.QuadPart;
                    }
                }

                //
                //  Force deleted piece to flush first so dirty page dumps are
                //  accurate. This is only neccessary for indexes
                //

                if (DataScb->AttributeTypeCode == $INDEX_ALLOCATION ) {

                    ASSERT( DataScb->Header.PagingIoResource == NULL );

                    CcFlushCache( &DataScb->NonpagedScb->SegmentObject, (PLARGE_INTEGER)&TruncatePoint, (ULONG)(DataScb->Header.FileSize.QuadPart - TruncatePoint), &Iosb );
                    NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );
                }



                StartingVcn = LlClustersFromBytes( Vcb, TruncatePoint );

                NtfsDeleteAllocation( IrpContext,
                                      DataScb->FileObject,
                                      DataScb,
                                      StartingVcn,
                                      MAXLONGLONG,
                                      TRUE,
                                      FALSE );

                //
                //  Now truncate the file sizes to the end of the last allocated record.
                //

                DataScb->Header.ValidDataLength.QuadPart =
                DataScb->Header.FileSize.QuadPart = EndOfIndexOffset;

                NtfsWriteFileSizes( IrpContext,
                                    DataScb,
                                    &DataScb->Header.ValidDataLength.QuadPart,
                                    FALSE,
                                    TRUE,
                                    TRUE );

                //
                //  Tell the cache manager about the new file size.
                //

                CcSetFileSizes( DataScb->FileObject,
                                (PCC_FILE_SIZES)&DataScb->Header.AllocationSize );

                //
                //  We have truncated the index stream.  Update the change count
                //  so that we won't trust any cached index entry information.
                //

                DataScb->ScbType.Index.ChangeCount += 1;
            }
        }

        //
        //  As our final task we need to add this index to the recently deallocated
        //  queues for the Scb and the Irp Context.  First scan through the IrpContext queue
        //  looking for a matching Scb.  I do don't find one then we allocate a new one and insert
        //  it in the appropriate queues and lastly we add our index to the entry
        //

        {
            PDEALLOCATED_RECORDS DeallocatedRecords;
            PLIST_ENTRY Links;

            //
            //  After the following loop either we've found an existing record in the irp context
            //  queue for the appropriate scb or deallocated records is null and we know we need
            //  to create a record
            //

            DeallocatedRecords = NULL;
            for (Links = IrpContext->RecentlyDeallocatedQueue.Flink;
                 Links != &IrpContext->RecentlyDeallocatedQueue;
                 Links = Links->Flink) {

                DeallocatedRecords = CONTAINING_RECORD( Links, DEALLOCATED_RECORDS, IrpContextLinks );

                if (DeallocatedRecords->Scb == DataScb) {

                    break;
                }

                DeallocatedRecords = NULL;
            }

            //
            //  If we need to create a new record then allocate a record and insert it in both queues
            //  and initialize its other fields
            //

            if (DeallocatedRecords == NULL) {

                DeallocatedRecords = (PDEALLOCATED_RECORDS)ExAllocateFromPagedLookasideList( &NtfsDeallocatedRecordsLookasideList );
                InsertTailList( &DataScb->ScbType.Index.RecentlyDeallocatedQueue, &DeallocatedRecords->ScbLinks );
                InsertTailList( &IrpContext->RecentlyDeallocatedQueue, &DeallocatedRecords->IrpContextLinks );
                DeallocatedRecords->Scb = DataScb;
                DeallocatedRecords->NumberOfEntries = DEALLOCATED_RECORD_ENTRIES;
                DeallocatedRecords->NextFreeEntry = 0;
            }

            //
            //  At this point deallocated records points to a record that we are to fill in.
            //  We need to check whether there is space to add this entry.  Otherwise we need
            //  to allocate a larger deallocated record structure from pool.
            //

            if (DeallocatedRecords->NextFreeEntry == DeallocatedRecords->NumberOfEntries) {

                PDEALLOCATED_RECORDS NewDeallocatedRecords;
                ULONG BytesInEntryArray;

                //
                //  Double the number of entries in the current structure and
                //  allocate directly from pool.
                //

                BytesInEntryArray = 2 * DeallocatedRecords->NumberOfEntries * sizeof( ULONG );
                NewDeallocatedRecords = NtfsAllocatePool( PagedPool,
                                                           DEALLOCATED_RECORDS_HEADER_SIZE + BytesInEntryArray );
                RtlZeroMemory( NewDeallocatedRecords, DEALLOCATED_RECORDS_HEADER_SIZE + BytesInEntryArray );

                //
                //  Initialize the structure by copying the existing structure.  Then
                //  update the number of entries field.
                //

                RtlCopyMemory( NewDeallocatedRecords,
                               DeallocatedRecords,
                               DEALLOCATED_RECORDS_HEADER_SIZE + (BytesInEntryArray / 2) );

                NewDeallocatedRecords->NumberOfEntries = DeallocatedRecords->NumberOfEntries * 2;

                //
                //  Remove the previous structure from the list and insert the new structure.
                //

                RemoveEntryList( &DeallocatedRecords->ScbLinks );
                RemoveEntryList( &DeallocatedRecords->IrpContextLinks );

                InsertTailList( &DataScb->ScbType.Index.RecentlyDeallocatedQueue,
                                &NewDeallocatedRecords->ScbLinks );
                InsertTailList( &IrpContext->RecentlyDeallocatedQueue,
                                &NewDeallocatedRecords->IrpContextLinks );

                //
                //  Deallocate the previous structure and use the new structure in its place.
                //

                if (DeallocatedRecords->NumberOfEntries == DEALLOCATED_RECORD_ENTRIES) {

                    ExFreeToPagedLookasideList( &NtfsDeallocatedRecordsLookasideList, DeallocatedRecords );

                } else {

                    NtfsFreePool( DeallocatedRecords );
                }

                DeallocatedRecords = NewDeallocatedRecords;
            }

            ASSERT( DeallocatedRecords->NextFreeEntry < DeallocatedRecords->NumberOfEntries );

            DeallocatedRecords->Index[DeallocatedRecords->NextFreeEntry] = Index;
            DeallocatedRecords->NextFreeEntry += 1;
        }

    } finally {

        NtfsReleaseScb( IrpContext, DataScb );
    }

    //
    //  Check if this is the lowest index we've deallocated.  It will be a future starting
    //  hint if so.
    //

    if (RecordAllocationContext->LowestDeallocatedIndex > Index) {

        RecordAllocationContext->LowestDeallocatedIndex = Index;
    }

    DebugTrace( -1, Dbg, ("NtfsDeallocateRecord -> VOID\n") );

    return;
}


VOID
NtfsReserveMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine reserves a record, without actually allocating it, so that the
    record may be allocated later via NtfsAllocateReservedRecord.  This support
    is used, for example, to reserve a record for describing Mft extensions in
    the current Mft mapping.  Only one record may be reserved at a time.

    Note that even though the reserved record number is returned, it may not
    be used until it is allocated.

Arguments:

    Vcb - This is the Vcb for the volume.  We update flags in the Vcb on
        completion of this operation.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    None - We update the Vcb and MftScb during this operation.

--*/

{
    PSCB DataScb;

    RTL_BITMAP Bitmap;

    BOOLEAN StuffAdded = FALSE;
    PBCB BitmapBcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReserveMftRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = Vcb->MftScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        PSCB BitmapScb;
        PULONG CurrentBitmapSize;
        ULONG BitmapSizeInBytes;
        LONGLONG EndOfIndexOffset;
        LONGLONG ClusterCount;

        ULONG Index;
        ULONG BitOffset;
        PVOID BitmapBuffer;
        UCHAR BitmapByte = 0;

        ULONG SizeToPin;

        ULONG BitmapCurrentOffset;

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        {
            ULONG BytesPerRecord = DataScb->ScbType.Index.RecordAllocationContext.BytesPerRecord;
            ULONG ExtendGranularity = DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity;

            if ((DataScb->ScbType.Index.RecordAllocationContext.BitmapScb == NULL) &&
                !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &DataScb->ScbType.Index.RecordAllocationContext );

                DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                ExtendGranularity,
                                                &DataScb->ScbType.Index.RecordAllocationContext );
            }
        }

        BitmapScb = DataScb->ScbType.Index.RecordAllocationContext.BitmapScb;
        CurrentBitmapSize = &DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize;
        BitmapSizeInBytes = *CurrentBitmapSize / 8;

        //
        //  Snapshot the bitmap before possibly modifying it - we own it exclusive through
        //  the data scb since they share the same resource but have not snapped it before
        //

        NtfsSnapshotScb( IrpContext, BitmapScb );

        //
        //  Loop through the entire bitmap.  We always start from the first user
        //  file number as our starting point.
        //

        BitOffset = FIRST_USER_FILE_NUMBER;

        for (BitmapCurrentOffset = 0;
             BitmapCurrentOffset < BitmapSizeInBytes;
             BitmapCurrentOffset += PAGE_SIZE) {

            //
            //  Calculate the size to read from this point to the end of
            //  bitmap, or a page, whichever is less.
            //

            SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

            if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

            //
            //  Unpin any Bcb from a previous loop.
            //

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Read the desired bitmap page.
            //

            NtfsMapStream( IrpContext,
                           BitmapScb,
                           BitmapCurrentOffset,
                           SizeToPin,
                           &BitmapBcb,
                           &BitmapBuffer );

            //
            //  Initialize the bitmap and search for a free bit.
            //

            RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToPin * 8 );

            StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                    DataScb,
                                                    BitmapCurrentOffset * 8,
                                                    &Bitmap );

            Index = RtlFindClearBits( &Bitmap, 1, BitOffset );

            //
            //  If we found something, then leave the loop.
            //

            if (Index != 0xffffffff) {

                //
                //  Remember the byte containing the reserved index.
                //

                BitmapByte = ((PCHAR) Bitmap.Buffer)[Index / 8];

                break;
            }

            //
            //  For each subsequent page the page offset is zero.
            //

            BitOffset = 0;
        }

        //
        //  Now check if we have located a record that can be allocated,  If not then extend
        //  the size of the bitmap by 64 bits.
        //

        if (Index == 0xffffffff) {

            //
            //  Cleanup from previous loop.
            //

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Calculate the page offset for the next page to pin.
            //

            BitmapCurrentOffset = BitmapSizeInBytes & ~(PAGE_SIZE - 1);

            //
            //  Calculate the index of next file record to allocate.
            //

            Index = *CurrentBitmapSize;

            //
            //  Now advance the sizes and calculate the size in bytes to
            //  read.
            //

            *CurrentBitmapSize += BITMAP_EXTEND_GRANULARITY;
            DataScb->ScbType.Index.RecordAllocationContext.NumberOfFreeBits += BITMAP_EXTEND_GRANULARITY;

            //
            //  Calculate the new size of the bitmap in bits and check if we must grow
            //  the allocation.
            //

            BitmapSizeInBytes = *CurrentBitmapSize / 8;

            //
            //  Check for allocation first.
            //

            if (BitmapScb->Header.AllocationSize.LowPart < BitmapSizeInBytes) {

                //
                //  Calculate number of clusters to next page boundary, and allocate
                //  that much.
                //

                ClusterCount = ((BitmapSizeInBytes + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));

                ClusterCount = LlClustersFromBytes( Vcb,
                                                    ((ULONG) ClusterCount - BitmapScb->Header.AllocationSize.LowPart) );

                NtfsAddAllocation( IrpContext,
                                   BitmapScb->FileObject,
                                   BitmapScb,
                                   LlClustersFromBytes( Vcb,
                                                        BitmapScb->Header.AllocationSize.QuadPart ),
                                   ClusterCount,
                                   FALSE,
                                   NULL );
            }

            //
            //  Tell the cache manager about the new file size.
            //

            BitmapScb->Header.FileSize.QuadPart = BitmapSizeInBytes;

            CcSetFileSizes( BitmapScb->FileObject,
                            (PCC_FILE_SIZES)&BitmapScb->Header.AllocationSize );

            //
            //  Now read the page in and mark it dirty so that any new range will
            //  be zeroed.
            //

            SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

            if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

            NtfsPinStream( IrpContext,
                           BitmapScb,
                           BitmapCurrentOffset,
                           SizeToPin,
                           &BitmapBcb,
                           &BitmapBuffer );

            CcSetDirtyPinnedData( BitmapBcb, NULL );

            //
            //  Update the ValidDataLength, now that we have read (and possibly
            //  zeroed) the page.
            //

            BitmapScb->Header.ValidDataLength.LowPart = BitmapSizeInBytes;

            NtfsWriteFileSizes( IrpContext,
                                BitmapScb,
                                &BitmapScb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );

        } else {

            //
            //  The Index at this point is actually relative, so convert it to absolute
            //  before rejoining common code.
            //

            Index += (BitmapCurrentOffset * 8);
        }

        //
        //  We now have an index.  There are three possible states for the file
        //  record corresponding to this index within the Mft.  They are:
        //
        //      - File record could lie beyond the current end of the file.
        //          There is nothing to do in this case.
        //
        //      - File record is part of a hole in the Mft.  In that case
        //          we allocate space for it bring it into memory.
        //
        //      - File record is already within allocated space.  There is nothing
        //          to do in that case.
        //
        //  We store the index as our reserved index and update the Vcb flags.  If
        //  the hole filling operation fails then the RestoreScbSnapshots routine
        //  will clear these values.
        //

        DataScb->ScbType.Mft.ReservedIndex = Index;

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        SetFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );
        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        if (NtfsIsMftIndexInHole( IrpContext, Vcb, Index, NULL )) {

            //
            //  Make sure nothing is left pinned in the bitmap.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Try to fill the hole in the Mft.  We will have this routine
            //  raise if unable to fill in the hole.
            //

            NtfsFillMftHole( IrpContext, Vcb, Index );
        }

        //
        //  At this point we have the index to reserve and the value of the
        //  byte in the bitmap which contains this bit.  We make sure the
        //  Mft includes the allocation for this index and the other
        //  bits within the same byte.  This is so we can uninitialize these
        //  file records so chkdsk won't look at stale data.
        //

        EndOfIndexOffset = LlBytesFromFileRecords( Vcb, (Index + 8) & ~(7));

        //
        //  Now check if we are extending the file.  We update the file size and
        //  valid data now.
        //

        if (EndOfIndexOffset > DataScb->Header.FileSize.QuadPart) {

            ULONG AddedFileRecords;
            ULONG CurrentIndex;

            //
            //  Check for allocation first.
            //

            if (EndOfIndexOffset > DataScb->Header.AllocationSize.QuadPart) {

                ClusterCount = ((Index + DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity) &
                                ~(DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity - 1));

                ClusterCount = LlBytesFromFileRecords( Vcb, (ULONG) ClusterCount );

                ClusterCount = LlClustersFromBytesTruncate( Vcb,
                                                            ClusterCount - DataScb->Header.AllocationSize.QuadPart );

                NtfsAddAllocation( IrpContext,
                                   DataScb->FileObject,
                                   DataScb,
                                   LlClustersFromBytes( Vcb,
                                                        DataScb->Header.AllocationSize.QuadPart ),
                                   ClusterCount,
                                   FALSE,
                                   NULL );
            }

            //
            //  Now we have to figure out how many file records we will be
            //  adding and the index of the first record being added.
            //

            CurrentIndex = (ULONG) LlFileRecordsFromBytes( Vcb, DataScb->Header.FileSize.QuadPart );
            AddedFileRecords = (ULONG) (EndOfIndexOffset - DataScb->Header.FileSize.QuadPart);
            AddedFileRecords = FileRecordsFromBytes( Vcb, AddedFileRecords );

            DataScb->Header.FileSize.QuadPart = EndOfIndexOffset;
            DataScb->Header.ValidDataLength.QuadPart = EndOfIndexOffset;

            NtfsWriteFileSizes( IrpContext,
                                DataScb,
                                &DataScb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );

            //
            //  Tell the cache manager about the new file size.
            //

            CcSetFileSizes( DataScb->FileObject,
                            (PCC_FILE_SIZES)&DataScb->Header.AllocationSize );

            //
            //  Update our bookeeping to reflect the number of file records
            //  added.
            //

            DataScb->ScbType.Mft.FreeRecordChange += AddedFileRecords;
            Vcb->MftFreeRecords += AddedFileRecords;

            //
            //  We now have to go through each of the file records added
            //  and mark it as not IN_USE.  We don't want stale data in this range
            //  to ever confuse chkdsk or rescan.  These records begin after the
            //  current end of file.  We won't worry about anything currently
            //  in the file because it would already be marked as IN-USE or
            //  not correctly.  We are only concerned with records which will
            //  become part of the valid portion of the file since we will
            //  skip them in the normal allocation path (we want to limit
            //  disk IO in a file record containing MFT mapping).
            //

            //
            //  Chop off the bits which are already part of the file.
            //

            BitmapByte >>= (8 - AddedFileRecords);

            //
            //  Now perform the initialization routine for each file record beyond the
            //  previous end of the file.
            //

            while (AddedFileRecords) {

                //
                //  If not allocated then uninitialize it now.
                //

                if (!FlagOn( BitmapByte, 0x1 )) {

                    NtfsInitializeMftHoleRecords( IrpContext,
                                                  Vcb,
                                                  CurrentIndex,
                                                  1 );
                }

                BitmapByte >>= 1;
                CurrentIndex += 1;
                AddedFileRecords -= 1;
            }
        }

    } finally {

        DebugUnwind( NtfsReserveMftRecord );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        NtfsReleaseScb( IrpContext, DataScb );
    }

    DebugTrace( -1, Dbg, ("NtfsReserveMftRecord -> Exit\n") );

    return;
}


ULONG
NtfsAllocateMftReservedRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine allocates a previously reserved record, and returns its
    number.

Arguments:

    Vcb - This is the Vcb for the volume.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    ULONG - Returns the index of the record just reserved, zero based.

--*/

{
    PSCB DataScb;

    ULONG ReservedIndex;

    PBCB BitmapBcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateMftReservedRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = Vcb->MftScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        PSCB BitmapScb;
        ULONG RelativeIndex;
        ULONG SizeToPin;

        RTL_BITMAP Bitmap;
        PVOID BitmapBuffer;

        BITMAP_RANGE BitmapRange;
        ULONG BitmapCurrentOffset = 0;

        //
        //  If we are going to allocate file record 15 then do so and set the
        //  flags in the IrpContext and Vcb.
        //

        if (!FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED )) {

            SetFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED );
            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_15_USED );

            try_return( ReservedIndex = FIRST_USER_FILE_NUMBER - 1 );
        }

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        {
            ULONG BytesPerRecord = DataScb->ScbType.Index.RecordAllocationContext.BytesPerRecord;
            ULONG ExtendGranularity = DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity;

            if ((DataScb->ScbType.Index.RecordAllocationContext.BitmapScb == NULL) &&
                !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &DataScb->ScbType.Index.RecordAllocationContext );

                DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                ExtendGranularity,
                                                &DataScb->ScbType.Index.RecordAllocationContext );
            }
        }

        BitmapScb = DataScb->ScbType.Index.RecordAllocationContext.BitmapScb;
        ReservedIndex = DataScb->ScbType.Mft.ReservedIndex;

        //
        //  Find the start of the page containing the reserved index.
        //

        BitmapCurrentOffset = (ReservedIndex / 8) & ~(PAGE_SIZE - 1);

        RelativeIndex = ReservedIndex & (BITS_PER_PAGE - 1);

        //
        //  Calculate the size to read from this point to the end of
        //  bitmap, or a page, whichever is less.
        //

        SizeToPin = (DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize / 8)
                    - BitmapCurrentOffset;

        if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

        //
        //  Read the desired bitmap page.
        //

        NtfsPinStream( IrpContext,
                       BitmapScb,
                       BitmapCurrentOffset,
                       SizeToPin,
                       &BitmapBcb,
                       &BitmapBuffer );

        //
        //  Initialize the bitmap.
        //

        RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToPin * 8 );

        //
        //  Now log this change as well.
        //

        BitmapRange.BitMapOffset = RelativeIndex;
        BitmapRange.NumberOfBits = 1;

        (VOID) NtfsWriteLog( IrpContext,
                             BitmapScb,
                             BitmapBcb,
                             SetBitsInNonresidentBitMap,
                             &BitmapRange,
                             sizeof(BITMAP_RANGE),
                             ClearBitsInNonresidentBitMap,
                             &BitmapRange,
                             sizeof(BITMAP_RANGE),
                             BitmapCurrentOffset,
                             0,
                             0,
                             Bitmap.SizeOfBitMap >> 3 );

        NtfsRestartSetBitsInBitMap( IrpContext, &Bitmap, RelativeIndex, 1 );

        //
        //  Now that we've located an index we can subtract the number of free bits in the bitmap
        //

        DataScb->ScbType.Index.RecordAllocationContext.NumberOfFreeBits -= 1;

        //
        //  If we didn't extend the file then we have used a free file record in the file.
        //  Update our bookeeping count for free file records.
        //

        DataScb->ScbType.Mft.FreeRecordChange -= 1;
        Vcb->MftFreeRecords -= 1;

        //
        //  Now determine if we extended the index of the last set bit
        //

        if (ReservedIndex > (ULONG)DataScb->ScbType.Index.RecordAllocationContext.IndexOfLastSetBit) {

            DataScb->ScbType.Index.RecordAllocationContext.IndexOfLastSetBit = ReservedIndex;
        }

        //
        //  Clear the fields that indicate we have a reserved index.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        DataScb->ScbType.Mft.ReservedIndex = 0;

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsAllocateMftReserveRecord );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        NtfsReleaseScb( IrpContext, DataScb );
    }

    DebugTrace( -1, Dbg, ("NtfsAllocateMftReserveRecord -> %08lx\n", ReservedIndex) );

    return ReservedIndex;
}


VOID
NtfsDeallocateRecordsComplete (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine removes recently deallocated record information from
    the Scb structures based on the input irp context.

Arguments:

    IrpContext - Supplies the Queue of recently deallocate records

Return Value:

    None.

--*/

{
    PDEALLOCATED_RECORDS DeallocatedRecords;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeallocateRecordsComplete\n") );

    //
    //  Now while the irp context's recently deallocated queue is not empty
    //  we will grap the first entry off the queue, remove it from both
    //  the scb and irp context queue, and free the record
    //

    while (!IsListEmpty( &IrpContext->RecentlyDeallocatedQueue )) {

        DeallocatedRecords = CONTAINING_RECORD( IrpContext->RecentlyDeallocatedQueue.Flink,
                                                DEALLOCATED_RECORDS,
                                                IrpContextLinks );

        RemoveEntryList( &DeallocatedRecords->ScbLinks );

        //
        //  Reset our hint index if one of the deallocated indexes is suitable.
        //

        if (DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.StartingHint >
            DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.LowestDeallocatedIndex) {

            DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.StartingHint =
                DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.LowestDeallocatedIndex;
        }

        //
        //  Make sure to reset the LowestDeallocated.
        //

        DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.LowestDeallocatedIndex = MAXULONG;

        //
        //  Now remove the record from the irp context queue and deallocate the
        //  record
        //

        RemoveEntryList( &DeallocatedRecords->IrpContextLinks );

        //
        //  If this record is the default size then return it to our private list.
        //  Otherwise deallocate it to pool.
        //

        if (DeallocatedRecords->NumberOfEntries == DEALLOCATED_RECORD_ENTRIES) {

            ExFreeToPagedLookasideList( &NtfsDeallocatedRecordsLookasideList, DeallocatedRecords );

        } else {

            NtfsFreePool( DeallocatedRecords );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsDeallocateRecordsComplete -> VOID\n") );

    return;
}


BOOLEAN
NtfsIsRecordAllocated (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine is used to query if a record is currently allocated for
    the specified record allocation context.

Arguments:

    RecordAllocationContext - Supplies the record allocation context used
        in this operation

    Index - Supplies the index of the record being queried, zero based.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    BOOLEAN - TRUE if the record is currently allocated and FALSE otherwise.

--*/

{
    BOOLEAN Results;

    PSCB DataScb;
    PSCB BitmapScb;
    ULONG CurrentBitmapSize;

    PVCB Vcb;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;

    PATTRIBUTE_RECORD_HEADER AttributeRecordHeader;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsRecordAllocated\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = RecordAllocationContext->DataScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        Vcb = DataScb->Fcb->Vcb;

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        BitmapScb = RecordAllocationContext->BitmapScb;

        {
            ULONG ExtendGranularity;
            ULONG BytesPerRecord;
            ULONG TruncateGranularity;

            //
            //  Remember the current values in the record context structure.
            //

            BytesPerRecord = RecordAllocationContext->BytesPerRecord;
            TruncateGranularity = RecordAllocationContext->TruncateGranularity;
            ExtendGranularity = RecordAllocationContext->ExtendGranularity;

            if ((BitmapScb == NULL) && !NtfsIsAttributeResident(NtfsFoundAttribute(BitmapAttribute))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  RecordAllocationContext );

                RecordAllocationContext->CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (RecordAllocationContext->CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                TruncateGranularity,
                                                RecordAllocationContext );
            }
        }

        BitmapScb = RecordAllocationContext->BitmapScb;
        CurrentBitmapSize = RecordAllocationContext->CurrentBitmapSize;

        //
        //  We will do different operations based on whether the bitmap is resident or nonresident
        //  The first case will handle the resident bitmap
        //

        if (BitmapScb == NULL) {

            UCHAR NewByte;

            //
            //  Initialize the local bitmap
            //

            AttributeRecordHeader = NtfsFoundAttribute( BitmapAttribute );

            RtlInitializeBitMap( &Bitmap,
                                 (PULONG)NtfsAttributeValue( AttributeRecordHeader ),
                                 CurrentBitmapSize );

            //
            //  And check if the indcated bit is Set.  If it is set then the record is allocated.
            //

            NewByte = ((PUCHAR)Bitmap.Buffer)[ Index / 8 ];

            Results = BooleanFlagOn( NewByte, BitMask[Index % 8] );

        } else {

            PVOID BitmapBuffer;
            ULONG SizeToMap;
            ULONG RelativeIndex;
            ULONG BitmapCurrentOffset;

            //
            //  Calculate Vcn and relative index of the bit we will deallocate,
            //  from the nearest page boundary.
            //

            BitmapCurrentOffset = (Index / 8) & ~(PAGE_SIZE - 1);
            RelativeIndex = Index & (BITS_PER_PAGE - 1);

            //
            //  Calculate the size to read from this point to the end of
            //  bitmap.
            //

            SizeToMap = CurrentBitmapSize / 8 - BitmapCurrentOffset;

            if (SizeToMap > PAGE_SIZE) { SizeToMap = PAGE_SIZE; }

            NtfsMapStream( IrpContext,
                           BitmapScb,
                           BitmapCurrentOffset,
                           SizeToMap,
                           &BitmapBcb,
                           &BitmapBuffer );

            RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToMap * 8 );

            //
            //  Now check if the indicated bit is set.  If it is set then the record is allocated.
            //  no idea whether the update is applied or not.
            //

            Results = RtlAreBitsSet(&Bitmap, RelativeIndex, 1);
        }

    } finally {

        DebugUnwind( NtfsIsRecordDeallocated );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        NtfsReleaseScb( IrpContext, DataScb );
    }

    DebugTrace( -1, Dbg, ("NtfsIsRecordAllocated -> %08lx\n", Results) );

    return Results;
}


VOID
NtfsScanMftBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called during mount to initialize the values related to
    the Mft in the Vcb.  These include the number of free records and hole
    records.  Also whether we have already used file record 15.  We also scan
    the Mft to check whether there is any excess mapping.

Arguments:

    Vcb - Supplies the Vcb for the volume.

Return Value:

    None.

--*/

{
    PBCB BitmapBcb = NULL;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanMftBitmap...\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        ULONG SizeToMap;
        ULONG FileRecords;
        ULONG RemainingRecords;
        ULONG BitmapCurrentOffset;
        ULONG BitmapBytesToRead;
        PUCHAR BitmapBuffer;
        UCHAR NextByte;
        VCN Vcn;
        LCN Lcn;
        LONGLONG Clusters;

        //
        //  Start by walking through the file records for the Mft
        //  checking for excess mapping.
        //

        NtfsLookupAttributeForScb( IrpContext, Vcb->MftScb, NULL, &AttrContext );

        //
        //  We don't care about the first one.  Let's find the rest of them.
        //

        while (NtfsLookupNextAttributeForScb( IrpContext,
                                              Vcb->MftScb,
                                              &AttrContext )) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            SetFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED );

            FileRecord = NtfsContainingFileRecord( &AttrContext );

            //
            //  Now check for the free space.
            //

            if (FileRecord->BytesAvailable - FileRecord->FirstFreeByte < Vcb->MftReserved) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_EXCESS_MAP );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
                break;
            }
        }

        //
        //  We now want to find the number of free records within the Mft
        //  bitmap.  We need to figure out how many file records are in
        //  the Mft and then map the necessary bytes in the bitmap and
        //  find the count of set bits.  We will round the bitmap length
        //  down to a byte boundary and then look at the last byte
        //  separately.
        //

        FileRecords = (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart );

        //
        //  Remember how many file records are in the last byte of the bitmap.
        //

        RemainingRecords = FileRecords & 7;

        FileRecords &= ~(7);
        BitmapBytesToRead = FileRecords / 8;

        for (BitmapCurrentOffset = 0;
             BitmapCurrentOffset < BitmapBytesToRead;
             BitmapCurrentOffset += PAGE_SIZE) {

            RTL_BITMAP Bitmap;
            ULONG MapAdjust;

            //
            //  Calculate the size to read from this point to the end of
            //  bitmap, or a page, whichever is less.
            //

            SizeToMap = BitmapBytesToRead - BitmapCurrentOffset;

            if (SizeToMap > PAGE_SIZE) { SizeToMap = PAGE_SIZE; }

            //
            //  If we aren't pinning a full page and have some bits
            //  in the next byte then pin an extra byte.
            //

            if ((SizeToMap != PAGE_SIZE) && (RemainingRecords != 0)) {

                MapAdjust = 1;

            } else {

                MapAdjust = 0;
            }

            //
            //  Unpin any Bcb from a previous loop.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Read the desired bitmap page.
            //

            NtfsMapStream( IrpContext,
                           Vcb->MftBitmapScb,
                           BitmapCurrentOffset,
                           SizeToMap + MapAdjust,
                           &BitmapBcb,
                           &BitmapBuffer );

            //
            //  Initialize the bitmap and search for a free bit.
            //

            RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToMap * 8 );

            Vcb->MftFreeRecords += RtlNumberOfClearBits( &Bitmap );
        }

        //
        //  If there are some remaining bits in the next byte then process
        //  them now.
        //

        if (RemainingRecords) {

            PVOID RangePtr;
            ULONG Index;

            //
            //  Hopefully this byte is on the same page.  Otherwise we will
            //  free this page and go to the next.  In this case the Vcn will
            //  have the correct value because we walked past the end of the
            //  current file records already.
            //

            if (SizeToMap == PAGE_SIZE) {

                //
                //  Unpin any Bcb from a previous loop.
                //

                NtfsUnpinBcb( IrpContext, &BitmapBcb );

                //
                //  Read the desired bitmap page.
                //

                NtfsMapStream( IrpContext,
                               Vcb->MftScb->ScbType.Index.RecordAllocationContext.BitmapScb,
                               BitmapCurrentOffset,
                               1,
                               &BitmapBcb,
                               &BitmapBuffer );

                //
                //  Set this to the byte prior to the last byte.  This will
                //  set this to the same state as if on the same page.
                //

                SizeToMap = 0;
            }

            //
            //  We look at the next byte in the page and figure out how
            //  many bits are set.
            //

            NextByte = *((PUCHAR) Add2Ptr( BitmapBuffer, SizeToMap + 1 ));

            while (RemainingRecords--) {

                if (!FlagOn( NextByte, 0x01 )) {

                    Vcb->MftFreeRecords += 1;
                }

                NextByte >>= 1;
            }

            //
            //  We are now ready to look for holes within the Mft.  We will look
            //  through the Mcb for the Mft looking for holes.  The holes must
            //  always be an integral number of file records.
            //

            RangePtr = NULL;
            Index = 0;

            while (NtfsGetSequentialMcbEntry( &Vcb->MftScb->Mcb,
                                              &RangePtr,
                                              Index,
                                              &Vcn,
                                              &Lcn,
                                              &Clusters )) {

                //
                //  Look for a hole and count the clusters.
                //

                if (Lcn == UNUSED_LCN) {

                    if (Vcb->FileRecordsPerCluster == 0) {

                        Vcb->MftHoleRecords += (((ULONG)Clusters) >> Vcb->MftToClusterShift);

                    } else {

                        Vcb->MftHoleRecords += (((ULONG)Clusters) << Vcb->MftToClusterShift);
                    }
                }

                Index += 1;
            }
        }

    } finally {

        DebugUnwind( NtfsScanMftBitmap );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        DebugTrace( -1, Dbg, ("NtfsScanMftBitmap...\n") );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsAddDeallocatedRecords (
    IN PVCB Vcb,
    IN PSCB Scb,
    IN ULONG StartingIndexOfBitmap,
    IN OUT PRTL_BITMAP Bitmap
    )

/*++

Routine Description:

    This routine will modify the input bitmap by removing from it
    any records that are in the recently deallocated queue of the scb.
    If we do add stuff then we will not modify the bitmap buffer itself but
    will allocate a new copy for the bitmap.

Arguments:

    Vcb - Supplies the Vcb for the volume

    Scb - Supplies the Scb used in this operation

    StartingIndexOfBitmap - Supplies the base index to use to bias the bitmap

    Bitmap - Supplies the bitmap being modified

Return Value:

    BOOLEAN - TRUE if the bitmap has been modified and FALSE
        otherwise.

--*/

{
    BOOLEAN Results;
    ULONG EndingIndexOfBitmap;
    PLIST_ENTRY Links;
    PDEALLOCATED_RECORDS DeallocatedRecords;
    ULONG i;
    ULONG Index;
    PVOID NewBuffer;
    ULONG SizeOfBitmapInBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddDeallocatedRecords...\n") );

    //
    //  Until shown otherwise we will assume that we haven't updated anything
    //

    Results = FALSE;

    //
    //  Calculate the last index in the bitmap
    //

    EndingIndexOfBitmap = StartingIndexOfBitmap + Bitmap->SizeOfBitMap - 1;
    SizeOfBitmapInBytes = (Bitmap->SizeOfBitMap + 7) / 8;

    //
    //  Check if we need to bias the bitmap with the reserved index
    //

    if ((Scb == Vcb->MftScb) &&
        FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED ) &&
        (StartingIndexOfBitmap <= Scb->ScbType.Mft.ReservedIndex) &&
        (Scb->ScbType.Mft.ReservedIndex <= EndingIndexOfBitmap)) {

        //
        //  The index is a hit so now bias the index with the start of the bitmap
        //  and allocate an extra buffer to hold the bitmap
        //

        Index = Scb->ScbType.Mft.ReservedIndex - StartingIndexOfBitmap;

        NewBuffer = NtfsAllocatePool(PagedPool, SizeOfBitmapInBytes );
        RtlCopyMemory( NewBuffer, Bitmap->Buffer, SizeOfBitmapInBytes );
        Bitmap->Buffer = NewBuffer;

        Results = TRUE;

        //
        //  And now set the bits in the bitmap to indicate that the record
        //  cannot be reallocated yet.  Also set the other bits within the
        //  same byte so we can put all of the file records for the Mft
        //  within the same pages of the Mft.
        //

        ((PUCHAR) Bitmap->Buffer)[ Index / 8 ] = 0xff;
    }

    //
    //  Scan through the recently deallocated queue looking for any indexes that
    //  we need to modify
    //

    for (Links = Scb->ScbType.Index.RecentlyDeallocatedQueue.Flink;
         Links != &Scb->ScbType.Index.RecentlyDeallocatedQueue;
         Links = Links->Flink) {

        DeallocatedRecords = CONTAINING_RECORD( Links, DEALLOCATED_RECORDS, ScbLinks );

        //
        //  For every index in the record check if the index is within the range
        //  of the bitmap we are working with
        //

        for (i = 0; i < DeallocatedRecords->NextFreeEntry; i += 1) {

            if ((StartingIndexOfBitmap <= DeallocatedRecords->Index[i]) &&
                 (DeallocatedRecords->Index[i] <= EndingIndexOfBitmap)) {

                //
                //  The index is a hit so now bias the index with the start of the bitmap
                //  and check if we need to allocate an extra buffer to hold the bitmap
                //

                Index = DeallocatedRecords->Index[i] - StartingIndexOfBitmap;

                if (!Results) {

                    NewBuffer = NtfsAllocatePool(PagedPool, SizeOfBitmapInBytes );
                    RtlCopyMemory( NewBuffer, Bitmap->Buffer, SizeOfBitmapInBytes );
                    Bitmap->Buffer = NewBuffer;

                    Results = TRUE;
                }

                //
                //  And now set the bit in the bitmap to indicate that the record
                //  cannot be reallocated yet.  It's possible that the bit is
                //  already set if we have aborted a transaction which then
                //  restores the bit.
                //

                SetFlag( ((PUCHAR)Bitmap->Buffer)[ Index / 8 ], BitMask[Index % 8] );
            }
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAddDeallocatedRecords -> %08lx\n", Results) );

    return Results;
}


//
//  Local support routine
//

LCN
NtfsInitializeMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to reserve a range of the volume bitmap for use by the
    Mft zone.  We first look for a range which is contiguous with the end of the Mft.
    If unavailable we look for a suitable length range out of the cached runs array.

    We expect our caller has loaded the cached runs array with free runs in the volume
    bitmap and also that the Mcb for the Mft is fully loaded.

Arguments:

    Vcb - This is the Vcb for the volume we are looking for the zone for.

Return Value:

    LCN - Return the LCN for the first run in the free portion of the zone.

--*/

{
    LONGLONG ClusterCount;
    LCN Lcn;
    VCN Vcn;
    LCN ZoneStart;
    LONGLONG MinZoneSize;
    LONGLONG DefaultZoneSize;
    LONGLONG MftClusters;
    BOOLEAN FoundRun;

    PAGED_CODE();

    //
    //  We synchronize on the volume bitmap.
    //

    ASSERT( NtfsIsExclusiveScb( Vcb->BitmapScb ));
    ASSERT( NtfsIsExclusiveScb( Vcb->MftScb ));

    DebugTrace( +1, Dbg, ("NtfsInitializeMftZone\n") );

    //
    //  Remember the default size of the new zone and the number of clusters in the Mft.
    //

    MinZoneSize = Vcb->TotalClusters >> (NTFS_MFT_ZONE_DEFAULT_SHIFT + 1);
    DefaultZoneSize = (Vcb->TotalClusters >> NTFS_MFT_ZONE_DEFAULT_SHIFT) * NtfsMftZoneMultiplier;
    MftClusters = LlClustersFromBytesTruncate( Vcb, Vcb->MftScb->Header.AllocationSize.QuadPart );

    if (DefaultZoneSize > MftClusters + MinZoneSize) {

        DefaultZoneSize -= MftClusters;

    } else {

        DefaultZoneSize = MinZoneSize;
    }

    //
    //  Get the last Lcn for the Mft and check if we can find a contiguous free run.
    //

    FoundRun = NtfsLookupLastNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                           &Vcn,
                                           &Lcn );

    ASSERT( FoundRun && (Vcn + 1 >= MftClusters) );

    //
    //  Look first in the cached runs array.  If not there then look to the disk.
    //

    Lcn += 1;
    if (!NtfsLookupCachedLcn( &Vcb->CachedRuns,
                              Lcn,
                              &ZoneStart,
                              &ClusterCount,
                              NULL )) {

        //
        //  If there are no free runs then set the zone to a default value.
        //

        if (Vcb->CachedRuns.Used == 0) {

            ZoneStart = Lcn;
            ClusterCount = DefaultZoneSize;

        //
        //  There should be a run available in the bitmap.
        //

        } else {

            NtfsFindFreeBitmapRun( IrpContext,
                                   Vcb,
                                   DefaultZoneSize,
                                   Lcn,
                                   TRUE,
                                   TRUE,
                                   &ZoneStart,
                                   &ClusterCount );

            //
            //  If there is no contiguous range then look for the best fit in the cached
            //  runs array.  Start by asking for half the original zone request.  Up it
            //  if the current Mft is rather small.
            //

            if (ZoneStart != Lcn) {

                ClusterCount = DefaultZoneSize;

                //
                //  Lookup in the cached runs array by length.
                //

                NtfsLookupCachedLcnByLength( &Vcb->CachedRuns,
                                             ClusterCount,
                                             TRUE,
                                             Lcn,
                                             &ZoneStart,
                                             &ClusterCount,
                                             NULL );
            }
        }
    }

    //
    //  We now have a value for the zone start and length.  Make sure we aren't overreserving the
    //  volume.  Consider the current size of the Mft and the length of the additional zone.
    //

    if (ClusterCount > DefaultZoneSize) {

        ClusterCount = DefaultZoneSize;
    }

    //
    //  Align the zone on ULONG boundary.  RtlFindNextForwardRunClear expects the pointers
    //  to be ulong aligned.
    //

    Vcb->MftZoneStart = ZoneStart & ~0x1f;
    Vcb->MftZoneEnd = (ZoneStart + ClusterCount + 0x1f) & ~0x1f;

    //
    //  Keep it close to total clusters.
    //

    if (Vcb->MftZoneEnd > Vcb->TotalClusters) {

        Vcb->MftZoneEnd = (Vcb->TotalClusters + 0x1f) & ~0x1f;
    }

    ClearFlag( Vcb->VcbState, VCB_STATE_REDUCED_MFT );

    //
    //  Remove the Mft zone from the cached runs.  We always look to the
    //  bitmap directly when extending the Mft.
    //

    NtfsRemoveCachedLcn( &Vcb->CachedRuns,
                         Vcb->MftZoneStart,
                         Vcb->MftZoneEnd - Vcb->MftZoneStart );

    DebugTrace( -1, Dbg, ("NtfsInitializeMftZone -> VOID\n") );

    return ZoneStart;
}


//
//  Local support routine
//

BOOLEAN
NtfsReduceMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called when it appears that there is no disk space left on the
    disk except the Mft zone.  We will try to reduce the zone to make space
    available for user files.

Arguments:

    Vcb - Supplies the Vcb for the volume

Return Value:

    BOOLEAN - TRUE if the Mft zone was shrunk.  FALSE otherwise.

--*/

{
    BOOLEAN ReduceMft = FALSE;

    LONGLONG FreeClusters;
    LONGLONG TargetFreeClusters;
    LONGLONG PrevFreeClusters;

    ULONG CurrentOffset;

    LCN Lcn;
    LCN StartingLcn;
    LCN SplitLcn;
    LCN FinalLcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;

    PAGED_CODE();

    //
    //  Nothing to do if disk is almost empty.
    //

    if (Vcb->FreeClusters < (4 * MFT_EXTEND_GRANULARITY)) {

        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Bound our search by the end of the volume.
        //

        FinalLcn = Vcb->MftZoneEnd;
        if (Vcb->MftZoneEnd > Vcb->TotalClusters) {

            FinalLcn = Vcb->TotalClusters;
        }

        //
        //  We want to find the number of free clusters in the Mft zone and
        //  return half of them to the pool of clusters for users files.
        //

        FreeClusters = 0;

        for (Lcn = Vcb->MftZoneStart;
             Lcn < FinalLcn;
             Lcn = StartingLcn + Bitmap.SizeOfBitMap) {

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &StartingLcn, &Bitmap, &BitmapBcb );

            if ((StartingLcn + Bitmap.SizeOfBitMap) > FinalLcn) {

                Bitmap.SizeOfBitMap = (ULONG) (FinalLcn - StartingLcn);
            }

            if (StartingLcn != Lcn) {

                Bitmap.SizeOfBitMap -= (ULONG) (Lcn - StartingLcn);
                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer,
                                         (ULONG) (Lcn - StartingLcn) / 8 );

                StartingLcn = Lcn;
            }

            FreeClusters += RtlNumberOfClearBits( &Bitmap );
        }

        //
        //  If we are below our threshold then don't do the split.
        //

        if (FreeClusters < (4 * MFT_EXTEND_GRANULARITY)) {

            try_return( NOTHING );
        }

        //
        //  Now we want to calculate 1/2 of this number of clusters and set the
        //  zone end to this point.
        //

        TargetFreeClusters = Int64ShraMod32( FreeClusters, 1 );

        //
        //  Now look for the page which contains the split point.
        //

        FreeClusters = 0;

        for (Lcn = Vcb->MftZoneStart;
             Lcn < FinalLcn;
             Lcn = StartingLcn + Bitmap.SizeOfBitMap) {

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &StartingLcn, &Bitmap, &BitmapBcb );

            if ((StartingLcn + Bitmap.SizeOfBitMap) > FinalLcn) {

                Bitmap.SizeOfBitMap = (ULONG) (FinalLcn - StartingLcn);
            }

            if (StartingLcn != Lcn) {

                Bitmap.SizeOfBitMap -= (ULONG) (Lcn - StartingLcn);
                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer,
                                         (ULONG) (Lcn - StartingLcn) / 8 );

                StartingLcn = Lcn;
            }

            PrevFreeClusters = FreeClusters;
            FreeClusters += RtlNumberOfClearBits( &Bitmap );

            //
            //  Check if we found the page containing the split point.
            //

            if (FreeClusters >= TargetFreeClusters) {

                CurrentOffset = 0;

                while (TRUE) {

                    if (!RtlCheckBit( &Bitmap, CurrentOffset )) {

                        PrevFreeClusters += 1;
                        if (PrevFreeClusters == TargetFreeClusters) {

                            break;
                        }
                    }

                    CurrentOffset += 1;
                }

                SplitLcn = Lcn + CurrentOffset;
                ReduceMft = TRUE;
                break;
            }
        }

        //
        //  If we are to reduce the Mft zone then set the split point and exit.
        //  We always round the split point up to a ULONG bitmap boundary so
        //  that the bitmap for the zone is ULONG aligned.  RtlFindNextForwardRunClear
        //  expects the pointers to be ulong aligned.
        //

        if (ReduceMft) {

            Vcb->MftZoneEnd = (SplitLcn + 0x1f) & ~0x1f;

            //
            //  Keep it close to total clusters.
            //

            if (Vcb->MftZoneEnd > Vcb->TotalClusters) {

                Vcb->MftZoneEnd = (Vcb->TotalClusters + 0x1f) & ~0x1f;
            }

            ASSERT( Vcb->MftZoneEnd >= Vcb->MftZoneStart );

            if (Int64ShraMod32( Vcb->TotalClusters, 4 ) > Vcb->FreeClusters) {

                SetFlag( Vcb->VcbState, VCB_STATE_REDUCED_MFT );
            }
        }

    try_exit:  NOTHING;
    } finally {

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return ReduceMft;
}


//
//  Local support routine
//

VOID
NtfsCheckRecordStackUsage (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called in the record package prior to adding allocation
    to either a data stream or bitmap stream.  The purpose is to verify
    that there is room on the stack to perform a log file full in the
    AddAllocation operation.  This routine will check the stack space and
    the available log file space and raise LOG_FILE_FULL defensively if
    both of these reach a critical threshold.

Arguments:

Return Value:

    None - this routine will raise if necessary.

--*/

{
    LOG_FILE_INFORMATION LogFileInfo;
    ULONG InfoSize;
    LONGLONG RemainingLogFile;

    PAGED_CODE();

    //
    //  Check the stack usage first.
    //

    if (IoGetRemainingStackSize() < OVERFLOW_RECORD_THRESHHOLD) {

        //
        //  Now check the log file space.
        //

        InfoSize = sizeof( LOG_FILE_INFORMATION );

        RtlZeroMemory( &LogFileInfo, InfoSize );

        LfsReadLogFileInformation( IrpContext->Vcb->LogHandle,
                                   &LogFileInfo,
                                   &InfoSize );

        //
        //  Check that 1/4 of the log file is available.
        //

        if (InfoSize != 0) {

            RemainingLogFile = LogFileInfo.CurrentAvailable - LogFileInfo.TotalUndoCommitment;

            if ((RemainingLogFile <= 0) ||
                (RemainingLogFile < Int64ShraMod32(LogFileInfo.TotalAvailable, 2))) {

#ifdef PERF_STATS
                IrpContext->LogFullReason = LF_RECORD_STACK_CHECK;
#endif
                
                NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
            }
        }
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsRunIsClear (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG RunLength
    )

/*++

Routine Description:

    This routine verifies that a group of clusters are unallocated.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    StartingLcn - Supplies the start of the cluster run

    RunLength   - Supplies the length of the cluster run

Return Value:

    None.

--*/
{
    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;
    BOOLEAN StuffAdded = FALSE;
    LONGLONG BitOffset;
    LONGLONG BitCount;
    LCN BaseLcn;
    LCN Lcn = StartingLcn;
    LONGLONG ValidDataLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRunIsClear\n") );

    ValidDataLength = Vcb->BitmapScb->Header.ValidDataLength.QuadPart;

    try {

        //
        //  Ensure that StartingLcn is not past the length of the bitmap.
        //

        if (StartingLcn > ValidDataLength * 8) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }

        while (RunLength > 0){

            //
            //  Access the next page of bitmap and update it
            //

            NtfsMapPageInBitmap(IrpContext, Vcb, Lcn, &BaseLcn, &Bitmap, &BitmapBcb);

            //
            //  Get offset into this page and bits to end of this page
            //

            BitOffset = Lcn - BaseLcn;
            BitCount = Bitmap.SizeOfBitMap - BitOffset;

            //
            //  Adjust for bits to end of page
            //

            if (BitCount > RunLength){

                BitCount = RunLength;
            }

            //
            //  If any bit is set get out
            //

            if (!RtlAreBitsClear( &Bitmap, (ULONG)BitOffset, (ULONG)BitCount)) {

                NtfsRaiseStatus( IrpContext, STATUS_ALREADY_COMMITTED, NULL, NULL );
            }

            StuffAdded = NtfsAddRecentlyDeallocated(Vcb, BaseLcn, &Bitmap);

            //
            //  Now if anything was added, check if the desired clusters are still
            //  free, else just free the stuff added.
            //

            if (StuffAdded) {

                //
                //  If any bit is set now, raise STATUS_DELETE_PENDING to indicate
                //  that the space will soon be free (or can be made free).
                //

                if (!RtlAreBitsClear( &Bitmap, (ULONG)BitOffset, (ULONG)BitCount)) {

                    NtfsRaiseStatus( IrpContext, STATUS_DELETE_PENDING, NULL, NULL );
                }

                //
                //  Free up resources
                //

                NtfsFreePool(Bitmap.Buffer);
                StuffAdded = FALSE;
            }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Decrease remaining bits by amount checked in this page and move Lcn to beginning
            //  of next page
            //

            RunLength = RunLength - BitCount;
            Lcn = BaseLcn + Bitmap.SizeOfBitMap;
        }

    } finally {

        DebugUnwind(NtfsRunIsClear);

        //
        //  Free up resources
        //

        if(StuffAdded){ NtfsFreePool(Bitmap.Buffer); StuffAdded = FALSE; }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsRunIsClear -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsInitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine will initialize the cached run information.

Arguments:

    CachedRuns - Pointer to an uninitialized cached run structure.

Return Value:

    None - this routine will raise if unable to initialize the structure.

--*/

{
    USHORT Index;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeCachedRuns\n") );

    //
    //  Initialize the operating parameters.
    //

    CachedRuns->MaximumSize = 9000;
    CachedRuns->MinCount = 100;

    //
    //  Allocate pool for the arrays.
    //

    CachedRuns->LcnArray = NtfsAllocatePool( PagedPool,
                                             sizeof( NTFS_LCN_CLUSTER_RUN ) * NTFS_INITIAL_CACHED_RUNS );

    CachedRuns->LengthArray = NtfsAllocatePool( PagedPool,
                                                sizeof( USHORT ) * NTFS_INITIAL_CACHED_RUNS );

    //
    //  Mark all entries so that they can be detected as deleted.
    //

    for (Index = 0; Index < NTFS_INITIAL_CACHED_RUNS; Index += 1) {

        CachedRuns->LcnArray[Index].RunLength = 0;
        CachedRuns->LcnArray[Index].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
        CachedRuns->LengthArray[Index] = NTFS_CACHED_RUNS_DEL_INDEX;
    }

    CachedRuns->Avail = NTFS_INITIAL_CACHED_RUNS;

    //
    //  Allocate space for the histogram of small run lengths.
    //

    CachedRuns->Bins = NTFS_CACHED_RUNS_BIN_COUNT;
    CachedRuns->BinArray = NtfsAllocatePool( PagedPool,
                                             sizeof( USHORT ) * CachedRuns->Bins );
    RtlZeroMemory( CachedRuns->BinArray,
                   sizeof( USHORT ) * CachedRuns->Bins );

    //
    //  Allocate space for the windows of deleted entries in the sorted
    //  arrays.
    //

    CachedRuns->DelLcnCount = 0;
    CachedRuns->DelLengthCount = 0;
    CachedRuns->DeletedLcnWindows = NtfsAllocatePool( PagedPool,
                                                      sizeof( NTFS_DELETED_RUNS ) * NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );
    CachedRuns->DeletedLengthWindows = NtfsAllocatePool( PagedPool,
                                                         sizeof( NTFS_DELETED_RUNS ) * NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    //
    //  Create a window of deleted entries to cover the newly allocated
    //  entries.
    //

    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, TRUE );
    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, FALSE );

    //
    //  Clear the in use count.
    //

    CachedRuns->Used = 0;

    //
    //  Reset the longest freed run.
    //

    CachedRuns->LongestFreedRun = MAXLONGLONG;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsInitializeCachedRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsReinitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine is called to reinitialize the cached runs array.

Arguments:

    CachedRuns - Pointer to a cached run structure.

Return Value:

    None

--*/

{
    USHORT Index;
    PNTFS_LCN_CLUSTER_RUN NewLcnArray;
    PUSHORT NewLengthArray;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReinitializeCachedRuns\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Reallocate to get a smaller array.  If we get an allocation failure then simply
    //  empty the larger arrays.
    //

    if (CachedRuns->Avail != NTFS_INITIAL_CACHED_RUNS) {

        NewLcnArray = NtfsAllocatePoolNoRaise( PagedPool,
                                               sizeof( NTFS_LCN_CLUSTER_RUN ) * NTFS_INITIAL_CACHED_RUNS );

        if (NewLcnArray != NULL) {

            //
            //  Allocate the length array.
            //

            NewLengthArray = NtfsAllocatePoolNoRaise( PagedPool,
                                                      sizeof( USHORT ) * NTFS_INITIAL_CACHED_RUNS );

            //
            //  If we didn't get the Length array then simply use what we have already.
            //

            if (NewLengthArray == NULL) {

                NtfsFreePool( NewLcnArray );

            //
            //  Otherwise replace the Lcn and length arrays.
            //

            } else {

                NtfsFreePool( CachedRuns->LcnArray );
                CachedRuns->LcnArray = NewLcnArray;

                NtfsFreePool( CachedRuns->LengthArray );
                CachedRuns->LengthArray = NewLengthArray;

                CachedRuns->Avail = NTFS_INITIAL_CACHED_RUNS;
            }
        }
    }

    //
    //  Mark all entries so that they can be detected as deleted.
    //

    for (Index = 0; Index < CachedRuns->Avail; Index += 1) {

        CachedRuns->LcnArray[Index].RunLength = 0;
        CachedRuns->LcnArray[Index].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
        CachedRuns->LengthArray[Index] = NTFS_CACHED_RUNS_DEL_INDEX;
    }

    //
    //  Clear the histogram of run lengths.
    //

    RtlZeroMemory( CachedRuns->BinArray, sizeof( USHORT ) * CachedRuns->Bins );

    //
    //  Clear the list of windows of deleted entries.
    //

    CachedRuns->DelLcnCount = 0;
    CachedRuns->DelLengthCount = 0;

    //
    //  Create a window of deleted entries to cover all of the entries.
    //

    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, TRUE );
    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, FALSE );

    //
    //  Clear the in use count.
    //

    CachedRuns->Used = 0;

    //
    //  Reset the longest freed run.
    //

    CachedRuns->LongestFreedRun = MAXLONGLONG;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsReinitializeCachedRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUninitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine is called to clean up the cached run information.

Arguments:

    CachedRuns - Pointer to a cached run structure.  Be defensive and check that
    it is really initialized.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUninitializeCachedRuns\n") );

    if (CachedRuns->LcnArray != NULL) {

        NtfsFreePool( CachedRuns->LcnArray );
        CachedRuns->LcnArray = NULL;
    }

    if (CachedRuns->LengthArray != NULL) {

        NtfsFreePool( CachedRuns->LengthArray );
        CachedRuns->LengthArray = NULL;
    }

    if (CachedRuns->BinArray != NULL) {

        NtfsFreePool( CachedRuns->BinArray );
        CachedRuns->BinArray = NULL;
    }

    if (CachedRuns->DeletedLcnWindows != NULL) {

        NtfsFreePool( CachedRuns->DeletedLcnWindows );
        CachedRuns->DeletedLcnWindows = NULL;
    }

    if (CachedRuns->DeletedLengthWindows != NULL) {

        NtfsFreePool( CachedRuns->DeletedLengthWindows );
        CachedRuns->DeletedLengthWindows = NULL;
    }

    CachedRuns->Used = 0;
    CachedRuns->Avail = 0;
    CachedRuns->DelLcnCount = 0;
    CachedRuns->DelLengthCount = 0;
    CachedRuns->Bins = 0;

    DebugTrace( -1, Dbg, ("NtfsUninitializeCachedRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsLookupCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    )

/*++

Routine Description:

    This routine is called to look up a specific Lcn in the cached runs structure.
    If found it will return the entire run.  It will also return the index in the
    Lcn array to use as an optimization in a later call.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - This is the desired Lcn.

    StartingLcn - Address to store the Lcn which begins the run in the cached
        structure.  Typically this is the same as the Lcn above.

    RunLength - Address to store the length of the found run.

    Index - If specified we store the index for the run we found.  This can be
        used as an optimization if we later remove the run.

Return Value:

    BOOLEAN - TRUE if the run was found.  FALSE otherwise.

--*/

{
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    USHORT FoundIndex;
    BOOLEAN FoundLcn;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupCachedLcn\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Lookup a run containing the specific Lcn.
    //

    FoundLcn = NtfsPositionCachedLcn( CachedRuns,
                                      Lcn,
                                      &FoundIndex );

    //
    //  If we found the Lcn then return the full run.
    //

    if (FoundLcn) {

        ThisEntry = CachedRuns->LcnArray + FoundIndex;
        *StartingLcn = ThisEntry->Lcn;
        *RunLength = ThisEntry->RunLength;
    }

    if (ARGUMENT_PRESENT( Index )) {

        *Index = FoundIndex;
    }

    DebugTrace( -1, Dbg, ("NtfsLookupCachedLcn -> %01x\n", FoundLcn) );

    return FoundLcn;
}


//
//  Local support routine
//

BOOLEAN
NtfsGetNextCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT Index,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength
    )

/*++

Routine Description:

    This routine is called to find an entry in the Lcn array by position.
    It is assumed that the entry is not deleted.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Index - Index to look up.  It might point beyond the array.

    StartingLcn - Address to store the Lcn at this position.

    RunLength - Address to store the RunLength at this position.

Return Value:

    BOOLEAN - TRUE if an entry was found, FALSE otherwise.

--*/

{
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    BOOLEAN FoundRun = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetNextCachedLcn\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  If the input index is within the array then return the run.
    //

    if (Index < CachedRuns->Used) {

        ThisEntry = CachedRuns->LcnArray + Index;

        ASSERT( ThisEntry->RunLength );
        *StartingLcn = ThisEntry->Lcn;
        *RunLength = ThisEntry->RunLength;
        FoundRun = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsGetNextCachedLcn -> %01x\n", FoundRun) );

    return FoundRun;
}


//
//  Local support routine
//

BOOLEAN
NtfsLookupCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG Length,
    IN BOOLEAN AllowShorter,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    )

/*++

Routine Description:

    This routine is called to look up a cached run of a certain length.  We
    give caller any run of the given length or longer if possible.  If there
    is no such entry, we will use a shorter entry if allowed.

Arguments:

    CachedRuns - Pointer to the cached run structure.

    Length - Length of the run we are interested in.

    AllowShorter - whether to accept a shorter length run if nothing else is available

    Lcn - We try to find the run which is closest to this Lcn, but has the
        requested Length.

    StartingLcn - Address to store the starting Lcn of the run we found.

    RunLength - Address to store the length of the run we found.

    Index - If specified then this is the index in the RunLength array
        of the entry we found.  It can be used later to remove the entry.

Return Value:

    BOOLEAN - TRUE if an entry was found, FALSE otherwise.

--*/

{
    USHORT FoundIndex;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_DELETED_RUNS DelWindow;
    BOOLEAN FoundRun;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupCachedLcnByLength\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Position ourselves for a run of a particular length.
    //

    FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                              Length,
                                              &Lcn,
                                              NULL,
                                              TRUE,
                                              &FoundIndex );

    if (!FoundRun) {

        //
        //  We didn't find a run with the desired length.  However if
        //  we aren't pointing past the end of the array then there
        //  is an entry available we can use.
        //

        if (FoundIndex < CachedRuns->Used) {

            FoundRun = TRUE;

        } else if (AllowShorter && (CachedRuns->Used > 0)) {

            //
            //  There are no larger entries, but there might be smaller
            //  ones and the caller has indicated we can use them.  The
            //  entry at the end of the list should be the largest
            //  available.
            //

            FoundIndex = CachedRuns->Used - 1;
            FoundRun = TRUE;
        }

        //
        //  Check and see if there is a suitable element at or near this index.
        //

        if (FoundRun) {

            //
            //  The entry has been deleted.  Get the window of deleted
            //  entries that covers it and see if there is a usable entry on either side.
            //

            if (CachedRuns->LengthArray[ FoundIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) {

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              FoundIndex,
                                              FoundIndex,
                                              FALSE,
                                              NULL);

                ASSERT( DelWindow );
                ASSERT( DelWindow->StartIndex <= FoundIndex );
                ASSERT( DelWindow->EndIndex >= FoundIndex );

                //
                //  Use the entry just before the start of this window
                //  of deleted entries if one exists.
                //

                if (DelWindow->StartIndex > 0) {

                    FoundIndex = DelWindow->StartIndex - 1;

                //
                //  All of the entries are deleted.
                //

                } else {

                    FoundRun = FALSE;
                }

            //
            //  If we aren't considering a shorter element then this should be a longer one.
            //

            } else {

                ASSERT( AllowShorter ||
                        (CachedRuns->LcnArray[ CachedRuns->LengthArray[ FoundIndex ]].RunLength >= Length) );

            }
        }
    }

    //
    //  If we have a run then return the run information.
    //

    if (FoundRun) {

        ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ FoundIndex ];
        ASSERT( ThisEntry->RunLength != 0 );
        *StartingLcn = ThisEntry->Lcn;
        *RunLength = ThisEntry->RunLength;

        if (ARGUMENT_PRESENT( Index )) {

            *Index = FoundIndex;
        }
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsLookupCachedLcnByLength -> %01x\n", FoundRun) );

    return FoundRun;
}


//
//  Local support routine
//

VOID
NtfsAddDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList
    )

/*++

Routine Description:

    This routine is called to add the given range of indices to a window
    of entries known to be deleted.  If the entries are adjacent to an
    existing window, that window is extended.  Otherwise a new window is
    allocated.  If there is no space in the array to add a new window, the
    list is compacted.  Therefore, callers should be aware that indices may
    change across this call.  However we do guarantee that the indices in
    [FirstIndex..LastIndex] will not move.

    It is assumed that no window already includes the given index range.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    FirstIndex - Index that marks the start of the range of deleted entries.

    LastIndex - The index of the last entry in the range of deleted entries.

    LcnList - If TRUE, the indices are from the Lcn-sorted list.
        If FALSE, the indices are from the length-sorted list.

Return Value:

    None.

--*/

{
    USHORT WindowIndex;
    PUSHORT Count;
    PNTFS_DELETED_RUNS FirstWindow;
    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_DELETED_RUNS NextWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddDelWindow\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Get pointers to the windows we will be updating.
    //

    if (LcnList) {

        Count = &CachedRuns->DelLcnCount;
        FirstWindow = CachedRuns->DeletedLcnWindows;

    } else {

        Count = &CachedRuns->DelLengthCount;
        FirstWindow = CachedRuns->DeletedLengthWindows;
    }

    ASSERT( *Count <= NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    while (TRUE) {

        DebugTrace( 0, Dbg, ("*Count=%04x, FirstIndex=%04x, LastIndex=%04x\n", *Count, FirstIndex, LastIndex) );

        if (*Count != 0) {

            //
            //  Get the window of deleted entries that is closest to the range
            //  of indices we are adding.
            //

            DelWindow = NtfsGetDelWindow(CachedRuns,
                                         FirstIndex,
                                         LastIndex,
                                         LcnList,
                                         &WindowIndex );

            ASSERT( DelWindow != NULL );
            ASSERT( (DelWindow->EndIndex < FirstIndex) || (DelWindow->StartIndex > LastIndex) );

            DebugTrace( 0, Dbg, ("WindowIndex=%04x, StartIndex=%04x, EndIndex=%04x\n",
                                 WindowIndex, DelWindow->StartIndex, DelWindow->EndIndex) );

            //
            //  Check if our range extends this window.
            //

            if (DelWindow->EndIndex == (FirstIndex - 1)) {

                //
                //  Extend this window upwards.
                //

                DebugTrace( 0, Dbg, ("Extend window up from %04x to %04x\n",
                                     DelWindow->EndIndex, LastIndex) );

                DelWindow->EndIndex = LastIndex;

                //
                //  If not the last window then check if we ajoin the following window.
                //

                if (WindowIndex < (*Count - 1) ) {

                    NextWindow = DelWindow + 1;
                    ASSERT( NextWindow->StartIndex > LastIndex );

                    if (NextWindow->StartIndex == (LastIndex + 1) ) {

                        //
                        //  Combine these two windows.
                        //

                        DebugTrace( 0, Dbg, ("Combine with next window up to %04x\n",
                                             NextWindow->EndIndex) );

                        DelWindow->EndIndex = NextWindow->EndIndex;

                        //
                        //  Delete the additional window.
                        //

                        NtfsDeleteDelWindow( CachedRuns,
                                             LcnList,
                                             WindowIndex + 1 );
                    }
                }

                break;

            //
            //  Check if we extend this window downwards.
            //

            } else if (DelWindow->StartIndex == (LastIndex + 1)) {

                DebugTrace( 0, Dbg, ("Extend window down from %04x to %04x\n",
                                     DelWindow->EndIndex, FirstIndex) );

                DelWindow->StartIndex = FirstIndex;

                //
                //  Check if we join the previous window if present.
                //

                if (WindowIndex > 0) {

                    NextWindow = DelWindow - 1;
                    ASSERT( NextWindow->EndIndex < FirstIndex );

                    if (NextWindow->EndIndex == (FirstIndex - 1) ) {

                        //
                        //  Combine these two windows.
                        //

                        DebugTrace( 0,
                                    Dbg,
                                    ("Combine with prev window up to %04x\n", NextWindow->StartIndex) );

                        NextWindow->EndIndex = DelWindow->EndIndex;

                        //
                        //  Delete the unused window.
                        //

                        NtfsDeleteDelWindow( CachedRuns,
                                             LcnList,
                                             WindowIndex );
                    }
                }

                break;

            //
            //  Add a new window after the window we found.
            //

            } else if (DelWindow->EndIndex < FirstIndex) {

                //
                //  Insert the new window after WindowIndex.
                //

                DebugTrace( 0, Dbg, ("New window at %04x + 1\n", WindowIndex) );
                WindowIndex += 1;

            } else {

                //
                //  Insert the new window at WindowIndex.
                //

                DebugTrace( 0, Dbg, ("New window at %04x\n", WindowIndex) );
            }

        } else {

            //
            //  Just create a new window at index 0.
            //

            DebugTrace( 0, Dbg, ("First new window\n") );
            WindowIndex = 0;
        }

        //
        //  If we reach this point then we need to make a new window.  We have the position
        //  we want to put the window.
        //
        //  If we don't have an available run then compact two of the existing runs.
        //

        if (*Count == NTFS_CACHED_RUNS_MAX_DEL_WINDOWS) {

            DebugTrace( 0, Dbg, ("Compact\n") );

            NtfsCompactCachedRuns( CachedRuns,
                                   FirstIndex,
                                   LastIndex,
                                   LcnList );

            ASSERT( *Count < NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

            //
            //  Retry the loop to find the correct window position.
            //

            continue;
        }

        //
        //  Position ourselves at the insert point.
        //

        DelWindow = FirstWindow + WindowIndex;

        //
        //  Right copy the windows to make a space if we aren't at the end.
        //

        if (WindowIndex < *Count) {

            DebugTrace( 0, Dbg, ("Copy up window indices from %04x, %04x entries\n",
                                 WindowIndex,
                                 *Count - WindowIndex) );

            RtlMoveMemory( DelWindow + 1,
                           DelWindow,
                           sizeof( NTFS_DELETED_RUNS ) * (*Count - WindowIndex) );
        }

        //
        //  Put the new information in DelWindow
        //

        DelWindow->StartIndex = FirstIndex;
        DelWindow->EndIndex = LastIndex;

        //
        //  Increment the windows count.
        //

        *Count += 1;
        break;
    }

    ASSERT( (CachedRuns->DelLcnCount > 0) || !LcnList );
    ASSERT( (CachedRuns->DelLengthCount > 0) || LcnList );

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {

        //
        //  Make certain that the windows are in order and don't overlap.
        //

        for (WindowIndex = 0, DelWindow = NextWindow = FirstWindow;
             WindowIndex < *Count;
             WindowIndex += 1, NextWindow += 1) {

            ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
            if (NextWindow != DelWindow) {

                ASSERT( NextWindow->StartIndex > (DelWindow->EndIndex + 1) );
                DelWindow += 1;
            }
        }
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsAddDelWindow -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsShrinkDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN ShrinkFromStart,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    )

/*++

Routine Description:

    This routine is called to remove one entry from the given window
    of entries known to be deleted.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    ShrinkFromStart - If TRUE, remove the first entry in the window.
        If FALSE, remove the last entry in the window.

    LcnWindow - If TRUE, the window is of Lcn indices.  If FALSE, the window is
        of length indices.

    WindowIndex - The index of the window.

Return Value:

    None.

--*/

{
    PUSHORT Count;
    PNTFS_DELETED_RUNS DelWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsShrinkDelWindow\n") );
    DebugTrace( 0, Dbg, ("WindowIndex %04x\n", WindowIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    if (LcnWindow) {

        Count = &CachedRuns->DelLcnCount;
        DelWindow = (CachedRuns->DeletedLcnWindows + WindowIndex);

    } else {

        Count = &CachedRuns->DelLengthCount;
        DelWindow = (CachedRuns->DeletedLengthWindows + WindowIndex);
    }

    //
    //  Caller better give us something in the correct range.
    //

    ASSERT( WindowIndex < *Count );

    //
    //  If the window has a single entry then remove it.
    //

    if (DelWindow->StartIndex == DelWindow->EndIndex) {

        NtfsDeleteDelWindow( CachedRuns,
                             LcnWindow,
                             WindowIndex );

    //
    //  Remove the first entry if desired.
    //

    } else if (ShrinkFromStart) {

        DelWindow->StartIndex += 1;

    //
    //  Otherwise the last entry.
    //

    } else {

        DelWindow->EndIndex -= 1;
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {

        PNTFS_DELETED_RUNS FirstWindow;
        PNTFS_DELETED_RUNS NextWindow;
        USHORT Index;

        //
        //  Make certain that the windows are in order and don't overlap.
        //

        if (LcnWindow) {

            FirstWindow = CachedRuns->DeletedLcnWindows;

        } else {

            FirstWindow = CachedRuns->DeletedLengthWindows;
        }

        for (Index = 0, DelWindow = NextWindow = FirstWindow;
             Index < *Count;
             Index += 1, NextWindow += 1) {

            ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
            if (NextWindow != DelWindow) {

                ASSERT( NextWindow->StartIndex > (DelWindow->EndIndex + 1) );
                DelWindow += 1;
            }
        }
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsShrinkDelWindow -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsDeleteDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    )

/*++

Routine Description:

    This routine is called to remove the given window of entries known to
    be deleted.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    LcnWindow - If TRUE, the window is of Lcn indices.  If FALSE, the window is of length indices.

    WindowIndex - The index of the window.

Return Value:

    None.

--*/

{
    PUSHORT Count;
    PNTFS_DELETED_RUNS FirstWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteDelWindow\n") );
    DebugTrace( 0, Dbg, ("WindowIndex %04x\n", WindowIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Use the correct deleted window array.
    //

    if (LcnWindow) {

        Count = &CachedRuns->DelLcnCount;
        FirstWindow = CachedRuns->DeletedLcnWindows;

    } else {

        Count = &CachedRuns->DelLengthCount;
        FirstWindow = CachedRuns->DeletedLengthWindows;
    }

    //
    //  Delete this window by shifting any existing windows from the right.
    //

    if (WindowIndex < (*Count - 1)) {

        //
        //  Remove the deleted window.
        //

        DebugTrace( 0,
                    Dbg,
                    ("Move from WindowIndex %04x, %04x entries\n", WindowIndex + 1, *Count - 1 - WindowIndex) );

        RtlMoveMemory( FirstWindow + WindowIndex,
                       FirstWindow + WindowIndex + 1,
                       sizeof( NTFS_DELETED_RUNS ) * (*Count - 1 - WindowIndex) );
    }

    //
    //  Decrement the windows count.
    //

    *Count -= 1;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {

        PNTFS_DELETED_RUNS DelWindow;
        PNTFS_DELETED_RUNS NextWindow;

        //
        //  Make certain that the windows are in order and don't overlap.
        //

        for (WindowIndex = 0, DelWindow = NextWindow = FirstWindow;
             WindowIndex < *Count;
             WindowIndex += 1, NextWindow += 1) {

            ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );

            //
            //  Check against previous window if not at the first element.  We don't allow
            //  adjacent windows to touch because they should have merged.
            //

            if (NextWindow != DelWindow) {

                ASSERT( NextWindow->StartIndex > (DelWindow->EndIndex + 1) );
                DelWindow += 1;
            }
        }
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsDeleteDelWindow -> VOID\n") );

    return;
}


//
//  Local support routine
//


PNTFS_DELETED_RUNS
NtfsGetDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList,
    OUT PUSHORT WindowIndex OPTIONAL
    )

/*++

Routine Description:

    This routine is called to find the window of entries known to be deleted
    that is closest to the given range of indices.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    FirstIndex - Index that marks the start of the range.

    LastIndex - The index of the last entry in the range.

    LcnList - If TRUE, the indices are from the Lcn-sorted list.
        If FALSE, the indices are from the length-sorted list.

    WindowIndex - If specified, the index of the returned window is put here.

Return Value:

    PNTFS_DELETED_RUNS - Returns the closest window of deleted entries, or
        NULL is there are no windows.

--*/

{
    USHORT Count;
    USHORT Distance;
    USHORT Max, Min, Current;
    BOOLEAN Overlap = FALSE;
    PNTFS_DELETED_RUNS FirstWindow, NextWindow;
    PNTFS_DELETED_RUNS DelWindow = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetDelWindow\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Get pointers to the windows we will be searching.
    //

    if (LcnList) {

        Count = CachedRuns->DelLcnCount;
        FirstWindow = CachedRuns->DeletedLcnWindows;

    } else {

        Count = CachedRuns->DelLengthCount;
        FirstWindow = CachedRuns->DeletedLengthWindows;
    }

    if (Count != 0) {

        //
        //  Perform a binary search to find the next element to the right.
        //  We always do at least one comparison to determine if a single element
        //  is to the left or right.
        //

        Min = 0;
        Max = Count - 1;

        while (TRUE) {

            Current = (USHORT) (((ULONG) Max + Min) / 2);
            NextWindow = FirstWindow + Current;

            if (LastIndex < NextWindow->StartIndex) {

                //
                //  We are done if Max and Min match.  We test before changing Max
                //  because if Min is still 0 then we've never looked at it.
                //

                if (Min == Max) {

                    break;
                }

                Max = Current;

            } else if (LastIndex > NextWindow->EndIndex) {

                //
                //  Advance Min past this point.
                //

                Min = Current + 1;

                //
                //  Break if past Max.  This should only occur if our range is
                //  past the last window.
                //

                if (Min > Max) {

                    ASSERT( Min == Count );
                    break;
                }

            } else {

                //
                //  Simple case.  This is an overlap.
                //

                Overlap = TRUE;
                Min = Current;
                break;
            }
        }

        //
        //  Now find nearest.  First check if we are beyond the end of the array.
        //

        if (Min == Count) {

            Min = Count - 1;

        //
        //  If we aren't at the first entry and didn't already detect an overlap then
        //  compare adjacent entries.
        //

        } else if ((Min != 0) && !Overlap) {

            DelWindow = FirstWindow + Min - 1;
            NextWindow = DelWindow + 1;

            //
            //  Test that there is no overlap with the previous
            //  window.  If no overlap then check for the distance to
            //  the adjacent ranges.
            //

            if (FirstIndex > DelWindow->EndIndex) {

                ASSERT( NextWindow->StartIndex > LastIndex );
                Distance = NextWindow->StartIndex - LastIndex;

                if (Distance > FirstIndex - DelWindow->EndIndex) {

                    //
                    //  Move to the previous window.
                    //

                    Min -= 1;
                }

            //
            //  The previous window has an overlap.
            //

            } else {

                Min -= 1;
            }
        }

        if (ARGUMENT_PRESENT( WindowIndex )) {

            *WindowIndex = Min;
        }

        DelWindow = FirstWindow + Min;

        DebugTrace( 0, Dbg, ("Index -> %04x\n", Min) );
    }

    DebugTrace( -1, Dbg, ("NtfsGetDelWindow -> 0x%x\n", DelWindow) );

    return DelWindow;
}


//
//  Local support routine
//

USHORT
NtfsGetCachedLengthInsertionPoint (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine is called to add a new entry in the Lcn-sorted and
    length-sorted lists.  It is assumed that the caller has made certain
    that this new entry will not overlap any existing entries.

    This routine may chose not to add the new entry to the lists.  If adding
    this entry would force an equally or more desirable run out of the cache,
    we don't make the change.

    This routine can compact the lists.  Therefore, the caller should not
    assume that entries will not move.

    If this routine finds an insertion point and there is already an undeleted
    at that position, the new run sorts before it.  If the new run sorts
    higher than the entry at index CachedRuns->Avail - 1, we will return an
    index of CachedRuns->Avail.  The caller must check for this case and
    not access an entry beyond the list size.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Lcn to insert.

    Length - Length of the run to insert.

Return Value:

    USHORT - The index into the length-sorted table at which the given Length
        should be inserted.  If the entry should not be inserted,
        NTFS_CACHED_RUNS_DEL_INDEX is returned.

--*/

{
    BOOLEAN FoundRun;
    USHORT Index;
    LONGLONG RunLength;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetCachedLengthInsertionPoint\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    if ((CachedRuns->Used == CachedRuns->Avail) &&
        (CachedRuns->DelLengthCount == 0) ) {

        //
        //  Grow the lists.
        //

        if (!NtfsGrowCachedRuns( CachedRuns )) {

            //
            //  We couldn't grow the lists.
            //

            if (CachedRuns->Used == 0) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            //  Adding this entry will force another one to be deleted.
            //  Make sure the new entry is more desirable to add than
            //  all existing entries.
            //
            //  The check is to make certain that we have more than enough
            //  entries of a size smaller than Length such that we would
            //  be willing to delete one.
            //

            RunLength = 0;

            for (Index = 0;
                 (Index < CachedRuns->Bins) && (Index < (Length - 1) );
                 Index += 1) {

                if (CachedRuns->BinArray[ Index ] > CachedRuns->MinCount) {

                    //
                    //  We should delete an entry with RunLength = Index + 1
                    //

                    RunLength = Index + 1;
                    break;
                }
            }

            if (RunLength != 0) {

                //
                //  Find an entry of this length.
                //

                FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                                          RunLength,
                                                          NULL,
                                                          NULL,
                                                          TRUE,
                                                          &Index );
                ASSERT( FoundRun );
                ASSERT( (CachedRuns->LengthArray[Index] != NTFS_CACHED_RUNS_DEL_INDEX) &&
                        (CachedRuns->LcnArray[CachedRuns->LengthArray[Index]].RunLength != 0) );

                //
                //  Delete the entry.
                //

                ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
                NtfsDeleteCachedRun( CachedRuns,
                                     CachedRuns->LengthArray[ Index ],
                                     Index );

            } else {

                //
                //  Do not add the new entry.
                //

                DebugTrace( -1,
                            Dbg,
                            ("NtfsGetCachedLengthInsertionPoint -> 0x%x\n", NTFS_CACHED_RUNS_DEL_INDEX) );
                return NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }
    }

    //
    //  Get the insertion point for the new entry.
    //  If FoundRun is FALSE, the entry pointed to by Index is either deleted
    //  or sorts higher than the new one.
    //

    FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                              Length,
                                              &Lcn,
                                              NULL,
                                              TRUE,
                                              &Index );

    //
    //  Index points to the closest run by Lcn that has a RunLength equal
    //  to Length.  We need to check to see if the new entry should be
    //  inserted before or after it.
    //

    if (FoundRun) {

        ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
        if (ThisEntry->Lcn < Lcn) {

            //
            //  The new run should come after this one.
            //

            Index += 1;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsGetCachedLengthInsertionPoint -> 0x%x\n", Index) );

    return Index;
}


//
//  Local support routine
//

VOID
NtfsInsertCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length,
    IN USHORT LcnIndex
    )

/*++

Routine Description:

    This routine is called to add a new entry in the Lcn-sorted and
    length-sorted lists.  It is assumed that the caller has made certain
    that this new entry will not overlap any existing entries.

    This routine may chose not to add the new entry to the lists.  If adding
    this entry would force an equally or more desirable run out of the cache,
    we don't make the change.

    This routine can compact the lists.  Therefore, the caller should not
    assume that entries will not move.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Lcn to insert.

    Length - Length of the run to insert.

    LcnIndex - Index into the Lcn-sorted list where this new entry should
        be added.  Any non-deleted entry already at this position sorts
        after the new entry.

Return Value:

    None.

--*/

{
    USHORT Count;
    USHORT RunIndex;
    USHORT LenIndex;
    USHORT WindowIndex;
    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInsertCachedRun\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Find the position in the length-sorted list to insert this new
    //  entry.  This routine will grow the lists if necessary.
    //

    LenIndex = NtfsGetCachedLengthInsertionPoint( CachedRuns,
                                                  Lcn,
                                                  Length );

    //
    //  This entry will not be added to the lists because it would degrade the
    //  distribution of the length entries.
    //

    if (LenIndex == NTFS_CACHED_RUNS_DEL_INDEX) {

        return;
    }

    //
    //  Find the closest window of deleted entries to LcnIndex.
    //

    DelWindow = NtfsGetDelWindow( CachedRuns,
                                  LcnIndex,
                                  LcnIndex,
                                  TRUE,
                                  &WindowIndex );

    ASSERT( DelWindow != NULL );
    ASSERT( (DelWindow->EndIndex + 1 < LcnIndex) ||
            (LcnIndex < CachedRuns->Avail) );

    //
    //  Move the entries between LcnIndex and the start of the
    //  window up to make room for this new entry.
    //

    if (DelWindow->StartIndex > LcnIndex) {

        RtlMoveMemory( CachedRuns->LcnArray + LcnIndex + 1,
                       CachedRuns->LcnArray + LcnIndex,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * (DelWindow->StartIndex - LcnIndex) );

        //
        //  Update the indices in the Length-sorted list to reflect the
        //  move of the lcn-sorted entries.
        //

        for (Count = LcnIndex + 1;
             Count < DelWindow->StartIndex + 1;
             Count += 1) {

            RunIndex = CachedRuns->LcnArray[ Count ].LengthIndex;
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LengthArray[ RunIndex ] += 1;
        }

        //
        //  Check if we are using the deleted window at the tail of the array.  If
        //  so then we just increased the number of entries in use with this
        //  right shift.
        //

        if (DelWindow->StartIndex == CachedRuns->Used) {

            CachedRuns->LengthArray[ CachedRuns->Used ] = NTFS_CACHED_RUNS_DEL_INDEX;
            CachedRuns->Used += 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             TRUE,
                             TRUE,
                             WindowIndex);

    //
    //  Check if we need to move entries down to the nearest deleted window.
    //

    } else if ((DelWindow->EndIndex + 1) < LcnIndex) {

        //
        //  Update the insertion point to be LcnIndex - 1 and make a gap there
        //

        LcnIndex -= 1;

        //
        //  Move the entries between the end of the window and
        //  LcnIndex down to make room for this new entry.
        //

        RtlMoveMemory( CachedRuns->LcnArray + DelWindow->EndIndex,
                       CachedRuns->LcnArray + DelWindow->EndIndex + 1,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * (LcnIndex - DelWindow->EndIndex) );

        //
        // Update the indices in the Length-sorted list to reflect the
        // move of the lcn-sorted entries.
        //

        for (Count = DelWindow->EndIndex;
             Count < LcnIndex;
             Count += 1) {

            RunIndex = CachedRuns->LcnArray[ Count ].LengthIndex;
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LengthArray[ RunIndex ] -= 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             TRUE,
                             WindowIndex);

    //
    //  The window is adjacent to LcnIndex and the entry at LcnIndex
    //  sorts higher than the new run.  No moves are necessary.
    //  Decrement LcnIndex.
    //

    } else if ((DelWindow->EndIndex + 1) == LcnIndex) {

        LcnIndex -= 1;

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             TRUE,
                             WindowIndex);
    } else {

        //
        //  The window covers LcnIndex.  No moves are necessary.
        //

        if (DelWindow->StartIndex == LcnIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 TRUE,
                                 TRUE,
                                 WindowIndex);

        } else if (DelWindow->EndIndex == LcnIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 TRUE,
                                 WindowIndex);
        } else {

            //
            //  LcnIndex does not fall on the first or last entry in
            //  the window, we will update it to do so.  Otherwise we
            //  would have to split the window, with no real gain.
            //

            LcnIndex = DelWindow->EndIndex;

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 TRUE,
                                 WindowIndex);
        }
    }

    ASSERT( LcnIndex < CachedRuns->Avail );
    ASSERT( LcnIndex <= CachedRuns->Used );

    //
    //  Find the closest window of deleted entries to LenIndex.
    //

    DelWindow = NtfsGetDelWindow( CachedRuns,
                                  LenIndex,
                                  LenIndex,
                                  FALSE,
                                  &WindowIndex);
    ASSERT( DelWindow != NULL );
    ASSERT( (DelWindow->EndIndex < (LenIndex - 1)) ||
            (LenIndex < CachedRuns->Avail) );

    //
    //  The window is to the right.  Go ahead and
    //  move the entries between LenIndex and the start of the
    //  window up to make room for this new entry.
    //

    if (DelWindow->StartIndex > LenIndex) {

        RtlMoveMemory( CachedRuns->LengthArray + LenIndex + 1,
                       CachedRuns->LengthArray + LenIndex,
                       sizeof( USHORT ) * (DelWindow->StartIndex - LenIndex) );

        //
        // Update the indices in the Lcn-sorted list to reflect the
        // move of the length-sorted entries.
        //

        for (Count = LenIndex + 1;
             Count < DelWindow->StartIndex + 1;
             Count += 1) {

            RunIndex = CachedRuns->LengthArray[ Count ];
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LcnArray[ RunIndex ].LengthIndex += 1;
        }

        //
        //  We have just increased the number of entries in use with this
        //  right shift.
        //

        if (DelWindow->StartIndex == CachedRuns->Used) {

            CachedRuns->LcnArray[ CachedRuns->Used ].RunLength = 0;
            CachedRuns->LcnArray[ CachedRuns->Used ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            CachedRuns->Used += 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             TRUE,
                             FALSE,
                             WindowIndex);

    //
    //  The deleted window is to the left.  Slide everything to the left and
    //  Update the insertion point to be LenIndex - 1 and make a gap there.
    //

    } else if ((DelWindow->EndIndex + 1) < LenIndex) {

        LenIndex -= 1;

        //
        //  Move the entries between the end of the window and
        //  LenIndex down to make room for this new entry.
        //

        RtlMoveMemory( CachedRuns->LengthArray + DelWindow->EndIndex,
                       CachedRuns->LengthArray + DelWindow->EndIndex + 1,
                       sizeof( USHORT ) * (LenIndex - DelWindow->EndIndex) );

        //
        // Update the indices in the Lcn-sorted list to reflect the
        // move of the length-sorted entries.
        //

        for (Count = DelWindow->EndIndex;
             Count < LenIndex;
             Count += 1) {

            RunIndex = CachedRuns->LengthArray[ Count ];
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LcnArray[ RunIndex ].LengthIndex -= 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             FALSE,
                             WindowIndex);

    //
    //  The window is adjacent to LenIndex and the entry at LenIndex
    //  sorts higher than the new run.  No moves are necessary.
    //  Decrement LenIndex.
    //

    } else if ((DelWindow->EndIndex + 1) == LenIndex) {

        LenIndex -= 1;

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             FALSE,
                             WindowIndex);
    //
    //  The window covers LenIndex.  No moves are necessary.
    //

    } else {

        if (DelWindow->StartIndex == LenIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 TRUE,
                                 FALSE,
                                 WindowIndex);

        } else if (DelWindow->EndIndex == LenIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 FALSE,
                                 WindowIndex);
        } else {

            //
            //  LenIndex does not fall on the first or last entry in
            //  the window, we will update it to do so.  Otherwise we
            //  would have to split the window, with no real gain.
            //

            LenIndex = DelWindow->EndIndex;

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 FALSE,
                                 WindowIndex);
        }
    }

    ASSERT( LenIndex < CachedRuns->Avail );
    ASSERT( LenIndex <= CachedRuns->Used );

    //
    //  Insert the new entry at LcnIndex, LenIndex
    //

    ThisEntry = CachedRuns->LcnArray + LcnIndex;
    ThisEntry->Lcn = Lcn;
    ThisEntry->RunLength = Length;
    ThisEntry->LengthIndex = LenIndex;
    CachedRuns->LengthArray[ LenIndex ] = LcnIndex;

    //
    //  Update the count of entries of this size.
    //

    if (Length <= CachedRuns->Bins) {

        CachedRuns->BinArray[ Length - 1 ] += 1;
    }

    //
    //  Check if we've grown the number of entries used.
    //

    if (LcnIndex == CachedRuns->Used) {

        //
        //  Increase the count of the number of entries in use.
        //

        ASSERT( (CachedRuns->LengthArray[ CachedRuns->Used ] == NTFS_CACHED_RUNS_DEL_INDEX) ||
                (LenIndex == CachedRuns->Used) );

        CachedRuns->Used += 1;
    }

    if (LenIndex == CachedRuns->Used) {

        //
        //  Increase the count of the number of entries in use.
        //

        ASSERT( (CachedRuns->LcnArray[ CachedRuns->Used ].RunLength == 0) &&
                (CachedRuns->LcnArray[ CachedRuns->Used ].LengthIndex == NTFS_CACHED_RUNS_DEL_INDEX) );

        CachedRuns->Used += 1;
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsInsertCachedRun -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsDeleteCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT LcnIndex,
    IN USHORT LenIndex
    )

/*++

Routine Description:

    This routine is called to delete an Lcn run from the cached run arrays.

    It is possible that the lists will be compacted.  This will happen if
    we use the last window of deleted entries that we are allowed to cache
    for either the Lcn-sorted or Length-sorted lists.  Therefore, callers
    should be aware that indices may change across this call.  However we do
    guarantee that the indices LcnIndex and LenIndex will not move.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    LcnIndex - The index in the Lcn-sorted list of the entry to be deleted.

    LenIndex - The index in the Length-sorted list of the entry to be deleted.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteCachedRun\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    ASSERT( LcnIndex != NTFS_CACHED_RUNS_DEL_INDEX );
    ASSERT( LenIndex != NTFS_CACHED_RUNS_DEL_INDEX );

    //
    //  Update count of how many entries have this length.
    //

    if (CachedRuns->LcnArray[ LcnIndex ].RunLength <= CachedRuns->Bins) {

        CachedRuns->BinArray[CachedRuns->LcnArray[LcnIndex].RunLength - 1] -= 1;
    }

    //
    //  Update the entries so they appear to be deleted.
    //

    CachedRuns->LcnArray[ LcnIndex ].RunLength = 0;
    CachedRuns->LcnArray[ LcnIndex ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
    CachedRuns->LengthArray[ LenIndex ] = NTFS_CACHED_RUNS_DEL_INDEX;

    //
    //  Create windows of deleted entries to cover this newly deleted
    //  entry.
    //

    NtfsAddDelWindow( CachedRuns, LcnIndex, LcnIndex, TRUE );
    NtfsAddDelWindow( CachedRuns, LenIndex, LenIndex, FALSE );

#ifdef NTFS_CHECK_CACHED_RUNS

    //
    //  We will not check sort orders in NtfsVerifyCachedRuns because we
    //  could be making this call as part of deleting runs that have an
    //  overlap with a newly inserted run.  This could give false corruption
    //  warnings.
    //

    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, TRUE, TRUE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsDeleteCachedRun -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsInsertCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine is called to insert an Lcn run into the cached run arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Lcn to insert.

    Length - Length of the run to insert.

Return Value:

    None

--*/

{
    USHORT NextIndex;
    USHORT ThisIndex;
    LCN StartingLcn;
    LCN SaveLcn;
    LONGLONG RunLength;
    LONGLONG OldLength = 0;
    LCN EndOfNewRun;
    LCN EndOfThisRun;
    LCN EndOfNextRun;

    BOOLEAN ExtendedEntry = FALSE;
    BOOLEAN ScanForOverlap = FALSE;

    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_LCN_CLUSTER_RUN ThisEntry, NextEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInsertCachedLcn\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Return immediately if length is zero.
    //

    if (Length == 0) {

        DebugTrace( -1, Dbg, ("NtfsInsertCachedLcn -> VOID\n") );
        return;
    }

    //
    //  Lookup the Lcn at the start of our run.
    //

    NtfsLookupCachedLcn( CachedRuns,
                         Lcn,
                         &StartingLcn,
                         &RunLength,
                         &NextIndex );

    //
    //  We have a run to insert.  We need to deal with the following cases.
    //  Our strategy is to position ThisEntry at the position we want to store
    //  the resulting run.  Then remove any subsequent runs we overlap with, possibly
    //  extending the run we are working with.
    //
    //
    //      1 - We can merge with the prior run.  Save that position
    //          and remove any following slots we overlap with.
    //
    //      2 - We are beyond the array.  Simply store our run in
    //          this slot.
    //
    //      3 - We don't overlap with the current run.  Simply slide
    //          the runs up and insert a new entry.
    //
    //      4 - We are contained within the current run.  There is nothing
    //          we need to do.
    //
    //      5 - We overlap with the current run.  Use that slot
    //          and remove any following slots we overlap with.
    //

    NextEntry = CachedRuns->LcnArray + NextIndex;

    //
    //  Find a previous entry if present.
    //

    ThisIndex = NTFS_CACHED_RUNS_DEL_INDEX;

    if (NextIndex > 0) {

        ThisIndex = NextIndex - 1;
        ThisEntry = CachedRuns->LcnArray + ThisIndex;

        //
        //  If the entry has been deleted it must be ignored.  Get the
        //  window of deleted entries that covers it.
        //

        if (ThisEntry->RunLength == 0) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          ThisIndex,
                                          ThisIndex,
                                          TRUE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= ThisIndex );
            ASSERT( DelWindow->StartIndex <= ThisIndex );

            //
            //  Move to the entry just before the deleted window.
            //

            if (DelWindow->StartIndex > 0) {

                ThisIndex = DelWindow->StartIndex - 1;
                ThisEntry = CachedRuns->LcnArray + ThisIndex;

            } else {

                //
                //  All entries preceding NextEntry are deleted.
                //

                ThisIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }

        //
        //  Capture the end of the run.  It's invalid if we don't have
        //  a real index but all of the users of this will know that.
        //

        EndOfThisRun = ThisEntry->Lcn + ThisEntry->RunLength;
    }


    //
    //  Let's remember the end of the next run if present.
    //

    EndOfNewRun = Lcn + Length;

    if ((NextIndex < CachedRuns->Used) &&
        (NextEntry->RunLength != 0)) {

        EndOfNextRun = NextEntry->Lcn + NextEntry->RunLength;
    }

    //
    //  Case 1 - Merge with previous run.
    //

    if ((ThisIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
        (Lcn == EndOfThisRun)) {

        //
        //  Extend the entry in the runs array and remember the
        //  new length.  We will defer moving the run within the
        //  length-sorted array until we know the final length.
        //  It is possible that the combined entry overlaps with
        //  subsequent entries.  If the overlap lands in the middle
        //  of the final entry, the length may need to be extended
        //  even more.
        //

        Lcn = ThisEntry->Lcn;

        //
        //  Remember the original length of the entry.
        //

        OldLength = ThisEntry->RunLength;
        Length += ThisEntry->RunLength;
        ThisEntry->RunLength = Length;
        ExtendedEntry = TRUE;
        ScanForOverlap = TRUE;

    //
    //  Case 2 - We are at the end of the array
    //  Case 3 - We have a non-overlapping interior entry
    //

    } else if ((NextIndex >= CachedRuns->Used) ||
               (NextEntry->RunLength == 0) ||
               (EndOfNewRun < NextEntry->Lcn)) {

        //
        //  Insert the new run in both lists.
        //

        NtfsInsertCachedRun( CachedRuns,
                             Lcn,
                             Length,
                             NextIndex );

    //
    //  Case 4 - We are contained within the current entry.
    //

    } else if ((Lcn >= NextEntry->Lcn) &&
               (EndOfNewRun <= EndOfNextRun)) {

        NOTHING;

    //
    //  Case 5 - We overlap the next entry.  Extend the run to the end of
    //      current run if we end early.  Extend to the beginning of the
    //      run if we need to.
    //

    } else {

        //
        //  Remember if we are extending the run backwards.
        //

        if (Lcn < NextEntry->Lcn) {


            //
            //  Move the starting point back.
            //

            NextEntry->Lcn = Lcn;
            ExtendedEntry = TRUE;
            OldLength = NextEntry->RunLength;
        }

        //
        //  Remember if we go past the end of this run.
        //

        if (EndOfNewRun > EndOfNextRun) {

            ExtendedEntry = TRUE;
            ScanForOverlap = TRUE;
            OldLength = NextEntry->RunLength;
            Length = EndOfNewRun - NextEntry->Lcn;

        //
        //  Remember the full new length of this run.
        //

        } else {

            Length = EndOfNextRun - NextEntry->Lcn;
        }


        //
        //  Update the entry and position ThisEntry to point to it.
        //

        NextEntry->RunLength = Length;
        ThisEntry = NextEntry;
        ThisIndex = NextIndex;
    }

    //
    //  Walk forward to see if we need to join with other entires.
    //

    if (ScanForOverlap) {

        NextIndex = ThisIndex + 1;
        EndOfNewRun = ThisEntry->Lcn + ThisEntry->RunLength;

        while (NextIndex < CachedRuns->Used) {

            NextEntry = CachedRuns->LcnArray + NextIndex;

            //
            //  The entry has been deleted and must be ignored.  Get the
            //  window of deleted entries that covers it.
            //

            if (NextEntry->RunLength == 0) {

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              NextIndex,
                                              NextIndex,
                                              TRUE,
                                              NULL );

                ASSERT( DelWindow );
                ASSERT( DelWindow->EndIndex >= NextIndex );
                ASSERT( DelWindow->StartIndex <= NextIndex );

                NextIndex = DelWindow->EndIndex + 1;
                continue;
            }

            //
            //  Exit if there is no overlap.
            //

            if (EndOfNewRun < NextEntry->Lcn) {

                break;
            }

            //
            //  The runs overlap.
            //

            EndOfNextRun = NextEntry->Lcn + NextEntry->RunLength;
            if (EndOfNewRun < EndOfNextRun) {

                //
                //  Extend the new run.
                //

                ThisEntry->RunLength = EndOfNextRun - ThisEntry->Lcn;
                ExtendedEntry = TRUE;
                EndOfNewRun = EndOfNextRun;
            }

            //
            //  Delete the run.  This can cause compaction to be run and
            //  that will require us to have to recalculate ThisIndex.
            //

            SaveLcn = ThisEntry->Lcn;
            NtfsDeleteCachedRun( CachedRuns,
                                 NextIndex,
                                 NextEntry->LengthIndex );

            //
            //  Check if we should recompute ThisIndex because ThisEntry must have moved
            //  during compaction.
            //

            if ((ThisEntry->Lcn != SaveLcn) ||
                (ThisEntry->RunLength == 0) ) {

                NtfsLookupCachedLcn( CachedRuns,
                                     Lcn,
                                     &StartingLcn,
                                     &RunLength,
                                     &ThisIndex );
                ThisEntry = CachedRuns->LcnArray + ThisIndex;

                //
                //  Reset NextIndex to point to the end after ThisIndex.  That
                //  value may have moved due to compaction.
                //

                NextIndex = ThisIndex + 1;
            }

            if (EndOfNewRun == EndOfNextRun) {

                break;
            }
        }
    }

    //
    //  If we changed the existing entry then update the length bins.
    //

    if (ExtendedEntry) {

        NtfsModifyCachedBinArray( CachedRuns,
                                  OldLength,
                                  ThisEntry->RunLength );

        //
        //  Move the entry to the correct position in the length-sorted array
        //

        NtfsGrowLengthInCachedLcn( CachedRuns,
                                   ThisEntry,
                                   ThisIndex );
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsInsertCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsGrowLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    )

/*++

Routine Description:

    This routine is called when a run's length has been increased.  This
    routine makes the necessary changes to the length-sorted list.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    ThisEntry - Entry whose size is being changed.

    LcnIndex - The index in the Lcn-sorted array of this entry.

Return Value:

    None

--*/

{
    BOOLEAN FoundRun;
    USHORT Index;
    USHORT Count;
    USHORT RunIndex;
    USHORT WindowIndex;
    USHORT FirstWindowIndex;
    PNTFS_LCN_CLUSTER_RUN OldEntry;
    PNTFS_DELETED_RUNS DelWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGrowLengthInCachedLcn\n") );
    DebugTrace( 0, Dbg, ("ThisEntry = %08lx\n", ThisEntry) );
    DebugTrace( 0, Dbg, ("LcnIndex = %04x\n", LcnIndex) );
    DebugTrace( 0, Dbg, ("LengthIndex = %04x\n", ThisEntry->LengthIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Find the new insertion point.
    //

    //
    //  Find the nearest non-deleted entry with
    //  index > ThisEntry->LengthIndex.
    //

    if (ThisEntry->LengthIndex < (CachedRuns->Used - 1) ) {

        RunIndex = ThisEntry->LengthIndex + 1;

        if (CachedRuns->LengthArray[ RunIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) {

            //
            //  The entry has been deleted and must be ignored.  Get the
            //  window of deleted entries that covers it.
            //

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          RunIndex,
                                          RunIndex,
                                          FALSE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= RunIndex );
            ASSERT( DelWindow->StartIndex <= RunIndex );

            //
            //  Set RunIndex to the entry just after this deleted
            //  window.
            //

            if (DelWindow->EndIndex < (CachedRuns->Used - 1)) {

                RunIndex = DelWindow->EndIndex + 1;

            //
            //  Nothing to do.  The entry is still the largest in the
            //  list.
            //

            } else {

                RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }

    //
    //  Nothing to do.  The entry is still the largest in the list.
    //

    } else {

        RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
    }


    //
    //  If the run is possible out of position then compare our length with the following length.
    //

    if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

        OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ RunIndex ];

        //
        //  The entry will move in the list.  We need to search for
        //  the insertion position in the
        //  range [RunIndex..CachedRuns->Used].
        //

        if ((OldEntry->RunLength < ThisEntry->RunLength) ||
            ((OldEntry->RunLength == ThisEntry->RunLength) &&
             (OldEntry->Lcn < ThisEntry->Lcn)) ) {

            //
            //  Get the insertion point for the new entry.
            //

            FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                                      ThisEntry->RunLength,
                                                      &ThisEntry->Lcn,
                                                      &RunIndex,
                                                      TRUE,
                                                      &Index );

            //
            //  Index points to the closest run by Lcn that has a RunLength
            //  equal to Length.  We need to check to see if the new entry
            //  should be inserted before or after it.
            //

            if (FoundRun) {

                OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
                ASSERT( OldEntry->RunLength == ThisEntry->RunLength );

                //
                //  The new run should come before this one.
                //

                if (OldEntry->Lcn > ThisEntry->Lcn) {

                    //
                    //  We need to adjust Index downwards.
                    //

                    Index -= 1;
                }

            } else {

                //
                //  The entry pointed to by Index is either deleted or sorts
                //  higher than the new one.  Move the insertion point back one
                //  position.
                //

                Index -= 1;
            }

            //
            //  At this point, Index indicates the new position for the entry.
            //  Any entry currently at Index sorts lower.
            //

            ASSERT( Index > ThisEntry->LengthIndex );

            if (CachedRuns->LengthArray[ Index ] == NTFS_CACHED_RUNS_DEL_INDEX) {

                //
                //  Advance Index to before the start of this window of deleted
                //  entries.
                //

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              Index,
                                              Index,
                                              FALSE,
                                              NULL);
                ASSERT( DelWindow );
                ASSERT( DelWindow->StartIndex <= Index );
                ASSERT( DelWindow->EndIndex >= Index );

                Index = DelWindow->StartIndex - 1;
            }

            ASSERT( Index > ThisEntry->LengthIndex );

            //
            //  Move the entries between ThisEntry->LengthIndex + 1 and Index
            //  to the left.
            //

            RtlMoveMemory( CachedRuns->LengthArray + ThisEntry->LengthIndex,
                           CachedRuns->LengthArray + ThisEntry->LengthIndex + 1,
                           sizeof( USHORT ) * (Index - ThisEntry->LengthIndex) );

            //
            //  Update the indices in the Lcn-sorted list to reflect
            //  the move of the length-sorted entries.
            //

            for (Count = ThisEntry->LengthIndex, DelWindow = NULL;
                 Count < Index;
                 Count += 1) {

                RunIndex = CachedRuns->LengthArray[ Count ];

                //
                //  Update the Lcn array if the length entry isn't deleted.
                //

                if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

                    CachedRuns->LcnArray[ RunIndex ].LengthIndex = Count;

                } else {

                    //
                    //  Update the window of deleted entries.
                    //

                    if (DelWindow != NULL) {

                        //
                        //  The window we want must follow the last one we
                        //  found.
                        //

                        DelWindow += 1;
                        WindowIndex += 1;

                        ASSERT( WindowIndex < CachedRuns->DelLengthCount );

                    } else {

                        //
                        //  Lookup the window containing the entry.  Remember
                        //  to look for Count + 1 because the window we are
                        //  seaching for has not yet been updated.
                        //

                        DelWindow = NtfsGetDelWindow( CachedRuns,
                                                      Count + 1,
                                                      Count + 1,
                                                      FALSE,
                                                      &WindowIndex);
                        ASSERT( DelWindow != NULL );
                        FirstWindowIndex = WindowIndex;
                    }

                    ASSERT( DelWindow->StartIndex == (Count + 1) );
                    ASSERT( DelWindow->EndIndex < Index );

                    //
                    //  Update the window.
                    //

                    DelWindow->StartIndex -= 1;
                    DelWindow->EndIndex -= 1;

                    //
                    //  Advance Count past window.
                    //

                    Count = DelWindow->EndIndex;
                }
            }

            //
            //  We may have moved the first window to the left such that
            //  it should be merged with the preceding window.
            //

            if ((DelWindow != NULL) && (FirstWindowIndex > 0) ) {

                PNTFS_DELETED_RUNS PrevWindow;

                DelWindow = CachedRuns->DeletedLengthWindows + FirstWindowIndex;
                PrevWindow = DelWindow - 1;

                if (PrevWindow->EndIndex == (DelWindow->StartIndex - 1) ) {

                    //
                    //  We need to merge these windows.
                    //

                    PrevWindow->EndIndex = DelWindow->EndIndex;
                    NtfsDeleteDelWindow( CachedRuns,
                                         FALSE,
                                         FirstWindowIndex);
                }
            }

            //
            //  Update the entries corresponding to ThisEntry;
            //

            CachedRuns->LengthArray[ Index ] = LcnIndex;
            ThisEntry->LengthIndex = Index;
        }
    }

    DebugTrace( 0, Dbg, ("Final LengthIndex = %04x\n", ThisEntry->LengthIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, TRUE, TRUE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsGrowLengthInCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsShrinkLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    )

/*++

Routine Description:

    This routine is called when a run's length has been reduced.  This routine
    makes the necessary changes to the length-sorted list.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    ThisEntry - Entry whose size is being changed.

    LcnIndex - The index in the Lcn-sorted array of this entry.

Return Value:

    None

--*/

{
    BOOLEAN FoundRun;
    USHORT Index;
    USHORT WindowIndex;
    USHORT Count;
    USHORT RunIndex;
    PNTFS_LCN_CLUSTER_RUN OldEntry;
    PNTFS_DELETED_RUNS DelWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsShrinkLengthInCachedLcn\n") );
    DebugTrace( 0, Dbg, ("ThisEntry = %08lx\n", ThisEntry) );
    DebugTrace( 0, Dbg, ("LcnIndex = %04x\n", LcnIndex) );
    DebugTrace( 0, Dbg, ("LengthIndex = %04x\n", ThisEntry->LengthIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Find the nearest non-deleted entry with
    //  index < ThisEntry->LengthIndex.
    //

    if (ThisEntry->LengthIndex > 0) {

        RunIndex = ThisEntry->LengthIndex - 1;
        if (CachedRuns->LengthArray[ RunIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) {

            //
            //  The entry has been deleted and must be ignored.  Get the
            //  window of deleted entries that covers it.
            //

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          RunIndex,
                                          RunIndex,
                                          FALSE,
                                          NULL);
            ASSERT( DelWindow );
            ASSERT( DelWindow->EndIndex >= RunIndex );
            ASSERT( DelWindow->StartIndex <= RunIndex );

            //
            //  Move ahead of this window if possible.
            //

            if (DelWindow->StartIndex > 0) {

                RunIndex = DelWindow->StartIndex - 1;

            //
            //  Nothing to do.  The entry is still the smallest in the
            //  list.
            //

            } else {

                RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }

    //
    //  Nothing to do.  The entry is still the smallest in the list.
    //

    } else {

        RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
    }

    //
    //  If the run is possible out of position then compare our length with the prior length.
    //

    if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

        OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ RunIndex ];

        //
        //  Check for a conflict with the previous run.
        //

        if ((OldEntry->RunLength > ThisEntry->RunLength) ||
            ((OldEntry->RunLength == ThisEntry->RunLength) &&
             (OldEntry->Lcn > ThisEntry->Lcn)) ) {

            //
            //  Get the insertion point for the new entry.
            //

            FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                                      ThisEntry->RunLength,
                                                      &ThisEntry->Lcn,
                                                      &RunIndex,
                                                      FALSE,
                                                      &Index );

            //
            //  If found Index points to the closest run by Lcn that has a RunLength
            //  equal to Length.  We need to check to see if the new entry
            //  should be inserted before or after it.
            //

            if (FoundRun) {

                OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
                ASSERT( OldEntry->RunLength == ThisEntry->RunLength );

                if (OldEntry->Lcn < ThisEntry->Lcn) {

                    //
                    //  The new run should come after this one.
                    //  We need to adjust Index upwards.
                    //

                    Index += 1;
                    DebugTrace( 0, Dbg, ("Increment Index to %04x\n", Index) );
                }
            }

            //
            //  At this point, Index indicates the new position for the entry.
            //  Any entry currently at Index sorts higher.
            //

            ASSERT( Index < ThisEntry->LengthIndex );

            //
            //  Advance Index past the end of this window of deleted
            //  entries.
            //

            if (CachedRuns->LengthArray[ Index ] == NTFS_CACHED_RUNS_DEL_INDEX) {

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              Index,
                                              Index,
                                              FALSE,
                                              NULL);
                ASSERT( DelWindow );
                ASSERT( DelWindow->StartIndex <= Index );
                ASSERT( DelWindow->EndIndex >= Index );

                Index = DelWindow->EndIndex + 1;
                ASSERT( Index < ThisEntry->LengthIndex );
            }

            //  Move the entries between Index and ThisEntry->LengthIndex - 1
            //  to the right.
            //

            RtlMoveMemory( CachedRuns->LengthArray + Index + 1,
                           CachedRuns->LengthArray + Index,
                           sizeof( USHORT ) * (ThisEntry->LengthIndex - Index) );

            //
            //  Update the indices in the Lcn-sorted list to reflect
            //  the move of the length-sorted entries.
            //

            for (Count = Index + 1, DelWindow = NULL;
                 Count <= ThisEntry->LengthIndex;
                 Count += 1) {

                RunIndex = CachedRuns->LengthArray[ Count ];

                //
                //  Update the Lcn array if the length entry isn't deleted.
                //

                if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

                    CachedRuns->LcnArray[ RunIndex ].LengthIndex = Count;

                } else {

                    //
                    //  Update the window of deleted entries.
                    //

                    if (DelWindow != NULL) {

                        //
                        //  The window we want must follow the last one we
                        //  found.
                        //

                        DelWindow += 1;
                        WindowIndex += 1;

                        ASSERT( WindowIndex < CachedRuns->DelLengthCount );

                    //
                    //  Lookup the window containing the entry.  Remeber
                    //  to look for Count - 1 because the window we are
                    //  seaching for has not yet been updated.
                    //

                    } else {

                        DelWindow = NtfsGetDelWindow( CachedRuns,
                                                      Count - 1,
                                                      Count - 1,
                                                      FALSE,
                                                      &WindowIndex);
                        ASSERT( DelWindow != NULL );
                    }

                    ASSERT( DelWindow->StartIndex == (Count - 1) );
                    ASSERT( DelWindow->EndIndex < ThisEntry->LengthIndex );

                    //
                    //  Update the window.
                    //

                    DelWindow->StartIndex += 1;
                    DelWindow->EndIndex += 1;

                    //
                    //  Advance Count past window.
                    //

                    Count = DelWindow->EndIndex;
                }
            }

            //
            //  We may have moved the last window to the right such that
            //  it should be merged with the following window.
            //

            if ((DelWindow != NULL) &&
                ((WindowIndex + 1) < CachedRuns->DelLengthCount)) {

                PNTFS_DELETED_RUNS NextWindow = DelWindow + 1;

                if (DelWindow->EndIndex == (NextWindow->StartIndex - 1) ) {

                    //
                    //  We need to merge these windows.
                    //

                    DelWindow->EndIndex = NextWindow->EndIndex;
                    NtfsDeleteDelWindow( CachedRuns,
                                         FALSE,
                                         WindowIndex + 1);
                }
            }

            //
            //  Update the entries corresponding to ThisEntry;
            //

            CachedRuns->LengthArray[ Index ] = LcnIndex;
            ThisEntry->LengthIndex = Index;
        }
    }

    DebugTrace( 0, Dbg, ("Final LengthIndex = %04x\n", ThisEntry->LengthIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsShrinkLengthInCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsRemoveCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine is called to remove an entry from the cached run array.  The run is not
    guaranteed to be present.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Start of run to remove.

    Length - Length of run to remove.

Return Value:

    None

--*/

{
    USHORT Index;
    LCN StartingLcn;

    LCN EndOfExistingRun;
    LCN EndOfInputRun = Lcn + Length;
    LONGLONG RunLength;

    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;

    BOOLEAN FirstFragSmaller = FALSE;
    BOOLEAN DontSplit = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveCachedLcn\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Return immediately if length is zero.
    //

    if (Length == 0) {

        DebugTrace( -1, Dbg, ("NtfsRemoveCachedLcn -> VOID\n") );
        return;
    }

    //
    //  Lookup the run.  If we don't find anything then point past the end
    //  of the array.
    //

    NtfsLookupCachedLcn( CachedRuns, Lcn, &StartingLcn, &RunLength, &Index );

    //
    //  We have several cases to deal with.
    //
    //      1 - This run is past the end of array.  Nothing to do.
    //      2 - This run is not in the array.  Nothing to do.
    //      3 - This run starts past the beginning of a entry.  Resize the entry.
    //      4 - This run contains a complete array entry.  Remove the entry.
    //      5 - This run ends before the end of an entry.  Resize the entry.
    //

    //
    //  Loop to process the case where we encounter several entries.
    //  Test for case 1 as the exit condition for the loop.
    //

    while (Index < CachedRuns->Used) {

        ThisEntry = CachedRuns->LcnArray + Index;

        //
        //  The entry has been deleted and must be ignored.  Get the
        //  window of deleted entries that covers it.
        //

        if (ThisEntry->RunLength == 0) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          Index,
                                          Index,
                                          TRUE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= Index );
            ASSERT( DelWindow->StartIndex <= Index );

            //
            //  Advance the index past the deleted entries.
            //

            Index = DelWindow->EndIndex + 1;
            continue;
        }

        //
        //  Remember the range of this run.
        //

        EndOfExistingRun = ThisEntry->Lcn + ThisEntry->RunLength;

        //
        //  Case 2 - No overlap.
        //

        if (EndOfInputRun <= ThisEntry->Lcn) {

            break;

        //
        //  Case 3 - The run starts beyond the beginning of this run.
        //

        } else if (Lcn > ThisEntry->Lcn) {

            //
            //  Reduce the current entry so that is covers only the
            //  first fragment and move it to the correct position in
            //  the length-sorted array.
            //

            NtfsModifyCachedBinArray( CachedRuns,
                                      ThisEntry->RunLength,
                                      Lcn - ThisEntry->Lcn );

            ThisEntry->RunLength = Lcn - ThisEntry->Lcn;

            //
            //  Adjust this length in the run length array.
            //

            NtfsShrinkLengthInCachedLcn( CachedRuns,
                                         ThisEntry,
                                         Index );

            //
            //  We need to split this entry in two.  Now reinsert the portion
            //  split off.
            //

            if (EndOfInputRun < EndOfExistingRun) {

                //
                //  Now create a new entry that covers the second
                //  fragment.  It should directly follow ThisEntry in the
                //  Lcn-sorted list.
                //

                NtfsInsertCachedRun( CachedRuns,
                                     EndOfInputRun,
                                     EndOfExistingRun - EndOfInputRun,
                                     Index + 1);

                //
                //  Nothing else to do.
                //

                break;

            //
            //  We will trim the tail of this entry.
            //

            } else if (EndOfInputRun > EndOfExistingRun) {

                Lcn = EndOfExistingRun;
                Index += 1;

            } else {

                break;
            }

        //
        //  Case 4 - Remove a complete entry.
        //

        } else if (EndOfInputRun >= EndOfExistingRun) {

            ASSERT( Lcn <= ThisEntry->Lcn );

            //
            //  Delete the run.  This can cause compaction to be run but we
            //  are guaranteed that the entry at Index will not move.
            //

            NtfsDeleteCachedRun( CachedRuns,
                                 Index,
                                 ThisEntry->LengthIndex );

            //
            //  Advance the Lcn if we go past this entry.
            //

            if (EndOfInputRun > EndOfExistingRun) {

                Lcn = EndOfExistingRun;

            } else {

                break;
            }

        //
        //  Case 5 - This entry starts at or before the start of the run
        //      and ends before the end of the run.
        //

        } else {

            ASSERT( Lcn <= ThisEntry->Lcn );
            ASSERT( EndOfInputRun < EndOfExistingRun );

            //
            //  Reduce the current entry so that is covers only the end of the
            //  run and move it to the correct position in the length-sorted
            //  array.
            //

            NtfsModifyCachedBinArray( CachedRuns,
                                      ThisEntry->RunLength,
                                      EndOfExistingRun - EndOfInputRun );

            ThisEntry->RunLength = EndOfExistingRun - EndOfInputRun;

            ThisEntry->Lcn = EndOfInputRun;
            NtfsShrinkLengthInCachedLcn( CachedRuns,
                                         ThisEntry,
                                         Index );
            break;
        }
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsRemoveCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsGrowCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine is called to grow the size of the cached run arrays if
    necessary.  We will not exceed the CachedRuns->MaximumSize.  It
    is assumed that there are no deleted entries in the arrays.  If we can
    grow the arrays, we double the size unless we would grow it by more than
    our max delta.  Otherwise we grow it by that amount.

Arguments:

    CachedRuns - Pointer to the cached runs structure to grow.

Return Value:

    BOOLEAN - TRUE if we were able to grow the structure, FALSE otherwise.

--*/

{
    USHORT NewSize;
    USHORT OldSize = CachedRuns->Avail;
    USHORT Index;
    PNTFS_LCN_CLUSTER_RUN NewLcnArray;
    PUSHORT NewLengthArray;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGrowCachedRuns\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Calculate the new size.
    //

    if (CachedRuns->Avail > NTFS_MAX_CACHED_RUNS_DELTA) {

        NewSize = CachedRuns->Avail + NTFS_MAX_CACHED_RUNS_DELTA;

    } else {

        NewSize = CachedRuns->Avail * 2;
    }

    if (NewSize > CachedRuns->MaximumSize) {

        NewSize = CachedRuns->MaximumSize;
    }

    if (NewSize > CachedRuns->Avail) {

        //
        //  Allocate the new buffers and copy the previous buffers over.
        //

        NewLcnArray = NtfsAllocatePoolNoRaise( PagedPool,
                                               sizeof( NTFS_LCN_CLUSTER_RUN ) * NewSize );

        if (NewLcnArray == NULL) {

            DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> FALSE\n") );
            return FALSE;
        }

        NewLengthArray = NtfsAllocatePoolNoRaise( PagedPool,
                                                  sizeof( USHORT ) * NewSize );

        if (NewLengthArray == NULL) {

            NtfsFreePool( NewLcnArray );
            DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> FALSE\n") );
            return FALSE;
        }

        RtlCopyMemory( NewLcnArray,
                       CachedRuns->LcnArray,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * CachedRuns->Used );

        RtlCopyMemory( NewLengthArray,
                       CachedRuns->LengthArray,
                       sizeof( USHORT ) * CachedRuns->Used );

        //
        //  Mark all entries so that they can be detected as deleted.
        //

        for (Index = CachedRuns->Used; Index < NewSize; Index += 1) {

            NewLcnArray[ Index ].RunLength = 0;
            NewLcnArray[ Index ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            NewLengthArray[ Index ] = NTFS_CACHED_RUNS_DEL_INDEX;
        }

        //
        //  Deallocate the existing buffers and set the cached runs structure
        //  to point to the new buffers.
        //

        NtfsFreePool( CachedRuns->LcnArray );
        CachedRuns->LcnArray = NewLcnArray;

        NtfsFreePool( CachedRuns->LengthArray );
        CachedRuns->LengthArray = NewLengthArray;

        //
        //  Update the count of available entries.
        //

        CachedRuns->Avail = NewSize;

        //
        //  Create a window of deleted entries to cover the newly allocated
        //  entries.
        //

        NtfsAddDelWindow( CachedRuns, OldSize, NewSize - 1, TRUE );
        NtfsAddDelWindow( CachedRuns, OldSize, NewSize - 1, FALSE );

    } else {

        DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> FALSE\n") );
        return FALSE;
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> TRUE\n") );

    return TRUE;
}


//
//  Local support routine
//

VOID
NtfsCompactCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnSortedList
    )

/*++

Routine Description:

    This routine is called to compact two of the windows of deleted entries
    into a single window.  Note that entries in the given range of indices
    have been marked as deleted, but are not yet in a window of deleted
    entries.  This should not trigger a corruption warning.  To avoid
    confusion, we will be sure not to choose the windows to be compacted
    such that the given range of indices gets moved.

Arguments:

    CachedRuns - Pointer to the cached run structure.

    FirstIndex - Index that marks the start of the newest range of deleted
        entries.

    LastIndex - The index of the last entry in the newest range of deleted
        entries.

    LcnSortedList - If TRUE, the Lcn-sorted list is compacted.
        If FALSE, the length-sorted list is compacted.

Return Value:

    None

--*/

{
    USHORT Gap1;
    USHORT Gap2;
    USHORT RunIndex;
    USHORT Count;
    USHORT GapIndex = NTFS_CACHED_RUNS_DEL_INDEX;
    PUSHORT WindowCount;
    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_DELETED_RUNS PrevWindow;
    PNTFS_DELETED_RUNS Windows;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCompactCachedRuns\n") );

    ASSERT( FirstIndex != NTFS_CACHED_RUNS_DEL_INDEX );
    ASSERT( LastIndex != NTFS_CACHED_RUNS_DEL_INDEX );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    if (LcnSortedList) {

        WindowCount = &CachedRuns->DelLcnCount;
        Windows = CachedRuns->DeletedLcnWindows;

    } else {

        WindowCount = &CachedRuns->DelLengthCount;
        Windows = CachedRuns->DeletedLengthWindows;
    }

    ASSERT( *WindowCount > 1 );

    //
    //  Loop through the windows looking for the smallest gap of non-deleted
    //  entries.  We will not choose a gap the covers [FirstIndex..LastIndex]
    //

    Gap1 = NTFS_CACHED_RUNS_DEL_INDEX;
    for (Count = 1, DelWindow = Windows + 1, PrevWindow = Windows;
         (Count < *WindowCount) && (Gap1 > 1);
         Count += 1, PrevWindow += 1, DelWindow += 1) {

        //
        //  Compute this gap if the exempt range doesn't fall within it.  We want to track the
        //  actual number of entries.
        //

        if ((PrevWindow->StartIndex > LastIndex) ||
            (DelWindow->EndIndex < FirstIndex)) {

            Gap2 = DelWindow->StartIndex - (PrevWindow->EndIndex + 1);

            //
            //  Remember if this gap is our smallest so far.
            //

            if (Gap2 < Gap1) {

                Gap1 = Gap2;
                GapIndex = Count;
            }
        }
    }

    //
    //  Merge the window at GapIndex with the one that precedes it by moving
    //  the non-deleted entries in the gap between them to the start of the
    //  preceding window.
    //

    ASSERT( GapIndex != NTFS_CACHED_RUNS_DEL_INDEX );
    DelWindow = Windows + GapIndex;
    PrevWindow = DelWindow - 1;

    //
    //  Copy the block of entries that we will be keeping
    //  into the insertion point.
    //

    DebugTrace( 0,
                Dbg,
                ("copy %04x entries from=%04x to=%04x\n", Gap1, PrevWindow->EndIndex + 1, PrevWindow->StartIndex) );

    if (LcnSortedList) {

        RtlMoveMemory( CachedRuns->LcnArray + PrevWindow->StartIndex,
                       CachedRuns->LcnArray + PrevWindow->EndIndex + 1,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * Gap1 );

        //
        //  Update the indices in the Length-sorted list to
        //  reflect the move of the lcn-sorted entries.
        //

        for (Count = 0; Count < Gap1; Count += 1) {

            RunIndex = CachedRuns->LcnArray[ PrevWindow->StartIndex + Count ].LengthIndex;
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LengthArray[ RunIndex ] = PrevWindow->StartIndex + Count;
        }

        //
        //  Mark the entries from the gap that are going to be part of the
        //  merged windows as deleted.
        //
        //  We only need to do this for entries past the end of the gap we are deleting.
        //

        Count = PrevWindow->StartIndex + Gap1;

        if (Count < PrevWindow->EndIndex + 1) {

            Count = PrevWindow->EndIndex + 1;
        }

        while (Count < DelWindow->StartIndex) {

            CachedRuns->LcnArray[ Count ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            CachedRuns->LcnArray[ Count ].RunLength = 0;
            Count += 1;
        }

    } else {

        RtlMoveMemory( CachedRuns->LengthArray + PrevWindow->StartIndex,
                       CachedRuns->LengthArray + PrevWindow->EndIndex + 1,
                       sizeof( USHORT ) * Gap1 );

        //
        //  Update the indices in the Lcn-sorted list to reflect
        //  the move of the length-sorted entries.
        //

        for (Count = 0; Count < Gap1; Count += 1) {

            RunIndex = CachedRuns->LengthArray[ PrevWindow->StartIndex + Count ];
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LcnArray[ RunIndex ].LengthIndex = PrevWindow->StartIndex + Count;
        }

        //
        //  Mark the entries from the gap that are going to be part of the
        //  merged windows as deleted.
        //
        //  We only need to do this for entries past the end of the gap we are deleting.
        //


        Count = PrevWindow->StartIndex + Gap1;

        if (Count < PrevWindow->EndIndex + 1) {

            Count = PrevWindow->EndIndex + 1;
        }

        while (Count < DelWindow->StartIndex) {

            CachedRuns->LengthArray[ Count ] = NTFS_CACHED_RUNS_DEL_INDEX;
            Count += 1;
        }
    }

    //
    //  Update the previous window to reflect the larger size.
    //

    ASSERT( (PrevWindow->EndIndex + Gap1 + 1) == DelWindow->StartIndex );
    PrevWindow->StartIndex += Gap1;
    PrevWindow->EndIndex = DelWindow->EndIndex;

    //
    //  Delete DelWindow.
    //

    NtfsDeleteDelWindow( CachedRuns,
                         LcnSortedList,
                         GapIndex);

#ifdef NTFS_CHECK_CACHED_RUNS

    //
    //  We will not check sort orders in NtfsVerifyCachedRuns because we
    //  could be making this call as part of deleting runs that have an
    //  overlap with a newly inserted run.  This could give false corruption
    //  warnings.
    //

    if (LcnSortedList) {

        NtfsVerifyCachedLcnRuns ( CachedRuns,
                                  FirstIndex,
                                  LastIndex,
                                  TRUE,
                                  TRUE );
    } else {

        NtfsVerifyCachedLenRuns ( CachedRuns,
                                  FirstIndex,
                                  LastIndex,
                                  TRUE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsCompactCachedRuns -> VOID\n") );
    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsPositionCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PUSHORT Index
    )

/*++

Routine Description:

    This routine is called to position ourselves with an Lcn lookup.  On return
    we will return the index where the current entry should go or where it
    currently resides.  The return value indicates whether the entry is
    present.  The Lcn does not have to be at the beginning of the found run.

Arguments:

    CachedRuns - Pointer to the cached run structure.

    Lcn - Lcn we are interested in.

    Index - Address to store the index of the position in the Lcn array.

Return Value:

    BOOLEAN - TRUE if the entry is found, FALSE otherwise.

--*/

{
    USHORT Min, Max, Current;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_DELETED_RUNS DelWindow;
    BOOLEAN FoundLcn = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPositionCachedLcn\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    //
    //  Perform a binary search to find the index.  Note we start Max past
    //  the end so don't rely on it being valid.
    //

    Min = 0;
    Max = CachedRuns->Avail;

    while (Min != Max) {

        Current = (USHORT) (((ULONG) Max + Min) / 2);
        ThisEntry = CachedRuns->LcnArray + Current;

        //
        //  The current entry has been deleted and must be ignored.
        //  Get the window of deleted entries that covers Current.
        //

        if (ThisEntry->RunLength == 0) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          Current,
                                          Current,
                                          TRUE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= Current );
            ASSERT( DelWindow->StartIndex <= Current );

            //
            //  Go to the edges of this deleted entries window to determine
            //  which way we should go.
            //

            //
            //  If the deleted window spans the remaining used runs then move
            //  to the beginning of the window.
            //

            if ((DelWindow->EndIndex + 1) >= CachedRuns->Used ) {

                Max = DelWindow->StartIndex;
                ASSERT( Min <= Max );

            //
            //  If the deleted window is not at index zero then look to the entry
            //  on the left.
            //

            } else if (DelWindow->StartIndex > 0) {

                ThisEntry = CachedRuns->LcnArray + DelWindow->StartIndex - 1;
                ASSERT( ThisEntry->RunLength != 0 );

                if (Lcn < (ThisEntry->Lcn + ThisEntry->RunLength)) {

                    //
                    //  The search should continue from the lower edge of the
                    //  window.
                    //

                    Max = DelWindow->StartIndex;
                    ASSERT( Min <= Max );

                } else {

                    //
                    //  The search should continue from the upper edge of the
                    //  window.
                    //

                    Min = DelWindow->EndIndex + 1;
                    ASSERT( Min <= Max );
                }

            //
            //  The search should continue from the upper edge of the
            //  deleted window.
            //

            } else {

                Min = DelWindow->EndIndex + 1;
                ASSERT( Min <= Max );
            }

            //
            //  Loop back now that Min or Max has been updated.
            //

            continue;
        }

        //
        //  If our Lcn is less than this then move the Max value down.
        //

        if (Lcn < ThisEntry->Lcn) {

            Max = Current;
            ASSERT( Min <= Max );

        //
        //  If our Lcn is outside the range for this entry then move
        //  the Min value up.  Make it one greater than the current
        //  index since we always round the index down.
        //

        } else if (Lcn >= (ThisEntry->Lcn + ThisEntry->RunLength)) {

            Min = Current + 1;
            ASSERT( Min <= Max );

        //
        //  This must be a hit.
        //

        } else {

            Min = Current;

            FoundLcn = TRUE;
            break;
        }
    }

    *Index = Min;

    //
    //  Check that we are positioned correctly.
    //

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    ThisEntry = CachedRuns->LcnArray + *Index - 1;

    ASSERT( FoundLcn ||
            (*Index == 0) ||
            (ThisEntry->RunLength == 0) ||
            (Lcn >= (ThisEntry->Lcn + ThisEntry->RunLength)) );

    ThisEntry = CachedRuns->LcnArray + *Index;
    ASSERT( FoundLcn ||
            (*Index == CachedRuns->Used) ||
            (ThisEntry->RunLength == 0) ||
            (Lcn < ThisEntry->Lcn) );
#endif

    DebugTrace( -1, Dbg, ("NtfsPositionCachedLcn -> %01x\n", FoundLcn) );

    return FoundLcn;
}


//
//  Local support routine
//

BOOLEAN
NtfsPositionCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG RunLength,
    IN PLCN Lcn OPTIONAL,
    IN PUSHORT StartIndex OPTIONAL,
    IN BOOLEAN SearchForward,
    OUT PUSHORT RunIndex
    )
/*++

Routine Description:

    This routine is called to search for a run of a particular length.  It
    returns the position of the run being looked for.  If the Lcn is specified
    then the run matching the desired RunLength that is closest to Lcn is
    chosen.

    This routine can be used to determine the insertion position for a new
    run.  The returned Index will be at or adjacent to the new run's position
    in the list.  The caller will have to check which.

    If this routine fails to find a run of the desired length, the returned
    Index will either point to a deleted entry or an entry that is larger or
    past the end of the array.

    ENHANCEMENT - If there is no match for the desired RunLength we currently choose the
    next higher size without checking for the one with the closest Lcn value.
    We could change the routine to restart the loop looking explicitly for the
    larger size so that the best choice in Lcn terms is returned.

Arguments:

    CachedRuns - Pointer to cached run structure.

    RunLength - Run length to look for.

    Lcn - If specified then we try to find the run which is closest to
        this Lcn, but has the requested Length.  If Lcn is UNUSED_LCN, we
        will end up choosing a match with the lowest Lcn as UNUSED_LCN
        is < 0.  This will result in maximum left-packing of the disk.
        If not specified we will randomly allocate matches on the length
        array.

    StartIndex - Optional index where the search should begin.

    SearchForward - If TRUE, the search should begin at StartIndex.  If
        FALSE, the search should end at StartIndex.

    RunIndex - Address to store index where the desired run is or should be.

Return Value:

    BOOLEAN - TRUE if we found a run with the desired RunLength,
        FALSE otherwise.

--*/

{
    USHORT Min, Max, Current, LcnIndex;
    USHORT MinMatch, MaxMatch;
    LONGLONG Distance;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_DELETED_RUNS DelWindow;
    BOOLEAN FoundRun = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPositionCachedLcnByLength\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    ASSERT( UNUSED_LCN < 0 );

    //
    //  Keep track of whether we are hitting matching length entries during the search.
    //

    MinMatch = MaxMatch = NTFS_CACHED_RUNS_DEL_INDEX;

    //
    //  Binary search to find the first entry which is equal to
    //  or larger than the one we wanted.  Bias the search with the
    //  user's end point if necessary.
    //

    Min = 0;
    Max = CachedRuns->Avail;
    if (ARGUMENT_PRESENT( StartIndex )) {

        if (SearchForward) {

            Min = *StartIndex;

        } else {

            Max = *StartIndex + 1;

            //
            //  The only time this could happen is if we are trying to
            //  find an entry that is larger than the largest in use.
            //  Just use values that will terminate the search.
            //

            if (Max > CachedRuns->Used) {

                Min = Max = CachedRuns->Used;
            }
        }

        ASSERT( Min <= Max );
    }

    while (Min != Max) {

        ASSERT( Min <= Max );

        //
        //  Find the mid-index point along with the Lcn index out of
        //  the length array and the entry in the Lcn array.
        //

        Current = (USHORT) (((ULONG) Max + Min) / 2);
        LcnIndex = CachedRuns->LengthArray[Current];
        ThisEntry = CachedRuns->LcnArray + LcnIndex;

        //
        //  The current entry has been deleted and must be
        //  ignored.  Get the window of deleted entries that
        //  covers Current.
        //

        if (LcnIndex == NTFS_CACHED_RUNS_DEL_INDEX) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          Current,
                                          Current,
                                          FALSE,
                                          NULL);
            ASSERT( DelWindow );
            ASSERT( DelWindow->EndIndex >= Current );
            ASSERT( DelWindow->StartIndex <= Current );

            //
            //  Go to the edges of this deleted entries window to determine
            //  which way we should go.
            //

            //
            //  If this window extends past the end of the used entries
            //  then move to the begining of it.
            //

            if ((DelWindow->EndIndex + 1) >= CachedRuns->Used ) {

                Max = DelWindow->StartIndex;
                ASSERT( Min <= Max );

            //
            //  If this window doesn't start at index zero then determine which
            //  direction to go.
            //

            } else if (DelWindow->StartIndex > 0) {

                //
                //  Point to the entry adjacent to the lower end of the window.
                //

                LcnIndex = CachedRuns->LengthArray[ DelWindow->StartIndex - 1 ];
                ASSERT( LcnIndex != NTFS_CACHED_RUNS_DEL_INDEX );

                ThisEntry = CachedRuns->LcnArray + LcnIndex;
                ASSERT( ThisEntry->RunLength != 0 );

                //
                //  If this entry is longer than we asked for then the search
                //  should continue from the lower edge of the window.
                //

                if (RunLength < ThisEntry->RunLength) {

                    Max = DelWindow->StartIndex;
                    ASSERT( Min <= Max );

                //
                //  The search should continue from the upper edge of the
                //  window if our run length is longer.
                //

                } else if (RunLength > ThisEntry->RunLength) {

                    Min = DelWindow->EndIndex + 1;
                    ASSERT( Min <= Max );

                //
                //  We have found the desired run if our caller didn't specify
                //  an Lcn.
                //

                } else if (!ARGUMENT_PRESENT( Lcn )) {

                    Min = DelWindow->StartIndex - 1;
                    FoundRun = TRUE;
                    break;

                //
                //  If our Lcn is less than the Lcn in the entry then the search
                //  should continue from the lower edge of the window.
                //

                } else if (*Lcn < ThisEntry->Lcn) {

                    Max = DelWindow->StartIndex;
                    ASSERT( Min <= Max );

                //
                //  If the entry overlaps then we have a match.  We already
                //  know our Lcn is >= to the start Lcn of the range from
                //  the test above.
                //

                } else if (*Lcn < (ThisEntry->Lcn + ThisEntry->RunLength)) {

                    Min = DelWindow->StartIndex - 1;
                    FoundRun = TRUE;
                    break;

                //
                //  Move Min past the end of the window.  We'll check later to see
                //  which end is closer.
                //

                } else {

                    Min = DelWindow->EndIndex + 1;
                    MinMatch = DelWindow->StartIndex - 1;
                    ASSERT( Min <= Max );
                    ASSERT( MinMatch != MaxMatch );
                }

            //
            //  The search should continue from the upper edge of the
            //  window.
            //

            } else {

                Min = DelWindow->EndIndex + 1;
                ASSERT( Min <= Max );
            }

            //
            //  Loop back now that Min or Max has been updated.
            //

            continue;
        }

        //
        //  If the run length of this entry is more than we want then
        //  move the Max value down.
        //

        if (RunLength < ThisEntry->RunLength) {

            Max = Current;
            ASSERT( Min <= Max );

        //
        //  If the run length of this entry is less than we want then
        //  move the Min value up.
        //

        } else if (RunLength > ThisEntry->RunLength) {

            Min = Current + 1;
            ASSERT( Min <= Max );

        //
        //  If our caller doesn't care about the Lcn then return this entry to
        //  him.
        //

        } else if (!ARGUMENT_PRESENT( Lcn )) {

            //
            //  The caller doesn't care about the Lcn, or the Lcn falls in
            //  the current run.
            //

            Min = Current;
            FoundRun = TRUE;
            break;

        //
        //  If the Lcn is less than the Lcn in the entry then move Max down.
        //

        } else if (*Lcn < ThisEntry->Lcn) {

            Max = Current;

            if (Current != MinMatch) {

                MaxMatch = Current;
            }
            ASSERT( Min <= Max );
            ASSERT( MinMatch != MaxMatch );

        //
        //  If the entry overlaps then we have a match.  We already
        //  know our Lcn is >= to the start Lcn of the range from
        //  the test above.
        //

        } else if (*Lcn < (ThisEntry->Lcn + ThisEntry->RunLength)) {

            Min = Current;
            FoundRun = TRUE;
            break;

        //
        //  Advance Min past the current point.
        //

        } else {

            Min = Current + 1;
            MinMatch = Current;
            ASSERT( Min <= Max );
            ASSERT( MinMatch != MaxMatch );
        }
    }

    //
    //  If we don't have an exact match then we want to find the nearest point.  We kept track
    //  of the nearest length matches as we went along.
    //

    if (!FoundRun) {

        //
        //  We have a length match if either match entry was updated.  Check for the nearest
        //  distance if they don't match.
        //

        ASSERT( (MinMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                (MinMatch != MaxMatch) );

        if (MinMatch != MaxMatch) {

            FoundRun = TRUE;

            //
            //  Make sure our search found one of these.
            //

            ASSERT( (MinMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MinMatch <= Min) );
            ASSERT( (MinMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MinMatch == Min) ||
                    (MinMatch == Min - 1) ||
                    (CachedRuns->LengthArray[ Min - 1 ] == NTFS_CACHED_RUNS_DEL_INDEX) );

            ASSERT( (MaxMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MaxMatch >= Min) );
            ASSERT( (MaxMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MaxMatch == Min) ||
                    (MaxMatch == Min + 1) ||
                    (CachedRuns->LengthArray[ Min + 1 ] == NTFS_CACHED_RUNS_DEL_INDEX) );

            //
            //  If the user specified an Lcn then we need to check for the nearest entry.
            //

            if (ARGUMENT_PRESENT( Lcn )) {

                Min = MinMatch;

                if (MaxMatch != NTFS_CACHED_RUNS_DEL_INDEX) {

                    ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ MaxMatch ];

                    Distance = ThisEntry->Lcn - *Lcn;
                    Min = MaxMatch;

                    if (MinMatch != NTFS_CACHED_RUNS_DEL_INDEX) {

                        ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ MinMatch ];

                        if (*Lcn - (ThisEntry->Lcn + RunLength) < Distance) {

                            Min = MinMatch;
                        }
                    }
                }
            }
        }
    }

    *RunIndex = Min;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (FoundRun) {

        LcnIndex = CachedRuns->LengthArray[ Min ];
        ASSERT( LcnIndex != NTFS_CACHED_RUNS_DEL_INDEX );

        ThisEntry = CachedRuns->LcnArray + LcnIndex;
        ASSERT( RunLength == ThisEntry->RunLength );
    }
#endif

    DebugTrace( 0, Dbg, ("*RunIndex = %04x\n", *RunIndex) );
    DebugTrace( -1, Dbg, ("NtfsPositionCachedLcnByLength -> %01x\n", FoundRun) );

    return FoundRun;
}

#ifdef NTFS_CHECK_CACHED_RUNS

//
//  Local support routine
//

VOID
NtfsVerifyCachedLcnRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    )

/*++

Routine Description:

    This routine is called to verify the state of the cached runs arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure

    FirstIndex - Index that marks the start of the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    LastIndex - The index of the last entry in the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    SkipSortCheck - If TRUE, the list may be out of order at this time and
        we should skip the checks for overlapping ranges or length sorts.

    SkipBinCheck - If TRUE, the BinArray may be out of sync and should not
        be checked.

Return Value:

    None

--*/

{
    USHORT Index;
    USHORT BinArray[ NTFS_CACHED_RUNS_BIN_COUNT ];
    USHORT LcnWindowIndex = 0;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_LCN_CLUSTER_RUN LastEntry = NULL;
    PNTFS_DELETED_RUNS LcnDelWindow = NULL;
    PNTFS_DELETED_RUNS NextWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyCachedLcnRuns\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    ASSERT( CachedRuns->Used <= CachedRuns->Avail );

    //
    //  Initialize the tracking variables.
    //

    RtlZeroMemory( BinArray, NTFS_CACHED_RUNS_BIN_COUNT * sizeof( USHORT ));

    if (CachedRuns->DelLcnCount != 0) {

        LcnDelWindow = CachedRuns->DeletedLcnWindows;
    }

    ASSERT( CachedRuns->DelLcnCount <= NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    //
    //  Verify that every element in the Lcn-sorted list is correctly
    //  ordered.  If it's RunLength is 0, make certain its index is
    //  recorded in a window of deleted entries.  If its LengthIndex is
    //  not NTFS_CACHED_RUNS_DEL_INDEX, make sure it refers to an entry in
    //  the length-sorted list that refers back to it and is in a window of
    //  deleted entries if and only if RunLength is 0.
    //

    for (Index = 0, ThisEntry = CachedRuns->LcnArray;
         Index < CachedRuns->Avail;
         Index += 1, ThisEntry += 1) {

        //
        //  This entry is not deleted.
        //

        if (ThisEntry->RunLength != 0) {

            //
            //  Better be in the used region with valid indexes.
            //

            ASSERT( Index < CachedRuns->Used );
            ASSERT( ThisEntry->LengthIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            ASSERT( ThisEntry->LengthIndex < CachedRuns->Used );
            ASSERT( ThisEntry->Lcn != UNUSED_LCN );

            //
            //  Verify that the entry is not in the current window of deleted
            //  entries.
            //

            ASSERT( (LcnDelWindow == NULL) ||
                    (LcnDelWindow->StartIndex > Index) );

            //
            //  Verify the sort order.
            //

            ASSERT( (LastEntry == NULL) ||
                    SkipSortCheck ||
                    (ThisEntry->Lcn > (LastEntry->Lcn + LastEntry->RunLength)) );

            LastEntry = ThisEntry;

            //
            //  Make certain that the corresponding entry in the Length-sorted
            //  list points back to this entry.
            //

            ASSERT( CachedRuns->LengthArray[ ThisEntry->LengthIndex ] == Index );

            //
            //  Keep track of how many entries have this length.
            //

            if (ThisEntry->RunLength <= CachedRuns->Bins) {

                BinArray[ ThisEntry->RunLength - 1 ] += 1;
            }

        //
        //  This is a deleted entry.  Make sure it is in the deleted window array.
        //

        } else {

            ASSERT( ThisEntry->LengthIndex == NTFS_CACHED_RUNS_DEL_INDEX );

            //
            //  Verify that the entry is in the current window of deleted
            //  entries unless we have excluded this entry.
            //

            if ((FirstIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                (LastIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                ((FirstIndex > Index) ||
                 (LastIndex < Index))) {

                ASSERT( (LcnDelWindow != NULL) &&
                        (LcnDelWindow->StartIndex <= Index) &&
                        (LcnDelWindow->EndIndex >= Index) );
            }

            //
            //  Advance the window of deleted entries if we are at the end.
            //

            if ((LcnDelWindow != NULL) && (LcnDelWindow->EndIndex == Index)) {

                LcnWindowIndex += 1;
                if (LcnWindowIndex < CachedRuns->DelLcnCount) {

                    LcnDelWindow += 1;

                } else {

                    LcnDelWindow = NULL;
                }
            }
        }
    }

    //
    //  We should have walked past all of the deleted entries.
    //

    //
    //  Make certain that the windows are in order and don't overlap.
    //

    for (LcnWindowIndex = 0, LcnDelWindow = NextWindow = CachedRuns->DeletedLcnWindows;
         LcnWindowIndex < CachedRuns->DelLcnCount;
         LcnWindowIndex += 1, NextWindow += 1) {

        ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
        if (NextWindow != LcnDelWindow) {

            ASSERT( NextWindow->StartIndex > (LcnDelWindow->EndIndex + 1) );
            LcnDelWindow += 1;
        }
    }

    //
    //  Verify that the histogram of RunLengths is correct.
    //

    for (Index = 0;
         Index < NTFS_CACHED_RUNS_BIN_COUNT;
         Index += 1) {

        ASSERT( SkipBinCheck || (BinArray[ Index ] == CachedRuns->BinArray[ Index ]) );
    }

    DebugTrace( -1, Dbg, ("NtfsVerifyCachedLcnRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsVerifyCachedLenRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck
    )

/*++

Routine Description:

    This routine is called to verify the state of the cached runs arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure

    FirstIndex - Index that marks the start of the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    LastIndex - The index of the last entry in the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    SkipSortCheck - If TRUE, the list may be out of order at this time and
        we should skip the checks for overlapping ranges or length sorts.

Return Value:

    None

--*/

{
    USHORT Index;
    USHORT LenWindowIndex = 0;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_LCN_CLUSTER_RUN LastEntry = NULL;
    PNTFS_DELETED_RUNS LenDelWindow = NULL;
    PNTFS_DELETED_RUNS NextWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyCachedLenRuns\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    ASSERT( CachedRuns->Used <= CachedRuns->Avail );

    //
    //  Initialize the tracking variables.
    //

    if (CachedRuns->DelLengthCount != 0) {

        LenDelWindow = CachedRuns->DeletedLengthWindows;
    }

    ASSERT( CachedRuns->DelLengthCount <= NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    //
    //  Verify that every element in the Length-sorted list is correctly
    //  ordered.  If it's index is NTFS_CACHED_RUNS_DEL_INDEX, make certain
    //  its index is recorded in a window of deleted entries.  Otherwise,
    //  make certain that its Index refers to an entry in the lcn-sorted list
    //  that refers back to it.
    //

    for (Index = 0; Index < CachedRuns->Avail; Index += 1) {

        //
        //  Verify any entry not in a deleted window.
        //

        if (CachedRuns->LengthArray[ Index ] != NTFS_CACHED_RUNS_DEL_INDEX) {

            ASSERT( Index < CachedRuns->Used );
            ASSERT( CachedRuns->LengthArray[ Index ] < CachedRuns->Used );
            ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];

            //
            //  Verify that the corresponding Lcn-sorted entry is not deleted.
            //

            ASSERT( ThisEntry->RunLength != 0 );

            //
            //  Verify that the entry is not in the current window of deleted
            //  entries.
            //

            ASSERT( (LenDelWindow == NULL) ||
                    (LenDelWindow->StartIndex > Index) );

            //
            //  Verify the sort order if we have the previous entry.
            //

            ASSERT( (LastEntry == NULL) ||
                    SkipSortCheck ||
                    (LastEntry->RunLength < ThisEntry->RunLength) ||
                    ((LastEntry->RunLength == ThisEntry->RunLength) &&
                     (ThisEntry->Lcn > (LastEntry->Lcn + LastEntry->RunLength))) );

            LastEntry = ThisEntry;

            //
            //  Make certain that the corresponding entry in the Lcn-sorted
            //  list points back to this entry.
            //

            ASSERT( ThisEntry->LengthIndex == Index );

        //
        //  The entry is deleted.
        //

        } else {

            //
            //  Verify that the entry is in the current window of deleted
            //  entries unless we have excluded this entry.
            //

            if ((FirstIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                (LastIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                ((FirstIndex > Index) ||
                 (LastIndex < Index))) {

                //
                //  Verify that the entry is in the current window of deleted
                //  entries.
                //

                ASSERT( (LenDelWindow != NULL) &&
                        (LenDelWindow->StartIndex <= Index) &&
                        (LenDelWindow->EndIndex >= Index) );
            }
        }

        //
        //  Advance the window of deleted entries if we are at the end.
        //

        if ((LenDelWindow != NULL) && (LenDelWindow->EndIndex == Index)) {

            LenWindowIndex += 1;
            if (LenWindowIndex < CachedRuns->DelLengthCount) {

                LenDelWindow += 1;

            } else {

                LenDelWindow = NULL;
            }
        }
    }

    //
    //  We should have walked past all of the deleted entries.
    //

    ASSERT( LenDelWindow == NULL );

    //
    //  Make certain that the windows are in order and don't overlap.
    //

    for (LenWindowIndex = 0, LenDelWindow = NextWindow = CachedRuns->DeletedLengthWindows;
         LenWindowIndex < CachedRuns->DelLengthCount;
         LenWindowIndex += 1, NextWindow += 1) {

        ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
        if (NextWindow != LenDelWindow) {

            ASSERT( NextWindow->StartIndex > (LenDelWindow->EndIndex + 1) );
            LenDelWindow += 1;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsVerifyCachedLenRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsVerifyCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    )

/*++

Routine Description:

    This routine is called to verify the state of the cached runs arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure

    SkipSortCheck - If TRUE, the list may be out of order at this time and
        we should skip the checks for overlapping ranges or length sorts.

    SkipBinCheck - If TRUE, the BinArray may be out of sync and should not
        be checked.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyCachedRuns\n") );

#ifdef NTFS_CHECK_CACHED_RUNS
    ASSERT( (CachedRuns->Vcb == NULL) ||
            NtfsIsExclusiveScb( CachedRuns->Vcb->BitmapScb ));
#endif

    NtfsVerifyCachedLcnRuns ( CachedRuns,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              SkipSortCheck,
                              SkipBinCheck );

    NtfsVerifyCachedLenRuns ( CachedRuns,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              SkipSortCheck );

    DebugTrace( -1, Dbg, ("NtfsVerifyCachedRuns -> VOID\n") );

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\create.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Ntfs called by the
    dispatch driver.

Author:

    Brian Andrew    [BrianAn]       10-Dec-1991

Revision History:

--*/

#include "NtfsProc.h"
#ifdef NTFSDBG
#include "lockorder.h"
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('CFtN')

//
//  Check for stack usage prior to the create call.
//

#ifdef _X86_
#define OVERFLOW_CREATE_THRESHHOLD         (0x1200)
#else
#define OVERFLOW_CREATE_THRESHHOLD         (0x1B00)
#endif // _X86_

#ifdef BRIANDBG
BOOLEAN NtfsCreateAllSparse = FALSE;
BOOLEAN NtfsTraverseAccessCheck = FALSE;

UNICODE_STRING NtfsTestName = {0x0,0x40,L"                               "};

VOID
NtfsTestOpenName (
    IN PFILE_OBJECT FileObject
    );
#endif

//
//  Local macros
//

//
//  VOID
//  NtfsPrepareForIrpCompletion (
//      IN PIRP_CONTEXT IrpContext,
//      IN PIRP Irp,
//      IN PNTFS_COMPLETION_CONTEXT Context
//      )
//

#define NtfsPrepareForIrpCompletion(IC,I,C) {               \
    (C)->IrpContext = (IC);                                 \
    IoCopyCurrentIrpStackLocationToNext( (I) );             \
    IoSetCompletionRoutine( (I),                            \
                            NtfsCreateCompletionRoutine,    \
                            (C),                            \
                            TRUE,                           \
                            TRUE,                           \
                            TRUE );                         \
    IoSetNextIrpStackLocation( (I) );                       \
}

//
//  BOOLEAN
//  NtfsVerifyNameIsDirectory (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsDirectory( IC, AN, ACN )                        \
    ( ( ((ACN)->Length == 0) ||                                         \
        NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsIndexAllocation, TRUE )) && \
      ( ((AN)->Length == 0) ||                                           \
        NtfsAreNamesEqual( IC->Vcb->UpcaseTable, AN, &NtfsFileNameIndex, TRUE )))

//
//  BOOLEAN
//  NtfsVerifyNameIsBitmap (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsBitmap( IC, AN, ACN )                                           \
    ( ( ((ACN)->Length == 0) ||                                                         \
        NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsBitmapString, TRUE )) &&     \
                                                                                        \
      ( ((AN)->Length == 0) ||                                                          \
        NtfsAreNamesEqual( IC->Vcb->UpcaseTable, AN, &NtfsFileNameIndex, TRUE )))

//
//  BOOLEAN
//  NtfsVerifyNameIsAttributeList (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsAttributeList( IC, AN, ACN )                                  \
    ( ((ACN)->Length != 0) &&                                                         \
        NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsAttrListString, TRUE ))

//
//  BOOLEAN
//  NtfsVerifyNameIsReparsePoint (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsReparsePoint( IC, AN, ACN )                                       \
    ( ((ACN)->Length != 0) &&                                                             \
        NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsReparsePointString, TRUE ))

//
//  VOID
//  NtfsRaiseToPost (
//      IN PIRP_CONTEXT IrpContext
//      )
//

#define NtfsRaiseToPost( IC )                                                        \
    SetFlag( (IC)->Flags, IRP_CONTEXT_FLAG_FORCE_POST );                              \
    if ((IC)->Union.OplockCleanup->CompletionContext != NULL) {                       \
        NtfsPrepareForIrpCompletion( (IC),                                            \
                                     (IC)->OriginatingIrp,                            \
                                     (IC)->Union.OplockCleanup->CompletionContext );  \
    }                                                                                 \
    NtfsRaiseStatus( (IC), STATUS_CANT_WAIT, NULL, NULL );

//
//  These are the flags used by the I/O system in deciding whether
//  to apply the share access modes.
//

#define NtfsAccessDataFlags     (   \
    FILE_EXECUTE                    \
    | FILE_READ_DATA                \
    | FILE_WRITE_DATA               \
    | FILE_APPEND_DATA              \
    | DELETE                        \
)

#define NtfsIsStreamNew( IrpInfo )     \
    ( (IrpInfo == FILE_CREATED) ||     \
      (IrpInfo == FILE_SUPERSEDED) ||  \
      (IrpInfo == FILE_OVERWRITTEN) )

//
//  Subset of flags used by IO system to determine whether user has used either
//  BACKUP or RESTORE privilege to get access to file.
//

#define NTFS_REQUIRES_BACKUP    (FILE_READ_DATA | FILE_READ_ATTRIBUTES)
#define NTFS_REQUIRES_RESTORE   (FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | DELETE)

//
//  Local definitions
//

typedef enum _SHARE_MODIFICATION_TYPE {

    CheckShareAccess,
    UpdateShareAccess,
    SetShareAccess,
    RecheckShareAccess

} SHARE_MODIFICATION_TYPE, *PSHARE_MODIFICATION_TYPE;

UNICODE_STRING NtfsVolumeDasd = CONSTANT_UNICODE_STRING ( L"$Volume" );

LUID NtfsSecurityPrivilege = { SE_SECURITY_PRIVILEGE, 0 };

//
//  VOID
//  NtfsBackoutFailedOpens (
//    IN PIRP_CONTEXT IrpContext,
//      IN PFILE_OBJECT FileObject,
//      IN PFCB ThisFcb,
//      IN PSCB ThisScb OPTIONAL,
//      IN PCCB ThisCcb OPTIONAL
//      );
//

#define NtfsBackoutFailedOpens(IC,FO,F,S,C) {           \
    if (((S) != NULL) && ((C) != NULL)) {               \
                                                        \
        NtfsBackoutFailedOpensPriv( IC, FO, F, S, C );  \
    }                                                   \
}                                                       \

//
//  Local support routines.
//

VOID
NtfsUpdateAllInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN PSCB ParentScb,
    IN PLCB Lcb
    );

NTSTATUS
NtfsOpenFcbById (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ParentLcb OPTIONAL,
    IN FILE_REFERENCE FileReference,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrCode,
    IN PCREATE_CONTEXT CreateContext
    );

NTSTATUS
NtfsOpenExistingPrefixFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB Lcb OPTIONAL,
    IN ULONG FullPathNameLength,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrCode,
    IN PCREATE_CONTEXT CreateContext
    );

NTSTATUS
NtfsOpenTargetDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PLCB ParentLcb OPTIONAL,
    IN OUT PUNICODE_STRING FullPathName,
    IN ULONG FinalNameLength,
    IN PCREATE_CONTEXT CreateContext
    );

NTSTATUS
NtfsOpenFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PINDEX_ENTRY IndexEntry,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN PQUICK_INDEX QuickIndex,
    IN PCREATE_CONTEXT CreateContext,
    OUT PLCB *LcbForTeardown
    );

NTSTATUS
NtfsCreateNewFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PFILE_NAME FileNameAttr,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN PINDEX_CONTEXT *IndexContext,
    IN PCREATE_CONTEXT CreateContext,
    OUT PLCB *LcbForTeardown
    );

PLCB
NtfsOpenSubdirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFILE_REFERENCE FileReference,
    IN UNICODE_STRING FileName,
    IN UCHAR FileNameFlags,
    IN PCREATE_CONTEXT CreateContext,
    OUT PLCB *LcbForTeardown
    );

NTSTATUS
NtfsOpenAttributeInExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOpenExistingAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN BOOLEAN DirectoryOpen,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOverwriteAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN BOOLEAN Supersede,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOpenNewAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN BOOLEAN LogIt,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

BOOLEAN
NtfsParseNameForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING String,
    IN OUT PUNICODE_STRING FileObjectString,
    IN OUT PUNICODE_STRING OriginalString,
    IN OUT PUNICODE_STRING NewNameString,
    IN PCREATE_CONTEXT CreateContext,
    OUT PUNICODE_STRING AttrName,
    OUT PATTRIBUTE_TYPE_CODE AttrCode
    );

NTSTATUS
NtfsCheckValidAttributeAccess (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PDUPLICATED_INFORMATION Info OPTIONAL,
    IN OUT PUNICODE_STRING AttrName,
    IN OUT PATTRIBUTE_TYPE_CODE AttrCode,
    IN ULONG CreateFlags,
    OUT PULONG CcbFlags,
    OUT PBOOLEAN IndexedAttribute
    );

NTSTATUS
NtfsOpenAttributeCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PSCB *ThisScb,
    OUT PSHARE_MODIFICATION_TYPE ShareModificationType
    );

VOID
NtfsAddEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB ThisFcb,
    IN PFILE_FULL_EA_INFORMATION EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PIO_STATUS_BLOCK Iosb
    );

VOID
NtfsCreateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB ThisFcb,
    IN OUT PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize,
    IN BOOLEAN LogIt,
    IN BOOLEAN ForceNonresident,
    IN PUSHORT PreviousFlags OPTIONAL
    );

VOID
NtfsRemoveDataAttributes (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset,
    IN ULONG CreateFlags
    );

VOID
NtfsRemoveReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb
    );

VOID
NtfsReplaceAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize
    );

NTSTATUS
NtfsOpenAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN SHARE_MODIFICATION_TYPE ShareModificationType,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

VOID
NtfsBackoutFailedOpensPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PCCB ThisCcb
    );

VOID
NtfsUpdateScbFromMemory (
    IN OUT PSCB Scb,
    IN POLD_SCB_SNAPSHOT ScbSizes
    );

VOID
NtfsOplockPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

NTSTATUS
NtfsCreateCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsCheckExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN BOOLEAN Indexed,
    IN ULONG CcbFlags
    );

NTSTATUS
NtfsBreakBatchOplock (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    OUT PSCB *ThisScb
    );

NTSTATUS
NtfsCompleteLargeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PLCB Lcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN ULONG CreateFlags
    );

NTSTATUS
NtfsEncryptionCreateCallback (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ThisScb,
    IN PCCB ThisCcb,
    IN PFCB ParentFcb,
    IN PCREATE_CONTEXT CreateContext,
    IN BOOLEAN CreateNewFile
    );

VOID
NtfsPostProcessEncryptedCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN ULONG EncryptionFileDirFlags,
    IN ULONG FailedInPostCreateOnly
    );

NTSTATUS
NtfsGetReparsePointValue (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN USHORT RemainingNameLength
    );

BOOLEAN
NtfsCheckValidFileAccess(
    IN PFCB ThisFcb,
    IN PIO_STACK_LOCATION IrpSp
    );


VOID
NtfsWaitForCreateEvent (
    IN PIRP Irp,
    IN PNTFS_COMPLETION_CONTEXT CompletionContextPointer
    );

NTSTATUS
NtfsLookupObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUNICODE_STRING FileName,
    OUT PFILE_REFERENCE FileReference
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAddEa)
#pragma alloc_text(PAGE, NtfsBackoutFailedOpensPriv)
#pragma alloc_text(PAGE, NtfsBreakBatchOplock)
#pragma alloc_text(PAGE, NtfsCheckExistingFile)
#pragma alloc_text(PAGE, NtfsCheckValidAttributeAccess)
#pragma alloc_text(PAGE, NtfsCheckValidFileAccess)
#pragma alloc_text(PAGE, NtfsCommonCreate)
#pragma alloc_text(PAGE, NtfsCommonVolumeOpen)
#pragma alloc_text(PAGE, NtfsCompleteLargeAllocation)
#pragma alloc_text(PAGE, NtfsCreateAttribute)
#pragma alloc_text(PAGE, NtfsCreateCompletionRoutine)
#pragma alloc_text(PAGE, NtfsCreateNewFile)
#pragma alloc_text(PAGE, NtfsEncryptionCreateCallback)
#pragma alloc_text(PAGE, NtfsFsdCreate)
#pragma alloc_text(PAGE, NtfsGetReparsePointValue)
#pragma alloc_text(PAGE, NtfsInitializeFcbAndStdInfo)
#pragma alloc_text(PAGE, NtfsLookupObjectId)
#pragma alloc_text(PAGE, NtfsNetworkOpenCreate)
#pragma alloc_text(PAGE, NtfsOpenAttribute)
#pragma alloc_text(PAGE, NtfsOpenAttributeCheck)
#pragma alloc_text(PAGE, NtfsOpenAttributeInExistingFile)
#pragma alloc_text(PAGE, NtfsOpenExistingAttr)
#pragma alloc_text(PAGE, NtfsOpenExistingPrefixFcb)
#pragma alloc_text(PAGE, NtfsOpenFcbById)
#pragma alloc_text(PAGE, NtfsOpenFile)
#pragma alloc_text(PAGE, NtfsOpenNewAttr)
#pragma alloc_text(PAGE, NtfsOpenSubdirectory)
#pragma alloc_text(PAGE, NtfsOpenTargetDirectory)
#pragma alloc_text(PAGE, NtfsOplockPrePostIrp)
#pragma alloc_text(PAGE, NtfsOverwriteAttr)
#pragma alloc_text(PAGE, NtfsParseNameForCreate)
#pragma alloc_text(PAGE, NtfsPostProcessEncryptedCreate)
#pragma alloc_text(PAGE, NtfsRemoveDataAttributes)
#pragma alloc_text(PAGE, NtfsRemoveReparsePoint)
#pragma alloc_text(PAGE, NtfsReplaceAttribute)
#pragma alloc_text(PAGE, NtfsTryOpenFcb)
#pragma alloc_text(PAGE, NtfsUpdateScbFromMemory)
#pragma alloc_text(PAGE, NtfsUpdateAllInformation)
#pragma alloc_text(PAGE, NtfsWaitForCreateEvent)
#endif


VOID
NtfsWaitForCreateEvent (
    IN PIRP Irp,
    IN PNTFS_COMPLETION_CONTEXT CompletionContextPointer
    )
/*++

Routine Description:

    This routine waits for the signal from the async thread that a piece of create is done
    for example if we posted the create for more stack space or are waiting for efs

Arguments:

    CompletionContextPointer - context containing event to wait for

Return Value:

    NTSTATUS - The status of the wait

--*/

{
    KPROCESSOR_MODE WaitMode = UserMode;
    LOGICAL PrevStackSwapEnable;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Don't let the stack get swapped out in case we post.
    //

    PrevStackSwapEnable = KeSetKernelStackSwapEnable( FALSE );

    FsRtlExitFileSystem();

    //
    //  Retry the wait until it completes successfully.
    //

    while (TRUE) {

        //
        //  Test the wait status to see if someone is trying to rundown the current
        //  thread.
        //

        Status = KeWaitForSingleObject( &CompletionContextPointer->Event,
                                        Executive,
                                        WaitMode,
                                        FALSE,
                                        NULL );

        if (Status == STATUS_SUCCESS) {

            KeClearEvent( &CompletionContextPointer->Event );
            break;
        }

        if (Status != STATUS_KERNEL_APC) {

            //
            //  In the (unlikely) event that the Irp we want to cancel is
            //  waiting for the encryption driver to return from the post
            //  create callout, we'll deadlock in here.  By signalling the
            //  EncryptionPending event, we're certain that any threads
            //  in that state will run, and check whether their irp has been
            //  cancelled.  It's harmless to signal this event, since any
            //  requests still actually waiting for the post create callout
            //  to return will still see the encryption pending bit set
            //  in their FCB and know to retry.
            //

            IoCancelIrp( Irp );
            KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
            WaitMode = KernelMode;
        }
    }

    FsRtlEnterFileSystem();

    //
    //  Restore the previous value for the stack swap.
    //

    if (PrevStackSwapEnable) {

        KeSetKernelStackSwapEnable( TRUE );
    }
}



NTSTATUS
NtfsFsdCreate (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Create.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext;
    LOGICAL CallPostCreate = FALSE;
    BOOLEAN Wait;
    CREATE_CONTEXT CreateContext;
    NTFS_COMPLETION_CONTEXT CompletionContext;
    LOGICAL ExitFileSystem;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (VolumeDeviceObject->DeviceObject.Size == (USHORT)sizeof( DEVICE_OBJECT )) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace( +1, Dbg, ("NtfsFsdCreate\n") );

    if (NtfsData.EncryptionCallBackTable.PreCreate != NULL) {

        ASSERT( NtfsData.EncryptionCallBackTable.PostCreate != NULL );
        Status = NtfsData.EncryptionCallBackTable.PreCreate( (PDEVICE_OBJECT) VolumeDeviceObject,
                                                     Irp,
                                                     IoGetCurrentIrpStackLocation(Irp)->FileObject );

        //
        //  Raise the status if a failure.
        //

        if (Status != STATUS_SUCCESS) {

            NtfsCompleteRequest( NULL, Irp, Status );
            return Status;
        }

        //
        //  We have to pair up our PreCreates with PostCreates, so remember them.
        //

        CallPostCreate = TRUE;

    } else {

        //
        //  If we simply don't have a precreate routine registered, then the precreate
        //  routine can't fail.  Let's always remember to call post create in this case.
        //

        CallPostCreate = TRUE;
    }

    //
    //  Call the common Create routine
    //

    IrpContext = NULL;

    FsRtlEnterFileSystem();
    ExitFileSystem = TRUE;

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        RtlZeroMemory( &CreateContext, sizeof( CREATE_CONTEXT ) );

        try {

            if (IrpContext == NULL) {

                Wait = CanFsdWait( Irp ) || CallPostCreate;

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

                if (Wait) {

                    KeInitializeEvent( &CompletionContext.Event, NotificationEvent, FALSE );
                }

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            //
            //  Setup the completion context for synchronous calls - note we reinit CreateContext
            //  each time through the main loop
            //

            if (Wait) {
                CreateContext.Cleanup.CompletionContext = &CompletionContext;
            }

            //
            //  Lest we complete the IRP without doing the appropriate PostCreate callouts...
            //  We'll complete the irp _unless_ we have an attached encryption driver with
            //  a post create callout registered. An unfortunate side effect here is that we
            //  have (inadvertently) called PreCreate on VolumeOpens as well...
            //

            if (CallPostCreate) {

                SetFlag( IrpContext->State,
                         IRP_CONTEXT_STATE_EFS_CREATE | IRP_CONTEXT_STATE_PERSISTENT );
            }

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_OPEN )) {

                Status = NtfsCommonVolumeOpen( IrpContext, Irp );
                ASSERT( Status != STATUS_PENDING );

            } else {

                //
                //  Make sure there is sufficient stack to perform the create.
                //  If we don't, carefully post this request.
                //

                if (IoGetRemainingStackSize( ) >= OVERFLOW_CREATE_THRESHHOLD) {

                    Status = NtfsCommonCreate( IrpContext, Irp, &CreateContext );

                    if (Status == STATUS_WAIT_FOR_OPLOCK) {

                        NtfsWaitForCreateEvent( Irp, CreateContext.Cleanup.CompletionContext );

                        //
                        //  remove pending flag (set by the oplock package)
                        //  since we retry and finish in this thread
                        //

                        ClearFlag( IoGetCurrentIrpStackLocation( Irp )->Control, SL_PENDING_RETURNED );
                    }


                } else {

                    ASSERT( IrpContext->ExceptionStatus == 0 );

                    //
                    //  Use the next stack location with NtfsCreateCompletionRoutine
                    //  and post this to a worker thread.
                    //

                    if (CreateContext.Cleanup.CompletionContext != NULL) {

                        NtfsPrepareForIrpCompletion( IrpContext, Irp, CreateContext.Cleanup.CompletionContext );
                    }

                    //
                    //  If lock buffer call raises, this'll fall through to ProcessException below.
                    //  Normally, this'll just return PENDING and we wait for the IRP to complete.
                    //
                    //  Set the create context into the union so it can be picked up in
                    //  NtfsFspDispatch. We'll reset this to an oplock cleanup in NtfsCommonCreate
                    //  when its retried
                    //

                    IrpContext->Union.CreateContext = &CreateContext;
                    Status = NtfsPostRequest( IrpContext, Irp );
                }
            }

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            ASSERT( GetExceptionCode() != STATUS_WAIT_FOR_OPLOCK  );

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  exception code
            //

            //
            //  Set the create context into the union in case we post on retry
            //  we'll reset this up to an oplock cleanup in common create
            //

            if (IrpContext) {
                IrpContext->Union.CreateContext = &CreateContext;
            }
            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );

        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL ||
             Status == STATUS_WAIT_FOR_OPLOCK) ;

    //
    //  Check if we need to have control of the Irp. I.e we're synchronous
    //  and we were able to allocate the irpcontext so we made it to at least NtfsCommonCreate
    //

    if (IrpContext && Wait) {

        //
        //  If pending then wait on the event to take control of the Irp again.
        //

        if (Status == STATUS_PENDING) {

            NtfsWaitForCreateEvent( Irp, &CompletionContext );
            Status = Irp->IoStatus.Status;

            if (CallPostCreate) {

                goto PreCreateComplete;
            }

            NtfsCompleteRequest( NULL, Irp, Status );

        } else if (CallPostCreate) {

            NTSTATUS PostCreateStatus;
            ULONG FailedInPostCreateOnly;

PreCreateComplete:

            if (NtfsData.EncryptionCallBackTable.PostCreate != NULL) {

                PIO_STACK_LOCATION IrpSp;

                //
                //  Restore the thread context pointer if associated with this IrpContext.
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

                    NtfsRestoreTopLevelIrp();
                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
                }

                FsRtlExitFileSystem();
                ExitFileSystem = FALSE;

#ifdef NTFSDBG
                ASSERT( IrpContext->OwnershipState == None );
#endif

                IrpSp = IoGetCurrentIrpStackLocation( Irp );
                PostCreateStatus = NtfsData.EncryptionCallBackTable.PostCreate( (PDEVICE_OBJECT) VolumeDeviceObject,
                                                                                Irp,
                                                                                IrpSp->FileObject,
                                                                                Status,
                                                                                &CreateContext.EncryptionContext );

                ASSERT( Status != STATUS_REPARSE || PostCreateStatus == STATUS_REPARSE );

                //
                //  If we got STATUS_ACCESS_DENIED and the user asked for MAXIMUM_ALLOWED then simply
                //  remove the references that allowed read or write access.
                //

                if ((PostCreateStatus == STATUS_ACCESS_DENIED) &&
                    FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->OriginalDesiredAccess, MAXIMUM_ALLOWED ) &&
                    (Irp->IoStatus.Information == FILE_OPENED)) {

                    PSCB Scb = (PSCB) IrpSp->FileObject->FsContext;
                    BOOLEAN CapturedDeleteAccess = IrpSp->FileObject->DeleteAccess;

                    //
                    //  Swallow the error status in this case.
                    //

                    PostCreateStatus = STATUS_SUCCESS;

                    //
                    //  Do all the work to reenter the file system.  We should never raise out of this block of
                    //  code.
                    //

                    FsRtlEnterFileSystem();
                    ExitFileSystem = TRUE;

                    NtfsAcquireResourceExclusive( IrpContext,
                                                  Scb,
                                                  TRUE );

                    IoRemoveShareAccess( IrpSp->FileObject,
                                         &Scb->ShareAccess );

                    //
                    //  Clear out the history in the file object.
                    //

                    IrpSp->FileObject->ReadAccess = FALSE;
                    IrpSp->FileObject->WriteAccess = FALSE;
                    IrpSp->FileObject->DeleteAccess = FALSE;

                    IrpSp->FileObject->SharedRead = FALSE;
                    IrpSp->FileObject->SharedWrite = FALSE;
                    IrpSp->FileObject->SharedDelete = FALSE;

                    ClearFlag( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                               (FILE_READ_DATA |
                                FILE_EXECUTE |
                                FILE_WRITE_DATA |
                                FILE_APPEND_DATA) );

                    //
                    //  If we already granted delete access then reapply.
                    //

                    if (CapturedDeleteAccess) {

                        PostCreateStatus = IoCheckShareAccess( DELETE,
                                                               IrpSp->Parameters.Create.ShareAccess,
                                                               IrpSp->FileObject,
                                                               &Scb->ShareAccess,
                                                               TRUE );
                    }

                    NtfsReleaseResource( IrpContext,
                                         Scb );

                    FsRtlExitFileSystem();
                    ExitFileSystem = FALSE;
                }

            } else {

                PostCreateStatus = STATUS_SUCCESS;
            }

            //
            //  We may have posted the create due to an oplock, in which case the IrpContext
            //  will look like we're in the FSP thread.  Let's clear the bit now since we're
            //  not in the FSP thread now.
            //

            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP );

            //
            //  Do our final cleanup only if we created a new encrypted directory/file or
            //  we got an error from the encryption callback above.
            //

            FailedInPostCreateOnly = NT_SUCCESS( Status ) && !NT_SUCCESS( PostCreateStatus );
            if (FailedInPostCreateOnly ||
                FlagOn( CreateContext.EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

                //
                //  Reenter the filesystem at this point.
                //

                if (!ExitFileSystem) {

                    FsRtlEnterFileSystem();
                    ExitFileSystem = TRUE;
                }

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

                //
                //  There's no fileobject to cleanup if the normal part of this create failed.
                //

                if (NT_SUCCESS( Status ) &&
                    (Status != STATUS_REPARSE)) {

                    NtfsPostProcessEncryptedCreate( IrpContext,
                                                    IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                                    CreateContext.EncryptionFileDirFlags,
                                                    FailedInPostCreateOnly );
                }
            }

            //
            //  If the encryption driver came up with a new reason to fail this irp, return
            //  that status.
            //

            if (FailedInPostCreateOnly) { Status = PostCreateStatus; }

            //
            //  Now we're really done with both the irp context and the irp, so let's
            //  get rid of them.
            //

            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    if (ExitFileSystem) {

        FsRtlExitFileSystem();
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  We should never return STATUS_CANT_WAIT or STATUS_PENDING
    //

    ASSERT( (Status != STATUS_CANT_WAIT) && (Status != STATUS_PENDING ) );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdCreate -> %08lx\n", Status) );
    return Status;
}


BOOLEAN
NtfsNetworkOpenCreate (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine implements the fast open create for path-based queries.

Arguments:

    Irp - Supplies the Irp being processed

    Buffer - Buffer to return the network query information

    DeviceObject - Supplies the volume device object where the file exists

Return Value:

    BOOLEAN - Indicates whether or not the fast path could be taken.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    BOOLEAN Result = TRUE;
    BOOLEAN DasdOpen = FALSE;
    CREATE_CONTEXT CreateContext;

    NTSTATUS Status;
    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //
    //  Call the common Create routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );
    RtlZeroMemory( &CreateContext, sizeof( CreateContext ) );

    try {

        //
        //  Allocate the Irp and update the top level storage.
        //

        NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );
        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        CreateContext.NetworkInfo = Buffer;

        Status = NtfsCommonCreate( IrpContext, Irp, &CreateContext );

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Catch the case where someone in attempting this on a DASD open.
        //

        if ((IrpContext != NULL) && (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_OPEN ))) {

            DasdOpen = TRUE;
        }

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  exception code.  Since there is no Irp the exception package
        //  will always deallocate the IrpContext so we won't do
        //  any retry in this path.
        //

        Status = GetExceptionCode();

        //
        //  Don't pass a retryable error to ProcessException.  We want to
        //  force this request to the Irp path in any case.
        //

        if ((Status == STATUS_CANT_WAIT) || (Status == STATUS_LOG_FILE_FULL)) {

            Status = STATUS_FILE_LOCK_CONFLICT;
            IrpContext->ExceptionStatus = STATUS_FILE_LOCK_CONFLICT;
        }

        Status = NtfsProcessException( IrpContext, NULL, Status );

        //
        //  Always fail the DASD case.
        //

        if (DasdOpen) {

            Status = STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  STATUS_SUCCESS is the typical case.  Test for it first.
    //

    if (Status != STATUS_SUCCESS) {

        //
        //  Return STATUS_FILE_LOCK_CONFLICT for any retryable error.
        //

        ASSERT( (Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL) );

        if ((Status == STATUS_REPARSE) || (Status == STATUS_FILE_LOCK_CONFLICT)) {

            Result = FALSE;
            Status = STATUS_FILE_LOCK_CONFLICT;
        }
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    Irp->IoStatus.Status = Status;
    return Result;
}


NTSTATUS
NtfsCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PCREATE_CONTEXT CreateContext
    )

/*++

Routine Description:

    This is the common routine for Create called by both the fsd and fsp
    threads.  If this open has already been detected to be a volume open then
    take we will take the volume open path instead.

Arguments:

    Irp - Supplies the Irp to process

    CompletionContext - Event used to serialize waiting for the oplock break.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT RelatedFileObject;

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AcquireFlags = 0;

    UNICODE_STRING AttrName;

    ATTRIBUTE_TYPE_CODE AttrCode = $UNUSED;

    PVCB Vcb;

    //
    //  The following are used to teardown any Lcb/Fcb this
    //  routine is responsible for.
    //

    PLCB LcbForTeardown = NULL;

    //
    //  The following indicate how far down the tree we have scanned.
    //

    PFCB ParentFcb;
    PLCB CurrentLcb;
    PSCB LastScb = NULL;
    PSCB CurrentScb;
    PLCB NextLcb;

    //
    //  The following are the in-memory structures associated with
    //  the relative file object.
    //

    TYPE_OF_OPEN RelatedFileObjectTypeOfOpen;
    PFCB RelatedFcb;
    PSCB RelatedScb;
    PCCB RelatedCcb;

    UCHAR CreateDisposition;
    UCHAR FileNameFlags;
    USHORT FileNameAttrLength = 0;

    PFILE_NAME FileNameAttr = NULL;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    QUICK_INDEX QuickIndex;

    FILE_REFERENCE FileReference;

#if defined(_WIN64)
    INDEX_CONTEXT IndexContextStruct;
#endif
    PINDEX_CONTEXT IndexContext = NULL;

    //
    //  The following unicode strings are used to track the names
    //  during the open operation.  They may point to the same
    //  buffer so careful checks must be done at cleanup.
    //
    //  OriginalFileName - This is the value to restore to the file
    //      object on error cleanup.  This will containg the
    //      attribute type codes and attribute names if present.
    //
    //  FullFileName - This is the constructed string which contains
    //      only the name components.  It may point to the same
    //      buffer as the original name but the length value is
    //      adjusted to cut off the attribute code and name.
    //
    //  ExactCaseName - This is the version of the full filename
    //      exactly as given by the caller.  Used to preserve the
    //      case given by the caller in the event we do a case
    //      insensitive lookup.  If the user is doing a relative open
    //      then we don't need to allocate a new buffer.  We can use
    //      the original name from above.
    //
    //  ExactCaseOffset - This is the offset in the FullFileName where
    //      the relative component begins.  This is where we position ourselves
    //      when restoring the correct case for this name.
    //
    //  RemainingName - This is the portion of the full name still
    //      to parse.
    //
    //  FinalName - This is the current component of the full name.
    //
    //  CaseInsensitiveIndex - This is the offset in the full file
    //      where we performed upcasing.  We need to restore the
    //      exact case on failures and if we are creating a file.
    //

    PUNICODE_STRING OriginalFileName = &CreateContext->Cleanup.OriginalFileName;
    PUNICODE_STRING FullFileName = &CreateContext->Cleanup.FullFileName;
    PUNICODE_STRING ExactCaseName = &CreateContext->Cleanup.ExactCaseName;
    USHORT ExactCaseOffset = 0;

    UNICODE_STRING RemainingName;
    UNICODE_STRING FinalName;
    ULONG CaseInsensitiveIndex = 0;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Innitialize all the remaining fields in the OPLOCK_CLEANUP structure.
    //

    CreateContext->Cleanup.FileObject = IrpSp->FileObject;

    CreateContext->Cleanup.RemainingDesiredAccess = IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess;
    CreateContext->Cleanup.PreviouslyGrantedAccess = IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess;
    CreateContext->Cleanup.DesiredAccess = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    CreateContext->Cleanup.AttributeNameLength = 0;
    CreateContext->Cleanup.AttributeCodeNameLength = 0;

#ifdef BRIANDBG
    if (NtfsTestName.Length != 0) {

        NtfsTestOpenName( IrpSp->FileObject );
    }
#endif

    //
    //  Initialize the attribute strings.
    //

    AttrName.Length = 0;

    DebugTrace( +1, Dbg, ("NtfsCommonCreate:  Entered\n") );
    DebugTrace( 0, Dbg, ("IrpContext                = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                       = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("->Flags                   = %08lx\n", Irp->Flags) );
    DebugTrace( 0, Dbg, ("->FileObject              = %08lx\n", IrpSp->FileObject) );
    DebugTrace( 0, Dbg, ("->RelatedFileObject       = %08lx\n", IrpSp->FileObject->RelatedFileObject) );
    DebugTrace( 0, Dbg, ("->FileName                = %Z\n",    &IrpSp->FileObject->FileName) );
    DebugTrace( 0, Dbg, ("->AllocationSize          = %08lx %08lx\n", Irp->Overlay.AllocationSize.LowPart,
                                                                     Irp->Overlay.AllocationSize.HighPart ) );
    DebugTrace( 0, Dbg, ("->EaBuffer                = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, ("->EaLength                = %08lx\n", IrpSp->Parameters.Create.EaLength) );
    DebugTrace( 0, Dbg, ("->DesiredAccess           = %08lx\n", IrpSp->Parameters.Create.SecurityContext->DesiredAccess) );
    DebugTrace( 0, Dbg, ("->Options                 = %08lx\n", IrpSp->Parameters.Create.Options) );
    DebugTrace( 0, Dbg, ("->FileAttributes          = %04x\n",  IrpSp->Parameters.Create.FileAttributes) );
    DebugTrace( 0, Dbg, ("->ShareAccess             = %04x\n",  IrpSp->Parameters.Create.ShareAccess) );
    DebugTrace( 0, Dbg, ("->Directory               = %04x\n",  FlagOn( IrpSp->Parameters.Create.Options,
                                                                       FILE_DIRECTORY_FILE )) );
    DebugTrace( 0, Dbg, ("->NonDirectoryFile        = %04x\n",  FlagOn( IrpSp->Parameters.Create.Options,
                                                                       FILE_NON_DIRECTORY_FILE )) );
    DebugTrace( 0, Dbg, ("->NoIntermediateBuffering = %04x\n",  FlagOn( IrpSp->Parameters.Create.Options,
                                                                       FILE_NO_INTERMEDIATE_BUFFERING )) );
    DebugTrace( 0, Dbg, ("->CreateDisposition       = %04x\n",  (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff) );
    DebugTrace( 0, Dbg, ("->IsPagingFile            = %04x\n",  FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) );
    DebugTrace( 0, Dbg, ("->OpenTargetDirectory     = %04x\n",  FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) );
    DebugTrace( 0, Dbg, ("->CaseSensitive           = %04x\n",  FlagOn( IrpSp->Flags, SL_CASE_SENSITIVE )) );
    DebugTrace( 0, Dbg, ("->NetworkInfo             = %08x\n",  CreateContext->NetworkInfo) );

    DebugTrace( 0, Dbg, ("->EntryRemainingDesiredAccess  = %08lx\n", CreateContext->Cleanup.RemainingDesiredAccess) );
    DebugTrace( 0, Dbg, ("->EntryPreviouslyGrantedAccess = %08lx\n", CreateContext->Cleanup.PreviouslyGrantedAccess) );

    //
    //  For NT5, the fact that the user has requested that the file be created
    //  encrypted means it will not be created compressed, regardless of the
    //  compression state of the parent directory.
    //

    if (FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

        SetFlag( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION );
    }

    //
    //  Verify that we can wait and acquire the Vcb exclusively.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        DebugTrace( 0, Dbg, ("Can't wait in create\n") );

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsCommonCreate:  Exit -> %08lx\n", Status) );
        return Status;
    }

    //
    //  If we're retrying this create because we're waiting for the key blob
    //  from the encryption driver, we want to wait for our notification
    //  event so we don't hog the cpu(s) and prevent the encryption driver
    //  from having a chance to give us the key blob.
    //

    if FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ENCRYPTION_RETRY ) {

        KeWaitForSingleObject( &NtfsEncryptionPendingEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ENCRYPTION_RETRY );
    }

    //
    //  While we were waiting for the encryption driver's post create callout
    //  to return OR at the top for an oplock break, the create may have been cancelled, 
    //  most likely because the user's  process is terminating.  In that case, 
    //  let's complete and exit now. 
    //

    if (Irp->Cancel) {

        Status = STATUS_CANCELLED;
        DebugTrace( -1, Dbg, ("NtfsCommonCreate:  Exit -> %08lx\n", Status) );

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE ) ||
            (CreateContext->NetworkInfo != NULL)) {

            NtfsCompleteRequest( IrpContext,
                                 NULL,
                                 Status );

        } else {

            NtfsCompleteRequest( IrpContext,
                                 Irp,
                                 Status );
        }

        return Status;
    }

    //
    //  Update the IrpContext with the oplock cleanup structure.
    //

    IrpContext->Union.OplockCleanup = &CreateContext->Cleanup;

    //
    //  Locate the volume device object and Vcb that we are trying to access.
    //

    Vcb = &((PVOLUME_DEVICE_OBJECT)IrpSp->DeviceObject)->Vcb;

    //
    //  We will need to acquire the vcb exclusive for paging file opens
    //  in order to do the fspclose that flushes out that vcb
    //  

    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) {

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Let's do some work here if the close lists have exceeded
        //  some threshold.  Cast 1 to a pointer to indicate who is calling
        //  FspClose.
        //

        if ((NtfsData.AsyncCloseCount + NtfsData.DelayedCloseCount) > NtfsThrottleCreates) {

            NtfsFspClose( (PVCB) 1 );
        }

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

        } else {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
        }

        SetFlag( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_VCB );

        //
        //  Set up local pointers to the file name.
        //

        *FullFileName = *OriginalFileName = CreateContext->Cleanup.FileObject->FileName;

        //
        //  Make sure that Darryl didn't send us a garbage name
        //

        ASSERT( CreateContext->Cleanup.FileObject->FileName.Length != 0 ||
                CreateContext->Cleanup.FileObject->FileName.Buffer == 0 );

        ExactCaseName->Buffer = NULL;

        //
        //  Check a few parameters before we proceed.
        //

        if ((FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE | FILE_NON_DIRECTORY_FILE ) ==
            (FILE_DIRECTORY_FILE | FILE_NON_DIRECTORY_FILE)) ||

            (Irp->Overlay.AllocationSize.QuadPart > MAXFILESIZE)) {

            Status = STATUS_INVALID_PARAMETER;
            try_return( Status );
        }

        //
        //  If the Vcb is locked then we cannot open another file.  If we have performed
        //  a dismount then make sure we have the Vcb acquired exclusive so we can
        //  check if we should dismount this volume.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_PERFORMED_DISMOUNT )) {

            DebugTrace( 0, Dbg, ("Volume is locked\n") );

            if (FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT ) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                NtfsReleaseVcb( IrpContext, Vcb );

                ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_VCB );
                
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_VCB );
            }

            //
            //  Either deny access or show the volume was dismounted.  Only show the dismount
            //  if the user is opening through a relative handle.
            //

            Status = STATUS_ACCESS_DENIED;
            if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_DISMOUNT ) &&
                (CreateContext->Cleanup.FileObject->RelatedFileObject != NULL)) {

                Status = STATUS_VOLUME_DISMOUNTED;
            }
            try_return( NOTHING );
        }

        //
        //  Initialize local copies of the stack values.
        //

        RelatedFileObject = CreateContext->Cleanup.FileObject->RelatedFileObject;

        if (!FlagOn( IrpSp->Flags, SL_CASE_SENSITIVE )) {
            SetFlag( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE );
        }

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID)) {
            SetFlag( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID );
        }

        CreateDisposition = (UCHAR) ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);

        //
        //  We don't want any file modifications to go through if the volume is readonly.
        //  However, we don't want to fail any _opens_ for writes either, because that
        //  could potentially break many apps. So ignore the PreviouslyGrantedAccess,
        //  and just look at the CreateDisposition.
        //

        if (NtfsIsVolumeReadOnly( Vcb )) {

            if ((CreateDisposition == FILE_CREATE) ||
                (CreateDisposition == FILE_SUPERSEDE) ||
                (CreateDisposition == FILE_OVERWRITE) ||
                (CreateDisposition == FILE_OVERWRITE_IF)) {

                Status = STATUS_MEDIA_WRITE_PROTECTED;
                try_return( Status );
            }
        }

        //
        //  Acquire the paging io resource if we are superseding/overwriting a
        //  file or if we are opening for non-cached access.
        //

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF) ||
            FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
        }

        //
        //  We don't allow an open for an existing paging file.  To insure that the
        //  delayed close Scb is not for this paging file we will unconditionally
        //  dereference it if this is a paging file open.
        //

        if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
            (!IsListEmpty( &NtfsData.AsyncCloseList ) ||
             !IsListEmpty( &NtfsData.DelayedCloseList ))) {

            NtfsFspClose( Vcb );
        }

        //
        //  Set up the file object's Vpb pointer in case anything happens.
        //  This will allow us to get a reasonable pop-up.
        //  Also set the flag to acquire the paging io resource if we might
        //  be creating a stream relative to a file.  We need to make
        //  sure to acquire the paging IO when we get the file.
        //

        if (RelatedFileObject != NULL) {

            CreateContext->Cleanup.FileObject->Vpb = RelatedFileObject->Vpb;

            if ((OriginalFileName->Length != 0) &&
                (OriginalFileName->Buffer[0] == L':') &&
                ((CreateDisposition == FILE_OPEN_IF) ||
                 (CreateDisposition == FILE_CREATE))) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }
        }

        //
        //  Ping the volume to make sure the Vcb is still mounted.  If we need
        //  to verify the volume then do it now, and if it comes out okay
        //  then clear the verify volume flag in the device object and continue
        //  on.  If it doesn't verify okay then dismount the volume and
        //  either tell the I/O system to try and create again (with a new mount)
        //  or that the volume is wrong. This later code is returned if we
        //  are trying to do a relative open and the vcb is no longer mounted.
        //

        if (!NtfsPingVolume( IrpContext, Vcb, NULL ) ||
            !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                //
                //  We need checkpoint sync to do a dismount which must 
                //  be acquired before the vcb - after dropping the vcb
                //  we must retest the volume
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_VCB );

                NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );

                try {

                    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                    SetFlag( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_VCB );

                    if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {
    
                        NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );

                        if (RelatedFileObject == NULL) {
    
                            Irp->IoStatus.Information = IO_REMOUNT;
                            NtfsRaiseStatus( IrpContext, STATUS_REPARSE, NULL, NULL );
    
                        } else {
    
                            NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
                        }
        
                        //
                        //  After releasing the vcb to do the verify - if the verify passes the voume
                        //  should be still mounted
                        //  
        
                        ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) );
                    }

                } finally {
                    NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
                }
            }

            //
            //  The volume verified correctly so now clear the verify bit
            //  and continue with the create
            //

            ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );
        }

        //
        //  Let's handle the open by Id case immediately.
        //

        if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

            FILE_REFERENCE FileReference;

            if (OriginalFileName->Length == sizeof( FILE_REFERENCE ) ||
                (OriginalFileName->Length == sizeof( FILE_REFERENCE ) + sizeof( WCHAR ))) {

                //
                //  This is the regular open by file id case.
                //  Perform a safe copy of the data to our local variable.
                //  accept slash prefixed filerefs
                //

                if (OriginalFileName->Length == sizeof( FILE_REFERENCE )) {
                    RtlCopyMemory( &FileReference,
                                   CreateContext->Cleanup.FileObject->FileName.Buffer,
                                   sizeof( FILE_REFERENCE ));
                } else {
                    RtlCopyMemory( &FileReference,
                                   CreateContext->Cleanup.FileObject->FileName.Buffer + 1,
                                   sizeof( FILE_REFERENCE ));
                }

            //
            //  If it's 16 bytes long, it should be an object id.  It may
            //  also be one WCHAR longer for the Win32 double backslash.
            //  This code only works for 5.0 volumes with object id indices.
            //

            } else if (((OriginalFileName->Length == OBJECT_ID_KEY_LENGTH) ||
                        (OriginalFileName->Length == OBJECT_ID_KEY_LENGTH + sizeof( WCHAR ))) &&

                       (Vcb->ObjectIdTableScb != NULL)) {

                //
                //  In the open by object id case, we need to do some
                //  more work to find the file reference.
                //

                Status = NtfsLookupObjectId( IrpContext, Vcb, OriginalFileName, &FileReference );
                if (!NT_SUCCESS( Status )) {

                    try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
                }

            } else {

                Status = STATUS_INVALID_PARAMETER;

                try_return( Status );
            }

            //
            //  Clear the name in the file object.
            //

            CreateContext->Cleanup.FileObject->FileName.Buffer = NULL;
            CreateContext->Cleanup.FileObject->FileName.Length = 0;

            ASSERT( CreateContext->CurrentFcb == NULL );

            Status = NtfsOpenFcbById( IrpContext,
                                      Irp,
                                      IrpSp,
                                      Vcb,
                                      NULL,
                                      FileReference,
                                      NtfsEmptyString,
                                      $UNUSED,
                                      CreateContext );

            if ((Status != STATUS_PENDING) && (Status != STATUS_WAIT_FOR_OPLOCK)) {

                //
                //  Remember if we can let the user see the name for this file opened by id.
                //

                if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags,
                                                      TOKEN_HAS_TRAVERSE_PRIVILEGE )) {

                    SetFlag( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );
                } else {
                    ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );
                }

                //
                //  Put the name back into the file object so that the IO system doesn't
                //  think this is a dasd handle.  Leave the max length at zero so
                //  we know this is not a real name.
                //

                CreateContext->Cleanup.FileObject->FileName.Buffer = OriginalFileName->Buffer;
                CreateContext->Cleanup.FileObject->FileName.Length = OriginalFileName->Length;
            }

            try_return( Status );
        }

        //
        //  Test for double beginning backslashes from the Win32 layer. Apparently
        //  they can't test for this.
        //

        if ((CreateContext->Cleanup.FileObject->FileName.Length > sizeof( WCHAR )) &&
            (CreateContext->Cleanup.FileObject->FileName.Buffer[1] == L'\\') &&
            (CreateContext->Cleanup.FileObject->FileName.Buffer[0] == L'\\')) {

            CreateContext->Cleanup.FileObject->FileName.Length -= sizeof( WCHAR );

            RtlMoveMemory( &CreateContext->Cleanup.FileObject->FileName.Buffer[0],
                           &CreateContext->Cleanup.FileObject->FileName.Buffer[1],
                           CreateContext->Cleanup.FileObject->FileName.Length );

            *FullFileName = *OriginalFileName = CreateContext->Cleanup.FileObject->FileName;

            //
            //  If there are still two beginning backslashes, the name is bogus.
            //

            if ((CreateContext->Cleanup.FileObject->FileName.Length > sizeof( WCHAR )) &&
                (CreateContext->Cleanup.FileObject->FileName.Buffer[1] == L'\\')) {

                Status = STATUS_OBJECT_NAME_INVALID;
                try_return( Status );
            }
        }

        //
        //  Remember if we need to perform any traverse access checks.
        //

        if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags,
                     TOKEN_HAS_TRAVERSE_PRIVILEGE )) {

            DebugTrace( 0, Dbg, ("Performing traverse access on this open\n") );

            SetFlag( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );

        } else {

            ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );

#ifdef BRIANDBG
            if (NtfsTraverseAccessCheck) {

                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );
            }
#endif
        }


        //
        //  If there is a related file object, we decode it to verify that this
        //  is a valid relative open.
        //

        if (RelatedFileObject != NULL) {

            PVCB DecodeVcb;

            //
            //  Check for a valid name.  The name can't begin with a backslash
            //  and can't end with two backslashes.
            //

            if (OriginalFileName->Length != 0) {

                //
                //  Check for a leading backslash.
                //

                if (OriginalFileName->Buffer[0] == L'\\') {

                    DebugTrace( 0, Dbg, ("Invalid name for relative open\n") );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Trim off any trailing backslash.
                //

                if (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\') {

                    SetFlag( CreateContext->CreateFlags, CREATE_FLAG_TRAILING_BACKSLASH );
                    CreateContext->Cleanup.FileObject->FileName.Length -= sizeof( WCHAR );
                    *OriginalFileName = *FullFileName = CreateContext->Cleanup.FileObject->FileName;
                }

                //
                //  Now check if there is a trailing backslash.  Note that if
                //  there was already a trailing backslash then there must
                //  be at least one more character or we would have failed
                //  with the original test.
                //

                if (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\') {

                    Status = STATUS_OBJECT_NAME_INVALID;
                    try_return( Status );
                }
            }

            RelatedFileObjectTypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                                                RelatedFileObject,
                                                                &DecodeVcb,
                                                                &RelatedFcb,
                                                                &RelatedScb,
                                                                &RelatedCcb,
                                                                TRUE );

            //
            //  Make sure the file object is one that we have seen
            //

            if (RelatedFileObjectTypeOfOpen == UnopenedFileObject) {

                DebugTrace( 0, Dbg, ("Can't use unopend file for relative open\n") );
                try_return( Status = STATUS_INVALID_PARAMETER );
            }

            //
            //  If the related file object was not opened as a file then we need to
            //  get the name and code if our caller passed a name length of zero.
            //  We need to fail this otherwise.
            //

            if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                //
                //  If the name length is zero then we want the attribute name and
                //  type code from the related file object.
                //

                if (OriginalFileName->Length == 0) {

                    AttrName = RelatedScb->AttributeName;
                    AttrCode = RelatedScb->AttributeTypeCode;
                //
                //  The relative file has to have been opened as a file.  We
                //  cannot do relative opens relative to an opened attribute.
                //

                } else {

                    DebugTrace( 0, Dbg, ("Invalid File object for relative open\n") );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }
            }

            //
            //  USN_V2  Remember the source info flags for this Ccb.
            //

            IrpContext->SourceInfo = RelatedCcb->UsnSourceInfo;

            //
            //  If the related Ccb is was opened by file Id, we will
            //  remember that for future use.
            //

            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID );
            }

            //
            //  Remember if the related Ccb was opened through a Dos-Only
            //  component.
            //

            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT )) {

                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
            }

        } else {

            RelatedFileObjectTypeOfOpen = UnopenedFileObject;

            if ((OriginalFileName->Length > 2) &&
                (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\')) {

                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_TRAILING_BACKSLASH );
                CreateContext->Cleanup.FileObject->FileName.Length -= sizeof( WCHAR );
                *OriginalFileName = *FullFileName = CreateContext->Cleanup.FileObject->FileName;

                //
                //  If there is still a trailing backslash on the name then
                //  the name is invalid.
                //

                if ((OriginalFileName->Length > 2) &&
                    (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\')) {

                    Status = STATUS_OBJECT_NAME_INVALID;
                    try_return( Status );
                }
            }
        }

        DebugTrace( 0, Dbg, ("Related File Object, TypeOfOpen -> %08lx\n", RelatedFileObjectTypeOfOpen) );

        //
        //  We check if this is a user volume open in that there is no name
        //  specified and the related file object is valid if present.  In that
        //  case set the correct flags in the IrpContext and raise so we can take
        //  the volume open path.
        //

        if ((OriginalFileName->Length == 0) &&
            ((RelatedFileObjectTypeOfOpen == UnopenedFileObject) ||
             (RelatedFileObjectTypeOfOpen == UserVolumeOpen))) {

            DebugTrace( 0, Dbg, ("Attempting to open entire volume\n") );

            SetFlag( IrpContext->State,
                     IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If the related file object was a volume open, then this open is
        //  illegal.
        //

        if (RelatedFileObjectTypeOfOpen == UserVolumeOpen) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  We enter the loop that does the processing for the prefix lookup.
        //  We optimize the case where we can match a prefix hit.  If there is
        //  no hit we will check if the name is legal or might possibly require
        //  parsing to handle the case where there is a named data stream.
        //

        SetFlag( CreateContext->CreateFlags, CREATE_FLAG_FIRST_PASS );

        while (TRUE) {

            PUNICODE_STRING FileObjectName;
            LONG Index;
            BOOLEAN ComplexName;

            //
            //  Lets make sure we have acquired the starting point for our
            //  name search.  If we have a relative file object then use
            //  that.  Otherwise we will start from the root.
            //

            if (RelatedFileObject != NULL) {

                CreateContext->CurrentFcb = RelatedFcb;

            } else {

                CreateContext->CurrentFcb = Vcb->RootIndexScb->Fcb;
            }

            //
            //  Init NextLcb
            //

            FileObjectName = &CreateContext->Cleanup.FileObject->FileName;
            NextLcb = NULL;

            //
            //  We would like to get the starting point shared, unless
            //  we know for certain we need it exclusively.
            //

            if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK | CREATE_FLAG_OPEN_BY_ID ) ||
                !FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE) ||
                (FileObjectName->Length == 0) ||
                (FileObjectName->Buffer[0] == L':') ||
                ((RelatedFileObject == NULL) &&
                 ((FileObjectName->Length <= sizeof( WCHAR )) ||
                  (FileObjectName->Buffer[1] == L':'))) ||
                ((RelatedFileObject != NULL) &&
                 (RelatedFileObjectTypeOfOpen != UserDirectoryOpen))) {

                NtfsAcquireFcbWithPaging( IrpContext, CreateContext->CurrentFcb, 0);
                ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );

            } else {

                NtfsAcquireSharedFcb( IrpContext, CreateContext->CurrentFcb, NULL, FALSE );
                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
            }

            if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_FIRST_PASS )) {

                if (!NtfsParseNameForCreate( IrpContext,
                                             RemainingName,
                                             FileObjectName,
                                             OriginalFileName,
                                             FullFileName,
                                             CreateContext,
                                             &AttrName,
                                             &AttrCode )) {

                    try_return( Status = STATUS_OBJECT_NAME_INVALID );
                }

                //
                //  If we might be creating a named stream acquire the
                //  paging IO as well.  This will keep anyone from peeking
                //  at the allocation size of any other streams we are converting
                //  to non-resident.
                //

                if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) &&
                    (AttrName.Length != 0) &&
                    ((CreateDisposition == FILE_OPEN_IF) ||
                     (CreateDisposition == FILE_CREATE))) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
                }

            //
            //  Build up the full name if this is not the open by file Id case.
            //

            } else if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                //
                //  If we have a related file object, then we build up the
                //  combined name.
                //

                if (RelatedFileObject != NULL) {

                    WCHAR *CurrentPosition;
                    USHORT AddSeparator;
                    ULONG FullNameLengthTemp;

                    if ((FileObjectName->Length == 0) ||
                        (RelatedCcb->FullFileName.Length == 2) ||
                        (FileObjectName->Buffer[0] == L':')) {

                        AddSeparator = 0;

                    } else {

                        AddSeparator = sizeof( WCHAR );
                    }

                    ExactCaseOffset = RelatedCcb->FullFileName.Length + AddSeparator;

                    FullNameLengthTemp = (ULONG) RelatedCcb->FullFileName.Length + AddSeparator + FileObjectName->Length;

                    //
                    // A crude test to see if the total length exceeds a ushort.
                    //

                    if ((FullNameLengthTemp & 0xffff0000L) != 0) {

                        try_return( Status = STATUS_OBJECT_NAME_INVALID );
                    }

                    FullFileName->MaximumLength =
                    FullFileName->Length = (USHORT) FullNameLengthTemp;

                    //
                    //  We need to allocate a name buffer.
                    //

                    FullFileName->Buffer = FsRtlAllocatePoolWithTag(PagedPool, FullFileName->Length, MODULE_POOL_TAG);

                    CurrentPosition = (WCHAR *) FullFileName->Buffer;

                    RtlCopyMemory( CurrentPosition,
                                   RelatedCcb->FullFileName.Buffer,
                                   RelatedCcb->FullFileName.Length );

                    CurrentPosition = (WCHAR *) Add2Ptr( CurrentPosition, RelatedCcb->FullFileName.Length );

                    if (AddSeparator != 0) {

                        *CurrentPosition = L'\\';

                        CurrentPosition += 1;
                    }

                    if (FileObjectName->Length != 0) {

                        RtlCopyMemory( CurrentPosition,
                                       FileObjectName->Buffer,
                                       FileObjectName->Length );
                    }

                    //
                    //  If the user specified a case sensitive comparison, then the
                    //  case insensitive index is the full length of the resulting
                    //  string.  Otherwise it is the length of the string in
                    //  the related file object.  We adjust for the case when the
                    //  original file name length is zero.
                    //

                    if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                        CaseInsensitiveIndex = FullFileName->Length;

                    } else {

                        CaseInsensitiveIndex = RelatedCcb->FullFileName.Length +
                                               AddSeparator;
                    }

                //
                //  The entire name is in the FileObjectName.  We check the buffer for
                //  validity.
                //

                } else {

                    //
                    //  We look at the name string for detectable errors.  The
                    //  length must be non-zero and the first character must be
                    //  '\'
                    //

                    if (FileObjectName->Length == 0) {

                        DebugTrace( 0, Dbg, ("There is no name to open\n") );
                        try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                    }

                    if (FileObjectName->Buffer[0] != L'\\') {

                        DebugTrace( 0, Dbg, ("Name does not begin with a backslash\n") );
                        try_return( Status = STATUS_INVALID_PARAMETER );
                    }

                    //
                    //  If the user specified a case sensitive comparison, then the
                    //  case insensitive index is the full length of the resulting
                    //  string.  Otherwise it is zero.
                    //

                    if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                        CaseInsensitiveIndex = FullFileName->Length;

                    } else {

                        CaseInsensitiveIndex = 0;
                    }
                }

            } else if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                CaseInsensitiveIndex = 0;

            } else {

                CaseInsensitiveIndex = FullFileName->Length;
            }

            //
            //  The remaining name is stored in the FullFileName variable.
            //  If we are doing a case-insensitive operation and have to
            //  upcase part of the remaining name then allocate a buffer
            //  now.  No need to allocate a buffer if we already allocated
            //  a new buffer for the full file name.
            //

            if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE ) &&
                (CaseInsensitiveIndex < FullFileName->Length)) {

                UNICODE_STRING StringToUpcase;

                //
                //  Original file name and full file name better have the same buffer or there
                //  should be a related file object.  If there is already an allocated
                //  buffer for the ExactCaseName then it should already be big enough for us.
                //

                ASSERT( (RelatedFileObject != NULL) ||
                        (FullFileName->Buffer == OriginalFileName->Buffer) );

                //
                //  If there is a related name then we can use the original buffer
                //  unless the full name is using the same buffer.
                //

                if (OriginalFileName->Buffer != FullFileName->Buffer) {

                    //
                    //  We might have already used the original buffer for the case
                    //  where we are retrying the request.
                    //

                    ASSERT( (ExactCaseName->Buffer == NULL) ||
                            (ExactCaseName->Buffer == OriginalFileName->Buffer) );

                    ExactCaseName->Buffer = OriginalFileName->Buffer;

                    //
                    //  MaximumLength includes any stream descriptors.
                    //  Length is limited to the Length in the FullName.
                    //

                    ExactCaseName->MaximumLength = OriginalFileName->Length;
                    ExactCaseName->Length = FullFileName->Length - ExactCaseOffset;
                    ASSERT( FullFileName->Length >= ExactCaseOffset );

                //
                //  We need to store the exact case name away for any of the create type
                //  operations and target directory opens since they are used in rename operations
                //  and we depend on the case being preserved in the ignored part of the name -
                //  otherwise we'll upcase in place.
                //

                } else if ((CreateDisposition == FILE_CREATE) ||
                           (CreateDisposition == FILE_OPEN_IF) ||
                           (CreateDisposition == FILE_OVERWRITE_IF) ||
                           (CreateDisposition == FILE_SUPERSEDE) ||
                           FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                    //
                    //  Allocate a buffer if we don't already have one.
                    //

                    ExactCaseName->MaximumLength = OriginalFileName->Length;

                    if (ExactCaseName->Buffer == NULL) {

                        ExactCaseName->Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                                          OriginalFileName->MaximumLength,
                                                                          MODULE_POOL_TAG );
                    }

                    RtlCopyMemory( ExactCaseName->Buffer,
                                   FullFileName->Buffer,
                                   FullFileName->MaximumLength );

                    ExactCaseName->Length = FullFileName->Length - ExactCaseOffset;
                    ASSERT( FullFileName->Length >= ExactCaseOffset );
                }

                //
                //  Upcase the file name portion of the full name.
                //

                StringToUpcase.Buffer = Add2Ptr( FullFileName->Buffer,
                                                 CaseInsensitiveIndex );

                StringToUpcase.Length =
                StringToUpcase.MaximumLength = FullFileName->Length - (USHORT) CaseInsensitiveIndex;

                NtfsUpcaseName( Vcb->UpcaseTable, Vcb->UpcaseTableSize, &StringToUpcase );
            }

            RemainingName = *FullFileName;

            //
            //  Make it plain we don't have any hash values.
            //

            CreateContext->FileHashLength = CreateContext->ParentHashLength = 0;

            //
            //  If this is the traverse access case or the open by file id case we start
            //  relative to the file object we have or the root directory.
            //  This is also true for the case where the file name in the file object is
            //  empty.
            //

            if ((FileObjectName->Length == 0) ||
                (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ) &&
                 (FileObjectName->Buffer[0] != L':'))) {

                //
                //  We should already have the parent exclusive if we hit this path.
                //

                ASSERT( !FlagOn( CreateContext->CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB ) );

                if (RelatedFileObject != NULL) {

                    CurrentLcb = RelatedCcb->Lcb;
                    CurrentScb = RelatedScb;

                    if (FileObjectName->Length == 0) {

                        RemainingName.Length = 0;

                    } else if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                        USHORT Increment;

                        Increment = RelatedCcb->FullFileName.Length
                                    + (RelatedCcb->FullFileName.Length == 2
                                       ? 0
                                       : 2);

                        RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer,
                                                                  Increment );

                        RemainingName.Length -= Increment;
                    }

                } else {

                    CurrentLcb = Vcb->RootLcb;
                    CurrentScb = Vcb->RootIndexScb;

                    RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer, sizeof( WCHAR ));
                    RemainingName.Length -= sizeof( WCHAR );
                }

            //
            //  Otherwise we will try a prefix lookup.
            //

            } else {

                if (RelatedFileObject != NULL) {

                    if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                        //
                        //  Skip over the characters in the related file object.
                        //

                        RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer,
                                                                  RelatedCcb->FullFileName.Length );
                        RemainingName.Length -= RelatedCcb->FullFileName.Length;

                        //
                        //  Step over the backslash if present.
                        //

                        if ((RemainingName.Length != 0) &&
                            (RemainingName.Buffer[0] == L'\\')) {

                            RemainingName.Buffer += 1;
                            RemainingName.Length -= sizeof( WCHAR );
                        }
                    }

                    CurrentLcb = RelatedCcb->Lcb;
                    CurrentScb = RelatedScb;

                } else {

                    CurrentLcb = Vcb->RootLcb;
                    CurrentScb = Vcb->RootIndexScb;

                    //
                    //  Skip over the lead-in '\' character.
                    //

                    RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer,
                                                              sizeof( WCHAR ));
                    RemainingName.Length -= sizeof( WCHAR );
                }

                LcbForTeardown = NULL;

                //
                //  If we don't have the starting Scb exclusively then let's try for
                //  a hash hit first.
                //

                if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB )) {

                    NextLcb = NtfsFindPrefixHashEntry( IrpContext,
                                                       &Vcb->HashTable,
                                                       CurrentScb,
                                                       &CreateContext->CreateFlags,
                                                       &CreateContext->CurrentFcb,
                                                       &CreateContext->FileHashValue,
                                                       &CreateContext->FileHashLength,
                                                       &CreateContext->ParentHashValue,
                                                       &CreateContext->ParentHashLength,
                                                       &RemainingName );

                    //
                    //  If we didn't get an Lcb then release the starting Scb
                    //  and reacquire exclusively.
                    //

                    if (NextLcb == NULL) {

                        NtfsReleaseFcbWithPaging( IrpContext, CreateContext->CurrentFcb );
                        NtfsAcquireFcbWithPaging( IrpContext, CreateContext->CurrentFcb, 0 );

                    } else {

                        //
                        //  Remember the Lcb we found.  If there is still a
                        //  portion of the name remaining then check if there
                        //  is an existing $INDEX_ALLOCATION scb on the file.
                        //  It is possible that we aren't even at a directory
                        //  in the reparse case.
                        //

                        CurrentLcb = NextLcb;

                        //
                        //  We have progressed parsing the name. Mark it as one that needs to be inspected
                        //  for possible reparse behavior.
                        //

                        SetFlag( CreateContext->CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE );

                        if (RemainingName.Length != 0) {

                            CurrentScb = NtfsCreateScb( IrpContext,
                                                        CreateContext->CurrentFcb,
                                                        $INDEX_ALLOCATION,
                                                        &NtfsFileNameIndex,
                                                        TRUE,
                                                        NULL );
                        }
                    }

                    //
                    //  In both cases here we own the Fcb exclusive.
                    //

                    ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
#ifdef NTFS_HASH_DATA
                } else {
                    Vcb->HashTable.SkipHashLookupCount += 1;
#endif
                }

                if ((RemainingName.Length != 0) &&
                    (CurrentScb != NULL)) {

                    NextLcb = NtfsFindPrefix( IrpContext,
                                              CurrentScb,
                                              &CreateContext->CurrentFcb,
                                              &LcbForTeardown,
                                              RemainingName,
                                              &CreateContext->CreateFlags,
                                              &RemainingName );
                }

                //
                //  If we found another link then update the CurrentLcb value.
                //

                if (NextLcb != NULL) {

                    CurrentLcb = NextLcb;

                    //
                    //  We have progressed parsing the name. Mark it as one that needs to be inspected
                    //  for possible reparse behavior.
                    //

                    SetFlag( CreateContext->CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE );
                }
            }

            if ((RemainingName.Length == 0) || !FlagOn( CreateContext->CreateFlags, CREATE_FLAG_FIRST_PASS )) {

                break;
            }

            //
            //  If we get here, it means that this is the first pass and we didn't
            //  have a prefix match.  If there is a colon in the
            //  remaining name, then we need to analyze the name in more detail.
            //

            ComplexName = FALSE;

            for (Index = (RemainingName.Length / sizeof( WCHAR )) - 1, ComplexName = FALSE;
                 Index >= 0;
                 Index -= 1) {

                if (RemainingName.Buffer[Index] == L':') {

                    ComplexName = TRUE;
                    break;
                }
            }

            if (!ComplexName) {

                break;
            }

            ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_FIRST_PASS);

            //
            //  Copy the exact name back to the full name.  In this case we want to
            //  restore the entire name including stream descriptors.
            //

            if (ExactCaseName->Buffer != NULL) {

                ASSERT( ExactCaseName->Length != 0 );
                ASSERT( FullFileName->MaximumLength >= ExactCaseName->Length );

                RtlCopyMemory( Add2Ptr( FullFileName->Buffer, ExactCaseOffset ),
                               ExactCaseName->Buffer,
                               ExactCaseName->MaximumLength );

                //
                //  Save the buffer for now but set the lengths to zero as a
                //  flag to indicate that we have already copied the data back.
                //

                ExactCaseName->Length = ExactCaseName->MaximumLength = 0;
            }

            //
            //  Let's release the Fcb we have currently acquired.
            //

            NtfsReleaseFcbWithPaging( IrpContext, CreateContext->CurrentFcb );
            LcbForTeardown = NULL;
        }

        //
        //  Check if the link or the Fcb is pending delete.
        //

        if (((CurrentLcb != NULL) && LcbLinkIsDeleted( CurrentLcb )) ||
            CreateContext->CurrentFcb->LinkCount == 0) {

            try_return( Status = STATUS_DELETE_PENDING );
        }

        //
        //  Put the new name into the file object.
        //

        CreateContext->Cleanup.FileObject->FileName = *FullFileName;

        //
        //  If the entire path was parsed, then we have access to the Fcb to
        //  open.  We either open the parent of the prefix match or the prefix
        //  match itself, depending on whether the user wanted to open
        //  the target directory.
        //

        if (RemainingName.Length == 0) {

            //
            //  Check the attribute name length.
            //

            if (AttrName.Length > (NTFS_MAX_ATTR_NAME_LEN * sizeof( WCHAR ))) {

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  If this is a target directory we check that the open is for the
            //  entire file.
            //  We assume that the final component can only have an attribute
            //  which corresponds to the type of file this is.  Meaning
            //  $INDEX_ALLOCATION for directory, $DATA (unnamed) for a file.
            //  We verify that the matching Lcb is not the root Lcb.
            //

            if (FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                if (CurrentLcb == Vcb->RootLcb) {

                    DebugTrace( 0, Dbg, ("Can't open parent of root\n") );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  We don't allow attribute names or attribute codes to
                //  be specified.
                //

                if ((AttrName.Length != 0) ||
                    FlagOn( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE )) {

                    DebugTrace( 0, Dbg, ("Can't specify complex name for rename\n") );
                    try_return( Status = STATUS_OBJECT_NAME_INVALID );
                }

                //
                //  When SL_OPEN_TARGET_DIRECTORY is set, the directory should not be opened
                //  as a reparse point; FILE_OPEN_REPARSE_POINT should not be set.
                //

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

                    //
                    //  Wrong open flag, invalid parameter.
                    //

                    DebugTrace( 0, Dbg, ("Can't open intermediate directory as reparse point 1.\n") );
                    Status = STATUS_INVALID_PARAMETER;
                    try_return( Status );
                }

                //
                //  We want to copy the exact case of the name back into the
                //  input buffer for this case.
                //

                if (ExactCaseName->Buffer != NULL) {

                    ASSERT( ExactCaseName->Length != 0 );
                    ASSERT( FullFileName->MaximumLength >= ExactCaseName->Length + ExactCaseOffset );

                    RtlCopyMemory( Add2Ptr( FullFileName->Buffer, ExactCaseOffset ),
                                   ExactCaseName->Buffer,
                                   ExactCaseName->MaximumLength );
                }

                //
                //  Acquire the parent of the last Fcb.  This is the actual file we
                //  are opening.
                //

                ParentFcb = CurrentLcb->Scb->Fcb;
                NtfsAcquireFcbWithPaging( IrpContext, ParentFcb, 0 );

                //
                //  Call our open target directory, remembering the target
                //  file existed.
                //

                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_FOUND_ENTRY );

                Status = NtfsOpenTargetDirectory( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  ParentFcb,
                                                  NULL,
                                                  &CreateContext->Cleanup.FileObject->FileName,
                                                  CurrentLcb->ExactCaseLink.LinkName.Length,
                                                  CreateContext );

                try_return( NOTHING );
            }

            //
            //  Otherwise we simply attempt to open the Fcb we matched.
            //

            if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                Status = NtfsOpenFcbById( IrpContext,
                                          Irp,
                                          IrpSp,
                                          Vcb,
                                          CurrentLcb,
                                          CreateContext->CurrentFcb->FileReference,
                                          AttrName,
                                          AttrCode,
                                          CreateContext );

                //
                //  If the status is pending, the irp or the file object may have gone
                //  away already.
                //

                if ((Status != STATUS_PENDING) && (Status != STATUS_WAIT_FOR_OPLOCK)) {

                    //
                    //  There should be no need to set TraverseAccessCheck now, it should
                    //  already be set correctly.
                    //

                    ASSERT( (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ) &&
                             FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_TRAVERSE_PRIVILEGE )) ||

                            (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ) &&
                             !FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_TRAVERSE_PRIVILEGE )) );

                    //
                    //  Set the maximum length in the file object name to
                    //  zero so we know that this is not a full name.
                    //

                    CreateContext->Cleanup.FileObject->FileName.MaximumLength = 0;
                }

            } else {

                //
                //  The current Fcb is acquired.
                //

                Status = NtfsOpenExistingPrefixFcb( IrpContext,
                                                    Irp,
                                                    IrpSp,
                                                    CurrentLcb,
                                                    FullFileName->Length,
                                                    AttrName,
                                                    AttrCode,
                                                    CreateContext );
            }

            try_return( NOTHING );
        }

        //
        //  Check if the current Lcb is a Dos-Only Name.
        //

        if ((CurrentLcb != NULL) &&
            (CurrentLcb->FileNameAttr->Flags == FILE_NAME_DOS)) {

            SetFlag( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
        }

        //
        //  We have a remaining portion of the file name which was unmatched in the
        //  prefix table.  We walk through these name components until we reach the
        //  last element.  If necessary, we add Fcb and Scb's into the graph as we
        //  walk through the names.
        //

        SetFlag( CreateContext->CreateFlags, CREATE_FLAG_FIRST_PASS);

        while (TRUE) {

            PFILE_NAME IndexFileName;

            //
            //  We check to see whether we need to inspect this name for possible reparse behavior
            //  and whether the CurrentFcb is a reparse point.
            //  Notice that if a directory is a reparse point, there should be no
            //  prefix match possible in NtfsFindPrefix beyond the directory name,
            //  as longer matches could bypass a reparse point.
            //

            if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE ) &&
                FlagOn( CreateContext->CurrentFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                USHORT AttributeNameLength = 0;

                //
                //  Traverse access is done before accessing the disk.
                //  For a directory we check for traverse access.
                //  For a file we check for read access.
                //

                if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK )) {

                    if (IsDirectory( &CreateContext->CurrentFcb->Info )) {

                        NtfsTraverseCheck( IrpContext,
                                           CreateContext->CurrentFcb,
                                           Irp );
                    } else {

                        NtfsAccessCheck ( IrpContext,
                                          CreateContext->CurrentFcb,
                                          NULL,
                                          Irp,
                                          FILE_GENERIC_READ,
                                          TRUE );
                    }
                }

                //
                //  Middle-of-name reparse point call.
                //  Notice that the FILE_OPEN_REPARSE_POINT flag only alters the behavior of
                //  a final element of a named path, not the intermediate components.
                //  Notice further that we need this check here prior to the directory check
                //  below as it is legal to have an intermediate name that is a file
                //  containing a symbolic link.
                //

                //
                //  When NetworkInfo is present, we are in the fast-I/O path to retrieve
                //  the attributes of a target file. The fast path does not process retries
                //  due to reparse points. We return indicating that a reparse point has
                //  been encountered without returning the reparse point data.
                //

                if (CreateContext->NetworkInfo) {

                    DebugTrace( 0, Dbg, ("Reparse point encountered with NetworkInfo present.\n") );
                    Status = STATUS_REPARSE;

                    try_return( Status );
                }

                //
                //  We account for the byte size of the attribute name delimiter : (colon)
                //  in unicode.
                //  If the name of the code or type of the attribute has been passed on explicitly,
                //  like $DATA or $INDEX_ALLOCATION, we also account for it.
                //
                //  Notice that the code below ignores the case when no attribute name has been specified
                //  yet the name of its code, or type, has been specified.
                //

                ASSERT( CreateContext->Cleanup.AttributeNameLength == AttrName.Length );
                if (CreateContext->Cleanup.AttributeNameLength > 0) {

                    AttributeNameLength += CreateContext->Cleanup.AttributeNameLength + 2;
                }
                if (CreateContext->Cleanup.AttributeCodeNameLength > 0) {

                    AttributeNameLength += CreateContext->Cleanup.AttributeCodeNameLength + 2;
                }
                if (RemainingName.Length > 0) {

                    //
                    //  Account for the backslash delimeter.
                    //

                    AttributeNameLength += 2;
                }

                DebugTrace( 0, Dbg, ("RemainingName.Length = %d CreateContext->Cleanup.AttributeNameLength = %d CreateContext->Cleanup.AttributeCodeNameLength = %d AttributeNameLength = %d sum = %d\n",
                            RemainingName.Length, CreateContext->Cleanup.AttributeNameLength, CreateContext->Cleanup.AttributeCodeNameLength, AttributeNameLength, (RemainingName.Length + AttributeNameLength)) );

                Status = NtfsGetReparsePointValue( IrpContext,
                                                   Irp,
                                                   IrpSp,
                                                   CreateContext->CurrentFcb,
                                                   (USHORT)(RemainingName.Length + AttributeNameLength) );

                try_return( Status );
            }

            //
            //  We check that the last Fcb we have is in fact a directory.
            //

            if (!IsDirectory( &CreateContext->CurrentFcb->Info )) {

                DebugTrace( 0, Dbg, ("Intermediate node is not a directory\n") );
                try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
            }

            //
            //  We dissect the name into the next component and the remaining name string.
            //  We don't need to check for a valid name if we examined the name already.
            //

            Status = NtfsDissectName( RemainingName,
                                      &FinalName,
                                      &RemainingName );
            if (!NT_SUCCESS( Status )) {
                try_return( Status );
            }

            DebugTrace( 0, Dbg, ("Final name     -> %Z\n", &FinalName) );
            DebugTrace( 0, Dbg, ("Remaining Name -> %Z\n", &RemainingName) );

            //
            //  If the final name is too long then either the path or the
            //  name is invalid.
            //

            if (FinalName.Length > (NTFS_MAX_FILE_NAME_LENGTH * sizeof( WCHAR ))) {

                if (RemainingName.Length == 0) {

                    try_return( Status = STATUS_OBJECT_NAME_INVALID );

                } else {

                    try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                }
            }

            //
            //  Catch single dot names (.) before scanning the index.  We don't
            //  want to allow someone to open the self entry in the root.
            //

            if ((FinalName.Length == 2) &&
                (FinalName.Buffer[0] == L'.')) {

                if (RemainingName.Length != 0) {

                    DebugTrace( 0, Dbg, ("Intermediate component in path doesn't exist\n") );
                    try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );

                //
                //  If the final component is illegal, then return the appropriate error.
                //

                } else {

                    try_return( Status = STATUS_OBJECT_NAME_INVALID );
                }
            }

            //
            //  Get the index allocation Scb for the current Fcb.
            //

            //
            //  We need to look for the next component in the name string in the directory
            //  we've reached.  We need to get a Scb to perform the index search.
            //  To do the search we need to build a filename attribute to perform the
            //  search with and then call the index package to perform the search.
            //

            CurrentScb = NtfsCreateScb( IrpContext,
                                        CreateContext->CurrentFcb,
                                        $INDEX_ALLOCATION,
                                        &NtfsFileNameIndex,
                                        FALSE,
                                        NULL );

            //
            //  If the CurrentScb does not have its normalized name and we have a valid
            //  parent, then update the normalized name.
            //

            if ((LastScb != NULL) &&
                (CurrentScb->ScbType.Index.NormalizedName.Length == 0) &&
                (LastScb->ScbType.Index.NormalizedName.Length != 0)) {

                NtfsUpdateNormalizedName( IrpContext, LastScb, CurrentScb, NULL, FALSE, FALSE );

            }

            //
            //  Release the parent Scb if we own it.
            //

            if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_FIRST_PASS )) {

                NtfsReleaseFcbWithPaging( IrpContext, ParentFcb );
            }

            LastScb = CurrentScb;

            //
            //  If traverse access is required, we do so now before accessing the
            //  disk.
            //

            if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK )) {

                NtfsTraverseCheck( IrpContext,
                                   CreateContext->CurrentFcb,
                                   Irp );
            }

            ASSERT( IndexEntryBcb == NULL );

            //
            //  Check that the name is valid before scanning the disk.
            //

            if (!NtfsIsFileNameValid( &FinalName, FALSE )) {

                DebugTrace( 0, Dbg, ("Component name is invalid\n") );
                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  Initialize or reinitialize the context as necessary.
            //

            if (IndexContext == NULL) {

#if defined(_WIN64)
                IndexContext = &IndexContextStruct;
#else
                //
                //  AllocateFromStack can raise but the create exception filter will catch it.
                //  We can only do this in one pass through the loop.  Otherwise we could
                //  walk off stack.
                //

                IndexContext = NtfsAllocateFromStack( sizeof( INDEX_CONTEXT ));
#endif
                NtfsInitializeIndexContext( IndexContext );
            }

            //
            //  Look on the disk to see if we can find the last component on the path.
            //

            if (NtfsLookupEntry( IrpContext,
                                 CurrentScb,
                                 BooleanFlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE ),
                                 &FinalName,
                                 &FileNameAttr,
                                 &FileNameAttrLength,
                                 &QuickIndex,
                                 &IndexEntry,
                                 &IndexEntryBcb,
                                 IndexContext )) {

                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_FOUND_ENTRY );
            } else {
                ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_FOUND_ENTRY );
            }

            //
            //  This call to NtfsLookupEntry may decide to push the root index.
            //  Create needs to free resources as it walks down the tree to prevent
            //  deadlocks.  If there is a transaction, commit it now so we will be
            //  able to free this resource.
            //

            if (IrpContext->TransactionId != 0) {

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Go through and free any Scb's in the queue of shared
                //  Scb's for transactions.
                //

                if (IrpContext->SharedScb != NULL) {
                    NtfsReleaseSharedResources( IrpContext );
                    ASSERT( IrpContext->SharedScb == NULL );
                }

                //
                // Release the MftScb, if we acquired it in pushing the root index.
                //

                NtfsReleaseExclusiveScbIfOwned( IrpContext, Vcb->MftScb );
            }

            if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_FOUND_ENTRY )) {

                ASSERT( !FlagOn( CreateContext->CurrentFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) );

                //
                //  Get the file name attribute so we can get the name out of it.
                //

                IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

                if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                    RtlCopyMemory( FinalName.Buffer,
                                   IndexFileName->FileName,
                                   FinalName.Length );
                }
            }

            //
            //  If we didn't find a matching entry in the index, we need to check if the
            //  name is illegal or simply isn't present on the disk.
            //

            if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_FOUND_ENTRY )) {

                //
                //  We're going to attempt to create the file. We can immediately reject
                //
                //  1. paths where an intermediate piece doesn't exist
                //  2. non create type opens unless this is an open target directory type open
                //  3. an overwrite_if on directories
                //  4. any attempt on a read-only volume
                //  5. creation attempts in a reparse point directory (not its target)
                //     we'd only reach this point if the file_flag_open_reparse_point flag was specified
                //

                if (RemainingName.Length != 0) {

                    DebugTrace( 0, Dbg, ("Intermediate component in path doesn't exist\n") );
                    try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );

                }

                if (FlagOn( CreateContext->CurrentFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                    DebugTrace( 0, Dbg, ("For reparse points subdirectories are not allowed.\n") );
                    try_return( Status = STATUS_DIRECTORY_IS_A_REPARSE_POINT );
                }

                if (!FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                    if ((CreateDisposition == FILE_OPEN) || (CreateDisposition == FILE_OVERWRITE)) {

                        DebugTrace( 0, Dbg, ("Final component in path doesn't exist\n") );
                        try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
                    }

                    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE ) &&
                               (CreateDisposition == FILE_OVERWRITE_IF)) {

                        DebugTrace( 0, Dbg, ("Can't create directory with overwrite_if flag\n") );
                        try_return( Status = STATUS_OBJECT_NAME_INVALID );
                    }

                    if (NtfsIsVolumeReadOnly( Vcb )) {

                        DebugTrace( 0, Dbg, ("Readonly volume can't create file\n") );
                        try_return( Status = STATUS_MEDIA_WRITE_PROTECTED );
                    }

                    //
                    //  Now copy the exact case of the name specified by the user back
                    //  in the file name buffer and file name attribute in order to
                    //  create the name.
                    //

                    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE)) {

                        ASSERT( ExactCaseName->Length != 0 );
                        ASSERT( FullFileName->Length >= ExactCaseName->Length + ExactCaseOffset );

                        RtlCopyMemory( FinalName.Buffer,
                                       Add2Ptr( ExactCaseName->Buffer,
                                                ExactCaseName->Length - FinalName.Length ),
                                       FinalName.Length );

                        RtlCopyMemory( FileNameAttr->FileName,
                                       Add2Ptr( ExactCaseName->Buffer,
                                                ExactCaseName->Length - FinalName.Length ),
                                       FinalName.Length );
                    }
                }

            }

            //
            //  If we're at the last component in the path, then this is the file
            //  to open or create
            //

            if (RemainingName.Length == 0) {

                break;
            }

            //
            //  Otherwise we create an Fcb for the subdirectory and the link between
            //  it and its parent Scb.
            //

            //
            //  Discard any mapping information we have for the parent.
            //

            NtfsRemoveFromFileRecordCache( IrpContext,
                                           NtfsSegmentNumber( &CurrentScb->Fcb->FileReference ));

            FileReference = IndexEntry->FileReference;
            FileNameFlags = ((PFILE_NAME) NtfsFoundIndexEntry( IndexEntry ))->Flags;

            //
            //  Close any mappings we have since open subdir may drop the parent
            //

            NtfsUnpinBcb( IrpContext, &IndexEntryBcb );
            NtfsReinitializeIndexContext( IrpContext, IndexContext );
            IndexEntry = NULL;

            //
            //  Remember that the current values will become the parent values.
            //

            ParentFcb = CreateContext->CurrentFcb;

            CurrentLcb = NtfsOpenSubdirectory( IrpContext,
                                               CurrentScb,
                                               &FileReference,
                                               FinalName,
                                               FileNameFlags,
                                               CreateContext,
                                               &LcbForTeardown );

            //
            //  Check that this link is a valid existing link.
            //

            if (LcbLinkIsDeleted( CurrentLcb ) ||
                CreateContext->CurrentFcb->LinkCount == 0) {

                try_return( Status = STATUS_DELETE_PENDING );
            }

            //
            //  We have progressed parsing the name. Mark it as one that needs to be inspected
            //  for possible reparse behavior.
            //

            SetFlag( CreateContext->CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE );

            //
            //  Go ahead and insert this link into the splay tree if it is not
            //  a system file.
            //

            if (!FlagOn( CurrentLcb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                //
                //  See if we can insert the hash for the parent.
                //

                if ((CreateContext->ParentHashLength != 0) &&
                    (RemainingName.Length == CreateContext->FileHashLength - CreateContext->ParentHashLength - sizeof( WCHAR )) &&
                    !FlagOn( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT ) &&
                    (CurrentLcb->FileNameAttr->Flags != FILE_NAME_DOS)) {

                    //
                    //  Remove any exising hash value.
                    //

                    if (FlagOn( CurrentLcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                        NtfsRemoveHashEntriesForLcb( CurrentLcb );
#ifdef NTFS_HASH_DATA
                        Vcb->HashTable.ParentConflict += 1;
#endif
                    }

                    NtfsInsertHashEntry( &Vcb->HashTable,
                                         CurrentLcb,
                                         CreateContext->ParentHashLength,
                                         CreateContext->ParentHashValue );
#ifdef NTFS_HASH_DATA
                    Vcb->HashTable.ParentInsert += 1;
#endif
                }

                NtfsInsertPrefix( CurrentLcb, CreateContext->CreateFlags );
            }

            //
            //  Since we have the location of this entry store the information into
            //  the Lcb.
            //

            RtlCopyMemory( &CurrentLcb->QuickIndex,
                           &QuickIndex,
                           sizeof( QUICK_INDEX ));

            //
            //  Check if the current Lcb is a Dos-Only Name.
            //

            if (CurrentLcb->FileNameAttr->Flags == FILE_NAME_DOS) {
                SetFlag( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
            }

            ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_FIRST_PASS);
        }

        //
        //  We now have the parent of the file to open and know whether the file exists on
        //  the disk.  At this point we either attempt to open the target directory or
        //  the file itself.
        //

        if (FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) {

            ASSERT( IndexContext != NULL );

            NtfsCleanupIndexContext( IrpContext, IndexContext );
            IndexContext = NULL;

            //
            //  We don't allow attribute names or attribute codes to
            //  be specified.
            //

            if ((AttrName.Length != 0) ||
                FlagOn( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE)) {

                DebugTrace( 0, Dbg, ("Can't specify complex name for rename\n") );
                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  When SL_OPEN_TARGET_DIRECTORY is set, the directory should not be opened
            //  as a reparse point; FILE_OPEN_REPARSE_POINT should not be set.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

                //
                //  Wrong open flag, invalid parameter.
                //

                DebugTrace( 0, Dbg, ("Can't open intermediate directory as reparse point 2.\n") );
                Status = STATUS_INVALID_PARAMETER;
                try_return( Status );
            }

            //
            //  We want to copy the exact case of the name back into the
            //  input buffer for this case.
            //

            if (ExactCaseName->Buffer != NULL) {

                ASSERT( ExactCaseName->Length != 0 );
                ASSERT( FullFileName->MaximumLength >= ExactCaseName->MaximumLength + ExactCaseOffset );

                RtlCopyMemory( Add2Ptr( FullFileName->Buffer, ExactCaseOffset ),
                               ExactCaseName->Buffer,
                               ExactCaseName->MaximumLength );
            }

            //
            //  Call our open target directory, remembering the target
            //  file existed.
            //

            Status = NtfsOpenTargetDirectory( IrpContext,
                                              Irp,
                                              IrpSp,
                                              CreateContext->CurrentFcb,
                                              CurrentLcb,
                                              &CreateContext->Cleanup.FileObject->FileName,
                                              FinalName.Length,
                                              CreateContext );


            try_return( Status );
        }

        //
        //  If we didn't find an entry, we will try to create the file.
        //

        if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_FOUND_ENTRY )) {

            //
            //  Update our pointers to reflect that we are at the
            //  parent of the file we want.
            //

            ParentFcb = CreateContext->CurrentFcb;

            //
            //  No point in going down the create path for a Network Query.
            //

            if (CreateContext->NetworkInfo) {

                Status = STATUS_OBJECT_NAME_NOT_FOUND;

            } else {

                Status = NtfsCreateNewFile( IrpContext,
                                            Irp,
                                            IrpSp,
                                            CurrentScb,
                                            FileNameAttr,
                                            *FullFileName,
                                            FinalName,
                                            AttrName,
                                            AttrCode,
                                            &IndexContext,
                                            CreateContext,
                                            &LcbForTeardown );
            }

            SetFlag( CreateContext->CreateFlags, CREATE_FLAG_CREATE_FILE_CASE );

        //
        //  Otherwise we call our routine to open the file.
        //

        } else {

            ASSERT( IndexContext != NULL );

            NtfsCleanupIndexContext( IrpContext, IndexContext );
            IndexContext = NULL;

            ParentFcb = CreateContext->CurrentFcb;

#ifdef BENL_DBG
            ASSERT( IrpContext->TransactionId == 0 );
#endif

            Status = NtfsOpenFile( IrpContext,
                                   Irp,
                                   IrpSp,
                                   CurrentScb,
                                   IndexEntry,
                                   *FullFileName,
                                   FinalName,
                                   AttrName,
                                   AttrCode,
                                   &QuickIndex,
                                   CreateContext,
                                   &LcbForTeardown );
        }

    try_exit:  NOTHING;

        //
        //  If we raise below then we need to back out any failed opens.
        //

        SetFlag( CreateContext->CreateFlags, CREATE_FLAG_BACKOUT_FAILED_OPENS );

        //
        //  Abort transaction on err by raising.
        //

        if ((Status != STATUS_PENDING) && (Status != STATUS_WAIT_FOR_OPLOCK)) {

            NtfsCleanupTransaction( IrpContext, Status, FALSE );
        }

    } finally {

        DebugUnwind( NtfsCommonCreate );

        //
        //  If we only have the current Fcb shared then simply give it up.
        //

        if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB ) && (CreateContext->CurrentFcb != NULL)) {

            NtfsReleaseFcb( IrpContext, CreateContext->CurrentFcb );
            CreateContext->CurrentFcb = NULL;
        }

        //
        //  Unpin the index entry.
        //

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  Cleanup the index context if used.
        //

        if (IndexContext != NULL) {

            NtfsCleanupIndexContext( IrpContext, IndexContext );
        }

        //
        //  Free the file name attribute if we allocated it.
        //

        if (FileNameAttr != NULL) {

            NtfsFreePool( FileNameAttr );
        }

        //
        //  Capture the status code from the IrpContext if we are in the exception path.
        //

        if (AbnormalTermination()) {

            Status = IrpContext->ExceptionStatus;
        }

        //
        //  If this is the oplock completion path then don't do any of this completion work,
        //  The Irp may already have been posted to another thread.
        //

        if ((Status != STATUS_PENDING) && (Status != STATUS_WAIT_FOR_OPLOCK)) {

            //
            //  If we successfully opened the file, we need to update the in-memory
            //  structures.
            //

            if (NT_SUCCESS( Status ) && (Status != STATUS_REPARSE)) {

                //
                //  If the create completed, there's no reason why we shouldn't have
                //  a valid ThisScb now.
                //

                ASSERT( CreateContext->ThisScb != NULL );

                //
                //  If we modified the original file name, we can delete the original
                //  buffer.
                //

                if ((OriginalFileName->Buffer != NULL) &&
                    (OriginalFileName->Buffer != FullFileName->Buffer)) {

                    NtfsFreePool( OriginalFileName->Buffer );
                }

                //
                //  Do our normal processing if this is not a Network Info query.
                //

                if (CreateContext->NetworkInfo == NULL) {

                    //
                    //  Find the Lcb for this open.
                    //

                    CurrentLcb = CreateContext->ThisCcb->Lcb;

                    //
                    //  Check if we were opening a paging file and if so then make sure that
                    //  the internal attribute stream is all closed down
                    //

                    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) {

                        NtfsDeleteInternalAttributeStream( CreateContext->ThisScb, TRUE, FALSE );
                    }

                    //
                    //  If we are not done with a large allocation for a new attribute,
                    //  then we must make sure that no one can open the file until we
                    //  try to get it extended.  Do this before dropping the Vcb.
                    //

                    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION )) {

                        //
                        //  For a new file, we can clear the link count and mark the
                        //  Lcb (if there is one) delete on close.
                        //

                        if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_CREATE_FILE_CASE )) {

                            CreateContext->CurrentFcb->LinkCount = 0;

                            SetFlag( CurrentLcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                        //
                        //  If we just created an attribute, then we will mark that attribute
                        //  delete on close to prevent it from being opened.
                        //

                        } else {

                            SetFlag( CreateContext->ThisScb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
                        }
                    }

                    //
                    //  Remember the POSIX flag and whether we had to do any traverse
                    //  access checking.
                    //

                    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                        SetFlag( CreateContext->ThisCcb->Flags, CCB_FLAG_IGNORE_CASE );
                    }

                    //
                    //  Remember if this user needs to do traverse checks so we can show him the
                    //  name from the root.
                    //

                    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK )) {

                        SetFlag( CreateContext->ThisCcb->Flags, CCB_FLAG_TRAVERSE_CHECK );
                    }

                    //
                    //  Remember who this user is so we know whether to allow
                    //  raw reads and writes of encrypted data.
                    //

                    {
                        PACCESS_STATE AccessState;
                        PRIVILEGE_SET PrivilegeSet;

                        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

                        //
                        //  No flags should be preset
                        //

                        ASSERT( CreateContext->ThisCcb->AccessFlags == 0 );

                        //
                        //  This will set the READ_DATA_ACCESS, WRITE_DATA_ACCESS,
                        //  APPEND_DATA_ACCESS, and EXECUTE_ACCESS bits correctly.
                        //

                        SetFlag( CreateContext->ThisCcb->AccessFlags,
                                 FlagOn( AccessState->PreviouslyGrantedAccess, FILE_READ_DATA |
                                                                               FILE_WRITE_DATA |
                                                                               FILE_APPEND_DATA |
                                                                               FILE_EXECUTE |
                                                                               FILE_WRITE_ATTRIBUTES |
                                                                               FILE_READ_ATTRIBUTES ));

                        //
                        //  Here we're setting BACKUP_ACCESS and RESTORE_ACCESS.  We want to set
                        //  the Ccb flag if the user has the privilege AND they opened the file up
                        //  with an access that is interesting. For example backup or restore will give
                        //  you synchronize but if you open the file up only for that we don't want
                        //  to remember the privileges (its too ambiguous and you'll backup or restore
                        //  depending op whether you're local or remote))
                        //

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, NTFS_REQUIRES_BACKUP ) &&
                            FlagOn( AccessState->Flags, TOKEN_HAS_BACKUP_PRIVILEGE )) {

                            SetFlag( CreateContext->ThisCcb->AccessFlags, BACKUP_ACCESS );
                        }

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, NTFS_REQUIRES_RESTORE ) &&
                            FlagOn( AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

                            SetFlag( CreateContext->ThisCcb->AccessFlags, RESTORE_ACCESS );
                        }

                        PrivilegeSet.PrivilegeCount = 1;
                        PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
                        PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid( SE_MANAGE_VOLUME_PRIVILEGE );
                        PrivilegeSet.Privilege[0].Attributes = 0;

                        if (SePrivilegeCheck( &PrivilegeSet,
                                              &AccessState->SubjectSecurityContext,
                                              NtfsEffectiveMode( Irp, IrpSp ))) {

                            SetFlag( CreateContext->ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );
                        }
                    }

                    //
                    //  We don't do "delete on close" for directories or open
                    //  by ID files.
                    //

                    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DELETE_ON_CLOSE ) &&
                        (!FlagOn( CreateContext->ThisCcb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) ||
                         !FlagOn( CreateContext->ThisCcb->Flags, CCB_FLAG_OPEN_AS_FILE ))) {

                        SetFlag( CreateContext->CreateFlags, CREATE_FLAG_DELETE_ON_CLOSE );

                        //
                        //  We modify the Scb and Lcb here only if we aren't in the
                        //  large allocation case.
                        //

                        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION )) {

                            SetFlag( CreateContext->ThisCcb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
                        }
                    }

                    //
                    //  If this is a named stream open and we have set any of our notify
                    //  flags then report the changes.
                    //

                    if ((Vcb->NotifyCount != 0) &&
                        !FlagOn( CreateContext->ThisCcb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
                        (CreateContext->ThisScb->AttributeName.Length != 0) &&
                        NtfsIsTypeCodeUserData( CreateContext->ThisScb->AttributeTypeCode ) &&
                        FlagOn( CreateContext->ThisScb->ScbState,
                                SCB_STATE_NOTIFY_ADD_STREAM |
                                SCB_STATE_NOTIFY_RESIZE_STREAM |
                                SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                        ULONG Filter = 0;
                        ULONG Action;

                        //
                        //  Start by checking for an add.
                        //

                        if (FlagOn( CreateContext->ThisScb->ScbState, SCB_STATE_NOTIFY_ADD_STREAM )) {

                            Filter = FILE_NOTIFY_CHANGE_STREAM_NAME;
                            Action = FILE_ACTION_ADDED_STREAM;

                        } else {

                            //
                            //  Check if the file size changed.
                            //

                            if (FlagOn( CreateContext->ThisScb->ScbState, SCB_STATE_NOTIFY_RESIZE_STREAM )) {

                                Filter = FILE_NOTIFY_CHANGE_STREAM_SIZE;
                            }

                            //
                            //  Now check if the stream data was modified.
                            //

                            if (FlagOn( CreateContext->ThisScb->ScbState, SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                                Filter |= FILE_NOTIFY_CHANGE_STREAM_WRITE;
                            }

                            Action = FILE_ACTION_MODIFIED_STREAM;
                        }

                        ASSERT( CreateContext->ThisScb && CreateContext->ThisCcb );
                        ASSERT( (CreateContext->ThisCcb->NodeTypeCode == NTFS_NTC_CCB_INDEX) || (CreateContext->ThisCcb->NodeTypeCode == NTFS_NTC_CCB_DATA) );

                        NtfsUnsafeReportDirNotify( IrpContext,
                                                   Vcb,
                                                   &CreateContext->ThisCcb->FullFileName,
                                                   CreateContext->ThisCcb->LastFileNameOffset,
                                                   &CreateContext->ThisScb->AttributeName,
                                                   ((FlagOn( CreateContext->ThisCcb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                     (CreateContext->ThisCcb->Lcb != NULL) &&
                                                     (CreateContext->ThisCcb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                    &CreateContext->ThisCcb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                    NULL),
                                                   Filter,
                                                   Action,
                                                   NULL );
                    }

                    ClearFlag( CreateContext->ThisScb->ScbState,
                               SCB_STATE_NOTIFY_ADD_STREAM |
                               SCB_STATE_NOTIFY_REMOVE_STREAM |
                               SCB_STATE_NOTIFY_RESIZE_STREAM |
                               SCB_STATE_NOTIFY_MODIFY_STREAM );

                //
                //  Otherwise copy the data out of the Scb/Fcb and return to our caller.
                //

                } else {

                    NtfsFillNetworkOpenInfo( CreateContext->NetworkInfo, CreateContext->ThisScb );

                    //
                    //  Teardown the Fcb if we should. We're in a success path
                    //  here so we don't have to worry about aborting anymore and the
                    //  need to hold any resources
                    //

                    if (!CreateContext->ThisScb->CleanupCount && !CreateContext->ThisScb->Fcb->DelayedCloseCount) {
                        if (!NtfsAddScbToFspClose( IrpContext, CreateContext->ThisScb, TRUE )) {

                            if (NtfsIsExclusiveScb( Vcb->MftScb ) ||
                                (NtfsPerformQuotaOperation( CreateContext->CurrentFcb ) &&
                                 NtfsIsSharedScb( Vcb->QuotaTableScb ))) {

                                SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
                            }

                            NtfsTeardownStructures( IrpContext,
                                                    CreateContext->CurrentFcb,
                                                    LcbForTeardown,
                                                    (BOOLEAN) (IrpContext->TransactionId != 0),
                                                    AcquireFlags,
                                                    NULL );
                        }
                    }

                    Irp->IoStatus.Information = sizeof( FILE_NETWORK_OPEN_INFORMATION );

                    Status = Irp->IoStatus.Status = STATUS_SUCCESS;
                }

            //
            //  Start a teardown on the last Fcb found and restore the name strings on
            //  a retryable error.
            //

            } else {

                //
                //  Perform the necessary cleanup if we raised writing a UsnJournal.
                //

                if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_BACKOUT_FAILED_OPENS )) {

                    NtfsBackoutFailedOpens( IrpContext, IrpSp->FileObject, CreateContext->CurrentFcb, CreateContext->ThisScb, CreateContext->ThisCcb );

                }

                //
                //  Start the cleanup process if we have looked at any Fcb's.
                //  We tell TeardownStructures not to remove any Scb's in
                //  the open attribute table if there is a transaction underway.
                //

                if (CreateContext->CurrentFcb != NULL) {

                    if (NtfsIsExclusiveScb( Vcb->MftScb ) ||
                        (NtfsPerformQuotaOperation( CreateContext->CurrentFcb ) &&
                         NtfsIsSharedScb( Vcb->QuotaTableScb ))) {

                        SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
                    }

                    //
                    //  Someone may have tried to open the $Bitmap stream.  We catch that and
                    //  fail it but the Fcb won't be in the exclusive list to be released.
                    //

                    if (NtfsEqualMftRef( &CreateContext->CurrentFcb->FileReference, &BitmapFileReference )) {

                        NtfsReleaseFcb( IrpContext, CreateContext->CurrentFcb );

                    } else {

                        BOOLEAN RemovedFcb;

                        //
                        //  In transactions that don't own any system resources we must
                        //  make sure that we don't release all of the resources before
                        //  the transaction commits.  Otherwise we won't correctly serialize
                        //  with clean checkpoints who wants to know the transaction
                        //  table is empty.  Case in point is if we create the parent Scb
                        //  and file Fcb in this call and tear them down in Teardown below.
                        //  If there are no other resources held then we have an open
                        //  transaction but no serialization.
                        //
                        //  In general we can simply acquire a system resource and put it
                        //  in the exlusive list in the IrpContext.  The best choice is
                        //  the Mft.  HOWEVER there is a strange deadlock path if we
                        //  try to acquire this while owning the security mutext.  This
                        //  can happen in the CreateNewFile path if we are creating a
                        //  new security descriptor.  So we need to add this check
                        //  before we acquire the Mft, owning the security stream will
                        //  give us the transaction protection we need.
                        //
                        //  Possible future cleanup is to change how we acquire the security
                        //  file after the security mutex.  Ideally the security mutex would
                        //  be a true end resource.
                        //

                        if ((IrpContext->TransactionId != 0) &&
                            (CreateContext->CurrentFcb->CleanupCount == 0) &&
                            ((CreateDisposition == FILE_OVERWRITE_IF) ||
                             (CreateDisposition == FILE_OVERWRITE) ||
                             (CreateDisposition == FILE_SUPERSEDE)) &&
                            ((Vcb->SecurityDescriptorStream == NULL) ||
                             (!NtfsIsSharedScb( Vcb->SecurityDescriptorStream )))) {

                            NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
                            SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
                        }

                        NtfsTeardownStructures( IrpContext,
                                                (CreateContext->ThisScb != NULL) ? (PVOID) CreateContext->ThisScb : CreateContext->CurrentFcb,
                                                LcbForTeardown,
                                                (BOOLEAN) (IrpContext->TransactionId != 0),
                                                AcquireFlags,
                                                &RemovedFcb );

                    }
                }

                if ((Status == STATUS_LOG_FILE_FULL) ||
                    (Status == STATUS_CANT_WAIT) ||
                    (Status == STATUS_REPARSE)) {

                    //
                    //  Recover the exact case name if present for a retryable condition.
                    //  and we haven't already recopied it back (ExactCaseName->Length == 0)
                    //

                    if ((ExactCaseName->Buffer != OriginalFileName->Buffer) &&
                        (ExactCaseName->Buffer != NULL) &&
                        (ExactCaseName->Length != 0)) {

                        ASSERT( OriginalFileName->MaximumLength >= ExactCaseName->MaximumLength );

                        RtlCopyMemory( OriginalFileName->Buffer,
                                       ExactCaseName->Buffer,
                                       ExactCaseName->MaximumLength );
                    }

                    //
                    //  Restitute the access control state to what it was when we entered the request.
                    //

                    IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess = CreateContext->Cleanup.RemainingDesiredAccess;
                    IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess = CreateContext->Cleanup.PreviouslyGrantedAccess;
                    IrpSp->Parameters.Create.SecurityContext->DesiredAccess = CreateContext->Cleanup.DesiredAccess;
                }

                //
                //  Free any buffer we allocated.
                //

                if ((FullFileName->Buffer != NULL) &&
                    (OriginalFileName->Buffer != FullFileName->Buffer)) {

                    DebugTrace( 0, Dbg, ("FullFileName->Buffer will be de-allocated %x\n", FullFileName->Buffer) );
                    NtfsFreePool( FullFileName->Buffer );
                    DebugDoit( FullFileName->Buffer = NULL );
                }

                //
                //  Set the file name in the file object back to it's original value.
                //

                CreateContext->Cleanup.FileObject->FileName = *OriginalFileName;

                //
                //  Always clear the LARGE_ALLOCATION flag so we don't get
                //  spoofed by STATUS_REPARSE.
                //

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION );
            }
        }

        //
        //  Always free the exact case name if allocated and it doesn't match the original
        //  name buffer.
        //

        if ((ExactCaseName->Buffer != OriginalFileName->Buffer) &&
            (ExactCaseName->Buffer != NULL)) {

            DebugTrace( 0, Dbg, ("ExactCaseName->Buffer will be de-allocated %x\n", ExactCaseName->Buffer) );
            NtfsFreePool( ExactCaseName->Buffer );
            DebugDoit( ExactCaseName->Buffer = NULL );
        }

        //
        //  We always give up the Vcb.
        //

        if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_VCB )) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If we didn't post this Irp then take action to complete the irp.
    //

    if ((Status != STATUS_PENDING) && (Status != STATUS_WAIT_FOR_OPLOCK)) {

        //
        //  If the current status is success and there is more allocation to
        //  allocate then complete the allocation.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION ) &&
            NT_SUCCESS( Status )) {

            //
            //  If the Create was successful, but we did not get all of the space
            //  allocated that we wanted, we have to complete the allocation now.
            //  Basically what we do is commit the current transaction and call
            //  NtfsAddAllocation to get the rest of the space.  Then if the log
            //  file fills up (or we are posting for other reasons) we turn the
            //  Irp into an Irp which is just trying to extend the file.  If we
            //  get any other kind of error, then we just delete the file and
            //  return with the error from create.
            //

            Status = NtfsCompleteLargeAllocation( IrpContext,
                                                  Irp,
                                                  CurrentLcb,
                                                  CreateContext->ThisScb,
                                                  CreateContext->ThisCcb,
                                                  CreateContext->CreateFlags );
        }

        //
        //  If our caller told us not to complete the irp, or if this
        //  is a network open, we don't really complete the irp.
        //  EFS_CREATES have PostCreate callouts to do before the
        //  irp gets completed, and before the irp context gets deleted,
        //  and the caller will do that for us. We should at least
        //  cleanup the irp context if our caller won't.
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE ) ||
            (CreateContext->NetworkInfo != NULL)) {

            NtfsCompleteRequest( IrpContext,
                                 NULL,
                                 Status );
#ifdef NTFSDBG
            ASSERT( None == IrpContext->OwnershipState );
#endif

        } else {

            NtfsCompleteRequest( IrpContext,
                                 Irp,
                                 Status );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCommonCreate:  Exit -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonVolumeOpen (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is opening the Volume Dasd file.  We have already done all the
    checks needed to verify that the user is opening the $DATA attribute.
    We check the security attached to the file and take some special action
    based on a volume open.

Arguments:

Return Value:

    NTSTATUS - The result of this operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    PVCB Vcb;
    PFCB ThisFcb;
    PCCB ThisCcb;

    BOOLEAN VcbAcquired = FALSE;

    BOOLEAN SharingViolation;
    BOOLEAN LockVolume = FALSE;
    BOOLEAN NotifyLockFailed = FALSE;
    BOOLEAN DelayFlush = FALSE;

    PAGED_CODE();

    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    DebugTrace( +1, Dbg, ("NtfsCommonVolumeOpen:  Entered\n") );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Start by checking the create disposition.  We can only open this
        //  file.
        //

        {
            ULONG CreateDisposition;

            CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

            if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {

                try_return( Status = STATUS_ACCESS_DENIED );
            }
        }

        //
        //  Make sure the directory flag isn't set for the volume open.
        //

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  If this volume open is going to generate an implicit volume lock
        //  (a la autochk), notify anyone who wants to close their handles so
        //  the lock can happen.  We need to do this before we acquire any resources.
        //

        if (!FlagOn( IrpSp->Parameters.Create.ShareAccess,
                     FILE_SHARE_WRITE | FILE_SHARE_DELETE )) {

            DebugTrace( 0, Dbg, ("Sending lock notification\n") );
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK );
            NotifyLockFailed = TRUE;
        }

        //
        //  Acquire the Vcb and verify the volume isn't locked.
        //

        Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;
        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_PERFORMED_DISMOUNT )) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  We do give READ-WRITE access to the volume even when
        //  it's actually write protected. This is just so that we won't break
        //  any apps. However, we don't let the user actually do any modifications.
        //

        // if ((NtfsIsVolumeReadOnly( Vcb )) &&
        //    (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
        //             FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE ))) {
        //
        //   try_return( Status = STATUS_MEDIA_WRITE_PROTECTED );
        //}

        //
        //  Ping the volume to make sure the Vcb is still mounted.  If we need
        //  to verify the volume then do it now, and if it comes out okay
        //  then clear the verify volume flag in the device object and continue
        //  on.  If it doesn't verify okay then dismount the volume and
        //  either tell the I/O system to try and create again (with a new mount)
        //  or that the volume is wrong. This later code is returned if we
        //  are trying to do a relative open and the vcb is no longer mounted.
        //

        if (!NtfsPingVolume( IrpContext, Vcb, NULL ) ||
            !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                //
                //  We need checkpoint sync to do a dismount which must 
                //  be acquired before the vcb - after dropping the vcb
                //  we must retest the volume
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                VcbAcquired = FALSE;
                NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );

                try {

                    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                    VcbAcquired = TRUE;

                    if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                        NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                        NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
                    }
                } finally {
                    NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
                }

            }

            //
            //  The volume verified correctly so now clear the verify bit
            //  and continue with the create
            //

            ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );
        }

        //
        //  Now acquire the Fcb for the VolumeDasd and verify the user has
        //  permission to open the volume.
        //

        ThisFcb = Vcb->VolumeDasdScb->Fcb;

        NtfsAcquireExclusiveFcb( IrpContext, ThisFcb, NULL, 0 );
        NtfsOpenCheck( IrpContext, ThisFcb, NULL, Irp );
        NtfsReleaseFcb( IrpContext, ThisFcb );

        //
        //  If the user does not want to share write or delete then we will try
        //  and take out a lock on the volume.
        //

        if (!FlagOn( IrpSp->Parameters.Create.ShareAccess,
                     FILE_SHARE_WRITE | FILE_SHARE_DELETE )) {

            //
            //  Do a quick test of the volume cleanup count if this opener won't
            //  share with anyone.  We can safely examine the cleanup count without
            //  further synchronization because we are guaranteed to have the
            //  Vcb exclusive at this point.
            //

#ifdef SYSCACHE_DEBUG
            if (!FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ ) &&
                ((Vcb->SyscacheScb && (Vcb->CleanupCount != 1)) ||
                 (!Vcb->SyscacheScb && (Vcb->CleanupCount != 0)))) {
#else
            if (!FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ ) &&
                (Vcb->CleanupCount != 0)) {
#endif

                try_return( Status = STATUS_SHARING_VIOLATION );

#ifdef SYSCACHE_DEBUG
            }
#else
            }
#endif

            //
            //  Go ahead and flush and purge the volume.  Then test to see if all
            //  of the user file objects were closed. This will release the dasd fcb
            //

            Status = NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, FALSE );

            //
            //  We don't care about certain errors in the flush path.
            //

            if (!NT_SUCCESS( Status )) {

                //
                //  If there are no conflicts but the status indicates disk corruption
                //  or a section that couldn't be removed then ignore the error.  We
                //  allow this open to succeed so that chkdsk can open the volume to
                //  repair the damage.
                //

                if ((Status == STATUS_UNABLE_TO_DELETE_SECTION) ||
                    (Status == STATUS_DISK_CORRUPT_ERROR) ||
                    (Status == STATUS_FILE_CORRUPT_ERROR)) {

                    Status = STATUS_SUCCESS;
                }
            }

            //
            //  If the flush and purge was successful but there are still file objects
            //  that block this open it is possible that the FspClose thread is
            //  blocked behind the Vcb.  Drop the Fcb and Vcb to allow this thread
            //  to get in and then reacquire them.  This will give this Dasd open
            //  another chance to succeed on the first try.
            //

            SharingViolation = FALSE;

            if (FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ)) {

                if (Vcb->ReadOnlyCloseCount != (Vcb->CloseCount - Vcb->SystemFileCloseCount)) {

                    SharingViolation = TRUE;
                }

            } else if (Vcb->CloseCount != Vcb->SystemFileCloseCount) {

                SharingViolation = TRUE;
            }

            if (SharingViolation && NT_SUCCESS( Status )) {

                //
                //  We need to commit the current transaction and release any
                //  resources.  This will release the Fcb for the volume as
                //  well.  Explicitly release the Vcb.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                    NtfsReleaseFcbWithPaging( IrpContext,
                                    (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                            FCB,
                                                            ExclusiveFcbLinks ));
                }

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                              IRP_CONTEXT_FLAG_RELEASE_MFT );

                NtfsReleaseVcb( IrpContext, Vcb );
                VcbAcquired = FALSE;

                CcWaitForCurrentLazyWriterActivity();

                //
                //  Now explicitly reacquire the Vcb.  Test that no one
                //  else got in to lock the volume in the meantime.
                //

                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                VcbAcquired = TRUE;

                if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_PERFORMED_DISMOUNT )) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                //
                //  Duplicate the flush/purge and test if there is no sharing
                //  violation. This will release the dasd fcb
                //

                Status = NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, FALSE );

                //
                //  We don't care about certain errors in the flush path.
                //

                if (!NT_SUCCESS( Status )) {

                    //
                    //  If there are no conflicts but the status indicates disk corruption
                    //  or a section that couldn't be removed then ignore the error.  We
                    //  allow this open to succeed so that chkdsk can open the volume to
                    //  repair the damage.
                    //

                    if ((Status == STATUS_UNABLE_TO_DELETE_SECTION) ||
                        (Status == STATUS_DISK_CORRUPT_ERROR) ||
                        (Status == STATUS_FILE_CORRUPT_ERROR)) {

                        Status = STATUS_SUCCESS;
                    }
                }

                SharingViolation = FALSE;

                if (FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ)) {

                    if (Vcb->ReadOnlyCloseCount != (Vcb->CloseCount - Vcb->SystemFileCloseCount)) {

                        SharingViolation = TRUE;
                    }

                } else if (Vcb->CloseCount != Vcb->SystemFileCloseCount) {

                    SharingViolation = TRUE;
                }
            }

            //
            //  Return an error if there are still conflicting file objects.
            //

            if (SharingViolation) {

                //
                //  If there was an error in the flush then return it.  Otherwise
                //  return SHARING_VIOLATION.
                //

                if (NT_SUCCESS( Status )) {

                    try_return( Status = STATUS_SHARING_VIOLATION );

                } else {

                    try_return( Status );
                }
            }

            if (!NT_SUCCESS( Status )) {

                //
                //  If there are no conflicts but the status indicates disk corruption
                //  or a section that couldn't be removed then ignore the error.  We
                //  allow this open to succeed so that chkdsk can open the volume to
                //  repair the damage.
                //

                if ((Status == STATUS_UNABLE_TO_DELETE_SECTION) ||
                    (Status == STATUS_DISK_CORRUPT_ERROR) ||
                    (Status == STATUS_FILE_CORRUPT_ERROR)) {

                    Status = STATUS_SUCCESS;

                //
                //  Fail this request on any other failures.
                //

                } else {

                    try_return( Status );
                }
            }

            //
            //  Remember that we want to lock the volume if the user plans to write.
            //  This is to allow autochk to fiddle with the volume.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                        FILE_WRITE_DATA | FILE_APPEND_DATA )) {

                LockVolume = TRUE;
            }

        //
        //  Just flush the volume data if the user requested read or write and the volume isn't
        //  readonly.  No need to purge or lock the volume.
        //

        } else if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                           FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA ) &&
                   !FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY )) {

            DelayFlush = TRUE;
        }

        //
        //  Put the Volume Dasd name in the file object. This is during the create / open path
        //  we're the only one with access to the fileobject
        //

        {
            PVOID Temp = FileObject->FileName.Buffer;

            FileObject->FileName.Buffer =
                FsRtlAllocatePoolWithTag(PagedPool, 8 * sizeof( WCHAR ), MODULE_POOL_TAG );

            if (Temp != NULL) {

                NtfsFreePool( Temp );
            }

            RtlCopyMemory( FileObject->FileName.Buffer, L"\\$Volume", 8 * sizeof( WCHAR ));
            FileObject->FileName.MaximumLength =
            FileObject->FileName.Length = 8*2;
        }

        //
        //  We never allow cached access to the volume file.
        //

        ClearFlag( FileObject->Flags, FO_CACHE_SUPPORTED );
        SetFlag( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );

        //
        //  Go ahead open the attribute.  This should only fail if there is an
        //  allocation failure or share access failure.
        //

        NtfsAcquireExclusiveFcb( IrpContext, ThisFcb, NULL, 0 );

        if (NT_SUCCESS( Status = NtfsOpenAttribute( IrpContext,
                                                    IrpSp,
                                                    Vcb,
                                                    NULL,
                                                    ThisFcb,
                                                    2,
                                                    NtfsEmptyString,
                                                    $DATA,
                                                    (ThisFcb->CleanupCount == 0 ?
                                                     SetShareAccess :
                                                     CheckShareAccess),
                                                    UserVolumeOpen,
                                                    FALSE,
                                                    CCB_FLAG_OPEN_AS_FILE,
                                                    NULL,
                                                    &Vcb->VolumeDasdScb,
                                                    &ThisCcb ))) {

            //
            //  Perform the final initialization.
            //

            //
            //  Check if we can administer the volume and note it in the ccb
            //

            //
            //  If the user was granted both read and write access then
            //  he can administer the volume.  This allows the interactive
            //  user to manage removable media if allowed by the access.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                        FILE_READ_DATA | FILE_WRITE_DATA ) == (FILE_READ_DATA | FILE_WRITE_DATA)) {

                SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );

            //
            //  We can also grant it through our ACL.
            //

            } else if (NtfsCanAdministerVolume( IrpContext, Irp, ThisFcb, NULL, NULL )) {

                SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );

            //
            //  We can also grant this through the MANAGE_VOLUME_PRIVILEGE.
            //

            } else {

                PRIVILEGE_SET PrivilegeSet;

                PrivilegeSet.PrivilegeCount = 1;
                PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
                PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid( SE_MANAGE_VOLUME_PRIVILEGE );
                PrivilegeSet.Privilege[0].Attributes = 0;

                if (SePrivilegeCheck( &PrivilegeSet,
                                      &IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext,
                                      NtfsEffectiveMode( Irp, IrpSp ))) {

                    SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );

                //
                //  Well nothing else worked.  Now we need to look at the security
                //  descriptor on the device.
                //

                } else {

                    NTSTATUS SeStatus;
                    BOOLEAN MemoryAllocated = FALSE;
                    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
                    ULONG RequestedAccess = FILE_READ_DATA | FILE_WRITE_DATA;

                    SeStatus = ObGetObjectSecurity( Vcb->Vpb->RealDevice,
                                                    &SecurityDescriptor,
                                                    &MemoryAllocated );

                    if (SeStatus == STATUS_SUCCESS) {

                        //
                        //  If there is a security descriptor then check the access.
                        //

                        if (SecurityDescriptor != NULL) {

                            if (NtfsCanAdministerVolume( IrpContext,
                                                         Irp,
                                                         ThisFcb,
                                                         SecurityDescriptor,
                                                         &RequestedAccess )) {

                                SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );
                            }

                            //
                            //  Free up the descriptor.
                            //

                            ObReleaseObjectSecurity( SecurityDescriptor,
                                                     MemoryAllocated );
                        }
                    }
                }
            }

            if (DelayFlush) {

                SetFlag( ThisCcb->Flags, CCB_FLAG_FLUSH_VOLUME_ON_IO );
            }

            //
            //  If we are locking the volume, do so now.
            //

            if (LockVolume) {

                SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
                Vcb->FileObjectWithVcbLocked = FileObject;

                //
                //  Looks like the lock succeeded, so we don't have to do the
                //  lock failed notification now.
                //

                NotifyLockFailed = FALSE;
            }

            //
            //  Report that we opened the volume.
            //

            Irp->IoStatus.Information = FILE_OPENED;
        }

    try_exit: NOTHING;

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  If we have a successful open then remove the name out of
        //  the file object.  The IO system gets confused when it
        //  is there.  We will deallocate the buffer with the Ccb
        //  when the handle is closed.
        //

        if (Status == STATUS_SUCCESS) {

            FileObject->FileName.Buffer = NULL;
            FileObject->FileName.MaximumLength =
            FileObject->FileName.Length = 0;

            SetFlag( ThisCcb->Flags, CCB_FLAG_ALLOCATED_FILE_NAME );
        }

    } finally {

        DebugUnwind( NtfsCommonVolumeOpen );

        if (VcbAcquired) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  Now that we aren't holding any resources, notify everyone
        //  who might want to reopen their handles. We want to do this
        //  before we complete the request because the FileObject might
        //  not exist beyond the life of the Irp.
        //

        if (NotifyLockFailed) {

            DebugTrace( 0, Dbg, ("Sending lock_failed notification\n") );
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonVolumeOpen:  Exit  ->  %08lx\n", Status) );
    }

    //
    //  If we have already done a PreCreate for this IRP (in FsdCreate),
    //  we should do the corresponding PostCreate before we complete the IRP. So,
    //  in that case, don't complete the IRP here -- just free the IrpContext.
    //  The IRP will be completed by the caller.
    //

    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE )) {
         NtfsCompleteRequest( IrpContext, NULL, Status );
    } else {
         NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Local support routine
//

VOID
NtfsUpdateAllInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN PSCB ParentScb OPTIONAL,
    IN PLCB Lcb OPTIONAL
    )

/*++

Routine Description:

    Reads on disk data for the fcb/scb as well as anything accumulated in the fileobject
    and updates the stdinfo / filesizes and duplicate info for all links.  If the dup
    info is updated all prev. work will be commited first.

Arguments:

    IrpContext -

    FileObject - the fileobject associated with the fcb and scb to update from

    Fcb - the fcb to be updated

    Scb -  the scb to be updated
    
    Ccb - The ccb for the file (used in updatedupinfo)
    
    ParentScb - optional parent to use on update
    
    Lcb  - optional lcb to use on update

Return Value:

    none

--*/

{
    PAGED_CODE();

    NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

    //
    //  Do the standard information, file sizes and then duplicate information
    //  if needed.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

        NtfsUpdateStandardInformation( IrpContext, Fcb );
    }

    if (FlagOn( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

        NtfsWriteFileSizes( IrpContext,
                            Scb,
                            &Scb->Header.ValidDataLength.QuadPart,
                            FALSE,
                            TRUE,
                            FALSE );
    }

    if (FlagOn( Fcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS ) &&
        !FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {
        
        NtfsUpdateDuplicateInfo( IrpContext, Fcb, Lcb, ParentScb );

        //
        //  Do dir notification if update came along a pathname
        //

        if (ARGUMENT_PRESENT( Lcb ) && (Fcb->Vcb->NotifyCount != 0)) {

            ULONG FilterMatch;

            ASSERT( ARGUMENT_PRESENT( ParentScb ) );
        
            //
            //  We map the Fcb info flags into the dir notify flags.
            //
        
            FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                    Fcb->InfoFlags | Lcb->InfoFlags );
        
            //
            //  If the filter match is non-zero, that means we also need to
            //  dir notify call.
            //
        
            if ((FilterMatch != 0) && (Ccb != NULL)) {
        
                NtfsReportDirNotify( IrpContext,
                                     Fcb->Vcb,
                                     &(Ccb)->FullFileName,
                                     (Ccb)->LastFileNameOffset,
                                     NULL,
                                     ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                       Ccb->Lcb != NULL &&
                                       Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0) ?
                                      &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                      NULL),
                                     FilterMatch,
                                     FILE_ACTION_MODIFIED,
                                     ParentScb->Fcb )
            }
        }
    
        NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );
        Fcb->InfoFlags = 0;

    }
    ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

    NtfsAcquireFsrtlHeader( Scb );
    ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
    NtfsReleaseFsrtlHeader( Scb );
}



//
//  Local support routine
//

NTSTATUS
NtfsOpenFcbById (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ParentLcb OPTIONAL,
    IN FILE_REFERENCE FileReference,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN PCREATE_CONTEXT CreateContext
    )

/*++

Routine Description:

    This routine is called to open a file by its file Id.  We need to
    verify that this file Id exists and then compare the type of the
    file with the requested type of open.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    Vcb - Vcb for this volume.

    ParentLcb - Lcb used to reach this Fcb.  Only specified when opening
        a file by name relative to a directory opened by file Id.

    FileReference - This is the file Id for the file to open.

    AttrName - This is the name of the attribute to open.

    AttrTypeCode - This is the attribute code to open.

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LONGLONG MftOffset;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PBCB Bcb = NULL;

    BOOLEAN IndexedAttribute;

    PFCB ThisFcb = NULL;
    BOOLEAN ExistingFcb = FALSE;

    ULONG CcbFlags = 0;
    ULONG Flags = 0;
    OLD_SCB_SNAPSHOT ScbSizes;
    BOOLEAN HaveScbSizes = FALSE;
    BOOLEAN DecrementCloseCount = FALSE;

    PSCB ParentScb = NULL;
    PLCB Lcb = ParentLcb;
    BOOLEAN AcquiredParentScb = FALSE;
    BOOLEAN AcquiredMft = FALSE;

    BOOLEAN AcquiredFcbTable = FALSE;
    UCHAR CreateDisposition = (UCHAR) ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenFcbById:  Entered\n") );

    //
    //  The next thing to do is to figure out what type
    //  of attribute the caller is trying to open.  This involves the
    //  directory/non-directory bits, the attribute name and code strings,
    //  the type of file, whether he passed in an ea buffer and whether
    //  there was a trailing backslash.
    //

    if (NtfsEqualMftRef( &FileReference,
                         &VolumeFileReference )) {

        if ((AttrName.Length != 0) ||
            FlagOn( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE)) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsOpenFcbById:  Exit  ->  %08lx\n", Status) );

            return Status;
        }

        SetFlag( IrpContext->State,
                 IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we don't already have the Fcb then look up the file record
        //  from the disk.
        //

        if (CreateContext->CurrentFcb == NULL) {

            //
            //  We start by reading the disk and checking that the file record
            //  sequence number matches and that the file record is in use.
            //  We remember whether this is a directory.  We will only go to
            //  the file if the file Id will lie within the Mft File.
            //

            MftOffset = NtfsFullSegmentNumber( &FileReference );

            MftOffset = Int64ShllMod32(MftOffset, Vcb->MftShift);

            //
            //  Make sure we are serialized with access to the Mft.  Otherwise
            //  someone else could be deleting the file as we speak.
            //

            NtfsAcquireSharedFcb( IrpContext, Vcb->MftScb->Fcb, NULL, 0 );
            AcquiredMft = TRUE;

            if (MftOffset >= Vcb->MftScb->Header.FileSize.QuadPart) {

                DebugTrace( 0, Dbg, ("File Id doesn't lie within Mft\n") );

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            NtfsReadMftRecord( IrpContext,
                               Vcb,
                               &FileReference,
                               FALSE,
                               &Bcb,
                               &FileRecord,
                               NULL );

            //
            //  This file record better be in use, have a matching sequence number and
            //  be the primary file record for this file.
            //

            if ((FileRecord->SequenceNumber != FileReference.SequenceNumber) ||
                !FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) ||
                (*((PLONGLONG) &FileRecord->BaseFileRecordSegment) != 0) ||
                (*((PULONG) FileRecord->MultiSectorHeader.Signature) != *((PULONG) FileSignature))) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            //
            //  If indexed then use the name for the file name index.
            //

            if (FlagOn( FileRecord->Flags, FILE_FILE_NAME_INDEX_PRESENT )) {

                AttrName = NtfsFileNameIndex;
                AttrTypeCode = $INDEX_ALLOCATION;
                SetFlag( Flags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE );
            }

            NtfsUnpinBcb( IrpContext, &Bcb );

        } else {

            ThisFcb = CreateContext->CurrentFcb;
            ExistingFcb = TRUE;
        }

        Status = NtfsCheckValidAttributeAccess( IrpContext,
                                                IrpSp,
                                                Vcb,
                                                ExistingFcb ? &ThisFcb->Info : NULL,
                                                &AttrName,
                                                &AttrTypeCode,
                                                Flags,
                                                &CcbFlags,
                                                &IndexedAttribute );

        if (!NT_SUCCESS( Status )) {

            leave;
        }

        //
        //  If we don't have an Fcb then create one now.
        //

        if (CreateContext->CurrentFcb == NULL) {

            NtfsAcquireFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = TRUE;

            //
            //  We know that it is safe to continue the open.  We start by creating
            //  an Fcb for this file.  It is possible that the Fcb exists.
            //  We create the Fcb first, if we need to update the Fcb info structure
            //  we copy the one from the index entry.  We look at the Fcb to discover
            //  if it has any links, if it does then we make this the last Fcb we
            //  reached.  If it doesn't then we have to clean it up from here.
            //

            ThisFcb = NtfsCreateFcb( IrpContext,
                                     Vcb,
                                     FileReference,
                                     BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ),
                                     TRUE,
                                     &ExistingFcb );

            ThisFcb->ReferenceCount += 1;

            //
            //  Try to do a fast acquire, otherwise we need to release
            //  the Fcb table, acquire the Fcb, acquire the Fcb table to
            //  dereference Fcb.  This should only be the case if the Fcb already
            //  existed.  In that case all of the flags indicating whether it
            //  has been deleted will be valid when we reacquire it.  We don't
            //  have to worry about Mft synchronization.
            //

            if (!NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT )) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
                NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
                AcquiredMft = FALSE;
                NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
                NtfsAcquireFcbTable( IrpContext, Vcb );

            } else {

                NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
                AcquiredMft = FALSE;
            }

            ThisFcb->ReferenceCount -= 1;

            NtfsReleaseFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = FALSE;

            //
            //  Store this Fcb into our caller's parameter and remember to
            //  to show we acquired it.
            //

            CreateContext->CurrentFcb = ThisFcb;
        }

        //
        //  We perform a check to see whether we will allow the system
        //  files to be opened.
        //
        //  No test to make if this is not a system file or it is the VolumeDasd file.
        //  The ACL will protect the volume file.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
            (NtfsSegmentNumber( &ThisFcb->FileReference ) != VOLUME_DASD_NUMBER) &&
            NtfsProtectSystemFiles) {

            if (!NtfsCheckValidFileAccess( ThisFcb, IrpSp )) {
                Status = STATUS_ACCESS_DENIED;
                DebugTrace( 0, Dbg, ("Invalid access to system files\n") );
                leave;
            }
        }

        //
        //  If the Fcb existed and this is a paging file then either return
        //  sharing violation or force the Fcb and Scb's to go away.
        //  Do this for the case where the user is opening a paging file
        //  but the Fcb is non-paged or the user is opening a non-paging
        //  file and the Fcb is for a paging file.
        //

        if (ExistingFcb &&

            ((FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
              !FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) ||

             (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
              !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )))) {

            if (ThisFcb->CleanupCount != 0) {

                Status = STATUS_SHARING_VIOLATION;
                leave;

            //
            //  If we have a persistent paging file then give up and
            //  return SHARING_VIOLATION.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                Status = STATUS_SHARING_VIOLATION;
                leave;

            //
            //  If there was an existing Fcb for a paging file we need to force
            //  all of the Scb's to be torn down.  The easiest way to do this
            //  is to flush and purge all of the Scb's (saving any attribute list
            //  for last) and then raise LOG_FILE_FULL to allow this request to
            //  be posted.
            //

            } else {

                //
                //  Reference the Fcb so it doesn't go away.
                //

                InterlockedIncrement( &ThisFcb->CloseCount );
                DecrementCloseCount = TRUE;

                //
                //  Flush and purge this Fcb.
                //

                NtfsFlushAndPurgeFcb( IrpContext, ThisFcb );

                InterlockedDecrement( &ThisFcb->CloseCount );
                DecrementCloseCount = FALSE;

                //
                //  Force this request to be posted and then raise
                //  CANT_WAIT.
                //

                NtfsRaiseToPost( IrpContext );
            }
        }

        //
        //  If the Fcb Info field needs to be initialized, we do so now.
        //  We read this information from the disk.
        //

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            HaveScbSizes = NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                      TRUE,
                                                      ThisFcb,
                                                      &ScbSizes );

            //
            //  Fix the quota for this file if necessary.
            //

            NtfsConditionallyFixupQuota( IrpContext, ThisFcb );

        }

        //
        //  Now that we have the dup info off disk recheck the create options
        //

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE ) &&
            !IsViewIndex( &ThisFcb->Info ) &&
            !IsDirectory( &ThisFcb->Info )) {

            NtfsRaiseStatus( IrpContext, STATUS_NOT_A_DIRECTORY, NULL, NULL );
        }

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE ) &&
            (IsViewIndex( &ThisFcb->Info ) || IsDirectory( &ThisFcb->Info ))) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_IS_A_DIRECTORY, NULL, NULL );
        }

        //
        //  If the link count is zero on this Fcb, then delete is pending.  Otherwise
        //  this might be an unused system file.
        //

        if (ThisFcb->LinkCount == 0) {

            if (NtfsSegmentNumber( &ThisFcb->FileReference ) >= FIRST_USER_FILE_NUMBER) {

                Status = STATUS_DELETE_PENDING;
                leave;

            } else {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
        }

        //
        //  We now call the worker routine to open an attribute on an existing file.
        //

        Status = NtfsOpenAttributeInExistingFile( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  ParentLcb,
                                                  ThisFcb,
                                                  0,
                                                  AttrName,
                                                  AttrTypeCode,
                                                  CcbFlags,
                                                  CREATE_FLAG_OPEN_BY_ID,
                                                  NULL,
                                                  &CreateContext->ThisScb,
                                                  &CreateContext->ThisCcb );

        //
        //  Check to see if we should update the last access time.
        //  We skip this for reparse points as *ThisScb and *ThisCcb may be NULL.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_WAIT_FOR_OPLOCK) &&
            (Status != STATUS_REPARSE)) {

            PSCB Scb = CreateContext->ThisScb;

            //
            //  Now look at whether we need to update the Fcb and on disk
            //  structures.
            //

            if (NtfsCheckLastAccess( IrpContext, ThisFcb )) {

                SetFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
            }

            //
            //  Perform the last bit of work.  If this a user file open, we need
            //  to check if we initialize the Scb.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    //
                    //  We may have the sizes from our Fcb update call.
                    //

                    if (HaveScbSizes &&
                        (AttrTypeCode == $DATA) &&
                        (AttrName.Length == 0) &&
                        !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB )) {

                        NtfsUpdateScbFromMemory( Scb, &ScbSizes );

                    } else {

                        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                    }
                }

                //
                //  Let's check if we need to set the cache bit.
                //

                if (!FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }
            }

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.  We do not do
            //  this for network opens or reparse points.  We have to pass
            //  FILE_EXISTING since we have no parent directory and the
            //  encryption callback needs a parent directory to handle a
            //  new file create.
            //

            if (CreateContext->NetworkInfo == NULL) {

                NtfsEncryptionCreateCallback( IrpContext,
                                              Irp,
                                              IrpSp,
                                              CreateContext->ThisScb,
                                              CreateContext->ThisCcb,
                                              NULL,
                                              CreateContext,
                                              FALSE );
            }

            //
            //  If this operation was a supersede/overwrite or we created a new
            //  attribute stream then we want to perform the file record and
            //  directory update now.  Otherwise we will defer the updates until
            //  the user closes his handle.
            //

            if (NtfsIsStreamNew(Irp->IoStatus.Information)) {
                NtfsUpdateAllInformation( IrpContext, IrpSp->FileObject, ThisFcb, CreateContext->ThisScb, NULL, NULL, NULL );
            }
        }

    } finally {

        DebugUnwind( NtfsOpenFcbById );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        if (AcquiredMft) {

            NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
        }

        //
        //  If this operation was not totally successful we need to
        //  back out the following changes.
        //
        //      Modifications to the Info fields in the Fcb.
        //      Any changes to the allocation of the Scb.
        //      Any changes in the open counts in the various structures.
        //      Changes to the share access values in the Fcb.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    ThisFcb,
                                    CreateContext->ThisScb,
                                    CreateContext->ThisCcb );
        }

        if (DecrementCloseCount) {

            InterlockedDecrement( &ThisFcb->CloseCount );
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        DebugTrace( -1, Dbg, ("NtfsOpenFcbById:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenExistingPrefixFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB Lcb OPTIONAL,
    IN ULONG FullPathNameLength,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN PCREATE_CONTEXT CreateContext
    )

/*++

Routine Description:

    This routine will open an attribute in a file whose Fcb was found
    with a prefix search.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    Lcb - This is the Lcb used to reach this Fcb.  Not specified if this is a volume open.

    FullPathNameLength - This is the length of the full path name.

    AttrName - This is the name of the attribute to open.

    AttrCode - This is the attribute type to open.

    CreateFlags - Flags for create operation - we care about the dos only component and trailing back slash
        flag

    CreateContext - Context with create variables.

Return Value:

    NTSTATUS - Indicates the result of this attribute based operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CcbFlags;
    BOOLEAN IndexedAttribute;
    BOOLEAN DecrementCloseCount = FALSE;

    ULONG LastFileNameOffset;

    OLD_SCB_SNAPSHOT ScbSizes;
    BOOLEAN HaveScbSizes = FALSE;

    ULONG CreateDisposition;

    PSCB ParentScb = NULL;
    PFCB ParentFcb = NULL;
    BOOLEAN AcquiredParentScb = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenExistingPrefixFcb:  Entered\n") );


    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        CcbFlags = CCB_FLAG_PARENT_HAS_DOS_COMPONENT;

    } else {

        CcbFlags = 0;
    }

    //
    //  The first thing to do is to figure out what type
    //  of attribute the caller is trying to open.  This involves the
    //  directory/non-directory bits, the attribute name and code strings,
    //  the type of file, whether he passed in an ea buffer and whether
    //  there was a trailing backslash.
    //

    if (NtfsEqualMftRef( &CreateContext->CurrentFcb->FileReference, &VolumeFileReference )) {

        if ((AttrName.Length != 0) ||
            (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE ))) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsOpenExistingPrefixFcb:  Exit  ->  %08lx\n", Status) );

            return Status;
        }

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    ParentScb = Lcb->Scb;

    LastFileNameOffset = FullPathNameLength - Lcb->ExactCaseLink.LinkName.Length;

    if (ParentScb != NULL) {

        ParentFcb = ParentScb->Fcb;
    }

    Status = NtfsCheckValidAttributeAccess( IrpContext,
                                            IrpSp,
                                            CreateContext->CurrentFcb->Vcb,
                                            &CreateContext->CurrentFcb->Info,
                                            &AttrName,
                                            &AttrTypeCode,
                                            CreateContext->CreateFlags,
                                            &CcbFlags,
                                            &IndexedAttribute );

    if (!NT_SUCCESS( Status )) {

        DebugTrace( -1, Dbg, ("NtfsOpenExistingPrefixFcb:  Exit  ->  %08lx\n", Status) );

        return Status;
    }

    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the Fcb existed and this is a paging file then either return
        //  sharing violation or force the Fcb and Scb's to go away.
        //  Do this for the case where the user is opening a paging file
        //  but the Fcb is non-paged or the user is opening a non-paging
        //  file and the Fcb is for a paging file.
        //

        if ((FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
             !FlagOn( CreateContext->CurrentFcb->FcbState, FCB_STATE_PAGING_FILE )) ||

            (FlagOn( CreateContext->CurrentFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
             !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ))) {

            if (CreateContext->CurrentFcb->CleanupCount != 0) {

                Status = STATUS_SHARING_VIOLATION;
                leave;

            //
            //  If we have a persistent paging file then give up and
            //  return SHARING_VIOLATION.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                Status = STATUS_SHARING_VIOLATION;
                leave;

            //
            //  If there was an existing Fcb for a paging file we need to force
            //  all of the Scb's to be torn down.  The easiest way to do this
            //  is to flush and purge all of the Scb's (saving any attribute list
            //  for last) and then raise LOG_FILE_FULL to allow this request to
            //  be posted.
            //

            } else {

                //
                //  Make sure this Fcb won't go away as a result of purging
                //  the Fcb.
                //

                InterlockedIncrement( &CreateContext->CurrentFcb->CloseCount );
                DecrementCloseCount = TRUE;

                //
                //  Flush and purge this Fcb.
                //

                NtfsFlushAndPurgeFcb( IrpContext, CreateContext->CurrentFcb );

                //
                //  Now decrement the close count we have already biased.
                //

                InterlockedDecrement( &CreateContext->CurrentFcb->CloseCount );
                DecrementCloseCount = FALSE;

                NtfsRaiseToPost( IrpContext );
            }
        }

        //
        //  This file might have been recently created, and we might have dropped the
        //  Fcb to call the PostCreate encryption callout, so the encryption driver
        //  hasn't yet called us back to set the encryption bit on the file.  If we're
        //  asked to open the file in this window, we would introduce corruption by
        //  writing plaintext now.  Let's just raise cant_wait and try again later.
        //

        if (FlagOn( CreateContext->CurrentFcb->FcbState, FCB_STATE_ENCRYPTION_PENDING )) {

#ifdef KEITHKA
            EncryptionPendingCount += 1;
#endif

            //
            //  Raise CANT_WAIT so we can wait on the encryption event at the top.
            //

            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ENCRYPTION_RETRY );

            //
            //  Clear the pending event so we can wait for it when we retry.
            //

            KeClearEvent( &NtfsEncryptionPendingEvent );
            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If this is a directory, it's possible that we hav an existing Fcb
        //  in the prefix table which needs to be initialized from the disk.
        //  We look in the InfoInitialized flag to know whether to go to
        //  disk.
        //

        if (!FlagOn( CreateContext->CurrentFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            //
            //  If we have a parent Fcb then make sure to acquire it.
            //

            if (ParentScb != NULL) {

                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                AcquiredParentScb = TRUE;
            }

            HaveScbSizes = NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                      TRUE,
                                                      CreateContext->CurrentFcb,
                                                      &ScbSizes );

            NtfsConditionallyFixupQuota( IrpContext, CreateContext->CurrentFcb );
        }

        //
        //  Check now whether we will need to acquire the parent to
        //  perform a update duplicate info.  We need to acquire it
        //  now to enforce our locking order in case any of the
        //  routines below acquire the Mft Scb.  Acquire it if we
        //  are doing a supersede/overwrite or possibly creating
        //  a named data stream.
        //

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF) ||
            ((AttrName.Length != 0) &&
             ((CreateDisposition == FILE_OPEN_IF) ||
              (CreateDisposition == FILE_CREATE)))) {

            NtfsPrepareForUpdateDuplicate( IrpContext,
                                           CreateContext->CurrentFcb,
                                           &Lcb,
                                           &ParentScb,
                                           FALSE );
        }

        //
        //  Call to open an attribute on an existing file.
        //  Remember we need to restore the Fcb info structure
        //  on errors.
        //

        Status = NtfsOpenAttributeInExistingFile( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  Lcb,
                                                  CreateContext->CurrentFcb,
                                                  LastFileNameOffset,
                                                  AttrName,
                                                  AttrTypeCode,
                                                  CcbFlags,
                                                  CreateContext->CreateFlags,
                                                  CreateContext->NetworkInfo,
                                                  &CreateContext->ThisScb,
                                                  &CreateContext->ThisCcb );

        //
        //  Check to see if we should update the last access time.
        //  We skip this for reparse points as *ThisScb and *ThisCcb may be NULL.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_WAIT_FOR_OPLOCK) &&
            (Status != STATUS_REPARSE)) {

            PSCB Scb = CreateContext->ThisScb;

            //
            //  This is a rare case.  There must have been an allocation failure
            //  to cause this but make sure the normalized name is stored.
            //

            if ((SafeNodeType( Scb ) == NTFS_NTC_SCB_INDEX) &&
                (Scb->ScbType.Index.NormalizedName.Length == 0)) {

                //
                //  We may be able to use the parent.
                //

                if ((ParentScb != NULL) &&
                    (ParentScb->ScbType.Index.NormalizedName.Length != 0)) {

                    NtfsUpdateNormalizedName( IrpContext,
                                              ParentScb,
                                              Scb,
                                              NULL,
                                              FALSE,
                                              FALSE );

                } else {

                    NtfsBuildNormalizedName( IrpContext,
                                             Scb->Fcb,
                                             Scb,
                                             &Scb->ScbType.Index.NormalizedName );
                }
            }

            //
            //  Perform the last bit of work.  If this a user file open, we need
            //  to check if we initialize the Scb.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    //
                    //  We may have the sizes from our Fcb update call.
                    //

                    if (HaveScbSizes &&
                        (AttrTypeCode == $DATA) &&
                        (AttrName.Length == 0) &&
                        !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB )) {

                        NtfsUpdateScbFromMemory( Scb, &ScbSizes );

                    } else {

                        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                    }
                }

                //
                //  Let's check if we need to set the cache bit.
                //

                if (!FlagOn( IrpSp->Parameters.Create.Options,
                             FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }
            }

            //
            //  If this is the paging file, we want to be sure the allocation
            //  is loaded.
            //

            if (FlagOn( CreateContext->CurrentFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                (Scb->Header.AllocationSize.QuadPart != 0) &&
                !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                LCN Lcn;
                VCN Vcn;
                VCN AllocatedVcns;

                AllocatedVcns = Int64ShraMod32(Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift);

                //
                //  First make sure the Mcb is loaded.
                //

                NtfsPreloadAllocation( IrpContext, Scb, 0, AllocatedVcns );

                //
                //  Now make sure the allocation is correctly loaded.  The last
                //  Vcn should correspond to the allocation size for the file.
                //

                if (!NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                 &Vcn,
                                                 &Lcn ) ||
                    (Vcn + 1) != AllocatedVcns) {

                    NtfsRaiseStatus( IrpContext,
                                     STATUS_FILE_CORRUPT_ERROR,
                                     NULL,
                                     CreateContext->CurrentFcb );
                }
            }

            //
            //  If this open is for an executable image we will want to update the
            //  last access time.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess, FILE_EXECUTE ) &&
                (Scb->AttributeTypeCode == $DATA)) {

                SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );
            }

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.  We do not do
            //  this for network opens or reparse points.
            //

            if (CreateContext->NetworkInfo == NULL) {

                NtfsEncryptionCreateCallback( IrpContext,
                                              Irp,
                                              IrpSp,
                                              CreateContext->ThisScb,
                                              CreateContext->ThisCcb,
                                              ParentFcb,
                                              CreateContext,
                                              FALSE );
            }

            //
            //  Check if should insert the hash entry.
            //

            if ((CreateContext->FileHashLength != 0) &&
                !FlagOn( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                (Lcb->FileNameAttr->Flags != FILE_NAME_DOS) ) {

                //
                //  Remove any exising hash value.
                //

                if (FlagOn( Lcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                    NtfsRemoveHashEntriesForLcb( Lcb );
#ifdef NTFS_HASH_DATA
                    CreateContext->CurrentFcb->Vcb->HashTable.OpenExistingConflict += 1;
#endif
                }

                NtfsInsertHashEntry( &CreateContext->CurrentFcb->Vcb->HashTable,
                                     Lcb,
                                     CreateContext->FileHashLength,
                                     CreateContext->FileHashValue );
#ifdef NTFS_HASH_DATA
                CreateContext->CurrentFcb->Vcb->HashTable.OpenExistingInsert += 1;
#endif
            }

            //
            //  If this operation was a supersede/overwrite or we created a new
            //  attribute stream then we want to perform the file record and
            //  directory update now.  Otherwise we will defer the updates until
            //  the user closes his handle.
            //

            if (NtfsIsStreamNew( Irp->IoStatus.Information )) {
                NtfsUpdateAllInformation( IrpContext, IrpSp->FileObject, CreateContext->CurrentFcb, CreateContext->ThisScb, CreateContext->ThisCcb, ParentScb, Lcb );
            }
        }

    } finally {

        DebugUnwind( NtfsOpenExistingPrefixFcb );

        if (DecrementCloseCount) {

            InterlockedDecrement( &CreateContext->CurrentFcb->CloseCount );
        }

        //
        //  If this operation was not totally successful we need to
        //  back out the following changes.
        //
        //      Modifications to the Info fields in the Fcb.
        //      Any changes to the allocation of the Scb.
        //      Any changes in the open counts in the various structures.
        //      Changes to the share access values in the Fcb.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    CreateContext->CurrentFcb,
                                    CreateContext->ThisScb,
                                    CreateContext->ThisCcb );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenExistingPrefixFcb:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenTargetDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PLCB ParentLcb OPTIONAL,
    IN OUT PUNICODE_STRING FullPathName,
    IN ULONG FinalNameLength,
    IN PCREATE_CONTEXT CreateContext
    )

/*++

Routine Description:

    This routine will perform the work of opening a target directory.  When the
    open is complete the Ccb and Lcb for this file object will be identical
    to any other open.  We store the full name for the rename in the
    file object but set the 'Length' field to include only the
    name upto the parent directory.  We use the 'MaximumLength' field to
    indicate the full name.

Arguments:

    Irp - This is the Irp for this create operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ThisFcb - This is the Fcb for the directory to open.

    ParentLcb - This is the Lcb used to reach the parent directory.  If not
        specified, we will have to find it here.  There will be no Lcb to
        find if this Fcb was opened by Id.

    FullPathName - This is the normalized string for open operation.  It now
        contains the full name as it appears on the disk for this open path.
        It may not reach all the way to the root if the relative file object
        was opened by Id.

    FinalNameLength - This is the length of the final component in the
        full path name.

    CreateFlags - Flags for create operation - we care about the dos only component flag

Return Value:

    NTSTATUS - Indicating the outcome of opening this target directory.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CcbFlags = CCB_FLAG_OPEN_AS_FILE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenTargetDirectory:  Entered\n") );

    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        SetFlag( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT );
    }

    //
    //  If the name doesn't begin with a backslash, remember this as
    //  an open by file ID.
    //

    if (FullPathName->Buffer[0] != L'\\') {

        SetFlag( CcbFlags, CCB_FLAG_OPEN_BY_FILE_ID );
    }

    //
    //  Modify the full path name so that the Maximum length field describes
    //  the full name and the Length field describes the name for the
    //  parent.
    //

    FullPathName->MaximumLength = FullPathName->Length;

    //
    //  If we don't have an Lcb, we will find it now.  We look at each Lcb
    //  for the parent Fcb and find one which matches the component
    //  ahead of the last component of the full name.
    //

    FullPathName->Length -= (USHORT)FinalNameLength;

    //
    //  If we are not at the root then subtract the bytes for the '\\'
    //  separator.
    //

    if (FullPathName->Length > sizeof( WCHAR )) {

        FullPathName->Length -= sizeof( WCHAR );
    }

    if (!ARGUMENT_PRESENT( ParentLcb ) && (FullPathName->Length != 0)) {

        PLIST_ENTRY Links;
        PLCB NextLcb;

        //
        //  If the length is two then the parent Lcb is the root Lcb.
        //

        if (FullPathName->Length == sizeof( WCHAR )
            && FullPathName->Buffer[0] == L'\\') {

            ParentLcb = (PLCB) ThisFcb->Vcb->RootLcb;

        } else {

            for (Links = ThisFcb->LcbQueue.Flink;
                 Links != &ThisFcb->LcbQueue;
                 Links = Links->Flink) {

                SHORT NameOffset;

                NextLcb = CONTAINING_RECORD( Links,
                                             LCB,
                                             FcbLinks );

                NameOffset = (SHORT) FullPathName->Length - (SHORT) NextLcb->ExactCaseLink.LinkName.Length;

                if (NameOffset >= 0) {

                    if (RtlEqualMemory( Add2Ptr( FullPathName->Buffer,
                                                 NameOffset ),
                                        NextLcb->ExactCaseLink.LinkName.Buffer,
                                        NextLcb->ExactCaseLink.LinkName.Length )) {

                        //
                        //  We found a matching Lcb.  Remember this and exit
                        //  the loop.
                        //

                        ParentLcb = NextLcb;
                        break;
                    }
                }
            }
        }
    }

    //
    //  Check this open for security access.
    //

    NtfsOpenCheck( IrpContext, ThisFcb, NULL, Irp );

    //
    //  Now actually open the attribute.
    //

    Status = NtfsOpenAttribute( IrpContext,
                                IrpSp,
                                ThisFcb->Vcb,
                                ParentLcb,
                                ThisFcb,
                                (ARGUMENT_PRESENT( ParentLcb )
                                 ? FullPathName->Length - ParentLcb->ExactCaseLink.LinkName.Length
                                 : 0),
                                NtfsFileNameIndex,
                                $INDEX_ALLOCATION,
                                (ThisFcb->CleanupCount == 0 ? SetShareAccess : CheckShareAccess),
                                UserDirectoryOpen,
                                FALSE,
                                CcbFlags,
                                NULL,
                                &CreateContext->ThisScb,
                                &CreateContext->ThisCcb );

    if (NT_SUCCESS( Status )) {

        //
        //  If the Scb does not have a normalized name then update it now.
        //

        if (CreateContext->ThisScb->ScbType.Index.NormalizedName.Length == 0) {

            NtfsBuildNormalizedName( IrpContext,
                                     CreateContext->ThisScb->Fcb,
                                     CreateContext->ThisScb,
                                     &CreateContext->ThisScb->ScbType.Index.NormalizedName );
        }

        //
        //  If the file object name is not from the root then use the normalized name
        //  to obtain the full name.
        //

        if (FlagOn( CcbFlags, CCB_FLAG_OPEN_BY_FILE_ID )) {

            USHORT BytesNeeded;
            USHORT Index;
            ULONG ComponentCount;
            ULONG NormalizedComponentCount;
            PWCHAR NewBuffer;
            PWCHAR NextChar;

            //
            //  Count the number of components in the directory portion of the
            //  name in the file object.
            //

            ComponentCount = 0;

            if (FullPathName->Length != 0) {

                ComponentCount = 1;
                Index = (FullPathName->Length / sizeof( WCHAR )) - 1;

                do {

                    if (FullPathName->Buffer[Index] == L'\\') {

                        ComponentCount += 1;
                    }

                    Index -= 1;

                } while (Index != 0);
            }

            //
            //  Count back this number of components in the normalized name.
            //

            NormalizedComponentCount = 0;
            Index = CreateContext->ThisScb->ScbType.Index.NormalizedName.Length / sizeof( WCHAR );

            //
            //  Special case the root to point directory to the leading backslash.
            //

            if (Index == 1) {

                Index = 0;
            }

            while (NormalizedComponentCount < ComponentCount) {

                Index -= 1;
                while (CreateContext->ThisScb->ScbType.Index.NormalizedName.Buffer[Index] != L'\\') {

                    Index -= 1;
                }

                NormalizedComponentCount += 1;
            }

            //
            //  Compute the size of the buffer needed for the full name.  This
            //  will be:
            //
            //      - Portion of normalized name used plus a separator
            //      - MaximumLength currently in FullPathName
            //

            BytesNeeded = (Index + 1) * sizeof( WCHAR );

            if (MAXUSHORT - FullPathName->MaximumLength < BytesNeeded) {

                NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
            }

            BytesNeeded += FullPathName->MaximumLength;

            NextChar =
            NewBuffer = NtfsAllocatePool( PagedPool, BytesNeeded );

            //
            //  Copy over the portion of the name from the normalized name.
            //

            if (Index != 0) {

                RtlCopyMemory( NextChar,
                               CreateContext->ThisScb->ScbType.Index.NormalizedName.Buffer,
                               Index * sizeof( WCHAR ));

                NextChar += Index;
            }

            *NextChar = L'\\';
            NextChar += 1;

            //
            //  Now copy over the remaining part of the name from the file object.
            //

            RtlCopyMemory( NextChar,
                           FullPathName->Buffer,
                           FullPathName->MaximumLength );

            //
            //  Now free the pool from the file object and update with the newly
            //  allocated pool.  Don't forget to update the Ccb to point to this new
            //  buffer.
            //

            NtfsFreePool( FullPathName->Buffer );

            FullPathName->Buffer = NewBuffer;
            FullPathName->MaximumLength =
            FullPathName->Length = BytesNeeded;
            FullPathName->Length -= (USHORT) FinalNameLength;

            if (FullPathName->Length > sizeof( WCHAR )) {

                FullPathName->Length -= sizeof( WCHAR );
            }

            CreateContext->ThisCcb->FullFileName = *FullPathName;
            CreateContext->ThisCcb->LastFileNameOffset = FullPathName->MaximumLength - (USHORT) FinalNameLength;
        }

        Irp->IoStatus.Information = (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_FOUND_ENTRY ) ? FILE_EXISTS : FILE_DOES_NOT_EXIST);
    }

    DebugTrace( -1, Dbg, ("NtfsOpenTargetDirectory:  Exit -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PINDEX_ENTRY IndexEntry,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN PQUICK_INDEX QuickIndex,
    IN PCREATE_CONTEXT CreateContext,
    OUT PLCB *LcbForTeardown
    )

/*++

Routine Description:

    This routine is called when we need to open an attribute on a file
    which currently exists.  We have the ParentScb and the file reference
    for the existing file.  We will create the Fcb for this file and the
    link between it and its parent directory.  We will add this link to the
    prefix table as well as the link for its parent Scb if specified.

    On entry the caller owns the parent Scb.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ParentScb - This is the Scb for the parent directory.

    IndexEntry - This is the index entry from the disk for this file.

    FullPathName - This is the string containing the full path name of
        this Fcb.  Meaningless for an open by Id call.

    FinalName - This is the string for the final component only.  If the length
        is zero then this is an open by Id call.

    AttrName - This is the name of the attribute to open.

    AttriCodeName - This is the name of the attribute code to open.

    CreateFlags - Flags for create option - we use open by id / ignore case / trailing backslash and
        dos only component

    CreateContext - Context with create variables.

    LcbForTeardown - This is the Lcb to use in teardown if we add an Lcb
        into the tree.

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CcbFlags = 0;
    PFILE_NAME IndexFileName;

    OLD_SCB_SNAPSHOT ScbSizes;

    PVCB Vcb = ParentScb->Vcb;

    PFCB LocalFcbForTeardown = NULL;
    PFCB ThisFcb;
    PLCB ThisLcb;

    FILE_REFERENCE PreviousFileReference;

    BOOLEAN IndexedAttribute;
    BOOLEAN DecrementCloseCount = FALSE;
    BOOLEAN ExistingFcb;
    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN UpdateFcbInfo = FALSE;
    BOOLEAN DroppedParent = FALSE;
    BOOLEAN HaveScbSizes = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenFile:  Entered\n") );

    IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        SetFlag( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT );
    }

    //
    //  The first thing to do is to figure out what type
    //  of attribute the caller is trying to open.  This involves the
    //  directory/non-directory bits, the attribute name and code strings,
    //  the type of file, whether he passed in an ea buffer and whether
    //  there was a trailing backslash.
    //

    if (NtfsEqualMftRef( &IndexEntry->FileReference,
                         &VolumeFileReference )) {

        if ((AttrName.Length != 0) ||
            FlagOn( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE )) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsOpenFile:  Exit  ->  %08lx\n", Status) );

            return Status;
        }

        SetFlag( IrpContext->State,
                 IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    Status = NtfsCheckValidAttributeAccess( IrpContext,
                                            IrpSp,
                                            Vcb,
                                            &IndexFileName->Info,
                                            &AttrName,
                                            &AttrTypeCode,
                                            CreateContext->CreateFlags,
                                            &CcbFlags,
                                            &IndexedAttribute );

    if (!NT_SUCCESS( Status )) {

        DebugTrace( -1, Dbg, ("NtfsOpenFile:  Exit  ->  %08lx\n", Status) );

        return Status;
    }

    NtfsAcquireFcbTable( IrpContext, Vcb );
    AcquiredFcbTable = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We know that it is safe to continue the open.  We start by creating
        //  an Fcb and Lcb for this file.  It is possible that the Fcb and Lcb
        //  both exist.  If the Lcb exists, then the Fcb must definitely exist.
        //  We create the Fcb first, if we need to update the Fcb info structure
        //  we copy the one from the index entry.  We look at the Fcb to discover
        //  if it has any links, if it does then we make this the last Fcb we
        //  reached.  If it doesn't then we have to clean it up from here.
        //

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 ParentScb->Vcb,
                                 IndexEntry->FileReference,
                                 BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ),
                                 BooleanFlagOn( IndexFileName->Info.FileAttributes,
                                                DUP_FILE_NAME_INDEX_PRESENT ),
                                 &ExistingFcb );

        ThisFcb->ReferenceCount += 1;

        //
        //  If we created this Fcb we must make sure to start teardown
        //  on it.
        //

        if (!ExistingFcb) {

            LocalFcbForTeardown = ThisFcb;

        } else {

            *LcbForTeardown = NULL;
            CreateContext->CurrentFcb = ThisFcb;
        }

        //
        //  Try to do a fast acquire, otherwise we need to release
        //  the Fcb table, acquire the Fcb, acquire the Fcb table to
        //  dereference Fcb.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE) &&
            (NtfsSegmentNumber( &ParentScb->Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER)) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );

            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireFcbTable( IrpContext, Vcb );

        } else if (!NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT )) {

            //
            //  Remember the current file reference in the index entry.
            //  We want to be able to detect whether an entry is removed.
            //

            PreviousFileReference = IndexEntry->FileReference;
            DroppedParent = TRUE;

            ParentScb->Fcb->ReferenceCount += 1;
            InterlockedIncrement( &ParentScb->CleanupCount );

            //
            //  Set the IrpContext to acquire paging io resources if our target
            //  has one.  This will lock the MappedPageWriter out of this file.
            //

            if (ThisFcb->PagingIoResource != NULL) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }

            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsReleaseScbWithPaging( IrpContext, ParentScb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireExclusiveScb( IrpContext, ParentScb );
            NtfsAcquireFcbTable( IrpContext, Vcb );
            InterlockedDecrement( &ParentScb->CleanupCount );
            ParentScb->Fcb->ReferenceCount -= 1;
        }

        ThisFcb->ReferenceCount -= 1;

        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  If the Fcb existed and this is a paging file then either return
        //  sharing violation or force the Fcb and Scb's to go away.
        //  Do this for the case where the user is opening a paging file
        //  but the Fcb is non-paged or the user is opening a non-paging
        //  file and the Fcb is for a paging file.
        //

        if (ExistingFcb &&

            ((FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
              !FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) ||

             (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
              !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )))) {

            if (ThisFcb->CleanupCount != 0) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If we have a persistent paging file then give up and
            //  return SHARING_VIOLATION.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If there was an existing Fcb for a paging file we need to force
            //  all of the Scb's to be torn down.  The easiest way to do this
            //  is to flush and purge all of the Scb's (saving any attribute list
            //  for last) and then raise LOG_FILE_FULL to allow this request to
            //  be posted.
            //

            } else {

                //
                //  Reference the Fcb so it won't go away on any flushes.
                //

                InterlockedIncrement( &ThisFcb->CloseCount );
                DecrementCloseCount = TRUE;

                //
                //  Flush and purge this Fcb.
                //

                NtfsFlushAndPurgeFcb( IrpContext, ThisFcb );

                InterlockedDecrement( &ThisFcb->CloseCount );
                DecrementCloseCount = FALSE;

                //
                //  Force this request to be posted and then raise
                //  CANT_WAIT.  The Fcb should be torn down in the finally
                //  clause below.
                //

                NtfsRaiseToPost( IrpContext );
            }
        }

        //
        //  We perform a check to see whether we will allow the system
        //  files to be opened.
        //
        //  No test to make if this is not a system file or it is the VolumeDasd file.
        //  The ACL will protect the volume file.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
            (NtfsSegmentNumber( &ThisFcb->FileReference ) != VOLUME_DASD_NUMBER) &&
            NtfsProtectSystemFiles) {

            if (!NtfsCheckValidFileAccess( ThisFcb, IrpSp )) {

                Status = STATUS_ACCESS_DENIED;
                DebugTrace( 0, Dbg, ("Invalid access to system files\n") );
                try_return( NOTHING );
            }
        }

        //
        //  If the Fcb Info field needs to be initialized, we do so now.
        //  We read this information from the disk as the duplicate information
        //  in the index entry is not guaranteed to be correct.
        //

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            HaveScbSizes = NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                      TRUE,
                                                      ThisFcb,
                                                      &ScbSizes );

            //
            //  Remember the last access time in the directory entry.
            //

            ThisFcb->Info.LastAccessTime = IndexFileName->Info.LastAccessTime;

            NtfsConditionallyFixupQuota( IrpContext, ThisFcb );
        }

        //
        //  Check if something happened to this file in the window where
        //  we dropped the parent.
        //

        if (DroppedParent) {

            //
            //  Check if the file has been deleted.
            //

            if (ExistingFcb && (ThisFcb->LinkCount == 0)) {

                try_return( Status = STATUS_DELETE_PENDING );

            //
            //  Check if the link may have been deleted.
            //

            } else if (!NtfsEqualMftRef( &IndexEntry->FileReference,
                                         &PreviousFileReference )) {

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }
        }

        //
        //  We have the actual data from the disk stored in the duplicate
        //  information in the Fcb.  We compare this with the duplicate
        //  information in the DUPLICATE_INFORMATION structure in the
        //  filename attribute.  If they don't match, we remember that
        //  we need to update the duplicate information.
        //

        if (!RtlEqualMemory( &ThisFcb->Info,
                             &IndexFileName->Info,
                             FIELD_OFFSET( DUPLICATED_INFORMATION, LastAccessTime ))) {

            UpdateFcbInfo = TRUE;

            //
            //  We expect this to be very rare but let's find the ones being changed.
            //

            if (ThisFcb->Info.CreationTime != IndexFileName->Info.CreationTime) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_CREATE );
            }

            if (ThisFcb->Info.LastModificationTime != IndexFileName->Info.LastModificationTime) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_MOD );
            }

            if (ThisFcb->Info.LastChangeTime != IndexFileName->Info.LastChangeTime) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            }
        }

        if (!RtlEqualMemory( &ThisFcb->Info.AllocatedLength,
                             &IndexFileName->Info.AllocatedLength,
                             FIELD_OFFSET( DUPLICATED_INFORMATION, Reserved ) -
                                FIELD_OFFSET( DUPLICATED_INFORMATION, AllocatedLength ))) {

            UpdateFcbInfo = TRUE;

            if (ThisFcb->Info.AllocatedLength != IndexFileName->Info.AllocatedLength) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

            if (ThisFcb->Info.FileSize != IndexFileName->Info.FileSize) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            if (ThisFcb->Info.FileAttributes != IndexFileName->Info.FileAttributes) {

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( ThisFcb ) ||
                           (ThisFcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( ThisFcb )) );

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            }

            if (ThisFcb->Info.PackedEaSize != IndexFileName->Info.PackedEaSize) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_EA_SIZE );
            }
        }

        //
        //  Don't update last access unless more than an hour.
        //

        if (NtfsCheckLastAccess( IrpContext, ThisFcb )) {

            SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
            UpdateFcbInfo = TRUE;
        }

        //
        //  Now get the link for this traversal.
        //

        ThisLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 ThisFcb,
                                 FinalName,
                                 IndexFileName->Flags,
                                 NULL );

        //
        //  We now know the Fcb is linked into the tree.
        //

        LocalFcbForTeardown = NULL;

        *LcbForTeardown = ThisLcb;
        CreateContext->CurrentFcb = ThisFcb;

        //
        //  If the link has been deleted, we cut off the open.
        //

        if (LcbLinkIsDeleted( ThisLcb )) {

            try_return( Status = STATUS_DELETE_PENDING );
        }

        //
        //  We now call the worker routine to open an attribute on an existing file.
        //

        Status = NtfsOpenAttributeInExistingFile( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  ThisLcb,
                                                  ThisFcb,
                                                  (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                                   ? 0
                                                   : FullPathName.Length - FinalName.Length),
                                                  AttrName,
                                                  AttrTypeCode,
                                                  CcbFlags,
                                                  CreateContext->CreateFlags,
                                                  CreateContext->NetworkInfo,
                                                  &CreateContext->ThisScb,
                                                  &CreateContext->ThisCcb );

        //
        //  Check to see if we should insert any prefix table entries
        //  and update the last access time.
        //  We skip this for reparse points as *ThisScb and *ThisCcb may be NULL.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_WAIT_FOR_OPLOCK) &&
            (Status != STATUS_REPARSE)) {

            PSCB Scb = CreateContext->ThisScb;

            //
            //  Go ahead and insert this link into the splay tree if it is not
            //  a system file.
            //

            if (!FlagOn( ThisLcb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                if ((CreateContext->FileHashLength != 0) &&
                    !FlagOn( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                    (ThisLcb->FileNameAttr->Flags != FILE_NAME_DOS) ) {

                    //
                    //  Remove any exising hash value.
                    //

                    if (FlagOn( ThisLcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                        NtfsRemoveHashEntriesForLcb( ThisLcb );
#ifdef NTFS_HASH_DATA
                        ThisFcb->Vcb->HashTable.OpenFileConflict += 1;
#endif
                    }

                    NtfsInsertHashEntry( &Vcb->HashTable,
                                         ThisLcb,
                                         CreateContext->FileHashLength,
                                         CreateContext->FileHashValue );
#ifdef NTFS_HASH_DATA
                    Vcb->HashTable.OpenFileInsert += 1;
#endif
                }

                NtfsInsertPrefix( ThisLcb, CreateContext->CreateFlags );
            }

            //
            //  If this is a directory open and the normalized name is not in
            //  the Scb then do so now.
            //

            if ((SafeNodeType( CreateContext->ThisScb ) == NTFS_NTC_SCB_INDEX) &&
                (CreateContext->ThisScb->ScbType.Index.NormalizedName.Length == 0)) {

                //
                //  We may be able to use the parent.
                //

                if (ParentScb->ScbType.Index.NormalizedName.Length != 0) {

                    NtfsUpdateNormalizedName( IrpContext,
                                              ParentScb,
                                              CreateContext->ThisScb,
                                              IndexFileName,
                                              FALSE,
                                              FALSE );

                } else {

                    NtfsBuildNormalizedName( IrpContext,
                                             CreateContext->ThisScb->Fcb,
                                             CreateContext->ThisScb,
                                             &CreateContext->ThisScb->ScbType.Index.NormalizedName );
                }
            }

            //
            //  Perform the last bit of work.  If this a user file open, we need
            //  to check if we initialize the Scb.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    //
                    //  We may have the sizes from our Fcb update call.
                    //

                    if (HaveScbSizes &&
                        (AttrTypeCode == $DATA) &&
                        (AttrName.Length == 0) &&
                        !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB )) {

                        NtfsUpdateScbFromMemory( Scb, &ScbSizes );

                    } else {

                        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                    }
                }

                //
                //  Let's check if we need to set the cache bit.
                //

                if (!FlagOn( IrpSp->Parameters.Create.Options,
                             FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }
            }

            //
            //  If this is the paging file, we want to be sure the allocation
            //  is loaded.
            //

            if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                (Scb->Header.AllocationSize.QuadPart != 0) &&
                !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                LCN Lcn;
                VCN Vcn;
                VCN AllocatedVcns;

                AllocatedVcns = Int64ShraMod32(Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift);

                NtfsPreloadAllocation( IrpContext, Scb, 0, AllocatedVcns );

                //
                //  Now make sure the allocation is correctly loaded.  The last
                //  Vcn should correspond to the allocation size for the file.
                //

                if (!NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                 &Vcn,
                                                 &Lcn ) ||
                    (Vcn + 1) != AllocatedVcns) {

                    NtfsRaiseStatus( IrpContext,
                                     STATUS_FILE_CORRUPT_ERROR,
                                     NULL,
                                     ThisFcb );
                }
            }

            //
            //  If this open is for an executable image we update the last
            //  access time.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess, FILE_EXECUTE ) &&
                (Scb->AttributeTypeCode == $DATA)) {

                SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );
            }

            //
            //  Let's update the quick index information in the Lcb.
            //

            RtlCopyMemory( &ThisLcb->QuickIndex,
                           QuickIndex,
                           sizeof( QUICK_INDEX ));

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.  We do not do
            //  this for network opens or reparse points.
            //

            if (CreateContext->NetworkInfo == NULL) {

                NtfsEncryptionCreateCallback( IrpContext,
                                              Irp,
                                              IrpSp,
                                              CreateContext->ThisScb,
                                              CreateContext->ThisCcb,
                                              ParentScb->Fcb,
                                              CreateContext,
                                              FALSE );
            }

            //
            //  If this operation was a supersede/overwrite or we created a new
            //  attribute stream then we want to perform the file record and
            //  directory update now.  Otherwise we will defer the updates until
            //  the user closes his handle.
            //

            if (UpdateFcbInfo || NtfsIsStreamNew( Irp->IoStatus.Information )) {
                NtfsUpdateAllInformation( IrpContext, IrpSp->FileObject, ThisFcb, CreateContext->ThisScb, CreateContext->ThisCcb, ParentScb, *LcbForTeardown ); 
            }
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsOpenFile );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        //
        //  If this operation was not totally successful we need to
        //  back out the following changes.
        //
        //      Modifications to the Info fields in the Fcb.
        //      Any changes to the allocation of the Scb.
        //      Any changes in the open counts in the various structures.
        //      Changes to the share access values in the Fcb.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    ThisFcb,
                                    CreateContext->ThisScb,
                                    CreateContext->ThisCcb );

        }

        if (DecrementCloseCount) {

            InterlockedDecrement( &ThisFcb->CloseCount );
        }

        //
        //  If we are to cleanup the Fcb we, look to see if we created it.
        //  If we did we can call our teardown routine.  Otherwise we
        //  leave it alone.
        //

        if ((LocalFcbForTeardown != NULL) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_WAIT_FOR_OPLOCK)) {

            NtfsTeardownStructures( IrpContext,
                                    ThisFcb,
                                    NULL,
                                    (BOOLEAN) (IrpContext->TransactionId != 0),
                                    0,
                                    NULL );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenFile:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsCreateNewFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PFILE_NAME FileNameAttr,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN PINDEX_CONTEXT *IndexContext,
    IN PCREATE_CONTEXT CreateContext,
    OUT PLCB *LcbForTeardown
    )

/*++

Routine Description:

    This routine is called when we need to open an attribute on a file
    which does not exist yet.  We have the ParentScb and the name to use
    for this create.  We will attempt to create the file and necessary
    attributes.  This will cause us to create an Fcb and the link between
    it and its parent Scb.  We will add this link to the prefix table as
    well as the link for its parent Scb if specified.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ParentScb - This is the Scb for the parent directory.

    FileNameAttr - This is the file name attribute we used to perform the
        search.  The file name is correct but the other fields need to
        be initialized.

    FullPathName - This is the string containing the full path name of
        this Fcb.

    FinalName - This is the string for the final component only.

    AttrName - This is the name of the attribute to open.

    AttriCodeName - This is the name of the attribute code to open.

    CreateFlags - Flags for create - we care about ignore case, dos only component,
        trailingbackslashes and open by id

    IndexContext - If this contains a non-NULL value then this is the result of a
        lookup which did not find the file.  It can be used to insert the name into the index.
        We will clean it up here in the error path to prevent a deadlock if we call
        TeardownStructures within this routine.

    CreateContext - Context with create variables.

    LcbForTeardown - This is the Lcb to use in teardown if we add an Lcb
        into the tree.

    Tunnel - This is the property tunnel to search for restoration

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVCB Vcb;

    ULONG CcbFlags = 0;
    ULONG UsnReasons = 0;
    BOOLEAN IndexedAttribute;

    BOOLEAN CleanupAttrContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PBCB FileRecordBcb = NULL;
    LONGLONG FileRecordOffset;
    FILE_REFERENCE ThisFileReference;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    PSCB Scb;
    PLCB ThisLcb = NULL;
    PFCB ThisFcb = NULL;
    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN RemovedFcb = FALSE;
    BOOLEAN DecrementCloseCount = FALSE;

    PACCESS_STATE AccessState;
    BOOLEAN ReturnedExistingFcb;

    BOOLEAN LoggedFileRecord = FALSE;

    BOOLEAN HaveTunneledInformation = FALSE;

    NAME_PAIR NamePair;
    NTFS_TUNNELED_DATA TunneledData;
    ULONG TunneledDataSize;
    ULONG OwnerId;
    PQUOTA_CONTROL_BLOCK QuotaControl = NULL;

    PSHARED_SECURITY SharedSecurity = NULL;

    VCN Cluster;
    LCN Lcn;
    VCN Vcn;

    ULONG DesiredAccess;

    UCHAR FileNameFlags;
#if (DBG || defined( NTFS_FREE_ASSERTS ))
    BOOLEAN Acquired;
    ULONG CreateDisposition;
#endif

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateNewFile:  Entered\n") );


    NtfsInitializeNamePair(&NamePair);

    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        SetFlag( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT );
    }

    //
    //  We will do all the checks to see if this open can fail.
    //  This includes checking the specified attribute names, checking
    //  the security access and checking the create disposition.
    //

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;
#endif

    ASSERT( (CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OVERWRITE) );
    ASSERT( !NtfsIsVolumeReadOnly( ParentScb->Vcb ));
    ASSERT( !FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE ) ||
            (CreateDisposition != FILE_OVERWRITE_IF));

    Vcb = ParentScb->Vcb;
    Status = NtfsCheckValidAttributeAccess( IrpContext,
                                            IrpSp,
                                            Vcb,
                                            NULL,
                                            &AttrName,
                                            &AttrTypeCode,
                                            CreateContext->CreateFlags,
                                            &CcbFlags,
                                            &IndexedAttribute );

    if (!NT_SUCCESS( Status )) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit  ->  %08lx\n", Status) );

        return Status;
    }

    //
    //  Fail this request if this is an indexed attribute and the TEMPORARY
    //  bit is set.
    //

    if (IndexedAttribute &&
        FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We won't allow someone to create a read-only file with DELETE_ON_CLOSE.
    //

    if (FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_READONLY ) &&
        FlagOn( IrpSp->Parameters.Create.Options, FILE_DELETE_ON_CLOSE )) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_CANNOT_DELETE) );
        return STATUS_CANNOT_DELETE;
    }

    //
    //  We do not allow that anything be created in a directory that is a reparse
    //  point. We verify that the parent is not in this category.
    //

    if (IsDirectory( &ParentScb->Fcb->Info ) &&
        (FlagOn( ParentScb->Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ))) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_DIRECTORY_IS_A_REPARSE_POINT) );
        return STATUS_DIRECTORY_IS_A_REPARSE_POINT;
    }

    //
    //  We do not allow anything to be created in a system directory (unless it is the root directory).
    //  we only allow creates for indices and data streams
    //

    if ((FlagOn( ParentScb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
         (ParentScb != Vcb->RootIndexScb)) ||
        !((AttrTypeCode == $DATA) || (AttrTypeCode == $INDEX_ALLOCATION))) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now perform the security checks.  The first is to check if we
        //  may create a file in the parent.  The second checks if the user
        //  desires ACCESS_SYSTEM_SECURITY and has the required privilege.
        //

        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

        //
        //  Calculate desired access needed in parent
        //

        if (!FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {
            DesiredAccess = FILE_ADD_FILE;
        } else {
            DesiredAccess = FILE_ADD_SUBDIRECTORY;
        }

        //
        //  If we have restore privilege auto grant all the access other than ACCESS_SYSTEM_SECURITY
        //  which always requires a privilege check
        //

        if (FlagOn( AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

            SetFlag( AccessState->PreviouslyGrantedAccess, FlagOn( AccessState->RemainingDesiredAccess, ~ACCESS_SYSTEM_SECURITY ) );
            ClearFlag( AccessState->RemainingDesiredAccess, AccessState->PreviouslyGrantedAccess );

            //
            //  We don't need any desired access in the parent since we have the privilege
            //

            DesiredAccess = 0;
        }

        //
        //  Always do an explicity access check - to guarantee auditing is done. This is done
        //  in checking only mode since we're asking about the parent not the file itself so
        //  the access state shouldn't change - in fact when creating a file you get whatever
        //  access state you ask for if you are allowed to create the file
        //

        NtfsAccessCheck( IrpContext, ParentScb->Fcb, NULL, Irp , DesiredAccess, TRUE );

        //
        //  We want to allow this user maximum access to this file.  We will
        //  use his desired access and check if he specified MAXIMUM_ALLOWED.
        //

        SetFlag( AccessState->PreviouslyGrantedAccess,
                 AccessState->RemainingDesiredAccess );

        if (FlagOn( AccessState->PreviouslyGrantedAccess, MAXIMUM_ALLOWED )) {

            SetFlag( AccessState->PreviouslyGrantedAccess, FILE_ALL_ACCESS );
            ClearFlag( AccessState->PreviouslyGrantedAccess, MAXIMUM_ALLOWED );
        }

        AccessState->RemainingDesiredAccess = 0;

        //
        //  Find/cache the security descriptor being passed in.  This call may
        //  create new data in the security indexes/stream and commits
        //  before any subsequent disk modifications occur.
        //

        SharedSecurity = NtfsCacheSharedSecurityForCreate( IrpContext, ParentScb->Fcb );

        //
        //  Make sure the parent has a normalized name.  We want to construct it now
        //  while we can still walk up the Lcb queue.  Otherwise we can deadlock
        //  on the Mft and other resources.
        //

        if ((AttrTypeCode == $INDEX_ALLOCATION) &&
            (ParentScb->ScbType.Index.NormalizedName.Length == 0)) {

            NtfsBuildNormalizedName( IrpContext,
                                     ParentScb->Fcb,
                                     ParentScb,
                                     &ParentScb->ScbType.Index.NormalizedName );
        }

        //
        //  Decide whether there's anything in the tunnel cache for this create.
        //  We don't do tunnelling in POSIX mode, hence the test for IgnoreCase.
        //

        if (!IndexedAttribute && FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

            TunneledDataSize = sizeof(NTFS_TUNNELED_DATA);

            if (FsRtlFindInTunnelCache( &Vcb->Tunnel,
                                        *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                        &FinalName,
                                        &NamePair.Short,
                                        &NamePair.Long,
                                        &TunneledDataSize,
                                        &TunneledData)) {

                ASSERT( TunneledDataSize == sizeof(NTFS_TUNNELED_DATA) );

                HaveTunneledInformation = TRUE;

                //
                //  If we have tunneled data and there's an object in the
                //  tunnel cache for this file, we need to acquire the object
                //  id index now (before acquiring any quota resources) to
                //  prevent a deadlock.  If there's no object id, then we
                //  won't try to set the object id later, and there's no
                //  deadlock to worry about.
                //

                if (TunneledData.HasObjectId) {

                    NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );

                    ASSERT( !FlagOn( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX ) );
                    SetFlag( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX );

                    //
                    //  The object id package won't post the Usn reason if it
                    //  sees it's been called in the create path, since the
                    //  file name is not yet in the file record, so it's unsafe
                    //  to call the Usn package.  When we post the create to the
                    //  Usn package below, we'll remember to post this one, too.
                    //

                    UsnReasons |= USN_REASON_OBJECT_ID_CHANGE;
                }
            }
        }

        //
        //  If quota tracking is enabled then get a owner id for the file.
        //

        if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED )) {

            PSID Sid;
            BOOLEAN OwnerDefaulted;

            //
            //  The quota index must be acquired before the MFT SCB is acquired.
            //

            ASSERT( !NtfsIsExclusiveScb( Vcb->MftScb ) || NtfsIsExclusiveScb( Vcb->QuotaTableScb ));

            //
            //  Extract the security id from the security descriptor.
            //

            Status = RtlGetOwnerSecurityDescriptor( SharedSecurity->SecurityDescriptor,
                                                    &Sid,
                                                    &OwnerDefaulted );

            if (!NT_SUCCESS( Status )) {
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            //
            // Generate a owner id.
            //

            OwnerId = NtfsGetOwnerId( IrpContext, Sid, TRUE, NULL );

            QuotaControl = NtfsInitializeQuotaControlBlock( Vcb, OwnerId );

            //
            //  Acquire the quota control block.  This is done here since it
            //  must be acquired before the MFT.
            //

            NtfsAcquireQuotaControl( IrpContext, QuotaControl );
        }

        //
        //  We will now try to do all of the on-disk operations.  This means first
        //  allocating and initializing an Mft record.  After that we create
        //  an Fcb to use to access this record.
        //

        ThisFileReference = NtfsAllocateMftRecord( IrpContext,
                                                   Vcb,
                                                   FALSE );

        //
        //  Pin the file record we need.
        //

        NtfsPinMftRecord( IrpContext,
                          Vcb,
                          &ThisFileReference,
                          TRUE,
                          &FileRecordBcb,
                          &FileRecord,
                          &FileRecordOffset );

        //
        //  Initialize the file record header.
        //

        NtfsInitializeMftRecord( IrpContext,
                                 Vcb,
                                 &ThisFileReference,
                                 FileRecord,
                                 FileRecordBcb,
                                 IndexedAttribute );

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 Vcb,
                                 ThisFileReference,
                                 BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ),
                                 IndexedAttribute,
                                 &ReturnedExistingFcb );

        ASSERT( !ReturnedExistingFcb );

        //
        //  Set the flag indicating we want to acquire the paging io resource
        //  if it doesn't already exist. Use acquire don't wait for lock order
        //  package. Since this is a new file and we haven't dropped the fcb table
        //  mutex yet, no one else can own it. So this will always succeed.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        Acquired =
#endif
        NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        ASSERT( Acquired );
#endif

        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  Reference the Fcb so it won't go away.
        //

        InterlockedIncrement( &ThisFcb->CloseCount );
        DecrementCloseCount = TRUE;

        //
        //  The first thing to create is the Ea's for the file.  This will
        //  update the Ea length field in the Fcb.
        //  We test here that the opener is opening the entire file and
        //  is not Ea blind.
        //

        if (Irp->AssociatedIrp.SystemBuffer != NULL) {

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_EA_KNOWLEDGE ) ||
                !FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                Status = STATUS_ACCESS_DENIED;
                leave;
            }
        }

        SetFlag( ThisFcb->FcbState, FCB_STATE_LARGE_STD_INFO );

        //
        //  Set up the security Id (if we've found one earlier).
        //  We need to be careful so that this works on upgraded and
        //  non-upgraded volumes.
        //

        if (ThisFcb->Vcb->SecurityDescriptorStream != NULL) {
            ThisFcb->SecurityId = SharedSecurity->Header.HashKey.SecurityId;
            ThisFcb->SharedSecurity = SharedSecurity;
            DebugTrace(0, (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX),
                       ( "SetFcbSecurity( %08x, %08x )\n", ThisFcb, SharedSecurity ));
            SharedSecurity = NULL;

        } else {

            ASSERT( ThisFcb->SecurityId == SECURITY_ID_INVALID );
        }

        ASSERT( SharedSecurity == NULL );

        //
        //  Assign the owner Id and quota control block to the fcb.  Once the
        //  quota control block is in the FCB this routine is not responsible
        //  for the reference to the quota control block.
        //

        if (QuotaControl != NULL) {

            //
            //  Assign the onwer Id and quota control block to the fcb.  Once the
            //  quota control block is in the FCB this routine is not responsible
            //  for the reference to the quota control block.
            //

            ThisFcb->OwnerId = OwnerId;
            ThisFcb->QuotaControl = QuotaControl;
            QuotaControl = NULL;
        }

        //
        //  Update the FileAttributes with the state of the CONTENT_INDEXED bit from the
        //  parent.
        //

        if (!FlagOn( ParentScb->Fcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            NtfsUpdateFcbInfoFromDisk( IrpContext, FALSE, ParentScb->Fcb, NULL );
        }

        ClearFlag( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );
        SetFlag( IrpSp->Parameters.Create.FileAttributes,
                 (ParentScb->Fcb->Info.FileAttributes & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) );

        //
        //  The changes to make on disk are first to create a standard information
        //  attribute.  We start by filling the Fcb with the information we
        //  know and creating the attribute on disk.
        //

        NtfsInitializeFcbAndStdInfo( IrpContext,
                                     ThisFcb,
                                     IndexedAttribute,
                                     FALSE,
                                     (BOOLEAN) (!FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION ) &&
                                                !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
                                                FlagOn( ParentScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )),
                                     IrpSp->Parameters.Create.FileAttributes,
                                     (HaveTunneledInformation ? &TunneledData : NULL) );

        //
        //  Next we create the Index for a directory or the unnamed data for
        //  a file if they are not explicitly being opened.
        //

        if (!IndexedAttribute) {

            if (!FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                //
                //  Update the quota
                //

                LONGLONG Delta = NtfsResidentStreamQuota( ThisFcb->Vcb );

                NtfsConditionallyUpdateQuota( IrpContext,
                                              ThisFcb,
                                              &Delta,
                                              FALSE,
                                              TRUE );

                //
                //  Create the attribute
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                NtfsCreateAttributeWithValue( IrpContext,
                                              ThisFcb,
                                              $DATA,
                                              NULL,
                                              NULL,
                                              0,
                                              (USHORT) ((!FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                                                         !FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION )) ?
                                                        (ParentScb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) :
                                                        0),
                                              NULL,
                                              FALSE,
                                              &AttrContext );

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                CleanupAttrContext = FALSE;

                ThisFcb->Info.AllocatedLength = 0;
                ThisFcb->Info.FileSize = 0;
            }

        } else {

            NtfsCreateIndex( IrpContext,
                             ThisFcb,
                             $FILE_NAME,
                             COLLATION_FILE_NAME,
                             Vcb->DefaultBytesPerIndexAllocationBuffer,
                             (UCHAR)Vcb->DefaultBlocksPerIndexAllocationBuffer,
                             NULL,
                             (USHORT) (!FlagOn( IrpSp->Parameters.Create.Options,
                                                FILE_NO_COMPRESSION ) ?
                                       (ParentScb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) :
                                       0),
                             TRUE,
                             FALSE );
        }

        //
        //  Now we create the Lcb, this means that this Fcb is in the graph.
        //

        ThisLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 ThisFcb,
                                 FinalName,
                                 0,
                                 NULL );

        ASSERT( ThisLcb != NULL );

        //
        //  Finally we create and open the desired attribute for the user.
        //

        if (AttrTypeCode == $INDEX_ALLOCATION) {

            Status = NtfsOpenAttribute( IrpContext,
                                        IrpSp,
                                        Vcb,
                                        ThisLcb,
                                        ThisFcb,
                                        (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                         ? 0
                                         : FullPathName.Length - FinalName.Length),
                                        NtfsFileNameIndex,
                                        $INDEX_ALLOCATION,
                                        SetShareAccess,
                                        UserDirectoryOpen,
                                        TRUE,
                                        (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                         ? CcbFlags | CCB_FLAG_OPEN_BY_FILE_ID
                                         : CcbFlags),
                                        NULL,
                                        &CreateContext->ThisScb,
                                        &CreateContext->ThisCcb );

        } else {

            Status = NtfsOpenNewAttr( IrpContext,
                                      Irp,
                                      IrpSp,
                                      ThisLcb,
                                      ThisFcb,
                                      (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                       ? 0
                                       : FullPathName.Length - FinalName.Length),
                                      AttrName,
                                      AttrTypeCode,
                                      TRUE,
                                      CcbFlags,
                                      FALSE,
                                      CreateContext->CreateFlags,
                                      &CreateContext->ThisScb,
                                      &CreateContext->ThisCcb );
        }

        //
        //  If we are successful, we add the parent Lcb to the prefix table if
        //  desired.  We will always add our link to the prefix queue.
        //

        if (NT_SUCCESS( Status )) {

            Scb = CreateContext->ThisScb;

            //
            //  Initialize the Scb if we need to do so.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                }

                if (!FlagOn( IrpSp->Parameters.Create.Options,
                             FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }

                //
                //  If this is the unnamed data attribute, we store the sizes
                //  in the Fcb.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                    ThisFcb->Info.AllocatedLength = Scb->TotalAllocated;
                    ThisFcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
                }
            }

            //
            //  Next add this entry to parent.  It is possible that this is a link,
            //  an Ntfs name, a DOS name or Ntfs/Dos name.  We use the filename
            //  attribute structure from earlier, but need to add more information.
            //

            NtfsAddLink( IrpContext,
                         (BOOLEAN) !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE ),
                         ParentScb,
                         ThisFcb,
                         FileNameAttr,
                         &LoggedFileRecord,
                         &FileNameFlags,
                         &ThisLcb->QuickIndex,
                         (HaveTunneledInformation? &NamePair : NULL),
                         *IndexContext );

            //
            //  We created the Lcb without knowing the correct value for the
            //  flags.  We update it now.
            //

            ThisLcb->FileNameAttr->Flags = FileNameFlags;
            FileNameAttr->Flags = FileNameFlags;

            //
            //  We also have to fix up the ExactCaseLink of the Lcb since we may have had
            //  a short name create turned into a tunneled long name create, meaning that
            //  it should be full uppercase. And the filename in the IRP.
            //

            if (FileNameFlags == FILE_NAME_DOS) {

                RtlUpcaseUnicodeString( &ThisLcb->ExactCaseLink.LinkName, &ThisLcb->ExactCaseLink.LinkName, FALSE );
                RtlUpcaseUnicodeString( &IrpSp->FileObject->FileName, &IrpSp->FileObject->FileName, FALSE );
            }

            //
            //  Clear the flags in the Fcb that indicate we need to update on
            //  disk structures.  Also clear any file object and Ccb flags
            //  which also indicate we may need to do an update.
            //

            ThisFcb->InfoFlags = 0;
            ClearFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            ClearFlag( IrpSp->FileObject->Flags,
                       FO_FILE_MODIFIED | FO_FILE_FAST_IO_READ | FO_FILE_SIZE_CHANGED );

            ClearFlag( CreateContext->ThisCcb->Flags,
                       (CCB_FLAG_UPDATE_LAST_MODIFY |
                        CCB_FLAG_UPDATE_LAST_CHANGE |
                        CCB_FLAG_SET_ARCHIVE) );

            //
            //  This code is still necessary for non-upgraded volumes.
            //

            NtfsAssignSecurity( IrpContext,
                                ParentScb->Fcb,
                                Irp,
                                ThisFcb,
                                FileRecord,
                                FileRecordBcb,
                                FileRecordOffset,
                                &LoggedFileRecord );

            //
            //  Log the file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  Now add the eas for the file.  We need to add them now because
            //  they are logged and we have to make sure we don't modify the
            //  attribute record after adding them.
            //

            if (Irp->AssociatedIrp.SystemBuffer != NULL) {

                NtfsAddEa( IrpContext,
                           Vcb,
                           ThisFcb,
                           (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer,
                           IrpSp->Parameters.Create.EaLength,
                           &Irp->IoStatus );
            }

            //
            //  Change the last modification time and last change time for the
            //  parent.
            //

            NtfsUpdateFcb( ParentScb->Fcb,
                           (FCB_INFO_CHANGED_LAST_CHANGE |
                            FCB_INFO_CHANGED_LAST_MOD |
                            FCB_INFO_UPDATE_LAST_ACCESS) );

            //
            //  If this is the paging file, we want to be sure the allocation
            //  is loaded.
            //

            if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) {

                Cluster = Int64ShraMod32( Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift );

                NtfsPreloadAllocation( IrpContext, Scb, 0, Cluster );

                //
                //  Now make sure the allocation is correctly loaded.  The last
                //  Vcn should correspond to the allocation size for the file.
                //

                if (!NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                 &Vcn,
                                                 &Lcn ) ||
                    (Vcn + 1) != Cluster) {

                    NtfsRaiseStatus( IrpContext,
                                     STATUS_FILE_CORRUPT_ERROR,
                                     NULL,
                                     ThisFcb );
                }
            }

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.
            //
            //  We need to do this now because the encryption driver may fail
            //  the create, and we don't want that to happen _after_ we've
            //  added the entry to the prefix table.
            //

            try {

                CreateContext->CurrentFcb = ThisFcb;

                NtfsEncryptionCreateCallback( IrpContext,
                                              Irp,
                                              IrpSp,
                                              CreateContext->ThisScb,
                                              CreateContext->ThisCcb,
                                              ParentScb->Fcb,
                                              CreateContext,
                                              TRUE );
            } finally {
                CreateContext->CurrentFcb = NULL;
            }


            //
            //  Now that there are no other failures, but *before* inserting the prefix
            //  entry and returning to code that assumes it cannot fail, we will post the
            //  UsnJournal change and actually attempt to write the UsnJournal.  Then we
            //  actually commit the transaction in order to reduce UsnJournal contention.
            //  This call must be made _after_ the call to NtfsInitializeFcbAndStdInfo,
            //  since that's where the object id gets set from the tunnel cache, and we
            //  wouldn't want to post the usn reason for the object id change if we
            //  haven't actually set the object id yet.
            //

            NtfsPostUsnChange( IrpContext, ThisFcb, (UsnReasons | USN_REASON_FILE_CREATE) );

            //
            //  If this is a directory open and the normalized name is not in
            //  the Scb then do so now.  We should always have a normalized name in the
            //  parent to build from.
            //

            if ((SafeNodeType( CreateContext->ThisScb ) == NTFS_NTC_SCB_INDEX) &&
                (CreateContext->ThisScb->ScbType.Index.NormalizedName.Length == 0)) {

                //
                //  We may be able to use the parent.
                //

                if (ParentScb->ScbType.Index.NormalizedName.Length != 0) {

                    NtfsUpdateNormalizedName( IrpContext,
                                              ParentScb,
                                              CreateContext->ThisScb,
                                              FileNameAttr,
                                              FALSE,
                                              TRUE );

                }
            }

            //
            //  Now, if anything at all is posted to the Usn Journal, we must write it now
            //  so that we do not get a log file full later.
            //

            ASSERT( IrpContext->Usn.NextUsnFcb == NULL );
            if (IrpContext->Usn.CurrentUsnFcb != NULL) {

                //
                //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                //  reduce contention.
                //

                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );
            }

            //
            //  We report to our parent that we created a new file.
            //

            if (!FlagOn( CreateContext->CreateFlags, CREATE_FLAG_OPEN_BY_ID ) && (Vcb->NotifyCount != 0)) {

                NtfsReportDirNotify( IrpContext,
                                     ThisFcb->Vcb,
                                     &CreateContext->ThisCcb->FullFileName,
                                     CreateContext->ThisCcb->LastFileNameOffset,
                                     NULL,
                                     ((FlagOn( CreateContext->ThisCcb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                       (CreateContext->ThisCcb->Lcb != NULL) &&
                                       (CreateContext->ThisCcb->Lcb->Scb->ScbType.Index.NormalizedName.Buffer != 0)) ?
                                      &CreateContext->ThisCcb->Lcb->Scb->ScbType.Index.NormalizedName :
                                      NULL),
                                     (IndexedAttribute
                                      ? FILE_NOTIFY_CHANGE_DIR_NAME
                                      : FILE_NOTIFY_CHANGE_FILE_NAME),
                                     FILE_ACTION_ADDED,
                                     ParentScb->Fcb );
            }

            ThisFcb->InfoFlags = 0;

            //
            //  Insert the hash entry for this as well.
            //

            if ((CreateContext->FileHashLength != 0) &&
                !FlagOn( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                (ThisLcb->FileNameAttr->Flags != FILE_NAME_DOS) ) {

                //
                //  Remove any exising hash value.
                //

                if (FlagOn( ThisLcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                    NtfsRemoveHashEntriesForLcb( ThisLcb );
                }

                NtfsInsertHashEntry( &Vcb->HashTable,
                                     ThisLcb,
                                     CreateContext->FileHashLength,
                                     CreateContext->FileHashValue );

#ifdef NTFS_HASH_DATA
                Vcb->HashTable.CreateNewFileInsert += 1;
#endif
            }


            //
            //  Now we insert the Lcb for this Fcb.
            //

            NtfsInsertPrefix( ThisLcb, CreateContext->CreateFlags );

            Irp->IoStatus.Information = FILE_CREATED;

            //
            //  If we'll be calling a post create callout, make sure
            //  NtfsEncryptionCreateCallback set this Fcb bit.
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE ) &&
                FlagOn( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT ) &&
                FlagOn( CreateContext->EncryptionFileDirFlags, FILE_NEW )) {

                ASSERT( FlagOn( ThisFcb->FcbState, FCB_STATE_ENCRYPTION_PENDING ) );
            }
        }

    } finally {

        DebugUnwind( NtfsCreateNewFile );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        NtfsUnpinBcb( IrpContext, &FileRecordBcb );

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (DecrementCloseCount) {

            InterlockedDecrement( &ThisFcb->CloseCount );
        }

        if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX )) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
            ClearFlag( CreateContext->CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX );
        }

        if (NamePair.Long.Buffer != NamePair.LongBuffer) {

            NtfsFreePool(NamePair.Long.Buffer);
        }

        if (SharedSecurity != NULL) {
            ASSERT( ThisFcb == NULL || ThisFcb->SharedSecurity == NULL );
            NtfsAcquireFcbSecurity( Vcb );
            RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
            NtfsReleaseFcbSecurity( Vcb );
        }

        //
        //  We need to cleanup any changes to the in memory
        //  structures if there is an error.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            ASSERT( !(AbnormalTermination()) || IrpContext->ExceptionStatus != STATUS_SUCCESS );

            if (*IndexContext != NULL) {

                NtfsCleanupIndexContext( IrpContext, *IndexContext );
                *IndexContext = NULL;
            }

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    ThisFcb,
                                    CreateContext->ThisScb,
                                    CreateContext->ThisCcb );

            //
            //  Derefence the quota control block if it was not assigned
            //  to the FCB.
            //

            if (QuotaControl != NULL) {
                NtfsDereferenceQuotaControlBlock( Vcb, &QuotaControl );
            }

            //
            //  Always force the Fcb to reinitialized.
            //

            if (ThisFcb != NULL) {

                PLIST_ENTRY Links;

                ClearFlag( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED );

                //
                //  Mark the Fcb and all Scb's as deleted to force all subsequent
                //  operations to fail.
                //

                SetFlag( ThisFcb->FcbState, FCB_STATE_FILE_DELETED );

                //
                //  We need to mark all of the Scbs as gone.
                //

                for (Links = ThisFcb->ScbQueue.Flink;
                     Links != &ThisFcb->ScbQueue;
                     Links = Links->Flink) {

                    Scb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                    Scb->ValidDataToDisk =
                    Scb->Header.AllocationSize.QuadPart =
                    Scb->Header.FileSize.QuadPart =
                    Scb->Header.ValidDataLength.QuadPart = 0;

                    SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                }

                //
                //  Clear the Scb field so our caller doesn't try to teardown
                //  from this point.
                //

                CreateContext->ThisScb = NULL;

                //
                //  If we created an Fcb then we want to check if we need to
                //  unwind any structure allocation.  We don't want to remove any
                //  structures needed for the coming AbortTransaction.  This
                //  includes the parent Scb as well as the current Fcb if we
                //  logged the ACL creation.
                //

                //
                //  Make sure the parent Fcb doesn't go away.  Then
                //  start a teardown from the Fcb we just found.
                //

                InterlockedIncrement( &ParentScb->CleanupCount );

                NtfsTeardownStructures( IrpContext,
                                        ThisFcb,
                                        NULL,
                                        LoggedFileRecord,
                                        0,
                                        &RemovedFcb );

                //
                //  If the Fcb was removed then both the Fcb and Lcb are gone.
                //

                if (RemovedFcb) {

                    ThisFcb = NULL;
                    ThisLcb = NULL;
                }

                InterlockedDecrement( &ParentScb->CleanupCount );
            }
        }

        //
        //  If the new Fcb is still present then either return it as the
        //  deepest Fcb encountered in this open or release it.
        //

        if (ThisFcb != NULL) {

            //
            //  If the Lcb is present then this is part of the tree.  Our
            //  caller knows to release it.
            //

            if (ThisLcb != NULL) {

                *LcbForTeardown = ThisLcb;
                CreateContext->CurrentFcb = ThisFcb;
            }
        }

        ASSERT( QuotaControl == NULL );
        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

PLCB
NtfsOpenSubdirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFILE_REFERENCE FileReference,
    IN UNICODE_STRING FileName,
    IN UCHAR FileNameFlags,
    IN PCREATE_CONTEXT CreateContext,
    OUT PLCB *LcbForTeardown
    )

/*++

Routine Description:

    This routine will create an Fcb for an intermediate node on an open path.
    We use the ParentScb and the information in the FileName attribute returned
    from the disk to create the Fcb and create a link between the Scb and Fcb.
    It's possible that the Fcb and Lcb already exist but the 'CreateXcb' calls
    handle that already.  This routine does not expect to fail.

Arguments:

    ParentScb - This is the Scb for the parent directory.

    FileName - This is the name for the entry.

    CreateFlags - Indicates if this open is using traverse access checking.

    CreatContext - Context containing current fcb

    FileReference - FileId of the subdirectory to open

    FileNameFlags - file name flags of the subdirectory being opened

    LcbForTeardown - This is the Lcb to use in teardown if we add an Lcb
        into the tree.

Return Value:

    PLCB - Pointer to the Link control block between the Fcb and its parent.

--*/

{
    PFCB ThisFcb;
    PLCB ThisLcb;
    PFCB LocalFcbForTeardown = NULL;

    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN ExistingFcb;

    PVCB Vcb = ParentScb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenSubdirectory:  Entered\n") );
    DebugTrace( 0, Dbg, ("ParentScb     ->  %08lx\n") );
    DebugTrace( 0, Dbg, ("IndexEntry    ->  %08lx\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        //
        //  The steps here are very simple create the Fcb, remembering if it
        //  already existed.  We don't update the information in the Fcb as
        //  we can't rely on the information in the duplicated information.
        //  A subsequent open of this Fcb will need to perform that work.
        //

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 ParentScb->Vcb,
                                 *FileReference,
                                 FALSE,
                                 TRUE,
                                 &ExistingFcb );

        ThisFcb->ReferenceCount += 1;

        //
        //  If we created this Fcb we must make sure to start teardown
        //  on it.
        //

        if (!ExistingFcb) {

            LocalFcbForTeardown = ThisFcb;

        } else {

            CreateContext->CurrentFcb = ThisFcb;
            *LcbForTeardown = NULL;
        }

        //
        //  Try to do a fast acquire, otherwise we need to release
        //  the Fcb table, acquire the Fcb, acquire the Fcb table to
        //  dereference Fcb. Just do an acquire for system files under the root i.e $Extend - this will match
        //  their canonical order
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE) &&
            (NtfsSegmentNumber( &ParentScb->Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER)) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );

            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireFcbTable( IrpContext, Vcb );

        } else if (!NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT )) {

            ParentScb->Fcb->ReferenceCount += 1;
            InterlockedIncrement( &ParentScb->CleanupCount );

            //
            //  Set the IrpContext to acquire paging io resources if our target
            //  has one.  This will lock the MappedPageWriter out of this file.
            //

            if (ThisFcb->PagingIoResource != NULL) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }

            //
            //  Release the fcb table first because its an end resource and release
            //  scb with paging might reacquire a fast mutex if freeing snapshots
            //

            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsReleaseScbWithPaging( IrpContext, ParentScb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireExclusiveScb( IrpContext, ParentScb );
            NtfsAcquireFcbTable( IrpContext, Vcb );
            InterlockedDecrement( &ParentScb->CleanupCount );
            ParentScb->Fcb->ReferenceCount -= 1;
        }

        ThisFcb->ReferenceCount -= 1;

        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  If this is a directory, it's possible that we hav an existing Fcb
        //  in the prefix table which needs to be initialized from the disk.
        //  We look in the InfoInitialized flag to know whether to go to
        //  disk.
        //

        ThisLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 ThisFcb,
                                 FileName,
                                 FileNameFlags,
                                 NULL );

        LocalFcbForTeardown = NULL;

        *LcbForTeardown = ThisLcb;
        CreateContext->CurrentFcb = ThisFcb;

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            NtfsUpdateFcbInfoFromDisk( IrpContext,
                                       BooleanFlagOn( CreateContext->CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ),
                                       ThisFcb,
                                       NULL );

            NtfsConditionallyFixupQuota( IrpContext, ThisFcb );
        }

    } finally {

        DebugUnwind( NtfsOpenSubdirectory );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        //
        //  If we are to cleanup the Fcb we, look to see if we created it.
        //  If we did we can call our teardown routine.  Otherwise we
        //  leave it alone.
        //

        if (LocalFcbForTeardown != NULL) {

            NtfsTeardownStructures( IrpContext,
                                    ThisFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    NULL );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenSubdirectory:  Lcb  ->  %08lx\n", ThisLcb) );
    }

    return ThisLcb;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenAttributeInExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is the worker routine for opening an attribute on an
    existing file.  It will handle volume opens, indexed opens, opening
    or overwriting existing attributes as well as creating new attributes.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisLcb - This is the Lcb we used to reach this Fcb.

    ThisFcb - This is the Fcb for the file being opened.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CcbFlags - This is the flag field for the Ccb.

    CreateFlags - Indicates if this open is an open by Id.

    NetworkInfo - If specified then this call is a fast open call to query
        the network information.  We don't update any of the in-memory structures
        for this.

    ThisScb - This is the address to store the Scb from this open.

    ThisCcb - This is the address to store the Ccb from this open.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CreateDisposition;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN FoundAttribute;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenAttributeInExistingFile:  Entered\n") );

    //
    //  When the Fcb denotes a reparse point, it will be retrieved below by one of
    //  NtfsOpenExistingAttr, NtfsOverwriteAttr or this routine prior to calling
    //  NtfsOpenNewAttr.
    //
    //  We do not retrieve the reparse point here, as we could, because in
    //  NtfsOpenExistingAttr and in NtfsOverwriteAttr there are extensive access
    //  control checks that need to be preserved. NtfsOpenNewAttr has no access
    //  checks.
    //

    //
    //  If the caller is ea blind, let's check the need ea count on the
    //  file.  We skip this check if he is accessing a named data stream.
    //

    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_EA_KNOWLEDGE ) &&
        FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

        PEA_INFORMATION ThisEaInformation;
        ATTRIBUTE_ENUMERATION_CONTEXT EaInfoAttrContext;

        NtfsInitializeAttributeContext( &EaInfoAttrContext );

        //
        //  Use a try-finally to facilitate cleanup.
        //

        try {

            //
            //  If we find the Ea information attribute we look in there for
            //  Need ea count.
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                           ThisFcb,
                                           &ThisFcb->FileReference,
                                           $EA_INFORMATION,
                                           &EaInfoAttrContext )) {

                ThisEaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &EaInfoAttrContext ));

                if (ThisEaInformation->NeedEaCount != 0) {

                    Status = STATUS_ACCESS_DENIED;
                }
            }

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &EaInfoAttrContext );
        }

        if (Status != STATUS_SUCCESS) {

            DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );

            return Status;
        }
    }

    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  If the result is a directory operation, then we know the attribute
    //  must exist.
    //

    if (AttrTypeCode == $INDEX_ALLOCATION) {

        //
        //  If this is not a file name index then we need to verify that the specified index
        //  exists.  We need to look for the $INDEX_ROOT attribute though not the
        //  $INDEX_ALLOCATION attribute.
        //

        if ((AttrName.Buffer != NtfsFileNameIndex.Buffer) || FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

            NtfsInitializeAttributeContext( &AttrContext );

            //
            //  Use a try-finally to facilitate cleanup.
            //

            try {

                FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                            ThisFcb,
                                                            &ThisFcb->FileReference,
                                                            $INDEX_ROOT,
                                                            &AttrName,
                                                            NULL,
                                                            (BOOLEAN) !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE ),
                                                            &AttrContext );
            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }

            //
            //  If we didn't find the name then we want to fail the request.
            //

            if (!FoundAttribute) {

                if ((CreateDisposition == FILE_OPEN) || (CreateDisposition == FILE_OVERWRITE)) {

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;

                } else {

                    Status = STATUS_ACCESS_DENIED;
                }

                DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );
                return Status;
            }
        }

        //
        //  Check the create disposition.
        //

        if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {

            Status = (ThisLcb == ThisFcb->Vcb->RootLcb
                      ? STATUS_ACCESS_DENIED
                      : STATUS_OBJECT_NAME_COLLISION);

        } else {

            Status = NtfsOpenExistingAttr( IrpContext,
                                           Irp,
                                           IrpSp,
                                           ThisLcb,
                                           ThisFcb,
                                           LastFileNameOffset,
                                           AttrName,
                                           $INDEX_ALLOCATION,
                                           CcbFlags,
                                           CreateFlags,
                                           TRUE,
                                           NetworkInfo,
                                           ThisScb,
                                           ThisCcb );

            //
            //  The IsEncrypted test below is meaningless for an uninitialized Fcb.
            //

            ASSERT( FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED ) );

            if ((Status == STATUS_SUCCESS) &&
                ARGUMENT_PRESENT( NetworkInfo ) &&
                IsEncrypted( &ThisFcb->Info )) {

                //
                //  We need to initialize the Scb now, otherwise we won't have set the
                //  encryption bit in the index Scb's attribute flags, and we will not
                //  return the right file attributes to the network opener.
                //

                if ((*ThisScb)->ScbType.Index.BytesPerIndexBuffer == 0) {

                    NtfsInitializeAttributeContext( &AttrContext );

                    //
                    //  Use a try-finally to facilitate cleanup.
                    //

                    try {

                        if (NtfsLookupAttributeByCode( IrpContext,
                                                       ThisFcb,
                                                       &ThisFcb->FileReference,
                                                       $INDEX_ROOT,
                                                       &AttrContext )) {

                            NtfsUpdateIndexScbFromAttribute( IrpContext,
                                                             *ThisScb,
                                                             NtfsFoundAttribute( &AttrContext ),
                                                             FALSE );

                        } else {

                            Status = STATUS_FILE_CORRUPT_ERROR;
                        }

                    } finally {

                        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    }

                    if (Status != STATUS_SUCCESS) {

                        DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );

                        return Status;
                    }
                }
            }
        }

    } else {

        //
        //  If it exists, we first check if the caller wanted to open that attribute.
        //  If the open is for a system file then look for that attribute explicitly.
        //

        if ((AttrName.Length == 0) &&
            (AttrTypeCode == $DATA) &&
            !FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

            FoundAttribute = TRUE;

        //
        //  Otherwise we see if the attribute exists.
        //

        } else {

            //
            //  Check that we own the paging io resource.  If we are creating the stream and
            //  need to break up the allocation then we must own the paging IO resource.
            //

            ASSERT( !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) ||
                    (IrpContext->CleanupStructure != NULL) ||
                    (ThisFcb->PagingIoResource == NULL) ||
                    (ThisFcb == ThisFcb->Vcb->RootIndexScb->Fcb) );

            NtfsInitializeAttributeContext( &AttrContext );

            //
            //  Use a try-finally to facilitate cleanup.
            //

            try {

                FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                            ThisFcb,
                                                            &ThisFcb->FileReference,
                                                            AttrTypeCode,
                                                            &AttrName,
                                                            NULL,
                                                            (BOOLEAN) !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE ),
                                                            &AttrContext );

                if (FoundAttribute && (AttrTypeCode == $DATA)) {

                    //
                    //  If there is an attribute name, we will copy the case of the name
                    //  to the input attribute name for data streams. For others the storage is common read-only regions.
                    //

                    PATTRIBUTE_RECORD_HEADER DataAttribute;

                    DataAttribute = NtfsFoundAttribute( &AttrContext );

                    RtlCopyMemory( AttrName.Buffer,
                                   Add2Ptr( DataAttribute, DataAttribute->NameOffset ),
                                   AttrName.Length );
                }

            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }
        }

        if (FoundAttribute) {

            //
            //  In this case we call our routine to open this attribute.
            //

            if ((CreateDisposition == FILE_OPEN) ||
                (CreateDisposition == FILE_OPEN_IF)) {

                Status = NtfsOpenExistingAttr( IrpContext,
                                               Irp,
                                               IrpSp,
                                               ThisLcb,
                                               ThisFcb,
                                               LastFileNameOffset,
                                               AttrName,
                                               AttrTypeCode,
                                               CcbFlags,
                                               CreateFlags,
                                               FALSE,
                                               NetworkInfo,
                                               ThisScb,
                                               ThisCcb );

                if ((Status != STATUS_PENDING) &&
                    (Status != STATUS_WAIT_FOR_OPLOCK) &&
                    (*ThisScb != NULL)) {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB );
                }

            //
            //  If he wanted to overwrite this attribute, we call our overwrite routine.
            //

            } else if ((CreateDisposition == FILE_SUPERSEDE) ||
                       (CreateDisposition == FILE_OVERWRITE) ||
                       (CreateDisposition == FILE_OVERWRITE_IF)) {

                if (!NtfsIsVolumeReadOnly( IrpContext->Vcb )) {

                    //
                    //  Check if mm will allow us to modify this file.
                    //

                    Status = NtfsOverwriteAttr( IrpContext,
                                                Irp,
                                                IrpSp,
                                                ThisLcb,
                                                ThisFcb,
                                                (BOOLEAN) (CreateDisposition == FILE_SUPERSEDE),
                                                LastFileNameOffset,
                                                AttrName,
                                                AttrTypeCode,
                                                CcbFlags,
                                                CreateFlags,
                                                ThisScb,
                                                ThisCcb );

                    //
                    //  Remember that this Scb was modified.
                    //

                    if ((Status != STATUS_PENDING) &&
                        (Status != STATUS_WAIT_FOR_OPLOCK) &&
                        (*ThisScb != NULL)) {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_MODIFIED );
                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB );
                    }

                } else {

                    //
                    //  We can't do any overwrite/supersede on R/O media.
                    //

                    Status = STATUS_MEDIA_WRITE_PROTECTED;
                }

            //
            //  Otherwise he is trying to create the attribute.
            //

            } else {

                Status = STATUS_OBJECT_NAME_COLLISION;
            }

        //
        //  The attribute doesn't exist.  If the user expected it to exist, we fail.
        //  Otherwise we call our routine to create an attribute.
        //

        } else if ((CreateDisposition == FILE_OPEN) ||
                   (CreateDisposition == FILE_OVERWRITE)) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;

        } else {

            //
            //  Perform the open check for this existing file.
            //

            Status = NtfsCheckExistingFile( IrpContext,
                                            IrpSp,
                                            ThisLcb,
                                            ThisFcb,
                                            (AttrTypeCode == $INDEX_ALLOCATION),
                                            CcbFlags );

            //
            //  End-of-name call to retrieve a reparse point.
            //  As NtfsOpenNewAttr has not access checks, we see whether we need to
            //  retrieve the reparse point here, prior to calling NtfsOpenNewAttr.
            //  The file information in ThisFcb tells whether this is a reparse point.
            //
            //  If we have succeded in the previous check and we do not have
            //  FILE_OPEN_REPARSE_POINT set, we retrieve the reparse point.
            //

            if (NT_SUCCESS( Status ) &&
                FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
                !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

                USHORT AttributeNameLength = 0;

                //
                //  We exclude the case when we get the $I30 name and $INDEX_ALLOCATION type
                //  as this is the standard manner of opening a directory.
                //

                if (!((AttrName.Length == NtfsFileNameIndex.Length) &&
                      (AttrTypeCode == $INDEX_ALLOCATION) &&
                      (RtlEqualMemory( AttrName.Buffer, NtfsFileNameIndex.Buffer, AttrName.Length )))) {

                    if (AttrName.Length > 0) {
                        ASSERT( AttrName.Length == ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeNameLength );
                        AttributeNameLength += AttrName.Length + 2;
                    }
                    if (((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength > 0) {
                        AttributeNameLength += ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength + 2;
                    }
                }
                DebugTrace( 0, Dbg, ("AttrTypeCode %x AttrName.Length (1) = %d AttributeCodeNameLength %d LastFileNameOffset %d\n",
                           AttrTypeCode, AttrName.Length, ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength, LastFileNameOffset) );

                Status = NtfsGetReparsePointValue( IrpContext,
                                                   Irp,
                                                   IrpSp,
                                                   ThisFcb,
                                                   AttributeNameLength );
            }

            //
            //  If this didn't fail and we did not encounter a reparse point,
            //  then attempt to create the stream.
            //

            if (NT_SUCCESS( Status ) &&
                (Status != STATUS_REPARSE)) {

                //
                //  Don't allow this operation on a system file (except the root directory which can have user data streams)
                //  or for anything other than user data streams
                //

                if ((FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
                     (NtfsSegmentNumber( &ThisFcb->FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER)) ||
                    (!NtfsIsTypeCodeUserData( AttrTypeCode ))) {

                    Status = STATUS_ACCESS_DENIED;

                } else if (!NtfsIsVolumeReadOnly( IrpContext->Vcb )) {

                    NtfsPostUsnChange( IrpContext, ThisFcb, USN_REASON_STREAM_CHANGE  );
                    Status = NtfsOpenNewAttr( IrpContext,
                                              Irp,
                                              IrpSp,
                                              ThisLcb,
                                              ThisFcb,
                                              LastFileNameOffset,
                                              AttrName,
                                              AttrTypeCode,
                                              FALSE,
                                              CcbFlags,
                                              TRUE,
                                              CreateFlags,
                                              ThisScb,
                                              ThisCcb );
                } else {

                    Status = STATUS_MEDIA_WRITE_PROTECTED;

                }
            }

            if (*ThisScb != NULL) {

                if (*ThisCcb != NULL) {

                    SetFlag( (*ThisCcb)->Flags,
                             CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
                }

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB );
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenExistingAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN BOOLEAN DirectoryOpen,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called to open an existing attribute.  We check the
    requested file access, the existance of
    an Ea buffer and the security on this file.  If these succeed then
    we check the batch oplocks and regular oplocks on the file.
    We also verify whether we need to retrieve a reparse point or not.
    If we have gotten this far, we simply call our routine to open the
    attribute.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ThisLcb - This is the Lcb used to reach this Fcb.

    ThisFcb - This is the Fcb to open.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CcbFlags - This is the flag field for the Ccb.

    CreateFlags - Indicates if this open is by file Id.

    DirectoryOpen - Indicates whether this open is a directory open or a data stream.

    NetworkInfo - If specified then this call is a fast open call to query
        the network information.  We don't update any of the in-memory structures
        for this.

    ThisScb - This is the address to store the address of the Scb.

    ThisCcb - This is the address to store the address of the Ccb.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS OplockStatus;

    SHARE_MODIFICATION_TYPE ShareModificationType;
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenExistingAttr:  Entered\n") );

    //
    //  For data streams we need to do a check that includes an oplock check.
    //  For directories we just need to figure the share modification type.
    //
    //  We also figure the type of open and the node type code based on the
    //  directory flag.
    //

    if (DirectoryOpen) {

        //
        //  Check for valid access on an existing file.
        //

        Status = NtfsCheckExistingFile( IrpContext,
                                        IrpSp,
                                        ThisLcb,
                                        ThisFcb,
                                        (AttrTypeCode == $INDEX_ALLOCATION),
                                        CcbFlags );

        ShareModificationType = (ThisFcb->CleanupCount == 0 ? SetShareAccess : CheckShareAccess);
        TypeOfOpen = UserDirectoryOpen;

    } else {

        //
        //  Don't break the batch oplock if opening to query the network info.
        //

        if (!ARGUMENT_PRESENT( NetworkInfo )) {

            Status = NtfsBreakBatchOplock( IrpContext,
                                           Irp,
                                           IrpSp,
                                           ThisFcb,
                                           AttrName,
                                           AttrTypeCode,
                                           ThisScb );

            if ((Status != STATUS_PENDING) && (Status != STATUS_WAIT_FOR_OPLOCK)) {

                if (NT_SUCCESS( Status = NtfsCheckExistingFile( IrpContext,
                                                                IrpSp,
                                                                ThisLcb,
                                                                ThisFcb,
                                                                (AttrTypeCode == $INDEX_ALLOCATION),
                                                                CcbFlags ))) {

                    Status = NtfsOpenAttributeCheck( IrpContext,
                                                     Irp,
                                                     IrpSp,
                                                     ThisScb,
                                                     &ShareModificationType );

                    TypeOfOpen = UserFileOpen ;
                }
            }

        //
        //  We want to perform the ACL check but not break any oplocks for the
        //  NetworkInformation query.
        //

        } else {

            Status = NtfsCheckExistingFile( IrpContext,
                                            IrpSp,
                                            ThisLcb,
                                            ThisFcb,
                                            (AttrTypeCode == $INDEX_ALLOCATION),
                                            CcbFlags );

            TypeOfOpen = UserFileOpen;

            ASSERT( NtfsIsTypeCodeUserData( AttrTypeCode ));
        }
    }

    //
    //  End-of-name call to retrieve a reparse point.
    //  The file information in ThisFcb tells whether this is a reparse point.
    //
    //  In three cases we proceed with the normal open for the file:
    //
    //  (1) When FILE_OPEN_REPARSE_POINT is set, as the caller wants a handle on the
    //      reparse point itself.
    //  (2) When we are retrieving the NetworkInfo, as then the caller can identify
    //      the reparse points and decide what to do, without having the need of apriori
    //      knowledge of where they are in the system.
    //      Note: when we retrieve NetworkInfo we can have FILE_OPEN_REPARSE_POINT set.
    //  (3) The data manipulation aspect of the DesiredAccess for this request was, exactly,
    //      FILE_READ_ATTRIBUTES, in which case we give a handle to the local entity.
    //
    //  Otherwise, we retrieve the value of the $REPARSE_POINT attribute.
    //
    //  Note: The logic in the if was re-arranged for performance. It used to read:
    //
    //        NT_SUCCESS( Status ) &&
    //        (Status != STATUS_PENDING) &&
    //        !ARGUMENT_PRESENT( NetworkInfo ) &&
    //        FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
    //        !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )
    //

    if ((Status != STATUS_PENDING) &&
        (Status != STATUS_WAIT_FOR_OPLOCK) &&
        FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
        NT_SUCCESS( Status ) &&
        !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

        USHORT AttributeNameLength = 0;

        //
        //  We exclude the case when we get the $I30 name and $INDEX_ALLOCATION type
        //  as this is the standard manner of opening a directory.
        //

        if (!((AttrName.Length == NtfsFileNameIndex.Length) &&
              (AttrTypeCode == $INDEX_ALLOCATION) &&
              (RtlEqualMemory( AttrName.Buffer, NtfsFileNameIndex.Buffer, AttrName.Length )))) {

             if (AttrName.Length > 0) {
                 ASSERT( AttrName.Length == ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeNameLength );
                 AttributeNameLength += AttrName.Length + 2;
             }
             if (((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength > 0) {
                AttributeNameLength += ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength + 2;
             }
        }
        DebugTrace( 0, Dbg, ("AttrTypeCode %x AttrName.Length (2) = %d AttributeCodeNameLength %d LastFileNameOffset %d\n",
                   AttrTypeCode, AttrName.Length, ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength, LastFileNameOffset) );

        Status = NtfsGetReparsePointValue( IrpContext,
                                           Irp,
                                           IrpSp,
                                           ThisFcb,
                                           AttributeNameLength );
    }

    //
    //  If we didn't post the Irp and we did not retrieve a reparse point
    //  and the operations above were successful, we proceed with the open.
    //

    if (NT_SUCCESS( Status ) &&
        (Status != STATUS_PENDING) &&
        (Status != STATUS_WAIT_FOR_OPLOCK) &&
        (Status != STATUS_REPARSE)) {

        //
        //  Now actually open the attribute.
        //

        OplockStatus = Status;

        Status = NtfsOpenAttribute( IrpContext,
                                    IrpSp,
                                    ThisFcb->Vcb,
                                    ThisLcb,
                                    ThisFcb,
                                    LastFileNameOffset,
                                    AttrName,
                                    AttrTypeCode,
                                    ShareModificationType,
                                    TypeOfOpen,
                                    FALSE,
                                    (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                     ? CcbFlags | CCB_FLAG_OPEN_BY_FILE_ID
                                     : CcbFlags),
                                    NetworkInfo,
                                    ThisScb,
                                    ThisCcb );

        //
        //  If there are no errors at this point, we set the caller's Iosb.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  We need to remember if the oplock break is in progress.
            //

            Status = OplockStatus;
            Irp->IoStatus.Information = FILE_OPENED;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOpenExistingAttr:  Exit -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOverwriteAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN BOOLEAN Supersede,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called to overwrite an existing attribute.  We do all of
    the same work as opening an attribute except that we can change the
    allocation of a file.  This routine will handle the case where a
    file is being overwritten and the case where just an attribute is
    being overwritten.  In the case of the former, we may change the
    file attributes of the file as well as modify the Ea's on the file.
    After doing all the access checks, we also verify whether we need to
    retrieve a reparse point or not.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisLcb - This is the Lcb we used to reach this Fcb.

    ThisFcb - This is the Fcb for the file being opened.

    Supersede - This indicates whether this is a supersede or overwrite
        operation.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CcbFlags - This is the flag field for the Ccb.

    CreateFlags - Indicates if this open is by file Id.

    ThisScb - This is the address to store the address of the Scb.

    ThisCcb - This is the address to store the address of the Ccb.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS OplockStatus;

    ULONG FileAttributes;
    ULONG PreviousFileAttributes;
    PACCESS_MASK DesiredAccess;
    ACCESS_MASK AddedAccess = 0;
    BOOLEAN MaximumRequested = FALSE;

    SHARE_MODIFICATION_TYPE ShareModificationType;

    PFILE_FULL_EA_INFORMATION FullEa = NULL;
    ULONG FullEaLength = 0;

    ULONG IncomingFileAttributes = 0;                               //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;   //  invalid value

    BOOLEAN DecrementScbCloseCount = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOverwriteAttr:  Entered\n") );

    DesiredAccess = &IrpSp->Parameters.Create.SecurityContext->DesiredAccess;

    if (FlagOn( *DesiredAccess, MAXIMUM_ALLOWED )) {

        MaximumRequested = TRUE;
    }

    //
    //  Check the oplock state of this file.
    //

    Status = NtfsBreakBatchOplock( IrpContext,
                                   Irp,
                                   IrpSp,
                                   ThisFcb,
                                   AttrName,
                                   AttrTypeCode,
                                   ThisScb );

    if ((Status == STATUS_WAIT_FOR_OPLOCK) || (Status == STATUS_PENDING)) {

        DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
        return Status;
    }

    //
    //  Remember the value of the file attribute flags and of the reparse point.
    //  If we succeed in NtfsRemoveReparsePoint but fail afterwards, we leave the duplicate
    //  information in an inconsistent state.
    //

    IncomingFileAttributes = ThisFcb->Info.FileAttributes;
    IncomingReparsePointTag = ThisFcb->Info.ReparsePointTag;

    //
    //  We first want to check that the caller's desired access and specified
    //  file attributes are compatible with the state of the file.  There
    //  are the two overwrite cases to consider.
    //
    //      OverwriteFile - The hidden and system bits passed in by the
    //          caller must match the current values.
    //
    //      OverwriteAttribute - We also modify the requested desired access
    //          to explicitly add the implicit access needed by overwrite.
    //
    //  We also check that for the overwrite attribute case, there isn't
    //  an Ea buffer specified.
    //

    if (FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

        BOOLEAN Hidden;
        BOOLEAN System;

        //
        //  Get the file attributes and clear any unsupported bits.
        //

        FileAttributes = (ULONG) IrpSp->Parameters.Create.FileAttributes;

        //
        //  Always set the archive bit in this operation.
        //

        SetFlag( FileAttributes, FILE_ATTRIBUTE_ARCHIVE );
        ClearFlag( FileAttributes,
                   ~FILE_ATTRIBUTE_VALID_SET_FLAGS | FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );

        if (IsEncrypted( &ThisFcb->Info )) {

            SetFlag( FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
        }

        DebugTrace( 0, Dbg, ("Checking hidden/system for overwrite/supersede\n") );

        Hidden = BooleanIsHidden( &ThisFcb->Info );
        System = BooleanIsSystem( &ThisFcb->Info );

        if ((Hidden && !FlagOn(FileAttributes, FILE_ATTRIBUTE_HIDDEN)
            ||
            System && !FlagOn(FileAttributes, FILE_ATTRIBUTE_SYSTEM))

                &&

            !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) {

            DebugTrace( 0, Dbg, ("The hidden and/or system bits do not match\n") );

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
            return Status;
        }

        //
        //  If the user specified an Ea buffer and they are Ea blind, we deny
        //  access.
        //

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_EA_KNOWLEDGE ) &&
            (Irp->AssociatedIrp.SystemBuffer != NULL)) {

            DebugTrace( 0, Dbg, ("This opener cannot create Ea's\n") );

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
            return Status;
        }

        //
        //  Add in the extra required access bits if we don't have restore privilege
        //  which would automatically grant them to us
        //

        if (!FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
            !FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

            SetFlag( AddedAccess,
                     (FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES) & ~(*DesiredAccess) );

            SetFlag( *DesiredAccess, FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES );
        }

    } else if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        DebugTrace( 0, Dbg, ("Can't specifiy an Ea buffer on an attribute overwrite\n") );

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
        return Status;
    }

    //
    //  Supersede or overwrite require specific access. We skip this step if we have the restore privilege
    //  which already grants these to us
    //

    if (!FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
        !FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

        ULONG NewAccess = FILE_WRITE_DATA;

        if (Supersede) {

            NewAccess = DELETE;
        }

        //
        //  Check if the user already has this new access.
        //

        if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                     NewAccess )) {

            SetFlag( AddedAccess,
                     NewAccess & ~(*DesiredAccess) );

            SetFlag( *DesiredAccess, NewAccess );
        }
    }

    //
    //  Check whether we can open this existing file.
    //

    Status = NtfsCheckExistingFile( IrpContext,
                                    IrpSp,
                                    ThisLcb,
                                    ThisFcb,
                                    (AttrTypeCode == $INDEX_ALLOCATION),
                                    CcbFlags );

    //
    //  If we have a success status then proceed with the oplock check and
    //  open the attribute.
    //

    if (NT_SUCCESS( Status )) {

        Status = NtfsOpenAttributeCheck( IrpContext,
                                         Irp,
                                         IrpSp,
                                         ThisScb,
                                         &ShareModificationType );

        //
        //  End-of-name call to retrieve a reparse point.
        //  The file information in ThisFcb tells whether this is a reparse point.
        //
        //  If we didn't post the Irp and the check operation was successful, and
        //  we do not have FILE_OPEN_REPARSE_POINT set, we retrieve the reparse point.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_WAIT_FOR_OPLOCK)) {

            //
            //  If we can't truncate the file size then return now.  Since
            //  NtfsRemoveDataAttributes will be truncating all the data
            //  streams for this file, we need to loop through any existing
            //  scbs we have to make sure they are all truncatable.
            //

            PSCB Scb = NULL;

            //
            //  We need to reset the share access once we open the file.  This is because
            //  we may have added WRITE or DELETE access into the granted bits and
            //  they may be reflected in the file object.  We don't want them
            //  present after the create.
            //

            if (ShareModificationType == UpdateShareAccess) {

                ShareModificationType = RecheckShareAccess;
            }

            //
            //  If we biased the desired access we need to remove the same
            //  bits from the granted access.  If maximum allowed was
            //  requested then we can skip this.
            //

            if (!MaximumRequested) {

                ClearFlag( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                           AddedAccess );
            }

            //
            //  Also remove the bits from the desired access field so we won't
            //  see them if this request gets posted for any reason.
            //

            ClearFlag( *DesiredAccess, AddedAccess );

            if (FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
                !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

                USHORT AttributeNameLength = 0;

                //
                //  We exclude the case when we get the $I30 name and $INDEX_ALLOCATION type
                //  as this is the standard manner of opening a directory.
                //

                if (!((AttrName.Length == NtfsFileNameIndex.Length) &&
                      (AttrTypeCode == $INDEX_ALLOCATION) &&
                      (RtlEqualMemory( AttrName.Buffer, NtfsFileNameIndex.Buffer, AttrName.Length )))) {

                    if (AttrName.Length > 0) {
                        ASSERT( AttrName.Length == ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeNameLength );
                        AttributeNameLength += AttrName.Length + 2;
                    }
                    if (((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength > 0) {
                        AttributeNameLength += ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength + 2;
                    }
                }
                DebugTrace( 0, Dbg, ("AttrTypeCode %x AttrName.Length (3) = %d AttributeCodeNameLength %d LastFileNameOffset %d\n",
                           AttrTypeCode, AttrName.Length, ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength, LastFileNameOffset) );

                Status = NtfsGetReparsePointValue( IrpContext,
                                                   Irp,
                                                   IrpSp,
                                                   ThisFcb,
                                                   AttributeNameLength );

                //
                //  Exit if we failed or this is a reparse point.
                //

                if (!NT_SUCCESS( Status ) || (Status == STATUS_REPARSE)) {

                    return Status;
                }
            }

            //
            //  Reference the Fcb so it doesn't go away.
            //

            InterlockedIncrement( &ThisFcb->CloseCount );

            //
            //  Use a try-finally to restore the close count correctly.
            //

            try {

                //
                //  Make sure the current Scb doesn't get deallocated in the test below.
                //

                if (*ThisScb != NULL) {

                    InterlockedIncrement( &(*ThisScb)->CloseCount );
                    DecrementScbCloseCount = TRUE;
                }

                while (TRUE) {

                    Scb = NtfsGetNextChildScb( ThisFcb, Scb );

                    if (Scb == NULL) { break; }

                    InterlockedIncrement( &Scb->CloseCount );
                    if (!MmCanFileBeTruncated( &(Scb)->NonpagedScb->SegmentObject,
                                               &Li0 )) {

                        Status = STATUS_USER_MAPPED_FILE;
                        DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );

                        //
                        //  The Scb close count will get decremented when we test
                        //  for Scb != NULL below.
                        //

                        try_return( Status );
                    }
                    InterlockedDecrement( &Scb->CloseCount );
                }

                //
                //  Remember the status from the oplock check.
                //

                OplockStatus = Status;

                //
                //  We perform the on-disk changes.  For a file overwrite, this includes
                //  the Ea changes and modifying the file attributes.  For an attribute,
                //  this refers to modifying the allocation size.  We need to keep the
                //  Fcb updated and remember which values we changed.
                //

                if (Irp->AssociatedIrp.SystemBuffer != NULL) {

                    //
                    //  Remember the values in the Irp.
                    //

                    FullEa = (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
                    FullEaLength = IrpSp->Parameters.Create.EaLength;
                }

                //
                //  Now do the file attributes and either remove or mark for
                //  delete all of the other $DATA attributes on the file.
                //

                if (FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                    //
                    //  When appropriate, delete the reparse point attribute.
                    //  This needs to be done prior to any modification to the Fcb, as we use
                    //  the value of the reparse point tag stored in ThisFcb.Info
                    //

                    if (FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                        //
                        //  Verify that the volume is of the appropriate kind.
                        //  Otherwise access a non-existing index.
                        //

                        if (!NtfsVolumeVersionCheck( ThisFcb->Vcb, NTFS_REPARSE_POINT_VERSION )) {

                            //
                            //  Return a volume not upgraded error.
                            //

                            Status = STATUS_VOLUME_NOT_UPGRADED;
                            DebugTrace( 0, Dbg, ("Trying to delete a reparse point in a back-level volume.\n") );
                            DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );

                            try_return( Status );
                        }

                        //
                        //  Remove the reparse point attribute.
                        //

                        NtfsRemoveReparsePoint( IrpContext,
                                                ThisFcb );

                        //
                        //  NtfsRemoveReparsPoint will commit if it removes the reparse point.  Update our
                        //  captured info values if there is no transaction.
                        //

                        if (IrpContext->TransactionId == 0) {

                            IncomingFileAttributes = ThisFcb->Info.FileAttributes;
                            IncomingReparsePointTag = ThisFcb->Info.ReparsePointTag;
                        }
                    }

                    //
                    //  This needs to happen after we delete the reparse point attribute to not
                    //  alter the value of the reparse point tag stored in ThisFcb.Info
                    //  Replace the current Ea's on the file.  This operation will update
                    //  the Fcb for the file.
                    //

                    NtfsAddEa( IrpContext,
                               ThisFcb->Vcb,
                               ThisFcb,
                               FullEa,
                               FullEaLength,
                               &Irp->IoStatus );

                    //
                    //  Copy the directory bit from the current Info structure.
                    //

                    if (IsDirectory( &ThisFcb->Info)) {

                        SetFlag( FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );
                    }

                    //
                    //  Copy the view index bit from the current Info structure.
                    //

                    if (IsViewIndex( &ThisFcb->Info)) {

                        SetFlag( FileAttributes, DUP_VIEW_INDEX_PRESENT );
                    }

                    //
                    //  Remember the previous file attribute to capture the
                    //  state of the CONTENT_INDEX flag.
                    //

                    PreviousFileAttributes = ThisFcb->Info.FileAttributes;

                    //
                    //  Now either add to the current attributes or replace them.
                    //

                    if (Supersede) {

                        ThisFcb->Info.FileAttributes = FileAttributes;

                    } else {

                        ThisFcb->Info.FileAttributes |= FileAttributes;
                    }

                    //
                    //  Get rid of any named $DATA attributes in the file.
                    //

                    NtfsRemoveDataAttributes( IrpContext,
                                              ThisFcb,
                                              ThisLcb,
                                              IrpSp->FileObject,
                                              LastFileNameOffset,
                                              CreateFlags );

                    //
                    //  Check if the CONTENT_INDEX bit changed.
                    //

                    ASSERT( *ThisScb != NULL );

                    if (FlagOn( PreviousFileAttributes ^ ThisFcb->Info.FileAttributes,
                                FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )) {

                        NtfsPostUsnChange( IrpContext, *ThisScb, USN_REASON_INDEXABLE_CHANGE );
                    }
                }
// **** CONSIDER SETTING SCB ENCRYPTED FLAG HERE??? ****
                //
                //  Now we perform the operation of opening the attribute.
                //

                NtfsReplaceAttribute( IrpContext,
                                      IrpSp,
                                      ThisFcb,
                                      *ThisScb,
                                      ThisLcb,
                                      *(PLONGLONG)&Irp->Overlay.AllocationSize );

                NtfsPostUsnChange( IrpContext, *ThisScb, USN_REASON_DATA_TRUNCATION );

                //
                //  If we are overwriting a fle and the user doesn't want it marked as
                //  compressed, then change the attribute flag.
                //  If we are overwriting a file and its previous state was sparse
                //  then also clear the sparse flag.
                //

                if (FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                    if (!FlagOn( (*ThisScb)->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                        ClearFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
                    }

                    if (!FlagOn( (*ThisScb)->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                        ClearFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
                    }
                }

                //
                //  Now attempt to open the attribute.
                //

                ASSERT( NtfsIsTypeCodeUserData( AttrTypeCode ));

                Status = NtfsOpenAttribute( IrpContext,
                                            IrpSp,
                                            ThisFcb->Vcb,
                                            ThisLcb,
                                            ThisFcb,
                                            LastFileNameOffset,
                                            AttrName,
                                            AttrTypeCode,
                                            ShareModificationType,
                                            UserFileOpen,
                                            FALSE,
                                            (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                             ? CcbFlags | CCB_FLAG_OPEN_BY_FILE_ID
                                             : CcbFlags),
                                            NULL,
                                            ThisScb,
                                            ThisCcb );

            try_exit:  NOTHING;
            } finally {

                //
                //  Roll back any temporary changes to the close counts.
                //

                if (DecrementScbCloseCount) {

                    InterlockedDecrement( &(*ThisScb)->CloseCount );
                }

                if (Scb != NULL) {

                    InterlockedDecrement( &Scb->CloseCount );
                }
                InterlockedDecrement( &ThisFcb->CloseCount );

                //
                //  Need to roll-back the value of the reparse point flag in case of
                //  problems.
                //

                if (AbnormalTermination()) {

                   ThisFcb->Info.FileAttributes = IncomingFileAttributes;
                   ThisFcb->Info.ReparsePointTag = IncomingReparsePointTag;
                }
            }

            if (NT_SUCCESS( Status )) {

                //
                //  Set the flag in the Scb to indicate that the size of the
                //  attribute has changed.
                //

                SetFlag( (*ThisScb)->ScbState, SCB_STATE_NOTIFY_RESIZE_STREAM );

                //
                //  Since this is an supersede/overwrite, purge the section
                //  so that mappers will see zeros.
                //

                CcPurgeCacheSection( IrpSp->FileObject->SectionObjectPointer,
                                     NULL,
                                     0,
                                     FALSE );

                //
                //  Remember the status of the oplock in the success code.
                //

                Status = OplockStatus;

                //
                //  Now update the Iosb information.
                //

                if (Supersede) {

                    Irp->IoStatus.Information = FILE_SUPERSEDED;

                } else {

                    Irp->IoStatus.Information = FILE_OVERWRITTEN;
                }
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenNewAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN BOOLEAN LogIt,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called to create a new attribute on the disk.
    All access and security checks have been done outside of this
    routine, all we do is create the attribute and open it.
    We test if the attribute will fit in the Mft record.  If so we
    create it there.  Otherwise we call the create attribute through
    allocation.

    We then open the attribute with our common routine.  In the
    resident case the Scb will have all file values set to
    the allocation size.  We set the valid data size back to zero
    and mark the Scb as truncate on close.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisLcb - This is the Lcb we used to reach this Fcb.

    ThisFcb - This is the Fcb for the file being opened.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CreateFile - Indicates if we are in the create file path.

    CcbFlags - This is the flag field for the Ccb.

    LogIt - Indicates if we need to log the create operations.

    CreateFlags - Indicates if this open is related to a OpenByFile open.

    ThisScb - This is the address to store the address of the Scb.

    ThisCcb - This is the address to store the address of the Ccb.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN ScbExisted;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenNewAttr:  Entered\n") );

    //
    //  Check that the attribute name is legal.  The only restriction is the name length.
    //

    if (AttrName.Length > NTFS_MAX_ATTR_NAME_LEN * sizeof( WCHAR )) {

        DebugTrace( -1, Dbg, ("NtfsOpenNewAttr:  Exit -> %08lx\n", Status) );
        return STATUS_OBJECT_NAME_INVALID;
    }

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We create the Scb because we will use it.
        //

        *ThisScb = NtfsCreateScb( IrpContext,
                                  ThisFcb,
                                  AttrTypeCode,
                                  &AttrName,
                                  FALSE,
                                  &ScbExisted );

        //
        //  An attribute has gone away but the Scb hasn't left yet.
        //  Also mark the header as unitialized.
        //

        ClearFlag( (*ThisScb)->ScbState, SCB_STATE_HEADER_INITIALIZED |
                                         SCB_STATE_ATTRIBUTE_RESIDENT |
                                         SCB_STATE_FILE_SIZE_LOADED );

        //
        //  If we're creating an alternate stream in an encrypted file, and the
        //  loaded encryption driver wants the stream to be encrypted and uncompressed,
        //  we need to make sure the new stream is indeed created uncompressed.
        //

        if (IsEncrypted( &ThisFcb->Info ) &&
            (FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS | ENCRYPTION_ALLOW_COMPRESSION ) == ENCRYPTION_ALL_STREAMS)) {

            DebugTrace( 0, Dbg, ("Encrypted file, creating alternate stream uncompressed") );
            SetFlag( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION );
        }

        //
        //  Create the attribute on disk and update the Scb and Fcb.
        //

        NtfsCreateAttribute( IrpContext,
                             IrpSp,
                             ThisFcb,
                             *ThisScb,
                             ThisLcb,
                             *(PLONGLONG)&Irp->Overlay.AllocationSize,
                             LogIt,
                             FALSE,
                             NULL );

        //
        //  Now actually open the attribute.
        //

        ASSERT( NtfsIsTypeCodeUserData( AttrTypeCode ));

        Status = NtfsOpenAttribute( IrpContext,
                                    IrpSp,
                                    ThisFcb->Vcb,
                                    ThisLcb,
                                    ThisFcb,
                                    LastFileNameOffset,
                                    AttrName,
                                    AttrTypeCode,
                                    (ThisFcb->CleanupCount != 0 ? CheckShareAccess : SetShareAccess),
                                    UserFileOpen,
                                    CreateFile,
                                    (CcbFlags | (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID ) ? CCB_FLAG_OPEN_BY_FILE_ID : 0)),
                                    NULL,
                                    ThisScb,
                                    ThisCcb );

        //
        //  If there are no errors at this point, we set the caller's Iosb.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Read the attribute information from the disk.
            //

            NtfsUpdateScbFromAttribute( IrpContext, *ThisScb, NULL );

            //
            //  Set the flag to indicate that we created a stream and also remember to
            //  to check if we need to truncate on close.
            //

            NtfsAcquireFsrtlHeader( *ThisScb );
            SetFlag( (*ThisScb)->ScbState,
                     SCB_STATE_TRUNCATE_ON_CLOSE | SCB_STATE_NOTIFY_ADD_STREAM );

            //
            //  If we created a temporary stream then mark the Scb.
            //

            if (FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

                SetFlag( (*ThisScb)->ScbState, SCB_STATE_TEMPORARY );
                SetFlag( IrpSp->FileObject->Flags, FO_TEMPORARY_FILE );
            }

            NtfsReleaseFsrtlHeader( *ThisScb );

            Irp->IoStatus.Information = FILE_CREATED;
        }

    } finally {

        DebugUnwind( NtfsOpenNewAttr );

        //
        //  Uninitialize the attribute context.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsOpenNewAttr:  Exit -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

BOOLEAN
NtfsParseNameForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING String,
    IN OUT PUNICODE_STRING FileObjectString,
    IN OUT PUNICODE_STRING OriginalString,
    IN OUT PUNICODE_STRING NewNameString,
    IN PCREATE_CONTEXT CreateContext,
    OUT PUNICODE_STRING AttrName,
    OUT PATTRIBUTE_TYPE_CODE AttrCode
    )

/*++

Routine Description:

    This routine parses the input string and remove any intermediate
    named attributes from intermediate nodes.  It verifies that all
    intermediate nodes specify the file name index attribute if any
    at all.  On output it will store the modified string which contains
    component names only, into the file object name pointer pointer.  It is legal
    for the last component to have attribute strings.  We pass those
    back via the attribute name strings.  We also construct the string to be stored
    back in the file object if we need to post this request.

Arguments:

    String - This is the string to normalize.

    FileObjectString - We store the normalized string into this pointer, removing the
        attribute and attribute code strings from all component.

    OriginalString - This is the same as the file object string except we append the
        attribute name and attribute code strings.  We assume that the buffer for this
        string is the same as the buffer for the FileObjectString.

    NewNameString - This is the string which contains the full name being parsed.
        If the buffer is different than the buffer for the Original string then any
        character shifts will be duplicated here.

    CreateContext - create context contains the flags field

    AttrName - We store the attribute name specified in the last component
        in this string.

    AttrCode - We store the attribute type  specified in the last
        component in this string if there is any. We'll also mark the create context flags
        with a flag if there was one

Return Value:

    BOOLEAN - TRUE if the path is legal, FALSE otherwise.

--*/

{
    PARSE_TERMINATION_REASON TerminationReason;
    UNICODE_STRING ParsedPath;

    NTFS_NAME_DESCRIPTOR NameDescript;

    BOOLEAN RemovedComplexName = FALSE;

    LONG FileObjectIndex;
    LONG NewNameIndex;

    BOOLEAN SameBuffers = (OriginalString->Buffer == NewNameString->Buffer);

    PCUNICODE_STRING TestAttrName;
    PCUNICODE_STRING TestAttrCodeName;

    POPLOCK_CLEANUP OplockCleanup = IrpContext->Union.OplockCleanup;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsParseNameForCreate:  Entered\n") );

    //
    //  We loop through the input string calling ParsePath to swallow the
    //  biggest chunk we can.  The main case we want to deal with is
    //  when we encounter a non-simple name.  If this is not the
    //  final component, the attribute name and code type better
    //  indicate that this is a directory.  The only other special
    //  case we consider is the case where the string is an
    //  attribute only.  This is legal only for the first component
    //  of the file, and then only if there is no leading backslash.
    //

    //
    //  Initialize some return values.
    //

    AttrName->Length = 0;
    *AttrCode = $UNUSED;

    //
    //  Set up the indexes into our starting file object string.
    //

    FileObjectIndex = (LONG) FileObjectString->Length - (LONG) String.Length;
    NewNameIndex = (LONG) NewNameString->Length - (LONG) String.Length;

    //
    //  We don't allow trailing colons.
    //

    if (String.Buffer[(String.Length / sizeof( WCHAR )) - 1] == L':') {

        return FALSE;
    }

    if (String.Length != 0) {

        while (TRUE) {

            //
            //  Parse the next chunk in the input string.
            //

            TerminationReason = NtfsParsePath( String,
                                               FALSE,
                                               &ParsedPath,
                                               &NameDescript,
                                               &String );

            //
            //  Analyze the termination reason to discover if we can abort the
            //  parse process.
            //

            switch (TerminationReason) {

            case NonSimpleName :

                //
                //  We will do the work below.
                //

                break;

            case IllegalCharacterInName :
            case VersionNumberPresent :
            case MalFormedName :

                //
                //  We simply return an error.
                //

                DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Illegal character\n") );
                return FALSE;

            case AttributeOnly :

                //
                //  This is legal only if it is the only component of a relative open.  We
                //  test this by checking that we are at the end of string and the file
                //  object name has a lead in ':' character or this is the root directory
                //  and the lead in characters are '\:'.
                //

                if ((String.Length != 0) ||
                    RemovedComplexName ||
                    (FileObjectString->Buffer[0] == L'\\' ?
                     FileObjectString->Buffer[1] != L':' :
                     FileObjectString->Buffer[0] != L':')) {

                    DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Illegal character\n") );
                    return FALSE;
                }

                //
                //  We can drop down to the EndOfPath case as it will copy over
                //  the parsed path portion.
                //

            case EndOfPathReached :

                NOTHING;
            }

            //
            //  We add the filename part of the non-simple name to the parsed
            //  path.  Check if we can include the separator.
            //

            if ((TerminationReason != EndOfPathReached)
                && (FlagOn( NameDescript.FieldsPresent, FILE_NAME_PRESENT_FLAG ))) {

                if (ParsedPath.Length > sizeof( WCHAR )
                    || (ParsedPath.Length == sizeof( WCHAR )
                        && ParsedPath.Buffer[0] != L'\\')) {

                    ParsedPath.Length += sizeof( WCHAR );
                }

                ParsedPath.Length += NameDescript.FileName.Length;
            }

            FileObjectIndex += ParsedPath.Length;
            NewNameIndex += ParsedPath.Length;

            //
            //  If the remaining string is empty, then we remember any attributes and
            //  exit now.
            //

            if (String.Length == 0) {

                //
                //  If the name specified either an attribute or attribute
                //  name, we remember them.
                //

                if (FlagOn( NameDescript.FieldsPresent, ATTRIBUTE_NAME_PRESENT_FLAG )) {

                    *AttrName = NameDescript.AttributeName;
                }

                if (FlagOn( NameDescript.FieldsPresent, ATTRIBUTE_TYPE_PRESENT_FLAG )) {

                    SetFlag( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE );

                    if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_IGNORE_CASE )) {
                        NtfsUpcaseName( IrpContext->Vcb->UpcaseTable, IrpContext->Vcb->UpcaseTableSize, &NameDescript.AttributeType );
                    }

                    *AttrCode = NtfsGetAttributeTypeCode( IrpContext->Vcb, &NameDescript.AttributeType );

                    //
                    //  Reject names with $UNUSED in them
                    //

                    if (*AttrCode == $UNUSED) {
                        return FALSE;
                    }

                    OplockCleanup->AttributeCodeNameLength = NameDescript.AttributeType.Length;
                }
                break;
            }

            //
            //  This can only be the non-simple case.  If there is more to the
            //  name, then the attributes better describe a directory.  We also shift the
            //  remaining bytes of the string down.
            //

            ASSERT( FlagOn( NameDescript.FieldsPresent, ATTRIBUTE_NAME_PRESENT_FLAG | ATTRIBUTE_TYPE_PRESENT_FLAG ));

            TestAttrName = FlagOn( NameDescript.FieldsPresent,
                                   ATTRIBUTE_NAME_PRESENT_FLAG )
                           ? &NameDescript.AttributeName
                           : &NtfsEmptyString;

            TestAttrCodeName = FlagOn( NameDescript.FieldsPresent,
                                       ATTRIBUTE_TYPE_PRESENT_FLAG )
                               ? &NameDescript.AttributeType
                               : &NtfsEmptyString;

            //
            //  Valid Complex names are [$I30]:$INDEX_ALLOCATION
            //                          [$I30]:$BITMAP
            //                          :$ATTRIBUTE_LIST
            //                          :$REPARSE_POINT
            //

            if (!NtfsVerifyNameIsDirectory( IrpContext,
                                            TestAttrName,
                                            TestAttrCodeName ) &&

                !NtfsVerifyNameIsBitmap( IrpContext,
                                         TestAttrName,
                                         TestAttrCodeName ) &&

                !NtfsVerifyNameIsAttributeList( IrpContext,
                                                TestAttrName,
                                                TestAttrCodeName ) &&

                !NtfsVerifyNameIsReparsePoint( IrpContext,
                                                TestAttrName,
                                                TestAttrCodeName )) {

                DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Invalid intermediate component\n") );
                return FALSE;
            }

            RemovedComplexName = TRUE;

            //
            //  We need to insert a separator and then move the rest of the string
            //  down.
            //

            FileObjectString->Buffer[FileObjectIndex / sizeof( WCHAR )] = L'\\';

            if (!SameBuffers) {

                NewNameString->Buffer[NewNameIndex / sizeof( WCHAR )] = L'\\';
            }

            FileObjectIndex += sizeof( WCHAR );
            NewNameIndex += sizeof( WCHAR );

            RtlMoveMemory( &FileObjectString->Buffer[FileObjectIndex / sizeof( WCHAR )],
                           String.Buffer,
                           String.Length );

            if (!SameBuffers) {

                RtlMoveMemory( &NewNameString->Buffer[NewNameIndex / sizeof( WCHAR )],
                               String.Buffer,
                               String.Length );
            }

            String.Buffer = &NewNameString->Buffer[NewNameIndex / sizeof( WCHAR )];
        }
    }

    //
    //  At this point the original string is the same as the file object string.
    //

    FileObjectString->Length = (USHORT) FileObjectIndex;
    NewNameString->Length = (USHORT) NewNameIndex;

    OriginalString->Length = FileObjectString->Length;

    //
    //  We want to store the attribute index values in the original name
    //  string.  We just need to extend the original name length.
    //

    if ((AttrName->Length != 0) ||
        FlagOn( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE )) {

        OriginalString->Length += (2 + AttrName->Length);

        if (FlagOn( CreateContext->CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE )) {

            OriginalString->Length += (2 + NameDescript.AttributeType.Length);
        }
    }

    //
    //  Store in the OPLOCK_CLEANUP structure the lengths of the names of the attribute and
    //  of the code.
    //

    OplockCleanup->AttributeNameLength = AttrName->Length;

    DebugTrace( 0, Dbg, ("AttrName->Length %d AttrCodeName->Length %d\n", OplockCleanup->AttributeNameLength, OplockCleanup->AttributeCodeNameLength) );
    DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Exit\n") );

    return TRUE;
}


//
//  Local support routine.
//

BOOLEAN
NtfsCheckValidFileAccess(
    IN PFCB ThisFcb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Common routine used to rule out access to files in open path. This only disallows
    always invalid open reqests / acl checks, oplocks sharing are done elsewhere

              Fail immediately if this is a special system file or the user wants an illegal access.

              We allow READ_ATTRIBUTES and some ACL access to a subset of system files.  Deny all
              access to the following files.

                USN Journal
                Volume Log File
                Volume Bitmap
                Boot File
                Bad Cluster File
                As of now undefined system files

             Check for supersede/overwrite first.


Arguments:

    Fcb - Address of the Fcb pointer where the $REPARSE_POINT attribute is located.

    IrpSp - This is the Irp stack pointer for the filesystem.

Return Value:

    TRUE if access is allowed

--*/
{
    ULONG CreateDisposition = (UCHAR) ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);
    ULONG InvalidAccess;
    BOOLEAN Result = TRUE;

    PAGED_CODE()

    //
    //  Verify we don't have the system flag set on the root.
    //

    ASSERT( NtfsSegmentNumber( &ThisFcb->FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER );

    if ((CreateDisposition == FILE_SUPERSEDE) ||
        (CreateDisposition == FILE_OVERWRITE) ||
        (CreateDisposition == FILE_OVERWRITE_IF) ||

        //
        //  Check for special system files.
        //

        (NtfsSegmentNumber( &ThisFcb->FileReference ) == LOG_FILE_NUMBER) ||
        (NtfsSegmentNumber( &ThisFcb->FileReference ) == BIT_MAP_FILE_NUMBER) ||
        (NtfsSegmentNumber( &ThisFcb->FileReference ) == BOOT_FILE_NUMBER) ||
        (NtfsSegmentNumber( &ThisFcb->FileReference ) == BAD_CLUSTER_FILE_NUMBER) ||
        FlagOn( ThisFcb->FcbState, FCB_STATE_USN_JOURNAL ) ||

        //
        //  Check for currently undefined system files.
        //

        ((NtfsSegmentNumber( &ThisFcb->FileReference ) < FIRST_USER_FILE_NUMBER) &&
         (NtfsSegmentNumber( &ThisFcb->FileReference ) > LAST_SYSTEM_FILE_NUMBER))) {

        Result = FALSE;

    } else {

        //
        //  If we are beyond the reserved range then use the ACL to protect the file.
        //

        if (NtfsSegmentNumber( &ThisFcb->FileReference ) >= FIRST_USER_FILE_NUMBER) {

            InvalidAccess = 0;

        //
        //  If we are looking at the $Extend directory then permit the ACL operations.
        //

        } else if (NtfsSegmentNumber( &ThisFcb->FileReference ) == EXTEND_NUMBER) {

            InvalidAccess = ~(FILE_READ_ATTRIBUTES | SYNCHRONIZE | READ_CONTROL | WRITE_DAC | WRITE_OWNER);

        //
        //  Otherwise restrict access severely.
        //

        } else {

            InvalidAccess = ~(FILE_READ_ATTRIBUTES | SYNCHRONIZE);
        }

        if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess, InvalidAccess )) {

            Result = FALSE;
        }
    }

    return Result;
}


NTSTATUS
NtfsCheckValidAttributeAccess (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PDUPLICATED_INFORMATION Info OPTIONAL,
    IN OUT PUNICODE_STRING AttrName,
    IN OUT PATTRIBUTE_TYPE_CODE AttrCode,
    IN ULONG CreateFlags,
    OUT PULONG CcbFlags,
    OUT PBOOLEAN IndexedAttribute
    )

/*++

Routine Description:

    This routine looks at the file, the specified attribute name and
    code to determine if an attribute of this file may be opened
    by this user.  If there is a conflict between the file type
    and the attribute name and code, or the specified type of attribute
    (directory/nondirectory) we will return FALSE.
    We also check that the attribute code string is defined for the
    volume at this time.

    The final check of this routine is just whether a user is allowed
    to open the particular attribute or if Ntfs will guard them.

Arguments:

    IrpSp - This is the stack location for this open.

    Vcb - This is the Vcb for this volume.

    Info - If specified, this is the duplicated information for this file.

    AttrName - This is the attribute name specified.

    AttrCode - This is the attribute type to use to open the attribute - we will
        replace with the real type if it hasn't been specified yet.

    AttrTypeCode - Used to store the attribute type code determined here.

    CreateFlags - Create flags - we care about the trailing backslash

    CcbFlags - We set the Ccb flags here to store in the Ccb later.

    IndexedAttribute - Set to indicate the type of open.

Return Value:

    NTSTATUS - STATUS_SUCCESS if access is allowed, the status code indicating
        the reason for denial otherwise.

--*/

{
    BOOLEAN Indexed;
    ULONG  CreateDisposition =  ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckValidAttributeAccess:  Entered\n") );

    //
    //  If the user specified a attribute code string, we find the
    //  corresponding attribute.  If there is no matching attribute
    //  type code then we report that this access is invalid.
    //

    if (FlagOn( CreateFlags, CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE )) {

        ASSERT( (*AttrCode) != $UNUSED );

        if ((*AttrCode) == $INDEX_ALLOCATION) {

            if (AttrName->Length != 0) {

                if (NtfsAreNamesEqual( Vcb->UpcaseTable, AttrName, &NtfsFileNameIndex, TRUE )) {

                    AttrName->Length = 0;

                } else {

                    //
                    //  This isn't a filename index, so it better be a view index.
                    //

                    if (!ARGUMENT_PRESENT(Info) || !IsViewIndex( Info )) {

                        DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Bad name for index allocation\n") );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

        } else if (*AttrCode != $DATA) {

            //
            //  never allow supersede  on any other name attributes
            //

            if ((CreateDisposition == FILE_SUPERSEDE) ||
                (CreateDisposition == FILE_OVERWRITE) ||
                (CreateDisposition == FILE_OVERWRITE_IF))  {

                return STATUS_ACCESS_DENIED;
            }
        }
    }

    //
    //  Pull some values out of the Irp and IrpSp.
    //

    Indexed = BooleanFlagOn( IrpSp->Parameters.Create.Options,
                             FILE_DIRECTORY_FILE );

    //
    //  We need to determine whether the user expects to open an
    //  indexed or non-indexed attribute.  If either of the
    //  directory/non-directory flags in the Irp stack are set,
    //  we will use those.
    //
    //  Otherwise we need to examine some of the other input parameters.
    //  We have the following information:
    //
    //      1 - We may have a duplicated information structure for the file.
    //          (Not present on a create).
    //      2 - The user specified the name with a trailing backslash.
    //      3 - The user passed in an attribute name.
    //      4 - The user passed in an attribute type.
    //
    //  We first look at the attribute type code and name.  If they are
    //  both unspecified we determine the type of access by following
    //  the following steps.
    //
    //      1 - If there is a duplicated information structure we
    //          set the code to $INDEX_ALLOCATION and remember
    //          this is indexed.  Otherwise this is a $DATA
    //          attribute.
    //
    //      2 - If there is a trailing backslash we assume this is
    //          an indexed attribute.
    //
    //  If have an attribute code type or name, then if the code type is
    //  $INDEX_ALLOCATION without a name this is an indexed attribute.
    //  Otherwise we assume a non-indexed attribute.
    //

    if (!FlagOn( IrpSp->Parameters.Create.Options,
                    FILE_NON_DIRECTORY_FILE | FILE_DIRECTORY_FILE) &&
        (AttrName->Length == 0)) {

        if (*AttrCode == $UNUSED) {

            if (ARGUMENT_PRESENT( Info )) {

                Indexed = BooleanIsDirectory( Info );

            } else {

                Indexed = FALSE;
            }

        } else if (*AttrCode == $INDEX_ALLOCATION) {

            Indexed = TRUE;
        }

    } else if (*AttrCode == $INDEX_ALLOCATION) {

        Indexed = TRUE;
    }

    //
    //  If the type code was unspecified, we can assume it from the attribute
    //  name and the type of the file.  If the file is a directory and
    //  there is no attribute name, we assume this is an indexed open.
    //  Otherwise it is a non-indexed open.
    //

    if (*AttrCode == $UNUSED) {

        if (Indexed && AttrName->Length == 0) {

            *AttrCode = $INDEX_ALLOCATION;

        } else {

            *AttrCode = $DATA;
        }
    }

    //
    //  If the user specified directory all we need to do is check the
    //  following condition.
    //
    //      1 - If the file was specified, it must be a directory.
    //      2 - The attribute type code must be $INDEX_ALLOCATION with either:
    //             no attribute name
    //                    or
    //             duplicate info present & view index bit set in dupe info
    //      3 - The user isn't trying to open the volume.
    //

    if (Indexed) {

        if ((*AttrCode != $INDEX_ALLOCATION) ||

                ((AttrName->Length != 0) &&
                 ((!ARGUMENT_PRESENT( Info )) || !IsViewIndex( Info )))) {

            DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Conflict in directory\n") );
            return STATUS_NOT_A_DIRECTORY;

        //
        //  If there is a current file and it is not a directory and
        //  the caller wanted to perform a create.  We return
        //  STATUS_OBJECT_NAME_COLLISION, otherwise we return STATUS_NOT_A_DIRECTORY.
        //

        } else if (ARGUMENT_PRESENT( Info ) &&
                   !IsDirectory( Info ) &&
                   !IsViewIndex( Info)) {

            if (((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff) == FILE_CREATE) {

                return STATUS_OBJECT_NAME_COLLISION;

            } else {

                return STATUS_NOT_A_DIRECTORY;
            }
        }

        SetFlag( *CcbFlags, CCB_FLAG_OPEN_AS_FILE );

    //
    //  If the user specified a non-directory that means he is opening a non-indexed
    //  attribute.  We check for the following condition.
    //
    //      1 - Only the unnamed data attribute may be opened for a volume.
    //      2 - We can't be opening an unnamed $INDEX_ALLOCATION attribute.
    //

    } else {

        //
        //  Now determine if we are opening the entire file.
        //

        if (*AttrCode == $DATA) {

            if (AttrName->Length == 0) {
                SetFlag( *CcbFlags, CCB_FLAG_OPEN_AS_FILE );
            }

        } else {

            //
            //  For all other attributes only support read attributes access
            //

            if (IrpSp->Parameters.Create.SecurityContext->AccessState->OriginalDesiredAccess & ~(FILE_READ_ATTRIBUTES | SYNCHRONIZE)) {

                return STATUS_ACCESS_DENIED;
            }
        }

        if (ARGUMENT_PRESENT( Info ) &&
            IsDirectory( Info ) &&
            FlagOn( *CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

            DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Can't open directory as file\n") );
            return STATUS_FILE_IS_A_DIRECTORY;
        }
    }

    //
    //  If we make it this far, lets check that we will allow access to
    //  the attribute specified.  Typically we only allow the user to
    //  access non system files.  Also only the Data attributes and
    //  attributes created by the user may be opened.  We will protect
    //  these with boolean flags to allow the developers to enable
    //  reading any attributes.
    //

    if (NtfsProtectSystemAttributes) {

        if (!NtfsIsTypeCodeUserData( *AttrCode ) &&
            ((*AttrCode != $INDEX_ALLOCATION) || !Indexed) &&
            (*AttrCode != $BITMAP) &&
            (*AttrCode != $ATTRIBUTE_LIST) &&
            (*AttrCode != $REPARSE_POINT) &&
            (*AttrCode < $FIRST_USER_DEFINED_ATTRIBUTE)) {

            DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  System attribute code\n") );
            return STATUS_ACCESS_DENIED;
        }

    }

    //
    //  Now check if the trailing backslash is compatible with the
    //  file being opened.
    //

    if (FlagOn( CreateFlags, CREATE_FLAG_TRAILING_BACKSLASH )) {

        if (!Indexed ||
            FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

            return STATUS_OBJECT_NAME_INVALID;

        } else {

            Indexed = TRUE;
            *AttrCode = $INDEX_ALLOCATION;
        }
    }

    //
    //  If we are opening the default index allocation stream or bitmap
    //  for a directory, set its attribute name appropriately.
    //  Note: if info is not present we're creating the attribute and
    //  it also must be a directory in this case
    //

    if (((ARGUMENT_PRESENT( Info ) && IsDirectory( Info )) ||
         (!ARGUMENT_PRESENT( Info ))) &&

        (((*AttrCode == $INDEX_ALLOCATION) || (*AttrCode == $BITMAP)) &&
         (AttrName->Length == 0))) {

        *AttrName = NtfsFileNameIndex;
    }

    *IndexedAttribute = Indexed;

    DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Exit\n") );

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenAttributeCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PSCB *ThisScb,
    OUT PSHARE_MODIFICATION_TYPE ShareModificationType
    )

/*++

Routine Description:

    This routine is a general routine which checks if an existing
    non-indexed attribute may be opened.  It considers only the oplock
    state of the file and the current share access.  In the course of
    performing these checks, the Scb for the attribute may be
    created and the share modification for the actual OpenAttribute
    call is determined.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisScb - Address to store the Scb if found or created.

    ShareModificationType - Address to store the share modification type
        for a subsequent OpenAttribute call.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN DeleteOnClose;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenAttributeCheck:  Entered\n") );

    //
    //  We should already have the Scb for this file.
    //

    ASSERT_SCB( *ThisScb );

    //
    //  If there are other opens on this file, we need to check the share
    //  access before we check the oplocks.  We remember that
    //  we did the share access check by simply updating the share
    //  access we open the attribute.
    //

    if ((*ThisScb)->CleanupCount != 0) {

        //
        //  We check the share access for this file without updating it.
        //

        Status = IoCheckShareAccess( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                                     IrpSp->Parameters.Create.ShareAccess,
                                     IrpSp->FileObject,
                                     &(*ThisScb)->ShareAccess,
                                     FALSE );

        if (!NT_SUCCESS( Status )) {

            DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit -> %08lx\n", Status) );
            return Status;
        }

        DebugTrace( 0, Dbg, ("Check oplock state of existing Scb\n") );

        if (SafeNodeType( *ThisScb ) == NTFS_NTC_SCB_DATA) {

            //
            //  If the handle count is greater than 1 then fail this
            //  open now if the caller wants a filter oplock.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER ) &&
                ((*ThisScb)->CleanupCount > 1)) {

                NtfsRaiseStatus( IrpContext, STATUS_OPLOCK_NOT_GRANTED, NULL, NULL );
            }

            Status = FsRtlCheckOplock( &(*ThisScb)->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsOplockPrePostIrp );

            //
            //  If the return value isn't success or oplock break in progress
            //  the irp has been posted.  We return right now.
            //

            if (Status == STATUS_PENDING) {

                DebugTrace( 0, Dbg, ("Irp posted through oplock routine\n") );
                DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit -> %08lx\n", Status) );

                return STATUS_WAIT_FOR_OPLOCK;
            }
        }

        *ShareModificationType = UpdateShareAccess;

    //
    //  If the unclean count in the Fcb is 0, we will simply set the
    //  share access.
    //

    } else {

        *ShareModificationType = SetShareAccess;
    }

    DeleteOnClose = BooleanFlagOn( IrpSp->Parameters.Create.Options,
                                   FILE_DELETE_ON_CLOSE );

    //
    //  Can't do DELETE_ON_CLOSE on read only volumes.
    //

    if (DeleteOnClose && NtfsIsVolumeReadOnly( (*ThisScb)->Vcb )) {

        DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit -> %08lx\n", STATUS_CANNOT_DELETE) );
        return STATUS_CANNOT_DELETE;
    }

    //
    //  If the user wants write access access to the file make sure there
    //  is process mapping this file as an image.  Any attempt to delete
    //  the file will be stopped in fileinfo.c
    //

    if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                FILE_WRITE_DATA )
        || DeleteOnClose) {

        //
        //  Use a try-finally to decrement the open count.  This is a little
        //  bit of trickery to keep the scb around while we are doing the
        //  flush call.
        //

        InterlockedIncrement( &(*ThisScb)->CloseCount );

        try {

            //
            //  If there is an image section then we better have the file
            //  exclusively.
            //

            if ((*ThisScb)->NonpagedScb->SegmentObject.ImageSectionObject != NULL) {

                if (!MmFlushImageSection( &(*ThisScb)->NonpagedScb->SegmentObject,
                                          MmFlushForWrite )) {

                    DebugTrace( 0, Dbg, ("Couldn't flush image section\n") );

                    Status = DeleteOnClose ? STATUS_CANNOT_DELETE :
                                             STATUS_SHARING_VIOLATION;
                }
            }

        } finally {

            InterlockedDecrement( &(*ThisScb)->CloseCount );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit  ->  %08lx\n", Status) );

    return Status;
}


//
//  Local support routine.
//

VOID
NtfsAddEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB ThisFcb,
    IN PFILE_FULL_EA_INFORMATION EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PIO_STATUS_BLOCK Iosb
    )

/*++

Routine Description:

    This routine will add an ea set to the file.  It writes the attributes
    to disk and updates the Fcb info structure with the packed ea size.

Arguments:

    Vcb - This is the volume being opened.

    ThisFcb - This is the Fcb for the file being opened.

    EaBuffer - This is the buffer passed by the user.

    EaLength - This is the stated length of the buffer.

    Iosb - This is the Status Block to use to fill in the offset of an
        offending Ea.

Return Value:

    None - This routine will raise on error.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    EA_LIST_HEADER EaList;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddEa:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Initialize the EaList header.
        //

        EaList.PackedEaSize = 0;
        EaList.NeedEaCount = 0;
        EaList.UnpackedEaSize = 0;
        EaList.BufferSize = 0;
        EaList.FullEa = NULL;

        if (ARGUMENT_PRESENT( EaBuffer )) {

            //
            //  Check the user's buffer for validity.
            //

            Status = IoCheckEaBufferValidity( EaBuffer,
                                              EaLength,
                                              &Length );

            if (!NT_SUCCESS( Status )) {

                DebugTrace( -1, Dbg, ("NtfsAddEa:  Invalid ea list\n") );
                Iosb->Information = Length;
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            //
            //  ****    Maybe this routine should raise.
            //

            Status = NtfsBuildEaList( IrpContext,
                                      Vcb,
                                      &EaList,
                                      EaBuffer,
                                      &Iosb->Information );

            if (!NT_SUCCESS( Status )) {

                DebugTrace( -1, Dbg, ("NtfsAddEa: Couldn't build Ea list\n") );
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }
        }

        //
        //  Now replace the existing EAs.
        //

        NtfsReplaceFileEas( IrpContext, ThisFcb, &EaList );

    } finally {

        DebugUnwind( NtfsAddEa );

        //
        //  Free the in-memory copy of the Eas.
        //

        if (EaList.FullEa != NULL) {

            NtfsFreePool( EaList.FullEa );
        }

        DebugTrace( -1, Dbg, ("NtfsAddEa:  Exit -> %08lx\n", Status) );
    }

    return;
}


VOID
NtfsInitializeFcbAndStdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN BOOLEAN Directory,
    IN BOOLEAN ViewIndex,
    IN BOOLEAN Compressed,
    IN ULONG FileAttributes,
    IN PNTFS_TUNNELED_DATA SetTunneledData OPTIONAL
    )

/*++

Routine Description:

    This routine will initialize an Fcb for a newly created file and create
    the standard information attribute on disk.  We assume that some information
    may already have been placed in the Fcb so we don't zero it out.  We will
    initialize the allocation size to zero, but that may be changed later in
    the create process.

Arguments:

    ThisFcb - This is the Fcb for the file being opened.

    Directory - Indicates if this is a directory file.

    ViewIndex - Indicates if this is a view index.

    Compressed - Indicates if this is a compressed file.

    FileAttributes - These are the attributes the user wants to attach to
        the file.  We will just clear any unsupported bits.

    SetTunneledData - Optionally force the creation time and/or object id
        to a given value

Return Value:

    None - This routine will raise on error.

--*/

{
    STANDARD_INFORMATION StandardInformation;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeFcbAndStdInfo:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Mask out the invalid bits of the file atributes.  Then set the
        //  file name index bit if this is a directory.
        //

        if (!Directory) {

            SetFlag( FileAttributes, FILE_ATTRIBUTE_ARCHIVE );
        }

        ClearFlag( FileAttributes, ~FILE_ATTRIBUTE_VALID_SET_FLAGS | FILE_ATTRIBUTE_NORMAL );

        if (Directory) {

            SetFlag( FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );
        }

        if (ViewIndex) {

            SetFlag( FileAttributes, DUP_VIEW_INDEX_PRESENT );
        }

        if (Compressed) {

            SetFlag( FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

        ThisFcb->Info.FileAttributes = FileAttributes;

        //
        //  Fill in the rest of the Fcb Info structure.
        //

        if (SetTunneledData == NULL) {

            NtfsGetCurrentTime( IrpContext, ThisFcb->Info.CreationTime );

            ThisFcb->Info.LastModificationTime = ThisFcb->Info.CreationTime;
            ThisFcb->Info.LastChangeTime = ThisFcb->Info.CreationTime;
            ThisFcb->Info.LastAccessTime = ThisFcb->Info.CreationTime;

            ThisFcb->CurrentLastAccess = ThisFcb->Info.CreationTime;

        } else {

            NtfsSetTunneledData( IrpContext,
                                 ThisFcb,
                                 SetTunneledData );

            NtfsGetCurrentTime( IrpContext, ThisFcb->Info.LastModificationTime );

            ThisFcb->Info.LastChangeTime = ThisFcb->Info.LastModificationTime;
            ThisFcb->Info.LastAccessTime = ThisFcb->Info.LastModificationTime;

            ThisFcb->CurrentLastAccess = ThisFcb->Info.LastModificationTime;
        }

        //
        //  We assume these sizes are zero.
        //

        ThisFcb->Info.AllocatedLength = 0;
        ThisFcb->Info.FileSize = 0;

        //
        //  Copy the standard information fields from the Fcb and create the
        //  attribute.
        //

        RtlZeroMemory( &StandardInformation, sizeof( STANDARD_INFORMATION ));

        StandardInformation.CreationTime = ThisFcb->Info.CreationTime;
        StandardInformation.LastModificationTime = ThisFcb->Info.LastModificationTime;
        StandardInformation.LastChangeTime = ThisFcb->Info.LastChangeTime;
        StandardInformation.LastAccessTime = ThisFcb->Info.LastAccessTime;
        StandardInformation.FileAttributes = ThisFcb->Info.FileAttributes;

        StandardInformation.ClassId = 0;
        StandardInformation.OwnerId = ThisFcb->OwnerId;
        StandardInformation.SecurityId = ThisFcb->SecurityId;
        StandardInformation.Usn = ThisFcb->Usn;

        SetFlag( ThisFcb->FcbState, FCB_STATE_LARGE_STD_INFO );

        NtfsCreateAttributeWithValue( IrpContext,
                                      ThisFcb,
                                      $STANDARD_INFORMATION,
                                      NULL,
                                      &StandardInformation,
                                      sizeof( STANDARD_INFORMATION ),
                                      0,
                                      NULL,
                                      FALSE,
                                      &AttrContext );

        //
        //  We know that the open call will generate a single link.
        //  (Remember that a separate 8.3 name is not considered a link)
        //

        ThisFcb->LinkCount =
        ThisFcb->TotalLinks = 1;

        //
        //  Now set the header initialized flag in the Fcb.
        //

        SetFlag( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED );

    } finally {

        DebugUnwind( NtfsInitializeFcbAndStdInfo );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsInitializeFcbAndStdInfo:  Exit\n") );
    }

    return;
}


//
//  Local support routine.
//

VOID
NtfsCreateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB ThisFcb,
    IN OUT PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize,
    IN BOOLEAN LogIt,
    IN BOOLEAN ForceNonresident,
    IN PUSHORT PreviousFlags OPTIONAL
    )

/*++

Routine Description:

    This routine is called to create an attribute of a given size on the
    disk.  This path will only create non-resident attributes unless the
    allocation size is zero.

    The Scb will contain the attribute name and type code on entry.

Arguments:

    IrpSp - Stack location in the Irp for this request.

    ThisFcb - This is the Fcb for the file to create the attribute in.

    ThisScb - This is the Scb for the attribute to create.

    ThisLcb - This is the Lcb for propagating compression parameters

    AllocationSize - This is the size of the attribute to create.

    LogIt - Indicates whether we should log the creation of the attribute.
        Also indicates if this is a create file operation.

    ForceNonresident - Indicates that we want to create this stream non-resident.
        This is the case if this is a supersede of a previously non-resident
        stream.  Once a stream is non-resident it can't go back to resident.

    PreviousFlags - If specified then this is a supersede operation and
        this is the previous compression flags for the file.

Return Value:

    None - This routine will raise on error.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER ThisAttribute = NULL;

    USHORT AttributeFlags = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateAttribute:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) {

            //
            //  Always force this to be non-resident.
            //

            ForceNonresident = TRUE;

        } else if (!FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION )) {

            //
            //  If this is the root directory then use the Scb from the Vcb.
            //

            if (ARGUMENT_PRESENT( PreviousFlags)) {

                AttributeFlags = *PreviousFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK;

            } else if (ThisLcb == ThisFcb->Vcb->RootLcb) {

                AttributeFlags = (USHORT)(ThisFcb->Vcb->RootIndexScb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);

            } else if (ThisLcb != NULL) {

                AttributeFlags = (USHORT)(ThisLcb->Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);

            } else if (IsCompressed( &ThisFcb->Info )) {

                AttributeFlags = COMPRESSION_FORMAT_LZNT1 - 1;
            }
        }

        //
        //  If this is a supersede we need to check whether to propagate
        //  the sparse bit.
        //

        if ((AllocationSize != 0) && ARGUMENT_PRESENT( PreviousFlags )) {

            SetFlag( AttributeFlags, FlagOn( *PreviousFlags, ATTRIBUTE_FLAG_SPARSE ));
        }

#ifdef BRIANDBG
        if (!ARGUMENT_PRESENT( PreviousFlags ) &&
            !FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
            (ThisScb->AttributeTypeCode == $DATA) &&
            (NtfsCreateAllSparse)) {

            SetFlag( AttributeFlags, ATTRIBUTE_FLAG_SPARSE );

            if (!FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE )) {

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( ThisFcb ) ||
                           (ThisFcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( ThisFcb )) );

                SetFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
                SetFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            }

            //
            //  Set the FastIo state.
            //

            NtfsAcquireFsrtlHeader( ThisScb );
            ThisScb->Header.IsFastIoPossible = NtfsIsFastIoPossible( ThisScb );
            NtfsReleaseFsrtlHeader( ThisScb );
        }
#endif

        //
        //  If we are creating a sparse or compressed stream then set the size to a
        //  compression unit boundary.
        //

        if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

            ULONG CompressionUnit = BytesFromClusters( ThisScb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );

            if (ThisScb->Vcb->SparseFileUnit < CompressionUnit) {

                CompressionUnit = ThisScb->Vcb->SparseFileUnit;
            }

            AllocationSize = BlockAlign(  AllocationSize, (LONG)CompressionUnit );
        }

        //
        //  We lookup that attribute again and it better not be there.
        //  We need the file record in order to know whether the attribute
        //  is resident or not.
        //

        if (ForceNonresident || (AllocationSize != 0)) {

            DebugTrace( 0, Dbg, ("Create non-resident attribute\n") );

            //
            //  If the file is sparse then set the allocation size to zero
            //  and add a sparse range after this call.
            //

            if (!NtfsAllocateAttribute( IrpContext,
                                        ThisScb,
                                        ThisScb->AttributeTypeCode,
                                        &ThisScb->AttributeName,
                                        AttributeFlags,
                                        FALSE,
                                        LogIt,
                                        (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ?
                                         0 :
                                         AllocationSize),
                                        NULL )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION );
            }

            //
            //  Now add the sparse allocation for a sparse file if the size is
            //  non-zero.
            //

            if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
                (AllocationSize != 0)) {

                //
                //  If the sparse flag is set then we better be doing a supersede
                //  with logging enabled.
                //

                ASSERT( LogIt );
                NtfsAddSparseAllocation( IrpContext,
                                         NULL,
                                         ThisScb,
                                         0,
                                         AllocationSize );
            }

            SetFlag( ThisScb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

        } else {

            //
            //  Update the quota if this is a user stream.
            //

            if (FlagOn( ThisScb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

                LONGLONG Delta = NtfsResidentStreamQuota( ThisFcb->Vcb );

                NtfsConditionallyUpdateQuota( IrpContext,
                                              ThisFcb,
                                              &Delta,
                                              LogIt,
                                              TRUE );
            }

            NtfsCreateAttributeWithValue( IrpContext,
                                          ThisFcb,
                                          ThisScb->AttributeTypeCode,
                                          &ThisScb->AttributeName,
                                          NULL,
                                          (ULONG) AllocationSize,
                                          AttributeFlags,
                                          NULL,
                                          LogIt,
                                          &AttrContext );

            ThisAttribute = NtfsFoundAttribute( &AttrContext );

        }

        //
        //  Clear the header initialized bit and read the sizes from the
        //  disk.
        //

        ClearFlag( ThisScb->ScbState, SCB_STATE_HEADER_INITIALIZED );
        NtfsUpdateScbFromAttribute( IrpContext,
                                    ThisScb,
                                    ThisAttribute );

    } finally {

        DebugUnwind( NtfsCreateAttribute );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsCreateAttribute:  Exit\n") );
    }

    return;

    UNREFERENCED_PARAMETER( PreviousFlags );
}


//
//  Local support routine
//

VOID
NtfsRemoveDataAttributes (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset,
    IN ULONG CreateFlags
    )

/*++

Routine Description:

    This routine is called to remove (or mark for delete) all of the named
    data attributes on a file.  This is done during an overwrite
    or supersede operation.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    ThisFcb - This is the Fcb for the file in question.

    ThisLcb - This is the Lcb used to reach this Fcb (if specified).

    FileObject - This is the file object for the file.

    LastFileNameOffset - This is the offset of the file in the full name.

    CreateFlags - Indicates if this open is being performed by file id.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_TYPE_CODE TypeCode = $DATA;

    UNICODE_STRING AttributeName;
    PSCB ThisScb;

    BOOLEAN MoreToGo;

    ASSERT_EXCLUSIVE_FCB( ThisFcb );

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &Context );

        //
        //  Enumerate all of the attributes with the matching type code
        //

        MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                              ThisFcb,
                                              &ThisFcb->FileReference,
                                              TypeCode,
                                              &Context );

        while (MoreToGo) {

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  We only look at named data attributes.
            //

            if (Attribute->NameLength != 0) {

                //
                //  Construct the name and find the Scb for the attribute.
                //

                AttributeName.Buffer = (PWSTR) Add2Ptr( Attribute, Attribute->NameOffset );
                AttributeName.MaximumLength = AttributeName.Length = Attribute->NameLength * sizeof( WCHAR );

                ThisScb = NtfsCreateScb( IrpContext,
                                         ThisFcb,
                                         TypeCode,
                                         &AttributeName,
                                         FALSE,
                                         NULL );

                //
                //  If there is an open handle on this file, we simply mark
                //  the Scb as delete pending.
                //

                if (ThisScb->CleanupCount != 0) {

                    SetFlag( ThisScb->ScbState, SCB_STATE_DELETE_ON_CLOSE );

                //
                //  Otherwise we remove the attribute and mark the Scb as
                //  deleted.  The Scb will be cleaned up when the Fcb is
                //  cleaned up.
                //

                } else {

                    NtfsDeleteAttributeRecord( IrpContext,
                                               ThisFcb,
                                               (DELETE_LOG_OPERATION |
                                                DELETE_RELEASE_FILE_RECORD |
                                                DELETE_RELEASE_ALLOCATION),
                                               &Context );

                    SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

                    //
                    //  If this is a named stream, then report this to the dir notify
                    //  package.
                    //

                    if (!FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID ) &&
                        (ThisScb->Vcb->NotifyCount != 0) &&
                        (ThisScb->AttributeName.Length != 0) &&
                        (ThisScb->AttributeTypeCode == TypeCode)) {

                        NtfsReportDirNotify( IrpContext,
                                             ThisFcb->Vcb,
                                             &FileObject->FileName,
                                             LastFileNameOffset,
                                             &ThisScb->AttributeName,
                                             ((ARGUMENT_PRESENT( ThisLcb ) &&
                                               (ThisLcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &ThisLcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FILE_NOTIFY_CHANGE_STREAM_NAME,
                                             FILE_ACTION_REMOVED_STREAM,
                                             NULL );
                    }

                    //
                    //  Since we have marked this stream as deleted then we need to checkpoint so
                    //  that we can uninitialize the Scb.  Otherwise some stray operation may
                    //  attempt to operate on the Scb.
                    //

                    ThisScb->ValidDataToDisk =
                    ThisScb->Header.AllocationSize.QuadPart =
                    ThisScb->Header.FileSize.QuadPart =
                    ThisScb->Header.ValidDataLength.QuadPart = 0;

                    NtfsCheckpointCurrentTransaction( IrpContext );
                    ThisScb->AttributeTypeCode = $UNUSED;
                }
            }

            //
            //  Get the next attribute.
            //

            MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                      ThisFcb,
                                                      TypeCode,
                                                      &Context );
        }


    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsRemoveReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb
    )

/*++

Routine Description:

    This routine is called to remove the reparse point that exists in a file.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    ThisFcb - This is the Fcb for the file in question.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PSCB ThisScb = NULL;
    PVCB Vcb = ThisFcb->Vcb;

    MAP_HANDLE MapHandle;

    BOOLEAN ThisScbAcquired = FALSE;
    BOOLEAN CleanupAttributeContext = FALSE;
    BOOLEAN IndexAcquired = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;

    ULONG IncomingFileAttributes = 0;                               //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;   //  invalid value

    ASSERT_EXCLUSIVE_FCB( ThisFcb );

    PAGED_CODE();

    //
    //  Remember the values of the file attribute flags and of the reparse tag
    //  for abnormal termination recovery.
    //

    IncomingFileAttributes = ThisFcb->Info.FileAttributes;
    IncomingReparsePointTag = ThisFcb->Info.ReparsePointTag;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {
        NtfsInitializeAttributeContext( &Context );
        CleanupAttributeContext = TRUE;

        //
        //  Lookup the reparse point attribute.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       ThisFcb,
                                       &ThisFcb->FileReference,
                                       $REPARSE_POINT,
                                       &Context )) {

            //
            //  Delete the record from the reparse point index.
            //

            {
                NTSTATUS Status = STATUS_SUCCESS;
                INDEX_KEY IndexKey;
                INDEX_ROW IndexRow;
                REPARSE_INDEX_KEY KeyValue;

                //
                //  Acquire the mount table index so that the following two operations on it
                //  are atomic for this call.
                //

                NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                IndexAcquired = TRUE;

                //
                //  Verify that this file is in the reparse point index and delete it.
                //

                KeyValue.FileReparseTag = ThisFcb->Info.ReparsePointTag;
                KeyValue.FileId = *(PLARGE_INTEGER)&ThisFcb->FileReference;

                IndexKey.Key = (PVOID)&KeyValue;
                IndexKey.KeyLength = sizeof(KeyValue);

                NtOfsInitializeMapHandle( &MapHandle );
                InitializedMapHandle = TRUE;

                //
                //  NtOfsFindRecord will return an error status if the key is not found.
                //

                Status = NtOfsFindRecord( IrpContext,
                                          Vcb->ReparsePointTableScb,
                                          &IndexKey,
                                          &IndexRow,
                                          &MapHandle,
                                          NULL );

                if (!NT_SUCCESS(Status)) {

                    //
                    //  Should not happen. The reparse point should be in the index.
                    //

                    DebugTrace( 0, Dbg, ("Record not found in the reparse point index.\n") );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, ThisFcb );
                }

                //
                //  Remove the entry from the reparse point index.
                //

                NtOfsDeleteRecords( IrpContext,
                                    Vcb->ReparsePointTableScb,
                                    1,            // deleting one record from the index
                                    &IndexKey );
            }

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  If the stream is non-resident, then get a hold of an Scb for it.
            //

            if (!NtfsIsAttributeResident( Attribute )) {

                ThisScb = NtfsCreateScb( IrpContext,
                                         ThisFcb,
                                         $REPARSE_POINT,
                                         &NtfsEmptyString,
                                         FALSE,
                                         NULL );

                NtfsAcquireExclusiveScb( IrpContext, ThisScb );
                ThisScbAcquired = TRUE;
            }

            //
            //  Post the change to the Usn Journal (on errors change is backed out)
            //

            NtfsPostUsnChange( IrpContext, ThisFcb, USN_REASON_REPARSE_POINT_CHANGE );

            NtfsDeleteAttributeRecord( IrpContext,
                                       ThisFcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &Context );

            //
            //  Set the change attribute flag.
            //

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( ThisFcb ) ||
                       (ThisFcb->PagingIoResource != NULL &&
                        NtfsIsSharedFcbPagingIo( ThisFcb )) );

            SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

            //
            //  Clear the reparse point bit in the duplicate file attribute.
            //

            ClearFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT );

            //
            //  Clear the ReparsePointTag field in the duplicate file attribute.
            //

            ThisFcb->Info.ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;

            //
            //  Put the reparse point deletion and the attribute flag into the
            //  the same transaction.
            //

            NtfsUpdateStandardInformation( IrpContext, ThisFcb );

            //
            //  If we have acquired the Scb then set the sizes back to zero.
            //  Flag that the attribute has been deleted.
            //  Always commit this change since we update the field in the Fcb.
            //

            if (ThisScbAcquired) {

                ThisScb->Header.FileSize =
                ThisScb->Header.ValidDataLength =
                ThisScb->Header.AllocationSize = Li0;
            }

            //
            //  Since we've been called from NtfsOverwriteAttr before
            //  NtfsRemoveDataAttributes gets called, we need to make sure
            //  that if we're holding the Mft, we drop itwhen we checkpoint.
            //  Otherwise we have a potential deadlock when
            //  NtfsRemoveDataAttributes tries to acquire the quota index
            //  while holding the Mft.
            //

            if ((Vcb->MftScb != NULL) &&
                (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL) &&
                NtfsIsExclusiveScb( Vcb->MftScb )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
            }

            //
            //  Checkpoint the Txn to commit the changes.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );
            ClearFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            if (ThisScbAcquired) {

                //
                //  Set the Scb flag to indicate that the attribute is gone.
                //

                ThisScb->AttributeTypeCode = $UNUSED;
                SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
            }
        }

    } finally {

        if (ThisScbAcquired) {

            NtfsReleaseScb( IrpContext, ThisScb );
        }

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Release the reparse point index Scb and the map handle.
        //

        if (IndexAcquired) {

            NtfsReleaseScb( IrpContext, Vcb->ReparsePointTableScb );
        }

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        //
        //  Need to roll-back the value of the file attributes and the reparse point
        //  flag in case of problems.
        //

        if (AbnormalTermination()) {

            ThisFcb->Info.FileAttributes = IncomingFileAttributes;
            ThisFcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }
    }

    return;
}

//
//  Local support routine.
//

VOID
NtfsReplaceAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize
    )

/*++

Routine Description:

    This routine is called to replace an existing attribute with
    an attribute of the given allocation size.  This routine will
    handle the case whether the existing attribute is resident
    or non-resident and the resulting attribute is resident or
    non-resident.

    There are two cases to consider.  The first is the case where the
    attribute is currently non-resident.  In this case we will always
    leave the attribute non-resident regardless of the new allocation
    size.  The argument being that the file will probably be used
    as it was before.  In this case we will add or delete allocation.
    The second case is where the attribute is currently resident.  In
    This case we will remove the old attribute and add a new one.

Arguments:

    IrpSp - This is the Irp stack location for this request.

    ThisFcb - This is the Fcb for the file being opened.

    ThisScb - This is the Scb for the given attribute.

    ThisLcb - This is the Lcb via which this file is created.  It
              is used to propagate compression info.

    AllocationSize - This is the new allocation size.

Return Value:

    None.  This routine will raise.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReplaceAttribute:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Initialize the Scb if needed.
        //

        if (!FlagOn( ThisScb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, ThisScb, NULL );
        }

        NtfsSnapshotScb( IrpContext, ThisScb );

        //
        //  If the attribute is resident, simply remove the old attribute and create
        //  a new one.
        //

        if (FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            USHORT AttributeFlags;

            //
            //  Find the attribute on the disk.
            //

            NtfsLookupAttributeForScb( IrpContext,
                                       ThisScb,
                                       NULL,
                                       &AttrContext );

            AttributeFlags = ThisScb->AttributeFlags;

            NtfsDeleteAttributeRecord( IrpContext,
                                       ThisFcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &AttrContext );

            //
            //  Set all the attribute sizes to zero.
            //

            ThisScb->ValidDataToDisk =
            ThisScb->Header.AllocationSize.QuadPart =
            ThisScb->Header.ValidDataLength.QuadPart =
            ThisScb->Header.FileSize.QuadPart = 0;
            ThisScb->TotalAllocated = 0;

            //
            //  Create a stream file for the attribute in order to
            //  truncate the cache.  Set the initialized bit in
            //  the Scb so we don't go to disk, but clear it afterwords.
            //

            if ((ThisScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) ||
#ifdef  COMPRESS_ON_WIRE
                (ThisScb->Header.FileObjectC != NULL))
#else
                FALSE
#endif
                ) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   ThisScb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[REPLACEATTRIBUTE_FILE_NUMBER] );

                NtfsSetBothCacheSizes( ThisScb->FileObject,
                                       (PCC_FILE_SIZES)&ThisScb->Header.AllocationSize,
                                       ThisScb );
            }

            //
            //  Call our create attribute routine.
            //

            NtfsCreateAttribute( IrpContext,
                                 IrpSp,
                                 ThisFcb,
                                 ThisScb,
                                 ThisLcb,
                                 AllocationSize,
                                 TRUE,
                                 FALSE,
                                 &AttributeFlags );

        //
        //  Otherwise the attribute will stay non-resident, we simply need to
        //  add or remove allocation.
        //

        } else {

            ULONG AllocationUnit;

            //
            //  Create an internal attribute stream for the file.
            //

            if ((ThisScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) ||
#ifdef  COMPRESS_ON_WIRE
                (ThisScb->Header.FileObjectC != NULL)
#else
                FALSE
#endif
                ) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   ThisScb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[REPLACEATTRIBUTE2_FILE_NUMBER] );
            }

            //
            //  If the file is sparse or compressed then always round the
            //  new size to a compression unit boundary.  Otherwise round
            //  to a cluster boundary.
            //

            AllocationUnit = ThisScb->Vcb->BytesPerCluster;

            if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                ASSERT( ThisScb->CompressionUnit != 0 );
                AllocationUnit = ThisScb->CompressionUnit;
            }

            AllocationSize = BlockAlign( AllocationSize, (LONG)AllocationUnit );

            //
            //  Set the file size and valid data size to zero.
            //

            ThisScb->ValidDataToDisk = 0;
            ThisScb->Header.ValidDataLength = Li0;
            ThisScb->Header.FileSize = Li0;

            DebugTrace( 0, Dbg, ("AllocationSize -> %016I64x\n", AllocationSize) );

            //
            //  Write these changes to the file
            //

            //
            //  If the attribute is currently compressed or sparse then go ahead and discard
            //  all of the allocation.
            //

            if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                NtfsDeleteAllocation( IrpContext,
                                      ThisScb->FileObject,
                                      ThisScb,
                                      0,
                                      MAXLONGLONG,
                                      TRUE,
                                      TRUE );

                //
                //  Checkpoint the current transaction so we have these clusters
                //  available again.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  If the user doesn't want this stream to be compressed then
                //  remove the entire stream and recreate it non-compressed.  If
                //  the stream is currently sparse and the new file size
                //  is zero then also create the stream non-sparse.
                //

                if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) ||
                    (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION ) &&
                     !FlagOn( ThisScb->ScbState, SCB_STATE_COMPRESSION_CHANGE )) ||
                    (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
                     (AllocationSize == 0))) {

                    //
                    //  We may need to preserve one or the other of the sparse/compressed
                    //  flags.
                    //

                    USHORT PreviousFlags = ThisScb->AttributeFlags;

                    if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) {

                        PreviousFlags = 0;

                    } else {

                        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION )) {

                            ClearFlag( PreviousFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );
                        }

                        if ((AllocationSize == 0) &&
                            FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                            ClearFlag( PreviousFlags, ATTRIBUTE_FLAG_SPARSE );
                        }
                    }

                    NtfsLookupAttributeForScb( IrpContext,
                                               ThisScb,
                                               NULL,
                                               &AttrContext );

                    NtfsDeleteAttributeRecord( IrpContext,
                                               ThisFcb,
                                               DELETE_LOG_OPERATION |
                                                DELETE_RELEASE_FILE_RECORD |
                                                DELETE_RELEASE_ALLOCATION,
                                               &AttrContext );

                    //
                    //  Call our create attribute routine.
                    //

                    NtfsCreateAttribute( IrpContext,
                                         IrpSp,
                                         ThisFcb,
                                         ThisScb,
                                         ThisLcb,
                                         AllocationSize,
                                         TRUE,
                                         TRUE,
                                         &PreviousFlags );

                    //
                    //  Since the attribute may have changed state we need to
                    //  checkpoint.
                    //

                    NtfsCheckpointCurrentTransaction( IrpContext );
                }
            }

            //
            //  Now if the file allocation is being increased then we need to only add allocation
            //  to the attribute
            //

            if (ThisScb->Header.AllocationSize.QuadPart < AllocationSize) {

                NtfsAddAllocation( IrpContext,
                                   ThisScb->FileObject,
                                   ThisScb,
                                   LlClustersFromBytes( ThisScb->Vcb, ThisScb->Header.AllocationSize.QuadPart ),
                                   LlClustersFromBytes( ThisScb->Vcb, AllocationSize - ThisScb->Header.AllocationSize.QuadPart ),
                                   FALSE,
                                   NULL );
            //
            //  Otherwise the allocation is being decreased so we need to delete some allocation
            //

            } else if (ThisScb->Header.AllocationSize.QuadPart > AllocationSize) {

                NtfsDeleteAllocation( IrpContext,
                                      ThisScb->FileObject,
                                      ThisScb,
                                      LlClustersFromBytes( ThisScb->Vcb, AllocationSize ),
                                      MAXLONGLONG,
                                      TRUE,
                                      TRUE );
            }

            //
            //  We always unitialize the cache size to zero and write the new
            //  file size to disk.
            //

            NtfsWriteFileSizes( IrpContext,
                                ThisScb,
                                &ThisScb->Header.ValidDataLength.QuadPart,
                                FALSE,
                                TRUE,
                                TRUE );

            NtfsCheckpointCurrentTransaction( IrpContext );

            if (ThisScb->FileObject != NULL) {

                NtfsSetBothCacheSizes( ThisScb->FileObject,
                                       (PCC_FILE_SIZES)&ThisScb->Header.AllocationSize,
                                       ThisScb );
            }

            //
            //  Make sure the reservation bitmap shows no reserved bits.
            //

            if (ThisScb->ScbType.Data.ReservedBitMap != NULL) {

                NtfsDeleteReservedBitmap( ThisScb );
                ThisScb->ScbType.Data.TotalReserved = 0;
            }

            //
            //  Set the FastIo state.
            //

            NtfsAcquireFsrtlHeader( ThisScb );
            ThisScb->Header.IsFastIoPossible = NtfsIsFastIoPossible( ThisScb );
            NtfsReleaseFsrtlHeader( ThisScb );
        }

    } finally {

        DebugUnwind( NtfsReplaceAttribute );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsReplaceAttribute:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN SHARE_MODIFICATION_TYPE ShareModificationType,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine does the work of creating the Scb and updating the
    ShareAccess in the Fcb.  It also initializes the Scb if neccessary
    and creates Ccb.  Its final job is to set the file object type of
    open.

Arguments:

    IrpSp - This is the stack location for this volume.  We use it to get the
        file object, granted access and share access for this open.

    Vcb - Vcb for this volume.

    ThisLcb - This is the Lcb to the Fcb for the file being opened.  Not present
          if this is an open by id.

    ThisFcb - This is the Fcb for this file.

    LastFileNameOffset - This is the offset in the full path of the final component.

    AttrName - This is the attribute name to open.

    AttrTypeCode - This is the type code for the attribute being opened.

    ShareModificationType - This indicates how we should modify the
        current share modification on the Fcb.

    TypeOfOpen - This indicates how this attribute is being opened.

    CreateFile - Indicates if we are in the create file path.

    CcbFlags - This is the flag field for the Ccb.

    NetworkInfo - If specified then this open is on behalf of a fast query
        and we don't want to increment the counts or modify the share
        access on the file.

    ThisScb - If this points to a non-NULL value, it is the Scb to use.  Otherwise we
        store the Scb we create here.

    ThisCcb - Address to store address of created Ccb.

Return Value:

    NTSTATUS - Indicating the outcome of opening this attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN RemoveShareAccess = FALSE;
    ACCESS_MASK GrantedAccess;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenAttribute:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Remember the granted access.
        //

        GrantedAccess = IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess;

        //
        //  Create the Scb for this attribute if it doesn't exist.
        //

        if (*ThisScb == NULL) {

            DebugTrace( 0, Dbg, ("Looking for Scb\n") );

            *ThisScb = NtfsCreateScb( IrpContext,
                                      ThisFcb,
                                      AttrTypeCode,
                                      &AttrName,
                                      FALSE,
                                      NULL );
        }

        DebugTrace( 0, Dbg, ("ThisScb -> %08lx\n", *ThisScb) );
        DebugTrace( 0, Dbg, ("ThisLcb -> %08lx\n", ThisLcb) );

        //
        //  If this Scb is delete pending, we return an error.
        //

        if (FlagOn( (*ThisScb)->ScbState, SCB_STATE_DELETE_ON_CLOSE )) {

            DebugTrace( 0, Dbg, ("Scb delete is pending\n") );

            Status = STATUS_DELETE_PENDING;
            try_return( NOTHING );
        }

        //
        //  Skip all of the operations below if the user is doing a fast
        //  path open.
        //

        if (!ARGUMENT_PRESENT( NetworkInfo )) {

            //
            //  If this caller wanted a filter oplock and the cleanup count
            //  is non-zero then fail the request.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                if (SafeNodeType( *ThisScb ) != NTFS_NTC_SCB_DATA) {

                    Status = STATUS_INVALID_PARAMETER;
                    try_return( NOTHING );

                //
                //  This must be the only open on the file and the requested
                //  access must be FILE_READ/WRITE_ATTRIBUTES and the
                //  share access must share with everyone.
                //

                } else if (((*ThisScb)->CleanupCount != 0) ||
                           (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                                    ~(FILE_READ_ATTRIBUTES))) ||
                           ((IrpSp->Parameters.Create.ShareAccess &
                             (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)) !=
                            (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE))) {

                    Status = STATUS_OPLOCK_NOT_GRANTED;
                    try_return( NOTHING );
                }
            }

            //
            //  Update the share access structure.
            //

            //
            //  Case on the requested share modification value.
            //

            switch (ShareModificationType) {

            case UpdateShareAccess :

                DebugTrace( 0, Dbg, ("Updating share access\n") );

                IoUpdateShareAccess( IrpSp->FileObject,
                                     &(*ThisScb)->ShareAccess );
                break;

            case SetShareAccess :

                DebugTrace( 0, Dbg, ("Setting share access\n") );

                //
                //  This case is when this is the first open for the file
                //  and we simply set the share access.
                //

                IoSetShareAccess( GrantedAccess,
                                  IrpSp->Parameters.Create.ShareAccess,
                                  IrpSp->FileObject,
                                  &(*ThisScb)->ShareAccess );
                break;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
            case RecheckShareAccess :

                DebugTrace( 0, Dbg, ("Rechecking share access\n") );

                ASSERT( NT_SUCCESS( IoCheckShareAccess( GrantedAccess,
                                                        IrpSp->Parameters.Create.ShareAccess,
                                                        IrpSp->FileObject,
                                                        &(*ThisScb)->ShareAccess,
                                                        FALSE )));
#endif
            default:

                DebugTrace( 0, Dbg, ("Checking share access\n") );

                //
                //  For this case we need to check the share access and
                //  fail this request if access is denied.
                //

                if (!NT_SUCCESS( Status = IoCheckShareAccess( GrantedAccess,
                                                              IrpSp->Parameters.Create.ShareAccess,
                                                              IrpSp->FileObject,
                                                              &(*ThisScb)->ShareAccess,
                                                              TRUE ))) {

                    try_return( NOTHING );
                }
            }

            RemoveShareAccess = TRUE;

            //
            //  If this happens to be the first time we see write access on this
            //  Scb, then we need to remember it, and check if we have a disk full
            //  condition.
            //

            if (IrpSp->FileObject->WriteAccess &&
                !FlagOn((*ThisScb)->ScbState, SCB_STATE_WRITE_ACCESS_SEEN) &&
                (SafeNodeType( (*ThisScb) ) == NTFS_NTC_SCB_DATA)) {

                if ((*ThisScb)->ScbType.Data.TotalReserved != 0) {

                    NtfsAcquireReservedClusters( Vcb );

                    //
                    //  Does this Scb have reserved space that causes us to exceed the free
                    //  space on the volume?
                    //

                    if (((LlClustersFromBytes(Vcb, (*ThisScb)->ScbType.Data.TotalReserved) + Vcb->TotalReserved) >
                         Vcb->FreeClusters)) {

                        NtfsReleaseReservedClusters( Vcb );

                        try_return( Status = STATUS_DISK_FULL );
                    }

                    //
                    //  Otherwise tally in the reserved space now for this Scb, and
                    //  remember that we have seen write access.
                    //

                    Vcb->TotalReserved += LlClustersFromBytes(Vcb, (*ThisScb)->ScbType.Data.TotalReserved);
                    NtfsReleaseReservedClusters( Vcb );
                }

                SetFlag( (*ThisScb)->ScbState, SCB_STATE_WRITE_ACCESS_SEEN );
            }

            //
            //  Create the Ccb and put the remaining name in it.
            //

            *ThisCcb = NtfsCreateCcb( IrpContext,
                                      ThisFcb,
                                      *ThisScb,
                                      (BOOLEAN)(AttrTypeCode == $INDEX_ALLOCATION),
                                      ThisFcb->EaModificationCount,
                                      CcbFlags,
                                      IrpSp->FileObject,
                                      LastFileNameOffset );

            if (FlagOn( ThisFcb->Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED ) &&
                FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_FOR_FREE_SPACE_QUERY )) {

                //
                //  Get the owner id of the calling thread.  This must be done at
                //  create time since that is the only time the owner is valid.
                //

                (*ThisCcb)->OwnerId = NtfsGetCallersUserId( IrpContext );
            }

            //
            //  Link the Ccb into the Lcb.
            //

            if (ARGUMENT_PRESENT( ThisLcb )) {

                NtfsLinkCcbToLcb( IrpContext, ThisFcb, *ThisCcb, ThisLcb );
            }

            //
            //  Update the Fcb delete counts if necessary.
            //

            if (RemoveShareAccess) {

                //
                //  Update the count in the Fcb and store a flag in the Ccb
                //  if the user is not sharing the file for deletes.  We only
                //  set these values if the user is accessing the file
                //  for read/write/delete access.  The I/O system ignores
                //  the sharing mode unless the file is opened with one
                //  of these accesses.
                //

                if (FlagOn( GrantedAccess, NtfsAccessDataFlags )
                    && !FlagOn( IrpSp->Parameters.Create.ShareAccess,
                                FILE_SHARE_DELETE )) {

                    ThisFcb->FcbDenyDelete += 1;
                    SetFlag( (*ThisCcb)->Flags, CCB_FLAG_DENY_DELETE );
                }

                //
                //  Do the same for the file delete count for any user
                //  who opened the file as a file and requested delete access.
                //

                if (FlagOn( (*ThisCcb)->Flags, CCB_FLAG_OPEN_AS_FILE )
                    && FlagOn( GrantedAccess,DELETE )) {

                    ThisFcb->FcbDeleteFile += 1;
                    SetFlag( (*ThisCcb)->Flags, CCB_FLAG_DELETE_FILE | CCB_FLAG_DELETE_ACCESS );
                }
            }

            //
            //  Let our cleanup routine undo the share access change now.
            //

            RemoveShareAccess = FALSE;

            //
            //  Increment the cleanup and close counts
            //

            NtfsIncrementCleanupCounts( *ThisScb,
                                        ThisLcb,
                                        BooleanFlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ));

            NtfsIncrementCloseCounts( *ThisScb,
                                      BooleanFlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ),
                                      (BOOLEAN) IsFileObjectReadOnly( IrpSp->FileObject ));

            //
            //  If this is a user view index open, we want to set TypeOfOpen in
            //  time to get it copied into the Ccb.
            //

            if (FlagOn( (*ThisScb)->ScbState, SCB_STATE_VIEW_INDEX )) {

                TypeOfOpen = UserViewIndexOpen;
            }

            if (TypeOfOpen != UserDirectoryOpen) {

                DebugTrace( 0, Dbg, ("Updating Vcb and File object for user open\n") );

                //
                //  Set the section object pointer if this is a data Scb
                //

                IrpSp->FileObject->SectionObjectPointer = &(*ThisScb)->NonpagedScb->SegmentObject;

            } else {

                //
                //  Set the Scb encrypted bit from the Fcb.
                //

                if (FlagOn( ThisFcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED )) {

                    SetFlag( (*ThisScb)->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );
                }
            }

            //
            //  Set the file object type.
            //

            NtfsSetFileObject( IrpSp->FileObject,
                               TypeOfOpen,
                               *ThisScb,
                               *ThisCcb );

            //
            //  If this is a non-cached open and  there are only non-cached opens
            //  then go ahead and try to delete the section. We may go through here
            //  twice due to a logfile full and on the 2nd time no longer have a section
            //  The filesize then is updated in the close path
            //  We will never flush and purge system files like the mft in this path
            //

            if (FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
                !CreateFile &&
                ((*ThisScb)->AttributeTypeCode == $DATA) &&
                ((*ThisScb)->CleanupCount == (*ThisScb)->NonCachedCleanupCount) &&
                ((*ThisScb)->NonpagedScb->SegmentObject.ImageSectionObject == NULL) &&
                ((*ThisScb)->CompressionUnit == 0) &&
                MmCanFileBeTruncated( &(*ThisScb)->NonpagedScb->SegmentObject, NULL ) &&
                FlagOn( (*ThisScb)->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
                !FlagOn( (*ThisScb)->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                //
                //  Only do this in the Fsp so we have enough stack space for the flush.
                //  Also only call if we really have a datasection
                //

                if (((*ThisScb)->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                    !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                    NtfsRaiseToPost( IrpContext );
                }


                //
                //  Flush and purge the stream.
                //

                NtfsFlushAndPurgeScb( IrpContext,
                                      *ThisScb,
                                      (ARGUMENT_PRESENT( ThisLcb ) ?
                                       ThisLcb->Scb :
                                       NULL) );
            }

            //
            //  Check if we should request a filter oplock.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                FsRtlOplockFsctrl( &(*ThisScb)->ScbType.Data.Oplock,
                                   IrpContext->OriginatingIrp,
                                   1 );
            }
        }

        //
        //  Mark the Scb if this is a temporary file.
        //

        if (FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

            SetFlag( (*ThisScb)->ScbState, SCB_STATE_TEMPORARY );
            SetFlag( IrpSp->FileObject->Flags, FO_TEMPORARY_FILE );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsOpenAttribute );

        //
        //  Back out local actions on error.
        //

        if (AbnormalTermination()
            && RemoveShareAccess) {

            IoRemoveShareAccess( IrpSp->FileObject, &(*ThisScb)->ShareAccess );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenAttribute:  Status -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine.
//

VOID
NtfsBackoutFailedOpensPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PCCB ThisCcb
    )

/*++

Routine Description:

    This routine is called during an open that has failed after
    modifying in-memory structures.  We will repair the following
    structures.

        Vcb - Decrement the open counts.  Check if we locked the volume.

        ThisFcb - Restore he Share Access fields and decrement open counts.

        ThisScb - Decrement the open counts.

        ThisCcb - Remove from the Lcb and delete.

Arguments:

    FileObject - This is the file object for this open.

    ThisFcb - This is the Fcb for the file being opened.

    ThisScb - This is the Scb for the given attribute.

    ThisCcb - This is the Ccb for this open.

Return Value:

    None.

--*/

{
    PLCB Lcb;
    PVCB Vcb = ThisFcb->Vcb;
    PSCB CurrentParentScb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBackoutFailedOpens:  Entered\n") );

    //
    //  If there is an Scb and Ccb, we remove the share access from the
    //  Fcb.  We also remove all of the open and unclean counts incremented
    //  by us.
    //

    //
    //  Remove this Ccb from the Lcb.
    //

    Lcb = ThisCcb->Lcb;
    NtfsUnlinkCcbFromLcb( IrpContext, ThisFcb, ThisCcb );

    //
    //  Check if we need to remove the share access for this open.
    //

    IoRemoveShareAccess( FileObject, &ThisScb->ShareAccess );

    //
    //  Modify the delete counts in the Fcb.
    //

    if (FlagOn( ThisCcb->Flags, CCB_FLAG_DELETE_FILE )) {

        ThisFcb->FcbDeleteFile -= 1;
        ClearFlag( ThisCcb->Flags, CCB_FLAG_DELETE_FILE );
    }

    if (FlagOn( ThisCcb->Flags, CCB_FLAG_DENY_DELETE )) {

        ThisFcb->FcbDenyDelete -= 1;
        ClearFlag( ThisCcb->Flags, CCB_FLAG_DENY_DELETE );
    }

    //
    //  Decrement the cleanup and close counts
    //

    NtfsDecrementCleanupCounts( ThisScb,
                                Lcb,
                                BooleanFlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ));

    //
    //  Trim any normalized names created in this open if no cleanup counts left
    //

    if (0 == ThisScb->CleanupCount ) {

        switch (ThisCcb->TypeOfOpen) {

        case UserDirectoryOpen :

            //
            //  Cleanup the current scb node if it has a name
            //

            if (ThisScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) {

                NtfsDeleteNormalizedName( ThisScb );
            }

            //
            //  Fallthrough to deal with parents - in some case the current node failed to get a name
            //  but we populated a tree of long names on the way down
            //

        case UserFileOpen :

            if (Lcb != NULL) {
                CurrentParentScb = Lcb->Scb;
            } else {
                CurrentParentScb = NULL;
            }

            //
            //  Try to trim normalized names if the name is suff. long and we don't own the mft
            //  which would cause a deadlock
            //

            if ((CurrentParentScb != NULL) &&
                (CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) &&
                !NtfsIsSharedScb( Vcb->MftScb )) {

                NtfsTrimNormalizedNames( IrpContext, ThisFcb, CurrentParentScb);
            }
            break;

        }  //  endif switch
    }

    NtfsDecrementCloseCounts( IrpContext,
                              ThisScb,
                              Lcb,
                              (BOOLEAN) BooleanFlagOn(ThisFcb->FcbState, FCB_STATE_PAGING_FILE),
                              (BOOLEAN) IsFileObjectReadOnly( FileObject ),
                              TRUE,
                              NULL );

    //
    //  Now clean up the Ccb.
    //

    NtfsDeleteCcb( ThisFcb, &ThisCcb );

    DebugTrace( -1, Dbg, ("NtfsBackoutFailedOpens:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUpdateScbFromMemory (
    IN OUT PSCB Scb,
    IN POLD_SCB_SNAPSHOT ScbSizes
    )

/*++

Routine Description:

    All of the information from the attribute is stored in the snapshot.  We process
    this data identically to NtfsUpdateScbFromAttribute.

Arguments:

    Scb - This is the Scb to update.

    ScbSizes - This contains the sizes to store in the scb.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateScbFromMemory:  Entered\n") );

    //
    //  Check whether this is resident or nonresident
    //

    if (ScbSizes->Resident) {

        Scb->Header.AllocationSize.QuadPart = ScbSizes->FileSize;

        if (!FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

            Scb->Header.ValidDataLength =
            Scb->Header.FileSize = Scb->Header.AllocationSize;
        }

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 0, 0 );
        }
#endif

        Scb->Header.AllocationSize.LowPart =
          QuadAlign( Scb->Header.AllocationSize.LowPart );

        Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

        NtfsVerifySizes( &Scb->Header );

        //
        //  Set the resident flag in the Scb.
        //

        SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

    } else {

        VCN FileClusters;
        VCN AllocationClusters;

        if (!FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

            Scb->Header.ValidDataLength.QuadPart = ScbSizes->ValidDataLength;
            Scb->Header.FileSize.QuadPart = ScbSizes->FileSize;

            if (FlagOn( ScbSizes->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                Scb->ValidDataToDisk = ScbSizes->ValidDataLength;
            }
        }

        Scb->TotalAllocated = ScbSizes->TotalAllocated;
        Scb->Header.AllocationSize.QuadPart = ScbSizes->AllocationSize;


#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 1, 0 );
        }
#endif

        ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

        //
        //  Get the size of the compression unit.
        //

        ASSERT( (ScbSizes->CompressionUnit == 0) ||
                (ScbSizes->CompressionUnit == NTFS_CLUSTERS_PER_COMPRESSION) ||
                FlagOn( ScbSizes->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ));

        if ((ScbSizes->CompressionUnit != 0) &&
            (ScbSizes->CompressionUnit < 31)) {
            Scb->CompressionUnit = BytesFromClusters( Scb->Vcb,
                                                      1 << ScbSizes->CompressionUnit );
            Scb->CompressionUnitShift = ScbSizes->CompressionUnit;
        }

        ASSERT( (Scb->CompressionUnit == 0) ||
                (Scb->AttributeTypeCode == $INDEX_ALLOCATION) ||
                NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));

        //
        //  Compute the clusters for the file and its allocation.
        //

        AllocationClusters = LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart );

        if (Scb->CompressionUnit == 0) {

            FileClusters = LlClustersFromBytes(Scb->Vcb, Scb->Header.FileSize.QuadPart);

        } else {

            FileClusters = BlockAlign( Scb->Header.FileSize.QuadPart, (LONG)Scb->CompressionUnit );
        }

        //
        //  If allocated clusters are greater than file clusters, mark
        //  the Scb to truncate on close.
        //

        if (AllocationClusters > FileClusters) {

            SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
        }
    }

    Scb->AttributeFlags = ScbSizes->AttributeFlags;

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

        //
        //  If sparse CC should flush and purge when the file is mapped to
        //  keep reservations accurate
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {
            SetFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
        }

        if (NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode )) {

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                SetFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
            }

            //
            //  If the attribute is resident, then we will use our current
            //  default.
            //

            if (Scb->CompressionUnit == 0) {

                Scb->CompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                Scb->CompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                //
                //  Trim the compression unit for large sparse clusters.
                //

                while (Scb->CompressionUnit > Scb->Vcb->SparseFileUnit) {

                    Scb->CompressionUnit >>= 1;
                    Scb->CompressionUnitShift -= 1;
                }
            }
        }
    }

    //
    //  If the compression unit is non-zero or this is a resident file
    //  then set the flag in the common header for the Modified page writer.
    //

    NtfsAcquireFsrtlHeader( Scb );
    Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
    NtfsReleaseFsrtlHeader( Scb );

    SetFlag( Scb->ScbState,
             SCB_STATE_UNNAMED_DATA | SCB_STATE_FILE_SIZE_LOADED | SCB_STATE_HEADER_INITIALIZED );

    DebugTrace( -1, Dbg, ("NtfsUpdateScbFromMemory:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsOplockPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.  This routine will update
    the originating Irp in the IrpContext and release all of the Fcbs and
    paging io resources in the IrpContext.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIRP_CONTEXT IrpContext;
    POPLOCK_CLEANUP OplockCleanup;

    PAGED_CODE();

    IrpContext = (PIRP_CONTEXT) Context;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL ));

    IrpContext->OriginatingIrp = Irp;
    OplockCleanup = IrpContext->Union.OplockCleanup;

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Adjust the filename strings as needed.
    //

    if ((OplockCleanup->ExactCaseName.Buffer != OplockCleanup->OriginalFileName.Buffer) &&
        (OplockCleanup->ExactCaseName.Buffer != NULL)) {

        ASSERT( OplockCleanup->ExactCaseName.Length != 0 );
        ASSERT( OplockCleanup->OriginalFileName.MaximumLength >= OplockCleanup->ExactCaseName.MaximumLength );

        RtlCopyMemory( OplockCleanup->OriginalFileName.Buffer,
                       OplockCleanup->ExactCaseName.Buffer,
                       OplockCleanup->ExactCaseName.MaximumLength );
    }

    //
    //  Restitute the access control state to what it was when we entered the request.
    //

    IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess = OplockCleanup->RemainingDesiredAccess;
    IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess = OplockCleanup->PreviouslyGrantedAccess;
    IrpSp->Parameters.Create.SecurityContext->DesiredAccess = OplockCleanup->DesiredAccess;

    //
    //  Free any buffer we allocated.
    //

    if ((OplockCleanup->FullFileName.Buffer != NULL) &&
        (OplockCleanup->OriginalFileName.Buffer != OplockCleanup->FullFileName.Buffer)) {

        NtfsFreePool( OplockCleanup->FullFileName.Buffer );
        OplockCleanup->FullFileName.Buffer = NULL;
    }

    //
    //  If in the fsp restore the thread context pointer if its associated with this IrpContext since
    //  we're really going to post to another worker thread item.
    //  Non-fsp creates will continue in the same thread. We use the same test as NtfsOplockComplete
    //

    if ((IrpContext->Union.OplockCleanup == NULL) ||
         (IrpContext->Union.OplockCleanup->CompletionContext == NULL)) {

         ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) );

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL)) {

            NtfsRestoreTopLevelIrp();
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
        }
    }

    //
    //  Cleanup the IrpContext.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
    NtfsCleanupIrpContext( IrpContext, FALSE );

    //
    //  Set the file name in the file object back to it's original value.
    //

    OplockCleanup->FileObject->FileName = OplockCleanup->OriginalFileName;

    return;
}


//
//  Local support routine.
//

NTSTATUS
NtfsCreateCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for synchronous creates.  It is only called if
    STATUS_PENDING was returned.  We return MORE_PROCESSING_REQUIRED to take
    control of the Irp again and also clear the top level thread storage.  We have to
    do this because we could be calling this routine in an Fsp thread and are
    waiting for the event in an Fsd thread.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Contxt - This is the event to signal.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can take
    control of the Irp in the original thread.

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( ((PNTFS_COMPLETION_CONTEXT) Contxt)->IrpContext );

    //
    //  Restore the thread context pointer if associated with this IrpContext.
    //  It is important for the create irp because we we might be completing
    //  the irp but take control of it again in a separate thread.
    //

    if (FlagOn( ((PNTFS_COMPLETION_CONTEXT) Contxt)->IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

        NtfsRestoreTopLevelIrp();
        ClearFlag( ((PNTFS_COMPLETION_CONTEXT) Contxt)->IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
    }

    KeSetEvent( &((PNTFS_COMPLETION_CONTEXT) Contxt)->Event, 0, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}


//
//  Local support routine.
//

NTSTATUS
NtfsCheckExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN BOOLEAN Index,
    IN ULONG CcbFlags
    )

/*++

Routine Description:

    This routine is called to check the desired access on an existing file
    against the ACL's and the read-only status of the file.  If we fail on
    the access check, that routine will raise.  Otherwise we will return a
    status to indicate success or the failure cause.  This routine will access
    and update the PreviouslyGrantedAccess field in the security context.

Arguments:

    IrpSp - This is the Irp stack location for this open.

    ThisLcb - This is the Lcb used to reach the Fcb to open.

    ThisFcb - This is the Fcb where the open will occur.

    Index - Whether this is an index or not

    CcbFlags - This is the flag field for the Ccb.

Return Value:

    None.

--*/

{
    BOOLEAN MaximumAllowed = FALSE;

    PACCESS_STATE AccessState;

    PAGED_CODE();

    //
    //  Save a pointer to the access state for convenience.
    //

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Start by checking that there are no bits in the desired access that
    //  conflict with the read-only state of the file if the file is not an index
    //

    if (IsReadOnly( &ThisFcb->Info ) && !Index) {

        if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess, FILE_WRITE_DATA | FILE_APPEND_DATA )) {

            return STATUS_ACCESS_DENIED;
        }
    }

    //
    //  If the volume itself is mounted readonly, we still let open-for-writes
    //  go through for legacy reasons. DELETE_ON_CLOSE is an exception.
    //

    if ((IsReadOnly( &ThisFcb->Info )) ||
        (NtfsIsVolumeReadOnly( ThisFcb->Vcb ))) {

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DELETE_ON_CLOSE )) {

            return STATUS_CANNOT_DELETE;
        }
    }

    //
    //  Otherwise we need to check the requested access vs. the allowable
    //  access in the ACL on the file.  We will want to remember if
    //  MAXIMUM_ALLOWED was requested and remove the invalid bits for
    //  a read-only file.
    //

    //
    //  Remember if maximum allowed was requested.
    //

    if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                MAXIMUM_ALLOWED )) {

        MaximumAllowed = TRUE;
    }

    NtfsOpenCheck( IrpContext,
                   ThisFcb,
                   (((ThisLcb != NULL) && (ThisLcb != ThisFcb->Vcb->RootLcb))
                    ? ThisLcb->Scb->Fcb
                    : NULL),
                   IrpContext->OriginatingIrp );

    //
    //  If this is a read-only file (not directory) and we requested maximum allowed then
    //  remove the invalid bits. Ditto for readonly volumes.
    //

    if (MaximumAllowed &&
        ((IsReadOnly( &ThisFcb->Info ) & !Index) ||
         NtfsIsVolumeReadOnly( ThisFcb->Vcb ))) {

        ClearFlag( AccessState->PreviouslyGrantedAccess,
                   FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_ADD_SUBDIRECTORY | FILE_DELETE_CHILD );
    }

    //
    //  We do a check here to see if we conflict with the delete status on the
    //  file.  Right now we check if there is already an opener who has delete
    //  access on the file and this opener doesn't allow delete access.
    //  We can skip this test if the opener is not requesting read, write or
    //  delete access.
    //

    if (ThisFcb->FcbDeleteFile != 0
        && FlagOn( AccessState->PreviouslyGrantedAccess, NtfsAccessDataFlags )
        && !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_DELETE )) {

        DebugTrace( -1, Dbg, ("NtfsCheckExistingFile:  Exit\n") );
        return STATUS_SHARING_VIOLATION;
    }

    //
    //  We do a check here to see if we conflict with the delete status on the
    //  file.  If we are opening the file and requesting delete, then there can
    //  be no current handles which deny delete.
    //

    if (ThisFcb->FcbDenyDelete != 0
        && FlagOn( AccessState->PreviouslyGrantedAccess, DELETE )
        && FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

        return STATUS_SHARING_VIOLATION;
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine.
//

NTSTATUS
NtfsBreakBatchOplock (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    OUT PSCB *ThisScb
    )

/*++

Routine Description:

    This routine is called for each open of an existing attribute to
    check for current batch oplocks on the file.  We will also check
    whether we will want to flush and purge this stream in the case
    where only non-cached handles remain on the file.  We only want
    to do that in an Fsp thread because we will require every bit
    of stack we can get.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisFcb - This is the Fcb for the file being opened.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    ThisScb - Address to store the Scb if found or created.

Return Value:

    NTSTATUS - Will be either STATUS_SUCCESS or STATUS_PENDING.

--*/

{
    BOOLEAN ScbExisted;
    PSCB NextScb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBreakBatchOplock:  Entered\n") );

    //
    //  In general we will just break the batch oplock for the stream we
    //  are trying to open.  However if we are trying to delete the file
    //  and someone has a batch oplock on a different stream which
    //  will cause our open to fail then we need to try to break those
    //  batch oplocks.  Likewise if we are opening a stream and won't share
    //  with a file delete then we need to break any batch oplocks on the main
    //  stream of the file.
    //

    //
    //  Consider the case where we are opening a stream and there is a
    //  batch oplock on the main data stream.
    //

    if (AttrName.Length != 0) {

        if (ThisFcb->FcbDeleteFile != 0 &&
            !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_DELETE )) {

            Links = ThisFcb->ScbQueue.Flink;

            while (Links != &ThisFcb->ScbQueue) {

                NextScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                if (NextScb->AttributeTypeCode == $DATA &&
                    NextScb->AttributeName.Length == 0) {

                    if (FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                        //
                        //  We remember if a batch oplock break is underway for the
                        //  case where the sharing check fails.
                        //

                        Irp->IoStatus.Information = FILE_OPBATCH_BREAK_UNDERWAY;

                        //
                        //  If the oplock break is pending raise can't wait and retry at the top
                        //

                        if (FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                              Irp,
                                              (PVOID) IrpContext,
                                              NtfsOplockComplete,
                                              NtfsOplockPrePostIrp ) == STATUS_PENDING) {

                            return STATUS_WAIT_FOR_OPLOCK;
                        }
                    }

                    break;
                }

                Links = Links->Flink;
            }
        }

    //
    //  Now consider the case where we are opening the main stream and want to
    //  delete the file but an opener on a stream is preventing us.
    //

    } else if (ThisFcb->FcbDenyDelete != 0 &&
               FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess,
                       MAXIMUM_ALLOWED | DELETE )) {

        //
        //  Find all of the other data Scb and check their oplock status.
        //

        Links = ThisFcb->ScbQueue.Flink;

        while (Links != &ThisFcb->ScbQueue) {

            NextScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

            if (NextScb->AttributeTypeCode == $DATA &&
                NextScb->AttributeName.Length != 0) {

                if (FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                    //
                    //  We remember if a batch oplock break is underway for the
                    //  case where the sharing check fails.
                    //

                    Irp->IoStatus.Information = FILE_OPBATCH_BREAK_UNDERWAY;

                    //
                    //  We wait on the oplock.
                    //

                    if (FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                          Irp,
                                          (PVOID) IrpContext,
                                          NtfsOplockComplete,
                                          NtfsOplockPrePostIrp ) == STATUS_PENDING) {

                        return STATUS_WAIT_FOR_OPLOCK;
                    }

                    Irp->IoStatus.Information = 0;
                }
            }

            Links = Links->Flink;
        }
    }

    //
    //  We try to find the Scb for this file.
    //

    *ThisScb = NtfsCreateScb( IrpContext,
                              ThisFcb,
                              AttrTypeCode,
                              &AttrName,
                              FALSE,
                              &ScbExisted );

    //
    //  If there was a previous Scb, we examine the oplocks.
    //

    if (ScbExisted &&
        (SafeNodeType( *ThisScb ) == NTFS_NTC_SCB_DATA)) {

        //
        //  If we have to flush and purge then we want to be in the Fsp.
        //

        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) &&
            FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            ((*ThisScb)->CleanupCount == (*ThisScb)->NonCachedCleanupCount) &&
            ((*ThisScb)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {


            NtfsRaiseToPost( IrpContext );
        }

        if (FsRtlCurrentBatchOplock( &(*ThisScb)->ScbType.Data.Oplock )) {

            //
            //  If the handle count is greater than 1 then fail this
            //  open now.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER ) &&
                ((*ThisScb)->CleanupCount > 1)) {

                NtfsRaiseStatus( IrpContext, STATUS_OPLOCK_NOT_GRANTED, NULL, NULL );
            }

            DebugTrace( 0, Dbg, ("Breaking batch oplock\n") );

            //
            //  We remember if a batch oplock break is underway for the
            //  case where the sharing check fails.
            //

            Irp->IoStatus.Information = FILE_OPBATCH_BREAK_UNDERWAY;

            if (FsRtlCheckOplock( &(*ThisScb)->ScbType.Data.Oplock,
                                  Irp,
                                  (PVOID) IrpContext,
                                  NtfsOplockComplete,
                                  NtfsOplockPrePostIrp ) == STATUS_PENDING) {

                return STATUS_WAIT_FOR_OPLOCK;
            }

            Irp->IoStatus.Information = 0;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsBreakBatchOplock:  Exit  -  %08lx\n", STATUS_SUCCESS) );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsCompleteLargeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PLCB Lcb OPTIONAL,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN ULONG CreateFlags
    )

/*++

Routine Description:

    This routine is called when we need to add more allocation to a stream
    being opened.  This stream could have been reallocated or created with
    this call but we didn't allocate all of the space in the main path.

Arguments:

    Irp - This is the Irp for this open operation.

    Lcb - This is the Lcb used to reach the stream being opened.  Won't be
        specified in the open by ID case.

    Scb - This is the Scb for the stream being opened.

    Ccb - This is the Ccb for the this user handle.

    CreateFlags - Indicates if this handle requires delete on close and
        if we created or reallocated this stream.

Return Value:

    NTSTATUS - the result of this operation.

--*/

{
    NTSTATUS Status;
    FILE_ALLOCATION_INFORMATION AllInfo;

    PAGED_CODE();

    //
    //  Commit the current transaction and free all resources.
    //

    NtfsCheckpointCurrentTransaction( IrpContext );
    NtfsReleaseAllResources( IrpContext );

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );
    AllInfo.AllocationSize = Irp->Overlay.AllocationSize;

    Status = IoSetInformation( IoGetCurrentIrpStackLocation( Irp )->FileObject,
                               FileAllocationInformation,
                               sizeof( FILE_ALLOCATION_INFORMATION ),
                               &AllInfo );

    ASSERT( (Scb->CompressionUnit == 0) || (Scb->Header.AllocationSize.QuadPart % Scb->CompressionUnit == 0) );

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

    //
    //  Success!  We will reacquire the Vcb quickly to undo the
    //  actions taken above to block access to the new file/attribute.
    //

    if (NT_SUCCESS( Status )) {

        NtfsAcquireExclusiveVcb( IrpContext, Scb->Vcb, TRUE );

        //
        //  Enable access to new file.
        //

        if (FlagOn( CreateFlags, CREATE_FLAG_CREATE_FILE_CASE )) {

            Scb->Fcb->LinkCount = 1;

            if (ARGUMENT_PRESENT( Lcb )) {

                ClearFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                    ClearFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                }
            }

        //
        //  Enable access to new attribute.
        //

        } else {

            ClearFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
        }

        //
        //  If this is the DeleteOnClose case, we mark the Scb and Lcb
        //  appropriately.
        //

        if (FlagOn( CreateFlags, CREATE_FLAG_DELETE_ON_CLOSE )) {

            SetFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
        }

        NtfsReleaseVcb( IrpContext, Scb->Vcb );

    //
    //  Else there was some sort of error, and we need to let cleanup
    //  and close execute, since when we complete Create with an error
    //  cleanup and close would otherwise never occur.  Cleanup will
    //  delete or truncate a file or attribute as appropriate, based on
    //  how we left the Fcb/Lcb or Scb above.
    //

    } else {

        NtfsIoCallSelf( IrpContext,
                        IoGetCurrentIrpStackLocation( Irp )->FileObject,
                        IRP_MJ_CLEANUP );

        NtfsIoCallSelf( IrpContext,
                        IoGetCurrentIrpStackLocation( Irp )->FileObject,
                        IRP_MJ_CLOSE );
    }

    return Status;
}


//
//  Local support routine
//

ULONG
NtfsOpenExistingEncryptedStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN PFCB CurrentFcb
    )

/*++

Routine Description:

    This routine determines with which FileDirFlags, if any, we should call
    the encryption driver's create callback.

Arguments:

    ThisScb - This is the Scb for the file being opened.

    CurrentFcb - This is the Fcb for the file being opened.

Return Value:

    ULONG - The set of flags, such as FILE_EXISTING or DIRECTORY_EXISTING that
            should be passed to the encryption driver.  If 0 is returned, there
            is no need to call the encryption driver for this create.

--*/

{
    ULONG EncryptionFileDirFlags = 0;

    //
    //  If we don't have an encryption driver then raise ACCESS_DENIED unless
    //  this is a directory, in which case there really isn't any encrypted data
    //  that we need to worry about.  Consider the case where the user has
    //  marked a directory as encrypted and then removed the encryption driver.
    //  There may be unencrypted files in that directory, and there's no reason
    //  to prevent the user from getting to them.
    //

    if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER ) &&
        !IsDirectory( &CurrentFcb->Info )) {

        NtfsRaiseStatus( IrpContext, STATUS_ACCESS_DENIED, NULL, NULL );
    }

    //
    //  In NT5, we have not tested with encrypted compressed files, so if we
    //  encounter one (perhaps NT6 created it and the user has gone back to
    //  an NT5 safe build) let's not allow opening it for read/write access.
    //  Like the test above, this is only an issue for files, not directories.
    //

    if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
        !IsDirectory( &CurrentFcb->Info )) {

        NtfsRaiseStatus( IrpContext, STATUS_ACCESS_DENIED, NULL, NULL );
    }

    //
    //  Set the appropriate flags for the 3 existing stream cases.
    //

    if (IsDirectory( &CurrentFcb->Info )) {

        EncryptionFileDirFlags = DIRECTORY_EXISTING | STREAM_EXISTING;

    } else if (IsEncrypted( &CurrentFcb->Info )) {

        EncryptionFileDirFlags = FILE_EXISTING | STREAM_EXISTING | EXISTING_FILE_ENCRYPTED ;

    } else {

        EncryptionFileDirFlags = FILE_EXISTING | STREAM_EXISTING;
    }

    return EncryptionFileDirFlags;
}


//
//  Local support routine
//

NTSTATUS
NtfsEncryptionCreateCallback (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ThisScb,
    IN PCCB ThisCcb,
    IN PFCB ParentFcb,
    IN PCREATE_CONTEXT CreateContext,
    IN BOOLEAN CreateNewFile
    )

/*++

Routine Description:

    This routine performs the create callback to the encryption driver if one
    is registered, and it is appropriate to do the callback.  We do the
    callback for the open of an existing stream that is marked as encrypted,
    and for the creation of a new file/stream that will be encrypted.

    There are a number of interesting cases, each of which requires its own
    set of flags to be passed to the encryption engine.  Some optimization may
    be possible by setting and clearing individual bits for certain semi-general
    cases, but at a massive cost in readability/maintainability.

    Note: The encryption context is created if necc. in EfsPostCreateCall and not
    at this point

Arguments:

    Irp - Supplies the Irp to process.

    ThisScb - This is the Scb for the file being opened.

    ThisCcb - This is the Ccb for the file being opened

    ParentFcb - This is the Fcb for the parent of the file being opened.
                Although not truly optional, it may be NULL for an
                existing file being opened, such as an open by id.

    CreateNewFile - TRUE if we're being called from NtfsCreateNewFile, FALSE otherwise.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS EncryptionStatus = STATUS_SUCCESS;
    ULONG FileAttributes = (ULONG) IrpSp->Parameters.Create.FileAttributes;
    ULONG EncryptionFileDirFlags = 0;

    PAGED_CODE();

    //
    //  If this is an existing stream and the encryption bit is set then either
    //  call the driver or fail the request.  We have to test CreateNewFile
    //  also in case our caller has not set the Information field of the Irp yet.
    //

    if (!NtfsIsStreamNew( Irp->IoStatus.Information ) &&
        !CreateNewFile) {

        if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
            FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_EXECUTE)) {

            EncryptionFileDirFlags = NtfsOpenExistingEncryptedStream( IrpContext, ThisScb, CreateContext->CurrentFcb );
        } // else EncryptionFileDirFlags = 0;

    //
    //  We need the encryption driver for new creates.  We may be dealing with a
    //  new file create or a supersede/overwrite.
    //

    } else if (FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

        if (CreateNewFile) {

            //
            //  This is a new stream in a new file.
            //

            ASSERT( (ParentFcb == NULL) ||
                    FlagOn( ParentFcb->FcbState, FCB_STATE_DUP_INITIALIZED ));

            //
            //  We want this new file/directory to be created encrypted if
            //  its parent directory is encrypted, or our caller has asked
            //  to have it created encrypted.
            //

            if (((ParentFcb != NULL) &&
                 (IsEncrypted( &ParentFcb->Info ))) ||

                FlagOn( FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

                if (IsDirectory( &CreateContext->CurrentFcb->Info )) {

                    EncryptionFileDirFlags = DIRECTORY_NEW | STREAM_NEW;

                } else {

                    EncryptionFileDirFlags = FILE_NEW | STREAM_NEW;
                }
            } // else EncryptionFileDirFlags = 0;

        } else {

            //
            //  This is a supersede/overwrite or else a new stream being created
            //  in an existing file.
            //

            ASSERT( CreateContext->CurrentFcb != NULL );
            ASSERT( NtfsIsStreamNew( Irp->IoStatus.Information ) );

            if ((Irp->IoStatus.Information == FILE_SUPERSEDED) ||
                (Irp->IoStatus.Information == FILE_OVERWRITTEN)) {

                if (FlagOn( FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

                    //
                    //  This is a supersede/overwrite where the caller set the encrypted flag.
                    //

                    if (IsDirectory( &CreateContext->CurrentFcb->Info )) {

                        EncryptionFileDirFlags = DIRECTORY_NEW | STREAM_NEW;

                    } else if (FlagOn( ThisScb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        //
                        //  When superseding/overwriting the unnamed stream, the flags we
                        //  pass depend on the encrypted state of the old file.
                        //

                        if (IsEncrypted( &CreateContext->CurrentFcb->Info )) {

                            EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;

                        } else {

                            //
                            //  If there are open handles to this or any other stream, and the
                            //  encryption engine will wish it could encrypt all streams, we
                            //  may as well just fail the create now.
                            //

                            if ((CreateContext->CurrentFcb->CleanupCount > 1) &&
                                FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS )) {

                                NtfsRaiseStatus( IrpContext, STATUS_SHARING_VIOLATION, NULL, NULL );
                            }

                            EncryptionFileDirFlags = FILE_NEW | STREAM_NEW;
                        }

                    } else if (!FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS )) {

                        //
                        //  We're superseding a named stream; if the encryption engine allows individual
                        //  streams to be encrypted, notify it.
                        //

                        EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;
                    } // else EncryptionFileDirFlags = 0;

                } else if (!FlagOn( ThisScb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                           IsEncrypted( &CreateContext->CurrentFcb->Info )) {

                    //
                    //  This is a supersede/overwrite of a named stream within an encrypted file.
                    //

                    if (IsDirectory( &CreateContext->CurrentFcb->Info )) {

                        EncryptionFileDirFlags = DIRECTORY_EXISTING | STREAM_NEW;

                    } else {

                        EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;
                    }

                } else {

                    //
                    //  We're superseding/overwriting the unnamed stream, and it's retaining
                    //  its encryption from before the overwrite.
                    //

                    if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
                        FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                                FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_EXECUTE)) {

                        EncryptionFileDirFlags = NtfsOpenExistingEncryptedStream( IrpContext, ThisScb, CreateContext->CurrentFcb );
                    }
                }

            } else if (IsEncrypted( &CreateContext->CurrentFcb->Info )) {

                ASSERT( Irp->IoStatus.Information == FILE_CREATED );

                //
                //  This is a new stream being created in an existing encrypted file.
                //

                if (IsDirectory( &CreateContext->CurrentFcb->Info )) {

                    EncryptionFileDirFlags = DIRECTORY_EXISTING | STREAM_NEW;

                } else {

                    EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;
                }
            } // else EncryptionFileDirFlags = 0;
        }
    } // else EncryptionFileDirFlags = 0;

    //
    //  Remember the EncryptionFileDirFlags in case we need to use them to
    //  cleanup later.
    //

    ASSERT( CreateContext->EncryptionFileDirFlags == 0 ||
            CreateContext->EncryptionFileDirFlags == EncryptionFileDirFlags );

    CreateContext->EncryptionFileDirFlags = EncryptionFileDirFlags;

    //
    //  Perform the update if we have encryption flags and there is a callback.
    //

    if (EncryptionFileDirFlags != 0) {

        if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

            //
            //  While we're still holding the fcb, set the bit that reminds us
            //  to block other creates until the encryption engine has had its
            //  chance to set the key context for this stream.
            //

            ASSERT_EXCLUSIVE_FCB( CreateContext->CurrentFcb );
            SetFlag( CreateContext->CurrentFcb->FcbState, FCB_STATE_ENCRYPTION_PENDING );
        }

        if (NtfsData.EncryptionCallBackTable.FileCreate != NULL) {

            //
            //  Find the parent, if we can't find a parent (most likely in
            //  the supersede by id case) just pass the current fcb as the
            //  parent.
            //

            if ((ParentFcb == NULL)) {

                if ((ThisCcb->Lcb != NULL) &&
                    (ThisCcb->Lcb->Scb != NULL )) {

                    ParentFcb = ThisCcb->Lcb->Scb->Fcb;

                } else {

                    ParentFcb = CreateContext->CurrentFcb;
                }
            }

            ASSERT( ParentFcb != NULL );

            EncryptionStatus = NtfsData.EncryptionCallBackTable.FileCreate(
                                    CreateContext->CurrentFcb,
                                    ParentFcb,
                                    IrpSp,
                                    EncryptionFileDirFlags,
                                    (NtfsIsVolumeReadOnly( CreateContext->CurrentFcb->Vcb )) ? READ_ONLY_VOLUME : 0,
                                    IrpContext,
                                    (PDEVICE_OBJECT) CONTAINING_RECORD( CreateContext->CurrentFcb->Vcb,
                                                                        VOLUME_DEVICE_OBJECT,
                                                                        Vcb ),
                                    NULL,
                                    &ThisScb->EncryptionContext,
                                    &ThisScb->EncryptionContextLength,
                                    &CreateContext->EncryptionContext,
                                    NULL );

            if (EncryptionStatus != STATUS_SUCCESS) {

                NtfsRaiseStatus( IrpContext, EncryptionStatus, NULL, NULL );
            }
        }
    }

    return EncryptionStatus;
}


//
//  Local support routine
//

VOID
NtfsPostProcessEncryptedCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN ULONG EncryptionFileDirFlags,
    IN ULONG FailedInPostCreateOnly
    )

/*++

Routine Description:

    This routine is called after the encryption driver's post create callout
    returns.  If we failed a create in the post create callout that had been
    successful before the post create callout, we have to cleanup the file.
    If we just created the file, we need to clear the encryption_pending bit
    safely.

Arguments:

    FileObject - Supplies the FileObject being created.

    EncryptionFileDirFlags - Some combination of FILE_NEW, FILE_EXISTING, etc.

    FailedInPostCreateOnly - Pass TRUE if the create operation had succeeded
                             until the PostCreate callout.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PLCB Lcb;

    NTSTATUS Status;

    BOOLEAN FcbStillExists = TRUE;

    PAGED_CODE();

    //
    //  In some failure cases, we'll have no FileObject, in which case we have
    //  no cleanup to do.  We can't do much without a FileObject anyway.
    //

    if (FileObject == NULL) {

        return;
    }

    NtfsDecodeFileObject( IrpContext,
                          FileObject,
                          &Vcb,
                          &Fcb,
                          &Scb,
                          &Ccb,
                          FALSE );

    //
    //  If we failed only in the post create, backout this create.
    //

    if (FailedInPostCreateOnly) {

        if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW ) ||

            (FlagOn( EncryptionFileDirFlags, STREAM_NEW ) &&
             FlagOn( EncryptionFileDirFlags, FILE_EXISTING ))) {

            //
            //  Delete the stream if we still can.  First acquire
            //  the Scb so we can safely test some bits in it.
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );

            //
            //  If a dismount happened while we weren't holding the Scb,
            //  we should just do the cleanup & close and get out of here.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                //
                //  See if we can still delete the stream.  N.B. If we're
                //  working with the unnamed data stream, deleting the
                //  stream will delete the file.
                //

                Lcb = Ccb->Lcb;

                if (!FlagOn( Scb->ScbState, SCB_STATE_MULTIPLE_OPENS ) &&
                    (Lcb != NULL)) {

                    //
                    //  Now see if the file is really deleteable according to indexsup
                    //

                    if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                        BOOLEAN LastLink;
                        BOOLEAN NonEmptyIndex = FALSE;

                        //
                        //  If the link is not deleted, we check if it can be deleted.
                        //  Since we dropped all our resources for the PostCreate callout,
                        //  this might be a nonempty index or a file with multiple
                        //  links already.
                        //

                        if (!LcbLinkIsDeleted( Lcb ) && NtfsIsLinkDeleteable( IrpContext, Scb->Fcb, &NonEmptyIndex, &LastLink )) {


                            //
                            //  It is ok to get rid of this guy.  All we need to do is
                            //  mark this Lcb for delete and decrement the link count
                            //  in the Fcb.  If this is a primary link, then we
                            //  indicate that the primary link has been deleted.
                            //

                            SetFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                            ASSERTMSG( "Link count should not be 0\n", Scb->Fcb->LinkCount != 0 );
                            Scb->Fcb->LinkCount -= 1;

                            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                                SetFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                            }

                            //
                            //  Indicate in the file object that a delete is pending
                            //

                            FileObject->DeletePending = TRUE;
                        }

                    } else {

                        //
                        //  Otherwise we are simply removing the attribute.
                        //

                        SetFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );

                        //
                        //  Indicate in the file object that a delete is pending
                        //

                        FileObject->DeletePending = TRUE;
                    }
                }
            }

            //
            //  We can clear the pending bit now that we're done handling the
            //  failure.
            //

            if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

                ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );
                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
                ASSERT( (Scb->EncryptionContext != NULL) || FailedInPostCreateOnly );
                ClearFlag( Fcb->FcbState, FCB_STATE_ENCRYPTION_PENDING );
                KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
                NtfsReleaseFcb( IrpContext, Fcb );
            }

            //
            //  We need to release the Scb now, since the close may
            //  result in the Scb getting freed.
            //

            NtfsReleaseScb( IrpContext, Scb );

            Status = NtfsIoCallSelf( IrpContext,
                                     FileObject,
                                     IRP_MJ_CLEANUP );

            ASSERT( STATUS_SUCCESS == Status );

            FcbStillExists = FALSE;

            Status = NtfsIoCallSelf( IrpContext,
                                     FileObject,
                                     IRP_MJ_CLOSE );

            ASSERT( STATUS_SUCCESS == Status );

        } else if ((FlagOn( EncryptionFileDirFlags, FILE_EXISTING ) &&
                    FlagOn( EncryptionFileDirFlags, STREAM_EXISTING )) ||

                   FlagOn( EncryptionFileDirFlags, DIRECTORY_EXISTING )) {

#ifdef NTFSDBG
            ASSERT( None == IrpContext->OwnershipState );
#endif

            //
            //  All we have to do in this case is a cleanup and a close.
            //

            Status = NtfsIoCallSelf( IrpContext,
                                     FileObject,
                                     IRP_MJ_CLEANUP );

            ASSERT( STATUS_SUCCESS == Status );

            FcbStillExists = FALSE;

            Status = NtfsIoCallSelf( IrpContext,
                                     FileObject,
                                     IRP_MJ_CLOSE );

            ASSERT( STATUS_SUCCESS == Status );
        }
    }

    //
    //  If we've done a cleanup & close, the Fcb may have been freed already,
    //  in which case we should just set the pending event and get out of here.
    //  If we still have the Fcb, let's make sure we've cleared the pending bit.
    //

    if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

        if (FcbStillExists) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );
            NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
            ClearFlag( Fcb->FcbState, FCB_STATE_ENCRYPTION_PENDING );
            KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
            NtfsReleaseFcb( IrpContext, Fcb );

        } else {

            KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
        }
    }
}


NTSTATUS
NtfsTryOpenFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PFCB *CurrentFcb,
    IN FILE_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine is called to open a file by its file segment number.
    We need to verify that this file Id exists.  This code is
    patterned after open by Id.

Arguments:

    Vcb - Vcb for this volume.

    CurrentFcb - Address of Fcb pointer.  Store the Fcb we find here.

    FileReference - This is the file Id for the file to open the
                    sequence number is ignored.

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

Note:

    If the status is successful then the FCB is returned with its reference
    count incremented and the FCB held exclusive.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LONGLONG MftOffset;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PBCB Bcb = NULL;

    PFCB ThisFcb;

    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN AcquiredMft = TRUE;
    BOOLEAN ThisFcbFree = TRUE;

    PAGED_CODE();

    ASSERT( *CurrentFcb == NULL );

    //
    //  Do not bother with system files.
    //

    //
    //  If this is a system fcb then return.
    //

    if (NtfsFullSegmentNumber( &FileReference ) < FIRST_USER_FILE_NUMBER &&
        NtfsFullSegmentNumber( &FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER) {

        return STATUS_NOT_FOUND;
    }

    //
    //  Calculate the offset in the MFT. Use the full segment number since the user
    //  can specify any 48-bit value.
    //

    MftOffset = NtfsFullSegmentNumber( &FileReference );

    MftOffset = Int64ShllMod32(MftOffset, Vcb->MftShift);

    //
    //  Acquire the MFT shared so it cannot shrink on us.
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->MftScb );

    try {

        if (MftOffset >= Vcb->MftScb->Header.FileSize.QuadPart) {

            DebugTrace( 0, Dbg, ("File Id doesn't lie within Mft\n") );

             Status = STATUS_END_OF_FILE;
             leave;
        }

        NtfsReadMftRecord( IrpContext,
                           Vcb,
                           &FileReference,
                           FALSE,
                           &Bcb,
                           &FileRecord,
                           NULL );

        //
        //  This file record better be in use, better not be one of the other system files,
        //  and have a matching sequence number and be the primary file record for this file.
        //

        if (!FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) ||
            FlagOn( FileRecord->Flags, FILE_SYSTEM_FILE ) ||
            (*((PLONGLONG) &FileRecord->BaseFileRecordSegment) != 0) ||
            (*((PULONG) FileRecord->MultiSectorHeader.Signature) != *((PULONG) FileSignature))) {

            Status = STATUS_NOT_FOUND;
            leave;
        }

        //
        //  Get the current sequence number.
        //

        FileReference.SequenceNumber = FileRecord->SequenceNumber;

        NtfsUnpinBcb( IrpContext, &Bcb );

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        //
        //  We know that it is safe to continue the open.  We start by creating
        //  an Fcb for this file.  It is possible that the Fcb exists.
        //  We create the Fcb first, if we need to update the Fcb info structure
        //  we copy the one from the index entry.  We look at the Fcb to discover
        //  if it has any links, if it does then we make this the last Fcb we
        //  reached.  If it doesn't then we have to clean it up from here.
        //

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 Vcb,
                                 FileReference,
                                 FALSE,
                                 TRUE,
                                 NULL );

        //
        //  ReferenceCount the fcb so it does no go away.
        //

        ThisFcb->ReferenceCount += 1;

        //
        //  Release the mft and fcb table before acquiring the FCB exclusive.
        //

        NtfsReleaseScb( IrpContext, Vcb->MftScb );
        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredMft = FALSE;
        AcquiredFcbTable = FALSE;

        NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
        ThisFcbFree = FALSE;

        //
        //  Repin the file record with synchronization to the fcb
        //

        NtfsReadMftRecord( IrpContext,
                           Vcb,
                           &FileReference,
                           FALSE,
                           &Bcb,
                           &FileRecord,
                           NULL );

        //
        //  Skip any deleted files.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_FILE_DELETED ) ||
            !FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE )) {

            NtfsUnpinBcb( IrpContext, &Bcb );

#ifdef QUOTADBG
            DbgPrint( "NtfsTryOpenFcb: Deleted fcb found. Fcb = %lx\n", ThisFcb );
#endif
            NtfsAcquireFcbTable( IrpContext, Vcb );
            ASSERT( ThisFcb->ReferenceCount > 0 );
            ThisFcb->ReferenceCount--;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            NtfsTeardownStructures( IrpContext,
                                    ThisFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    &ThisFcbFree );

            //
            //  Release the fcb if it has not been deleted.
            //

            if (!ThisFcbFree) {
                NtfsReleaseFcb( IrpContext, ThisFcb );
                ThisFcbFree = TRUE;
            }

            //
            //  Teardown may generate a transaction, clean it up.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, Status );

            Status = STATUS_NOT_FOUND;
            leave;
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        //
        //  Store this Fcb into our caller's parameter and remember to
        //  to show we acquired it.
        //

        *CurrentFcb = ThisFcb;
        ThisFcbFree = TRUE;


        //
        //  If the Fcb Info field needs to be initialized, we do so now.
        //  We read this information from the disk.
        //

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            NtfsUpdateFcbInfoFromDisk( IrpContext,
                                       TRUE,
                                       ThisFcb,
                                       NULL );

        }

    } finally {

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        if (AcquiredMft) {
            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

        if (!ThisFcbFree) {
            NtfsReleaseFcb( IrpContext, ThisFcb );
        }
    }

    return Status;

}


//
//  Worker routine.
//

NTSTATUS
NtfsGetReparsePointValue (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN USHORT RemainingNameLength
    )

/*++

Routine Description:

    This routine retrieves the value of the specified reparse point and returns it to
    the caller.

    The user-controlled data in the reparse point is returned in a new buffer pointed
    from  Irp->Tail.Overlay.AuxiliaryBuffer. When the request traverses the stack of
    layered drivers and not one operates on it, it is freed by the I/O subsystem in
    IoCompleteRequest.

    To provide callers with an indication of where in the name the parsing stoped, in
    the Reserved field of the REPARSE_DATA_BUFFER structure we return the length of the
    portion of the name that remains to be parsed by NTFS. We account for the file
    delimiter in our value to make the paste of names easy in IopParseDevice.

    The name offset arithmetic is correct only if:
    (1) All the intermediate names in the path are simple, that is, they do not contain
        any : (colon) in them.
    (2) The RemainingNameLength includes all the parts present in the last name component.

    When this function succeeds, it sets in Irp->IoStatus.Information the Tag of the
    reparse point that we have just copied out. In this case we return STATUS_REPARSE
    and set Irp->IoStatus.Status to STATUS_REPARSE.

Arguments:

    IrpContext - Supplies the Irp context of the call.

    Irp - Supplies the Irp being processed

    IrpSp - This is the Irp stack pointer for the filesystem.

    Fcb - Address of the Fcb pointer where the $REPARSE_POINT attribute is located.

    RemainingNameLength - Length of the part of the name that still needs to be parsed.

Return Value:

    NTSTATUS - The return status for the operation.
               If successful, STATUS_REPARSE will be returned.

--*/

{
    NTSTATUS Status = STATUS_REPARSE;
    PREPARSE_DATA_BUFFER ReparseBuffer = NULL;

    POPLOCK_CLEANUP OplockCleanup = IrpContext->Union.OplockCleanup;

    BOOLEAN CleanupAttributeContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
    ULONG AttributeLengthInBytes = 0;    //  Invalid value
    PVOID AttributeData = NULL;

    PBCB Bcb = NULL;

    PAGED_CODE( );

    DebugTrace( +1, Dbg, ("NtfsGetReparsePointValue,  Fcb %08lx\n", Fcb) );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    DebugTrace( 0, Dbg, ("OplockCleanup->OriginalFileName %x %Z\n", OplockCleanup->OriginalFileName.Buffer, &OplockCleanup->OriginalFileName) );
    DebugTrace( 0, Dbg, ("OplockCleanup->FullFileName     %x %Z\n", OplockCleanup->FullFileName.Buffer, &OplockCleanup->FullFileName) );
    DebugTrace( 0, Dbg, ("OplockCleanup->ExactCaseName    %x %Z\n", OplockCleanup->ExactCaseName.Buffer, &OplockCleanup->ExactCaseName) );
    DebugTrace( 0, Dbg, ("IrpSP...->FileName              %x %Z\n", IrpSp->FileObject->FileName.Buffer, &IrpSp->FileObject->FileName) );
#endif

    DebugTrace( 0,
                Dbg,
                ("Length of remaining name [d] %04ld %04lx OriginalFileName.Length [d] %04ld %04lx\n",
                 RemainingNameLength,
                 RemainingNameLength,
                 OplockCleanup->OriginalFileName.Length,
                 OplockCleanup->OriginalFileName.Length) );

    ASSERT( FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ));
    ASSERT( Irp->Tail.Overlay.AuxiliaryBuffer == NULL );

    //
    //  Now it is time to use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Find the reparse point attribute in the file.
        //

        CleanupAttributeContext = TRUE;
        NtfsInitializeAttributeContext( &AttributeContext );

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $REPARSE_POINT,
                                        &AttributeContext )) {

            DebugTrace( 0, Dbg, ("Can't find the $REPARSE_POINT attribute.\n") );

            //
            //  Should not happen. Raise an exeption as we are in an
            //  inconsistent state. The attribute flag says that
            //  $REPARSE_POINT has to be present.
            //

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Find the size of the attribute and map its value to AttributeData.
        //

        AttributeHeader = NtfsFoundAttribute( &AttributeContext );

        if (NtfsIsAttributeResident( AttributeHeader )) {

            AttributeLengthInBytes = AttributeHeader->Form.Resident.ValueLength;
            DebugTrace( 0, Dbg, ("Attribute is resident with length %08lx\n", AttributeLengthInBytes) );

            if (AttributeLengthInBytes > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                leave;
            }

            //
            // Point to the value of the attribute.
            //

            AttributeData = NtfsAttributeValue( AttributeHeader );

        } else {

            ULONG Length;

            if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                DebugTrace( 0, Dbg, ("Nonresident.FileSize is too long.\n") );

                leave;
            }

            //
            //  Note that we coerse different LENGTHS
            //

            AttributeLengthInBytes = (ULONG)AttributeHeader->Form.Nonresident.FileSize;
            DebugTrace( 0, Dbg, ("Attribute is non-resident with length %05lx\n", AttributeLengthInBytes) );

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   &AttributeData,
                                   &Length,
                                   &Bcb,
                                   &AttributeContext );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
            if (AttributeLengthInBytes != Length) {
                DebugTrace( 0, Dbg, ("AttributeLengthInBytes [d]%05ld and Length [d]%05ld differ.\n", AttributeLengthInBytes, Length) );
            }
            ASSERT( AttributeLengthInBytes == Length );
#endif
        }

        //
        //  Reference the reparse point data.
        //  It is appropriate to use this cast, and not concern ourselves with the GUID
        //  buffer, because we only read the common fields.
        //

        ReparseBuffer = (PREPARSE_DATA_BUFFER)AttributeData;
        DebugTrace( 0, Dbg, ("ReparseDataLength [d]%08ld %08lx\n",
                    ReparseBuffer->ReparseDataLength, ReparseBuffer->ReparseDataLength) );

        //
        //  Validate the reparse point further
        //

        Status = NtfsValidateReparsePointBuffer( AttributeLengthInBytes,
                                                 ReparseBuffer );

        if (!NT_SUCCESS( Status )) {

            //
            //  Return the error status
            //

            leave;

        } else {

            //
            //  Return STATUS_REPARSE as successful status.
            //

            Status = STATUS_REPARSE;
        }

        //
        //  We leave all the names in their original state.
        //  Return the complete reparse point data buffer off
        //  Irp->Tail.Overlay.AuxiliaryBuffer, already including the ReparseDataLength.
        //

        Irp->Tail.Overlay.AuxiliaryBuffer = NtfsAllocatePool( NonPagedPool,
                                                              AttributeLengthInBytes );
        DebugTrace( 0, Dbg, ("Irp->Tail.Overlay.AuxiliaryBuffer %08lx\n", Irp->Tail.Overlay.AuxiliaryBuffer) );
        RtlCopyMemory( (PCHAR)Irp->Tail.Overlay.AuxiliaryBuffer,
                       (PCHAR)AttributeData,
                       AttributeLengthInBytes );

        //
        //  We also return the length of the portion of the name that remains to be parsed using the
        //  Reserved field in the REPARSE_DATA_BUFFER structure.
        //
        //  The \ (backslash) in a multi-component name is always accounted for by the code before
        //  calling this routine.
        //  The : (colon) in a complex name is always accounted for by the code before calling this
        //  routine.
        //

        ReparseBuffer = (PREPARSE_DATA_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

        ReparseBuffer->Reserved = RemainingNameLength;

        //
        //  Better not have a non-zero length if opened by file id.
        //

        ASSERT( (RemainingNameLength == 0) ||
                !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID ));

        DebugTrace( 0, Dbg, ("Final value for ReparseBuffer->Reserved = %d\n", ReparseBuffer->Reserved) );

        //
        //  When the Reserved field is positive, the offset should always denote the backslash character
        //  or the colon character.
        //
        //  Assert this here.
        //

        if (ReparseBuffer->Reserved) {

            DebugTrace( 0, Dbg, ("NameOffset = %d\n", (OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)) );

            ASSERT( (*((PCHAR)(OplockCleanup->OriginalFileName.Buffer) + (OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)) == L'\\') ||
                    (*((PCHAR)(OplockCleanup->OriginalFileName.Buffer) + (OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)) == L':') );

            ASSERT( (OplockCleanup->OriginalFileName.Buffer[(OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)/sizeof(WCHAR)] == L'\\') ||
                    (OplockCleanup->OriginalFileName.Buffer[(OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)/sizeof(WCHAR)] == L':') );
        }

        //
        //  Set the Information field to the ReparseTag.
        //

        Irp->IoStatus.Information = ReparseBuffer->ReparseTag;

    } finally {

        DebugUnwind( NtfsGetReparsePointValue );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Unpin the Bcb ... in case you needed to pin it above.
        //  The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );
    }

    DebugTrace( -1, Dbg, ("NtfsGetReparsePointValue -> IoStatus.Information %08lx  Status %08lx\n", Irp->IoStatus.Information, Status) );

    return Status;

    UNREFERENCED_PARAMETER( IrpSp );
}

NTSTATUS
NtfsLookupObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUNICODE_STRING FileName,
    OUT PFILE_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine retrieves the value of the specified objectid and returns it to
    the caller.

Arguments:

    IrpContext - Supplies the Irp context of the call.

    Vcb - the volume to look it up in

    FileName - Contains the objectid embedded in the unicode string

    FileReference - on success contains the file that this objectid refers to


Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    UCHAR ObjectId[OBJECT_ID_KEY_LENGTH];
    NTFS_OBJECTID_INFORMATION ObjectIdInfo;
    MAP_HANDLE MapHandle;

    BOOLEAN CleanupMapHandle = FALSE;

    PAGED_CODE();

    //
    //  Copy the object id out of the file name, optionally skipping
    //  over the Win32 backslash at the start of the buffer.
    //

    if (FileName->Length == OBJECT_ID_KEY_LENGTH) {

        RtlCopyMemory( ObjectId,
                       &FileName->Buffer[0],
                       sizeof( ObjectId ) );

    } else {

        RtlCopyMemory( ObjectId,
                       &FileName->Buffer[1],
                       sizeof( ObjectId ) );
    }

    //
    //  Acquire the object id index for the volume.
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->ObjectIdTableScb );

    //
    //  Find the ObjectId.
    //

    try {
        IndexKey.Key = ObjectId;
        IndexKey.KeyLength = sizeof( ObjectId );

        NtOfsInitializeMapHandle( &MapHandle );
        CleanupMapHandle = TRUE;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->ObjectIdTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {
            leave;
        }

        ASSERT( IndexRow.DataPart.DataLength == sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlZeroMemory( &ObjectIdInfo,
                       sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlCopyMemory( &ObjectIdInfo,
                       IndexRow.DataPart.Data,
                       sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlCopyMemory( FileReference,
                       &ObjectIdInfo.FileSystemReference,
                       sizeof( FILE_REFERENCE ) );

        //
        //  Now we have a file reference number, we're ready to proceed
        //  normally and open the file.  There's no point in holding the
        //  object id index anymore, we've looked up all we needed in there.
        //

    } finally {
        NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );

        if (CleanupMapHandle) {
            NtOfsReleaseMap( IrpContext, &MapHandle );
        }
    }

    return Status;
}


#ifdef BRIANDBG
VOID
NtfsTestOpenName (
    IN PFILE_OBJECT FileObject
    )
{
    ULONG Count = NtfsTestName.Length;

    //
    //  This will let us catch particular opens through the debugger.
    //

    if ((Count != 0) &&
        (FileObject->FileName.Length >= Count)) {

        PWCHAR TestChar;
        PWCHAR SourceChar = &FileObject->FileName.Buffer[ FileObject->FileName.Length / sizeof( WCHAR ) ];

        Count = Count / sizeof( WCHAR );
        TestChar = &NtfsTestName.Buffer[ Count ];

        do {
            TestChar -= 1;
            SourceChar -= 1;

            if ((*TestChar | 0x20) != (*SourceChar | 0x20)) {

                break;
            }

            Count -= 1;

        } while (Count != 0);

        ASSERT( Count != 0 );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\close.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Ntfs called by the
    dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

ULONG NtfsAsyncPassCount = 0;

#ifdef LFS_CLUSTER_CHECK
LONG
NtfsFspCloseExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );
#endif

//
//  Local procedure prototypes
//

NTSTATUS
NtfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PCCB *Ccb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN CalledFromFsp
    );

VOID
NtfsQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN DelayClose
    );

PIRP_CONTEXT
NtfsRemoveClose (
    IN PVCB Vcb OPTIONAL,
    IN BOOLEAN ThrottleCreate
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonClose)
#pragma alloc_text(PAGE, NtfsFsdClose)
#pragma alloc_text(PAGE, NtfsFspClose)
#endif


NTSTATUS
NtfsFsdClose (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Close.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    BOOLEAN IsSystemFile;
    BOOLEAN IsReadOnly;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (VolumeDeviceObject->DeviceObject.Size == (USHORT)sizeof(DEVICE_OBJECT)) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace( +1, Dbg, ("NtfsFsdClose\n") );

    //
    //  Extract and decode the file object, we are willing to handle the unmounted
    //  file object.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    //
    //  Special case the unopened file object
    //

    if (TypeOfOpen == UnopenedFileObject) {

        DebugTrace( 0, Dbg, ("Close unopened file object\n") );

        Status = STATUS_SUCCESS;
        NtfsCompleteRequest( NULL, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsFsdClose -> %08lx\n", Status) );
        return Status;
    }

    //
    //  If this is the log file object for the Vcb then clear the field in the Vcb and
    //  return.  We don't need to synchronize here since there is only one file object
    //  and it is closed only once.
    //

    if (FileObject == Vcb->LogFileObject) {

        //
        //  Clear the internal file name constant
        //

        NtfsClearInternalFilename( Vcb->LogFileObject );

        Vcb->LogFileObject = NULL;

        Status = STATUS_SUCCESS;
        NtfsCompleteRequest( NULL, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsFsdClose -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Call the common Close routine
    //

    FsRtlEnterFileSystem();

    //
    //  Remember if this Ccb has gone through close.
    //

    if (Ccb != NULL) {

        //
        //  We are not synchronized with the file resources at this point.
        //  It is possible that NtfsUpdateFileDupInfo or the rename path may want to
        //  update the name in the CCB. Our intention here is to mark this CCB_FLAG_CLOSE
        //  so that these other operations know to skip this CCB.  We need to deal with the
        //  race condition where these other operations don't see the CLOSE flag but
        //  then access the CCB name (which points back to the file object) after we
        //  return the file object to the object manager (but put the CCB on the delayed
        //  close queue).
        //
        //  We will use the Fcb mutex to close the hole where DupInfo and rename need to look
        //  at a CCB that might be in the close path.
        //

        NtfsLockFcb( NULL, Fcb );
        SetFlag( Ccb->Flags, CCB_FLAG_CLOSE );

        //
        //  If we're protecting the name in dupinfo path - strip it from the fileobject and free it
        //  with the ccb
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_PROTECT_NAME )) {

            SetFlag( Ccb->Flags, CCB_FLAG_ALLOCATED_FILE_NAME );
            FileObject->FileName.Buffer = NULL;
            FileObject->FileName.Length = FileObject->FileName.MaximumLength = 0;
        }

        NtfsUnlockFcb( NULL, Fcb );
        ASSERT( FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE ));
    }

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );
    IsSystemFile = FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) || (TypeOfOpen == StreamFileOpen);
    IsReadOnly = (BOOLEAN)IsFileObjectReadOnly( FileObject );

    do {

        try {

            //
            //  Jam Wait to FALSE when we create the IrpContext, to avoid
            //  deadlocks when coming in from cleanup.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, FALSE, &IrpContext );

                //
                //  Set the level structure on the stack.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

                //
                //  If this is a top level request and we are not in the
                //  system process, then we can wait.  If it is a top level
                //  request and we are in the system process then we would
                //  rather not block this thread at all.  If the number of pending
                //  async closes is not too large we will post this immediately.
                //

                if (NtfsIsTopLevelRequest( IrpContext )) {

                    if (PsGetCurrentProcess() != NtfsData.OurProcess) {

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                    //
                    //  This close is within the system process.  It could be
                    //  the segment derefernce thread.  We want to be careful
                    //  about processing the close in this thread.  If we
                    //  process the close too slowly we can eventually
                    //  cause a large backlog of file objects within
                    //  MM.  We will consider posting under the following conditions.
                    //
                    //      - There are more that four times as many file objects as handles (AND)
                    //      - The number of excess file objects (CloseCount - CleanupCount) is
                    //          over our async post threshold for this size system.
                    //      - we're the deref seg thread (identified by current priority being above real time )
                    //

                    } else {

                        NtfsAsyncPassCount += 1;

                        if ((KeQueryPriorityThread( PsGetCurrentThread() ) >= LOW_REALTIME_PRIORITY) ||
                            
                            (FlagOn( NtfsAsyncPassCount, 3 ) &&
                             (Vcb->CleanupCount * 4 < Vcb->CloseCount) &&
                             (Vcb->CloseCount - Vcb->CleanupCount > NtfsAsyncPostThreshold + NtfsMaxDelayedCloseCount))) {

                            Status = STATUS_PENDING;
                            break;
                        }
                    }

                //
                //  This is a recursive Ntfs call.  Post this unless we already
                //  own this file.  Otherwise we could deadlock walking
                //  up the tree. Also if there was any error in the top level post it to
                //  preserve stack
                //

                } else if (!NtfsIsExclusiveScb( Scb ) ||
                           (IrpContext->TopLevelIrpContext->ExceptionStatus != STATUS_SUCCESS )) {

                    Status = STATUS_PENDING;
                    break;
                }

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            //
            //  If this Scb should go on the delayed close queue then
            //  status is STATUS_PENDING;
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_DELAY_CLOSE ) &&
                (Scb->Fcb->DelayedCloseCount == 0)) {

                Status = STATUS_PENDING;

            } else {

                Status = NtfsCommonClose( IrpContext,
                                          Scb,
                                          Fcb,
                                          Vcb,
                                          &Ccb,
                                          TypeOfOpen,
                                          IsReadOnly,
                                          FALSE );
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  exception code.
            //

            if (IrpContext == NULL) {

                //
                //  We could've hit insufficient resources in trying to allocate
                //  the IrpContext. Make sure we don't leave a reference
                //  hanging around in this case. ProcessException will complete
                //  the IRP for us.
                //

                PLCB Lcb;

                ASSERT( GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES );

                if (Ccb != NULL) {

                    Lcb = Ccb->Lcb;
                    NtfsUnlinkCcbFromLcb( NULL, Fcb, Ccb );
                    NtfsDeleteCcb( Fcb, &Ccb );

                } else {

                    Lcb = NULL;
                }

                //
                //  This only decrements the close counts so it will not raise
                // 

                NtfsDecrementCloseCounts( NULL,
                                          Scb,
                                          Lcb,
                                          IsSystemFile,
                                          IsReadOnly,
                                          TRUE,
                                          NULL );

            }

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

        ASSERT( NT_SUCCESS( Status ) || (IrpContext == NULL) || IsListEmpty(&IrpContext->ExclusiveFcbList) );

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    //
    //  Io believes that it needs to free the FileObject->FileName.Buffer ONLY
    //  if FileObject->FileName.Length != 0.  Ntfs hides the attribute name
    //  between FileObject->FileName.Length and FileObject->Filename.MaximumLength
    //  and for a attribute-name-open relative to a file opened by Id, the Length
    //  field will be zero.  This, alas, causes Io to leak names.  So...
    //
    //  If we have a buffer allocated, make sure that the length is not zero when
    //  Io gets to see it.
    //

    if (FileObject->FileName.Buffer != NULL) {

        FileObject->FileName.Length = 1;
    }

    //
    //  Trigger an assert on any unexpected cases.
    //

    ASSERT( (Status == STATUS_SUCCESS) || (Status == STATUS_PENDING) ||
             (Status == STATUS_INSUFFICIENT_RESOURCES) );

    //
    //  Post the request to the close queue on PENDING.
    //

    if (Status == STATUS_PENDING) {

        BOOLEAN DelayCloseQueue = FALSE;

        //
        //  If the status is can't wait, then let's get the information we
        //  need into the IrpContext, complete the request,
        //  and post the IrpContext.
        //

        //
        //  Restore the thread context pointer if associated with this IrpContext.
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

            NtfsRestoreTopLevelIrp();
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
        }

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        Status = STATUS_SUCCESS;

        IrpContext->OriginatingIrp = (PIRP) Scb;
        IrpContext->Union.SubjectContext = (PSECURITY_SUBJECT_CONTEXT) Ccb;
        IrpContext->TransactionId = (TRANSACTION_ID) TypeOfOpen;

        //
        //  At this point the file is effectively readonly - by changing it
        //  here we remove a race with implict locking through volume opens and
        //  the async close queue. Note: we have NO synchroniation here other
        //  than the interlocked operation. The vcb will not go away until
        //  this close is done
        //

        if (Ccb != NULL)  {

            if (!IsFileObjectReadOnly( FileObject )) {
                FileObject->WriteAccess = 0;
                FileObject->DeleteAccess = 0;
                InterlockedIncrement( &Vcb->ReadOnlyCloseCount );
            }
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO );

        } else {

            //
            //  System files should never be read-only. There will be
            //  a ccb for all user fileobjects. Internal fileobjects are
            //  also always marked as system
            //

            ASSERT( !IsFileObjectReadOnly( FileObject ));
        }

        //
        //  Decide which close queue this will go on.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_DELAY_CLOSE )) {

            NtfsAcquireFsrtlHeader( Scb );
            ClearFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );
            NtfsReleaseFsrtlHeader( Scb );

            if (Scb->Fcb->DelayedCloseCount == 0) {

                DelayCloseQueue = TRUE;
            }
        }

        NtfsQueueClose( IrpContext, DelayCloseQueue );

    //
    //  Succeed in all other cases.
    //

    } else {

        if (Status == STATUS_SUCCESS) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        }

        //
        //  INSUFFICIENT_RESOURCES is the only other status that
        //  we can hit at this point. We would've completed the IRP in
        //  the except clause above in this case, so don't try doing it again.
        //

        ASSERT( Status == STATUS_SUCCESS || Status == STATUS_INSUFFICIENT_RESOURCES );
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdClose -> %08lx\n", Status) );

    return Status;
}


VOID
NtfsFspClose (
    IN PVCB ThisVcb OPTIONAL
    )

/*++

Routine Description:

    This routine implements the FSP part of Close.

Arguments:

    ThisVcb - If specified then we want to remove all closes for a given Vcb.
        Otherwise this routine will close all of the async closes and as many
        of the delayed closes as possible.

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext;
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    TYPE_OF_OPEN TypeOfOpen;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN ReadOnly;

    NTSTATUS Status = STATUS_SUCCESS;

    PVCB CurrentVcb = NULL;

    BOOLEAN ThrottleCreate = FALSE;
    ULONG ClosedCount = 0;

    DebugTrace( +1, Dbg, ("NtfsFspClose\n") );

    PAGED_CODE();

    FsRtlEnterFileSystem();

    //
    //  Occasionally we are called from some other routine to try to
    //  reduce the backlog of closes.  This is indicated by a pointer
    //  value of 1.
    //

    if (ThisVcb == (PVCB) 1) {

        ThisVcb = NULL;
        ThrottleCreate = TRUE;
    }

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    //
    //  Extract and decode the file object, we are willing to handle the unmounted
    //  file object.  Note we normally get here via an IrpContext which really
    //  just points to a file object.  We should never see an Irp, unless it can
    //  happen for verify or some other reason.
    //

    while (IrpContext = NtfsRemoveClose( ThisVcb, ThrottleCreate )) {

        ASSERT_IRP_CONTEXT( IrpContext );

        //
        //  Recover the information about the file object being closed from
        //  the data stored in the IrpContext.  The following fields are
        //  used for this.
        //
        //  OriginatingIrp - Contains the Scb
        //  SubjectContext - Contains the Ccb
        //  TransactionId - Contains the TypeOfOpen
        //  Flags - Has bit for read-only file.
        //

        Scb = (PSCB) IrpContext->OriginatingIrp;
        IrpContext->OriginatingIrp = NULL;

        Ccb = (PCCB) IrpContext->Union.SubjectContext;
        IrpContext->Union.SubjectContext = NULL;

        TypeOfOpen = (TYPE_OF_OPEN) IrpContext->TransactionId;
        IrpContext->TransactionId = 0;

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO )) {

            ReadOnly = TRUE;
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO );

        } else {

            ReadOnly = FALSE;
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );
        SetFlag( IrpContext->State,
                 IRP_CONTEXT_STATE_IN_FSP | IRP_CONTEXT_STATE_WAIT );

        //
        //  Loop for retryable errors.
        //

        Status = STATUS_SUCCESS;

        do {

            //
            //  Set the TopLevel structure.
            //

            NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            //
            //  Call the common Close routine.
            //

            try {

                //
                //  Do logfile full checkpointing
                //

                if (Status == STATUS_LOG_FILE_FULL) {
                    NtfsCheckpointForLogFileFull( IrpContext );
                }

                CurrentVcb = IrpContext->Vcb;

                Status = NtfsCommonClose( IrpContext,
                                          Scb,
                                          Scb->Fcb,
                                          IrpContext->Vcb,
                                          &Ccb,
                                          TypeOfOpen,
                                          ReadOnly,
                                          TRUE );

                ASSERT(Status == STATUS_SUCCESS);

#ifdef LFS_CLUSTER_CHECK
            } except( NtfsFspCloseExceptionFilter( IrpContext, GetExceptionInformation() )) {
#else
            } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {
#endif

                Status = NtfsProcessException( IrpContext, NULL, GetExceptionCode() );
            }

            ASSERT( NT_SUCCESS(Status) || IsListEmpty(&IrpContext->ExclusiveFcbList) );

            //
            //  If we got a log file full, and our caller may have something
            //  acquired, then clean up and raise again.
            //

            if (((Status == STATUS_LOG_FILE_FULL) ||
                 (Status == STATUS_CANT_WAIT)) &&
                 ARGUMENT_PRESENT( ThisVcb )) {

                //
                //  If the status is can't wait, then let's get the information we
                //  need into the IrpContext, complete the request,
                //  and post the IrpContext.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
                NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

                //
                //  Restore the information on the file object being closed.
                //

                IrpContext->OriginatingIrp = (PIRP)Scb;
                IrpContext->Union.SubjectContext = (PVOID)Ccb;
                IrpContext->TransactionId = TypeOfOpen;
                if (ReadOnly) {
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO );
                }

                //
                //  Now queue the close as an async close and get out.
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

                    NtfsRestoreTopLevelIrp();
                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
                }

                NtfsQueueClose( IrpContext, FALSE );

                FsRtlExitFileSystem();
                ExRaiseStatus( Status );
            }

        } while ((Status == STATUS_LOG_FILE_FULL) || (Status == STATUS_CANT_WAIT));

        //
        //  No more for us to do.  Clean up the IrpContext in any case.
        //

        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

        //
        //  If we were just throttling creates and we made our last pass
        //  then exit.
        //

        if (ThrottleCreate) {
            break;
        }
    }


    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFspClose -> NULL\n") );

    return;
}


BOOLEAN
NtfsAddScbToFspClose (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN DelayClose
    )

/*++

Routine Description:

    This routine is called to add an entry for the current Scb onto one
    of the Fsp close queues.  This is used when we want to guarantee that
    a teardown will be called on an Scb or Fcb when the current operation
    can't begin the operation.

Arguments:

    Scb - Scb to add to the queue.

    DelayClose - Indicates which queue this should go into.

Return Value:

    BOOLEAN - Indicates whether or not the SCB was added to the delayed
        close queue

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;
    BOOLEAN Result = TRUE;

    PAGED_CODE();

    //
    //  Use a try-except to catch any allocation failures.  The only valid
    //  error here is an allocation failure for the new irp context.
    //

    try {

        NtfsInitializeIrpContext( NULL, TRUE, &NewIrpContext );

        //
        //  Set the necessary fields to post this to the workqueue.
        //

        NewIrpContext->Vcb = Scb->Vcb;
        NewIrpContext->MajorFunction = IRP_MJ_CLOSE;

        NewIrpContext->OriginatingIrp = (PIRP) Scb;
        NewIrpContext->TransactionId = (TRANSACTION_ID) StreamFileOpen;

        //
        //  Now increment the close counts for this Scb.
        //

        NtfsIncrementCloseCounts( Scb, TRUE, FALSE );

        //
        //  Move the Scb to the end of the Fcb queue.  We don't want to
        //  keep other Scb's from being deleted because this one is on
        //  the delayed close queue.
        //

        if (Scb->FcbLinks.Flink != &Scb->Fcb->ScbQueue) {

            NtfsLockFcb( IrpContext, Scb->Fcb );
            RemoveEntryList( &Scb->FcbLinks );
            InsertTailList( &Scb->Fcb->ScbQueue, &Scb->FcbLinks );
            ASSERT( Scb->FcbLinks.Flink == &Scb->Fcb->ScbQueue );
            NtfsUnlockFcb( IrpContext, Scb->Fcb );
        }

        //
        //  Now add this to the correct queue.
        //

        NtfsQueueClose( NewIrpContext, DelayClose );

    } except( FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH ) {

        NtfsMinimumExceptionProcessing( IrpContext );
        Result = FALSE;
    }

    return Result;

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Internal support routine
//

NTSTATUS
NtfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PCCB *Ccb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN CalledFromFsp
    )

/*++

Routine Description:

    This is the common routine for Close called by both the fsd and fsp
    threads.  Key for this routine is how to acquire the Vcb and whether to
    leave the Vcb acquired on exit.

Arguments:

    Scb - Scb for this stream.

    Fcb - Fcb for this stream.

    Vcb - Vcb for this volume.

    Ccb - User's Ccb for user files.

    TypeOfOpen - Indicates the type of open for this stream.

    ReadOnly - Indicates if the file object was for read-only access.

    CalledFromFsp - Indicates whether this function was called from NtfsFspClose.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    BOOLEAN ExclusiveVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;

    BOOLEAN SystemFile;
    BOOLEAN RemovedFcb = FALSE;
    ULONG AcquireFlags = ACQUIRE_NO_DELETE_CHECK | ACQUIRE_HOLD_BITMAP;
    BOOLEAN NeedVcbExclusive = FALSE;
    BOOLEAN WriteFileSize;

    NTSTATUS Status = STATUS_SUCCESS;

    PLCB Lcb;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    //
    //  Get the current Irp stack location
    //

    DebugTrace( +1, Dbg, ("NtfsCommonClose\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
    }

    //
    //  Loop here to acquire both the Vcb and Fcb.  We want to acquire
    //  the Vcb exclusively if the file has multiple links.
    //

    while (TRUE) {

        WriteFileSize = FALSE;

        //
        //  Perform an unsafe test and optimistically acquire Vcb.
        //

        if (NeedVcbExclusive ||
            (Fcb->LcbQueue.Flink != Fcb->LcbQueue.Blink) ||
            FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

            if (!NtfsAcquireExclusiveVcb( IrpContext, Vcb, FALSE )) {
                return STATUS_PENDING;
            }
            ExclusiveVcb = TRUE;

        } else {

            if (!NtfsAcquireSharedVcb( IrpContext, Vcb, FALSE )) {
                return STATUS_PENDING;
            }
        }

        //
        //  Now try to acquire the Fcb.  If we are unable to acquire it then
        //  release the Vcb and return.  This can only be from the Fsd path
        //  since otherwise Wait will be TRUE.
        //

        if (!NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, AcquireFlags )) {

            //
            //  Always release the Vcb.  This can only be from the Fsd thread.
            //

            NtfsReleaseVcb( IrpContext, Vcb );
            return STATUS_PENDING;
        }
        AcquiredFcb = TRUE;

        //
        //  Recheck scbstate now that we own the fcb exclusive to see if we need
        //  to write the filesize at this point
        //

        if ((!FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) &&
            (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) &&
            (FlagOn( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE )) &&
            (Fcb->LinkCount > 0) &&
            (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ))) {

            WriteFileSize = TRUE;
            NtfsReleaseFcb( IrpContext, Fcb );
            AcquiredFcb = FALSE;

            //
            //  NtfsAcquireWithPaging only  gets the paging if the irpcontext
            //  flag is set. Also it assumes no delete check which we explictly
            //  want here anyway.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            if (!NtfsAcquireFcbWithPaging( IrpContext, Fcb, AcquireFlags )) {

                NtfsReleaseVcb( IrpContext, Vcb );
                return STATUS_PENDING;
            }
            AcquiredFcb = TRUE;

            //
            //  Recapture whether we need to write file size since dropping
            //

            if ((!FlagOn( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE )) ||
                (Fcb->LinkCount == 0) ||
                (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ))) {

                WriteFileSize = FALSE;
            }
        }

        if (ExclusiveVcb) {
            break;
        }

        //
        //  Otherwise we need to confirm that our unsafe test above was correct.
        //

        if ((Fcb->LcbQueue.Flink != Fcb->LcbQueue.Blink) ||
            FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

            NeedVcbExclusive = TRUE;
            NtfsReleaseFcbWithPaging( IrpContext, Fcb );
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredFcb = FALSE;

        } else {

            break;
        }
    }

    //
    //  Set the wait flag in the IrpContext so we can acquire any other files
    //  we encounter.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    try {

        //
        //  See if we possibly have to do any Usn processing
        //

        if (Fcb->FcbUsnRecord != NULL) {

            //
            //  If the file has no more user handles, but there is a pending Usn
            //  update (this should normally only happen if a stream was mapped
            //  by the user), then scan the streams to see if there are any
            //  remaining datasections, and if not then post the close.
            //

            if ((Fcb->CleanupCount == 0) &&
                (Fcb->FcbUsnRecord->UsnRecord.Reason != 0)) {

                if (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED ) &&
                    !FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) &&
                    !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_FAILED_CLOSE )) {

                    PSCB TempScb;

                    //
                    //  Leave if there are any streams with user-mapped files.
                    //

                    TempScb = (PSCB)CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                                       SCB,
                                                       FcbLinks );

                    while (&TempScb->FcbLinks != &Fcb->ScbQueue) {

                        if ((TempScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                            !MmCanFileBeTruncated( &TempScb->NonpagedScb->SegmentObject, &Li0)) {
                            goto NoPost;
                        }

                        TempScb = (PSCB)CONTAINING_RECORD( TempScb->FcbLinks.Flink,
                                                           SCB,
                                                           FcbLinks );
                    }

                    //
                    //  If we are not supposed to wait, then we should force this request to
                    //  be posted. All recursive closes will go here since they are async
                    //

                    if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {
                        Status = STATUS_PENDING;
                        leave;
                    }

                    //
                    //  We cannot generate logfile fulls in a regular thread with a recursive close
                    //  safely without deadlocking
                    //

                    ASSERT( NtfsIsTopLevelRequest( IrpContext ) ||
                            FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) );

                    //
                    //  Protect the call to the Usn routines with a try-except.  If we hit
                    //  any non-fatal error then set the IrpContext flag which indicates
                    //  not to bother with the Usn and force a retry.
                    //

                    try {

                        //
                        //  Now try to actually post the change.
                        //

                        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                        //
                        //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                        //  reduce contention.  We force the write now, because the Fcb may get deleted
                        //  before we normally would write the changes when the transaction commits.
                        //

                        NtfsWriteUsnJournalChanges( IrpContext );
                        NtfsCheckpointCurrentTransaction( IrpContext );

                    } except( (!FsRtlIsNtstatusExpected( Status = GetExceptionCode() ) ||
                               (Status == STATUS_LOG_FILE_FULL) ||
                               (Status == STATUS_CANT_WAIT)) ?
                              EXCEPTION_CONTINUE_SEARCH :
                              EXCEPTION_EXECUTE_HANDLER ) {

                        //
                        //  We got some sort of error processing the Usn journal.  We can't
                        //  handle it in the close path.  Let's retry this request but don't
                        //  try to do the Usn operation.
                        //

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_FAILED_CLOSE );
                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }

                    //
                    //  Free any remaining resources before decrementing close counts below,
                    //  except for our Fcb.  This reduces contention via the Usn Journal and
                    //  prevents deadlocks since the Usn Journal is acquired last.
                    //

                    ASSERT(Fcb->ExclusiveFcbLinks.Flink != NULL);
                    while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                        if (&Fcb->ExclusiveFcbLinks == IrpContext->ExclusiveFcbList.Flink) {

                            RemoveEntryList( &Fcb->ExclusiveFcbLinks );
                            Fcb->ExclusiveFcbLinks.Flink = NULL;

                        } else {

                            NtfsReleaseFcb( IrpContext,
                                            (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                                    FCB,
                                                                    ExclusiveFcbLinks ));
                        }
                    }
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                                  IRP_CONTEXT_FLAG_RELEASE_MFT );

                    //
                    //  Now reinsert our Fcb if we removed it from the list.  Check the Flink
                    //  field to know if this is the case.  Otherwise a higher level IrpContext
                    //  will own this.
                    //

                    if (Fcb->ExclusiveFcbLinks.Flink == NULL) {

                        InsertTailList( &IrpContext->ExclusiveFcbList, &Fcb->ExclusiveFcbLinks );
                    }

                    //
                    //  Escape here if we are not posting the close due to a user-mapped file.
                    //

                NoPost: NOTHING;
                }
            }
        }

        //
        //  Now rewrite the filesizes if we have to
        //

        if (WriteFileSize) {

            ASSERT( IrpContext->CleanupStructure != NULL );

            //
            //  If the call to write the file size or the commit  produces a logfile full
            //  we must retry in the fsp thread  to prevent deadlocking from
            //  a recursive caller's already owning the vcb and an attempt to
            //  checkpoint
            //

            try {

                NtfsWriteFileSizes( IrpContext, Scb, &Scb->Header.ValidDataLength.QuadPart, TRUE, TRUE, FALSE );
                NtfsCheckpointCurrentTransaction( IrpContext );
                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE );

            } except( (Status = GetExceptionCode()), (Status != STATUS_LOG_FILE_FULL || FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) ?
                      EXCEPTION_CONTINUE_SEARCH :
                      EXCEPTION_EXECUTE_HANDLER ) {

                NtfsMinimumExceptionProcessing( IrpContext );
                Status = STATUS_PENDING;
            }

            if (Status == STATUS_PENDING) {
                leave;
            }

        }  //  endif writing filesize

        //
        //  We take the same action for all open files.  We
        //  delete the Ccb if present, and we decrement the close
        //  file counts.
        //

        if ((*Ccb) != NULL) {

            Lcb = (*Ccb)->Lcb;
            NtfsUnlinkCcbFromLcb( IrpContext, Fcb, (*Ccb) );
            NtfsDeleteCcb( Fcb, Ccb );

        } else {

            Lcb = NULL;
        }

        SystemFile = FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) || (TypeOfOpen == StreamFileOpen);
        NtfsDecrementCloseCounts( IrpContext,
                                  Scb,
                                  Lcb,
                                  SystemFile,
                                  ReadOnly,
                                  FALSE,
                                  &RemovedFcb );

        //
        //  Now that we're holding the Vcb, and we're past the point where we might
        //  raise log file full, we can safely adjust this field.
        //

        if (CalledFromFsp) {

            InterlockedDecrement( &Vcb->QueuedCloseCount );
        }

        //
        //  If we had to write a log record for close, it can only be for duplicate
        //  information.  We will commit that transaction here and remove
        //  the entry from the transaction table.  We do it here so we won't
        //  fail inside the 'except' of a 'try-except'.
        //

        if (IrpContext->TransactionId != 0) {

            try {

                NtfsCommitCurrentTransaction( IrpContext );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                NtfsMinimumExceptionProcessing( IrpContext );
                if (IrpContext->TransactionId != 0) {

                    NtfsCleanupFailedTransaction( IrpContext );
                }
            }
        }

    } finally {

        DebugUnwind( NtfsCommonClose );

        //
        //  Manage fcb explictly because we recursively come into this path
        //  and its cleaner to release the fcb at the same level in which you acquire it
        //

        if (AcquiredFcb && !RemovedFcb) {
            NtfsReleaseFcbWithPaging( IrpContext, Fcb );
        }

        if (ExclusiveVcb) {
            NtfsReleaseVcbCheckDelete( IrpContext, Vcb, IRP_MJ_CLOSE, NULL );
        } else {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonClose -> returning\n") );
    }

    return Status;
}


//
//  Internal support routine, spinlock wrapper.
//

VOID
NtfsQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN DelayClose
    )
{
    KIRQL SavedIrql;
    BOOLEAN StartWorker = FALSE;

    InterlockedIncrement( &(IrpContext->Vcb->QueuedCloseCount) );

    if (DelayClose) {

        //
        //  Increment the delayed close count for the Fcb for this
        //  file.
        //

        InterlockedIncrement( &((PSCB) IrpContext->OriginatingIrp)->Fcb->DelayedCloseCount );

        ASSERT( IsListEmpty( &IrpContext->ExclusiveFcbList ) );
        ASSERT( IsListEmpty( &IrpContext->RecentlyDeallocatedQueue ) );

        RtlZeroMemory( &IrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ));

        SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
        
        InsertTailList( &NtfsData.DelayedCloseList,
                        &IrpContext->WorkQueueItem.List );

        NtfsData.DelayedCloseCount += 1;

        if (NtfsData.DelayedCloseCount > NtfsMaxDelayedCloseCount) {

            NtfsData.ReduceDelayedClose = TRUE;

            if (!NtfsData.AsyncCloseActive) {

                NtfsData.AsyncCloseActive = TRUE;
                StartWorker = TRUE;
            }
        }

    } else {

        SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

        ASSERT( IsListEmpty( &IrpContext->ExclusiveFcbList ) );
        ASSERT( IsListEmpty( &IrpContext->RecentlyDeallocatedQueue ) );
        RtlZeroMemory( &IrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ));

        InsertTailList( &NtfsData.AsyncCloseList,
                        &IrpContext->WorkQueueItem.List );

        NtfsData.AsyncCloseCount += 1;

        if (!NtfsData.AsyncCloseActive) {

            NtfsData.AsyncCloseActive = TRUE;

            StartWorker = TRUE;
        }
    }

    KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, SavedIrql );

    if (StartWorker) {

        ExQueueWorkItem( &NtfsData.NtfsCloseItem, CriticalWorkQueue );
    }
}


//
//  Internal support routine, spinlock wrapper.
//

PIRP_CONTEXT
NtfsRemoveClose (
    IN PVCB Vcb OPTIONAL,
    IN BOOLEAN ThrottleCreate
    )
{

    PLIST_ENTRY Entry;
    KIRQL SavedIrql;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN FromDelayedClose = FALSE;

    SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

    //
    //  First check the list of async closes.
    //

    if (!IsListEmpty( &NtfsData.AsyncCloseList )) {

        Entry = NtfsData.AsyncCloseList.Flink;

        while (Entry != &NtfsData.AsyncCloseList) {

            //
            //  Extract the IrpContext.
            //

            IrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

            //
            //  If no Vcb was specified or this Vcb is for our volume
            //  then perform the close.
            //

            if (!ARGUMENT_PRESENT( Vcb ) ||
                IrpContext->Vcb == Vcb) {

                RemoveEntryList( Entry );
                NtfsData.AsyncCloseCount -= 1;

                break;

            } else {

                IrpContext = NULL;
                Entry = Entry->Flink;
            }
        }
    }

    //
    //  If we didn't find anything look through the delayed close
    //  queue.
    //

    if (IrpContext == NULL) {

        //
        //  Now check our delayed close list.
        //

        if (ARGUMENT_PRESENT( Vcb )) {

            Entry = NtfsData.DelayedCloseList.Flink;
            IrpContext = NULL;

            //
            //  If we were given a Vcb, only do the closes for this volume.
            //

            while (Entry != &NtfsData.DelayedCloseList) {

                //
                //  Extract the IrpContext.
                //

                IrpContext = CONTAINING_RECORD( Entry,
                                                IRP_CONTEXT,
                                                WorkQueueItem.List );

                //
                //  Is this close on our volume?
                //

                if (IrpContext->Vcb == Vcb) {

                    RemoveEntryList( Entry );
                    NtfsData.DelayedCloseCount -= 1;
                    FromDelayedClose = TRUE;
                    break;

                } else {

                    IrpContext = NULL;
                    Entry = Entry->Flink;
                }
            }

        //
        //  Check if need to reduce the delayed close count.
        //

        } else if (NtfsData.ReduceDelayedClose) {

            if (NtfsData.DelayedCloseCount > NtfsMinDelayedCloseCount) {

                //
                //  Do any closes over the limit.
                //

                Entry = RemoveHeadList( &NtfsData.DelayedCloseList );

                NtfsData.DelayedCloseCount -= 1;

                //
                //  Extract the IrpContext.
                //

                IrpContext = CONTAINING_RECORD( Entry,
                                                IRP_CONTEXT,
                                                WorkQueueItem.List );
                FromDelayedClose = TRUE;

            } else {

                NtfsData.ReduceDelayedClose = FALSE;
            }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        } else {

            ASSERT( NtfsData.DelayedCloseCount <= NtfsMaxDelayedCloseCount );
#endif
        }
    }

    //
    //  If this is the delayed close case then decrement the delayed close count
    //  on this Fcb.
    //

    if (FromDelayedClose) {

        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, SavedIrql );

        InterlockedDecrement( &((PSCB) IrpContext->OriginatingIrp)->Fcb->DelayedCloseCount );

    //
    //  If we are returning NULL, show that we are done.
    //

    } else {

        if (!ARGUMENT_PRESENT( Vcb ) &&
            (IrpContext == NULL) &&
            !ThrottleCreate) {

            NtfsData.AsyncCloseActive = FALSE;
        }

        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, SavedIrql );
    }
    if (IrpContext != NULL) {

        //
        //  Reset the shared fields
        //  

        InitializeListHead( &IrpContext->RecentlyDeallocatedQueue );
        InitializeListHead( &IrpContext->ExclusiveFcbList );
        
    }

    ASSERT( (Vcb == NULL) || NtfsIsExclusiveVcb( Vcb ) || (IrpContext == NULL) );
    return IrpContext;
}

#ifdef LFS_CLUSTER_CHECK
LONG
NtfsFspCloseExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    ASSERT( (ExceptionCode == STATUS_SUCCESS) ||
            (ExceptionCode == STATUS_LOG_FILE_FULL) ||
            (ExceptionCode == STATUS_CANT_WAIT) );

    return NtfsExceptionFilter( IrpContext, ExceptionPointer );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\colatsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ColatSup.c

Abstract:

    This module implements the collation routine callbacks for Ntfs

Author:

    Tom Miller      [TomM]          26-Nov-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_INDEXSUP)

FSRTL_COMPARISON_RESULT
NtfsFileCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileContainsWildcards (
    IN PVOID Value
    );

VOID
NtfsFileUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value
    );

FSRTL_COMPARISON_RESULT
DummyCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
DummyIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
DummyIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
DummyContainsWildcards (
    IN PVOID Value
    );

VOID
DummyUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN OUT PVOID Value
    );

PCOMPARE_VALUES NtfsCompareValues[COLLATION_NUMBER_RULES] = {&DummyCompareValues,
                                                             &NtfsFileCompareValues,
                                                             &DummyCompareValues};

PIS_IN_EXPRESSION NtfsIsInExpression[COLLATION_NUMBER_RULES] = {&DummyIsInExpression,
                                                                &NtfsFileIsInExpression,
                                                                &DummyIsInExpression};

PARE_EQUAL NtfsIsEqual[COLLATION_NUMBER_RULES] = {&DummyIsEqual,
                                                  &NtfsFileIsEqual,
                                                  &DummyIsEqual};

PCONTAINS_WILDCARD NtfsContainsWildcards[COLLATION_NUMBER_RULES] = {&DummyContainsWildcards,
                                                                    &NtfsFileContainsWildcards,
                                                                    &DummyContainsWildcards};

PUPCASE_VALUE NtfsUpcaseValue[COLLATION_NUMBER_RULES] = {&DummyUpcaseValue,
                                                         &NtfsFileUpcaseValue,
                                                         &DummyUpcaseValue};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DummyCompareValues)
#pragma alloc_text(PAGE, DummyContainsWildcards)
#pragma alloc_text(PAGE, DummyIsEqual)
#pragma alloc_text(PAGE, DummyIsInExpression)
#pragma alloc_text(PAGE, DummyUpcaseValue)
#pragma alloc_text(PAGE, NtfsFileCompareValues)
#pragma alloc_text(PAGE, NtfsFileContainsWildcards)
#pragma alloc_text(PAGE, NtfsFileIsEqual)
#pragma alloc_text(PAGE, NtfsFileIsInExpression)
#pragma alloc_text(PAGE, NtfsFileNameIsInExpression)
#pragma alloc_text(PAGE, NtfsFileNameIsEqual)
#pragma alloc_text(PAGE, NtfsFileUpcaseValue)
#endif


FSRTL_COMPARISON_RESULT
NtfsFileCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This routine is called to compare a file name expression (the value) with
    a file name from the index to see if it is less than, equal to or greater
    than.  If a wild card is encountered in the expression, WildCardIs is
    returned.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    IndexEntry - Pointer to the index entry being compared to.

    WildCardIs - Value to be returned if a wild card is encountered in the
                 expression.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    Result of the comparison

--*/

{
    PFILE_NAME ValueName, IndexName;
    UNICODE_STRING ValueString, IndexString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;
    IndexName = (PFILE_NAME)(IndexEntry + 1);

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexName->FileNameLength << 1;
    IndexString.Buffer = &IndexName->FileName[0];

    return NtfsCollateNames( UnicodeTable,
                             UnicodeTableSize,
                             &ValueString,
                             &IndexString,
                             WildCardIs,
                             IgnoreCase );
}


BOOLEAN
NtfsFileIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This routine is called to compare a file name expression (the value) with
    a file name from the index to see if the file name is a match in this expression.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    IndexEntry - Pointer to the index entry being compared to.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is in the specified expression.

--*/

{
    PFILE_NAME ValueName, IndexName;
    UNICODE_STRING ValueString, IndexString;

    PAGED_CODE();

    if (NtfsSegmentNumber( &IndexEntry->FileReference ) < FIRST_USER_FILE_NUMBER &&
        NtfsProtectSystemFiles) {

        return FALSE;
    }

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;
    IndexName = (PFILE_NAME)(IndexEntry + 1);

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexName->FileNameLength << 1;
    IndexString.Buffer = &IndexName->FileName[0];

    return NtfsIsNameInExpression( UnicodeTable,
                                   &ValueString,
                                   &IndexString,
                                   IgnoreCase );
}


BOOLEAN
NtfsFileIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This routine is called to compare a constant file name (the value) with
    a file name from the index to see if the file name is an exact match.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    IndexEntry - Pointer to the index entry being compared to.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is a constant match.

--*/

{
    PFILE_NAME ValueName, IndexName;
    UNICODE_STRING ValueString, IndexString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;
    IndexName = (PFILE_NAME)(IndexEntry + 1);

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexName->FileNameLength << 1;
    IndexString.Buffer = &IndexName->FileName[0];

    return NtfsAreNamesEqual( UnicodeTable,
                              &ValueString,
                              &IndexString,
                              IgnoreCase );
}


BOOLEAN
NtfsFileContainsWildcards (
    IN PVOID Value
    )

/*++

RoutineDescription:

    This routine is called to see if a file name attribute contains wildcards.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.


ReturnValue:

    TRUE - if the file name contains a wild card.

--*/

{
    PFILE_NAME ValueName;
    UNICODE_STRING ValueString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    return FsRtlDoesNameContainWildCards( &ValueString );
}


VOID
NtfsFileUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value
    )

/*++

RoutineDescription:

    This routine is called to upcase a file name attribute in place.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    ValueLength - Length of the value expression in bytes.

ReturnValue:

    None.

--*/

{
    PFILE_NAME ValueName;
    UNICODE_STRING ValueString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    NtfsUpcaseName( UnicodeTable, UnicodeTableSize, &ValueString );

    return;
}


//
//  The other collation rules are currently unused.
//

FSRTL_COMPARISON_RESULT
DummyCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( UnicodeTableSize );
    UNREFERENCED_PARAMETER( IgnoreCase );
    UNREFERENCED_PARAMETER( WildCardIs );
    UNREFERENCED_PARAMETER( IndexEntry );
    UNREFERENCED_PARAMETER( Value );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);

    return EqualTo;
}

BOOLEAN
DummyIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( IndexEntry );
    UNREFERENCED_PARAMETER( IgnoreCase );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return EqualTo;
}

BOOLEAN
DummyIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( IndexEntry );
    UNREFERENCED_PARAMETER( IgnoreCase );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return EqualTo;
}

BOOLEAN
DummyContainsWildcards (
    IN PVOID Value
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( Value );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return EqualTo;
}

VOID
DummyUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( UnicodeTableSize );
    UNREFERENCED_PARAMETER( Value );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return;
}

//
//  The following routines are not general index match functions, but rather
//  specific file name match functions used only for automatic Dos Name generation.
//


BOOLEAN
NtfsFileNameIsInExpression (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This is a special match routine for matching FILE_NAME attributes only,
    which is used only by the special code paths dealing with automatically
    generated short names.

    This routine is called to compare a file name expression (the value) with
    a file name from the index to see if the file name is a match in this expression.

Arguments:

    ExpressionName - pointer to the expression for file name.

    FileName - Pointer to the FileName to match.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is in the specified expression.

--*/

{
    UNICODE_STRING ExpressionString, FileString;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    ExpressionString.Length =
    ExpressionString.MaximumLength = (USHORT)ExpressionName->FileNameLength << 1;
    ExpressionString.Buffer = &ExpressionName->FileName[0];

    FileString.Length =
    FileString.MaximumLength = (USHORT)FileName->FileNameLength << 1;
    FileString.Buffer = &FileName->FileName[0];

    return NtfsIsNameInExpression( UnicodeTable,
                                   &ExpressionString,
                                   &FileString,
                                   IgnoreCase );
}


BOOLEAN
NtfsFileNameIsEqual (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This is a special match routine for matching FILE_NAME attributes only,
    which is used only by the special code paths dealing with automatically
    generated short names.

    This routine is called to compare a constant file name (the value) with
    a file name from the index to see if the file name is an exact match.

Arguments:

    ExpressionName - pointer to the expression for file name.

    FileName - Pointer to the FileName to match.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is a constant match.

--*/

{
    UNICODE_STRING ExpressionString, FileString;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    ExpressionString.Length =
    ExpressionString.MaximumLength = (USHORT)ExpressionName->FileNameLength << 1;
    ExpressionString.Buffer = &ExpressionName->FileName[0];

    FileString.Length =
    FileString.MaximumLength = (USHORT)FileName->FileNameLength << 1;
    FileString.Buffer = &FileName->FileName[0];

    return NtfsAreNamesEqual( UnicodeTable,
                              &ExpressionString,
                              &FileString,
                              IgnoreCase );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\devctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the Device Control routines for Ntfs called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]        28-May-1991

Revision History:

--*/

#include "NtfsProc.h"
#include <ntddsnap.h>

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVCTRL)

//
//  Local procedure prototypes
//

NTSTATUS
DeviceControlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonDeviceControl)
#endif


NTSTATUS
NtfsCommonDeviceControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Device Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    TYPE_OF_OPEN TypeOfOpen;
    PIO_STACK_LOCATION IrpSp;
    NTFS_COMPLETION_CONTEXT Context;
    PNTFS_COMPLETION_CONTEXT CompletionContext = NULL;
    LOGICAL ReleaseResources = FALSE;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCommonDeviceControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    
    //
    //  Extract and decode the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, 
                                       IrpSp->FileObject,
                                       &Vcb, 
                                       &Fcb, 
                                       &Scb, 
                                       &Ccb, 
                                       TRUE );

    //
    //  The only type of opens we accept are user volume opens.
    //

    if (TypeOfOpen != UserVolumeOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsCommonDeviceControl -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }
    
    try {

        //
        //  A few IOCTLs actually require some intervention on our part
        //

        switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES:

            //
            //  This is sent by the Volume Snapshot driver (Lovelace).
            //  We flush the volume, and hold all file resources
            //  to make sure that nothing more gets dirty. Then we wait
            //  for the IRP to complete or cancel.
            //
                     
            Status =  NtfsCheckpointForVolumeSnapshot( IrpContext );
            
            if (NT_SUCCESS( Status )) {

                ReleaseResources = TRUE;
            }
            
            KeInitializeEvent( &Context.Event, NotificationEvent, FALSE );
            Context.IrpContext = IrpContext;
            CompletionContext = &Context;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            
            break;

        case IOCTL_VOLSNAP_RELEASE_WRITES:

            //
            //  No-op for filesystems.
            //
            
            break;
            
        default:

            break;
        }

        //
        //  If error, complete the irp, free the IrpContext
        //  and return to the caller.
        //

        if (!NT_SUCCESS( Status )) {

            NtfsCompleteRequest( NULL, Irp, Status );
            leave;
        }
    
        //
        //  Get the next stack location, and copy over the stack parameter
        //  information
        //
        
        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        //  Set up the completion routine
        //

        IoSetCompletionRoutine( Irp,
                                DeviceControlCompletionRoutine,
                                CompletionContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Send the request. And wait.
        //

        Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );

        if ((Status == STATUS_PENDING) && 
            (CompletionContext != NULL)) {

            KeWaitForSingleObject( &CompletionContext->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }
        
    } finally {
        
        //
        //  Release all the resources that we held because of a
        //  VOLSNAP_FLUSH_AND_HOLD. 
        //

        if (ReleaseResources && !NtfsIsVolumeReadOnly( IrpContext->Vcb )) {
        
            NtfsReleaseAllFiles( IrpContext, IrpContext->Vcb, FALSE );
            NtfsReleaseVcb( IrpContext, Vcb );
        }
#ifdef SUPW_DBG
        if (AbnormalTermination()) {

            DbgPrint("CommonDevControl Raised: Status %8lx\n", Status);
        }
#endif
    }

    NtfsCleanupIrpContext( IrpContext, TRUE );
    
    DebugTrace( -1, Dbg, ("NtfsCommonDeviceControl -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
DeviceControlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    
    //
    //  Add the hack-o-ramma to fix formats.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }
    
    if (Contxt) {
        
        PNTFS_COMPLETION_CONTEXT CompletionContext = (PNTFS_COMPLETION_CONTEXT)Contxt;

        KeSetEvent( &CompletionContext->Event, 0, FALSE );
    }

    //
    //  Return success always, because we want this IRP to go away for good
    //  irrespective of the IRP completion status.
    //
    
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\dirctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routine for Ntfs called
    by the dispatch driver.

Author:

    Tom Miller      [TomM]          1-Jan-1992

        (Based heavily on GaryKi's dirctrl.c for pinball.)

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRCTRL)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('dFtN')

NTSTATUS
NtfsQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonDirectoryControl)
#pragma alloc_text(PAGE, NtfsFsdDirectoryControl)
#pragma alloc_text(PAGE, NtfsNotifyChangeDirectory)
#pragma alloc_text(PAGE, NtfsReportViewIndexNotify)
#pragma alloc_text(PAGE, NtfsQueryDirectory)
#endif


NTSTATUS
NtfsFsdDirectoryControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Directory Control.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;
    IRP_CONTEXT LocalIrpContext;

    BOOLEAN Wait;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdDirectoryControl\n") );

    //
    //  Call the common Directory Control routine
    //

    FsRtlEnterFileSystem();

    //
    //  Always make these requests look top level.
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the IrpContext.
                //

                Wait = FALSE;
                if (CanFsdWait( Irp )) {

                    Wait = TRUE;
                    IrpContext = &LocalIrpContext;
                }

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            Status = NtfsCommonDirectoryControl( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdDirectoryControl -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonDirectoryControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Directory Control called by both the fsd
    and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PSCB Scb;
    PCCB Ccb;
    PFCB Fcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonDirectoryControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call an internal worker routine to complete
    //  the irp.
    //

    switch ( IrpSp->MinorFunction ) {

    case IRP_MN_QUERY_DIRECTORY:

        //
        //  Decide if this is a view or filename index.
        //

        if ((UserViewIndexOpen == TypeOfOpen) &&
            FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

            Status = NtfsQueryViewIndex( IrpContext, Irp, Vcb, Scb, Ccb );

        } else if ((UserDirectoryOpen == TypeOfOpen) &&
                   !FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

            Status = NtfsQueryDirectory( IrpContext, Irp, Vcb, Scb, Ccb );

        } else {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace( -1, Dbg, ("NtfsCommonDirectoryControl -> STATUS_INVALID_PARAMETER\n") );
            return STATUS_INVALID_PARAMETER;
        }

        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        //
        //  We can't perform this operation on open by Id or if the caller has
        //  closed his handle.  Make sure the handle is for either a view index
        //  or file name index.
        //

        if (((TypeOfOpen != UserDirectoryOpen) &&
             (TypeOfOpen != UserViewIndexOpen)) ||
            FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) ||
            FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace( -1, Dbg, ("NtfsCommonDirectoryControl -> STATUS_INVALID_PARAMETER\n") );
            return STATUS_INVALID_PARAMETER;
        }

        Status = NtfsNotifyChangeDirectory( IrpContext, Irp, Vcb, Scb, Ccb );
        break;

    default:

        DebugTrace( 0, Dbg, ("Invalid Minor Function %08lx\n", IrpSp->MinorFunction) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsCommonDirectoryControl -> %08lx\n", Status) );

    return Status;
}


VOID
NtfsReportViewIndexNotify (
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID ChangeInfoBuffer,
    IN USHORT ChangeInfoBufferLength
    )

/*++

Routine Description:

    This function notifies processes that there has been a change to a
    view index they are watching.  It is analogous to the NtfsReportDirNotify
    macro, which is used only for directories, while this function is used
    only for view indices.

Arguments:

    Vcb - The volume on which the change is taking place.

    Fcb - The file on which the change is taking place.

    FilterMatch  -  This flag field is compared with the completion filter
        in the notify structure.  If any of the corresponding bits in the
        completion filter are set, then a notify condition exists.

    Action  -  This is the action code to store in the user's buffer if
        present.

    ChangeInfoBuffer - Pointer to a buffer of information related to the
        change being reported.  This information is returned to the
        process that owns the notify handle.

    ChangeInfoBufferLength - The length, in bytes, of the buffer passed
        in ChangeInfoBuffer.


Return Value:

    None.

--*/

{
    STRING ChangeInfo;

    PAGED_CODE( );

    ChangeInfo.Length = ChangeInfo.MaximumLength = ChangeInfoBufferLength;
    ChangeInfo.Buffer = ChangeInfoBuffer;

    FsRtlNotifyFilterReportChange( Vcb->NotifySync,
                                   &Vcb->ViewIndexNotifyList,
                                   NULL,
                                   0,
                                   &ChangeInfo,
                                   &ChangeInfo,
                                   FilterMatch,
                                   Action,
                                   Fcb,
                                   NULL );
}


//
//  Local Support Routine
//

NTSTATUS
NtfsQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing or enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

    Vcb - Supplies its Vcb

    Scb - Supplies its Scb

    Ccb - Supplies its Ccb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    PUCHAR Buffer;
    CLONG UserBufferLength;

    ULONG BaseLength;

    PUNICODE_STRING UniFileName;
    FILE_INFORMATION_CLASS FileInformationClass;
    ULONG FileIndex;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;
    BOOLEAN AccessingUserBuffer = FALSE;

    BOOLEAN IgnoreCase;

    BOOLEAN NextFlag;

    BOOLEAN GotEntry;

    BOOLEAN CallRestart;

    ULONG NextEntry;
    ULONG LastEntry;

    PFILE_DIRECTORY_INFORMATION DirInfo;
    PFILE_FULL_DIR_INFORMATION FullDirInfo;
    PFILE_BOTH_DIR_INFORMATION BothDirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;

    PFILE_NAME FileNameBuffer;
    PVOID UnwindFileNameBuffer = NULL;
    ULONG FileNameLength;

    ULONG SizeOfFileName = FIELD_OFFSET( FILE_NAME, FileName );

    INDEX_CONTEXT OtherContext;

    PFCB AcquiredFcb = NULL;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN CcbAcquired = FALSE;

    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN FirstQuery = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT_VCB( Vcb );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsQueryDirectory...\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, (" ->Length               = %08lx\n", IrpSp->Parameters.QueryDirectory.Length) );
    DebugTrace( 0, Dbg, (" ->FileName             = %08lx\n", IrpSp->Parameters.QueryDirectory.FileName) );
    DebugTrace( 0, Dbg, (" ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass) );
    DebugTrace( 0, Dbg, (" ->FileIndex            = %08lx\n", IrpSp->Parameters.QueryDirectory.FileIndex) );
    DebugTrace( 0, Dbg, (" ->SystemBuffer         = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, (" ->RestartScan          = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, (" ->ReturnSingleEntry    = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, (" ->IndexSpecified       = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED)) );
    DebugTrace( 0, Dbg, ("Vcb        = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Ccb        = %08lx\n", Ccb) );

#if DBG
    //
    //  Enable debug port displays when certain enumeration strings are given
    //

#if NTFSPOOLCHECK
    if (IrpSp->Parameters.QueryDirectory.FileName != NULL) {
        if (IrpSp->Parameters.QueryDirectory.FileName->Length >= 10 &&
            RtlEqualMemory( IrpSp->Parameters.QueryDirectory.FileName->Buffer, L"$HEAP", 10 )) {

            NtfsDebugHeapDump( IrpSp->Parameters.QueryDirectory.FileName );

        }
    }
#endif  //  NTFSPOOLCHECK
#endif  //  DBG

    //
    //  Because we probably need to do the I/O anyway we'll reject any request
    //  right now that cannot wait for I/O.  We do not want to abort after
    //  processing a few index entries.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        DebugTrace( 0, Dbg, ("Automatically enqueue Irp to Fsp\n") );

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsQueryDirectory -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = IrpSp->Parameters.QueryDirectory.Length;

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;
    FileIndex = IrpSp->Parameters.QueryDirectory.FileIndex;

    //
    //  Look in the Ccb to see the type of search.
    //

    IgnoreCase = BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE );

    RestartScan = BooleanFlagOn( IrpSp->Flags, SL_RESTART_SCAN );
    ReturnSingleEntry = BooleanFlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY );
    IndexSpecified = BooleanFlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED );

    //
    //  Determine the size of the constant part of the structure.
    //

    switch (FileInformationClass) {

    case FileDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                   FileName[0] );
        break;

    case FileFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileNamesInformation:

        BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                   FileName[0] );
        break;

    case FileBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    default:

        Status = STATUS_INVALID_INFO_CLASS;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsQueryDirectory -> %08lx\n", Status) );
        return Status;
    }

    NtfsInitializeIndexContext( &OtherContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We only allow one active request in this handle at a time.  If this is
        //  not a synchronous request then wait on the handle.
        //

        if (!FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO )) {

            EOF_WAIT_BLOCK WaitBlock;
            NtfsAcquireIndexCcb( Scb, Ccb, &WaitBlock );
            CcbAcquired = TRUE;
        }

        //
        //  We have to create a File Name string for querying if there is either
        //  one specified in this request, or we do not already have a value
        //  in the Ccb.  If we already have one then we will ignore the input
        //  name in this case unless the INDEX_SPECIFIED bit is set.
        //

        if ((Ccb->QueryBuffer == NULL) ||
            ((IrpSp->Parameters.QueryDirectory.FileName != NULL) && IndexSpecified)) {

            //
            //  Now, if the input string is NULL, we have to create the default
            //  string "*".
            //

            if (IrpSp->Parameters.QueryDirectory.FileName == NULL) {

                FileNameLength = SizeOfFileName + sizeof(WCHAR);
                FileNameBuffer = NtfsAllocatePool(PagedPool, FileNameLength );

                //
                //  Initialize it.
                //

                FileNameBuffer->ParentDirectory = Scb->Fcb->FileReference;
                FileNameBuffer->FileNameLength = 1;
                FileNameBuffer->Flags = 0;
                FileNameBuffer->FileName[0] = '*';

            //
            //  We know we have an input file name, and we may or may not already
            //  have one in the Ccb.  Allocate space for it, initialize it, and
            //  set up to deallocate on the way out if we already have a pattern
            //  in the Ccb.
            //

            } else {

                UniFileName = IrpSp->Parameters.QueryDirectory.FileName;

                if (!NtfsIsFileNameValid(UniFileName, TRUE)) {

                    if ((Ccb->QueryBuffer == NULL) || 
                        (UniFileName->Length > 4) || 
                        (UniFileName->Length == 0) || 
                        (UniFileName->Buffer[0] != L'.') || 
                        ((UniFileName->Length == 4) && (UniFileName->Buffer[1] != L'.'))) {

                        try_return( Status = STATUS_OBJECT_NAME_INVALID );
                    }
                }

                FileNameLength = (USHORT)IrpSp->Parameters.QueryDirectory.FileName->Length;

                FileNameBuffer = NtfsAllocatePool(PagedPool, SizeOfFileName + FileNameLength );

                RtlCopyMemory( FileNameBuffer->FileName,
                               UniFileName->Buffer,
                               FileNameLength );

                FileNameLength += SizeOfFileName;

                FileNameBuffer->ParentDirectory = Scb->Fcb->FileReference;
                FileNameBuffer->FileNameLength = (UCHAR)((FileNameLength - SizeOfFileName) / sizeof( WCHAR ));
                FileNameBuffer->Flags = 0;
            }

            //
            //  If we already have a query buffer, deallocate this on the way
            //  out.
            //

            if (Ccb->QueryBuffer != NULL) {

                //
                //  If we have a name to resume from then override the restart
                //  scan boolean.
                //

                if ((UnwindFileNameBuffer = FileNameBuffer) != NULL) {

                    RestartScan = FALSE;
                }

            //
            //  Otherwise, store this one in the Ccb.
            //

            } else {

                UNICODE_STRING Expression;

                Ccb->QueryBuffer = (PVOID)FileNameBuffer;
                Ccb->QueryLength = (USHORT)FileNameLength;
                FirstQuery = TRUE;

                //
                //  If the search expression contains a wild card then remember this in
                //  the Ccb.
                //

                Expression.MaximumLength =
                Expression.Length = FileNameBuffer->FileNameLength * sizeof( WCHAR );
                Expression.Buffer = FileNameBuffer->FileName;

                //
                //  When we establish the search pattern, we must also establish
                //  whether the user wants to see "." and "..".  This code does
                //  not necessarily have to be perfect (he said), but should be
                //  good enough to catch the common cases.  Dos does not have
                //  perfect semantics for these cases, and the following determination
                //  will mimic what FastFat does exactly.
                //

                if (Scb != Vcb->RootIndexScb) {
                    static UNICODE_STRING DotString = CONSTANT_UNICODE_STRING( L"." );

                    if (FsRtlDoesNameContainWildCards(&Expression)) {

                        if (FsRtlIsNameInExpression( &Expression,
                                                     &DotString,
                                                     FALSE,
                                                     NULL )) {


                            SetFlag( Ccb->Flags, CCB_FLAG_RETURN_DOT | CCB_FLAG_RETURN_DOTDOT );
                        }
                    } else {
                        if (NtfsAreNamesEqual( Vcb->UpcaseTable, &Expression, &DotString, FALSE )) {

                            SetFlag( Ccb->Flags, CCB_FLAG_RETURN_DOT | CCB_FLAG_RETURN_DOTDOT );
                        }
                    }
                }
            }

        //
        //  Otherwise we are just restarting the query from the Ccb.
        //

        } else {

            FileNameBuffer = (PFILE_NAME)Ccb->QueryBuffer;
            FileNameLength = Ccb->QueryLength;
        }

        Irp->IoStatus.Information = 0;

        //
        //  Use a try-except to handle errors accessing the user buffer.
        //

        try {

            ULONG BytesToCopy;

            FCB_TABLE_ELEMENT Key;
            PFCB_TABLE_ELEMENT Entry;

            BOOLEAN MatchAll = FALSE;

            //
            //  See if we are supposed to try to acquire an Fcb on this
            //  resume.
            //

            if (Ccb->FcbToAcquire.LongValue != 0) {

                //
                //  First we need to acquire the Vcb shared, since we will
                //  acquire two Fcbs.
                //

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                VcbAcquired = TRUE;

                //
                //  Now look up the Fcb, and if it is there, reference it
                //  and remember it.
                //

                Key.FileReference = Ccb->FcbToAcquire.FileReference;
                NtfsAcquireFcbTable( IrpContext, Vcb );
                Entry = RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );
                if (Entry != NULL) {
                    AcquiredFcb = Entry->Fcb;
                    AcquiredFcb->ReferenceCount += 1;
                }
                NtfsReleaseFcbTable( IrpContext, Vcb );

                //
                //  Now that it cannot go anywhere, acquire it.
                //

                if (AcquiredFcb != NULL) {
                    NtfsAcquireSharedFcb( IrpContext, AcquiredFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }

                //
                //  Now that we actually acquired it, we may as well clear this
                //  field.
                //

                Ccb->FcbToAcquire.LongValue = 0;
            }

            //
            //  Acquire shared access to the Scb.
            //

            NtfsAcquireSharedScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            //
            //  Now that we have both files acquired, we can free the Vcb.
            //

            if (VcbAcquired) {
                NtfsReleaseVcb( IrpContext, Vcb );
                VcbAcquired = FALSE;
            }

            //
            //  If the volume is no longer mounted, we should fail this
            //  request.  Since we have the Scb shared now, we know that
            //  a dismount request can't sneak in.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            //
            // If we are in the Fsp now because we had to wait earlier,
            // we must map the user buffer, otherwise we can use the
            // user's buffer directly.
            //

            Buffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

            //
            //  Check if this is the first call to query directory for this file
            //  object.  It is the first call if the enumeration context field of
            //  the ccb is null.  Also check if we are to restart the scan.
            //

            if (FirstQuery || RestartScan) {

                CallRestart = TRUE;
                NextFlag = FALSE;

                //
                //  On first/restarted scan, note that we have not returned either
                //  of these guys.
                //

                ClearFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED | CCB_FLAG_DOTDOT_RETURNED );

            //
            //  Otherwise check to see if we were given a file name to restart from
            //

            } else if (UnwindFileNameBuffer != NULL) {

                CallRestart = TRUE;
                NextFlag = TRUE;

                //
                //  The guy could actually be asking to return to one of the dot
                //  file positions, so we must handle that correctly.
                //

                if ((FileNameBuffer->FileNameLength <= 2) &&
                    (FileNameBuffer->FileName[0] == L'.')) {

                    if (FileNameBuffer->FileNameLength == 1) {

                        //
                        //  He wants to resume after ".", so we set to return
                        //  ".." again, and change the temporary pattern to
                        //  rewind our context to the front.
                        //

                        ClearFlag( Ccb->Flags, CCB_FLAG_DOTDOT_RETURNED );
                        SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED );

                        FileNameBuffer->FileName[0] = L'*';
                        NextFlag = FALSE;

                    } else if (FileNameBuffer->FileName[1] == L'.') {

                        //
                        //  He wants to resume after "..", so we the change
                        //  the temporary pattern to rewind our context to the
                        //  front.
                        //

                        SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED | CCB_FLAG_DOTDOT_RETURNED );
                        FileNameBuffer->FileName[0] =
                        FileNameBuffer->FileName[1] = L'*';
                        NextFlag = FALSE;
                    }

                //
                //  Always return the entry after the user's file name.
                //

                } else {

                    SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED | CCB_FLAG_DOTDOT_RETURNED );
                }

            //
            //  Otherwise we're simply continuing a previous enumeration from
            //  where we last left off.  And we always leave off one beyond the
            //  last entry we returned.
            //

            } else {

                CallRestart = FALSE;
                NextFlag = FALSE;
            }

            //
            //  At this point we are about to enter our query loop.  We have
            //  already decided if we need to call restart or continue when we
            //  go after an index entry.  The variables LastEntry and NextEntry are
            //  used to index into the user buffer.  LastEntry is the last entry
            //  we added to the user buffer, and NextEntry is the current
            //  one we're working on.
            //

            LastEntry = 0;
            NextEntry = 0;

            //
            //  Remember if we are matching everything by checking these two common
            //  cases.
            //

            MatchAll = (FileNameBuffer->FileName[0] == L'*')

                        &&

                       ((FileNameBuffer->FileNameLength == 1) ||

                        ((FileNameBuffer->FileNameLength == 3) &&
                         (FileNameBuffer->FileName[1] == L'.') &&
                         (FileNameBuffer->FileName[2] == L'*')));

            while (TRUE) {

                PINDEX_ENTRY IndexEntry;
                PFILE_NAME NtfsFileName;
                PDUPLICATED_INFORMATION DupInfo;
                PFILE_NAME DosFileName;
                FILE_REFERENCE FileId;

                ULONG BytesRemainingInBuffer;
                ULONG FoundFileNameLength;

                struct {

                    FILE_NAME FileName;
                    WCHAR LastChar;
                } DotDotName;

                BOOLEAN SynchronizationError;

                DebugTrace( 0, Dbg, ("Top of Loop\n") );
                DebugTrace( 0, Dbg, ("LastEntry = %08lx\n", LastEntry) );
                DebugTrace( 0, Dbg, ("NextEntry = %08lx\n", NextEntry) );

                //
                //  If a previous pass through the loop acquired the Fcb table then
                //  release it now.  We don't want to be holding it if we take a fault
                //  on the directory stream.  Otherwise we can get into a circular
                //  deadlock if we need to acquire the mutex for this file while
                //  holding the mutex for the Fcb Table.
                //

                if (FlagOn( OtherContext.Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED )) {
                    NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
                    ClearFlag( OtherContext.Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
                }
                DosFileName = NULL;

                //
                //  Lookup the next index entry.  Check if we need to do the lookup
                //  by calling restart or continue.  If we do need to call restart
                //  check to see if we have a real AnsiFileName.  And set ourselves
                //  up for subsequent iternations through the loop
                //

                if (CallRestart) {

                    GotEntry = NtfsRestartIndexEnumeration( IrpContext,
                                                            Ccb,
                                                            Scb,
                                                            (PVOID)FileNameBuffer,
                                                            IgnoreCase,
                                                            NextFlag,
                                                            &IndexEntry,
                                                            AcquiredFcb );
                    CallRestart = FALSE;

                } else {

                    GotEntry = NtfsContinueIndexEnumeration( IrpContext,
                                                             Ccb,
                                                             Scb,
                                                             NextFlag,
                                                             &IndexEntry );
                }

                //
                //  Check to see if we should quit the loop because we are only
                //  returning a single entry.  We actually want to spin around
                //  the loop top twice so that our enumeration has has us left off
                //  at the last entry we didn't return.  We know this is now our
                //  second time though the loop if NextEntry is not zero.
                //

                if ((ReturnSingleEntry) && (NextEntry != 0)) {

                    break;
                }

                //
                //  Assume we won't be returning the file id.
                //

                *((PLONGLONG) &FileId) = 0;

                //
                //  Assume we are to return one of the names "." or "..".
                //  We should not search farther in the index so we set
                //  NextFlag to FALSE.
                //

                RtlZeroMemory( &DotDotName, sizeof(DotDotName) );
                NtfsFileName = &DotDotName.FileName;
                NtfsFileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
                NtfsFileName->FileName[0] =
                NtfsFileName->FileName[1] = L'.';
                DupInfo = &Scb->Fcb->Info;
                NextFlag = FALSE;

                //
                //  Handle "." first.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_DOT_RETURNED ) &&
                    FlagOn( Ccb->Flags, CCB_FLAG_RETURN_DOT )) {

                    FoundFileNameLength = 2;
                    GotEntry = TRUE;
                    SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED );

                    FileId = Scb->Fcb->FileReference;

                //
                //  Handle ".." next.
                //

                } else if (!FlagOn(Ccb->Flags, CCB_FLAG_DOTDOT_RETURNED) &&
                           FlagOn(Ccb->Flags, CCB_FLAG_RETURN_DOTDOT)) {

                    FoundFileNameLength = 4;
                    GotEntry = TRUE;
                    SetFlag( Ccb->Flags, CCB_FLAG_DOTDOT_RETURNED );

                } else {

                    //
                    //  Compute the length of the name we found.
                    //

                    if (GotEntry) {

                        FileId = IndexEntry->FileReference;

                        NtfsFileName = (PFILE_NAME)(IndexEntry + 1);

                        FoundFileNameLength = NtfsFileName->FileNameLength * sizeof( WCHAR );

                        //
                        //  Verify the index entry is valid.
                        //

                        if (FoundFileNameLength != IndexEntry->AttributeLength - SizeOfFileName) {

                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                        }

                        DupInfo = &NtfsFileName->Info;
                        NextFlag = TRUE;

                        //
                        //  Don't return any system files.
                        //

                        if (NtfsSegmentNumber( &IndexEntry->FileReference ) < FIRST_USER_FILE_NUMBER &&
                            NtfsProtectSystemFiles) {

                            continue;
                        }

                    }
                }

                //
                //  Now check to see if we actually got another index entry.  If
                //  we didn't then we also need to check if we never got any
                //  or if we just ran out.  If we just ran out then we break out
                //  of the main loop and finish the Irp after the loop
                //

                if (!GotEntry) {

                    DebugTrace( 0, Dbg, ("GotEntry is FALSE\n") );

                    if (NextEntry == 0) {

                        if (FirstQuery) {

                            try_return( Status = STATUS_NO_SUCH_FILE );
                        }

                        try_return( Status = STATUS_NO_MORE_FILES );
                    }

                    break;
                }

                //
                //  Cleanup and reinitialize context from previous loop.
                //

                NtfsReinitializeIndexContext( IrpContext, &OtherContext );

                //
                //  We may have matched a Dos-Only name.  If so we will save
                //  it and go get the Ntfs name.
                //

                if (!FlagOn(NtfsFileName->Flags, FILE_NAME_NTFS) &&
                    FlagOn(NtfsFileName->Flags, FILE_NAME_DOS)) {

                    //
                    //  If we are returning everything, then we can skip
                    //  the Dos-Only names and save some cycles.
                    //

                    if (MatchAll) {
                        continue;
                    }

                    DosFileName = NtfsFileName;

                    NtfsFileName = NtfsRetrieveOtherFileName( IrpContext,
                                                              Ccb,
                                                              Scb,
                                                              IndexEntry,
                                                              &OtherContext,
                                                              AcquiredFcb,
                                                              &SynchronizationError );

                    //
                    //  If we got an Ntfs name, then we need to list this entry now
                    //  iff the Ntfs name is not in the expression.  If the Ntfs
                    //  name is in the expression, we can just continue and print
                    //  this name when we encounter it by the Ntfs name.
                    //

                    if (NtfsFileName != NULL) {

                        if (FlagOn( Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION )) {

                            if (NtfsFileNameIsInExpression( Vcb->UpcaseTable,
                                                            (PFILE_NAME)Ccb->QueryBuffer,
                                                            NtfsFileName,
                                                            IgnoreCase )) {

                                continue;
                            }

                        } else {

                            if (NtfsFileNameIsEqual( Vcb->UpcaseTable,
                                                     (PFILE_NAME)Ccb->QueryBuffer,
                                                     NtfsFileName,
                                                     IgnoreCase )) {

                                continue;
                            }
                        }

                        FoundFileNameLength = NtfsFileName->FileNameLength * sizeof( WCHAR );

                    } else if (SynchronizationError) {

                        if (Irp->IoStatus.Information != 0) {
                            try_return( Status = STATUS_SUCCESS );
                        } else {
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                    } else {

                        continue;
                    }
                }

                //
                //  Here are the rules concerning filling up the buffer:
                //
                //  1.  The Io system garentees that there will always be
                //      enough room for at least one base record.
                //
                //  2.  If the full first record (including file name) cannot
                //      fit, as much of the name as possible is copied and
                //      STATUS_BUFFER_OVERFLOW is returned.
                //
                //  3.  If a subsequent record cannot completely fit into the
                //      buffer, none of it (as in 0 bytes) is copied, and
                //      STATUS_SUCCESS is returned.  A subsequent query will
                //      pick up with this record.
                //

                BytesRemainingInBuffer = UserBufferLength - NextEntry;

                if ((NextEntry != 0) &&
                    ((BaseLength + FoundFileNameLength > BytesRemainingInBuffer) ||
                     (UserBufferLength < NextEntry))) {

                    DebugTrace( 0, Dbg, ("Next entry won't fit\n") );

                    try_return( Status = STATUS_SUCCESS );
                }

                ASSERT( BytesRemainingInBuffer >= BaseLength );

                //
                //  Zero the base part of the structure.
                //

                AccessingUserBuffer = TRUE;
                RtlZeroMemory( &Buffer[NextEntry], BaseLength );
                AccessingUserBuffer = FALSE;

                //
                //  Now we have an entry to return to our caller. we'll
                //  case on the type of information requested and fill up the
                //  user buffer if everything fits
                //

                switch (FileInformationClass) {

                case FileIdFullDirectoryInformation:

                    AccessingUserBuffer = TRUE;
                    ((PFILE_ID_FULL_DIR_INFORMATION)&Buffer[NextEntry])->FileId.QuadPart = *((PLONGLONG) &FileId);
                    AccessingUserBuffer = FALSE;

                    goto FillFullDirectoryInformation;

                case FileIdBothDirectoryInformation:

                    AccessingUserBuffer = TRUE;
                    ((PFILE_ID_BOTH_DIR_INFORMATION)&Buffer[NextEntry])->FileId.QuadPart = *((PLONGLONG) &FileId);
                    AccessingUserBuffer = FALSE;

                    //  Fall thru

                case FileBothDirectoryInformation:

                    BothDirInfo = (PFILE_BOTH_DIR_INFORMATION)&Buffer[NextEntry];

                    //
                    //  If this is not also a Dos name, and the Ntfs flag is set
                    //  (meaning there is a separate Dos name), then call the
                    //  routine to get the short name, if we do not already have
                    //  it from above.
                    //

                    if (!FlagOn( NtfsFileName->Flags, FILE_NAME_DOS ) &&
                        FlagOn( NtfsFileName->Flags, FILE_NAME_NTFS )) {

                        if (DosFileName == NULL) {

                            DosFileName = NtfsRetrieveOtherFileName( IrpContext,
                                                                     Ccb,
                                                                     Scb,
                                                                     IndexEntry,
                                                                     &OtherContext,
                                                                     AcquiredFcb,
                                                                     &SynchronizationError );
                        }

                        if (DosFileName != NULL) {

                            //
                            //  Verify this is a legal length short name - Note we only do partial
                            //  verification checks on index buffers which is why we have to 
                            //  check here. 
                            //  

                            if (DosFileName->FileNameLength * sizeof( WCHAR ) > sizeof( BothDirInfo->ShortName )) {
                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
                            }

                            AccessingUserBuffer = TRUE;
                            BothDirInfo->ShortNameLength = DosFileName->FileNameLength * sizeof( WCHAR );
                            RtlCopyMemory( BothDirInfo->ShortName,
                                           DosFileName->FileName,
                                           BothDirInfo->ShortNameLength );
                        } else if (SynchronizationError) {

                            if (Irp->IoStatus.Information != 0) {
                                try_return( Status = STATUS_SUCCESS );
                            } else {
                                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                            }
                        }
                    }

                    //  Fallthru

                case FileFullDirectoryInformation:

FillFullDirectoryInformation:

                    DebugTrace( 0, Dbg, ("Getting file full Unicode directory information\n") );

                    FullDirInfo = (PFILE_FULL_DIR_INFORMATION)&Buffer[NextEntry];

                    //
                    //  EAs and reparse points cannot both be in a file at the same
                    //  time. We return different information for each case.
                    //

                    AccessingUserBuffer = TRUE;
                    if (FlagOn( DupInfo->FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT)) {

                        FullDirInfo->EaSize = DupInfo->ReparsePointTag;
                    } else {

                        FullDirInfo->EaSize = DupInfo->PackedEaSize;

                        //
                        //  Add 4 bytes for the CbListHeader.
                        //

                        if (DupInfo->PackedEaSize != 0) {

                            FullDirInfo->EaSize += 4;
                        }
                    }

                    //  Fallthru

                case FileDirectoryInformation:

                    DebugTrace( 0, Dbg, ("Getting file Unicode directory information\n") );

                    DirInfo = (PFILE_DIRECTORY_INFORMATION)&Buffer[NextEntry];

                    AccessingUserBuffer = TRUE;
                    DirInfo->CreationTime.QuadPart = DupInfo->CreationTime;
                    DirInfo->LastAccessTime.QuadPart = DupInfo->LastAccessTime;
                    DirInfo->LastWriteTime.QuadPart = DupInfo->LastModificationTime;
                    DirInfo->ChangeTime.QuadPart = DupInfo->LastChangeTime;

                    DirInfo->FileAttributes = DupInfo->FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;

                    if (IsDirectory( DupInfo ) || IsViewIndex( DupInfo )) {
                        DirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    }
                    if (DirInfo->FileAttributes == 0) {
                        DirInfo->FileAttributes = FILE_ATTRIBUTE_NORMAL;
                    }

                    DirInfo->FileNameLength = FoundFileNameLength;

                    DirInfo->EndOfFile.QuadPart = DupInfo->FileSize;
                    DirInfo->AllocationSize.QuadPart = DupInfo->AllocatedLength;

                    break;

                case FileNamesInformation:

                    DebugTrace( 0, Dbg, ("Getting file Unicode names information\n") );

                    AccessingUserBuffer = TRUE;
                    NamesInfo = (PFILE_NAMES_INFORMATION)&Buffer[NextEntry];

                    NamesInfo->FileNameLength = FoundFileNameLength;

                    break;

                default:

                    try_return( Status = STATUS_INVALID_INFO_CLASS );
                }

                //
                //  Compute how many bytes we can copy.  This should only be less
                //  than the file name length if we are only returning a single
                //  entry.
                //

                if (BytesRemainingInBuffer >= BaseLength + FoundFileNameLength) {

                    BytesToCopy = FoundFileNameLength;

                } else {

                    BytesToCopy = BytesRemainingInBuffer - BaseLength;

                    Status = STATUS_BUFFER_OVERFLOW;
                }

                ASSERT( AccessingUserBuffer );
                RtlCopyMemory( &Buffer[NextEntry + BaseLength],
                               NtfsFileName->FileName,
                               BytesToCopy );

                //
                //  If/when we actually emit a record for the Fcb acquired,
                //  then we can release that file now.  Note we do not just
                //  do it on the first time through the loop, because some of
                //  our callers back up a bit when they give us the resume point.
                //

                if ((AcquiredFcb != NULL) &&
                    (DupInfo != &Scb->Fcb->Info) &&
                    NtfsEqualMftRef(&IndexEntry->FileReference, &Ccb->FcbToAcquire.FileReference)) {

                    //
                    //  Now look up the Fcb, and if it is there, reference it
                    //  and remember it.
                    //
                    //  It is pretty inconvenient here to see if the ReferenceCount
                    //  goes to zero and try to do a TearDown, we do not have the
                    //  right resources.  Note that the window is small, and the Fcb
                    //  will go away if either someone opens the file again, someone
                    //  tries to delete the directory, or someone tries to lock the
                    //  volume.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcb->ReferenceCount -= 1;
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    NtfsReleaseFcb( IrpContext, AcquiredFcb );
                    AcquiredFcb = NULL;
                }

                //
                //  Set up the previous next entry offset
                //

                *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;
                AccessingUserBuffer = FALSE;

                //
                //  And indicate how much of the user buffer we have currently
                //  used up.  We must compute this value before we long align
                //  ourselves for the next entry.  This is the point where we
                //  quad-align the length of the previous entry.
                //

                Irp->IoStatus.Information = QuadAlign( Irp->IoStatus.Information) +
                                            BaseLength + BytesToCopy;

                //
                //  If we weren't able to copy the whole name, then we bail here.
                //

                if (!NT_SUCCESS( Status )) {

                    try_return( Status );
                }

                //
                //  Set ourselves up for the next iteration
                //

                LastEntry = NextEntry;
                NextEntry += (ULONG)QuadAlign( BaseLength + BytesToCopy );
            }

            //
            //  At this point we've successfully filled up some of the buffer so
            //  now is the time to set our status to success.
            //

            Status = STATUS_SUCCESS;

        } except( (!FsRtlIsNtstatusExpected( GetExceptionCode() ) && AccessingUserBuffer) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
        }

    try_exit:

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  Set the last access flag in the Fcb if the caller
        //  didn't set it explicitly.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME ) &&
            !FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_LAST_ACCESS )) {

            NtfsGetCurrentTime( IrpContext, Scb->Fcb->CurrentLastAccess );
            SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );
        }

    } finally {

        DebugUnwind( NtfsQueryDirectory );

        if (VcbAcquired) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        NtfsCleanupIndexContext( IrpContext, &OtherContext );

        if (AcquiredFcb != NULL) {

            //
            //  Now look up the Fcb, and if it is there, reference it
            //  and remember it.
            //
            //  It is pretty inconvenient here to see if the ReferenceCount
            //  goes to zero and try to do a TearDown, we do not have the
            //  right resources.  Note that the window is small, and the Fcb
            //  will go away if either someone opens the file again, someone
            //  tries to delete the directory, or someone tries to lock the
            //  volume.
            //

            NtfsAcquireFcbTable( IrpContext, Vcb );
            AcquiredFcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsReleaseFcb( IrpContext, AcquiredFcb );
        }

        if (ScbAcquired) {
            NtfsReleaseScb( IrpContext, Scb );
        }

        NtfsCleanupAfterEnumeration( IrpContext, Ccb );

        if (CcbAcquired) {

            NtfsReleaseIndexCcb( Scb, Ccb );
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        if (UnwindFileNameBuffer != NULL) {

            NtfsFreePool(UnwindFileNameBuffer);
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsQueryDirectory -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing or enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

    Vcb - Supplies its Vcb

    Scb - Supplies its Scb

    Ccb - Supplies its Ccb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG CompletionFilter;

    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;
    PCHECK_FOR_TRAVERSE_ACCESS CallBack = NULL;

    BOOLEAN WatchTree;
    BOOLEAN ViewIndex;
    BOOLEAN FreeSubjectContext = FALSE;
    BOOLEAN SetNotifyCounts = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT_VCB( Vcb );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsNotifyChangeDirectory...\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, (" ->CompletionFilter = %08lx\n", IrpSp->Parameters.NotifyDirectory.CompletionFilter) );
    DebugTrace( 0, Dbg, (" ->WatchTree        = %08lx\n", FlagOn( IrpSp->Flags, SL_WATCH_TREE )) );
    DebugTrace( 0, Dbg, ("Vcb        = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Ccb        = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );

    //
    //  Reference our input parameter to make things easier
    //

    CompletionFilter = IrpSp->Parameters.NotifyDirectory.CompletionFilter;
    WatchTree = BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE );

    //
    //  Always set the wait bit in the IrpContext so the initial wait can't fail.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  We will only acquire the Vcb to perform the dirnotify task.  The dirnotify
    //  package will provide synchronization between this operation and cleanup.
    //  We need the Vcb to synchronize with any rename or link operations underway.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        //
        //  If the Link count is zero on this Fcb then complete this request
        //  with STATUS_DELETE_PENDING.
        //

        if (Scb->Fcb->LinkCount == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_DELETE_PENDING, NULL, NULL );
        }

        ViewIndex = BooleanFlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX );

        //
        //  If we need to verify traverse access for this caller then allocate and
        //  capture the subject context to pass to the dir notify package.  That
        //  package will be responsible for deallocating it.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_TRAVERSE_CHECK )) {

            //
            //  We only use the subject context for directories 
            //    

            if (!ViewIndex) {
                SubjectContext = NtfsAllocatePool( PagedPool,
                                                    sizeof( SECURITY_SUBJECT_CONTEXT ));

                FreeSubjectContext = TRUE;
                SeCaptureSubjectContext( SubjectContext );

                FreeSubjectContext = FALSE;
            }
            CallBack = NtfsNotifyTraverseCheck;
        } 

        //
        //  Update the notify counts and setup for cleanup processing before
        //  we hand off the irp
        // 

        if (!FlagOn( Ccb->Flags, CCB_FLAG_DIR_NOTIFY )) {

            SetFlag( Ccb->Flags, CCB_FLAG_DIR_NOTIFY );

            if (ViewIndex) {

                InterlockedIncrement( &Vcb->ViewIndexNotifyCount );

            } else {

                InterlockedIncrement( &Vcb->NotifyCount );
            }
            SetNotifyCounts = TRUE;
        }

        //
        //  Call the Fsrtl package to process the request.  We cast the
        //  unicode strings to ansi strings as the dir notify package
        //  only deals with memory matching.
        //

        if (ViewIndex) {

            //
            //  View indices use different values for the overloaded inputs
            //  to FsRtlNotifyFilterChangeDirectory.
            //

            FsRtlNotifyFilterChangeDirectory( Vcb->NotifySync,
                                              &Vcb->ViewIndexNotifyList,
                                              Ccb,
                                              NULL,
                                              WatchTree,
                                              FALSE,
                                              CompletionFilter,
                                              Irp,
                                              CallBack,
                                              (PSECURITY_SUBJECT_CONTEXT) Scb->Fcb,
                                              NULL );
        } else {

            FsRtlNotifyFilterChangeDirectory( Vcb->NotifySync,
                                              &Vcb->DirNotifyList,
                                              Ccb,
                                              (PSTRING) &Scb->ScbType.Index.NormalizedName,
                                              WatchTree,
                                              FALSE,
                                              CompletionFilter,
                                              Irp,
                                              CallBack,
                                              SubjectContext,
                                              NULL );
        }

        //
        //  We no longer own the irp at this point and can't safely touch the
        //  scb/ccb etc. anymore since everything might be gone now
        //  

        Status = STATUS_PENDING;

    } finally {

        DebugUnwind( NtfsNotifyChangeDirectory );

        NtfsReleaseVcb( IrpContext, Vcb );

        //
        //  Since the dir notify package is holding the Irp, we discard the
        //  the IrpContext.
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, NULL, 0 );

        } else {
        
            //
            //  Unroll any notify counts we added on exceptions
            // 

            if (SetNotifyCounts) {

                ClearFlag( Ccb->Flags, CCB_FLAG_DIR_NOTIFY );

                if (ViewIndex) {

                    InterlockedDecrement( &Vcb->ViewIndexNotifyCount );

                } else {

                    InterlockedDecrement( &Vcb->NotifyCount );
                }
            }

            if (FreeSubjectContext) {
                NtfsFreePool( SubjectContext );
            }
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsNotifyChangeDirectory -> %08lx\n", Status) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ea.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Ea.c

Abstract:

    This module implements the File set and query Ea routines for Ntfs called
    by the dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('EFtN')

//
//  Local definitions
//

//
//  The following gives us an empty name string.
//

UNICODE_STRING AttrNoName = CONSTANT_UNICODE_STRING( L"" );

#define MAXIMUM_EA_SIZE             0x0000ffff

//
//  The following macros compute the packed and unpacked size of the EAs.
//  We use the 1 char defined in the structure for the NULL terminator of
//  the name.
//

#define SizeOfEaInformation                                         \
    (sizeof( ULONG ) + sizeof( USHORT ) + 3 * sizeof( UCHAR ))

#define PackedEaSize(EA)                                            \
    ((SizeOfEaInformation - 4)                                      \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaNameLength               \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaValueLength)

#define RawUnpackedEaSize(EA)                                       \
    (SizeOfEaInformation                                            \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaNameLength               \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaValueLength)             \

#define AlignedUnpackedEaSize(EA)                                   \
    (((PFILE_FULL_EA_INFORMATION) EA)->NextEntryOffset != 0         \
     ? ((PFILE_FULL_EA_INFORMATION) EA)->NextEntryOffset            \
     : (LongAlign( RawUnpackedEaSize( EA ))))                       \

//
//  BOOLEAN
//  NtfsAreEaNamesEqual (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSTRING NameA,
//      IN PSTRING NameB
//      );
//

#define NtfsAreEaNamesEqual(NAMEA, NAMEB ) ((BOOLEAN)              \
    ((NAMEA)->Length == (NAMEB)->Length                            \
     && RtlEqualMemory( (NAMEA)->Buffer,                           \
                        (NAMEB)->Buffer,                           \
                        (NAMEA)->Length ) )                        \
)

//
//  VOID
//  NtfsUpcaseEaName (
//      IN PSTRING EaName,
//      OUT PSTRING UpcasedEaName
//      );
//

#define NtfsUpcaseEaName( NAME, UPCASEDNAME )   \
    RtlUpperString( UPCASEDNAME, NAME )

BOOLEAN
NtfsIsEaNameValid (
    IN STRING Name
    );

//
//  Local procedure prototypes
//

VOID
NtfsAppendEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN PVCB Vcb
    );

VOID
NtfsDeleteEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN ULONG Offset
    );

BOOLEAN
NtfsLocateEaByName (
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN ULONG EaBufferLength,
    IN PSTRING EaName,
    OUT PULONG Offset
    );

IO_STATUS_BLOCK
NtfsQueryEaUserEaList (
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN PFILE_GET_EA_INFORMATION UserEaList,
    IN BOOLEAN ReturnSingleEntry
    );

IO_STATUS_BLOCK
NtfsQueryEaIndexSpecified (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN ULONG UserEaIndex,
    IN BOOLEAN ReturnSingleEntry
    );

IO_STATUS_BLOCK
NtfsQueryEaSimpleScan (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN BOOLEAN ReturnSingleEntry,
    IN ULONG StartingOffset
    );

BOOLEAN
NtfsIsDuplicateGeaName (
    IN PFILE_GET_EA_INFORMATION CurrentGea,
    IN PFILE_GET_EA_INFORMATION UserGeaBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAppendEa)
#pragma alloc_text(PAGE, NtfsBuildEaList)
#pragma alloc_text(PAGE, NtfsCommonQueryEa)
#pragma alloc_text(PAGE, NtfsCommonSetEa)
#pragma alloc_text(PAGE, NtfsDeleteEa)
#pragma alloc_text(PAGE, NtfsIsDuplicateGeaName)
#pragma alloc_text(PAGE, NtfsIsEaNameValid)
#pragma alloc_text(PAGE, NtfsLocateEaByName)
#pragma alloc_text(PAGE, NtfsMapExistingEas)
#pragma alloc_text(PAGE, NtfsQueryEaIndexSpecified)
#pragma alloc_text(PAGE, NtfsQueryEaSimpleScan)
#pragma alloc_text(PAGE, NtfsQueryEaUserEaList)
#pragma alloc_text(PAGE, NtfsReplaceFileEas)
#endif


NTSTATUS
NtfsCommonQueryEa (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query Ea called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION MappedEaBuffer = NULL;
    ULONG UserBufferLength;
    PFILE_GET_EA_INFORMATION UserEaList;
    ULONG UserEaListLength;
    ULONG UserEaIndex;
    ULONG EaLength;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;
    BOOLEAN TempBufferAllocated = FALSE;
    
    PFILE_FULL_EA_INFORMATION CurrentEas;
    PBCB EaBcb;

    ATTRIBUTE_ENUMERATION_CONTEXT EaInfoAttr;
    BOOLEAN CleanupEaInfoAttr;
    PEA_INFORMATION EaInformation;
    EA_INFORMATION DummyEaInformation;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryEa\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("SystemBuffer       = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.QueryEa.Length) );
    DebugTrace( 0, Dbg, ("EaList             = %08lx\n", IrpSp->Parameters.QueryEa.EaList) );
    DebugTrace( 0, Dbg, ("EaListLength       = %08lx\n", IrpSp->Parameters.QueryEa.EaListLength) );
    DebugTrace( 0, Dbg, ("EaIndex            = %08lx\n", IrpSp->Parameters.QueryEa.EaIndex) );
    DebugTrace( 0, Dbg, ("RestartScan        = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, ("ReturnSingleEntry  = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, ("IndexSpecified     = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED)) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This must be a user file or directory and the Ccb must indicate that
    //  the caller opened the entire file.
    //

    if ((TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) ||
        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Fcb exclusively.
    //

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    //
    //  If this file is a reparse point it cannot support EAs.
    //  Return to caller STATUS_EAS_NOT_SUPPORTED.
    //

    if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

        DebugTrace( 0, Dbg, ("Reparse point present. EAs not supported.\n") );
        Status = STATUS_EAS_NOT_SUPPORTED;

        //
        //  Release the Fcb and return to caller.
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Make sure the volume is still mounted.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

        DebugTrace( 0, Dbg, ("Volume dismounted.\n") );
        Status = STATUS_VOLUME_DISMOUNTED;

        //
        //  Release the Fcb and return to caller.
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Reference our input parameters to make things easier
        //

        UserBufferLength = IrpSp->Parameters.QueryEa.Length;
        UserEaList = (PFILE_GET_EA_INFORMATION) IrpSp->Parameters.QueryEa.EaList;
        UserEaListLength = IrpSp->Parameters.QueryEa.EaListLength;
        UserEaIndex = IrpSp->Parameters.QueryEa.EaIndex;
        RestartScan = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
        ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
        IndexSpecified = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

        //
        //  Initialize our local variables.
        //

        Status = STATUS_SUCCESS;
        CleanupEaInfoAttr = FALSE;
        EaBcb = NULL;

        //
        //  Map the user's buffer.
        //

        if (UserBufferLength != 0) {

            EaBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

            // 
            // Allocate a system buffer to work on, out of paranoia.
            // This buffer will get zeroed later before we actually use it.
            //

            if (Irp->RequestorMode != KernelMode) {

                MappedEaBuffer = EaBuffer;
                EaBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );
                TempBufferAllocated = TRUE;
            } 

            //
            //  Let's clear the output buffer.
            //
    
            RtlZeroMemory( EaBuffer, UserBufferLength );
        }

        //
        //  Verify that the Ea file is in a consistant state.  If the
        //  Ea modification count in the Fcb doesn't match that in
        //  the CCB, then the Ea file has been changed from under
        //  us.  If we are not starting the search from the beginning
        //  of the Ea set, we return an error.
        //

        if ((UserEaList == NULL) && 
            (Ccb->NextEaOffset != 0) &&
            !IndexSpecified &&
            !RestartScan && 
            (Fcb->EaModificationCount != Ccb->EaModificationCount)) {

            DebugTrace( 0, Dbg, ("NtfsCommonQueryEa:  Ea file in unknown state\n") );

            Status = STATUS_EA_CORRUPT_ERROR;

            try_return( Status );
        }

        //
        //  Show that the Ea's for this file are consistant for this
        //  file handle.
        //

        Ccb->EaModificationCount = Fcb->EaModificationCount;

        //
        //  We need to look up the attribute for the Ea information.
        //  If we don't find the attribute, then there are no EA's for
        //  this file.  In that case we dummy up an ea list to use below.
        //

        NtfsInitializeAttributeContext( &EaInfoAttr );

        CleanupEaInfoAttr = TRUE;

        {
            BOOLEAN EasOnFile;

            EasOnFile = FALSE;

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $EA_INFORMATION,
                                           &EaInfoAttr)) {

                //
                //  As a sanity check we will check that the unpacked length is
                //  non-zero.  It should always be so.
                //

                EaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &EaInfoAttr ));

                if (EaInformation->UnpackedEaSize != 0) {

                    EasOnFile = TRUE;
                }
            }

            if (EasOnFile) {

                //
                //  We obtain a pointer to the start of the existing Ea's for the file.
                //

                CurrentEas = NtfsMapExistingEas( IrpContext,
                                                 Fcb,
                                                 &EaBcb,
                                                 &EaLength );

            } else {

                CurrentEas = NULL;
                EaLength = 0;

                DummyEaInformation.PackedEaSize = 0;
                DummyEaInformation.NeedEaCount = 0;
                DummyEaInformation.UnpackedEaSize = 0;

                EaInformation = &DummyEaInformation;
            }
        }

        //
        //  We now satisfy the user's request depending on whether he
        //  specified an Ea name list, an Ea index or restarting the
        //  search.
        //

        //
        //  The user has supplied a list of Ea names.
        //

        if (UserEaList != NULL) {

            Irp->IoStatus = NtfsQueryEaUserEaList( CurrentEas,
                                                   EaInformation,
                                                   EaBuffer,
                                                   UserBufferLength,
                                                   UserEaList,
                                                   ReturnSingleEntry );

        //
        //  The user supplied an index into the Ea list.
        //

        } else if (IndexSpecified) {

            Irp->IoStatus = NtfsQueryEaIndexSpecified( Ccb,
                                                       CurrentEas,
                                                       EaInformation,
                                                       EaBuffer,
                                                       UserBufferLength,
                                                       UserEaIndex,
                                                       ReturnSingleEntry );

        //
        //  Else perform a simple scan, taking into account the restart
        //  flag and the position of the next Ea stored in the Ccb.
        //

        } else {

            Irp->IoStatus = NtfsQueryEaSimpleScan( Ccb,
                                                   CurrentEas,
                                                   EaInformation,
                                                   EaBuffer,
                                                   UserBufferLength,
                                                   ReturnSingleEntry,
                                                   RestartScan
                                                   ? 0
                                                   : Ccb->NextEaOffset );
        }

        Status = Irp->IoStatus.Status;

        //
        // Copy the data onto the user buffer if we ended up allocating
        // a temporary buffer to work on.
        //

        if ((UserBufferLength != 0) && (MappedEaBuffer != NULL)) {

            try {
        
                RtlCopyMemory( MappedEaBuffer, EaBuffer, UserBufferLength );
                
            } except( EXCEPTION_EXECUTE_HANDLER ) {

                try_return( Status = STATUS_INVALID_USER_BUFFER );
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsCommonQueryEa );

        //
        //  We cleanup any attribute contexts.
        //

        if (CleanupEaInfoAttr) {

            NtfsCleanupAttributeContext( IrpContext, &EaInfoAttr );
        }

        //
        //  Unpin the stream file if pinned.
        //

        NtfsUnpinBcb( IrpContext, &EaBcb );

        //
        //  Release the Fcb.
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        if (TempBufferAllocated) {

            NtfsFreePool( EaBuffer );
        }
        
        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsCommonSetEa (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set Ea called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Offset;

    ATTRIBUTE_ENUMERATION_CONTEXT EaInfoAttr;
    PEA_INFORMATION EaInformation;
    PFILE_FULL_EA_INFORMATION SafeBuffer = NULL;
    
    BOOLEAN PreviousEas;

    EA_LIST_HEADER EaList;

    PBCB EaBcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    NtfsInitializeAttributeContext( &EaInfoAttr );

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetEa\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Initialize the IoStatus values.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    //  Check that the file object is associated with either a user file or
    //  user directory open or an open by file ID.
    //

    if ((Ccb == NULL) ||
        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE ) ||
        ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen))) {

        DebugTrace( 0, Dbg, ("Invalid file object\n") );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We must be writable.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We must be waitable.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Acquire the paging file resource.  We need to protect ourselves against collided
    //  page waits in the case where we need to do a ConvertToNonresident in this path.
    //  If we acquire the main and then take the fault we can see the deadlock.  Acquire
    //  the paging io resource to lock everyone else out.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
    NtfsAcquireFcbWithPaging( IrpContext, Fcb, 0 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        ULONG UserBufferLength;
        PFILE_FULL_EA_INFORMATION Buffer;

        PFILE_FULL_EA_INFORMATION CurrentEas;

        //
        //  Reference the input parameters and initialize our local variables.
        //

        UserBufferLength = IrpSp->Parameters.SetEa.Length;

        EaBcb = NULL;
        Offset = 0;

        EaList.FullEa = NULL;

        
        //
        //  If this file is a reparse point one cannot establish an EA in it.
        //  Return to caller STATUS_EAS_NOT_SUPPORTED.
        //
    
        if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {
    
            DebugTrace( 0, Dbg, ("Reparse point present, cannot set EA.\n") );
            Status = STATUS_EAS_NOT_SUPPORTED;
            leave;
        }
    
        //
        //  Make sure the volume is still mounted.
        //
    
        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
    
            DebugTrace( 0, Dbg, ("Volume dismounted.\n") );
            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }
    
        //
        //  Map the user's Ea buffer.
        //

        Buffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

        if (UserBufferLength != 0) {

            // 
            // Be paranoid and copy the user buffer into kernel space.
            //

            if (Irp->RequestorMode != KernelMode) {

                SafeBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );

                try {

                    RtlCopyMemory( SafeBuffer, Buffer, UserBufferLength );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    try_return( Status = STATUS_INVALID_USER_BUFFER );
                }

                Buffer = SafeBuffer;
            }
        }

        //
        //  Check the user's buffer for validity.
        //

        {
            ULONG ErrorOffset;

            Status = IoCheckEaBufferValidity( Buffer,
                                              UserBufferLength,
                                              &ErrorOffset );

            if (!NT_SUCCESS( Status )) {

                Irp->IoStatus.Information = ErrorOffset;
                try_return( Status );
            }
        }

        //
        //  Check if the file has existing Ea's.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $EA_INFORMATION,
                                       &EaInfoAttr)) {

            PreviousEas = TRUE;

            EaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &EaInfoAttr ));

        } else {

            PreviousEas = FALSE;
        }

        //
        //  Sanity check.
        //

        ASSERT( !PreviousEas || EaInformation->UnpackedEaSize != 0 );

        //
        //  Initialize our Ea list structure depending on whether there
        //  were previous Ea's or not.
        //

        if (PreviousEas) {

            //
            //  Copy the information out of the Ea information attribute.
            //

            EaList.PackedEaSize = (ULONG) EaInformation->PackedEaSize;
            EaList.NeedEaCount = EaInformation->NeedEaCount;
            EaList.UnpackedEaSize = EaInformation->UnpackedEaSize;

            CurrentEas = NtfsMapExistingEas( IrpContext,
                                             Fcb,
                                             &EaBcb,
                                             &EaList.BufferSize );

            //
            //  The allocated size of the Ea buffer is the Unpacked length.
            //

            EaList.FullEa = NtfsAllocatePool(PagedPool, EaList.BufferSize );

            //
            //  Now copy the mapped Eas.
            //

            RtlCopyMemory( EaList.FullEa,
                           CurrentEas,
                           EaList.BufferSize );

            //
            //  Upin the stream file.
            //

            NtfsUnpinBcb( IrpContext, &EaBcb );

        } else {

            //
            //  Set this up as an empty list.
            //

            EaList.PackedEaSize = 0;
            EaList.NeedEaCount = 0;
            EaList.UnpackedEaSize = 0;
            EaList.BufferSize = 0;
            EaList.FullEa = NULL;
        }

        //
        //  Build the new ea list.
        //

        Status = NtfsBuildEaList( IrpContext,
                                  Vcb,
                                  &EaList,
                                  Buffer,
                                  &Irp->IoStatus.Information );

        if (!NT_SUCCESS( Status )) {

            try_return( Status );
        }

        //
        //  Replace the existing Eas.
        //

        NtfsReplaceFileEas( IrpContext, Fcb, &EaList );

        //
        //  Increment the Modification count for the Eas.
        //

        Fcb->EaModificationCount++;

        //
        //  Update the information in the duplicate information and mark
        //  the Fcb as info modified.
        //

        if (EaList.UnpackedEaSize == 0) {

            Fcb->Info.PackedEaSize = 0;

        } else {

            Fcb->Info.PackedEaSize = (USHORT) EaList.PackedEaSize;
        }

        //
        //  Update the caller's Iosb.
        //

        Irp->IoStatus.Information = 0;
        Status = STATUS_SUCCESS;

    try_exit:  NOTHING;

        //
        //  Check if there are transactions to cleanup.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  Show that we changed the Ea's and also set the Ccb flag so we will
        //  update the time stamps.
        //

        SetFlag( Ccb->Flags,
                 CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );

    } finally {

        DebugUnwind( NtfsCommonSetEa );

        //
        //  Free the in-memory copy of the Eas.
        //

        if (EaList.FullEa != NULL) {

            NtfsFreePool( EaList.FullEa );
        }

        //
        //  Unpin the Bcb.
        //

        NtfsUnpinBcb( IrpContext, &EaBcb );

        //
        //  Cleanup any attribute contexts used.
        //

        NtfsCleanupAttributeContext( IrpContext, &EaInfoAttr );

        //
        // If we allocated a temporary buffer, free it.
        //

        if (SafeBuffer != NULL) {

            NtfsFreePool( SafeBuffer );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", Status) );
    }
    
    //
    //  Complete the Irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

VOID
NtfsAppendEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine appends a new packed ea onto an existing ea list,
    it also will allocate/dealloate pool as necessary to hold the ea list.

Arguments:

    EaListHeader - Supplies a pointer the Ea list header structure.

    FullEa - Supplies a pointer to the new full ea that is to be appended
             to the ea list.

    Vcb - Vcb for this volume.

Return Value:

    None.

--*/

{
    ULONG UnpackedEaLength;
    STRING EaName;
    PFILE_FULL_EA_INFORMATION ThisEa;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAppendEa...\n") );

    UnpackedEaLength = AlignedUnpackedEaSize( FullEa );

    //
    //  As a quick check see if the computed packed ea size plus the
    //  current ea list size will overflow the buffer.
    //

    if (UnpackedEaLength + EaListHeader->UnpackedEaSize > EaListHeader->BufferSize) {

        //
        //  We will overflow our current work buffer so allocate a larger
        //  one and copy over the current buffer
        //

        PVOID Temp;
        ULONG NewAllocationSize;

        DebugTrace( 0, Dbg, ("Allocate a new ea list buffer\n") );

        //
        //  Compute a new size and allocate space.  Always increase the
        //  allocation in cluster increments.
        //

        NewAllocationSize = ClusterAlign( Vcb,
                                          UnpackedEaLength
                                          + EaListHeader->UnpackedEaSize );

        Temp = NtfsAllocatePool(PagedPool, NewAllocationSize );

        //
        //  Move over the existing ea list and zero the remaining space.
        //

        RtlCopyMemory( Temp,
                       EaListHeader->FullEa,
                       EaListHeader->BufferSize );

        RtlZeroMemory( Add2Ptr( Temp, EaListHeader->BufferSize ),
                       NewAllocationSize - EaListHeader->BufferSize );

        //
        //  Deallocate the current Ea list and use the freshly allocated list.
        //

        if (EaListHeader->FullEa != NULL) {

            NtfsFreePool( EaListHeader->FullEa );
        }

        EaListHeader->FullEa = Temp;

        EaListHeader->BufferSize = NewAllocationSize;
    }

    //
    //  Determine if we need to increment our need ea changes count
    //

    if (FlagOn( FullEa->Flags, FILE_NEED_EA )) {

        EaListHeader->NeedEaCount += 1;
    }

    //
    //  Now copy over the ea.
    //
    //  Before:
    //             UsedSize                     Allocated
    //                |                             |
    //                V                             V
    //      +xxxxxxxx+-----------------------------+
    //
    //  After:
    //                              UsedSize    Allocated
    //                                 |            |
    //                                 V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+------------+
    //

    ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( EaListHeader->FullEa,
                                                  EaListHeader->UnpackedEaSize );

    RtlCopyMemory( ThisEa,
                   FullEa,
                   UnpackedEaLength );

    //
    //  We always store the offset of this Ea in the next entry offset field.
    //

    ThisEa->NextEntryOffset = UnpackedEaLength;

    //
    //  Upcase the name.
    //

    EaName.MaximumLength = EaName.Length = ThisEa->EaNameLength;
    EaName.Buffer = &ThisEa->EaName[0];

    NtfsUpcaseEaName( &EaName, &EaName );

    //
    //  Increment the used size in the ea list structure
    //

    EaListHeader->UnpackedEaSize += UnpackedEaLength;
    EaListHeader->PackedEaSize += PackedEaSize( FullEa );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAppendEa -> VOID\n") );

    return;

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Local support routine
//

VOID
NtfsDeleteEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN ULONG Offset
    )

/*++

Routine Description:

    This routine deletes an individual packed ea from the supplied
    ea list.

Arguments:

    EaListHeader - Supplies a pointer to the Ea list header structure.

    Offset - Supplies the offset to the individual ea in the list to delete

Return Value:

    None.

--*/

{
    PFILE_FULL_EA_INFORMATION ThisEa;
    ULONG UnpackedEaLength;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeletePackedEa, Offset = %08lx\n", Offset) );

    //
    //  Get a reference to the Ea to delete.
    //

    ThisEa = Add2Ptr( EaListHeader->FullEa, Offset );

    //
    //  Determine if we need to decrement our need ea changes count
    //

    if (FlagOn( ThisEa->Flags, FILE_NEED_EA )) {

        EaListHeader->NeedEaCount--;
    }

    //
    //  Decrement the Ea size values.
    //

    EaListHeader->PackedEaSize -= PackedEaSize( ThisEa );

    UnpackedEaLength = AlignedUnpackedEaSize( ThisEa );
    EaListHeader->UnpackedEaSize -= UnpackedEaLength;

    //
    //  Shrink the ea list over the deleted ea.  The amount to copy is the
    //  total size of the ea list minus the offset to the end of the ea
    //  we're deleting.
    //
    //  Before:
    //              Offset    Offset+UnpackedEaLength  UsedSize    Allocated
    //                |                |                  |            |
    //                V                V                  V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+zzzzzzzzzzzzzzzzzz+------------+
    //
    //  After
    //              Offset            UsedSize                     Allocated
    //                |                  |                             |
    //                V                  V                             V
    //      +xxxxxxxx+zzzzzzzzzzzzzzzzzz+-----------------------------+
    //

    RtlMoveMemory( ThisEa,
                   Add2Ptr( ThisEa, ThisEa->NextEntryOffset ),
                   EaListHeader->UnpackedEaSize - Offset );

    //
    //  And zero out the remaing part of the ea list, to make things
    //  nice and more robust
    //

    RtlZeroMemory( Add2Ptr( EaListHeader->FullEa, EaListHeader->UnpackedEaSize ),
                   UnpackedEaLength );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteEa -> VOID\n") );

    return;

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Local support routine
//

BOOLEAN
NtfsLocateEaByName (
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN ULONG EaBufferLength,
    IN PSTRING EaName,
    OUT PULONG Offset
    )

/*++

Routine Description:

    This routine locates the offset for the next individual packed ea
    inside of a ea list, given the name of the ea to locate.

Arguments:

    FullEa - Pointer to the first Ea to look at.

    EaBufferLength - This is the ulong-aligned size of the Ea buffer.

    EaName - Supplies the name of the ea search for

    Offset - Receives the offset to the located individual ea in the list
        if one exists.

Return Value:

    BOOLEAN - TRUE if the named ea exists in the list and FALSE
        otherwise.

--*/

{
    PFILE_FULL_EA_INFORMATION ThisEa;
    STRING Name;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLocateEaByName, EaName = %Z\n", EaName) );

    //
    //  If the Ea list is NULL, there is nothing to do.
    //

    if (FullEa == NULL) {

        DebugTrace( -1, Dbg, ("NtfsLocateEaByName:  No work to do\n") );
        return FALSE;
    }

    //
    //  For each ea in the list check its name against the
    //  ea name we're searching for
    //

    *Offset = 0;

    //
    //  We assume there is at least one Ea in the list.
    //

    do {

        ThisEa = Add2Ptr( FullEa, *Offset );

        //
        //  Make a string out of the name in the Ea and compare it to the
        //  given string.
        //

        RtlInitString( &Name, &ThisEa->EaName[0] );

        if ( RtlCompareString( EaName, &Name, TRUE ) == 0 ) {

            DebugTrace( -1, Dbg, ("NtfsLocateEaByName -> TRUE, *Offset = %08lx\n", *Offset) );
            return TRUE;
        }

        //
        //  Update the offset to get to the next Ea.
        //

        *Offset += AlignedUnpackedEaSize( ThisEa );

    } while ( *Offset < EaBufferLength );

    //
    //  We've exhausted the ea list without finding a match so return false
    //

    DebugTrace( -1, Dbg, ("NtfsLocateEaByName -> FALSE\n") );
    return FALSE;
}


//
//  Local support routine.
//

PFILE_FULL_EA_INFORMATION
NtfsMapExistingEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBCB *EaBcb,
    OUT PULONG EaLength
    )

/*++

Routine Description:

    This routine maps the current Eas for the file, either through the
    Mft record for the file if resident or the Scb for the non-resident
    Eas.

Arguments:

    Fcb - Pointer to the Fcb for the file whose Ea's are being queried.

    EaBcb - Pointer to the Bcb to use if we are mapping data in the
        Ea attribute stream file.

    EaLength - Returns the length of the unpacked Eas in bytes.

Return Value:

    PFILE_FULL_EA_INFORMATION - Pointer to the mapped attributes.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PFILE_FULL_EA_INFORMATION CurrentEas;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapExistingEas:  Entered\n") );

    //
    //  We start by looking up the Ea attribute.  It better be there.
    //

    NtfsInitializeAttributeContext( &Context );

    if (!NtfsLookupAttributeByCode( IrpContext,
                                    Fcb,
                                    &Fcb->FileReference,
                                    $EA,
                                    &Context )) {

        //
        //  This is a disk corrupt error.
        //

        DebugTrace( -1, Dbg, ("NtfsMapExistingEas:  Corrupt disk\n") );

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    try {

        NtfsMapAttributeValue( IrpContext,
                               Fcb,
                               (PVOID *)&CurrentEas,
                               EaLength,
                               EaBcb,
                               &Context );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsMapExistingEas:  Exit\n") );

    return CurrentEas;
}


//
//  Local support routine.
//

IO_STATUS_BLOCK
NtfsQueryEaUserEaList (
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN PFILE_GET_EA_INFORMATION UserEaList,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs given a list
    of Ea's to search for.

Arguments:

    CurrentEas - This is a pointer to the current Eas for the file

    EaInformation - This is a pointer to an Ea information attribute.

    EaBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    UserEaList - Supplies the user specified ea name list

    ReturnSingleEntry - Indicates if we are to return a single entry or not

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    ULONG GeaOffset;
    ULONG FeaOffset;
    ULONG Offset;

    PFILE_FULL_EA_INFORMATION LastFullEa;
    PFILE_FULL_EA_INFORMATION NextFullEa;

    PFILE_GET_EA_INFORMATION GetEa;

    BOOLEAN Overflow;
    ULONG PrevEaPadding;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaUserEaList:  Entered\n") );

    //
    //  Setup pointer in the output buffer so we can track the Ea being
    //  written to it and the last Ea written.
    //

    LastFullEa = NULL;

    Overflow = FALSE;

    //
    //  Initialize our next offset value.
    //

    GeaOffset = 0;
    Offset = 0;
    PrevEaPadding = 0;

    //
    //  Loop through all the entries in the user's ea list.
    //

    while (TRUE) {

        STRING GeaName;
        STRING OutputEaName;
        ULONG RawEaSize;

        //
        //  Get the next entry in the user's list.
        //

        GetEa = (PFILE_GET_EA_INFORMATION) Add2Ptr( UserEaList, GeaOffset );

        //
        //  Make a string reference to the name and see if we can locate
        //  the ea by name.
        //

        GeaName.MaximumLength = GeaName.Length = GetEa->EaNameLength;
        GeaName.Buffer = &GetEa->EaName[0];

        //
        //  Upcase the name so we can do a case-insensitive compare.
        //

        NtfsUpcaseEaName( &GeaName, &GeaName );

        //
        //  Check for a valid name.
        //

        if (!NtfsIsEaNameValid( GeaName )) {

            DebugTrace( -1, Dbg, ("NtfsQueryEaUserEaList:  Invalid Ea Name\n") );

            Iosb.Information = GeaOffset;
            Iosb.Status = STATUS_INVALID_EA_NAME;
            return Iosb;
        }

        GeaOffset += GetEa->NextEntryOffset;

        //
        //  If this is a duplicate name, then step over this entry.
        //

        if (NtfsIsDuplicateGeaName( GetEa, UserEaList )) {

            //
            //  If we've exhausted the entries in the Get Ea list, then we are
            //  done.
            //

            if (GetEa->NextEntryOffset == 0) {
                break;
            } else {
                continue;
            }
        }

        //
        //  Generate a pointer in the Ea buffer.
        //

        NextFullEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( EaBuffer, Offset + PrevEaPadding );

        //
        //  Try to find a matching Ea.
        //  If we couldn't, let's dummy up an Ea to give to the user.
        //

        if (!NtfsLocateEaByName( CurrentEas,
                                 EaInformation->UnpackedEaSize,
                                 &GeaName,
                                 &FeaOffset )) {

            //
            //  We were not able to locate the name therefore we must
            //  dummy up a entry for the query.  The needed Ea size is
            //  the size of the name + 4 (next entry offset) + 1 (flags)
            //  + 1 (name length) + 2 (value length) + the name length +
            //  1 (null byte).
            //

            RawEaSize = 4+1+1+2+GetEa->EaNameLength+1;

            if ((RawEaSize + PrevEaPadding) > UserBufferLength) {

                Overflow = TRUE;
                break;
            }

            //
            //  Everything is going to work fine, so copy over the name,
            //  set the name length and zero out the rest of the ea.
            //

            NextFullEa->NextEntryOffset = 0;
            NextFullEa->Flags = 0;
            NextFullEa->EaNameLength = GetEa->EaNameLength;
            NextFullEa->EaValueLength = 0;
            RtlCopyMemory( &NextFullEa->EaName[0],
                           &GetEa->EaName[0],
                           GetEa->EaNameLength );

            //
            //  Upcase the name in the buffer.
            //

            OutputEaName.MaximumLength = OutputEaName.Length = GeaName.Length;
            OutputEaName.Buffer = NextFullEa->EaName;

            NtfsUpcaseEaName( &OutputEaName, &OutputEaName );

            NextFullEa->EaName[GetEa->EaNameLength] = 0;

        //
        //  Otherwise return the Ea we found back to the user.
        //

        } else {

            PFILE_FULL_EA_INFORMATION ThisEa;

            //
            //  Reference this ea.
            //

            ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( CurrentEas, FeaOffset );

            //
            //  Check if this Ea can fit in the user's buffer.
            //

            RawEaSize = RawUnpackedEaSize( ThisEa );

            if (RawEaSize > (UserBufferLength - PrevEaPadding)) {

                Overflow = TRUE;
                break;
            }

            //
            //  Copy this ea to the user's buffer.
            //

            RtlCopyMemory( NextFullEa,
                           ThisEa,
                           RawEaSize);

            NextFullEa->NextEntryOffset = 0;
        }

        //
        //  Compute the next offset in the user's buffer.
        //

        Offset += (RawEaSize + PrevEaPadding);

        //
        //  If we were to return a single entry then break out of our loop
        //  now
        //

        if (ReturnSingleEntry) {

            break;
        }

        //
        //  If we have a new Ea entry, go back and update the offset field
        //  of the previous Ea entry.
        //

        if (LastFullEa != NULL) {

            LastFullEa->NextEntryOffset = PtrOffset( LastFullEa, NextFullEa );
        }

        //
        //  If we've exhausted the entries in the Get Ea list, then we are
        //  done.
        //

        if (GetEa->NextEntryOffset == 0) {

            break;
        }

        //
        //  Remember this as the previous ea value.  Also update the buffer
        //  length values and the buffer offset values.
        //

        LastFullEa = NextFullEa;
        UserBufferLength -= (RawEaSize + PrevEaPadding);

        //
        //  Now remember the padding bytes needed for this call.
        //

        PrevEaPadding = LongAlign( RawEaSize ) - RawEaSize;
    }

    //
    //  If the Ea information won't fit in the user's buffer, then return
    //  an overflow status.
    //

    if (Overflow) {

        Iosb.Information = 0;
        Iosb.Status = STATUS_BUFFER_OVERFLOW;

    //
    //  Otherwise return the length of the data returned.
    //

    } else {

        //
        //  Return the length of the buffer filled and a success
        //  status.
        //

        Iosb.Information = Offset;
        Iosb.Status = STATUS_SUCCESS;
    }

    DebugTrace( 0, Dbg, ("Status        -> %08lx\n", Iosb.Status) );
    DebugTrace( 0, Dbg, ("Information   -> %08lx\n", Iosb.Information) );
    DebugTrace( -1, Dbg, ("NtfsQueryEaUserEaList:  Exit\n") );

    return Iosb;
}


//
//  Local support routine
//

IO_STATUS_BLOCK
NtfsQueryEaIndexSpecified (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN ULONG UserEaIndex,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs given an ea index

Arguments:

    Ccb - This is the Ccb for the caller.

    CurrentEas - This is a pointer to the current Eas for the file.

    EaInformation - This is a pointer to an Ea information attribute.

    EaBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    UserEaIndex - This is the Index for the first ea to return.  The value
        1 indicates the first ea of the file.

    ReturnSingleEntry - Indicates if we are to return a single entry or not

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    ULONG i;
    ULONG Offset;
    PFILE_FULL_EA_INFORMATION ThisEa;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaIndexSpecified:  Entered\n") );

    i = 1;
    Offset = 0;
    ThisEa = NULL;

    //
    //  If the index value is zero, there are no Eas to return.
    //

    if (UserEaIndex == 0
        || EaInformation->UnpackedEaSize == 0) {

        DebugTrace( -1, Dbg, ("NtfsQueryEaIndexSpecified: Non-existant entry\n") );

        Iosb.Information = 0;
        Iosb.Status = STATUS_NONEXISTENT_EA_ENTRY;

        return Iosb;
    }

    //
    //  Walk through the CurrentEas until we find the starting Ea offset.
    //

    while (i < UserEaIndex
           && Offset < EaInformation->UnpackedEaSize) {

        ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( CurrentEas, Offset );

        Offset += AlignedUnpackedEaSize( ThisEa );

        i += 1;
    }

    if (Offset >= EaInformation->UnpackedEaSize) {

        //
        //  If we just passed the last Ea, we will return STATUS_NO_MORE_EAS.
        //  This is for the caller who may be enumerating the Eas.
        //

        if (i == UserEaIndex) {

            Iosb.Status = STATUS_NO_MORE_EAS;

        //
        //  Otherwise we report that this is a bad ea index.
        //

        } else {

            Iosb.Status = STATUS_NONEXISTENT_EA_ENTRY;
        }

        DebugTrace( -1, Dbg, ("NtfsQueryEaIndexSpecified -> %08lx\n", Iosb.Status) );
        return Iosb;
    }

    //
    //  We now have the offset of the first Ea to return to the user.
    //  We simply call our EaSimpleScan routine to do the actual work.
    //

    Iosb = NtfsQueryEaSimpleScan( Ccb,
                                  CurrentEas,
                                  EaInformation,
                                  EaBuffer,
                                  UserBufferLength,
                                  ReturnSingleEntry,
                                  Offset );

    DebugTrace( -1, Dbg, ("NtfsQueryEaIndexSpecified:  Exit\n") );

    return Iosb;
}


//
//  Local support routine
//

IO_STATUS_BLOCK
NtfsQueryEaSimpleScan (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN BOOLEAN ReturnSingleEntry,
    IN ULONG StartingOffset
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs starting from a given
    offset within the Ea attribute.

Arguments:

    Ccb - This is the Ccb for the caller.

    CurrentEas - This is a pointer to the current Eas for the file.

    EaInformation - This is a pointer to an Ea information attribute.

    EaBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    ReturnSingleEntry - Indicates if we are to return a single entry or not

    StartingOffset - Supplies the offset of the first Ea to return

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    PFILE_FULL_EA_INFORMATION LastFullEa;
    PFILE_FULL_EA_INFORMATION NextFullEa;
    PFILE_FULL_EA_INFORMATION ThisEa;

    BOOLEAN BufferOverflow = FALSE;

    ULONG BufferOffset;
    ULONG PrevEaPadding;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaSimpleScan:  Entered\n") );

    //
    //  Initialize our Ea pointers and the offsets into the user buffer
    //  and our Ea buffer.
    //

    LastFullEa = NULL;
    BufferOffset = 0;
    PrevEaPadding = 0;

    //
    //  Loop until the Ea offset is beyond the valid range of Eas.
    //

    while (StartingOffset < EaInformation->UnpackedEaSize) {

        ULONG EaSize;

        //
        //  Reference the next EA to return.
        //

        ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( CurrentEas, StartingOffset);

        //
        //  If the size of this Ea is greater than the remaining buffer size,
        //  we exit the loop.  We need to remember to include any padding bytes
        //  from the previous Eas.
        //

        EaSize = RawUnpackedEaSize( ThisEa );

        if ((EaSize + PrevEaPadding) > UserBufferLength) {

            BufferOverflow = TRUE;
            break;
        }

        //
        //  Copy the Ea into the user's buffer.
        //

        BufferOffset += PrevEaPadding;

        NextFullEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( EaBuffer, BufferOffset );

        RtlCopyMemory( NextFullEa, ThisEa, EaSize );

        //
        //  Move to the next Ea.
        //

        LastFullEa = NextFullEa;
        UserBufferLength -= (EaSize + PrevEaPadding);
        BufferOffset += EaSize;

        StartingOffset += LongAlign( EaSize );

        //
        //  Remember the padding needed for this entry.
        //

        PrevEaPadding = LongAlign( EaSize ) - EaSize;

        //
        //  If the user only wanted one entry, exit now.
        //

        if (ReturnSingleEntry) {

            break;
        }
    }

    //
    //  If we didn't find any entries, it could be because there were no
    //  more to find or that we ran out of buffer space.
    //

    if (LastFullEa == NULL) {

        Iosb.Information = 0;

        //
        //  We were not able to return a single ea entry, now we need to find
        //  out if it is because we didn't have an entry to return or the
        //  buffer is too small.  If the Offset variable is less than
        //  the size of the Ea attribute, then the user buffer is too small.
        //

        if (EaInformation->UnpackedEaSize == 0) {

            Iosb.Status = STATUS_NO_EAS_ON_FILE;

        } else if (StartingOffset >= EaInformation->UnpackedEaSize) {

            Iosb.Status = STATUS_NO_MORE_EAS;

        } else {

            Iosb.Status = STATUS_BUFFER_TOO_SMALL;
        }

    //
    //  Otherwise we have returned some Ea's.  Update the Iosb to return.
    //

    } else {

        //
        //  Update the Ccb to show where to start the next search.
        //

        Ccb->NextEaOffset = StartingOffset;

        //
        //  Zero the next entry field of the last Ea.
        //

        LastFullEa->NextEntryOffset = 0;

        //
        //  Now update the Iosb.
        //

        Iosb.Information = BufferOffset;

        //
        //  If there are more to return, report the buffer was too small.
        //  Otherwise return STATUS_SUCCESS.
        //

        if (BufferOverflow) {

            Iosb.Status = STATUS_BUFFER_OVERFLOW;

        } else {

            Iosb.Status = STATUS_SUCCESS;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsQueryEaSimpleScan:  Exit\n") );

    return Iosb;
}


//
//  Local support routine
//

BOOLEAN
NtfsIsDuplicateGeaName (
    IN PFILE_GET_EA_INFORMATION GetEa,
    IN PFILE_GET_EA_INFORMATION UserGeaBuffer
    )

/*++

Routine Description:

    This routine walks through a list of Gea names to find a duplicate name.
    'GetEa' is an actual position in the list, 'UserGeaBuffer' is the beginning
    of the list.  We are only interested in
    previous matching ea names, as the ea information for that ea name
    would have been returned with the previous instance.

Arguments:

    GetEa - Supplies the Ea name structure for the ea name to match.

    UserGeaBuffer - Supplies a pointer to the user buffer with the list
        of ea names to search for.

Return Value:

    BOOLEAN - TRUE if a previous match is found, FALSE otherwise.

--*/

{
    BOOLEAN DuplicateFound;
    STRING GeaString;

    PFILE_GET_EA_INFORMATION ThisGetEa;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsDuplicateGeaName:  Entered\n") );

    //
    //  Set up the string structure.
    //

    GeaString.MaximumLength = GeaString.Length = GetEa->EaNameLength;
    GeaString.Buffer = &GetEa->EaName[0];

    DuplicateFound = FALSE;

    ThisGetEa = UserGeaBuffer;

    //
    //  We loop until we reach the given Gea or a match is found.
    //

    while (ThisGetEa != GetEa) {

        STRING ThisGea;

        //
        //  Create a string structure for the current Gea.
        //

        ThisGea.MaximumLength = ThisGea.Length = ThisGetEa->EaNameLength;
        ThisGea.Buffer = &ThisGetEa->EaName[0];

        //
        //  Check if the Gea names match, exit if they do.
        //

        if (NtfsAreEaNamesEqual( &GeaString,
                                 &ThisGea )) {

                DuplicateFound = TRUE;
                break;
        }

        //
        //  Move to the next Gea entry.
        //

        ThisGetEa = (PFILE_GET_EA_INFORMATION) Add2Ptr( ThisGetEa,
                                                        ThisGetEa->NextEntryOffset );
    }

    DebugTrace( -1, Dbg, ("NtfsIsDuplicateGeaName:  Exit\n") );

    return DuplicateFound;
}


//
//  Local support routine
//

NTSTATUS
NtfsBuildEaList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION UserEaList,
    OUT PULONG_PTR ErrorOffset
    )

/*++

Routine Description:

    This routine is called to build an up-to-date Ea list based on the
    given existing Ea list and the user-specified Ea list.

Arguments:

    Vcb - The Vcb for the volume.

    EaListHeader - This is the Ea list to modify.

    UserEaList - This is the user specified Ea list.

    ErrorOffset - Supplies the address to store the offset of an invalid
        Ea in the user's list.

Return Value:

    NTSTATUS - The result of modifying the Ea list.

--*/

{
    NTSTATUS Status;
    BOOLEAN MoreEas;
    ULONG Offset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBuildEaList:  Entered\n") );

    Status = STATUS_SUCCESS;
    Offset = 0;

    //
    //  Now for each full ea in the input user buffer we do the specified operation
    //  on the ea.
    //

    do {

        STRING EaName;
        ULONG EaOffset;

        PFILE_FULL_EA_INFORMATION ThisEa;

        ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( UserEaList, Offset );

        //
        //  Create a string out of the name in the user's Ea.
        //

        EaName.MaximumLength = EaName.Length = ThisEa->EaNameLength;
        EaName.Buffer = &ThisEa->EaName[0];

        //
        //  If the Ea isn't valid, return error offset to caller.
        //

        if (!NtfsIsEaNameValid( EaName )) {

            *ErrorOffset = Offset;
            Status = STATUS_INVALID_EA_NAME;

            break;
        }

        //
        //  Verify that no invalid ea flags are set.
        //

        if (ThisEa->Flags != 0
            && ThisEa->Flags != FILE_NEED_EA) {

            *ErrorOffset = Offset;
            Status = STATUS_INVALID_EA_NAME;

            break;
        }

        //
        //  If we can find the name in the Ea set, we remove it.
        //

        if (NtfsLocateEaByName( EaListHeader->FullEa,
                                EaListHeader->UnpackedEaSize,
                                &EaName,
                                &EaOffset )) {

            NtfsDeleteEa( IrpContext,
                          EaListHeader,
                          EaOffset );
        }

        //
        //  If the user specified a non-zero value length, we add this
        //  ea to the in memory Ea list.
        //

        if (ThisEa->EaValueLength != 0) {

            NtfsAppendEa( IrpContext,
                          EaListHeader,
                          ThisEa,
                          Vcb );
        }

        //
        //  Move to the next Ea in the list.
        //

        Offset += AlignedUnpackedEaSize( ThisEa );

        MoreEas = (BOOLEAN) (ThisEa->NextEntryOffset != 0);

    } while( MoreEas );

    //
    //  First we check that the packed size of the Eas does not exceed the
    //  maximum value.  We have to reserve the 4 bytes for the OS/2 list
    //  header.
    //

    if (NT_SUCCESS( Status )) {

        if (EaListHeader->PackedEaSize > (MAXIMUM_EA_SIZE - 4)) {

            Status = STATUS_EA_TOO_LARGE;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsBuildEaList:  Exit\n") );

    return Status;
}


//
//  Local support routine
//

VOID
NtfsReplaceFileEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PEA_LIST_HEADER EaList
    )

/*++

Routine Description:

    This routine will replace an existing Ea list with a new Ea list.  It
    correctly handles the case where there was no previous Eas and where we
    are removing all of the previous EAs.

Arguments:

    Fcb - Fcb for the file with the EAs

    EaList - This contains the modified Ea list.

Return Value:

    None.

--*/

{
    EA_INFORMATION ThisEaInformation;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PSCB EaScb;
    BOOLEAN EaChange = FALSE;
    BOOLEAN EaScbAcquired = FALSE;


    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReplaceFileEas:  Entered\n") );

    ThisEaInformation.PackedEaSize = (USHORT) EaList->PackedEaSize;
    ThisEaInformation.UnpackedEaSize = EaList->UnpackedEaSize;
    ThisEaInformation.NeedEaCount = EaList->NeedEaCount;

    NtfsInitializeAttributeContext( &Context );

    //
    //  First we handle $EA_INFORMATION and then the $EA attribute in the
    //  same fashion.
    //

    try {

        //
        //  Lookup the $EA_INFORMATION attribute.  If it does not exist then we
        //  will need to create one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $EA_INFORMATION,
                                        &Context )) {

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Create a new $EA_INFORMATION attribute\n") );

                NtfsCleanupAttributeContext( IrpContext, &Context );
                NtfsInitializeAttributeContext( &Context );

                NtfsCreateAttributeWithValue( IrpContext,
                                              Fcb,
                                              $EA_INFORMATION,
                                              NULL,                          // attribute name
                                              &ThisEaInformation,
                                              sizeof(EA_INFORMATION),
                                              0,                             // attribute flags
                                              NULL,                          // where indexed
                                              TRUE,                          // logit
                                              &Context );

                EaChange = TRUE;
            }

        } else {

            //
            //  If it exists, and we are writing an EA, then we have to update it.
            //

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Change an existing $EA_INFORMATION attribute\n") );

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          0,                                 // Value offset
                                          &ThisEaInformation,
                                          sizeof(EA_INFORMATION),
                                          TRUE,                              // SetNewLength
                                          TRUE,                              // LogNonResidentToo
                                          FALSE,                             // CreateSectionUnderway
                                          FALSE,
                                          &Context );

            //
            //  If it exists, but our new length is zero, then delete it.
            //

            } else {

                DebugTrace( 0, Dbg, ("Delete existing $EA_INFORMATION attribute\n") );

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &Context );
            }

            EaChange = TRUE;
        }

        //
        //  Now we will cleanup and reinitialize the context for reuse.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsInitializeAttributeContext( &Context );

        //
        //  Lookup the $EA attribute.  If it does not exist then we will need to create
        //  one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $EA,
                                        &Context )) {

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Create a new $EA attribute\n") );

                NtfsCleanupAttributeContext( IrpContext, &Context );
                NtfsInitializeAttributeContext( &Context );

                NtfsCreateAttributeWithValue( IrpContext,
                                              Fcb,
                                              $EA,
                                              NULL,                          // attribute name
                                              EaList->FullEa,
                                              EaList->UnpackedEaSize,
                                              0,                             // attribute flags
                                              NULL,                          // where indexed
                                              TRUE,                          // logit
                                              &Context );
                EaChange = TRUE;
            }

        } else {

            //
            //  If it exists, and we are writing an EA, then we have to update it.
            //

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Change an existing $EA attribute\n") );

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          0,                                 // Value offset
                                          EaList->FullEa,
                                          EaList->UnpackedEaSize,
                                          TRUE,                              // SetNewLength
                                          TRUE,                              // LogNonResidentToo
                                          FALSE,                             // CreateSectionUnderway
                                          FALSE,
                                          &Context );

            //
            //  If it exists, but our new length is zero, then delete it.
            //

            } else {

                DebugTrace( 0, Dbg, ("Delete existing $EA attribute\n") );

                //
                //  If the stream is non-resident then get hold of an
                //  Scb for this.
                //

                if (!NtfsIsAttributeResident( NtfsFoundAttribute( &Context ))) {

                    EaScb = NtfsCreateScb( IrpContext,
                                           Fcb,
                                           $EA,
                                           &NtfsEmptyString,
                                           FALSE,
                                           NULL );

                    NtfsAcquireExclusiveScb( IrpContext, EaScb );
                    EaScbAcquired = TRUE;
                }

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &Context );

                //
                //  If we have acquired the Scb then knock the sizes back
                //  to zero.
                //

                if (EaScbAcquired) {

                    EaScb->Header.FileSize =
                    EaScb->Header.ValidDataLength =
                    EaScb->Header.AllocationSize = Li0;

                    SetFlag( EaScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                }
            }
            EaChange = TRUE;
        }

        //
        //  Increment the Modification count for the Eas.
        //

        Fcb->EaModificationCount++;

        if (EaList->UnpackedEaSize == 0) {

            Fcb->Info.PackedEaSize = 0;

        } else {

            Fcb->Info.PackedEaSize = (USHORT) EaList->PackedEaSize;
        }

        //
        //  Post a USN journal record for this change
        //

        if (EaChange) {

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_EA_CHANGE );
        }

        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_EA_SIZE );

    } finally {

        DebugUnwind( NtfsReplaceFileEas );

        if (EaScbAcquired) {

            NtfsReleaseScb( IrpContext, EaScb );
        }

        //
        //  Cleanup our attribute enumeration context
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsReplaceFileEas:  Exit\n") );

    return;
}


BOOLEAN
NtfsIsEaNameValid (
    IN STRING Name
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal Ea names.

    For Ea names, the following rules apply:

    A. An Ea name may not contain any of the following characters:

       0x0000 - 0x001F  \ / : * ? " < > | , + = [ ] ;

Arguments:

    Name - Supllies the name to check.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/

{
    ULONG Index;

    UCHAR Char;

    PAGED_CODE();

    //
    //  Empty names are not valid.
    //

    if ( Name.Length == 0 ) { return FALSE; }

    //
    //  At this point we should only have a single name, which can't have
    //  more than 254 characters
    //

    if ( Name.Length > 254 ) { return FALSE; }

    for ( Index = 0; Index < (ULONG)Name.Length; Index += 1 ) {

        Char = Name.Buffer[ Index ];

        //
        //  Skip over and Dbcs chacters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            ASSERT( Index != (ULONG)(Name.Length - 1) );

            Index += 1;

            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalFat(Char, FALSE) ) {

            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fieldoff.c ===
#include "NtfsProc.h"
#include <stdio.h>

#define doit(a,b) { printf("%s %04lx %4lx %s\n", #a, FIELD_OFFSET(a,b), sizeof(d.b), #b); }

void __cdecl main()
{
    printf("<Record>  <offset>  <size>  <field>\n\n");
    {
        NTFS_DATA d;
        doit( NTFS_DATA, NodeTypeCode );
        doit( NTFS_DATA, NodeByteSize );
        doit( NTFS_DATA, DriverObject );
        doit( NTFS_DATA, VcbQueue );
        doit( NTFS_DATA, Resource );
        doit( NTFS_DATA, AsyncCloseList );
        doit( NTFS_DATA, AsyncCloseActive );
        doit( NTFS_DATA, ReduceDelayedClose );
        doit( NTFS_DATA, AsyncCloseCount );
        doit( NTFS_DATA, OurProcess );
        doit( NTFS_DATA, DelayedCloseCount );
        doit( NTFS_DATA, DelayedCloseList );
        doit( NTFS_DATA, NtfsCloseItem );
        doit( NTFS_DATA, FreeFcbTableSize );
        doit( NTFS_DATA, UnusedUchar );
        doit( NTFS_DATA, FreeFcbTableArray );
        doit( NTFS_DATA, FreeEresourceSize );
        doit( NTFS_DATA, FreeEresourceTotal );
        doit( NTFS_DATA, FreeEresourceMiss );
        doit( NTFS_DATA, FreeEresourceArray );
        doit( NTFS_DATA, CacheManagerCallbacks );
        doit( NTFS_DATA, CacheManagerVolumeCallbacks );
        doit( NTFS_DATA, VolumeCheckpointDpc );
        doit( NTFS_DATA, VolumeCheckpointTimer );
        doit( NTFS_DATA, VolumeCheckpointItem );
        doit( NTFS_DATA, Flags );
        doit( NTFS_DATA, ReadAheadThreads );
    }
    printf("\n");
    {
        RECORD_ALLOCATION_CONTEXT d;
        doit( RECORD_ALLOCATION_CONTEXT, DataScb             );
        doit( RECORD_ALLOCATION_CONTEXT, BitmapScb           );
        doit( RECORD_ALLOCATION_CONTEXT, CurrentBitmapSize   );
        doit( RECORD_ALLOCATION_CONTEXT, NumberOfFreeBits    );
        doit( RECORD_ALLOCATION_CONTEXT, IndexOfLastSetBit   );
        doit( RECORD_ALLOCATION_CONTEXT, BytesPerRecord      );
        doit( RECORD_ALLOCATION_CONTEXT, ExtendGranularity   );
        doit( RECORD_ALLOCATION_CONTEXT, TruncateGranularity );
    }
    printf("\n");
    {
        RESTART_POINTERS d;
        doit( RESTART_POINTERS, Resource                     );
        doit( RESTART_POINTERS, Table                        );
        doit( RESTART_POINTERS, SpinLock                     );
        doit( RESTART_POINTERS, ResourceInitialized          );
        doit( RESTART_POINTERS, Unused                       );
    }
    printf("\n");
    {
        NTFS_MCB_ENTRY d;
        doit( NTFS_MCB_ENTRY, LruLinks                       );
        doit( NTFS_MCB_ENTRY, NtfsMcb                        );
        doit( NTFS_MCB_ENTRY, NtfsMcbArray                   );
        doit( NTFS_MCB_ENTRY, LargeMcb                       );
    }
    printf("\n");
    {
        NTFS_MCB_ARRAY d;
        doit( NTFS_MCB_ARRAY, StartingVcn                    );
        doit( NTFS_MCB_ARRAY, EndingVcn                      );
        doit( NTFS_MCB_ARRAY, NtfsMcbEntry                   );
        doit( NTFS_MCB_ARRAY, Unused                         );
    }
    printf("\n");
    {
        NTFS_MCB d;
        doit( NTFS_MCB, FcbHeader             );
        doit( NTFS_MCB, PoolType              );
        doit( NTFS_MCB, NtfsMcbArraySizeInUse );
        doit( NTFS_MCB, NtfsMcbArraySize      );
        doit( NTFS_MCB, NtfsMcbArray          );
        doit( NTFS_MCB, FastMutex             );
    }
    printf("\n");
    {
        DEALLOCATED_CLUSTERS d;
        doit( DEALLOCATED_CLUSTERS, Mcb );
        doit( DEALLOCATED_CLUSTERS, Lsn );
        doit( DEALLOCATED_CLUSTERS, ClusterCount );
    }
    printf("\n");
    {
        VCB d;
        doit( VCB, NodeTypeCode );
        doit( VCB, NodeByteSize );
        doit( VCB, TargetDeviceObject );
        doit( VCB, VcbLinks );
        doit( VCB, MftScb );
        doit( VCB, Mft2Scb );
        doit( VCB, LogFileScb );
        doit( VCB, VolumeDasdScb );
        doit( VCB, RootIndexScb );
        doit( VCB, BitmapScb );
        doit( VCB, AttributeDefTableScb );
        doit( VCB, UpcaseTableScb );
        doit( VCB, BadClusterFileScb );
        doit( VCB, QuotaTableScb );
        doit( VCB, MftBitmapScb );
        doit( VCB, LogFileObject );
        doit( VCB, MftReserveFlags );
        doit( VCB, MftDefragState );
        doit( VCB, VcbState );
        doit( VCB, Statistics );
        doit( VCB, CleanupCount );
        doit( VCB, CloseCount );
        doit( VCB, ReadOnlyCloseCount );
        doit( VCB, SystemFileCloseCount );
        doit( VCB, TotalClusters );
        doit( VCB, FreeClusters );
        doit( VCB, DeallocatedClusters );
        doit( VCB, TotalReserved );
        doit( VCB, FreeSpaceMcb );
        doit( VCB, FreeSpaceMcbMaximumSize );
        doit( VCB, FreeSpaceMcbTrimToSize );
        doit( VCB, LastBitmapHint );
        doit( VCB, RootLcb );
        doit( VCB, Vpb );
        doit( VCB, BigEnoughToMove );
        doit( VCB, DefaultBlocksPerIndexAllocationBuffer );
        doit( VCB, DefaultBytesPerIndexAllocationBuffer );
        doit( VCB, BytesPerSector );
        doit( VCB, BytesPerCluster );
        doit( VCB, BytesPerFileRecordSegment );
        doit( VCB, ClustersPerFileRecordSegment );
        doit( VCB, FileRecordsPerCluster );
        doit( VCB, MftStartLcn );
        doit( VCB, Mft2StartLcn );
        doit( VCB, NumberSectors );
        doit( VCB, VolumeSerialNumber );
        doit( VCB, VolumeCreationTime );
        doit( VCB, VolumeLastModificationTime );
        doit( VCB, VolumeLastChangeTime );
        doit( VCB, VolumeLastAccessTime );
        doit( VCB, ClusterMask );
        doit( VCB, InverseClusterMask );
        doit( VCB, ClusterShift );
        doit( VCB, MftShift );
        doit( VCB, MftToClusterShift );
        doit( VCB, ClustersPerPage );
        doit( VCB, MftReserved );
        doit( VCB, MftCushion );
        doit( VCB, FcbTableMutex );
        doit( VCB, FcbSecurityMutex );
        doit( VCB, CheckpointMutex );
        doit( VCB, CheckpointNotifyEvent );
        doit( VCB, CheckpointFlags );
        doit( VCB, AttributeFlagsMask );
        doit( VCB, UnusedUshort );
        doit( VCB, MftHoleGranularity );
        doit( VCB, MftFreeRecords );
        doit( VCB, MftHoleRecords );
        doit( VCB, LogHandle );
        doit( VCB, MftHoleMask );
        doit( VCB, MftHoleInverseMask );
        doit( VCB, MftClustersPerHole );
        doit( VCB, MftHoleClusterMask );
        doit( VCB, MftHoleClusterInverseMask );
        doit( VCB, LastRestartArea );
        doit( VCB, OpenAttributeTable );
        doit( VCB, LastBaseLsn );
        doit( VCB, TransactionTable );
        doit( VCB, EndOfLastCheckpoint );
        doit( VCB, DeviceName );
        doit( VCB, UpcaseTable );
        doit( VCB, UpcaseTableSize );
        doit( VCB, FcbTable );
        doit( VCB, DirNotifyList );
        doit( VCB, NotifySync );
        doit( VCB, FileObjectWithVcbLocked );
        doit( VCB, MftZoneStart );
        doit( VCB, MftZoneEnd );
        doit( VCB, PriorDeallocatedClusters );
        doit( VCB, ActiveDeallocatedClusters );
        doit( VCB, DeallocatedClusters1 );
        doit( VCB, DeallocatedClusters2 );
        doit( VCB, MftBitmapAllocationContext );
        doit( VCB, Resource );
        doit( VCB, AttributeDefinitions );
        doit( VCB, LogHeaderReservation );
        doit( VCB, Tunnel );
    }
    printf("\n");
    {
        VOLUME_DEVICE_OBJECT d;
        doit( VOLUME_DEVICE_OBJECT, DeviceObject );
        doit( VOLUME_DEVICE_OBJECT, PostedRequestCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueue );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueSpinLock );
        doit( VOLUME_DEVICE_OBJECT, Vcb );
    }
    printf("\n");
    {
        QUICK_INDEX d;
        doit( QUICK_INDEX, ChangeCount );
        doit( QUICK_INDEX, BufferOffset );
        doit( QUICK_INDEX, CapturedLsn );
        doit( QUICK_INDEX, IndexBlock );
    }
    printf("\n");
    {
        NAME_LINK d;
        doit( NAME_LINK, LinkName );
        doit( NAME_LINK, Links );
    }
    printf("\n");
    {
        LCB d;
        doit( LCB, NodeTypeCode );
        doit( LCB, NodeByteSize );
        doit( LCB, LcbState );

        doit( LCB, ScbLinks );
        doit( LCB, Scb );
        doit( LCB, CleanupCount );

        doit( LCB, FcbLinks );
        doit( LCB, Fcb );
        doit( LCB, ReferenceCount );

        doit( LCB, IgnoreCaseLink );
        doit( LCB, InfoFlags );

        doit( LCB, OverlayParentDirectory );
        doit( LCB, CcbQueue );

        doit( LCB, ExactCaseLink );
        doit( LCB, FileNameAttr );

        doit( LCB, QuickIndex );

        doit( LCB, OverlayFileNameLength );
        doit( LCB, OverlayFlags );
        doit( LCB, OverlayFileName );
    }
    printf("\n");
    {
        FCB d;
        doit( FCB, NodeTypeCode );
        doit( FCB, NodeByteSize );
        doit( FCB, FcbState );
        doit( FCB, FileReference );
        doit( FCB, CleanupCount );
        doit( FCB, CloseCount );
        doit( FCB, ReferenceCount );
        doit( FCB, FcbDenyDelete );
        doit( FCB, FcbDeleteFile );
        doit( FCB, BaseExclusiveCount );
        doit( FCB, EaModificationCount );
        doit( FCB, LcbQueue );
        doit( FCB, ScbQueue );
        doit( FCB, ExclusiveFcbLinks );
        doit( FCB, Vcb );
        doit( FCB, FcbMutex );
        doit( FCB, Resource );
        doit( FCB, PagingIoResource );
        doit( FCB, Info );
        doit( FCB, InfoFlags );
        doit( FCB, LinkCount );
        doit( FCB, TotalLinks );
        doit( FCB, CurrentLastAccess );
        doit( FCB, SharedSecurity );
        doit( FCB, QuotaControl );
        doit( FCB, UpdateLsn );
        doit( FCB, ClassId );
        doit( FCB, OwnerId );
        doit( FCB, DelayedCloseCount );
        doit( FCB, SecurityId );
        doit( FCB, Usn );
        doit( FCB, FcbUsnRecord );
    }
    printf("\n");
    {
        SCB_DATA d;
        doit( SCB_DATA, TotalReserved );
        doit( SCB_DATA, Oplock );
        doit( SCB_DATA, FileLock );
        doit( SCB_DATA, ReservedBitMap );
        doit( SCB_DATA, PadUlong );
    }
    printf("\n");
    {
        SCB_INDEX d;
        doit( SCB_INDEX, RecentlyDeallocatedQueue );
        doit( SCB_INDEX, LcbQueue );
        doit( SCB_INDEX, RecordAllocationContext );
        doit( SCB_INDEX, ExactCaseNode );
        doit( SCB_INDEX, IgnoreCaseNode );
        doit( SCB_INDEX, NormalizedName );
        doit( SCB_INDEX, ChangeCount );
        doit( SCB_INDEX, AttributeBeingIndexed );
        doit( SCB_INDEX, CollationRule );
        doit( SCB_INDEX, BytesPerIndexBuffer );
        doit( SCB_INDEX, BlocksPerIndexBuffer );
        doit( SCB_INDEX, IndexBlockByteShift );
        doit( SCB_INDEX, AllocationInitialized );
        doit( SCB_INDEX, PadUchar );
        doit( SCB_INDEX, IndexDepthHint );
        doit( SCB_INDEX, PadUshort );
    }
    printf("\n");
    {
        SCB_MFT d;
        doit( SCB_MFT, RecentlyDeallocatedQueue );
        doit( SCB_MFT, AddedClusters );
        doit( SCB_MFT, RemovedClusters );
        doit( SCB_MFT, FreeRecordChange );
        doit( SCB_MFT, HoleRecordChange );
        doit( SCB_MFT, ReservedIndex );
        doit( SCB_MFT, PadUlong );
    }
    printf("\n");
    {
        SCB_NONPAGED d;
        doit( SCB_NONPAGED, NodeTypeCode );
        doit( SCB_NONPAGED, NodeByteSize );
        doit( SCB_NONPAGED, OpenAttributeTableIndex );
        doit( SCB_NONPAGED, SegmentObject );
        doit( SCB_NONPAGED, Vcb );
    }
    printf("\n");
    {
        SCB d;
        doit( SCB, Header );

        doit( SCB, FcbLinks );
        doit( SCB, Fcb );
        doit( SCB, Vcb );
        doit( SCB, ScbState );
        doit( SCB, NonCachedCleanupCount );
        doit( SCB, CleanupCount );
        doit( SCB, CloseCount );
        doit( SCB, ShareAccess );
        doit( SCB, AttributeTypeCode );
        doit( SCB, AttributeName );
        doit( SCB, FileObject );
        doit( SCB, LazyWriteThread );
        doit( SCB, NonpagedScb );
        doit( SCB, Mcb );
        doit( SCB, McbStructs );
        doit( SCB, CompressionUnit );
        doit( SCB, AttributeFlags );
        doit( SCB, CompressionUnitShift );
        doit( SCB, PadUchar );
        doit( SCB, ValidDataToDisk );
        doit( SCB, TotalAllocated );
        doit( SCB, EofListHead );
        doit( SCB, Union );
        doit( SCB, ScbSnapshot );
        doit( SCB, PadUlong );
        doit( SCB, ScbType.Data );
        doit( SCB, ScbType.Index );
        doit( SCB, ScbType.Mft );
    }
    printf("\n");
    {
        SCB_SNAPSHOT d;
        doit( SCB_SNAPSHOT, SnapshotLinks );
        doit( SCB_SNAPSHOT, AllocationSize );
        doit( SCB_SNAPSHOT, FileSize );
        doit( SCB_SNAPSHOT, ValidDataLength );
        doit( SCB_SNAPSHOT, ValidDataToDisk );
        doit( SCB_SNAPSHOT, TotalAllocated );
        doit( SCB_SNAPSHOT, LowestModifiedVcn );
        doit( SCB_SNAPSHOT, HighestModifiedVcn );
        doit( SCB_SNAPSHOT, Scb );
        doit( SCB_SNAPSHOT, Unused );
    }
    printf("\n");
    {
        CCB d;
        doit( CCB, NodeTypeCode );
        doit( CCB, NodeByteSize );
        doit( CCB, Flags );

        doit( CCB, FullFileName );
        doit( CCB, LastFileNameOffset );
        doit( CCB, EaModificationCount );
        doit( CCB, NextEaOffset );

        doit( CCB, LcbLinks );
        doit( CCB, Lcb );

        doit( CCB, TypeOfOpen );
        doit( CCB, PadBytes );

        doit( CCB, IndexContext );

        doit( CCB, QueryLength );
        doit( CCB, QueryBuffer );
        doit( CCB, IndexEntryLength );
        doit( CCB, IndexEntry );

        doit( CCB, FcbToAcquire.LongValue );
        doit( CCB, FcbToAcquire.FileReference );
    }
    printf("\n");
    {
        CCB_DATA d;
        doit( CCB_DATA, Opaque );
    }
    printf("\n");
    {
        FCB_DATA d;
        doit( FCB_DATA, Fcb );
        doit( FCB_DATA, Scb );
        doit( FCB_DATA, Ccb );
        doit( FCB_DATA, Lcb );
        doit( FCB_DATA, FileName );
    }
    printf("\n");
    {
        FCB_INDEX d;
        doit( FCB_INDEX, Fcb );
        doit( FCB_INDEX, Scb );
        doit( FCB_INDEX, Ccb );
        doit( FCB_INDEX, Lcb );
        doit( FCB_INDEX, FileName );
    }
    printf("\n");
    {
        IRP_CONTEXT d;
        doit( IRP_CONTEXT, NodeTypeCode );
        doit( IRP_CONTEXT, NodeByteSize );
        doit( IRP_CONTEXT, Flags );
        doit( IRP_CONTEXT, State );
        doit( IRP_CONTEXT, ExceptionStatus );
        doit( IRP_CONTEXT, TransactionId );
        doit( IRP_CONTEXT, MajorFunction );
        doit( IRP_CONTEXT, MinorFunction );
        doit( IRP_CONTEXT, SharedScbSize );
        doit( IRP_CONTEXT, SharedScb );
        doit( IRP_CONTEXT, CleanupStructure );
        doit( IRP_CONTEXT, Vcb );
        doit( IRP_CONTEXT, OriginatingIrp );
        doit( IRP_CONTEXT, TopLevelIrpContext );
        doit( IRP_CONTEXT, TopLevelContext );
        doit( IRP_CONTEXT, ExclusiveFcbList );
        doit( IRP_CONTEXT, RecentlyDeallocatedQueue );
        doit( IRP_CONTEXT, DeallocatedClusters );
        doit( IRP_CONTEXT, LastRestartArea );
        doit( IRP_CONTEXT, FreeClusterChange );
        doit( IRP_CONTEXT, Union.NtfsIoContext );
        doit( IRP_CONTEXT, Union.AuxiliaryBuffer );
        doit( IRP_CONTEXT, Union.SubjectContext );
        doit( IRP_CONTEXT, Union.OplockCleanup );
        doit( IRP_CONTEXT, Union.PostSpecialCallout );
        doit( IRP_CONTEXT, CheckNewLength );
        doit( IRP_CONTEXT, Usn );
        doit( IRP_CONTEXT, SourceInfo );
        doit( IRP_CONTEXT, ScbSnapshot );
        doit( IRP_CONTEXT, EncryptionFileDirFlags );
        doit( IRP_CONTEXT, EfsCreateContext );
        doit( IRP_CONTEXT, CacheCount );
        doit( IRP_CONTEXT, FileRecordCache );
        doit( IRP_CONTEXT, WorkQueueItem );
    }
    printf("\n");
    {
        TOP_LEVEL_CONTEXT d;
        doit( TOP_LEVEL_CONTEXT, TopLevelRequest );
        doit( TOP_LEVEL_CONTEXT, ValidSavedTopLevel );
        doit( TOP_LEVEL_CONTEXT, OverflowReadThread );
        doit( TOP_LEVEL_CONTEXT, Ntfs );
        doit( TOP_LEVEL_CONTEXT, VboBeingHotFixed );
        doit( TOP_LEVEL_CONTEXT, ScbBeingHotFixed );
        doit( TOP_LEVEL_CONTEXT, SavedTopLevelIrp );
        doit( TOP_LEVEL_CONTEXT, TopLevelIrpContext );
    }
    printf("\n");
    {
        FOUND_ATTRIBUTE d;
        doit( FOUND_ATTRIBUTE, MftFileOffset );
        doit( FOUND_ATTRIBUTE, Attribute );
        doit( FOUND_ATTRIBUTE, FileRecord );
        doit( FOUND_ATTRIBUTE, Bcb );
        doit( FOUND_ATTRIBUTE, AttributeDeleted );
    }
    printf("\n");
    {
        ATTRIBUTE_LIST_CONTEXT d;
        doit( ATTRIBUTE_LIST_CONTEXT, Entry );
        doit( ATTRIBUTE_LIST_CONTEXT, Bcb );
        doit( ATTRIBUTE_LIST_CONTEXT, AttributeList );
        doit( ATTRIBUTE_LIST_CONTEXT, FirstEntry );
        doit( ATTRIBUTE_LIST_CONTEXT, BeyondFinalEntry );
        doit( ATTRIBUTE_LIST_CONTEXT, NonresidentListBcb );
    }
    printf("\n");
    {
        ATTRIBUTE_ENUMERATION_CONTEXT d;
        doit( ATTRIBUTE_ENUMERATION_CONTEXT, FoundAttribute );
        doit( ATTRIBUTE_ENUMERATION_CONTEXT, AttributeList );
    }
    printf("\n");
    {
        INDEX_LOOKUP_STACK d;
        doit( INDEX_LOOKUP_STACK, Bcb );
        doit( INDEX_LOOKUP_STACK, StartOfBuffer );
        doit( INDEX_LOOKUP_STACK, IndexHeader );
        doit( INDEX_LOOKUP_STACK, IndexEntry );
        doit( INDEX_LOOKUP_STACK, IndexBlock );
        doit( INDEX_LOOKUP_STACK, CapturedLsn );
    }
    printf("\n");
    {
        INDEX_CONTEXT d;
        doit( INDEX_CONTEXT, AttributeContext );
        doit( INDEX_CONTEXT, Base );
        doit( INDEX_CONTEXT, Top );
        doit( INDEX_CONTEXT, LookupStack );
        doit( INDEX_CONTEXT, Current );
        doit( INDEX_CONTEXT, ScbChangeCount );
        doit( INDEX_CONTEXT, OldAttribute );
        doit( INDEX_CONTEXT, NumberEntries );
        doit( INDEX_CONTEXT, Flags );
        doit( INDEX_CONTEXT, AcquiredFcb );
        doit( INDEX_CONTEXT, Unused );
    }
    printf("\n");
    {
        NTFS_IO_CONTEXT d;
        doit( NTFS_IO_CONTEXT, IrpCount );
        doit( NTFS_IO_CONTEXT, MasterIrp );
        doit( NTFS_IO_CONTEXT, IrpSpFlags );
        doit( NTFS_IO_CONTEXT, AllocatedContext );
        doit( NTFS_IO_CONTEXT, PagingIo );
        doit( NTFS_IO_CONTEXT, Wait.Async.Resource );
        doit( NTFS_IO_CONTEXT, Wait.Async.ResourceThreadId );
        doit( NTFS_IO_CONTEXT, Wait.Async.RequestedByteCount );
        doit( NTFS_IO_CONTEXT, Wait.SyncEvent );
    }
    printf("\n");
    {
        IO_RUN d;
        doit( IO_RUN, StartingVbo );
        doit( IO_RUN, StartingLbo );
        doit( IO_RUN, BufferOffset );
        doit( IO_RUN, ByteCount );
        doit( IO_RUN, SavedIrp );
        doit( IO_RUN, Unused );
    }
    printf("\n");
    {
        NTFS_NAME_DESCRIPTOR d;
        doit( NTFS_NAME_DESCRIPTOR, FieldsPresent );
        doit( NTFS_NAME_DESCRIPTOR, FileName );
        doit( NTFS_NAME_DESCRIPTOR, AttributeType );
        doit( NTFS_NAME_DESCRIPTOR, AttributeName );
        doit( NTFS_NAME_DESCRIPTOR, VersionNumber );
    }
    printf("\n");
    {
        EA_LIST_HEADER d;
        doit( EA_LIST_HEADER, PackedEaSize );
        doit( EA_LIST_HEADER, NeedEaCount );
        doit( EA_LIST_HEADER, UnpackedEaSize );
        doit( EA_LIST_HEADER, BufferSize );
        doit( EA_LIST_HEADER, FullEa );
    }
    printf("\n");
    {
        DEALLOCATED_RECORDS d;
        doit( DEALLOCATED_RECORDS, ScbLinks );
        doit( DEALLOCATED_RECORDS, IrpContextLinks );
        doit( DEALLOCATED_RECORDS, Scb );
        doit( DEALLOCATED_RECORDS, NumberOfEntries );
        doit( DEALLOCATED_RECORDS, NextFreeEntry );
        doit( DEALLOCATED_RECORDS, Index );
    }
    printf("\n");
    {
        FCB_TABLE_ELEMENT d;
        doit( FCB_TABLE_ELEMENT, FileReference );
        doit( FCB_TABLE_ELEMENT, Fcb );
    }
    printf("\n");
    {
        SHARED_SECURITY d;
        doit( SHARED_SECURITY, ParentFcb );
        doit( SHARED_SECURITY, ReferenceCount );
        doit( SHARED_SECURITY, SecurityDescriptor );
    }
    printf("\n");
    {
        OLD_SCB_SNAPSHOT d;
        doit( OLD_SCB_SNAPSHOT, AllocationSize );
        doit( OLD_SCB_SNAPSHOT, FileSize );
        doit( OLD_SCB_SNAPSHOT, ValidDataLength );
        doit( OLD_SCB_SNAPSHOT, TotalAllocated );
        doit( OLD_SCB_SNAPSHOT, CompressionUnit );
        doit( OLD_SCB_SNAPSHOT, Resident );
        doit( OLD_SCB_SNAPSHOT, AttributeFlags );
    }
    printf("\n");
    {
        READ_AHEAD_THREAD d;
        doit( READ_AHEAD_THREAD, Links );
        doit( READ_AHEAD_THREAD, Thread );
    }
    printf("\n");
    {
        DEFRAG_MFT d;
        doit( DEFRAG_MFT, WorkQueueItem );
        doit( DEFRAG_MFT, Vcb );
        doit( DEFRAG_MFT, DeallocateWorkItem );
    }
    printf("\n");
    {
        NUKEM d;
        doit( NUKEM, Next );
        doit( NUKEM, RecordNumbers );
    }
    printf("\n");
    {
        NAME_PAIR d;
        doit( NAME_PAIR, Short );
        doit( NAME_PAIR, Long );
        doit( NAME_PAIR, ShortBuffer );
        doit( NAME_PAIR, LongBuffer );
    }
    printf("\n");
    {
        OPLOCK_CLEANUP d;
        doit( OPLOCK_CLEANUP, OriginalFileName );
        doit( OPLOCK_CLEANUP, FullFileName );
        doit( OPLOCK_CLEANUP, ExactCaseName );
        doit( OPLOCK_CLEANUP, FileObject );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\deviosup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Ntfs

Author:

    Brian Andrew    BrianAn
    Tom Miller      TomM

Revision History:

--*/

#include "NtfsProc.h"
#include <ntddft.h>
#include <ntddvol.h>

#ifdef NTFS_RWC_DEBUG
extern BOOLEAN NtfsBreakOnConflict;
#endif

//
//  Number of pages to allocate a mdl on the stack for
//

#define NTFS_MDL_TRANSFER_PAGES 0x10

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_DEVIOSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('DFtN')

//
//  We need a special test for success, whenever we are seeing if we should
//  hot fix, because the FT driver returns one of two success codes if a read or
//  write failed to only one of the members.
//

#define FT_SUCCESS(STS) (NT_SUCCESS(STS) &&                                 \
                         ((STS) != STATUS_FT_READ_RECOVERY_FROM_BACKUP) &&  \
                         ((STS) != STATUS_FT_WRITE_RECOVERY))


//
//  Boolean to control whether we output HotFix information to the debugger.
//

#if DBG
BOOLEAN NtfsHotFixTrace = FALSE;
#define HotFixTrace(X) {if (NtfsHotFixTrace) KdPrint(X);}
#else
#define HotFixTrace(X) {NOTHING;}
#endif

//
//  Boolean to indicate whether to break on a decompress error
//

#if (defined BRIANDBG || defined SYSCACHE_DEBUG)
BOOLEAN NtfsStopOnDecompressError = TRUE;
#else
BOOLEAN NtfsStopOnDecompressError = FALSE;
#endif

//
//  Macro to collect the Disk IO stats.
//

#define CollectDiskIoStats(VCB,SCB,FUNCTION,COUNT) {                                           \
    PFILESYSTEM_STATISTICS FsStats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()].Common; \
    ASSERT((SCB)->Fcb != NULL);                                                                \
    if (NtfsIsTypeCodeUserData( (SCB)->AttributeTypeCode ) &&                                  \
        !FlagOn( (SCB)->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {                              \
        if ((FUNCTION) == IRP_MJ_WRITE) {                                                      \
            FsStats->UserDiskWrites += (COUNT);                                                \
        } else {                                                                               \
            FsStats->UserDiskReads += (COUNT);                                                 \
        }                                                                                      \
    } else if ((SCB) != (VCB)->LogFileScb) {                                                   \
        if ((FUNCTION) == IRP_MJ_WRITE) {                                                      \
            FsStats->MetaDataDiskWrites += (COUNT);                                            \
        } else {                                                                               \
            FsStats->MetaDataDiskReads += (COUNT);                                             \
        }                                                                                      \
    }                                                                                          \
}

//
//  Define a context for holding the context the compression state
//  for buffers.
//

typedef struct COMPRESSION_CONTEXT {

    //
    //  Pointer to allocated compression buffer, and its length
    //

    PUCHAR CompressionBuffer;
    ULONG CompressionBufferLength;

    //
    //  Saved fields from originating Irp
    //

    PMDL SavedMdl;
    PVOID SavedUserBuffer;

    //
    //  System Buffer pointer and offset in the System (user's) buffer
    //

    PVOID SystemBuffer;
    ULONG SystemBufferOffset;

    //
    //  IoRuns array in use.  This array may be extended one time
    //  in NtfsPrepareBuffers.
    //

    PIO_RUN IoRuns;
    ULONG AllocatedRuns;

    //
    //  Workspace pointer, so that cleanup can occur in the caller.
    //

    PVOID WorkSpace;

    //
    //  Write acquires the Scb.
    //

    BOOLEAN ScbAcquired;
    BOOLEAN FinishBuffersNeeded;

    //
    //  If this field is TRUE, it means the data has been copied from the
    //  system buffer to the compression buffer, and further operations,
    //  like compression, should look to the compression buffer for their
    //  source data.
    //

    BOOLEAN DataTransformed;

} COMPRESSION_CONTEXT, *PCOMPRESSION_CONTEXT;

//
//  Local support routines
//

VOID
NtfsAllocateCompressionBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN OUT PULONG CompressionBufferLength
    );

VOID
NtfsDeallocateCompressionBuffer (
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN BOOLEAN Reinitialize
    );

LONG
NtfsCompressionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

ULONG
NtfsPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags,
    IN OUT PBOOLEAN Wait,
    OUT PULONG NumberRuns,
    OUT PCOMPRESSION_CONTEXT CompressionContext
    );

NTSTATUS
NtfsFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN ULONG StreamFlags
    );

VOID
NtfsMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns,
    IN UCHAR IrpSpFlags
    );

VOID
NtfsSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN LBO StartingLbo,
    IN ULONG ByteCount,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN UCHAR IrpSpFlags
    );

VOID
NtfsWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
NtfsMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    );

NTSTATUS
NtfsPagingFileNoAllocCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
NtfsSingleNonAlignedSync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PUCHAR Buffer,
    IN VBO Vbo,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    );

NTSTATUS
NtfsEncryptBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext
    );

VOID
NtfsFixDataError (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns,
    IN UCHAR IrpSpFlags
    );

VOID
NtfsPostHotFix(
    IN PIRP Irp,
    IN PLONGLONG BadVbo,
    IN LONGLONG BadLbo,
    IN ULONG ByteLength,
    IN BOOLEAN DelayIrpCompletion
    );

VOID
NtfsPerformHotFix (
    IN PIRP_CONTEXT IrpContext
    );

BOOLEAN
NtfsGetReservedBuffer (
    IN PFCB ThisFcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    IN UCHAR Need2
    );

BOOLEAN
NtfsFreeReservedBuffer (
    IN PVOID Buffer
    );

LONG
NtfsDefragExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN OUT PULONG DeletePendingFailureCountsLeft
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, NtfsReadFromPlex)
#pragma alloc_text(PAGE, NtfsDefragFile)

#endif


INLINE
BOOLEAN
NtfsZeroEndOfBuffer (
    IN PIRP Irp,
    IN PNTFS_IO_CONTEXT Context
    )

/*++

Routine Description:

    This routine Zeros the end of an async transfer. Because the transfer is done
    in sector sized chunks there will be garbage data from the end of file size to
    the sector boundary.  If there are any errors they will stored in the IoStatus field
    of the irp. We're going to allow out of resource errors in this path because its async.
    Only the synchronous paging paths have a guarantee of fwd. progress

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be zeroed

    Device - device which contains the vcb

    Context - io context which has the original operation bounds

Return Value:

    TRUE if successful

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_OBJECT DeviceObject;
    PVCB Vcb;
    PVOID SystemBuffer;
    ULONG RoundedTransfer;
    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * (NTFS_MDL_TRANSFER_PAGES + 1)];
    PMDL PartialMdl = (PMDL) Buffer;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    DeviceObject = IrpSp->DeviceObject;

    //
    //  Zero the difference between filesize and data read if necc. on reads
    //

    if ((IrpSp->MajorFunction == IRP_MJ_READ) &&
        (Context->Wait.Async.RequestedByteCount < IrpSp->Parameters.Read.Length)) {


        Vcb = &((PVOLUME_DEVICE_OBJECT) DeviceObject)->Vcb;

        ASSERT( Vcb->NodeTypeCode == NTFS_NTC_VCB );

        RoundedTransfer = BlockAlign( Context->Wait.Async.RequestedByteCount, (LONG)Vcb->BytesPerSector );

        if (RoundedTransfer > Context->Wait.Async.RequestedByteCount) {

            MmInitializeMdl( PartialMdl, NULL, NTFS_MDL_TRANSFER_PAGES * PAGE_SIZE );
            IoBuildPartialMdl( Irp->MdlAddress, PartialMdl, Add2Ptr( MmGetMdlBaseVa( Irp->MdlAddress ), MmGetMdlByteOffset( Irp->MdlAddress ) + Context->Wait.Async.RequestedByteCount ), RoundedTransfer - Context->Wait.Async.RequestedByteCount );

            //
            //  Now map that last page
            //

            SystemBuffer = MmGetSystemAddressForMdlSafe( PartialMdl, NormalPagePriority );
            if (SystemBuffer == NULL) {

                //
                //  We're an async path so we can return out of resources
                //

                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                return FALSE;
            }

#ifdef BENL_DBG
//            KdPrint(( "NTFS: Zero %x %x %x\n", MmGetMdlByteOffset( Irp->MdlAddress ), RoundedTransfer, Context->Wait.Async.RequestedByteCount ));
#endif

            //
            //  Zero the end of the transfer between expected size and read size. If the mdl is not
            //  on a page boundary this will all be offset by the MdlByteOffset
            //

            RtlZeroMemory( SystemBuffer, RoundedTransfer - Context->Wait.Async.RequestedByteCount );
            MmPrepareMdlForReuse( PartialMdl );
        }
    }

    return TRUE;
}


VOID
NtfsLockUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/

{
    PMDL Mdl = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    if (Irp->MdlAddress == NULL) {

        //
        // Allocate the Mdl, and Raise if we fail.
        //

        Mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, FALSE, Irp );

        if (Mdl == NULL) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, Irp->RequestorMode, Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            NTSTATUS Status;

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            Irp->MdlAddress = NULL;

            NtfsRaiseStatus( IrpContext,
                             FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }
    }

    //
    //  And return to our caller
    //

    return;
}


PVOID
NtfsMapUserBuffer (
    IN OUT PIRP Irp,
    IN MM_PAGE_PRIORITY Priority
    )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.

Arguments:

    Irp - Pointer to the Irp for the request.

    Priority - priority of the pages should be normalpagepriority unless its a metadata page
        in which case it can be high priority

Return Value:

    Mapped address

--*/

{
    PVOID SystemBuffer;

    //
    //  All paging i/o is high priority
    //  

    if (FlagOn( Irp->Flags, IRP_PAGING_IO )) {
        Priority = HighPagePriority;
    }

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;

    } else {

        //
        //  MM can return NULL if there are no system ptes.
        //

        if ((SystemBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, Priority )) == NULL) {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        return SystemBuffer;
    }
}


PVOID
NtfsMapUserBufferNoRaise (
    IN OUT PIRP Irp,
    IN MM_PAGE_PRIORITY Priority
    )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.

Arguments:

    Irp - Pointer to the Irp for the request.

    Priority - priority of the pages should be normalpagepriority unless its a metadata page
        in which case it can be high priority

Return Value:

    Mapped address

--*/

{
    //
    //  All paging i/o is high priority
    //  

    if (FlagOn( Irp->Flags, IRP_PAGING_IO )) {
        Priority = HighPagePriority;
    }

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;

    } else {

        //
        //  MM can return NULL if there are no system ptes.
        //

        return MmGetSystemAddressForMdlSafe( Irp->MdlAddress, Priority );
    }
}


VOID
NtfsFillIrpBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN ULONG ByteCount,
    IN ULONG Offset,
    IN UCHAR Pattern
    )
/*++

Routine Description:

    Fill a range in the buffer contained within an irp with a given pattern

Arguments:

    IrpContext - If present this an IrpContext put on the caller's stack
        to avoid having to allocate it from pool.

    Irp - Supplies the Irp being processed

    ByteCount - bytes to zero

    Offset - Offset within the irp's buffer to begin zeroing at

    Pattern - Pattern to fill the buffer with

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/
{
    PVOID SystemBuffer;
    PVCB Vcb = IrpContext->Vcb;
    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * 2];
    PMDL PartialMdl = (PMDL) Buffer;
    ULONG FillCount = ByteCount;

    //
    //  First attempt to directly map the user's buffer
    //

    SystemBuffer = NtfsMapUserBufferNoRaise( Irp, NormalPagePriority );

    //
    //  If there weren't pte in the system cache we'll use the reserved mapping instead
    //

    if (!SystemBuffer) {

        ASSERT( Irp->MdlAddress != NULL );

        MmInitializeMdl( PartialMdl, NULL, 2 * PAGE_SIZE );
        ExAcquireFastMutexUnsafe( &Vcb->ReservedMappingMutex );

        while (FillCount > 0) {

            IoBuildPartialMdl( Irp->MdlAddress, PartialMdl, Add2Ptr( MmGetMdlBaseVa( Irp->MdlAddress ), MmGetMdlByteOffset( Irp->MdlAddress ) + Offset + ByteCount - FillCount ), min( PAGE_SIZE, FillCount ));
            SystemBuffer = MmMapLockedPagesWithReservedMapping( Vcb->ReservedMapping,
                                                                RESERVE_POOL_TAG,
                                                                PartialMdl,
                                                                MmCached );

            ASSERT( SystemBuffer != NULL );

            try {
                RtlFillMemory( SystemBuffer, min( PAGE_SIZE, FillCount), Pattern );
            } except( EXCEPTION_EXECUTE_HANDLER ) {

                MmUnmapReservedMapping( Vcb->ReservedMapping, RESERVE_POOL_TAG, PartialMdl );
                MmPrepareMdlForReuse( PartialMdl );
                ExReleaseFastMutexUnsafe( &Vcb->ReservedMappingMutex );
                NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
            }

            if (FillCount >= PAGE_SIZE) {
                FillCount -= PAGE_SIZE;
            } else {
                FillCount = 0;
            }

            MmUnmapReservedMapping( Vcb->ReservedMapping, RESERVE_POOL_TAG, PartialMdl );
            MmPrepareMdlForReuse( PartialMdl );
            SystemBuffer = NULL;
        }

        ExReleaseFastMutexUnsafe( &Vcb->ReservedMappingMutex );

    } else {

        try {
            RtlFillMemory( Add2Ptr( SystemBuffer, Offset ), ByteCount, Pattern );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
             NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
        }
    }
}


NTSTATUS
NtfsVolumeDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB DasdScb,
    IN PCCB Ccb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io for Volume Dasd, as described
    in its parameters.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the DasdScb for the volume - we don't use vcb to find this
          since the vcb maybe dismounted

    Ccb - flag in it used to track whether to flush the volume

    StartingVbo - Starting offset within the file for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    The result of the Io operation.  STATUS_PENDING if this is an asynchronous
    open.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN AcquiredScb = FALSE;
    LOGICAL Dismounted;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVolumeDasdIo\n") );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Vcb           = %08lx\n", DasdScb->Vcb) );
    DebugTrace( 0, Dbg, ("StartingVbo   = %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );

    //
    //  Acquire the vcb if we'll flush based on the ccb flag - this test is
    //  safe since its off the ccb. Acquire the dasd handle shared otherwise
    //  use the appropriate object to capture the volume mount state
    //

    if (FlagOn( Ccb->Flags, CCB_FLAG_FLUSH_VOLUME_ON_IO )) {

        NtfsAcquireExclusiveVcb( IrpContext, DasdScb->Vcb, TRUE );
        Dismounted = !FlagOn( DasdScb->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );
        AcquiredVcb = TRUE;

    } else {

        if (!NtfsAcquireSharedScbWaitForEx( IrpContext, DasdScb )) {
            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, &DasdScb->Fcb->FileReference, DasdScb->Fcb );
        }
        Dismounted = FlagOn( DasdScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED );
        AcquiredScb = TRUE;
    }

    try {

        //
        //  If this is the handle that locked the volume its still ok to use
        //  even if dismounted. We don't necc. own the vcb but since the volume is def. dismounted
        //  at this point if we aren't the handle in question either the value will be null or not us
        //  so we're ok in either case
        //

        if (Dismounted &&
            (ClearFlag( (ULONG_PTR)DasdScb->Vcb->FileObjectWithVcbLocked, 1 ) != (ULONG_PTR)IrpSp->FileObject)) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Do delayed volume flush if required
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_FLUSH_VOLUME_ON_IO )) {

            ASSERT( IrpContext->ExceptionStatus == STATUS_SUCCESS );

            //
            //  No need to purge or lock the volume while flushing. NtfsFlushVolume
            //  will acquire the vcb exclusive
            //

            Status = NtfsFlushVolume( IrpContext, DasdScb->Vcb, TRUE, FALSE, TRUE, FALSE );

            //
            //  Ignore corruption errors while flushing
            //

            if (!NT_SUCCESS( Status ) && (Status != STATUS_FILE_CORRUPT_ERROR)) {

                //
                //  Report the error that there is an data section blocking the flush by returning
                //  sharing violation.  Otherwise Win32 callers will get INVALID_PARAMETER.
                //

                if (Status == STATUS_UNABLE_TO_DELETE_SECTION) {
                    Status = STATUS_SHARING_VIOLATION;
                }

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            ClearFlag( Ccb->Flags, CCB_FLAG_FLUSH_VOLUME_ON_IO );
        }

        //
        //  For nonbuffered I/O, we need the buffer locked in all
        //  cases.
        //
        //  This call may raise.  If this call succeeds and a subsequent
        //  condition is raised, the buffers are unlocked automatically
        //  by the I/O system when the request is completed, via the
        //  Irp->MdlAddress field.
        //

        NtfsLockUserBuffer( IrpContext,
                            Irp,
                            (IrpContext->MajorFunction == IRP_MJ_READ) ?
                            IoWriteAccess : IoReadAccess,
                            ByteCount );

        //
        //  Read or write the data
        //

        NtfsSingleAsync( IrpContext,
                         DasdScb->Vcb->TargetDeviceObject,
                         StartingVbo,
                         ByteCount,
                         Irp,
                         IrpContext->MajorFunction,
                         0 );

        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

            //
            //  We can get rid of the IrpContext now.
            //

            IrpContext->Union.NtfsIoContext = NULL;
            NtfsCleanupIrpContext( IrpContext, TRUE );

            DebugTrace( -1, Dbg, ("NtfsVolumeDasdIo -> STATUS_PENDING\n") );
            Status = STATUS_PENDING;
            leave;
        }

        //
        //  Wait for the result
        //

        NtfsWaitSync( IrpContext );

        Status = Irp->IoStatus.Status;

        DebugTrace( -1, Dbg, ("NtfsVolumeDasdIo -> %08lx\n", Irp->IoStatus.Status) );
    } finally {

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, DasdScb->Vcb );
        }
        if (AcquiredScb) {
            NtfsReleaseScb( IrpContext, DasdScb );
        }
    }

    return Status;
}



VOID
NtfsPagingFileIoWithNoAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine nevers blocks, and should only be used with the paging
    file since no completion processing is performed. This version does not allocate
    any memory so it guarantees fwd progress

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the file to act on.

    StartingVbo - Starting offset within the file for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * (NTFS_MDL_TRANSFER_PAGES + 1)];
    PMDL PartialMdl = (PMDL) Buffer;
    PMDL MasterMdl = Irp->MdlAddress;

    LONGLONG ThisClusterCount;
    ULONG ThisByteCount;
    LCN ThisLcn;
    LBO ThisLbo;
    VCN ThisVcn;

    PIO_STACK_LOCATION IrpSp;
    ULONG BufferOffset;

    PVCB Vcb = Scb->Vcb;

    ULONG ClusterOffset;
    VCN BeyondLastCluster;

    NTSTATUS Status;
    KEVENT Event;

    //
    //  Initialize some locals.
    //

    BufferOffset = 0;
    ClusterOffset = (ULONG) StartingVbo & Vcb->ClusterMask;
    BeyondLastCluster = LlClustersFromBytes( Vcb, StartingVbo + ByteCount );
    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );
    RtlZeroMemory( Buffer, sizeof( Buffer ) );
    ThisVcn = LlClustersFromBytesTruncate( Vcb, StartingVbo );

    while (ByteCount > 0) {

        //
        //  Try to lookup the next run
        //  Paging files reads/ writes should always be correct.  If
        //  we didn't find the allocation, something bad has happened.
        //

        if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                     ThisVcn,
                                     &ThisLcn,
                                     &ThisClusterCount,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL )) {;

            NtfsBugCheck( 0, 0, 0 );
        }

        //
        //  Adjust from Lcn to Lbo.
        //

        ThisLbo = LlBytesFromClusters( Vcb, ThisLcn ) + ClusterOffset;

        //
        // If next run is larger than we need, "ya get what you need".
        //

        ThisByteCount = BytesFromClusters( Vcb, (ULONG) ThisClusterCount ) - ClusterOffset;
        if (ThisVcn + ThisClusterCount >= BeyondLastCluster) {

            ThisByteCount = ByteCount;
        }

        //
        //  Now that we have properly bounded this piece of the
        //  transfer, it is time to read/write it NTFS_MDL_TRANSFER_PAGES pages at a time.
        //

        while (ThisByteCount > 0) {

            ULONG TransferSize = min( NTFS_MDL_TRANSFER_PAGES * PAGE_SIZE, ThisByteCount );

            //
            //  The partial mdl is on the stack
            //

            PartialMdl->Size = sizeof( Buffer );
            IoBuildPartialMdl( MasterMdl,
                               PartialMdl,
                               Add2Ptr( Irp->UserBuffer, BufferOffset ),
                               TransferSize );

            Irp->MdlAddress = PartialMdl;
            IrpSp = IoGetNextIrpStackLocation( Irp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = TransferSize;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;

            IoSetCompletionRoutine( Irp, NtfsPagingFileNoAllocCompletionRoutine, &Event, TRUE, TRUE, TRUE );

            Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );
            if (Status == STATUS_PENDING) {

                KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
                Status = Irp->IoStatus.Status;

            }

            ASSERT( Status != STATUS_INSUFFICIENT_RESOURCES );

            if (!FT_SUCCESS( Irp->IoStatus.Status )) {

                BOOLEAN DataLost = TRUE;

                if (!FsRtlIsTotalDeviceFailure( Status ) &&
                    (Status != STATUS_VERIFY_REQUIRED)) {

                    //
                    //  We don't want to try to hotfix READ errors on the paging file
                    //  because of deadlock possibilities with MM. Instead we'll just
                    //  return the error for MM to deal with. Chances are that
                    //  MM (eg. MiWaitForInPageComplete) will bugcheck anyway,
                    //  but it's still nicer than walking right into the deadlock.
                    //

                    if (IrpSp->MajorFunction != IRP_MJ_READ) {

                        if ((Irp->IoStatus.Status == STATUS_FT_READ_RECOVERY_FROM_BACKUP) ||
                            (Irp->IoStatus.Status == STATUS_FT_WRITE_RECOVERY)) {

                            //
                            //  We got the data down on part of the mirror so we can do the fix
                            //  asynchronously
                            //

                            DataLost = FALSE;
                        }

                        //
                        //  Start an async hotfix
                        //

                        try {

                            NtfsPostHotFix( Irp,
                                            &StartingVbo,
                                            ThisLbo,
                                            TransferSize,
                                            FALSE );

                        } except( GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                            //
                            //  If we don't have enough memory to post the hotfix - so be it
                            //  continue on
                            //

                            NtfsMinimumExceptionProcessing( IrpContext );
                        }
                    }
                }

                //
                //  If mm needs to rewrite the data return back the error
                //

                if (DataLost) {
                    Irp->MdlAddress = MasterMdl;
                    NtfsCompleteRequest( NULL, Irp, Irp->IoStatus.Status );
                    return;
                }
            }

            //
            //  Now adjust everything for the next pass through the loop
            //

            StartingVbo += TransferSize;
            BufferOffset += TransferSize;
            ByteCount -= TransferSize;
            ThisByteCount -= TransferSize;
            ThisLbo += TransferSize;
        }

        //
        //  Now adjust everything for the next pass through the loop but
        //  break out now if all the irps have been created for the io.
        //

        ClusterOffset = 0;
        ThisVcn += ThisClusterCount;
    }

    //
    //  Finally restore back the fields and complete the original irp
    //

    Irp->MdlAddress = MasterMdl;
    NtfsCompleteRequest( NULL, Irp, Irp->IoStatus.Status );
}



VOID
NtfsPagingFileIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine nevers blocks, and should only be used with the paging
    file since no completion processing is performed.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the file to act on.

    StartingVbo - Starting offset within the file for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    LONGLONG ThisClusterCount;
    ULONG ThisByteCount;

    LCN ThisLcn;
    LBO ThisLbo;

    VCN ThisVcn;

    PIRP AssocIrp;
    PIRP ContextIrp;
    PIO_STACK_LOCATION IrpSp;
    ULONG BufferOffset;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT OurDeviceObject;

    PVCB Vcb = Scb->Vcb;

    LIST_ENTRY AssociatedIrps;
    ULONG AssociatedIrpCount;

    ULONG ClusterOffset;
    VCN BeyondLastCluster;

    VBO OriginalStartingVbo = StartingVbo;
    ULONG OriginalByteCount = ByteCount;

    ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME ); //****ignore verify for now

    //
    //  Check whether we want to set the low order bit in the Irp to pass
    //  as a context value to the completion routine.
    //

    ContextIrp = Irp;

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY )) {

        SetFlag( ((ULONG_PTR) ContextIrp), 0x1 );
    }

    //
    //  Check that we are sector aligned.
    //

    ASSERT( (((ULONG)StartingVbo) & (Vcb->BytesPerSector - 1)) == 0 );

    //
    //  Initialize some locals.
    //

    BufferOffset = 0;
    ClusterOffset = (ULONG) StartingVbo & Vcb->ClusterMask;
    DeviceObject = Vcb->TargetDeviceObject;
    BeyondLastCluster = LlClustersFromBytes( Vcb, StartingVbo + ByteCount );

    //
    //  Try to lookup the first run.  If there is just a single run,
    //  we may just be able to pass it on.
    //

    ThisVcn = LlClustersFromBytesTruncate( Vcb, StartingVbo );

    //
    //  Paging files reads/ writes should always be correct.  If we didn't
    //  find the allocation, something bad has happened.
    //

    if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                 ThisVcn,
                                 &ThisLcn,
                                 &ThisClusterCount,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL )) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Adjust from Lcn to Lbo.
    //

    ThisLbo = LlBytesFromClusters( Vcb, ThisLcn ) + ClusterOffset;

    //
    //  Now set up the Irp->IoStatus.  It will be modified by the
    //  multi-completion routine in case of error or verify required.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = ByteCount;

    //
    //  Save the FileObject.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;
    OurDeviceObject = IrpSp->DeviceObject;

    //
    //  See if the write covers a single valid run, and if so pass
    //  it on.
    //

    if (ThisVcn + ThisClusterCount >= BeyondLastCluster) {

        DebugTrace( 0, Dbg, ("Passing Irp on to Disk Driver\n") );

        //
        //  We use our stack location to store request information in a
        //  rather strange way, to give us enough context to post a
        //  hot fix on error.  It's ok, because it is our stack location!
        //

        IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;
        IrpSp->Parameters.Read.Key = ((ULONG)StartingVbo);

        //
        //  Set up the completion routine address in our stack frame.
        //  This is only invoked on error or cancel, and just copies
        //  the error Status into master irp's iosb.
        //

        IoSetCompletionRoutine( Irp,
                                &NtfsPagingFileCompletionRoutine,
                                ContextIrp,
                                (BOOLEAN)!FlagOn(Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE),
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location for the disk driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        IrpSp->MajorFunction = IrpContext->MajorFunction;
        IrpSp->Parameters.Read.Length = ByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;

        //
        //  Issue the read/write request
        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be dealt with as a normal IO error.
        //

        (VOID)IoCallDriver( DeviceObject, Irp );

        DebugTrace( -1, Dbg, ("NtfsPagingFileIo -> VOID\n") );
        return;
    }

    //
    //  Loop while there are still byte writes to satisfy.  Always keep the
    //  associated irp count one up, so that the master irp won't get
    //  completed prematurly.
    //

    try {

        //
        //  We will allocate and initialize all of the Irps and then send
        //  them down to the driver.  We will queue them off of our
        //  AssociatedIrp queue.
        //

        InitializeListHead( &AssociatedIrps );
        AssociatedIrpCount = 0;

        while (TRUE) {

            //
            //  Reset this for unwinding purposes
            //

            AssocIrp = NULL;

            //
            //  If next run is larger than we need, "ya get what you need".
            //

            ThisByteCount = BytesFromClusters( Vcb, (ULONG) ThisClusterCount ) - ClusterOffset;
            if (ThisVcn + ThisClusterCount >= BeyondLastCluster) {

                ThisByteCount = ByteCount;
            }

            //
            //  Now that we have properly bounded this piece of the
            //  transfer, it is time to read/write it.
            //

            AssocIrp = IoMakeAssociatedIrp( Irp, (CCHAR)(DeviceObject->StackSize + 1) );

            if (AssocIrp == NULL) {
                break;
            }

            //
            //  Now add the Irp to our queue of Irps.
            //

            InsertTailList( &AssociatedIrps, &AssocIrp->Tail.Overlay.ListEntry );

            //
            //  Allocate and build a partial Mdl for the request.
            //

            {
                PMDL Mdl;

                Mdl = IoAllocateMdl( (PCHAR)Irp->UserBuffer + BufferOffset,
                                     ThisByteCount,
                                     FALSE,
                                     FALSE,
                                     AssocIrp );

                if (Mdl == NULL) {
                    break;
                }

                IoBuildPartialMdl( Irp->MdlAddress,
                                   Mdl,
                                   Add2Ptr( Irp->UserBuffer, BufferOffset ),
                                   ThisByteCount );
            }

            AssociatedIrpCount += 1;

            //
            //  Get the first IRP stack location in the associated Irp
            //

            IoSetNextIrpStackLocation( AssocIrp );
            IrpSp = IoGetCurrentIrpStackLocation( AssocIrp );

            //
            //  We use our stack location to store request information in a
            //  rather strange way, to give us enough context to post a
            //  hot fix on error.  It's ok, because it is our stack location!
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = ThisByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;
            IrpSp->Parameters.Read.Key = ((ULONG)StartingVbo);
            IrpSp->FileObject = FileObject;
            IrpSp->DeviceObject = OurDeviceObject;

            //
            //  Set up the completion routine address in our stack frame.
            //  This is only invoked on error or cancel, and just copies
            //  the error Status into master irp's iosb.
            //

            IoSetCompletionRoutine( AssocIrp,
                                    &NtfsPagingFileCompletionRoutine,
                                    ContextIrp,
                                    (BOOLEAN)!FlagOn(Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE),
                                    TRUE,
                                    TRUE );

            //
            //  Setup the next IRP stack location in the associated Irp for the disk
            //  driver beneath us.
            //

            IrpSp = IoGetNextIrpStackLocation( AssocIrp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = ThisByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;

            //
            //  Now adjust everything for the next pass through the loop but
            //  break out now if all the irps have been created for the io.
            //

            StartingVbo += ThisByteCount;
            BufferOffset += ThisByteCount;
            ByteCount -= ThisByteCount;
            ClusterOffset = 0;
            ThisVcn += ThisClusterCount;


            if (ByteCount == 0) {

                break;
            }

            //
            //  Try to lookup the next run (if we are not done).
            //  Paging files reads/ writes should always be correct.  If
            //  we didn't find the allocation, something bad has happened.
            //

            if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                         ThisVcn,
                                         &ThisLcn,
                                         &ThisClusterCount,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL )) {;

                NtfsBugCheck( 0, 0, 0 );
            }

            ThisLbo = LlBytesFromClusters( Vcb, ThisLcn );

        } //  while (ByteCount != 0)

        if (ByteCount == 0) {

            //
            //  We have now created all of the Irps that we need.  We will set the
            //  Irp count in the master Irp and then fire off the associated irps.
            //

            Irp->AssociatedIrp.IrpCount = AssociatedIrpCount;

            while (!IsListEmpty( &AssociatedIrps )) {

                AssocIrp = CONTAINING_RECORD( AssociatedIrps.Flink,
                                              IRP,
                                              Tail.Overlay.ListEntry );

                RemoveHeadList( &AssociatedIrps );

                (VOID) IoCallDriver( DeviceObject, AssocIrp );
            }
        } else {

            NtfsPagingFileIoWithNoAllocation( IrpContext, Irp, Scb, OriginalStartingVbo, OriginalByteCount );
        }
    } finally {

        DebugUnwind( NtfsPagingFileIo );

        //
        //  In the case of an error we must clean up any of the associated Irps
        //  we have created.
        //

        while (!IsListEmpty( &AssociatedIrps )) {

            AssocIrp = CONTAINING_RECORD( AssociatedIrps.Flink,
                                          IRP,
                                          Tail.Overlay.ListEntry );

            RemoveHeadList( &AssociatedIrps );

            if (AssocIrp->MdlAddress != NULL) {

                IoFreeMdl( AssocIrp->MdlAddress );
                AssocIrp->MdlAddress = NULL;
            }

            IoFreeIrp( AssocIrp );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsPagingFileIo -> VOID\n") );
    return;
}


BOOLEAN
NtfsIsReadAheadThread (
    )

/*++

Routine Description:

    This routine returns whether the current thread is doing read ahead.

Arguments:

    None

Return Value:

    FALSE - if the thread is not doing read ahead
    TRUE - if the thread is doing read ahead

--*/

{
    PREAD_AHEAD_THREAD ReadAheadThread;
    PVOID CurrentThread = PsGetCurrentThread();
    KIRQL OldIrql;

    OldIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

    ReadAheadThread = (PREAD_AHEAD_THREAD)NtfsData.ReadAheadThreads.Flink;

    //
    //  Scan for our thread, stopping at the end of the list or on the first
    //  NULL.  We can stop on the first NULL, since when we free an entry
    //  we move it to the end of the list.
    //

    while ((ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) &&
           (ReadAheadThread->Thread != NULL)) {

        //
        //  Get out if we see our thread.
        //

        if (ReadAheadThread->Thread == CurrentThread) {

            KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );
            return TRUE;
        }
        ReadAheadThread = (PREAD_AHEAD_THREAD)ReadAheadThread->Links.Flink;
    }

    KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );
    return FALSE;
}


//
//  Internal support routine
//

VOID
NtfsAllocateCompressionBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN OUT PULONG CompressionBufferLength
    )

/*++

Routine Description:

    This routine allocates a compression buffer of the desired length, and
            describes it with an Mdl.  It updates the Irp to describe the new buffer.
    Note that whoever allocates the CompressionContext must initially zero it.

Arguments:

    ThisScb - The stream where the IO is taking place.

    Irp - Irp for the current request

    CompressionContext - Pointer to the compression context for the request.

    CompressionBufferLength - Supplies length required for the compression buffer.
                              Returns length available.

Return Value:

    None.

--*/

{
    PMDL Mdl;

    //
    //  If no compression buffer is allocated, or it is too small, then we must
    //  take action here.
    //

    if (*CompressionBufferLength > CompressionContext->CompressionBufferLength) {

        //
        //  If there already is an Mdl, then there must also be a compression
        //  buffer (since we are part of main-line processing), and we must
        //  free these first.
        //

        if (CompressionContext->SavedMdl != NULL) {

            //
            //  Restore the byte count for which the Mdl was created, and free it.
            //

            Irp->MdlAddress->ByteCount = CompressionContext->CompressionBufferLength;

            NtfsDeleteMdlAndBuffer( Irp->MdlAddress,
                                    CompressionContext->CompressionBuffer );

            //
            //  Restore the Mdl and UserBuffer fields in the Irp.
            //

            Irp->MdlAddress = CompressionContext->SavedMdl;
            Irp->UserBuffer = CompressionContext->SavedUserBuffer;
            CompressionContext->SavedMdl = NULL;
            CompressionContext->CompressionBuffer = NULL;
        }

        CompressionContext->CompressionBufferLength = *CompressionBufferLength;

        //
        //  Allocate the compression buffer or raise
        //

        NtfsCreateMdlAndBuffer( IrpContext,
                                ThisScb,
                                (UCHAR) ((IrpContext->MajorFunction == IRP_MJ_WRITE) ?
                                         RESERVED_BUFFER_TWO_NEEDED :
                                         RESERVED_BUFFER_ONE_NEEDED),
                                &CompressionContext->CompressionBufferLength,
                                &Mdl,
                                &CompressionContext->CompressionBuffer );

        //
        //  Finally save the Mdl and Buffer fields from the Irp, and replace
        //  with the ones we just allocated.
        //

        CompressionContext->SavedMdl = Irp->MdlAddress;
        CompressionContext->SavedUserBuffer = Irp->UserBuffer;
        Irp->MdlAddress = Mdl;
        Irp->UserBuffer = CompressionContext->CompressionBuffer;
    }

    //
    //  Update the caller's length field in all cases.
    //

    *CompressionBufferLength = CompressionContext->CompressionBufferLength;
}


//
//  Internal support routine
//

VOID
NtfsDeallocateCompressionBuffer (
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN BOOLEAN Reinitialize
    )

/*++

Routine Description:

    This routine peforms all necessary cleanup for a compressed I/O, as described
    by the compression context.

Arguments:

    Irp - Irp for the current request

    CompressionContext - Pointer to the compression context for the request.

    Reinitialize - TRUE if we plan to continue using this context.

Return Value:

    None.

--*/

{
    //
    //  If there is a saved mdl, then we have to restore the original
    //  byte count it was allocated with and free it.  Then restore the
    //  Irp fields we modified.
    //

    if (CompressionContext->SavedMdl != NULL) {

        Irp->MdlAddress->ByteCount = CompressionContext->CompressionBufferLength;

        NtfsDeleteMdlAndBuffer( Irp->MdlAddress,
                                CompressionContext->CompressionBuffer );

    } else {

        NtfsDeleteMdlAndBuffer( NULL,
                                CompressionContext->CompressionBuffer );
    }

    //
    //  If there is a saved mdl, then we have to restore the original
    //  byte count it was allocated with and free it.  Then restore the
    //  Irp fields we modified.
    //

    if (CompressionContext->SavedMdl != NULL) {

        Irp->MdlAddress = CompressionContext->SavedMdl;
        Irp->UserBuffer = CompressionContext->SavedUserBuffer;
    }

    //
    //  If there is a work space structure allocated, free it.
    //

    if (CompressionContext->WorkSpace != NULL) {

        NtfsDeleteMdlAndBuffer( NULL, CompressionContext->WorkSpace );
    }

    //
    //  If are reinitializing the structure then clear the fields which
    //  we have already cleaned up.
    //

    if (Reinitialize) {

        CompressionContext->SavedMdl = NULL;
        CompressionContext->SavedUserBuffer = NULL;
        CompressionContext->CompressionBuffer = NULL;
        CompressionContext->WorkSpace = NULL;
        CompressionContext->CompressionBufferLength = 0;

    //
    //  Delete any allocate IoRuns array if we are done.
    //

    } else if (CompressionContext->AllocatedRuns != NTFS_MAX_PARALLEL_IOS) {
        NtfsFreePool( CompressionContext->IoRuns );
    }
}


//
//  Internal support routine
//

LONG
NtfsCompressionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

{
    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( FsRtlIsNtstatusExpected( ExceptionPointer->ExceptionRecord->ExceptionCode ) );
    return EXCEPTION_EXECUTE_HANDLER;
}


//
//  Internal support routine
//

ULONG
NtfsPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags,
    IN OUT PBOOLEAN Wait,
    OUT PULONG NumberRuns,
    OUT PCOMPRESSION_CONTEXT CompressionContext
    )

/*++

Routine Description:

    This routine prepares the buffers for a noncached transfer, and fills
    in the IoRuns array to describe all of the separate transfers which must
    take place.

    For compressed reads, the exact size of the compressed data is
    calculated by scanning the run information, and a buffer is allocated
    to receive the compressed data.

    For compressed writes, an estimate is made on how large of a compressed
    buffer will be required.  Then the compression is performed, as much as
    possible, into the compressed buffer which was allocated.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    NumberRuns - Returns the number of runs filled in to the IoRuns array.

    CompressionContext - Returns information related to the compression
                         to be cleaned up after the transfer.

    StreamFlags - Supplies either 0 or some combination of COMPRESSED_STREAM
                  and ENCRYPTED_STREAM

Return Value:

    Returns uncompressed bytes remaining to be processed, or 0 if all buffers
    are prepared in the IoRuns and CompressionContext.

--*/

{
    PVOID RangePtr;
    ULONG Index;

    LBO NextLbo;
    LCN NextLcn;
    VBO TempVbo;

    ULONG NextLcnOffset;

    VCN StartingVcn;

    ULONG NextByteCount;
    ULONG ReturnByteCount;
    ULONG TrimmedByteCount;
    LONGLONG NextClusterCount;

    BOOLEAN NextIsAllocated;
    BOOLEAN SparseWrite = FALSE;
    BOOLEAN OriginalSparseWrite = FALSE;

    ULONG BufferOffset;

    ULONG StructureSize;
    ULONG UsaOffset;
    ULONG BytesInIoRuns;
    BOOLEAN StopForUsa;

    PVOID SystemBuffer;

    ULONG CompressionUnit, CompressionUnitInClusters;
    ULONG CompressionUnitOffset;
    ULONG CompressedSize, FinalCompressedSize;
    LONGLONG FinalCompressedClusters;
    ULONG LastStartUsaIoRun;
    LOGICAL ReadRequest;
    PIO_STACK_LOCATION IrpSp;

    PIO_RUN IoRuns;

    NTSTATUS Status;

    VBO StartVbo = *StartingVbo;
    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    //
    //  Initialize some locals.
    //

    IoRuns = CompressionContext->IoRuns;
    *NumberRuns = 0;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ReadRequest = (LOGICAL)((IrpContext->MajorFunction == IRP_MJ_READ) ||
                            ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                             (IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                             (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_READ_FROM_PLEX)));

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    ASSERT( FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
            FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Write.Length) );

    NtfsLockUserBuffer( IrpContext,
                        Irp,
                        ReadRequest ?
                          IoWriteAccess : IoReadAccess,
                        IrpSp->Parameters.Read.Length );

    //
    //  Normally the Mdl BufferOffset picks up from where we last left off.
    //  However, for those cases where we have called NtfsAllocateCompressionBuffer,
    //  for a scratch buffer, we always reset to offset 0.
    //

    BufferOffset = CompressionContext->SystemBufferOffset;
    if (CompressionContext->SavedMdl != NULL) {
        BufferOffset = 0;
    }

    //
    //  Check if this request wants to drive the IO directly from the Mcb.  This is
    //  the case for all Scb's without a compression unit or for reads of uncompressed
    //  files or compressed reads.  Also proceed with sparse writes optimistically
    //  assuming the compression unit is allocated.
    //

    if ((ReadRequest) ?

         //
         //  Trust Mcb on reads of uncompressed files or reading compressed data.
         //

         ((Scb->CompressionUnit == 0) ||
          !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) ||
          FlagOn( StreamFlags, COMPRESSED_STREAM )) :

         //
         //  Trust Mcb (optimistically) for writes of uncompressed sparse files.
         //

         ((Scb->CompressionUnit == 0) ||
          (OriginalSparseWrite =
           SparseWrite = FlagOn( Scb->AttributeFlags,
                                  ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE))) {

        ASSERT( (ReadRequest) ||
                (IrpContext->MajorFunction == IRP_MJ_WRITE) ||
                FlagOn( StreamFlags, COMPRESSED_STREAM ) );

        ASSERT( (Scb->CompressionUnit == 0) ||
                NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ) );

        //
        //  If this is a Usa-protected structure and we are reading, figure out
        //  what units we want to access it in.
        //

        TrimmedByteCount = 0;

        if ((Scb->EncryptionContext != NULL) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE)) {

            //
            //  For an encrypted file, we will be allocating a new buffer in the irp
            //  so the entries in the ioruns array should have offsets relative to
            //  this new buffer.
            //

            if (ByteCount > LARGE_BUFFER_SIZE) {

                //
                //  Trim to LARGE_BUFFER_SIZE and remember the amount trimmed
                //  to add back to byte count later.
                //

                TrimmedByteCount = ByteCount - LARGE_BUFFER_SIZE;
                ByteCount = LARGE_BUFFER_SIZE;

                DebugTrace( 0, Dbg, ("\nTrimming ByteCount by %x", TrimmedByteCount) );
            }
        }

        StructureSize = ByteCount;
        if (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) &&
            (ReadRequest)) {

            //
            //  Get the the number of blocks, based on what type of stream it is.
            //  First check for Mft or Log file.
            //

            if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

                ASSERT((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb));

                StructureSize = Vcb->BytesPerFileRecordSegment;

            //
            //  Otherwise it is an index, so we can get the count out of the Scb.
            //

            } else if (Scb->Header.NodeTypeCode != NTFS_NTC_SCB_DATA) {

                StructureSize = Scb->ScbType.Index.BytesPerIndexBuffer;
            }

            //
            //  Remember the last index in the IO runs array which will allow us to
            //  read in a full USA structure in the worst case.
            //

            LastStartUsaIoRun = ClustersFromBytes( Vcb, StructureSize );

            if (LastStartUsaIoRun > NTFS_MAX_PARALLEL_IOS) {

                LastStartUsaIoRun = 0;

            } else {

                LastStartUsaIoRun = NTFS_MAX_PARALLEL_IOS - LastStartUsaIoRun;
            }
        }

        BytesInIoRuns = 0;
        UsaOffset = 0;
        StopForUsa = FALSE;

        while ((ByteCount != 0) && (*NumberRuns != NTFS_MAX_PARALLEL_IOS) && !StopForUsa) {

            //
            //  Lookup next run
            //

            StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

            //
            //  If another writer is modifying the Mcb of a sparse file then we need
            //  to serialize our lookup.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_PROTECT_SPARSE_MCB )) {

                NtfsPurgeFileRecordCache( IrpContext );
                NtfsAcquireSharedScb( IrpContext, Scb );

                try {

                    NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                            Scb,
                                                            StartingVcn,
                                                            &NextLcn,
                                                            &NextClusterCount,
                                                            NULL,
                                                            NULL );

                } finally {

                    NtfsReleaseScb( IrpContext, Scb );
                }

            } else {

                //
                //  Purge because lookupallocation may acquire the scb main if it needs to load
                //  which will be first main acquire and can be blocked behind an acquireallfiles
                //

                NtfsPurgeFileRecordCache( IrpContext );
                NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                        Scb,
                                                        StartingVcn,
                                                        &NextLcn,
                                                        &NextClusterCount,
                                                        NULL,
                                                        NULL );
            }

            ASSERT( NextIsAllocated ||
                    FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||
                    FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ||
                    (Scb == Vcb->MftScb) ||
                    FlagOn( StreamFlags, COMPRESSED_STREAM | ENCRYPTED_STREAM ) );

            //
            //  If this is a sparse write we need to deal with cases where
            //  the run is not allocated OR the last run in this transfer
            //  was unallocated but this run is allocated.
            //

            if (SparseWrite) {

                //
                //  If the current run is not allocated then break out of the loop.
                //

                if (!NextIsAllocated) {

                    //
                    //  Convert to synchronous since we need to allocate space
                    //

                    if (*Wait == FALSE) {

                        *Wait = TRUE;
                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                        ClearFlag( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_ASYNC );
                        KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                           NotificationEvent,
                                           FALSE );
                    }

                    break;

                }

                //
                //  Deal with the case where the last run in this transfer was not allocated.
                //  In that case we would have allocated a compression buffer and stored
                //  the original Mdl into the compression context.  Since this is an allocated
                //  range we can use the original user buffer and Mdl.  Restore these
                //  back into the original irp now.
                //
                //  If this file is encrypted, we do NOT want to change the buffer offset,
                //  because this offset will be stored as the first IoRun's buffer offset, and
                //  encrypt buffers will add the system buffer offset to that, and end up
                //  passing a bad buffer to the encryption driver.  Besides, it's inefficient
                //  to deallocate the buffer, since encrypt buffers will have to reallocate it.
                //

                if ((CompressionContext->SavedMdl != NULL) &&
                    (Scb->EncryptionContext == NULL)) {

                    NtfsDeallocateCompressionBuffer( Irp, CompressionContext, TRUE );
                    BufferOffset = CompressionContext->SystemBufferOffset;
                }
            }

            //
            //  Adjust from NextLcn to Lbo.  NextByteCount may overflow out of 32 bits
            //  but we will catch that below when we compare clusters.
            //

            NextLcnOffset = ((ULONG)StartVbo) & Vcb->ClusterMask;

            NextByteCount = BytesFromClusters( Vcb, (ULONG)NextClusterCount ) - NextLcnOffset;

            //
            // If next run is larger than we need, "ya get what you need".
            // Note that after this we are guaranteed that the HighPart of
            // NextByteCount is 0.
            //

            if ((ULONG)NextClusterCount >= ClustersFromBytes( Vcb, ByteCount + NextLcnOffset )) {

                NextByteCount = ByteCount;
            }

            //
            //  If the byte count is zero then we will spin indefinitely.  Raise
            //  corrupt here so the system doesn't hang.
            //

            if (NextByteCount == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            //
            //  If this is a USA-protected structure, broken up in
            //  multiple runs, then we want to guarantee that we do
            //  not end up in the middle of a Usa-protected structure in the read path.
            //  Therefore, on the first run we will calculate the
            //  initial UsaOffset.  Then in the worst case it can
            //  take the remaining four runs to finish the Usa structure.
            //
            //  On the first subsequent run to complete a Usa structure,
            //  we set the count to end exactly on a Usa boundary.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) &&
                (ReadRequest)) {

                //
                //  So long as we know there are more IO runs left than the maximum
                //  number needed for the USA structure just maintain the current
                //  Usa offset.
                //

                if (*NumberRuns < LastStartUsaIoRun) {

                    UsaOffset = (UsaOffset + NextByteCount) & (StructureSize - 1);

                //
                //  Now we will stop on the next Usa boundary, but we may not
                //  have it yet.
                //

                } else {

                    if ((NextByteCount + UsaOffset) >= StructureSize) {

                        NextByteCount = ((NextByteCount + UsaOffset) & ~(StructureSize - 1)) -
                                        (UsaOffset & (StructureSize - 1));
                        StopForUsa = TRUE;
                    }

                    UsaOffset += NextByteCount;
                }
            }

            //
            //  Only fill in the run array if the run is allocated.
            //

            if (NextIsAllocated) {

                //
                //  Adjust if the Lcn offset (if we have one) and isn't zero.
                //

                NextLbo = LlBytesFromClusters( Vcb, NextLcn );
                NextLbo = NextLbo + NextLcnOffset;

                //
                // Now that we have properly bounded this piece of the
                // transfer, it is time to write it.
                //
                // We remember each piece of a parallel run by saving the
                // essential information in the IoRuns array.  The tranfers
                // are started up in parallel below.
                //

                IoRuns[*NumberRuns].StartingVbo = StartVbo;
                IoRuns[*NumberRuns].StartingLbo = NextLbo;
                IoRuns[*NumberRuns].BufferOffset = BufferOffset;
                IoRuns[*NumberRuns].ByteCount = NextByteCount;
                BytesInIoRuns += NextByteCount;
                *NumberRuns += 1;

            } else if (ReadRequest) {

                SystemBuffer = Add2Ptr( NtfsMapUserBuffer( Irp, NormalPagePriority ), BufferOffset );

                //
                //  If this is not a compressed stream then fill this range with zeroes.
                //  Also if this is a sparse, non-compressed stream then check if we need to
                //  reserve clusters.
                //

                if (!FlagOn( StreamFlags, COMPRESSED_STREAM )) {

#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, SCE_FLAG_NON_CACHED | SCE_FLAG_READ | SCE_FLAG_PREPARE_BUFFERS, StartVbo + BufferOffset, NextByteCount, 0 );
                    }
#endif

                    RtlZeroMemory( SystemBuffer, NextByteCount );

                    if (FlagOn( Irp->Flags, IRP_PAGING_IO ) &&
                        FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE ) &&
                        (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE)) {

                        if (!NtfsReserveClusters( IrpContext,
                                                  Scb,
                                                  StartVbo,
                                                  NextByteCount )) {

                            NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                        }
                    }

                //
                //  If it is compressed then make sure the range begins with a zero in
                //  case MM passed a non-zeroed buffer.  Then the compressed read/write
                //  routines will know the chunk begins with a zero.
                //

                } else {

                    *((PULONG) SystemBuffer) = 0;
                }
            }

            //
            // Now adjust everything for the next pass through the loop.
            //

            StartVbo = StartVbo + NextByteCount;
            BufferOffset += NextByteCount;
            ByteCount -= NextByteCount;
        }

        //
        //  Let's remember about those bytes we trimmed off above.  We have more
        //  bytes remaining than we think, and we didn't transfer as much, so we
        //  need to back up where we start the next transfer.
        //

        if (TrimmedByteCount != 0) {

            DebugTrace( 0,
                        Dbg,
                        ("\nByteCount + TrimmedByteCount = %x + %x = %x",
                         ByteCount,
                         TrimmedByteCount,
                         ByteCount + TrimmedByteCount) );

            DebugTrace( 0,
                        Dbg,
                        ("\nStartVbo - TrimmedByteCount = %I64x - %x = %I64x",
                         StartVbo,
                         TrimmedByteCount,
                         StartVbo - TrimmedByteCount) );

            ByteCount += TrimmedByteCount;
        }

        //
        //  If this is a sparse write and the start of the write is unallocated then drop
        //  down to the compressed path below.  Otherwise do the IO we found.
        //

        if (!SparseWrite || (BytesInIoRuns != 0)) {

            return ByteCount;
        }
    }

    ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA  );

    //
    //  Initialize the compression parameters.
    //

    CompressionUnit = Scb->CompressionUnit;
    CompressionUnitInClusters = ClustersFromBytes(Vcb, CompressionUnit);
    CompressionUnitOffset = 0;
    if (CompressionUnit != 0) {
        CompressionUnitOffset = ((ULONG)StartVbo) & (CompressionUnit - 1);
    }

    //
    //  We want to make sure and wait to get byte count and things correctly.
    //

    if (!FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT)) {
        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  Handle the compressed read case.
    //

    if (IrpContext->MajorFunction == IRP_MJ_READ) {

        //
        //  If we have not already mapped the user buffer, then do it.
        //

        if (CompressionContext->SystemBuffer == NULL) {
            CompressionContext->SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
        }

        BytesInIoRuns = 0;

        //
        //  Adjust StartVbo and ByteCount by the offset.
        //

        ((ULONG)StartVbo) -= CompressionUnitOffset;
        ByteCount += CompressionUnitOffset;

        //
        //  Capture this value for maintaining the byte count to
        //  return.
        //

        ReturnByteCount = ByteCount;

        //
        //  Now, the ByteCount we actually have to process has to
        //  be rounded up to the next compression unit.
        //

        ByteCount = BlockAlign( ByteCount, (LONG)CompressionUnit );

        //
        //  Make sure we never try to handle more than a LARGE_BUFFER_SIZE
        //  at once, forcing our caller to call back.
        //

        if (ByteCount > LARGE_BUFFER_SIZE) {
            ByteCount = LARGE_BUFFER_SIZE;
        }

        //
        //  In case we find no allocation....
        //

        IoRuns[0].ByteCount = 0;

        while (ByteCount != 0) {

            //
            // Try to lookup the first run.  If there is just a single run,
            // we may just be able to pass it on.
            //

            ASSERT( !FlagOn( ((ULONG) StartVbo), Vcb->ClusterMask ));
            StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                    Scb,
                                                    StartingVcn,
                                                    &NextLcn,
                                                    &NextClusterCount,
                                                    NULL,
                                                    NULL );

#if (defined(NTFS_RWCMP_TRACE))
            ASSERT(!IsSyscache(Scb) || (NextClusterCount < 16) || !NextIsAllocated);
#endif

            //
            //  Adjust from NextLcn to Lbo.
            //
            //  If next run is larger than we need, "ya get what you need".
            //  Note that after this we are guaranteed that the HighPart of
            //  NextByteCount is 0.
            //


            if ((ULONG)NextClusterCount >= ClustersFromBytes( Vcb, ByteCount )) {

                NextByteCount = ByteCount;

            } else {

                NextByteCount = BytesFromClusters( Vcb, (ULONG)NextClusterCount );
            }

            //
            //  Adjust if the Lcn offset isn't zero.
            //

            NextLbo = LlBytesFromClusters( Vcb, NextLcn );

            //
            //  Only fill in the run array if the run is allocated.
            //

            if (NextIsAllocated) {

                //
                //  If the Lbos are contiguous, then we can do a contiguous
                //  transfer, so we just increase the current byte count.
                //

                if ((*NumberRuns != 0) && (NextLbo ==
                                           (IoRuns[*NumberRuns - 1].StartingLbo +
                                            (IoRuns[*NumberRuns - 1].ByteCount)))) {

                    //
                    //  Stop on the first compression unit boundary after the
                    //  the penultimate run in the default io array.
                    //

                    if (*NumberRuns >= NTFS_MAX_PARALLEL_IOS - 1) {

                        //
                        //  First, if we are beyond the penultimate run and we are starting
                        //  a run in a different compression unit than the previous
                        //  run, then we can just break out and not use the current
                        //  run.  (*NumberRuns has not yet been incremented.)
                        //  In order for it to be in the same run it can't begin at
                        //  offset 0 in the compression unit and it must be contiguous
                        //  with the virtual end of the previous run.
                        //  The only case where this can happen in the running system is
                        //  if there is a file record boundary in the middle of the
                        //  compression unit.
                        //

                        if ((*NumberRuns > NTFS_MAX_PARALLEL_IOS - 1) &&
                            (!FlagOn( (ULONG) StartVbo, CompressionUnit - 1 ) ||
                            (StartVbo != (IoRuns[*NumberRuns - 1].StartingVbo +
                                          IoRuns[*NumberRuns - 1].ByteCount)))) {

                            break;

                        //
                        //  Else detect the case where this run ends on or
                        //  crosses a compression unit boundary.  In this case,
                        //  just make sure the run stops on a compression unit
                        //  boundary, and break out to return it.
                        //

                        } else if ((((ULONG) StartVbo & (CompressionUnit - 1)) + NextByteCount) >=
                                   CompressionUnit) {

                            NextByteCount -= (((ULONG)StartVbo) + NextByteCount) & (CompressionUnit - 1);
                            BytesInIoRuns += NextByteCount;

                            if (ReturnByteCount > NextByteCount) {
                                ReturnByteCount -= NextByteCount;
                            } else {
                                ReturnByteCount = 0;
                            }

                            IoRuns[*NumberRuns - 1].ByteCount += NextByteCount;

                            break;
                        }
                    }

                    IoRuns[*NumberRuns - 1].ByteCount += NextByteCount;

                //
                //  Otherwise it is time to start a new run, if there is space for one.
                //

                } else {

                    //
                    //  If we have filled up the current I/O runs array, then we
                    //  will grow it once to a size which would allow the worst
                    //  case compression unit (all noncontiguous clusters) to
                    //  start at index NTFS_MAX_PARALLEL_IOS - 1.
                    //  The following if statement enforces
                    //  this case as the worst case.  With 16 clusters per compression
                    //  unit, the theoretical maximum number of parallel I/Os
                    //  would be 16 + NTFS_MAX_PARALLEL_IOS - 1, since we stop on the
                    //  first compression unit boundary after the penultimate run.
                    //  Normally, of course we will do much fewer.
                    //

                    if ((*NumberRuns == NTFS_MAX_PARALLEL_IOS) &&
                        (CompressionContext->AllocatedRuns == NTFS_MAX_PARALLEL_IOS)) {

                        PIO_RUN NewIoRuns;

                        NewIoRuns = NtfsAllocatePool( NonPagedPool,
                                                       (CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1) * sizeof(IO_RUN) );

                        RtlCopyMemory( NewIoRuns,
                                       CompressionContext->IoRuns,
                                       NTFS_MAX_PARALLEL_IOS * sizeof(IO_RUN) );

                        IoRuns = CompressionContext->IoRuns = NewIoRuns;
                        CompressionContext->AllocatedRuns = CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1;
                    }

                    //
                    // We remember each piece of a parallel run by saving the
                    // essential information in the IoRuns array.  The tranfers
                    // will be started up in parallel below.
                    //

                    ASSERT(*NumberRuns < CompressionContext->AllocatedRuns);

                    IoRuns[*NumberRuns].StartingVbo = StartVbo;
                    IoRuns[*NumberRuns].StartingLbo = NextLbo;
                    IoRuns[*NumberRuns].BufferOffset = BufferOffset;
                    IoRuns[*NumberRuns].ByteCount = NextByteCount;
                    if ((*NumberRuns + 1) < CompressionContext->AllocatedRuns) {
                        IoRuns[*NumberRuns + 1].ByteCount = 0;
                    }

                    //
                    //  Stop on the first compression unit boundary after the
                    //  penultimate run in the default array.
                    //

                    if (*NumberRuns >= NTFS_MAX_PARALLEL_IOS - 1) {

                        //
                        //  First, if we are beyond penultimate run and we are starting
                        //  a run in a different compression unit than the previous
                        //  run, then we can just break out and not use the current
                        //  run.  (*NumberRuns has not yet been incremented.)
                        //

                        if ((*NumberRuns > NTFS_MAX_PARALLEL_IOS - 1) &&
                            ((((ULONG)StartVbo) & ~(CompressionUnit - 1)) !=
                             ((((ULONG)IoRuns[*NumberRuns - 1].StartingVbo) +
                               IoRuns[*NumberRuns - 1].ByteCount - 1) &
                               ~(CompressionUnit - 1)))) {

                            break;

                        //
                        //  Else detect the case where this run ends on or
                        //  crosses a compression unit boundary.  In this case,
                        //  just make sure the run stops on a compression unit
                        //  boundary, and break out to return it.
                        //

                        } else if ((((ULONG)StartVbo) & ~(CompressionUnit - 1)) !=
                            ((((ULONG)StartVbo) + NextByteCount) & ~(CompressionUnit - 1))) {

                            NextByteCount -= (((ULONG)StartVbo) + NextByteCount) & (CompressionUnit - 1);
                            IoRuns[*NumberRuns].ByteCount = NextByteCount;
                            BytesInIoRuns += NextByteCount;

                            if (ReturnByteCount > NextByteCount) {
                                ReturnByteCount -= NextByteCount;
                            } else {
                                ReturnByteCount = 0;
                            }

                            *NumberRuns += 1;
                            break;
                        }
                    }
                    *NumberRuns += 1;
                }

                BytesInIoRuns += NextByteCount;
                BufferOffset += NextByteCount;
            }

            //
            //  Now adjust everything for the next pass through the loop.
            //

            StartVbo += NextByteCount;
            ByteCount -= NextByteCount;

            if (ReturnByteCount > NextByteCount) {
                ReturnByteCount -= NextByteCount;
            } else {
                ReturnByteCount = 0;
            }
        }

        //
        //  Allocate the compressed buffer if it is not already allocated.
        //

        if (BytesInIoRuns < CompressionUnit) {
            BytesInIoRuns = CompressionUnit;
        }
        NtfsAllocateCompressionBuffer( IrpContext, Scb, Irp, CompressionContext, &BytesInIoRuns );

        return ReturnByteCount;

    //
    //  Otherwise handle the compressed write case
    //

    } else {

        LONGLONG SavedValidDataToDisk;
        PUCHAR UncompressedBuffer;
        ULONG UncompressedOffset;
        ULONG ClusterOffset;
        BOOLEAN NoopRange;

        ULONG CompressedOffset;
        PBCB Bcb;

        ASSERT(IrpContext->MajorFunction == IRP_MJ_WRITE);

        //
        //  Adjust StartVbo and ByteCount by the offset.
        //

        ((ULONG)StartVbo) -= CompressionUnitOffset;
        ByteCount += CompressionUnitOffset;

        //
        //  Maintain additional bytes to be returned in ReturnByteCount,
        //  and adjust this if we are larger than a LARGE_BUFFER_SIZE.
        //

        ReturnByteCount = 0;
        if (ByteCount > LARGE_BUFFER_SIZE) {
            ReturnByteCount = ByteCount - LARGE_BUFFER_SIZE;
            ByteCount = LARGE_BUFFER_SIZE;
        }

        CompressedSize = ByteCount;
        if (!FlagOn( StreamFlags, COMPRESSED_STREAM ) && (CompressionUnit != 0)) {

            //
            //  To reduce pool consumption, make an educated/optimistic guess on
            //  how much pool we need to store the compressed data.  If we are wrong
            //  we will just have to do some more I/O.
            //

            CompressedSize = BlockAlign( ByteCount, (LONG)CompressionUnit );
            CompressedSize += Vcb->BytesPerCluster;

            if (CompressedSize > LARGE_BUFFER_SIZE) {
                CompressedSize = LARGE_BUFFER_SIZE;
            }

            //
            //  Allocate the compressed buffer if it is not already allocated, and this
            //  isn't the compressed stream.
            //

            if (SparseWrite &&
                (CompressionContext->SystemBuffer == NULL)) {

                CompressionContext->SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
            }

            //
            //  At this point BufferOffset should always be 0.
            //

            BufferOffset = 0;
            NtfsAllocateCompressionBuffer( IrpContext, Scb, Irp, CompressionContext, &CompressedSize );

            CompressionContext->DataTransformed = TRUE;
        }

        //
        //  Loop to compress the user's buffer.
        //

        CompressedOffset = 0;
        UncompressedOffset = 0;
        Bcb = NULL;

        try {

            BOOLEAN ChangeAllocation;
            ULONG SparseFileBias;

            //
            //  Loop as long as we will not overflow our compressed buffer, and we
            //  are also guanteed that we will not overflow the extended IoRuns array
            //  in the worst case (and as long as we have more write to satisfy!).
            //

            while ((ByteCount != 0) && (*NumberRuns <= NTFS_MAX_PARALLEL_IOS - 1) &&
                   (((CompressedOffset + CompressionUnit) <= CompressedSize) ||
                    FlagOn( StreamFlags, COMPRESSED_STREAM ))) {

                LONGLONG SizeToCompress;

                //
                //  State variables to determine a reallocate range.
                //

                VCN DeleteVcn;
                LONGLONG DeleteCount;
                LONGLONG AllocateCount;

                DeleteCount = 0;
                AllocateCount = 0;

                NoopRange = FALSE;
                SparseFileBias = 0;
                ClusterOffset = 0;

                //
                //  Assume we are only compressing to FileSize, or else
                //  reduce to one compression unit.  The maximum compression size
                //  we can accept is saving at least one cluster.
                //

                NtfsAcquireFsrtlHeader( Scb );

                //
                //  If this is a compressed stream then we may need to go past file size.
                //

                if (FlagOn( StreamFlags, COMPRESSED_STREAM)) {

                    SizeToCompress = BlockAlign( Scb->Header.FileSize.QuadPart, (LONG)CompressionUnit );
                    SizeToCompress -= StartVbo;

                } else {

                    SizeToCompress = Scb->Header.FileSize.QuadPart - StartVbo;
                }

                NtfsReleaseFsrtlHeader( Scb );

                //
                //  It is possible that if this is the lazy writer that the file
                //  size was rolled back from a cached write which is aborting.
                //  In that case we either truncate the write or can exit this
                //  loop if there is nothing left to write.
                //

                if (SizeToCompress <= 0) {

                    ByteCount = 0;
                    break;
                }

                //
                //  Note if CompressionUnit is 0, then we do not need SizeToCompress.
                //

                if (SizeToCompress > CompressionUnit) {
                    SizeToCompress = (LONGLONG)CompressionUnit;
                }

#ifdef  COMPRESS_ON_WIRE
                //
                //  For the normal uncompressed stream, map the data and compress it
                //  into the allocated buffer.
                //

                if (!FlagOn( StreamFlags, COMPRESSED_STREAM )) {

#endif

                    //
                    //  If this is a sparse write then we zero the beginning and
                    //  end of the compression unit as needed and copy in the user
                    //  data.
                    //

                    if (SparseWrite) {

                        //
                        //  Use local variables to position ourselves in the
                        //  compression context buffer and user system buffer.
                        //  We'll reuse StructureSize to show the number of
                        //  user bytes copied to the buffer.
                        //

                        SystemBuffer = Add2Ptr( CompressionContext->SystemBuffer,
                                                CompressionContext->SystemBufferOffset + UncompressedOffset );

                        UncompressedBuffer = Add2Ptr( CompressionContext->CompressionBuffer,
                                                      BufferOffset );

                        //
                        //  Zero the beginning of the compression buffer if necessary.
                        //

                        if (CompressionUnitOffset != 0) {

#ifdef SYSCACHE_DEBUG
                            if (ScbIsBeingLogged( Scb )) {
                                FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, SCE_FLAG_NON_CACHED | SCE_FLAG_PREPARE_BUFFERS | SCE_FLAG_WRITE, StartVbo, CompressionUnitOffset, 0 );
                            }
#endif

                            RtlZeroMemory( UncompressedBuffer, CompressionUnitOffset );
                            UncompressedBuffer += CompressionUnitOffset;
                        }

                        //
                        //  Now copy the user data into the buffer.
                        //

                        if ((ULONG) SizeToCompress < ByteCount) {

                            StructureSize = (ULONG) BlockAlign( SizeToCompress, (LONG)Vcb->BytesPerSector ) - CompressionUnitOffset;

                        } else {

                            StructureSize = ByteCount - CompressionUnitOffset;
                        }

                        RtlCopyMemory( UncompressedBuffer,
                                       SystemBuffer,
                                       StructureSize );

                        //
                        //  It may be necessary to zero the end of the buffer.
                        //

                        if ((ULONG) SizeToCompress > ByteCount) {

#ifdef SYSCACHE_DEBUG
                            if (ScbIsBeingLogged( Scb )) {
                                FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, SCE_FLAG_NON_CACHED | SCE_FLAG_PREPARE_BUFFERS | SCE_FLAG_WRITE, StartVbo + StructureSize, SizeToCompress - ByteCount, 1 );
                            }
#endif

                            RtlZeroMemory( Add2Ptr( UncompressedBuffer, StructureSize ),
                                           (ULONG) SizeToCompress - ByteCount );
                        }

                        FinalCompressedSize = CompressionUnit;
                        Status = STATUS_SUCCESS;

                    } else {

                        UncompressedBuffer = NULL;
                        if (CompressionUnit != 0) {

                            //
                            //  Map the aligned range, set it dirty, and flush.  We have to
                            //  loop, because the Cache Manager limits how much and over what
                            //  boundaries we can map.  Only do this if there a file
                            //  object.  Otherwise we will assume we are writing the
                            //  clusters directly to disk (via NtfsWriteClusters).
                            //

                            if (Scb->FileObject != NULL) {

                                CcMapData( Scb->FileObject,
                                           (PLARGE_INTEGER)&StartVbo,
                                           (ULONG)SizeToCompress,
                                           TRUE,
                                           &Bcb,
                                           &UncompressedBuffer );

#ifdef MAPCOUNT_DBG
                                IrpContext->MapCount += 1;
#endif

                            } else {

                                UncompressedBuffer = MmGetSystemAddressForMdlSafe( CompressionContext->SavedMdl, NormalPagePriority );

                                if (UncompressedBuffer == NULL) {

                                    NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
                                }
                            }

                            //
                            //  If we have not already allocated the workspace, then do it.  We don't
                            //  need the workspace if the file is not compressed (i.e. sparse).
                            //

                            if ((CompressionContext->WorkSpace == NULL) &&
                                FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                                ULONG CompressWorkSpaceSize;
                                ULONG FragmentWorkSpaceSize;

                                (VOID) RtlGetCompressionWorkSpaceSize( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                                       &CompressWorkSpaceSize,
                                                                       &FragmentWorkSpaceSize );

                                //
                                //  It is critical to ask for the work space buffer.  It is the only
                                //  one large enough to hold the bigger ia64 pointers.
                                //

                                NtfsCreateMdlAndBuffer( IrpContext,
                                                        Scb,
                                                        RESERVED_BUFFER_WORKSPACE_NEEDED,
                                                        &CompressWorkSpaceSize,
                                                        NULL,
                                                        &CompressionContext->WorkSpace );
                            }
                        }

                        try {

                            //
                            //  If we are moving an uncompressed file, then do not compress
                            //

                            if (CompressionUnit == 0) {
                                FinalCompressedSize = ByteCount;
                                Status = STATUS_SUCCESS;

                            //
                            //  If we are writing compressed, compress it now.
                            //

                            } else if (!FlagOn(Scb->ScbState, SCB_STATE_WRITE_COMPRESSED) ||
                                ((Status =
                                  RtlCompressBuffer( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                     UncompressedBuffer,
                                                     (ULONG)SizeToCompress,
                                                     CompressionContext->CompressionBuffer + CompressedOffset,
                                                     (CompressionUnit - Vcb->BytesPerCluster),
                                                     NTFS_CHUNK_SIZE,
                                                     &FinalCompressedSize,
                                                     CompressionContext->WorkSpace )) ==

                                                    STATUS_BUFFER_TOO_SMALL)) {

                                //
                                //  If it did not compress, just copy it over, sigh.  This looks bad,
                                //  but it should virtually never occur assuming compression is working
                                //  ok.  In the case where FileSize is in this unit, make sure we
                                //  at least copy to a sector boundary.
                                //

                                FinalCompressedSize = CompressionUnit;

                                if (!SparseWrite) {

                                    RtlCopyMemory( CompressionContext->CompressionBuffer + CompressedOffset,
                                                   UncompressedBuffer,
                                                   (ULONG)BlockAlign( SizeToCompress, (LONG)Vcb->BytesPerSector));
                                }

                                ASSERT(FinalCompressedSize <= (CompressedSize - CompressedOffset));
                                Status = STATUS_SUCCESS;
                            }

                        //
                        //  Probably Gary's compression routine faulted, but blame it on
                        //  the user buffer!
                        //

                        } except(NtfsCompressionFilter(IrpContext, GetExceptionInformation())) {
                            NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
                        }
                    }

                //
                //  For the compressed stream, we need to scan the compressed data
                //  to see how much we actually have to write.
                //

#ifdef  COMPRESS_ON_WIRE
                } else {

                    //
                    //  Don't walk off the end of the data being written, because that
                    //  would cause bogus faults in the compressed stream.
                    //

                    if (SizeToCompress > ByteCount) {
                        SizeToCompress = ByteCount;
                    }

                    //
                    //  Map the compressed data.
                    //

                    CcMapData( Scb->Header.FileObjectC,
                               (PLARGE_INTEGER)&StartVbo,
                               (ULONG)SizeToCompress,
                               TRUE,
                               &Bcb,
                               &UncompressedBuffer );

#ifdef MAPCOUNT_DBG
                    IrpContext->MapCount++;
#endif

                    FinalCompressedSize = 0;

                    //
                    //  Loop until we get an error or stop advancing.
                    //

                    RangePtr = UncompressedBuffer + CompressionUnit;
                    do {
                        Status = RtlDescribeChunk( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                   &UncompressedBuffer,
                                                   (PUCHAR)RangePtr,
                                                   (PUCHAR *)&SystemBuffer,
                                                   &CompressedSize );

                        //
                        //  Remember if we see any nonzero chunks
                        //

                        FinalCompressedSize |= CompressedSize;

                    } while (NT_SUCCESS(Status));

                    //
                    //  If we terminated on anything but STATUS_NO_MORE_ENTRIES, we
                    //  somehow picked up some bad data.
                    //

                    if (Status != STATUS_NO_MORE_ENTRIES) {
                        ASSERT(Status == STATUS_NO_MORE_ENTRIES);
                        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                    }
                    Status = STATUS_SUCCESS;

                    //
                    //  If we got any nonzero chunks, then calculate size of buffer to write.
                    //  (Size does not include terminating Ushort of 0.)
                    //

                    if (FinalCompressedSize != 0) {

                        FinalCompressedSize = BlockAlignTruncate( (ULONG_PTR)UncompressedBuffer, (ULONG)CompressionUnit );

                        //
                        //  If the Lazy Writer is writing beyond the end of the compression
                        //  unit (there are dirty pages at the end of the compression unit)
                        //  then we can throw this data away.
                        //

                        if (FinalCompressedSize < CompressionUnitOffset) {

                            //
                            //  Set up to move to the next compression unit.
                            //

                            NoopRange = TRUE;
                            ChangeAllocation = FALSE;

                            //
                            //  Set TempVbo to the compression unit offset.  The
                            //  number of bytes to skip over is the remaining
                            //  bytes in a compression unit.
                            //

                            TempVbo = CompressionUnitOffset;

                        //
                        //  If the Lazy Writer does not have the beginning of the compression
                        //  unit then raise out of here and wait for the write which includes
                        //  the beginning.
                        //

                        } else if (CompressionUnitOffset != 0) {
#if defined(COMPRESS_ON_WIRE) && defined(NTFS_RWC_DEBUG)
                            ASSERT( !NtfsBreakOnConflict ||
                                    (Scb->LazyWriteThread[1] == PsGetCurrentThread()) );
#endif
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_LOCK_CONFLICT, NULL, NULL );

                        //
                        //  If we saw more chunks than our writer is trying to write (it
                        //  more or less has to be the Lazy Writer), then we need to reject
                        //  this request and assume he will come back later for the entire
                        //  amount.  This could be a problem for WRITE_THROUGH.
                        //

                        } else if (FinalCompressedSize > ByteCount) {
#ifdef NTFS_RWC_DEBUG
                            ASSERT( !NtfsBreakOnConflict ||
                                    (Scb->LazyWriteThread[1] == PsGetCurrentThread()) );

                            ASSERT( Scb->LazyWriteThread[1] == PsGetCurrentThread() );
#endif
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_LOCK_CONFLICT, NULL, NULL );
                        }
                    }
                }
#endif

                NtfsUnpinBcb( IrpContext, &Bcb );

                //
                //  Round the FinalCompressedSize up to a cluster boundary now.
                //

                FinalCompressedSize = (FinalCompressedSize + Vcb->BytesPerCluster - 1) &
                                      ~(Vcb->BytesPerCluster - 1);

                //
                //  If the Status was not success, then we have to do something.
                //

                if (Status != STATUS_SUCCESS) {

                    //
                    //  If it was actually an error, then we will raise out of
                    //  here.
                    //

                    if (!NT_SUCCESS(Status)) {
                        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

                    //
                    //  If the buffer compressed to all zeros, then we will
                    //  not allocate anything.
                    //

                    } else if (Status == STATUS_BUFFER_ALL_ZEROS) {
                        FinalCompressedSize = 0;
                    }
                }

                if (!NoopRange) {

                    StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

                    //
                    //  Time to get the Scb if we do not have it already.  We
                    //  need to serialize our changes of the Mcb.
                    //  N.B. -- We may _not_ always be the top level request.
                    //  Converting a compressed stream to nonresident can
                    //  send us down this path with Irp != OriginatingIrp.
                    //

                    if (!CompressionContext->ScbAcquired) {

                        NtfsPurgeFileRecordCache( IrpContext );
                        NtfsAcquireExclusiveScb( IrpContext, Scb );
                        CompressionContext->ScbAcquired = TRUE;
                    }

                    NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                            Scb,
                                                            StartingVcn,
                                                            &NextLcn,
                                                            &NextClusterCount,
                                                            NULL,
                                                            NULL );

                    //
                    //  If this originally was a sparse write but we were defragging
                    //  then we need to be careful if the range is unallocated.  In
                    //  that case we really need to do the full sparse support.  Break
                    //  out of the loop at this point and perform the IO with
                    //  the ranges we already have.
                    //

                    if (!NextIsAllocated && OriginalSparseWrite && !SparseWrite) {

                        break;
                    }

                    //
                    //  If the StartingVcn is allocated, we always have to check
                    //  if we need to delete something, or if in the unusual case
                    //  there is a hole there smaller than a compression unit.
                    //
                    //  If this is a sparse write then we never have anything to
                    //  deallocate.
                    //

                    FinalCompressedClusters = ClustersFromBytes( Vcb, FinalCompressedSize );
                    ChangeAllocation = FALSE;

                    if (SparseWrite) {

                        //
                        //  It is possible that the compression unit has been allocated since we
                        //  tested allocation when we entered this routine.  If so we can
                        //  write directly to disk in the allocated range.  We need to
                        //  modify the range being written however.
                        //

                        if (NextIsAllocated) {

                            //
                            //  Move forward to the beginning of this write.
                            //

                            SparseFileBias = CompressionUnitOffset;
                            ((ULONG) StartVbo) += CompressionUnitOffset;
                            CompressedOffset += CompressionUnitOffset;
                            BufferOffset += CompressionUnitOffset;
                            FinalCompressedSize -= CompressionUnitOffset;

                            if (FinalCompressedSize > (ByteCount - CompressionUnitOffset)) {

                                FinalCompressedSize = (ByteCount - CompressionUnitOffset);
                            }

                            StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

                            //
                            //  Remember that we might not be on a cluster boundary at this point.
                            //

                            ClusterOffset = (ULONG) StartVbo & Vcb->ClusterMask;

                            //
                            //  Look up the correct range on the disk.
                            //

                            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                                    Scb,
                                                                    StartingVcn,
                                                                    &NextLcn,
                                                                    &NextClusterCount,
                                                                    NULL,
                                                                    NULL );

                            ASSERT( NextIsAllocated );

                        } else {

                            //
                            //  Set the Scb flag to indicate we need to serialize non-cached IO
                            //  with the Mcb.
                            //

                            SetFlag( Scb->ScbState, SCB_STATE_PROTECT_SPARSE_MCB );
                        }

                    } else if (NextIsAllocated || (NextClusterCount < CompressionUnitInClusters)) {

                        VCN TempClusterCount;

                        //
                        //  If we need fewer clusters than allocated, then just allocate them.
                        //  But if we need more clusters, then deallocate all the ones we have
                        //  now, otherwise we could corrupt file data if we back out a write
                        //  after actually having written the sectors.  (For example, we could
                        //  extend from 5 to 6 clusters and write 6 clusters of compressed data.
                        //  If we have to back that out we will have a 6-cluster pattern of
                        //  compressed data with one sector deallocated!).
                        //

                        NextIsAllocated = NextIsAllocated &&
                                          (NextClusterCount >= FinalCompressedClusters);

                        //
                        //  If we are cleaning up a hole, or the next run is unuseable,
                        //  then make sure we just delete it rather than sliding the
                        //  tiny run up with SplitMcb.  Note that we have the Scb exclusive,
                        //  and that since all compressed files go through the cache, we
                        //  know that the dirty pages can't go away even if we spin out
                        //  of here with ValidDataToDisk bumped up too high.
                        //

                        SavedValidDataToDisk = Scb->ValidDataToDisk;
                        if (!NextIsAllocated && ((StartVbo + CompressionUnit) > Scb->ValidDataToDisk)) {
                            Scb->ValidDataToDisk = StartVbo + CompressionUnit;
                        }

                        //
                        //  Also, we need to handle the case where a range within
                        //  ValidDataToDisk is fully allocated.  If we are going to compress
                        //  now, then we have the same problem with failing after writing
                        //  the compressed data out, i.e., because we are fully allocated
                        //  we would see the data as uncompressed after an abort, yet we
                        //  have written compressed data. We do not implement the entire
                        //  loop necessary to really see if the compression unit is fully
                        //  allocated - we just verify that NextClusterCount is less than
                        //  a compression unit and that the next run is not allocated.  Just
                        //  because the next contiguous run is also allocated does not guarantee
                        //  that the compression unit is fully allocated, but maybe we will
                        //  get some small defrag gain by reallocating what we need in a
                        //  single run.
                        //

                        NextIsAllocated = NextIsAllocated &&
                                          ((StartVbo >= Scb->ValidDataToDisk) ||
                                           (FinalCompressedClusters == CompressionUnitInClusters) ||
                                           ((NextClusterCount < CompressionUnitInClusters) &&
                                            (!NtfsLookupAllocation( IrpContext,
                                                                    Scb,
                                                                    StartingVcn + NextClusterCount,
                                                                    &NextLbo,
                                                                    &TempClusterCount,
                                                                    NULL,
                                                                    NULL ) ||
                                             (NextLbo != UNUSED_LCN))));

                        //
                        //  If we are not keeping any allocation, or we need less
                        //  than a compression unit, then call NtfsDeleteAllocation.
                        //


                        if (!NextIsAllocated ||
                            (FinalCompressedClusters < CompressionUnitInClusters)) {

                            //
                            //  Skip this explicit delete if we are rewriting within
                            //  ValidDataToDisk.  We know we won't be doing a SplitMcb.
                            //

                            DeleteVcn = StartingVcn;

                            if (NextIsAllocated) {

                                DeleteVcn += FinalCompressedClusters;
                            }

                            DeleteCount = CompressionUnit;

                            if (CompressionUnit == 0) {

                                DeleteCount = ByteCount;
                            }

                            DeleteCount = LlClustersFromBytes( Vcb, DeleteCount );

                            //
                            //  Take the explicit DeleteAllocation path if there is a chance
                            //  we might do a SplitMcb.  This is true for a compressed write
                            //  which extends into a new compression unit.
                            //

                            if ((CompressionUnit != 0) &&

                                ((StartingVcn + DeleteCount) >
                                 LlClustersFromBytesTruncate( Vcb,
                                                              ((Scb->ValidDataToDisk + CompressionUnit - 1) &
                                                               ~((LONGLONG) (CompressionUnit - 1))) ))) {

                                NtfsDeleteAllocation( IrpContext,
                                                      IrpSp->FileObject,
                                                      Scb,
                                                      DeleteVcn,
                                                      StartingVcn + DeleteCount - 1,
                                                      TRUE,
                                                      FALSE );

                                //
                                //  Set the DeleteCount to 0 so we know there is no other deallocate
                                //  to do.
                                //

                                DeleteCount = 0;

                            //
                            //  Bias the DeleteCount by the number of clusters into the compression
                            //  unit we are beginning.
                            //

                            } else {

                                DeleteCount -= (DeleteVcn - StartingVcn);
                                ASSERT( DeleteCount >= 0 );
                            }

                            ChangeAllocation = TRUE;
                        }

                        Scb->ValidDataToDisk = SavedValidDataToDisk;
                    }

                    //
                    //  Now deal with the case where we do need to allocate space.
                    //

                    TempVbo = StartVbo;
                    if (FinalCompressedSize != 0) {

                        //
                        //  If this compression unit is not (sufficiently) allocated, then
                        //  do it now.
                        //

                        if (!NextIsAllocated ||
                            ((NextClusterCount < FinalCompressedClusters) && !SparseWrite)) {

                            AllocateCount = FinalCompressedClusters;

                        } else {

                            AllocateCount = 0;
                        }

                        //
                        //  Now call our reallocate routine to do the work.
                        //

                        if ((DeleteCount != 0) || (AllocateCount != 0)) {

#ifdef SYSCACHE_DEBUG
                            if (ScbIsBeingLogged( Scb )) {

                                FsRtlLogSyscacheEvent( Scb, SCE_ADD_ALLOCATION, SCE_FLAG_PREPARE_BUFFERS, StartingVcn, AllocateCount, DeleteCount );
                            }
#endif

                            NtfsReallocateRange( IrpContext,
                                                 Scb,
                                                 DeleteVcn,
                                                 DeleteCount,
                                                 StartingVcn,
                                                 AllocateCount,
                                                 NULL );

                            ChangeAllocation = TRUE;
                        }

                        //
                        //  If we added space, something may have moved, so we must
                        //  look up our position and get a new index. Also relookup
                        //  to get a rangeptr and index
                        //

                        NtfsLookupAllocation( IrpContext,
                                              Scb,
                                              StartingVcn,
                                              &NextLcn,
                                              &NextClusterCount,
                                              &RangePtr,
                                              &Index );

                        //
                        //  Now loop to update the IoRuns array.
                        //

                        CompressedOffset += FinalCompressedSize;
                        while (FinalCompressedSize != 0) {

                            LONGLONG RunOffset;

                            //
                            //  Get the actual number of clusters being written.
                            //

                            FinalCompressedClusters = ClustersFromBytes( Vcb, FinalCompressedSize );

                            //
                            //  Try to lookup the first run.  If there is just a single run,
                            //  we may just be able to pass it on.  Index into the Mcb directly
                            //  for greater speed.
                            //

                            NextIsAllocated = NtfsGetSequentialMcbEntry( &Scb->Mcb,
                                                                         &RangePtr,
                                                                         Index,
                                                                         &StartingVcn,
                                                                         &NextLcn,
                                                                         &NextClusterCount );

                            //
                            //  It is possible that we could walk across an Mcb boundary and the
                            //  following entry isn't loaded.  In that case we want to look the
                            //  up the allocation specifically to force the Mcb load.
                            //

                            if (Index == MAXULONG) {

                                //
                                //  A failure on NtfsGetSequentialMcbEntry above will modify StartingVcn.
                                //  Recalculate here based on TempVbo.
                                //

                                StartingVcn = LlClustersFromBytesTruncate( Vcb, TempVbo );
                                NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                                        Scb,
                                                                        StartingVcn,
                                                                        &NextLcn,
                                                                        &NextClusterCount,
                                                                        &RangePtr,
                                                                        &Index );

                                ASSERT( NextIsAllocated );
                                NextIsAllocated = NtfsGetSequentialMcbEntry( &Scb->Mcb,
                                                                             &RangePtr,
                                                                             Index,
                                                                             &StartingVcn,
                                                                             &NextLcn,
                                                                             &NextClusterCount );
                            }

                            Index += 1;

                            ASSERT(NextIsAllocated);
                            ASSERT(NextLcn != UNUSED_LCN);

                            //
                            //  Our desired Vcn could be in the middle of this run, so do
                            //  some adjustments.
                            //

                            RunOffset = Int64ShraMod32(TempVbo, Vcb->ClusterShift) - StartingVcn;

                            ASSERT( ((PLARGE_INTEGER)&RunOffset)->HighPart >= 0 );
                            ASSERT( NextClusterCount > RunOffset );

                            NextLcn = NextLcn + RunOffset;
                            NextClusterCount = NextClusterCount - RunOffset;

                            //
                            //  Adjust from NextLcn to Lbo.  NextByteCount may overflow out of 32 bits
                            //  but we will catch that below when we compare clusters.
                            //

                            NextLbo = LlBytesFromClusters( Vcb, NextLcn ) + ClusterOffset;
                            NextByteCount = BytesFromClusters( Vcb, (ULONG)NextClusterCount );

                            //
                            //  If next run is larger than we need, "ya get what you need".
                            //  Note that after this we are guaranteed that the HighPart of
                            //  NextByteCount is 0.
                            //

                            if (NextClusterCount >= FinalCompressedClusters) {

                                NextByteCount = FinalCompressedSize;
                            }

                            //
                            //  If the Lbos are contiguous, then we can do a contiguous
                            //  transfer, so we just increase the current byte count.
                            //  For compressed streams, note however that the BufferOffset
                            //  may not be contiguous!
                            //

                            if ((*NumberRuns != 0) &&
                                (NextLbo == (IoRuns[*NumberRuns - 1].StartingLbo +
                                                      IoRuns[*NumberRuns - 1].ByteCount)) &&
                                (BufferOffset == (IoRuns[*NumberRuns - 1].BufferOffset +
                                                      IoRuns[*NumberRuns - 1].ByteCount))) {

                                IoRuns[*NumberRuns - 1].ByteCount += NextByteCount;

                            //
                            //  Otherwise it is time to start a new run, if there is space for one.
                            //

                            } else {

                                //
                                //  If we have filled up the current I/O runs array, then we
                                //  will grow it once to a size which would allow the worst
                                //  case compression unit (all noncontiguous clusters) to
                                //  start at the penultimate index.  The following if
                                //  statement enforces this case as the worst case.  With 16
                                //  clusters per compression unit, the theoretical maximum
                                //  number of parallel I/Os would be 16 + NTFS_MAX_PARALLEL_IOS - 1,
                                //  since we stop on the first compression unit
                                //  boundary after the penultimate run.  Normally, of course we
                                //  will do much fewer.
                                //

                                if ((*NumberRuns == NTFS_MAX_PARALLEL_IOS) &&
                                    (CompressionContext->AllocatedRuns == NTFS_MAX_PARALLEL_IOS)) {

                                    PIO_RUN NewIoRuns;

                                    NewIoRuns = NtfsAllocatePool( NonPagedPool,
                                                                   (CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1) * sizeof(IO_RUN) );

                                    RtlCopyMemory( NewIoRuns,
                                                   CompressionContext->IoRuns,
                                                   NTFS_MAX_PARALLEL_IOS * sizeof(IO_RUN) );

                                    IoRuns = CompressionContext->IoRuns = NewIoRuns;
                                    CompressionContext->AllocatedRuns = CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1;
                                }

                                //
                                // We remember each piece of a parallel run by saving the
                                // essential information in the IoRuns array.  The tranfers
                                // will be started up in parallel below.
                                //

                                IoRuns[*NumberRuns].StartingVbo = TempVbo;
                                IoRuns[*NumberRuns].StartingLbo = NextLbo;
                                IoRuns[*NumberRuns].BufferOffset = BufferOffset;
                                IoRuns[*NumberRuns].ByteCount = NextByteCount;
                                *NumberRuns += 1;
                            }

                            //
                            // Now adjust everything for the next pass through the loop.
                            //

                            BufferOffset += NextByteCount;
                            TempVbo = TempVbo + NextByteCount;
                            FinalCompressedSize -= NextByteCount;
                            ClusterOffset = 0;
                        }

                    } else if (DeleteCount != 0) {

                        //
                        //  Call our reallocate routine.
                        //

                        NtfsReallocateRange( IrpContext,
                                             Scb,
                                             DeleteVcn,
                                             DeleteCount,
                                             0,
                                             0,
                                             NULL );

                        ChangeAllocation = TRUE;
                    }

                }

                //
                //  For the compressed stream, we need to advance the buffer offset to the
                //  end of a compression unit, so that if adjacent compression units are
                //  being written, we correctly advance over the unused clusters in the
                //  compressed stream.
                //


                if (FlagOn(StreamFlags, COMPRESSED_STREAM)) {
                    BufferOffset += CompressionUnit - (ULONG)(TempVbo & (CompressionUnit - 1));
                }

                //
                //  If this is the unnamed data stream then we need to update
                //  the total allocated size.
                //

                if (ChangeAllocation &&
                    FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    (Scb->Fcb->Info.AllocatedLength != Scb->TotalAllocated)) {

                    Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                    SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                }

                UncompressedOffset += CompressionUnit - CompressionUnitOffset;

                //
                //  Now reduce the byte counts by the compression unit we just
                //  transferred.
                //

                if ((CompressionUnit != 0) && (ByteCount > CompressionUnit)) {
                    StartVbo += (CompressionUnit - SparseFileBias);
                    ByteCount -= CompressionUnit;
                } else {
                    StartVbo += (ByteCount - SparseFileBias);
                    ByteCount = 0;
                    leave;
                }

                CompressionUnitOffset = 0;
            }

        } finally {

            NtfsUnpinBcb( IrpContext, &Bcb );
        }

        //
        //  See if we need to advance ValidDataToDisk.
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
            (StartVbo > Scb->ValidDataToDisk)) {

            ASSERT( (Scb->ScbSnapshot != NULL) && (Scb->ScbSnapshot->ValidDataToDisk == Scb->ValidDataToDisk) );
            Scb->ValidDataToDisk = StartVbo;
        }

        return ByteCount + ReturnByteCount;
    }
}


//
//  Internal support routine
//

NTSTATUS
NtfsFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN ULONG StreamFlags
    )

/*++

Routine Description:

    This routine performs post processing for noncached transfers of
    compressed or encrypted data.  For reads, the decompression actually takes
    place here.  For reads and writes, all necessary cleanup operations are
    performed.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    CompressionContext - Supplies information related to the compression
                         filled in by NtfsPrepareBuffers.

    StreamFlags - Supplies either 0 or some combination of COMPRESSED_STREAM
                  and ENCRYPTED_STREAM

Return Value:

    Status from the operation

--*/

{
    VCN CurrentVcn, NextVcn, BeyondLastVcn;
    LCN NextLcn;

    ULONG Run;

    ULONG NextByteCount;
    LONGLONG NextClusterCount;

    LARGE_INTEGER OffsetWithinFile;

    BOOLEAN NextIsAllocated;
    BOOLEAN AlreadyFilled;

    PVOID SystemBuffer = NULL;

    ULONG CompressionUnit, CompressionUnitInClusters;
    ULONG StartingOffset, UncompressedOffset, CompressedOffset;
    ULONG CompressedSize;
    LONGLONG UncompressedSize;

    LONGLONG CurrentAllocatedClusterCount;

    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    //
    //  If this is a normal termination of a read, then let's give him the
    //  data...
    //

    ASSERT( (Scb->CompressionUnit != 0) ||
            (Scb->EncryptionContext != NULL) ||
            FlagOn( StreamFlags, COMPRESSED_STREAM ) );

    //
    //  We never want to be here if this is the read raw encrypted data case.
    //

    ASSERT( !FlagOn( StreamFlags, ENCRYPTED_STREAM ) );

    if (IrpContext->MajorFunction == IRP_MJ_READ) {

        //
        //  If there is an encryption context then transform the data.
        //

        if ((Scb->EncryptionContext != NULL) &&
            (NtfsData.EncryptionCallBackTable.AfterReadProcess != NULL)) {

            ASSERT ( NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) );

            //
            //  If the compression context has a buffer then we will use that.
            //

            if (CompressionContext->CompressionBuffer != NULL) {

                SystemBuffer = CompressionContext->CompressionBuffer;

            } else {

                SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
            }

            //
            //  Now look at each run of real data heading coming from the disk and
            //  let the encryption driver decrypt it.
            //

            for ( Run = 0; Run < NumberRuns; Run++ ) {

                OffsetWithinFile.QuadPart = CompressionContext->IoRuns[Run].StartingVbo;

                Status = NtfsData.EncryptionCallBackTable.AfterReadProcess(
                                                Add2Ptr(SystemBuffer, CompressionContext->IoRuns[Run].BufferOffset),
                                                &OffsetWithinFile,
                                                CompressionContext->IoRuns[Run].ByteCount,
                                                Scb->EncryptionContext);

                if (!NT_SUCCESS( Status )) {

                    return Status;
                }
            }

            if (!NT_SUCCESS( Status )) {

                return Status;
            }
        }

        //
        //  There may be a compression unit but there is no completion to do
        //  i.e this is an uncompressed sparse file.
        //  We might be operating on an encrypted file as well.
        //  In either case just exit if the file is not compressed.
        //

        if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            if (SystemBuffer != NULL) {

                KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE );
            }

            return STATUS_SUCCESS;
        }

        ASSERT( Scb->CompressionUnit != 0 );
        if (!FlagOn( StreamFlags, COMPRESSED_STREAM )) {

            //
            //  Initialize remaining context for the loop.
            //

            CompressionUnit = Scb->CompressionUnit;
            CompressionUnitInClusters = ClustersFromBytes(Vcb, CompressionUnit);
            CompressedOffset = 0;
            UncompressedOffset = 0;
            Status = STATUS_SUCCESS;

            //
            //  Map the user buffer.
            //

            SystemBuffer = (PVOID)((PCHAR)CompressionContext->SystemBuffer +
                                          CompressionContext->SystemBufferOffset);


            //
            //  Calculate the first Vcn and offset within the compression
            //  unit of the start of the transfer, and lookup the first
            //  run.
            //

            StartingOffset = *((PULONG)StartingVbo) & (CompressionUnit - 1);
            CurrentVcn = LlClustersFromBytes(Vcb, *StartingVbo - StartingOffset);

            NextIsAllocated =
            NtfsLookupAllocation( IrpContext,
                                  Scb,
                                  CurrentVcn,
                                  &NextLcn,
                                  &CurrentAllocatedClusterCount,
                                  NULL,
                                  NULL );

            //
            //  Set NextIsAllocated and NextLcn as the Mcb package would, to show if
            //  we are off the end.
            //

            if (!NextIsAllocated) {
                NextLcn = UNUSED_LCN;
            }

            NextIsAllocated = (BOOLEAN)(CurrentAllocatedClusterCount < (MAXLONGLONG - CurrentVcn));

            //
            //  If this is actually a hole or there was no entry in the Mcb, then
            //  set CurrentAllocatedClusterCount to zero so we will always make the first
            //  pass in the embedded while loop below.
            //

            if (!NextIsAllocated || (NextLcn == UNUSED_LCN)) {
                CurrentAllocatedClusterCount = 0;
            }

            //
            //  Prepare for the initial Mcb scan below by pretending that the
            //  next run has been looked up, and is a contiguous run of 0 clusters!
            //

            NextVcn = CurrentVcn + CurrentAllocatedClusterCount;
            NextClusterCount = 0;

            //
            //  Remember the last Vcn we should look up.
            //

            BeyondLastVcn = BlockAlign( *StartingVbo + ByteCount, (LONG)CompressionUnit );
            BeyondLastVcn = LlClustersFromBytesTruncate( Vcb, BeyondLastVcn );

            //
            //  Loop to return the data.
            //

            while (ByteCount != 0) {

                //
                //  Loop to determine the compressed size of the next compression
                //  unit.  I.e., loop until we either find the end of the current
                //  range of contiguous Vcns, or until we find that the current
                //  compression unit is fully allocated.
                //

                while (NextIsAllocated &&
                       (CurrentAllocatedClusterCount < CompressionUnitInClusters) &&
                       ((CurrentVcn + CurrentAllocatedClusterCount) == NextVcn)) {

                    if ((CurrentVcn + CurrentAllocatedClusterCount) > NextVcn) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }

                    CurrentAllocatedClusterCount = CurrentAllocatedClusterCount + NextClusterCount;

                    //
                    //  Loop to find the next allocated Vcn, or the end of the Mcb.
                    //  None of the interfaces using RangePtr and Index as inputs
                    //  can be used here, such as NtfsGetSequentialMcbEntry, because
                    //  we do not have the Scb main resource acquired, and writers can
                    //  be moving stuff around in parallel.
                    //

                    while (TRUE) {

                        //
                        //  Set up NextVcn for next call
                        //

                        NextVcn += NextClusterCount;

                        //
                        //  Exit if we are past the end of the range being decompressed.
                        //

                        if (NextVcn >= BeyondLastVcn) {

                            NextIsAllocated = TRUE;
                            break;
                        }

                        NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                                Scb,
                                                                NextVcn,
                                                                &NextLcn,
                                                                &NextClusterCount,
                                                                NULL,
                                                                NULL );

                        //
                        //  Set NextIsAllocated and NextLcn as the Mcb package would, to show if
                        //  we are off the end.
                        //

                        if (!NextIsAllocated) {
                            NextLcn = UNUSED_LCN;
                        }

                        NextIsAllocated = (BOOLEAN)(NextClusterCount < (MAXLONGLONG - NextVcn));

                        //
                        //  Get out if we hit the end or see something allocated.
                        //

                        if (!NextIsAllocated || (NextLcn != UNUSED_LCN)) {
                            break;
                        }
                    }
                }

                //
                //  The compression unit is fully allocated.
                //

                if (CurrentAllocatedClusterCount >= CompressionUnitInClusters) {

                    CompressedSize = CompressionUnit;
                    CurrentAllocatedClusterCount = CurrentAllocatedClusterCount - CompressionUnitInClusters;

                //
                //  Otherwise calculate how much is allocated at the current Vcn
                //  (if any).
                //

                } else {

                    CompressedSize = BytesFromClusters(Vcb, (ULONG)CurrentAllocatedClusterCount);
                    CurrentAllocatedClusterCount = 0;
                }

                //
                //  The next time through this loop, we will be working on the next
                //  compression unit.
                //

                CurrentVcn = CurrentVcn + CompressionUnitInClusters;

                //
                //  Calculate uncompressed size of the desired fragment, or
                //  entire compression unit.
                //

                NtfsAcquireFsrtlHeader( Scb );
                UncompressedSize = Scb->Header.FileSize.QuadPart -
                                   (*StartingVbo + UncompressedOffset);
                NtfsReleaseFsrtlHeader( Scb );

                if (UncompressedSize > CompressionUnit) {
                    (ULONG)UncompressedSize = CompressionUnit;
                }

                //
                //  Calculate how much we want now, based on StartingOffset and
                //  ByteCount.
                //

                NextByteCount = CompressionUnit - StartingOffset;
                if (NextByteCount > ByteCount) {
                    NextByteCount = ByteCount;
                }

                //
                //  Practice safe access
                //

                try {

                    //
                    //  There were no clusters allocated, return 0's.
                    //

                    AlreadyFilled = FALSE;
                    if (CompressedSize == 0) {

                        RtlZeroMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                       NextByteCount );

                    //
                    //  The compression unit was fully allocated, just copy.
                    //

                    } else if (CompressedSize == CompressionUnit) {

                        RtlCopyMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                       CompressionContext->CompressionBuffer +
                                         CompressedOffset + StartingOffset,
                                       NextByteCount );

                    //
                    //  Caller does not want the entire compression unit, decompress
                    //  a fragment.
                    //

                    } else if (NextByteCount < CompressionUnit) {

                        //
                        //  If we have not already allocated the workspace, then do it.
                        //

                        if (CompressionContext->WorkSpace == NULL) {
                            ULONG CompressWorkSpaceSize;
                            ULONG FragmentWorkSpaceSize;

                            ASSERT((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) != 0);

                            (VOID) RtlGetCompressionWorkSpaceSize( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                                   &CompressWorkSpaceSize,
                                                                   &FragmentWorkSpaceSize );

                            //
                            //  Allocate first from non-paged, then paged.  The typical
                            //  size of this workspace is just over a single page so
                            //  if both allocations fail then the system is running
                            //  a reduced capacity.  Return an error to the user
                            //  and let him retry.
                            //

                            CompressionContext->WorkSpace = NtfsAllocatePoolWithTagNoRaise( NonPagedPool, FragmentWorkSpaceSize, 'wftN' );

                            if (CompressionContext->WorkSpace == NULL) {

                                CompressionContext->WorkSpace =
                                    NtfsAllocatePool( PagedPool, FragmentWorkSpaceSize );
                            }
                        }

                        while (TRUE) {

                            Status =
                            RtlDecompressFragment( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                   (PUCHAR)SystemBuffer + UncompressedOffset,
                                                   NextByteCount,
                                                   CompressionContext->CompressionBuffer + CompressedOffset,
                                                   CompressedSize,
                                                   StartingOffset,
                                                   (PULONG)&UncompressedSize,
                                                   CompressionContext->WorkSpace );

                            ASSERT(NT_SUCCESS( Status ) || !NtfsStopOnDecompressError);

                            if (NT_SUCCESS(Status)) {

                                RtlZeroMemory( (PUCHAR)SystemBuffer + UncompressedOffset + (ULONG)UncompressedSize,
                                               NextByteCount - (ULONG)UncompressedSize );
                                break;

                            } else {

                                //
                                //  The compressed buffer could have been bad.  We need to fill
                                //  it with a pattern and get on with life.  Someone could be
                                //  faulting it in just to overwrite it, or it could be a rare
                                //  case of corruption.  We fill the data with a pattern, but
                                //  we must return success so a pagefault will succeed.  We
                                //  do this once, then loop back to decompress what we can.
                                //

                                Status = STATUS_SUCCESS;

                                if (!AlreadyFilled) {

                                    RtlFillMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                                   NextByteCount,
                                                   0xDF );
                                    AlreadyFilled = TRUE;

                                } else {
                                    break;
                                }
                            }
                        }

                    //
                    //  Decompress the entire compression unit.
                    //

                    } else {

                        ASSERT( StartingOffset == 0 );

                        while (TRUE) {

                            Status =
                            RtlDecompressBuffer( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                 (PUCHAR)SystemBuffer + UncompressedOffset,
                                                 NextByteCount,
                                                 CompressionContext->CompressionBuffer + CompressedOffset,
                                                 CompressedSize,
                                                 (PULONG)&UncompressedSize );

                            ASSERT(NT_SUCCESS( Status ) || !NtfsStopOnDecompressError);

                            if (NT_SUCCESS(Status)) {

                                RtlZeroMemory( (PUCHAR)SystemBuffer + UncompressedOffset + (ULONG)UncompressedSize,
                                               NextByteCount - (ULONG)UncompressedSize );
                                break;

                            } else {

                                //
                                //  The compressed buffer could have been bad.  We need to fill
                                //  it with a pattern and get on with life.  Someone could be
                                //  faulting it in just to overwrite it, or it could be a rare
                                //  case of corruption.  We fill the data with a pattern, but
                                //  we must return success so a pagefault will succeed.  We
                                //  do this once, then loop back to decompress what we can.
                                //

                                Status = STATUS_SUCCESS;

                                if (!AlreadyFilled) {

                                    RtlFillMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                                   NextByteCount,
                                                   0xDB );
                                    AlreadyFilled = TRUE;

                                } else {
                                    break;
                                }
                            }
                        }
                    }

                //
                //  If its an unexpected error then
                //  Probably Gary's decompression routine faulted, but blame it on
                //  the user buffer!
                //

                } except(NtfsCompressionFilter(IrpContext, GetExceptionInformation())) {

                      Status = GetExceptionCode();
                      if (!FsRtlIsNtstatusExpected( Status )) {
                          Status = STATUS_INVALID_USER_BUFFER;
                      }
                }

                if (!NT_SUCCESS(Status)) {
                    break;
                }

                //
                //  Advance these fields for the next pass through.
                //

                StartingOffset = 0;
                UncompressedOffset += NextByteCount;
                CompressedOffset += CompressedSize;
                ByteCount -= NextByteCount;
            }

            //
            //  We now flush the user's buffer to memory.
            //

            KeFlushIoBuffers( CompressionContext->SavedMdl, TRUE, FALSE );
        }

    //
    //  For compressed writes we just checkpoint the transaction and
    //  free all snapshots and resources, then get the Scb back.  Only do this if the
    //  request is for the same Irp as the original Irp.  We don't want to checkpoint
    //  if called from NtfsWriteClusters.
    //

    } else if (Irp == IrpContext->OriginatingIrp) {

        if (CompressionContext->ScbAcquired) {

            BOOLEAN Reinsert = FALSE;

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  We want to empty the exclusive Fcb list but still hold
            //  the current file.  Go ahead and remove it from the exclusive
            //  list and reinsert it after freeing the other entries.
            //

            while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                //
                //  If this is the Scb for this Fcb then remove it from the list.
                //  We have to preserve the number of times this Fcb may have been
                //  acquired outside of PrepareBuffers.
                //

                if ((PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                             FCB,
                                             ExclusiveFcbLinks ) == Scb->Fcb) {

                    RemoveEntryList( &Scb->Fcb->ExclusiveFcbLinks );
                    Reinsert = TRUE;

                } else {

                    NtfsReleaseFcb( IrpContext,
                                    (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                            FCB,
                                                            ExclusiveFcbLinks ));
                }
            }

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                          IRP_CONTEXT_FLAG_RELEASE_MFT );

            if (Reinsert) {

                InsertHeadList( &IrpContext->ExclusiveFcbList,
                                &Scb->Fcb->ExclusiveFcbLinks );

                //
                //  Release the Scb if we acquired it in PrepareBuffers.  It is
                //  important that we have released the Scb before going back
                //  and faulting into the data section.  Otherwise we could
                //  hit a collided page fault deadlock.
                //

                NtfsReleaseScb( IrpContext, Scb );
                CompressionContext->ScbAcquired = FALSE;
            }
        }
    }

    return Status;
}


PMDL
NtfsLockFileRange (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This function maps the given range of file into the cachemanager space and
    then probes and locks it down

Arguments:

    Scb - Supplies the stream file to act on.

    Offset - The starting point to be probed and locked

    Length - The lengh of the operation.

Return Value:

    PMDL - a mdl representing the locked area - this mdl must be unlocked and freed by the caller

--*/

{
    NTSTATUS Status;
    PBCB Bcb;
    PVOID Buffer;
    PMDL Mdl = NULL;

    //
    //  File must be cached
    //

    ASSERT( Scb->FileObject != NULL);

    //
    //  Map the offset into the address space
    //

    CcMapData( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, TRUE, &Bcb, &Buffer );

#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    //
    //  Lock the data into memory Don't tell Mm here that we plan to write it, as he sets
    //  dirty now and at the unlock below if we do.
    //

    try {

        //
        //  Now attempt to allocate an Mdl to describe the mapped data.
        //

        Mdl = IoAllocateMdl( Buffer, Length, FALSE, FALSE, NULL );

        if (Mdl == NULL) {
            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );

    //
    //  Catch any raises here and clean up appropriately.
    //

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();

        CcUnpinData( Bcb );

#ifdef MAPCOUNT_DBG
        IrpContext->MapCount--;
#endif

        if (Mdl != NULL) {

            IoFreeMdl( Mdl );
            Mdl = NULL;
        }

        NtfsRaiseStatus( IrpContext,
                         FsRtlIsNtstatusExpected(Status) ? Status : STATUS_UNEXPECTED_IO_ERROR,
                         NULL,
                         NULL );
    }

    CcUnpinData( Bcb );

#ifdef MAPCOUNT_DBG
    IrpContext->MapCount--;
#endif

    return Mdl;
}


VOID
NtfsZeroEndOfSector (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN BOOLEAN Cached
    )
/*++

Routine Description:

    This function zeroes from the given offset to the next sector boundary directly
    onto disk.  Particularly if the file is cached the caller must synchronize in some fashion
    to prevent the sector from being written at the same time through other paths.  I.e
    own ioateof or paging exclusive.  Also this only be called with non sparse / non compressed files


Arguments:

    Scb - Supplies the stream file to act on.

    Offset - The starting offset to zero to its sector boundary

Return Value:

    None - raises on error

--*/
{
    PVCB Vcb = Scb->Fcb->Vcb;
    ULONG BufferLength = Vcb->BytesPerSector;
    PMDL Mdl = NULL;
    PMDL OriginalMdl = Irp->MdlAddress;
    PVOID Buffer = NULL;
    LCN Lcn;
    LONGLONG ClusterCount;
    LONGLONG LogicalOffset;
    LONGLONG VirtualOffset;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS Status;
    LOGICAL Wait = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    ASSERT( !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) );

    //
    //  Decide whether to use cached or noncached path
    //

    if (Cached) {

        NtfsCreateMdlAndBuffer( IrpContext,
                                Scb,
                                RESERVED_BUFFER_ONE_NEEDED,
                                &BufferLength,
                                &Mdl,
                                &Buffer );

        try {

            RtlZeroMemory( Buffer, Vcb->BytesPerSector - (LONG)(Offset % Vcb->BytesPerSector) );
            CcCopyWrite( IrpSp->FileObject, (PLARGE_INTEGER)&Offset, Vcb->BytesPerSector - (LONG)(Offset % Vcb->BytesPerSector), TRUE, Buffer );

        } finally {
            NtfsDeleteMdlAndBuffer( Mdl, Buffer );
        }

    } else {

        //
        //  Find the lcn that contains the cluster in question
        //

        if (NtfsLookupAllocation( IrpContext, Scb, LlClustersFromBytesTruncate( Vcb, Offset ), &Lcn, &ClusterCount, NULL, NULL )) {

            try {

                //
                //  Set calls to be temp. synchronous
                //

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                NtfsCreateMdlAndBuffer( IrpContext,
                                        Scb,
                                        RESERVED_BUFFER_ONE_NEEDED,
                                        &BufferLength,
                                        &Mdl,
                                        &Buffer );
                Irp->MdlAddress = Mdl;

                //
                //  The logical offset on disk is at the lcn we found + the offset within that cluster of the
                //  offset rounded down to the nearest sector
                //

                LogicalOffset = LlBytesFromClusters( Vcb, Lcn ) + Offset - BlockAlignTruncate( Offset, (LONG)Vcb->BytesPerCluster );
                LogicalOffset = BlockAlignTruncate( LogicalOffset, (LONG)Vcb->BytesPerSector );

                //
                //  First read the sector
                //

                NtfsSingleAsync( IrpContext,
                                 Vcb->TargetDeviceObject,
                                 LogicalOffset,
                                 Vcb->BytesPerSector,
                                 Irp,
                                 IRP_MJ_READ,
                                 0 );

                NtfsWaitSync( IrpContext );

                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                    &Irp->IoStatus.Status,
                                                    TRUE,
                                                    STATUS_UNEXPECTED_IO_ERROR );

                //
                //  Decrypt the buffer if its encrypted
                //

                if ((Scb->EncryptionContext != NULL) &&
                    (NtfsData.EncryptionCallBackTable.AfterReadProcess != NULL)) {


                    VirtualOffset = BlockAlignTruncate( Offset, (LONG)Vcb->BytesPerSector );

                    Status = NtfsData.EncryptionCallBackTable.AfterReadProcess( Buffer,
                                                                                (PLARGE_INTEGER)&VirtualOffset,
                                                                                Vcb->BytesPerSector,
                                                                                Scb->EncryptionContext );

                    if (!NT_SUCCESS( Status )) {

                        NtfsRaiseStatus( IrpContext, Status, &Scb->Fcb->FileReference, Scb->Fcb );
                    }
                }

                //
                //  Clear return info field
                //

                Irp->IoStatus.Information = 0;

                //
                //  Zero out the remainder of the sector
                //

                RtlZeroMemory( Add2Ptr( Buffer, (LONG)(Offset % Vcb->BytesPerSector )),  Vcb->BytesPerSector - (LONG)(Offset % Vcb->BytesPerSector) );


                //
                //  Re-ecrypt the buffer if its encrypted
                //

                if ((Scb->EncryptionContext != NULL) &&
                    (NtfsData.EncryptionCallBackTable.BeforeWriteProcess != NULL)) {

                    Status = NtfsData.EncryptionCallBackTable.BeforeWriteProcess( Buffer,
                                                                                  Buffer,
                                                                                  (PLARGE_INTEGER)&VirtualOffset,
                                                                                  Vcb->BytesPerSector,
                                                                                  Scb->EncryptionContext );
                    if (!NT_SUCCESS( Status )) {

                        NtfsRaiseStatus( IrpContext, Status, &Scb->Fcb->FileReference, Scb->Fcb );
                    }
                }

                //
                //  Rewrite the sector back down
                //

                NtfsSingleAsync( IrpContext,
                                 Vcb->TargetDeviceObject,
                                 LogicalOffset,
                                 Vcb->BytesPerSector,
                                 Irp,
                                 IRP_MJ_WRITE,
                                 0 );

                NtfsWaitSync( IrpContext );

            } finally {

                //
                //  Reset to original wait state
                //

                if (!Wait) {
                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
                }

                NtfsDeleteMdlAndBuffer( Mdl, Buffer );
                Irp->MdlAddress = OriginalMdl;
            }
        }

    }

    return;
}


NTSTATUS
NtfsNonCachedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    The choice of a single run is made if possible, otherwise multiple runs
    are executed.

    Sparse files are supported.  If "holes" are encountered, then the user
    buffer is zeroed over the specified range.  This should only happen on
    reads during normal operation, but it can also happen on writes during
    restart, in which case it is also appropriate to zero the buffer.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    StreamFlags - Supplies either 0 or some combination of COMPRESSED_STREAM
                  and ENCRYPTED_STREAM

Return Value:

    None.

--*/

{
    ULONG OriginalByteCount, RemainingByteCount;
    ULONG NumberRuns;
    IO_RUN IoRuns[NTFS_MAX_PARALLEL_IOS];
    COMPRESSION_CONTEXT CompressionContext;
    NTSTATUS Status = STATUS_SUCCESS;
    PMDL Mdl = NULL;
    LONGLONG LfsStartingVbo;

    PVCB Vcb = Scb->Fcb->Vcb;

    BOOLEAN Wait;
    UCHAR IrpSpFlags = 0;

#ifdef PERF_STATS
    BOOLEAN CreateNewFile = FALSE;
    BOOLEAN TrackIos = FALSE;
    LARGE_INTEGER StartIo;
    LARGE_INTEGER Now;
    PTOP_LEVEL_CONTEXT TopLevelContext = NtfsGetTopLevelContext();
#endif

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsNonCachedIo\n") );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Scb           = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("StartingVbo   = %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );

    //
    //  Initialize some locals.
    //

    OriginalByteCount = ByteCount;

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Check if we need to do sequential writes.
    //

    if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
        FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE )) {

        IrpSpFlags = SL_FT_SEQUENTIAL_WRITE | SL_WRITE_THROUGH;
    }

#ifdef PERF_STATS
    {
        if ((ULONG_PTR)TopLevelContext >= FSRTL_MAX_TOP_LEVEL_IRP_FLAG &&
            (ULONG_PTR)TopLevelContext != (FSRTL_CACHE_TOP_LEVEL_IRP | 0x80000000)) {

            if (TopLevelContext->SavedTopLevelIrp &&
                (ULONG_PTR)TopLevelContext->SavedTopLevelIrp >= FSRTL_MAX_TOP_LEVEL_IRP_FLAG &&
                (ULONG_PTR)TopLevelContext->SavedTopLevelIrp != (FSRTL_CACHE_TOP_LEVEL_IRP | 0x80000000) &&
                (((PTOP_LEVEL_CONTEXT)TopLevelContext->SavedTopLevelIrp)->Ntfs == 0x5346544e)) {
                
                TopLevelContext = (PTOP_LEVEL_CONTEXT) TopLevelContext->SavedTopLevelIrp;
            }
            
            if ((TopLevelContext->ThreadIrpContext->MajorFunction == IRP_MJ_CREATE) &&
                (TopLevelContext->ThreadIrpContext->MinorFunction == IRP_MN_CREATE_NEW)) {

                CreateNewFile = TRUE;  
            }

            if (FlagOn( TopLevelContext->ThreadIrpContext->State, IRP_CONTEXT_STATE_TRACK_IOS )) {
                TrackIos = TRUE;    
            }
        }
    }
    
#endif

    //
    //  Prepare the (first set) of buffers for I/O.
    //

    RtlZeroMemory( &CompressionContext, sizeof(COMPRESSION_CONTEXT) );
    CompressionContext.IoRuns = IoRuns;
    CompressionContext.AllocatedRuns = NTFS_MAX_PARALLEL_IOS;
    CompressionContext.FinishBuffersNeeded =
        ((Scb->CompressionUnit != 0) || (Scb->EncryptionContext != NULL)) && 
        !FlagOn( StreamFlags, ENCRYPTED_STREAM );

    try {

        //
        //  If this is a write to a compressed file, we want to make sure here
        //  that any fragments of compression units get locked in memory, so
        //  no one will be reading them into the cache while we are mucking with
        //  the Mcb, etc.  We do this right here at the top so that we have
        //  more stack(!), and we get this over with before we have to acquire
        //  the Scb exclusive.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (Scb->CompressionUnit != 0) &&
            FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            LONGLONG TempOffset;
            LONGLONG TempRange;
            ULONG CompressionUnit = Scb->CompressionUnit;

#ifdef  COMPRESS_ON_WIRE

            //
            //  For a compressed stream, just make sure the stream exists.
            //

            if (FlagOn( StreamFlags, COMPRESSED_STREAM )) {

                if (Scb->Header.FileObjectC == NULL) {
                    NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );

                    //
                    //  If there is no one who will cause this stream to
                    //  be dereferenced then add an entry on the delayed
                    //  close queue for this.  We can do this test without
                    //  worrying about synchronization since it is OK to have
                    //  an extra entry in the delayed queue.
                    //

                    if ((Scb->CleanupCount == 0) &&
                        (Scb->Fcb->DelayedCloseCount == 0)) {

                        NtfsAddScbToFspClose( IrpContext, Scb, TRUE );
                    }
                }
            //
            //  This better be paging I/O, because we ignore the caller's buffer
            //  and write the entire compression unit out of the section.
            //
            //  We don't want to map in the data in the case where we are called
            //  from write clusters because MM is creating the section for the
            //  file.  Otherwise we will deadlock when Cc tries to create the
            //  section.
            //

            }

#endif

            if (

#ifdef  COMPRESS_ON_WIRE
                !FlagOn( StreamFlags, COMPRESSED_STREAM ) &&
#endif
                ((Irp == IrpContext->OriginatingIrp) ||
                 (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL))) {

                PMDL *TempMdl;

                if (Scb->FileObject == NULL) {
                    NtfsCreateInternalAttributeStream( IrpContext,
                                                       Scb,
                                                       FALSE,
                                                       &NtfsInternalUseFile[NONCACHEDIO_FILE_NUMBER] );

                    //
                    //  If there is no one who will cause this stream to
                    //  be dereferenced then add an entry on the delayed
                    //  close queue for this.  We can do this test without
                    //  worrying about synchronization since it is OK to have
                    //  an extra entry in the delayed queue.
                    //

                    if ((Scb->CleanupCount == 0) &&
                        (Scb->Fcb->DelayedCloseCount == 0)) {

                        NtfsAddScbToFspClose( IrpContext, Scb, TRUE );
                    }
                }

                //
                //  Lock the entire range rounded to its compression unit boundaries
                //  First round the start of the range down to a compression unit and then
                //  round the top of the range up to one
                //

                TempOffset = BlockAlignTruncate( StartingVbo, (LONG)CompressionUnit );
                TempRange = BlockAlign( StartingVbo + ByteCount, (LONG)CompressionUnit );

                TempMdl = &Mdl;

                do {

                    LONGLONG MapBoundary;
                    ULONG Range;

                    MapBoundary = BlockAlign( TempOffset + 1, VACB_MAPPING_GRANULARITY );
                    Range = (ULONG) min( TempRange - TempOffset, MapBoundary - TempOffset );

                    *TempMdl = NtfsLockFileRange( IrpContext,
                                                  Scb,
                                                  TempOffset,
                                                  Range );

                    TempOffset += Range;
                    TempMdl = &((*TempMdl)->Next );

                } while ( TempOffset != TempRange );

            } else {

                //
                //  This had better be a convert to non-resident.
                //

                ASSERT( StartingVbo == 0 );
                ASSERT( ByteCount <= Scb->CompressionUnit );
            }
        }

        //
        //  Check if need to trim the write for the log file.
        //

        if ((PAGE_SIZE != LFS_DEFAULT_LOG_PAGE_SIZE) &&
            (Scb == Vcb->LogFileScb) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE)) {

            LfsStartingVbo = StartingVbo;
            LfsCheckWriteRange( &Vcb->LfsWriteData, &LfsStartingVbo, &ByteCount );

            //
            //  If the byte count is now zero then exit this routine.
            //

            if (ByteCount == 0) {

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = ByteCount;
                DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> %08lx\n", Irp->IoStatus.Status) );
                try_return( Status = Irp->IoStatus.Status );
            }

            //
            //  Adjust the buffer offset in the compression context if necessary.
            //

            CompressionContext.SystemBufferOffset = (ULONG) (LfsStartingVbo - StartingVbo);
            StartingVbo = LfsStartingVbo;
        }

        RemainingByteCount = NtfsPrepareBuffers( IrpContext,
                                                 Irp,
                                                 Scb,
                                                 &StartingVbo,
                                                 ByteCount,
                                                 StreamFlags,
                                                 &Wait,
                                                 &NumberRuns,
                                                 &CompressionContext );

        //
        //  If we are writing to an encrypted stream, now is the
        //  time to do the encryption, before we pass the buffer
        //  down to the disk driver below us.
        //

        if ((Scb->EncryptionContext != NULL) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (NtfsData.EncryptionCallBackTable.BeforeWriteProcess != NULL) &&
            (!FlagOn( StreamFlags, ENCRYPTED_STREAM ))) {

            ASSERT ( NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) );
            ASSERT( NumberRuns > 0 );

            NtfsEncryptBuffers( IrpContext,
                                Irp,
                                Scb,
                                StartingVbo,
                                NumberRuns,
                                &CompressionContext );
        }

        ASSERT( RemainingByteCount < ByteCount );

        if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
            CollectDiskIoStats(Vcb, Scb, IrpContext->MajorFunction, NumberRuns);
        }

        //
        //  See if the write covers a single valid run, and if so pass
        //  it on.  Notice that if there is a single run but it does not
        //  begin at the beginning of the buffer then we will still need to
        //  allocate an associated Irp for this.
        //

        if ((RemainingByteCount == 0) &&
            (((NumberRuns == 1) &&
              (CompressionContext.IoRuns[0].BufferOffset == 0)) ||

            (NumberRuns == 0))) {

            DebugTrace( 0, Dbg, ("Passing Irp on to Disk Driver\n") );

            //
            //  See if there is an allocated run
            //

            if (NumberRuns == 1) {

                DebugTrace( 0, Dbg, ("One run\n") );

                //
                //  Now set up the Irp->IoStatus.  It will be modified by the
                //  completion routine in case of error or verify required.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;

                //
                //  We will continously try the I/O if we get a verify required
                //  back and can verify the volume
                //

                while (TRUE) {

                    //
                    //  Do the I/O and wait for it to finish
                    //

#ifdef PERF_STATS
                    if (TrackIos) {
                        TopLevelContext->ThreadIrpContext->Ios += 1;
                    }
                        
                    if (CreateNewFile) {
                    
                        InterlockedIncrement( &IrpContext->Vcb->IosPerCreates );
                        //KeQueryTickCount( &StartIo );
                        StartIo = KeQueryPerformanceCounter( NULL );
                    }
#endif

                    NtfsSingleAsync( IrpContext,
                                     Vcb->TargetDeviceObject,
                                     CompressionContext.IoRuns[0].StartingLbo,
                                     CompressionContext.IoRuns[0].ByteCount,
                                     Irp,
                                     IrpContext->MajorFunction,
                                     IrpSpFlags );

                    //
                    //  If this is an asynch transfer we return STATUS_PENDING.
                    //

                    if (!Wait) {

                        DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> STATUS_PENDING\n") );
                        try_return(Status = STATUS_PENDING);

                    } else {

                        NtfsWaitSync( IrpContext );

#ifdef PERF_STATS
                        if (CreateNewFile) {

                            //KeQueryTickCount( &Now );
                            Now = KeQueryPerformanceCounter( NULL );
                            IrpContext->Vcb->TimePerCreateIos += Now.QuadPart - StartIo.QuadPart;
                    
                        }
#endif

                    }

                    //
                    //  If we didn't get a verify required back then break out of
                    //  this loop
                    //

                    if (Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED) { break; }

                    //
                    //  Otherwise we need to verify the volume, and if it doesn't
                    //  verify correctly the we dismount the volume and raise our
                    //  error
                    //

                    if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                        //**** NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                        ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_INVALID, NULL, NULL );
                    }

                    //
                    //  The volume verified correctly so now clear the verify bit
                    //  and try and I/O again
                    //

                    ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

                    //
                    //  Reset the status before retrying.
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                }

                //
                //  See if we need to do a hot fix.  Hotfix if the request failed
                //  (except if called from WriteClusters) or we couldn't revert
                //  a USA block.
                //

                if ((!FT_SUCCESS( Irp->IoStatus.Status ) &&
                     ((IrpContext->MajorFunction != IRP_MJ_WRITE) ||
                      (Irp == IrpContext->OriginatingIrp))) ||
                    (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) &&
                     (IrpContext->MajorFunction == IRP_MJ_READ) &&
                     !NtfsVerifyAndRevertUsaBlock( IrpContext,
                                                   Scb,
                                                   Irp,
                                                   NULL,
                                                   0,
                                                   OriginalByteCount,
                                                   StartingVbo ))) {

                    //
                    //  Try to fix the problem
                    //

                    NtfsFixDataError( IrpContext,
                                      Scb,
                                      Vcb->TargetDeviceObject,
                                      Irp,
                                      1,
                                      CompressionContext.IoRuns,
                                      IrpSpFlags );
                }

            //
            //  Show that we successfully read zeros for the deallocated range.
            //

            } else {

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = ByteCount;
            }

            DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> %08lx\n", Irp->IoStatus.Status) );
            try_return( Status = Irp->IoStatus.Status );
        }

        //
        //  If there are bytes remaining and we cannot wait, then we must
        //  post this request unless we are doing paging io.
        //

        if (!Wait && (RemainingByteCount != 0)) {

            if (!FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            Wait = TRUE;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

            ClearFlag( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_ASYNC );
            KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                               NotificationEvent,
                               FALSE );
        }

        //
        //  Now set up the Irp->IoStatus.  It will be modified by the
        //  multi-completion routine in case of error or verify required.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Loop while there are still byte writes to satisfy.
        //

        while (TRUE) {

            //
            //  We will continously try the I/O if we get a verify required
            //  back and can verify the volume.  Note that we could have ended
            //  on a hole, and have no runs left.
            //

            if (NumberRuns != 0) {

                while (TRUE) {

#ifdef PERF_STATS

                    if (TrackIos) {
                        TopLevelContext->ThreadIrpContext->Ios += 1;
                    }

                    if (CreateNewFile) {
                    
                        
                        InterlockedIncrement( &IrpContext->Vcb->IosPerCreates );
                        //KeQueryTickCount( &StartIo );
                        StartIo = KeQueryPerformanceCounter( NULL );
                    }
#endif

                    //
                    //  Do the I/O and wait for it to finish
                    //

                    NtfsMultipleAsync( IrpContext,
                                       Vcb->TargetDeviceObject,
                                       Irp,
                                       NumberRuns,
                                       CompressionContext.IoRuns,
                                       IrpSpFlags );

                    //
                    //  If this is an asynchronous transfer, then return STATUS_PENDING.
                    //

                    if (!Wait) {

                        DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> STATUS_PENDING\n") );
                        try_return( Status = STATUS_PENDING );
                    }

                    NtfsWaitSync( IrpContext );

#ifdef PERF_STATS
                    if (CreateNewFile) {

//                        KeQueryTickCount( &Now );
                        Now = KeQueryPerformanceCounter( NULL );
                        IrpContext->Vcb->TimePerCreateIos += Now.QuadPart - StartIo.QuadPart;
                    }
#endif

#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb ) && (IrpContext->MajorFunction == IRP_MJ_WRITE)) {
                            FsRtlLogSyscacheEvent( Scb, SCE_WRITE, SCE_FLAG_SUB_WRITE, CompressionContext.IoRuns[NumberRuns-1].StartingVbo, CompressionContext.IoRuns[NumberRuns-1].ByteCount, Irp->IoStatus.Status );
                        }
#endif
                        //
                        //  If we didn't get a verify required back then break out of
                        //  this loop
                        //

                    if (Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED) { break; }

                    //
                    //  Otherwise we need to verify the volume, and if it doesn't
                    //  verify correctly the we dismount the volume and raise our
                    //  error
                    //

                    if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                        //**** NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                        ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_INVALID, NULL, NULL );
                    }

                    //
                    //  The volume verified correctly so now clear the verify bit
                    //  and try and I/O again
                    //

                    ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

                    //
                    //  Reset the status before retrying.
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                }

                //
                //  See if we need to do a hot fix.  Hotfix if the request failed
                //  (except if called from WriteClusters) or we couldn't revert
                //  a USA block.
                //

                if ((!FT_SUCCESS( Irp->IoStatus.Status ) &&
                     ((IrpContext->MajorFunction != IRP_MJ_WRITE) ||
                      (Irp == IrpContext->OriginatingIrp))) ||
                    (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) &&
                     (IrpContext->MajorFunction == IRP_MJ_READ) &&
                     !NtfsVerifyAndRevertUsaBlock( IrpContext,
                                                   Scb,
                                                   Irp,
                                                   NULL,
                                                   CompressionContext.IoRuns[0].BufferOffset,
                                                   OriginalByteCount -
                                                   CompressionContext.IoRuns[0].BufferOffset -
                                                   RemainingByteCount,
                                                   StartingVbo ))) {

                    //
                    //  Try to fix the problem
                    //

                    NtfsFixDataError( IrpContext,
                                      Scb,
                                      Vcb->TargetDeviceObject,
                                      Irp,
                                      NumberRuns,
                                      CompressionContext.IoRuns,
                                      IrpSpFlags );
                }
            }

            if (!NT_SUCCESS(Irp->IoStatus.Status) || (RemainingByteCount == 0)) { break; }

            if (CompressionContext.FinishBuffersNeeded) {

                Irp->IoStatus.Status =
                NtfsFinishBuffers( IrpContext,
                                   Irp,
                                   Scb,
                                   &StartingVbo,
                                   ByteCount - RemainingByteCount,
                                   NumberRuns,
                                   &CompressionContext,
                                   StreamFlags );

                if (!NT_SUCCESS(Irp->IoStatus.Status)) { break; }
            }

            StartingVbo = StartingVbo + (ByteCount - RemainingByteCount);
            CompressionContext.SystemBufferOffset += ByteCount - RemainingByteCount;

            ByteCount = RemainingByteCount;

            //
            //  Reset this boolean for each iteration.
            //

            CompressionContext.DataTransformed = FALSE;

            RemainingByteCount = NtfsPrepareBuffers( IrpContext,
                                                     Irp,
                                                     Scb,
                                                     &StartingVbo,
                                                     ByteCount,
                                                     StreamFlags,
                                                     &Wait,
                                                     &NumberRuns,
                                                     &CompressionContext );

            //
            //  If we are writing to an encrypted stream, now is the
            //  time to do the encryption, before we pass the buffer
            //  down to the disk driver below us.
            //
            if ((Scb->EncryptionContext != NULL) &&
                (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                (NtfsData.EncryptionCallBackTable.BeforeWriteProcess != NULL) &&
                (!FlagOn( StreamFlags, ENCRYPTED_STREAM ))) {

                ASSERT ( NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) );
                ASSERT( NumberRuns > 0 );

                NtfsEncryptBuffers( IrpContext,
                                    Irp,
                                    Scb,
                                    StartingVbo,
                                    NumberRuns,
                                    &CompressionContext );
            }

            ASSERT( RemainingByteCount < ByteCount );

            if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
                CollectDiskIoStats(Vcb, Scb, IrpContext->MajorFunction, NumberRuns);
            }
        }

        Status = Irp->IoStatus.Status;

    try_exit: NOTHING;

    } finally {

        //
        //  If this is a compressed file and we got success, go do our normal
        //  post processing.
        //

        if (CompressionContext.FinishBuffersNeeded &&
            NT_SUCCESS(Status) &&
            (Status != STATUS_PENDING) &&
            !AbnormalTermination() ) {

            Irp->IoStatus.Status =
            Status =
            NtfsFinishBuffers( IrpContext,
                               Irp,
                               Scb,
                               &StartingVbo,
                               ByteCount - RemainingByteCount,
                               NumberRuns,
                               &CompressionContext,
                               StreamFlags );
        }

        //
        //  For writes, free any Mdls which may have been used.
        //

        if (Mdl != NULL) {

            PMDL TempMdl;

            do {

                TempMdl = Mdl->Next;
                MmUnlockPages( Mdl );
                IoFreeMdl( Mdl );
                Mdl = TempMdl;

            } while (Mdl != NULL);
        }

        //
        //  Cleanup the compression context.
        //

        NtfsDeallocateCompressionBuffer( Irp, &CompressionContext, FALSE );
    }

    //
    //  Now set up the final byte count if we got success
    //

    if (Wait && NT_SUCCESS(Status)) {

        Irp->IoStatus.Information = OriginalByteCount;
    }

    DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> %08lx\n", Status) );
    return Status;
}


VOID
NtfsNonCachedNonAlignedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine differs from the above in that the range does not have to be
    sector aligned.  This accomplished with the use of intermediate buffers.
    devices where the sector is 1024 and callers have generated 512 byte aligned i/o.
    This accomplished with the use of intermediate buffers.

    Currently only read is supported.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Provides the stream to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file, and an array to store parameters for
    // parallel I/Os
    //

    LBO NextLbo;
    LCN NextLcn;
    ULONG NextLcnOffset;

    LONGLONG NextClusterCount;
    BOOLEAN NextIsAllocated;

    ULONG SectorOffset;
    ULONG SectorSize;
    ULONG BytesToCopy;
    ULONG OriginalByteCount;
    ULONG TailByteCount;
    VBO OriginalStartingVbo;

    PUCHAR UserBuffer;
    PUCHAR DiskBuffer = NULL;

    PMDL Mdl;
    PMDL SavedMdl;
    PVOID SavedUserBuffer;

    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsNonCachedNonAlignedRead\n") );
    DebugTrace( 0, Dbg, ("Irp                 = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MajorFunction       = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Scb                 = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("StartingVbo         = %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("ByteCount           = %08lx\n", ByteCount) );

    //
    //  Currently only read is supported.
    //

    ASSERT(IoGetCurrentIrpStackLocation(Irp)->MajorFunction != IRP_MJ_WRITE);

    //
    //  This code assumes the file is uncompressed.  Sparse files are supported.
    //  Before we assert that the file is uncompressed, assert that our test is
    //  going to be properly serialized.  We'll also be testing for the sparse
    //  attribute in the main code path, so we really need to be serialized here.
    //

    ASSERT( NtfsIsSharedScb( Scb ) ||
            ((Scb->Header.PagingIoResource != NULL) && NtfsIsSharedScbPagingIo( Scb )) );

    ASSERT( !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) );

    //
    //  Initialize some locals.
    //

    OriginalByteCount = ByteCount;
    OriginalStartingVbo = StartingVbo;
    SectorSize = Vcb->BytesPerSector;

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    NtfsLockUserBuffer( IrpContext,
                        Irp,
                        IoWriteAccess,
                        IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length );

    UserBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

    //
    //  Allocate the local buffer.  Round to pages to avoid any device alignment
    //  problems.
    //

    DiskBuffer = NtfsAllocatePool( NonPagedPool,
                                    (ULONG) ROUND_TO_PAGES( SectorSize ));

    //
    //  We use a try block here to ensure the buffer is freed, and to
    //  fill in the correct byte count in the Iosb.Information field.
    //

    try {

        //
        //  If the beginning of the request was not aligned correctly, read in
        //  the first part first.
        //

        SectorOffset = ((ULONG)StartingVbo) & (SectorSize - 1);

        if (SectorOffset != 0) {

            //
            //  Try to lookup the first run.
            //

            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                    Scb,
                                                    Int64ShraMod32( StartingVbo, Vcb->ClusterShift ),
                                                    &NextLcn,
                                                    &NextClusterCount,
                                                    NULL,
                                                    NULL );

            //
            //  If this is a sparse file and we've been asked to read in a
            //  deallocated range, we need to fill in the buffer with some
            //  zeroes and there's nothing to really read from the disk.
            //  If this isn't a sparse file, and this range isn't allocated,
            //  the file and/or mcb is corrupt.
            //

            if (!NextIsAllocated) {

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    RtlZeroMemory( DiskBuffer + SectorOffset,
                                   SectorSize - SectorOffset );
                } else {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } else {

                //
                //  Adjust for any Lcn offset to the start of the sector we want.
                //

                NextLcnOffset = ((ULONG)StartingVbo) & ~(SectorSize - 1);
                NextLcnOffset &= Vcb->ClusterMask;
                NextLbo = Int64ShllMod32(NextLcn, Vcb->ClusterShift);
                NextLbo = NextLbo + NextLcnOffset;

                NtfsSingleNonAlignedSync( IrpContext,
                                          Vcb,
                                          Scb,
                                          DiskBuffer,
                                          StartingVbo + NextLcnOffset,
                                          NextLbo,
                                          SectorSize,
                                          Irp );

                if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                    try_return( NOTHING );
                }
            }

            //
            //  Now copy the part of the first sector that we want to the user
            //  buffer.
            //

            BytesToCopy = (ByteCount >= SectorSize - SectorOffset
                           ? SectorSize - SectorOffset
                           : ByteCount);

            RtlCopyMemory( UserBuffer,
                           DiskBuffer + SectorOffset,
                           BytesToCopy );

            StartingVbo = StartingVbo + BytesToCopy;

            ByteCount -= BytesToCopy;

            if (ByteCount == 0) {

                try_return( NOTHING );
            }
        }

        ASSERT( (((ULONG)StartingVbo) & (SectorSize - 1)) == 0 );

        //
        //  If there is a tail part that is not sector aligned, read it.
        //

        TailByteCount = (ByteCount & (SectorSize - 1));

        if (TailByteCount != 0) {

            VBO LastSectorVbo;

            LastSectorVbo = BlockAlignTruncate( StartingVbo + ByteCount, (LONG)SectorSize );

            //
            //  Try to lookup the last part of the requested range.
            //

            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                    Scb,
                                                    Int64ShraMod32( LastSectorVbo, Vcb->ClusterShift ),
                                                    &NextLcn,
                                                    &NextClusterCount,
                                                    NULL,
                                                    NULL );

            //
            //  If this is a sparse file and we've been asked to read in a
            //  deallocated range, we need to fill in the buffer with some
            //  zeroes and there's nothing to really read from the disk.
            //  If this isn't a sparse file, and this range isn't allocated,
            //  the file and/or mcb is corrupt.
            //

            if (!NextIsAllocated) {

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    RtlZeroMemory( DiskBuffer,
                                   TailByteCount );
                } else {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } else {

                //
                //  Adjust for any Lcn offset.
                //

                NextLcnOffset = ((ULONG)LastSectorVbo) & Vcb->ClusterMask;
                NextLbo = Int64ShllMod32(NextLcn, Vcb->ClusterShift);
                NextLbo = NextLbo + NextLcnOffset;

                NtfsSingleNonAlignedSync( IrpContext,
                                          Vcb,
                                          Scb,
                                          DiskBuffer,
                                          LastSectorVbo,
                                          NextLbo,
                                          SectorSize,
                                          Irp );

                if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                    try_return( NOTHING );
                }
            }

            //
            //  Now copy over the part of this last sector that we need.
            //

            BytesToCopy = TailByteCount;

            UserBuffer += (ULONG)(LastSectorVbo - OriginalStartingVbo);

            RtlCopyMemory( UserBuffer, DiskBuffer, BytesToCopy );

            ByteCount -= BytesToCopy;

            if (ByteCount == 0) {

                try_return( NOTHING );
            }
        }

        ASSERT( ((((ULONG)StartingVbo) | ByteCount) & (SectorSize - 1)) == 0 );

        //
        //  Now build a Mdl describing the sector aligned balance of the transfer,
        //  and put it in the Irp, and read that part.
        //

        SavedMdl = Irp->MdlAddress;
        Irp->MdlAddress = NULL;

        SavedUserBuffer = Irp->UserBuffer;

        Irp->UserBuffer = (PUCHAR)MmGetMdlVirtualAddress( SavedMdl ) +
                          (ULONG)(StartingVbo - OriginalStartingVbo);


        Mdl = IoAllocateMdl(Irp->UserBuffer,
                            ByteCount,
                            FALSE,
                            FALSE,
                            Irp);

        if (Mdl == NULL) {

            Irp->MdlAddress = SavedMdl;
            Irp->UserBuffer = SavedUserBuffer;
            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        IoBuildPartialMdl(SavedMdl,
                          Mdl,
                          Irp->UserBuffer,
                          ByteCount);

        //
        //  Try to read in the pages.
        //

        try {

            NtfsNonCachedIo( IrpContext,
                             Irp,
                             Scb,
                             StartingVbo,
                             ByteCount,
                             0 );

        } finally {

            IoFreeMdl( Irp->MdlAddress );

            Irp->MdlAddress = SavedMdl;
            Irp->UserBuffer = SavedUserBuffer;
        }

    try_exit: NOTHING;

    } finally {

        NtfsFreePool( DiskBuffer );

        if ( !AbnormalTermination() && NT_SUCCESS(Irp->IoStatus.Status) ) {

            Irp->IoStatus.Information = OriginalByteCount;

            //
            //  We now flush the user's buffer to memory.
            //

            KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsNonCachedNonAlignedRead -> VOID\n") );
    return;
}


BOOLEAN
NtfsVerifyAndRevertUsaBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PIRP Irp OPTIONAL,
    IN PVOID SystemBuffer OPTIONAL,
    IN ULONG Offset,
    IN ULONG Length,
    IN LONGLONG FileOffset
    )

/*++

Routine Description:

    This routine will revert the bytes in all of the structures protected by
    update sequence arrays.  It copies the bytes from each Usa to the
    separate blocks protected.

    If a structure does not verify correctly, then it's signature is set
    to BaadSignature.

Arguments:

    Scb - The scb being read

    Irp - contain the buffer to be reverted if specified if not systembuffer should be

    SystemBuffer - contains the buffer if irp is null

    Offset - Offset within the buffer to be reverted

    Length - Length of the buffer to be reverted starting at the offset

    FileOffset - Offset within the file the buffer originates from

Return Value:

    FALSE - if at least one block did not verify correctly and received a BaadSignature
    TRUE - if no blocks received a BaadSignature

--*/

{
    PMULTI_SECTOR_HEADER MultiSectorHeader;
    PUSHORT SequenceArray;
    PUSHORT SequenceNumber;
    ULONG StructureSize;
    USHORT CountBlocks;
    PUSHORT ProtectedUshort;
    PVCB Vcb = Scb->Vcb;
    ULONG BytesLeft = Length;
    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * 2];
    PMDL PartialMdl = (PMDL) Buffer;

    BOOLEAN ReservedMapping = FALSE;
    BOOLEAN Result = TRUE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyAndRevertUsaBlock:  Entered\n") );

    ASSERT( (ARGUMENT_PRESENT( Irp ) && !ARGUMENT_PRESENT( SystemBuffer )) ||
            (!ARGUMENT_PRESENT( Irp ) && ARGUMENT_PRESENT( SystemBuffer )) );

    //
    //  Cast the buffer pointer to a Multi-Sector-Header and verify that this
    //  block has been initialized.
    //

    if (ARGUMENT_PRESENT( Irp )) {
        SystemBuffer = NtfsMapUserBufferNoRaise( Irp, HighPagePriority );
    }

    //
    //  We can't map the user buffer due to low resources - so switch to using the reserved
    //  mapping instead
    //

    if (SystemBuffer == NULL) {

        ExAcquireFastMutexUnsafe( &Vcb->ReservedMappingMutex );
        ReservedMapping = TRUE;

        MmInitializeMdl( PartialMdl, NULL, 2 * PAGE_SIZE );
        IoBuildPartialMdl( Irp->MdlAddress, PartialMdl, Add2Ptr( MmGetMdlBaseVa( Irp->MdlAddress ), MmGetMdlByteOffset( Irp->MdlAddress ) + Offset ), Vcb->BytesPerSector );
        MultiSectorHeader = (PMULTI_SECTOR_HEADER) MmMapLockedPagesWithReservedMapping( IrpContext->Vcb->ReservedMapping,
                                                                                        RESERVE_POOL_TAG,
                                                                                        PartialMdl,
                                                                                        MmCached );
        ASSERT( MultiSectorHeader != NULL );
    } else {
        MultiSectorHeader = (PMULTI_SECTOR_HEADER)Add2Ptr( SystemBuffer, Offset );
    }


    //
    //  Get the the number of blocks, based on what type of stream it is.
    //  First check for Mft or Log file.
    //

    if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

        ASSERT((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb));

        StructureSize = Vcb->BytesPerFileRecordSegment;

    } else if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) {

        ASSERT( Scb == Vcb->LogFileScb );

        //
        //  On the first pass through the log file, we see all -1,
        //  and we just want to let it go.
        //

        if (*(PULONG)&MultiSectorHeader->Signature == MAXULONG) {

            //
            //  Use the structure size given us by Lfs if present.
            //

            StructureSize = Vcb->LfsWriteData.LfsStructureSize;

        //
        //  Use the current size in the USA
        //

        } else {

            CountBlocks = (USHORT)(MultiSectorHeader->UpdateSequenceArraySize - 1);
            StructureSize = CountBlocks * SEQUENCE_NUMBER_STRIDE;

            //
            //  Check for plausibility and otherwise use page size.
            //

            if ((StructureSize != 0x1000)  && (StructureSize != 0x2000) && (StructureSize != PAGE_SIZE)) {

                StructureSize = PAGE_SIZE;
            }
        }

    //
    //  Otherwise it is an index, so we can get the count out of the Scb.
    //

    } else {

        StructureSize = Scb->ScbType.Index.BytesPerIndexBuffer;

        ASSERT((StructureSize == 0x800) || (StructureSize == 0x1000) || (StructureSize == 0x400));
        ASSERT((Length & (StructureSize - 1)) == 0);
    }

    //
    //  We're done with the mapped buffer so release the reserved mapping if we used them
    //

    if (ReservedMapping) {
        MmUnmapReservedMapping( Vcb->ReservedMapping, RESERVE_POOL_TAG, PartialMdl );
        MmPrepareMdlForReuse( PartialMdl );
        ExReleaseFastMutexUnsafe( &Vcb->ReservedMappingMutex );
        ReservedMapping = FALSE;
        MultiSectorHeader = NULL;
    }

    if (StructureSize == 0) {

        ASSERT( Scb == Vcb->LogFileScb );

        DebugTrace( -1, Dbg, ("NtfsVerifyAndRevertUsaBlock: (Virgin Log)\n") );
        return TRUE;
    }

    ASSERTMSG( "ReservedMapping should be large enough for this structure\n", StructureSize < 2 * PAGE_SIZE );

    CountBlocks = (USHORT)(StructureSize / SEQUENCE_NUMBER_STRIDE);

    //
    //  Loop through all of the multi-sector blocks in this transfer.
    //

    do {

        //
        //  First find our location in the MultiSectorHeader - use reserve mappings
        //  if we haven't got a system buffer
        //

        if (!SystemBuffer) {

            ExAcquireFastMutexUnsafe( &Vcb->ReservedMappingMutex );
            ReservedMapping = TRUE;

            IoBuildPartialMdl( Irp->MdlAddress,
                               PartialMdl,
                               Add2Ptr( MmGetMdlBaseVa( Irp->MdlAddress ), MmGetMdlByteOffset( Irp->MdlAddress ) + Offset + Length - BytesLeft),
                               StructureSize );
            MultiSectorHeader = (PMULTI_SECTOR_HEADER) MmMapLockedPagesWithReservedMapping( IrpContext->Vcb->ReservedMapping,
                                                                                            RESERVE_POOL_TAG,
                                                                                            PartialMdl,
                                                                                            MmCached );

            ASSERT( MultiSectorHeader != NULL );
        } else {
            MultiSectorHeader = (PMULTI_SECTOR_HEADER)Add2Ptr( SystemBuffer, Offset + Length - BytesLeft );
        }

        //
        //  Uninitialized log file pages always must contain MAXULONG, which is
        //  not a valid signature.  Do not do the check if we see MAXULONG.  Also
        //  since we may have read random uninitialized data, we must check every
        //  possible field that could cause us to fault or go outside of the block,
        //  and also not check in this case.
        //

        //
        //  For 0 or MAXULONG we assume the value is "expected", and we do not
        //  want to replace with the BaadSignature, just move on.
        //

        if ((*(PULONG)&MultiSectorHeader->Signature == MAXULONG) ||
            (*(PULONG)&MultiSectorHeader->Signature == 0)) {

            NOTHING;

        } else if ((CountBlocks == (USHORT)(MultiSectorHeader->UpdateSequenceArraySize - 1)) &&
                   !FlagOn(MultiSectorHeader->UpdateSequenceArrayOffset, 1) &&
                   (MultiSectorHeader->UpdateSequenceArrayOffset >= sizeof( MULTI_SECTOR_HEADER )) &&
                   (MultiSectorHeader->UpdateSequenceArrayOffset < SEQUENCE_NUMBER_STRIDE) &&
                   (StructureSize <= BytesLeft)) {

            ULONG CountToGo;

            CountToGo = CountBlocks;

            //
            //  Compute the array offset and recover the current sequence number.
            //

            SequenceNumber = (PUSHORT)Add2Ptr( MultiSectorHeader,
                                               MultiSectorHeader->UpdateSequenceArrayOffset );

            SequenceArray = SequenceNumber + 1;

            //
            //  We now walk through each block, and insure that the last byte in each
            //  block matches the sequence number.
            //

            ProtectedUshort = (PUSHORT) (Add2Ptr( MultiSectorHeader,
                                                  SEQUENCE_NUMBER_STRIDE - sizeof( USHORT )));

            //
            //  Loop to test for the correct sequence numbers and restore the
            //  sequence numbers.
            //

            do {

                //
                //  If the sequence number does not check, then raise if the record
                //  is not allocated.  If we do not raise, i.e. the routine returns,
                //  then smash the signature so we can easily tell the record is not
                //  allocated.
                //

                if (*ProtectedUshort != *SequenceNumber) {

                    //
                    //  We do nothing except exit if this is the log file and
                    //  the signature is the chkdsk signature.
                    //

                    if ((Scb != Vcb->LogFileScb) ||
                        (*(PULONG)MultiSectorHeader->Signature != *(PULONG)ChkdskSignature)) {

                        //
                        //  If this is the Mft or an index buffer and all of the data for this file
                        //  record is contained in the verified range of the
                        //  record then don't mark it bad.
                        //

                        if ((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb)) {

                            PFILE_RECORD_SEGMENT_HEADER FileRecord;

                            FileRecord = (PFILE_RECORD_SEGMENT_HEADER) MultiSectorHeader;

                            if (FileRecord->FirstFreeByte < ((CountBlocks - CountToGo) * SEQUENCE_NUMBER_STRIDE)) {

                                continue;
                            }
                        } else if (*(PULONG)MultiSectorHeader->Signature == *(PULONG)IndexSignature ) {

                            PINDEX_ALLOCATION_BUFFER IndexBuffer;

                            IndexBuffer = (PINDEX_ALLOCATION_BUFFER) MultiSectorHeader;

                            if (IndexBuffer->IndexHeader.FirstFreeByte < ((CountBlocks - CountToGo) * SEQUENCE_NUMBER_STRIDE)) {

                                continue;
                            }
                        }

                        *(PULONG)MultiSectorHeader->Signature = *(PULONG)BaadSignature;
                        Result = FALSE;
                    }

                    break;

                } else {

                    *ProtectedUshort = *SequenceArray++;
                }

                ProtectedUshort += (SEQUENCE_NUMBER_STRIDE / sizeof( USHORT ));

            } while (--CountToGo != 0);

        //
        //  If this is the log file, we report an error unless the current
        //  signature is the chkdsk signature.
        //

        } else if (Scb == Vcb->LogFileScb) {

            if (*(PULONG)MultiSectorHeader->Signature != *(PULONG)ChkdskSignature) {

                *(PULONG)MultiSectorHeader->Signature = *(PULONG)BaadSignature;
                Result = FALSE;
            }

        } else {

            VCN Vcn;
            LCN Lcn;
            LONGLONG ClusterCount;
            BOOLEAN IsAllocated;

            Vcn = LlClustersFromBytesTruncate( Vcb, FileOffset );

            //
            //  Release the reserved buffer before calling
            //

            if (ReservedMapping) {
                MmUnmapReservedMapping( Vcb->ReservedMapping, RESERVE_POOL_TAG, PartialMdl );
                MmPrepareMdlForReuse( PartialMdl );
                ExReleaseFastMutexUnsafe( &Vcb->ReservedMappingMutex );
                MultiSectorHeader = NULL;
                ReservedMapping = FALSE;
            }

            IsAllocated = NtfsLookupAllocation( IrpContext,
                                                Scb,
                                                Vcn,
                                                &Lcn,
                                                &ClusterCount,
                                                NULL,
                                                NULL );

            if (!SystemBuffer) {

                ExAcquireFastMutexUnsafe( &Vcb->ReservedMappingMutex );
                ReservedMapping = TRUE;

                IoBuildPartialMdl( Irp->MdlAddress, PartialMdl, Add2Ptr( MmGetMdlBaseVa( Irp->MdlAddress ), MmGetMdlByteOffset( Irp->MdlAddress ) + Offset + Length - BytesLeft), StructureSize );
                MultiSectorHeader = MmMapLockedPagesWithReservedMapping( IrpContext->Vcb->ReservedMapping,
                                                              RESERVE_POOL_TAG,
                                                              PartialMdl,
                                                              MmCached );

                ASSERT( MultiSectorHeader != NULL );
            }


            if (!IsAllocated &&
                ( ClusterCount >= LlClustersFromBytes( Vcb, StructureSize))) {

                *(PULONG)MultiSectorHeader->Signature = *(PULONG)HoleSignature;
            } else {
                *(PULONG)MultiSectorHeader->Signature = *(PULONG)BaadSignature;
                Result = FALSE;
            }
        }

        //
        //  Release the reserve mapping before looping
        //

        if (ReservedMapping) {
            MmUnmapReservedMapping( Vcb->ReservedMapping, RESERVE_POOL_TAG, PartialMdl );
            MmPrepareMdlForReuse( PartialMdl );
            ExReleaseFastMutexUnsafe( &Vcb->ReservedMappingMutex );
            MultiSectorHeader = NULL;
            ReservedMapping = FALSE;
        }

        if (BytesLeft > StructureSize) {
            BytesLeft -= StructureSize;
        } else {
            BytesLeft = 0;
        }
        FileOffset = FileOffset + StructureSize;

    } while (BytesLeft != 0);

    DebugTrace( -1, Dbg, ("NtfsVerifyAndRevertUsaBlock:  Exit\n") );
    return Result;
}


VOID
NtfsTransformUsaBlock (
    IN PSCB Scb,
    IN OUT PVOID SystemBuffer,
    IN OUT PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine will implement Usa protection for all structures of the
    transfer passed described by the caller.  It does so by copying the last
    short in each block of each Usa-protected structure to the
    Usa and storing the current sequence number into each of these bytes.

    It also increments the sequence number in the Usa.

Arguments:

    Buffer - This is the pointer to the start of the structure to transform.

    Length - This is the maximum size for the structure.

Return Value:

    ULONG - This is the length of the transformed structure.

--*/

{
    PMULTI_SECTOR_HEADER MultiSectorHeader;
    PUSHORT SequenceArray;
    PUSHORT SequenceNumber;
    ULONG StructureSize;
    USHORT CountBlocks;
    PUSHORT ProtectedUshort;
    PVCB Vcb = Scb->Vcb;
    ULONG BytesLeft = Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsTransformUsaBlock:  Entered\n") );

    //
    //  Cast the buffer pointer to a Multi-Sector-Header and verify that this
    //  block has been initialized.
    //

    MultiSectorHeader = (PMULTI_SECTOR_HEADER) Buffer;

    //
    //  Get the the number of blocks, based on what type of stream it is.
    //  First check for Mft or Log file.
    //

    if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

        ASSERT((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb));

        StructureSize = Vcb->BytesPerFileRecordSegment;

    } else if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) {

        //
        //  For the log file, use the value that Lfs has stored in the
        //  Lfs WRITE_DATA structure.
        //

        ASSERT( Scb == Vcb->LogFileScb );
        ASSERT( Vcb->LfsWriteData.LfsStructureSize != 0 );

        StructureSize = Vcb->LfsWriteData.LfsStructureSize;

    //
    //  Otherwise it is an index, so we can get the count out of the Scb.
    //

    } else {

        StructureSize = Scb->ScbType.Index.BytesPerIndexBuffer;

        ASSERT((StructureSize == 0x800) || (StructureSize == 0x1000) || (StructureSize == 0x400));
        ASSERT((Length & (StructureSize - 1)) == 0);
    }

    CountBlocks = (USHORT)(StructureSize / SEQUENCE_NUMBER_STRIDE);

    //
    //  Loop through all of the multi-sector blocks in this transfer.
    //

    do {

        //
        //  Any uninitialized structures will begin with BaadSignature or
        //  MAXULONG, as guaranteed by the Revert routine above.
        //

        if ((*(PULONG)&MultiSectorHeader->Signature != *(PULONG)BaadSignature) &&
            (*(PULONG)&MultiSectorHeader->Signature != *(PULONG)HoleSignature) &&
            (*(PULONG)&MultiSectorHeader->Signature != MAXULONG) &&
            ((MultiSectorHeader->UpdateSequenceArrayOffset & 1) == 0) &&
            (MultiSectorHeader->UpdateSequenceArrayOffset >= sizeof( MULTI_SECTOR_HEADER )) &&
            (MultiSectorHeader->UpdateSequenceArrayOffset < SEQUENCE_NUMBER_STRIDE)) {

            ULONG CountToGo = CountBlocks;

            //
            //  Compute the array offset and recover the current sequence number.
            //

            SequenceNumber = (PUSHORT)Add2Ptr( MultiSectorHeader,
                                               MultiSectorHeader->UpdateSequenceArrayOffset );

            //
            //  Increment sequence number before the write, both in the buffer
            //  going out and in the original buffer pointed to by SystemBuffer.
            //  Skip numbers with all 0's and all 1's because 0's are produced by
            //  by common failure cases and -1 is used by hot fix.
            //

            do {

                *SequenceNumber += 1;

                *(PUSHORT)Add2Ptr( SystemBuffer,
                                   MultiSectorHeader->UpdateSequenceArrayOffset ) += 1;

            } while ((*SequenceNumber == 0) || (*SequenceNumber == 0xFFFF));

            SequenceArray = SequenceNumber + 1;

            //
            //  We now walk through each block to copy each protected short
            //  to the sequence array, and replacing it by the incremented
            //  sequence number.
            //

            ProtectedUshort = (PUSHORT) (Add2Ptr( MultiSectorHeader,
                                                  SEQUENCE_NUMBER_STRIDE - sizeof( USHORT )));

            //
            //  Loop to test for the correct sequence numbers and restore the
            //  sequence numbers.
            //

            do {

                *SequenceArray++ = *ProtectedUshort;
                *ProtectedUshort = *SequenceNumber;

                ProtectedUshort += (SEQUENCE_NUMBER_STRIDE / sizeof( USHORT ));

            } while (--CountToGo != 0);
        }

        //
        //  Now adjust all pointers and counts before looping back.
        //

        MultiSectorHeader = (PMULTI_SECTOR_HEADER)Add2Ptr( MultiSectorHeader,
                                                           StructureSize );
        SystemBuffer = Add2Ptr( SystemBuffer, StructureSize );
        BytesLeft -= StructureSize;

    } while (BytesLeft != 0);

    DebugTrace( -1, Dbg, ("NtfsTransformUsaBlock:  Exit -> %08lx\n", StructureSize) );
    return;
}


VOID
NtfsCreateMdlAndBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN UCHAR NeedTwoBuffers,
    IN OUT PULONG Length,
    OUT PMDL *Mdl OPTIONAL,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine will allocate a buffer and create an Mdl which describes
    it.  This buffer and Mdl can then be used for an I/O operation, the
    pages will be locked in memory.

    This routine is intended to be used for cases where large I/Os are
    required.  It attempts to avoid allocations errors and bugchecks by
    using a reserved buffer scheme.  In order for this scheme to work without
    deadlocks, the calling thread must have all resources acquired that it
    will need prior to doing the I/O.  I.e., this routine itself may acquire
    a resource which must work as an end resource.

    Examples of callers to this routine are noncached writes to USA streams,
    and noncached reads and writes to compressed streams.  One case to be
    aware of is the case where a noncached compressed write needs to fault
    in the rest of a compression unit, in order to write the entire unit.
    In an extreme case the noncached writer will allocated one reserved buffer,
    and the noncached read of the rest of the compression unit may need to
    recursively acquire the resource in this routine and allocate the other
    reserved buffer.

Arguments:

    ThisScb - Scb for the file where the IO is occurring.

    NeedTwoBuffers - Indicates that this is the request for the a buffer for
        a transaction which may need two buffers.  A value of RESERVED_BUFFER_ONE_NEEDED means only 1
        buffer is needed.  A value of RESERVED_BUFFER_TWO_NEEDED or RESERVED_BUFFER_WORKSPACE_NEEDED
        indicates that we need two buffers and either ReservedBuffer1 or ReservedBuffer2 should be acquired.

    Length - This is the length needed for this buffer, returns (possibly larger)
        length allocated.

    Mdl - This is the address to store the address of the Mdl created.

    Buffer - This is the address to store the address of the buffer allocated.

Return Value:

    None.

--*/

{
    PVOID TempBuffer;
    PMDL TempMdl;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateMdlAndBuffer:  Entered\n") );

    ASSERT( (NeedTwoBuffers == RESERVED_BUFFER_WORKSPACE_NEEDED) ?
            (*Length <= WORKSPACE_BUFFER_SIZE) :
            (*Length <= LARGE_BUFFER_SIZE) );

    TempBuffer = NULL;
    TempMdl = NULL;

    //
    //  If this thread already owns a buffer then call to get the second.
    //
    //  If there have been no allocation failures recently, and
    //  we can use at least half of a big buffer, then go for
    //  one of our preallocated buffers first.
    //

    if ((NtfsReservedBufferThread == (PVOID) PsGetCurrentThread()) ||
        ((*Length >= LARGE_BUFFER_SIZE / 2) && !NtfsBufferAllocationFailure)) {

        //
        //  If we didn't get one then try from pool.
        //

        if (!NtfsGetReservedBuffer( ThisScb->Fcb, &TempBuffer, Length, NeedTwoBuffers )) {

            TempBuffer = NtfsAllocatePoolWithTagNoRaise( NonPagedPoolCacheAligned, *Length, '9ftN' );
        }

    //
    //  Otherwise try to allocate from pool and then get a reserved buffer if
    //  there have been no allocation errors recently.
    //

    } else {

        TempBuffer = NtfsAllocatePoolWithTagNoRaise( NonPagedPoolCacheAligned, *Length, '9ftN' );

        if ((TempBuffer == NULL) && !NtfsBufferAllocationFailure) {

            NtfsGetReservedBuffer( ThisScb->Fcb, &TempBuffer, Length, NeedTwoBuffers );
        }
    }

    //
    //  If we could not allocate a buffer from pool, then
    //  we must stake our claim to a reserved buffer.
    //
    //  We would like to queue the requests which need a single buffer because
    //  they won't be completely blocked by the owner of multiple buffers.
    //  But if this thread wants multiple buffers and there is already a
    //  thread with multiple buffers then fail this request with FILE_LOCK_CONFLICT
    //  in case the current thread is holding some resource needed by the
    //  existing owner.
    //

    if (TempBuffer == NULL) {

        ExAcquireResourceExclusiveLite( &NtfsReservedBufferResource, TRUE );

        //
        //  Show that we have gotten an allocation failure
        //

        NtfsBufferAllocationFailure = TRUE;

        //
        //  Loop here until we get a buffer or abort the current request.
        //

        while (TRUE) {

            KeDelayExecutionThread( KernelMode, FALSE, &NtfsShortDelay );

            if (NtfsGetReservedBuffer( ThisScb->Fcb, &TempBuffer, Length, NeedTwoBuffers )) {

                if (ExGetExclusiveWaiterCount( &NtfsReservedBufferResource ) == 0) {

                    NtfsBufferAllocationFailure = FALSE;
                }

                ExReleaseResourceLite( &NtfsReservedBufferResource );
                break;
            }

            //
            //  We will perform some deadlock detection here and raise
            //  STATUS_FILE_LOCK conflict in order to retry this request if
            //  anyone is queued behind the resource.  Deadlocks can occur
            //  under the following circumstances when another thread is
            //  blocked behind this resource:
            //
            //      - Current thread needs two buffers.  We can't block the
            //          Needs1 guy which may need to complete before the
            //          current Needs2 guy can proceed.  Exception is case
            //          where current thread already has a buffer and we
            //          have a recursive 2 buffer case.  In this case we
            //          are only waiting for the third buffer to become
            //          available.
            //
            //      - Current thread is the lazy writer.  Lazy writer will
            //          need buffer for USA transform.  He also can own
            //          the BCB resource that might be needed by the current
            //          owner of a buffer.
            //
            //      - Current thread is operating on the same Fcb as the owner
            //          of any of the buffers.
            //

            //
            //  If the current thread already owns one of the two buffers then
            //  always allow him to loop.  Otherwise perform deadlock detection
            //  if we need 2 buffers or this this is the lazy writer or we
            //  are trying to get the same Fcb already owned by the 2 buffer guy.
            //

            if ((PsGetCurrentThread() != NtfsReservedBufferThread) &&

                (NeedTwoBuffers ||

#ifdef COMPRESS_ON_WIRE
                (ThisScb->LazyWriteThread[0] == PsGetCurrentThread()) ||
                (ThisScb->LazyWriteThread[1] == PsGetCurrentThread()) ||
#else
                (NtfsGetTopLevelContext()->SavedTopLevelIrp == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP) ||

#endif
                (ThisScb->Fcb == NtfsReserved12Fcb))) {

                //
                //  If no one is waiting then see if we can continue waiting.
                //

                if (ExGetExclusiveWaiterCount( &NtfsReservedBufferResource ) == 0) {

                    //
                    //  If there is no one waiting behind us and there is no current
                    //  multi-buffer owner, then try again here.
                    //

                    if (NtfsReservedBufferThread == NULL) {

                        continue;
                    }

                    NtfsBufferAllocationFailure = FALSE;
                }

                ExReleaseResourceLite( &NtfsReservedBufferResource );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_LOCK_CONFLICT, NULL, NULL );
            }
        }
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (ARGUMENT_PRESENT(Mdl)) {

            //
            //  Allocate an Mdl for this buffer.
            //

            TempMdl = IoAllocateMdl( TempBuffer,
                                     *Length,
                                     FALSE,
                                     FALSE,
                                     NULL );

            if (TempMdl == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            //
            //  Lock the new Mdl in memory.
            //

            MmBuildMdlForNonPagedPool( TempMdl );
            *Mdl = TempMdl;
        }

    } finally {

        DebugUnwind( NtfsCreateMdlAndBuffer );

        //
        //  If abnormal termination, back out anything we've done.
        //

        if (AbnormalTermination()) {

            NtfsDeleteMdlAndBuffer( TempMdl, TempBuffer );

        //
        //  Otherwise, give the Mdl and buffer to the caller.
        //

        } else {

            *Buffer = TempBuffer;
        }

        DebugTrace( -1, Dbg, ("NtfsCreateMdlAndBuffer:  Exit\n") );
    }

    return;
}


VOID
NtfsDeleteMdlAndBuffer (
    IN PMDL Mdl OPTIONAL,
    IN PVOID Buffer OPTIONAL
    )

/*++

Routine Description:

    This routine will allocate a buffer and create an Mdl which describes
    it.  This buffer and Mdl can then be used for an I/O operation, the
    pages will be locked in memory.

Arguments:

    Mdl - Address of Mdl to free

    Buffer - This is the address to store the address of the buffer allocated.

Return Value:

    None.

--*/

{
    //
    //  Free Mdl if there is one
    //

    if (Mdl != NULL) {
        IoFreeMdl( Mdl );
    }

    //
    //  Free reserved buffer or pool
    //

    if (Buffer != NULL) {

        if (!NtfsFreeReservedBuffer( Buffer )) {

            NtfsFreePool( Buffer );
        }
    }
}


PMDL
NtfsBuildZeroMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG Length,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    Create an efficient mdl that describe a given length of zeros. We'll only
    allocate a one page buffer and make a mdl that maps all the pages back to the single
    physical page. We'll default to a smaller size buffer down to 1 PAGE if memory
    is tight. The caller should check the Mdl->ByteCount to see the true size

Arguments:

    Length - The desired length of the zero buffer. We may return less than this
    
    Buffer - This returns the nonpaged pool buffer we've allocated - the caller
        should free it after he frees the returned MDL. 

Return Value:

    a MDL if successfull / NULL if not

--*/

{
    PMDL ZeroMdl;
    ULONG SavedByteCount;
    PPFN_NUMBER Page;
    ULONG i;

    *Buffer = (PCHAR) NtfsAllocatePoolNoRaise( NonPagedPool, PAGE_SIZE );
    if (!*Buffer) {
        return NULL;
    }
    RtlZeroMemory( *Buffer, PAGE_SIZE );

    while (TRUE) {

        //
        //  Spin down trying to get an MDL which can describe our operation.
        //

        while (TRUE) {

            ZeroMdl = IoAllocateMdl( *Buffer, Length, FALSE, FALSE, NULL );

            //
            //  Throttle ourselves to what we've physically allocated.  Note that
            //  we could have started with an odd multiple of this number.  If we
            //  tried for exactly that size and failed, we're toast.
            //

            if (ZeroMdl || (Length <= PAGE_SIZE)) {

                break;
            }

            //
            //  Fallback by half and round down to a sector multiple.
            //

            Length = BlockAlignTruncate( Length / 2, (LONG)IrpContext->Vcb->BytesPerSector );
            if (Length < PAGE_SIZE) {
                Length = PAGE_SIZE;
            }
        }

        if (ZeroMdl == NULL) {
            NtfsFreePool( *Buffer );
            *Buffer = NULL;
            return NULL;
        }

        //
        //  If we have throttled all the way down, stop and just build a
        //  simple MDL describing our previous allocation.
        //

        if (Length == PAGE_SIZE) {

            MmBuildMdlForNonPagedPool( ZeroMdl );
            break;
        }

        //
        //  Now we will temporarily lock the allocated pages
        //  only, and then replicate the page frame numbers through
        //  the entire Mdl to keep writing the same pages of zeros.
        //
        //  It would be nice if Mm exported a way for us to not have
        //  to pull the Mdl apart and rebuild it ourselves, but this
        //  is so bizzare a purpose as to be tolerable.
        //

        SavedByteCount = ZeroMdl->ByteCount;
        ZeroMdl->ByteCount = PAGE_SIZE;
        MmBuildMdlForNonPagedPool( ZeroMdl );

        ZeroMdl->MdlFlags &= ~MDL_SOURCE_IS_NONPAGED_POOL;
        ZeroMdl->MdlFlags |= MDL_PAGES_LOCKED;
        ZeroMdl->MappedSystemVa = NULL;
        ZeroMdl->ByteCount = SavedByteCount;
        Page = MmGetMdlPfnArray( ZeroMdl );
        for (i = 0; i < (ADDRESS_AND_SIZE_TO_SPAN_PAGES( 0, SavedByteCount )); i++) {
            *(Page + i) = *(Page);
        }
        break;
    }

    return ZeroMdl;
}



VOID
NtfsWriteClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN PVOID Buffer,
    IN ULONG ClusterCount
    )

/*++

Routine Description:

    This routine is called to write clusters directly to a file.  It is
    needed when converting a resident attribute to non-resident when
    we can't initialize through the cache manager.  This happens when
    we receive a SetEndOfFile from MM when creating a section for
    a resident file.

Arguments:

    Vcb - Vcb for this device.

    StartingVbo - This is the starting offset to write to.

    Buffer - Buffer containing the data to write.

    ClusterCount - This is the number of clusters to write.

Return Value:

    None.  This routine will raise if the operation is unsuccessful.

--*/

{
    PIRP NewIrp = NULL;
    UCHAR MajorFunction = IrpContext->MajorFunction;
    BOOLEAN LockedUserBuffer = FALSE;
    PNTFS_IO_CONTEXT PreviousContext;
    ULONG State;
    ULONG ByteCount = BytesFromClusters( Vcb, ClusterCount );
    ULONG OriginalByteCount = ByteCount;
    PMDL Mdl = NULL;

    NTFS_IO_CONTEXT LocalContext;

    BOOLEAN ZeroBuffer = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsWriteClusters:  Entered\n") );
    DebugTrace( 0, Dbg, ("StartingVbo   -> %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("Buffer        -> %08lx\n", Buffer) );
    DebugTrace( 0, Dbg, ("ClusterCount  -> %08lx\n", ClusterCount) );

    //
    //  Force this operation to be synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Swap out the old Io context block.
    //

    PreviousContext = IrpContext->Union.NtfsIoContext;

    IrpContext->Union.NtfsIoContext = &LocalContext;
    State = IrpContext->State;
    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

    //
    //  Use a try-finally so we can clean up properly.
    //

    try {

        PIO_STACK_LOCATION IrpSp;

        RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));
        KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                           NotificationEvent,
                           FALSE );

        NewIrp = IoBuildAsynchronousFsdRequest( IRP_MJ_WRITE,
                                                Vcb->Vpb->DeviceObject,
                                                Buffer,
                                                ByteCount,
                                                (PLARGE_INTEGER)&StartingVbo,
                                                NULL );

        if (NewIrp == NULL) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        //
        //  We now have an Irp, we want to make it look as though it is part of
        //  the current call.  We need to adjust the Irp stack to update this.
        //

        IoSetNextIrpStackLocation( NewIrp );

        //
        //  Check if we're writing zeros 
        //  

        if (Buffer == NULL) {

            //
            //  This won't work for compression or encryption because they manipulate
            //  the input buffer
            //  

            ASSERT( !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_ENCRYPTED ) );

            Mdl = NtfsBuildZeroMdl( IrpContext, ByteCount, &Buffer ); 
            if (!Mdl) {
                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }
            ZeroBuffer = TRUE;
        }

        //
        //  Loop and do the write in chunks
        // 

        while (ByteCount != 0) {

            ULONG Size = ByteCount;

            if (!ZeroBuffer) {

                //
                //  Attempt to allocate a mdl - reducing the size if we fail until
                //  we're at a page size
                //

                do {

                    Mdl = IoAllocateMdl( Add2Ptr( Buffer, OriginalByteCount - ByteCount ), Size, FALSE, FALSE, NULL );

                    if (Mdl == NULL) {
                        Size = BlockAlignTruncate( Size / 2, (LONG)Vcb->BytesPerSector );
                    }
                } while ((Mdl == NULL) && (Size >= PAGE_SIZE));

                if (!Mdl) {
                    NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
                }
                //
                //  Now probe the buffer described by the Irp.  If we get an exception,
                //  deallocate the Mdl and return the appropriate "expected" status.
                //

                try {

                    MmProbeAndLockPages( Mdl, NewIrp->RequestorMode, IoReadAccess );

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    NTSTATUS Status;

                    Status = GetExceptionCode();

                    IoFreeMdl( Mdl );
                    NtfsRaiseStatus( IrpContext,
                                     FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER,
                                     NULL,
                                     NULL );
                }

                LockedUserBuffer = TRUE;
            } else {

                Size = min( ByteCount, Mdl->ByteCount );
            }

            //
            //  Put our buffer/Mdl into the Irp and update the offset and length
            //

            if (!ZeroBuffer) {
                NewIrp->UserBuffer = Add2Ptr( Buffer, OriginalByteCount - ByteCount );
            }
            NewIrp->MdlAddress = Mdl;

            IrpSp = IoGetCurrentIrpStackLocation( NewIrp );
            IrpSp->DeviceObject = Vcb->Vpb->DeviceObject;
            IrpSp->Parameters.Write.Length = Size;
            IrpSp->Parameters.Write.ByteOffset.QuadPart = StartingVbo;
            
            //
            //  Put the write code into the IrpContext.
            //

            IrpContext->MajorFunction = IRP_MJ_WRITE;

            //
            //  Write the data to the disk.
            //

            NtfsNonCachedIo( IrpContext,
                             NewIrp,
                             Scb,
                             StartingVbo,
                             Size,
                             0 );

            //
            //  If we encountered an error or didn't write all the bytes, then
            //  raise the error code.  We use the IoStatus in the Irp instead of
            //  our structure since this Irp will not be completed.
            //

            if (!NT_SUCCESS( NewIrp->IoStatus.Status )) {

                DebugTrace( 0, Dbg, ("Couldn't write clusters to disk -> %08lx\n", NewIrp->IoStatus.Status) );

                NtfsRaiseStatus( IrpContext, NewIrp->IoStatus.Status, NULL, NULL );

            } else if (NewIrp->IoStatus.Information != Size) {

                DebugTrace( 0, Dbg, ("Couldn't write all byes to disk\n") );
                NtfsRaiseStatus( IrpContext, STATUS_UNEXPECTED_IO_ERROR, NULL, NULL );
            }

            //
            //  Cleanup the MDL 
            //  

            if (LockedUserBuffer) {
                MmUnlockPages( NewIrp->MdlAddress );
                LockedUserBuffer = FALSE;
                IoFreeMdl( NewIrp->MdlAddress );
            }
            NewIrp->MdlAddress = NULL;

            //
            //  Adjust offset and length
            //  

            ByteCount -= Size;
            StartingVbo += Size;
        }

    } finally {

        DebugUnwind( NtfsWriteClusters );

        //
        //  Recover the Io Context and remember if it is from pool.
        //

        IrpContext->Union.NtfsIoContext = PreviousContext;

        SetFlag( IrpContext->State, FlagOn( State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT ) );

        IrpContext->MajorFunction = MajorFunction;

        //
        //  If we allocated an Irp, we need to deallocate it.  We also
        //  have to return the correct function code to the Irp Context.
        //

        if (NewIrp != NULL) {

            //
            //  If there is an Mdl we free that first.
            //

            if (NewIrp->MdlAddress != NULL) {

                if (LockedUserBuffer) {

                    MmUnlockPages( NewIrp->MdlAddress );
                }

                IoFreeMdl( NewIrp->MdlAddress );
            }

            IoFreeIrp( NewIrp );
        }

        if (ZeroBuffer && Buffer) {
            NtfsFreePool( Buffer );
        }

        DebugTrace( -1, Dbg, ("NtfsWriteClusters:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns,
    IN UCHAR IrpSpFlags
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read/write
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.  This initialization
    includes allocation of a spinlock.  The spinlock is deallocated in the
    NtfsWaitSync routine, so it is essential that the caller insure that
    this routine is always called under all circumstances following a call
    to this routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    DeviceObject - Supplies the device to be read

    MasterIrp - Supplies the master Irp.

    MulitpleIrpCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Vbo, Lbo, BufferOffset, and
        ByteCount for all the runs to executed in parallel.

    IrpSpFlags - Flags to set in the irp stack location for the i/o - i.e write through


Return Value:

    None.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    PNTFS_IO_CONTEXT Context;
    ULONG TotalByteCount = 0;

    ULONG UnwindRunCount = 0;

    BOOLEAN Wait;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMultipleAsync\n") );
    DebugTrace( 0, Dbg, ("MajorFunction    = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("DeviceObject     = %08lx\n", DeviceObject) );
    DebugTrace( 0, Dbg, ("MasterIrp        = %08lx\n", MasterIrp) );
    DebugTrace( 0, Dbg, ("MultipleIrpCount = %08lx\n", MultipleIrpCount) );
    DebugTrace( 0, Dbg, ("IoRuns           = %08lx\n", IoRuns) );

    //
    //  Set up things according to whether this is truely async.
    //

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    Context = IrpContext->Union.NtfsIoContext;

    try {

        //
        //  Initialize Context, for use in Read/Write Multiple Asynch.
        //

        Context->MasterIrp = MasterIrp;

        //
        //  Iterate through the runs, doing everything that can fail
        //

        for ( UnwindRunCount = 0;
              UnwindRunCount < MultipleIrpCount;
              UnwindRunCount++ ) {

            //
            //  Create an associated IRP, making sure there is one stack entry for
            //  us, as well.
            //

            IoRuns[UnwindRunCount].SavedIrp = NULL;

            Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(DeviceObject->StackSize + 1) );

            if (Irp == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            IoRuns[UnwindRunCount].SavedIrp = Irp;

            //
            //  Allocate and build a partial Mdl for the request.
            //

            Mdl = IoAllocateMdl( (PCHAR)MasterIrp->UserBuffer +
                                 IoRuns[UnwindRunCount].BufferOffset,
                                 IoRuns[UnwindRunCount].ByteCount,
                                 FALSE,
                                 FALSE,
                                 Irp );

            if (Mdl == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            //
            //  Sanity Check
            //

            ASSERT( Mdl == Irp->MdlAddress );

            IoBuildPartialMdl( MasterIrp->MdlAddress,
                               Mdl,
                               (PCHAR)MasterIrp->UserBuffer +
                               IoRuns[UnwindRunCount].BufferOffset,
                               IoRuns[UnwindRunCount].ByteCount );

            //
            //  Get the first IRP stack location in the associated Irp
            //

            IoSetNextIrpStackLocation( Irp );
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Setup the Stack location to describe our read.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].StartingVbo;

            //
            //  If this Irp is the result of a WriteThough operation,
            //  tell the device to write it through.
            //

            if (FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH)) {

                SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
            }

            //
            //  Set up the completion routine address in our stack frame.
            //

            IoSetCompletionRoutine( Irp,
                                    (Wait
                                     ? &NtfsMultiSyncCompletionRoutine
                                     : &NtfsMultiAsyncCompletionRoutine),
                                    Context,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Setup the next IRP stack location in the associated Irp for the disk
            //  driver beneath us.
            //

            IrpSp = IoGetNextIrpStackLocation( Irp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Flags = IrpSpFlags;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].StartingLbo;
            TotalByteCount += IoRuns[UnwindRunCount].ByteCount;
        }

        //
        //  We only need to set the associated IRP count in the master irp to
        //  make it a master IRP.  But we set the count to one more than our
        //  caller requested, because we do not want the I/O system to complete
        //  the I/O.  We also set our own count.
        //

        Context->IrpCount = MultipleIrpCount;
        MasterIrp->AssociatedIrp.IrpCount = MultipleIrpCount;
        IrpSp = IoGetCurrentIrpStackLocation( MasterIrp );
        IrpSp->Parameters.Read.Length = TotalByteCount;


        if (Wait) {

            MasterIrp->AssociatedIrp.IrpCount += 1;
        } else {

            //
            //  Convert the resource ownership to async before we do the i/o if 
            //  we haven't already 
            //  

            if (IrpContext->Union.NtfsIoContext->Wait.Async.Resource && 
                !FlagOn( IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId, 3 )) {

                ASSERT( NtfsIsSharedResource( IrpContext->Union.NtfsIoContext->Wait.Async.Resource ) == 1 );

                IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId = (ERESOURCE_THREAD)MasterIrp | 3;
                ExSetResourceOwnerPointer( IrpContext->Union.NtfsIoContext->Wait.Async.Resource, (PVOID)IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId );
            }
        }

        //
        //  Now that all the dangerous work is done, issue the Io requests
        //

        for (UnwindRunCount = 0;
             UnwindRunCount < MultipleIrpCount;
             UnwindRunCount++) {

            Irp = IoRuns[UnwindRunCount].SavedIrp;

            //
            //  If IoCallDriver returns an error, it has completed the Irp
            //  and the error will be caught by our completion routines
            //  and dealt with as a normal IO error.
            //

            (VOID)IoCallDriver( DeviceObject, Irp );
        }

    } finally {

        ULONG i;

        DebugUnwind( NtfsMultipleAsync );

        //
        //  Only allocating the spinlock, making the associated Irps
        //  and allocating the Mdls can fail.
        //

        if (AbnormalTermination()) {

            //
            //  Unwind
            //

            for (i = 0; i <= UnwindRunCount; i++) {

                if ((Irp = IoRuns[i].SavedIrp) != NULL) {

                    if (Irp->MdlAddress != NULL) {

                        IoFreeMdl( Irp->MdlAddress );
                    }

                    IoFreeIrp( Irp );
                }
            }
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsMultipleAsync -> VOID\n") );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN UCHAR IrpSpFlags
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    DeviceObject - Supplies the device to read

    Lbo - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

    MajorFunction - IRP_MJ_READ || IRP_MJ_WRITE

    IrpSpFlags - flags to set in the irp stack location for the i/o like write through

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSingleAsync\n") );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("DeviceObject  = %08lx\n", DeviceObject) );
    DebugTrace( 0, Dbg, ("Lbo           = %016I64x\n", Lbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );


    //
    //  Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )
                             ? &NtfsSingleSyncCompletionRoutine
                             : &NtfsSingleAsyncCompletionRoutine),
                            IrpContext->Union.NtfsIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;
    IrpSp->Flags = IrpSpFlags;

    //
    //  If this Irp is the result of a WriteThough operation,
    //  tell the device to write it through.
    //

    if (FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH)) {

        SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
    }

    //
    //  Convert the resource ownership to async before we do the i/o if 
    //  we haven't already 
    //  

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) &&
        IrpContext->Union.NtfsIoContext->Wait.Async.Resource && 
        !FlagOn( IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId, 3 )) {

        ASSERT( NtfsIsSharedResource( IrpContext->Union.NtfsIoContext->Wait.Async.Resource ) == 1 );

        IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId = (ERESOURCE_THREAD)Irp | 3;
        ExSetResourceOwnerPointer( IrpContext->Union.NtfsIoContext->Wait.Async.Resource, (PVOID)IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId );
    }

    //
    //  Issue the Io request
    //

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)IoCallDriver( DeviceObject, Irp );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSingleAsync -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsWaitSync (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine waits for one or more previously started I/O requests
    from the above routines, by simply waiting on the event.

Arguments:

    Context - Pointer to Context used in previous call(s) to be waited on.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsWaitSync:  Entered\n") );

    KeWaitForSingleObject( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeClearEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent );

    DebugTrace( -1, Dbg, ("NtfsWaitSync -> VOID\n") );
}


//
//  Local support routine.
//

NTSTATUS
NtfsMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads and writes
    started via NtfsMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{

    PNTFS_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN CompleteRequest = TRUE;

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, ("NtfsMultiAsyncCompletionRoutine, Context = %08lx\n", Context) );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        MasterIrp->IoStatus = Irp->IoStatus;

        //
        //  Track any lower drivers that fail a paging file operation insuff. resources
        //

        if ((Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) &&
            FlagOn( Context->Flags, NTFS_IO_CONTEXT_PAGING_IO ) &&
            (IrpSp->MajorFunction == IRP_MJ_READ)) {

            NtfsFailedHandedOffPagingReads += 1;
        }
    }

    //
    //  Decrement IrpCount and see if it goes to zero.
    //

    if (InterlockedDecrement( &Context->IrpCount ) == 0) {

        PERESOURCE Resource;
        ERESOURCE_THREAD ResourceThreadId;

        //
        //  Capture the resource values out of the context to prevent
        //  colliding with the Fsp thread if we post this.
        //

        Resource = Context->Wait.Async.Resource;
        ResourceThreadId = Context->Wait.Async.ResourceThreadId;

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( MasterIrp );

        //
        //  If this request was successful or we posted an async paging io
        //  request then complete this irp.
        //

        if (FT_SUCCESS( MasterIrp->IoStatus.Status )) {

            //
            //  Do any necc. zeroing for read requests - if it fails then just complete
            //  the irp ZeroEndOfBuffer will put the error into the irp iostatus
            //

            if (NtfsZeroEndOfBuffer( MasterIrp, Context )) {
                MasterIrp->IoStatus.Information =
                    Context->Wait.Async.RequestedByteCount;

                //
                //  Go ahead an mark the File object to indicate that we performed
                //  either a read or write if this is not a paging io operation.
                //

                if (!FlagOn( Context->Flags, NTFS_IO_CONTEXT_PAGING_IO ) &&
                    (IrpSp->FileObject != NULL)) {

                    if (IrpSp->MajorFunction == IRP_MJ_READ) {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );

                    } else {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_MODIFIED );
                    }
                }
            }

        //
        //  If we had an error and will hot fix, we simply post the entire
        //  request.
        //

        } else if (!FlagOn( Context->Flags, NTFS_IO_CONTEXT_PAGING_IO )) {

            PIRP_CONTEXT IrpContext = NULL;

            //
            //  We need an IrpContext and then have to post the request.
            //  Use a try_except in case we fail the request for an IrpContext.
            //

            CompleteRequest = FALSE;
            try {

                NtfsInitializeIrpContext( MasterIrp, TRUE, &IrpContext );
                IrpContext->Union.NtfsIoContext = Context;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                NtfsPostRequest( IrpContext, MasterIrp );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                //  Just give up.
                //

                CompleteRequest = TRUE;

                if (IrpContext) {

                    //
                    //  We cleanup the context below.
                    //

                    IrpContext->Union.NtfsIoContext = NULL;
                    NtfsCleanupIrpContext( IrpContext, TRUE );
                }
            }
        }

        //
        //  Now release the resource
        //

        if (Resource != NULL) {

            ExReleaseResourceForThreadLite( Resource,
                                        ResourceThreadId );
        }

        if (CompleteRequest) {

            //
            //  and finally, free the context record.
            //

            ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, Context );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsMultiAsyncCompletionRoutine\n") );

    //
    //  Return more processing required if we don't want the Irp to go away.
    //

    if (CompleteRequest) {

        return STATUS_SUCCESS;

    } else {

        //
        //  We need to cleanup the associated Irp and its Mdl.
        //

        IoFreeMdl( Irp->MdlAddress );
        IoFreeIrp( Irp );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
}


//
//  Local support routine.
//

NTSTATUS
NtfsMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all synchronous reads and writes
    started via NtfsMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{

    PNTFS_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;

    DebugTrace( +1, Dbg, ("NtfsMultiSyncCompletionRoutine, Context = %08lx\n", Context) );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        MasterIrp->IoStatus = Irp->IoStatus;

        //
        //  Track any lower drivers that fail a paging file operation insuff. resources
        //

        if ((Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) &&
            FlagOn( Context->Flags, NTFS_IO_CONTEXT_PAGING_IO ) &&
            (IoGetCurrentIrpStackLocation( Irp )->MajorFunction == IRP_MJ_READ)) {

            NtfsFailedHandedOffPagingReads += 1;
        }
    }

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    if (InterlockedDecrement(&Context->IrpCount) == 0) {

        KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );
    }

    DebugTrace( -1, Dbg, ("NtfsMultiSyncCompletionRoutine -> STATUS_MORE_PROCESSING_REQUIRED\n") );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

NTSTATUS
NtfsSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads and writes
    started via NtfsSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             NtfsSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PNTFS_IO_CONTEXT Context = Contxt;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN CompleteRequest = TRUE;

    PERESOURCE Resource;
    ERESOURCE_THREAD ResourceThreadId;

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, ("NtfsSingleAsyncCompletionRoutine, Context = %08lx\n", Context) );

    //
    //  Capture the resource values out of the context to prevent
    //  colliding with the Fsp thread if we post this.
    //

    Resource = Context->Wait.Async.Resource;
    ResourceThreadId = Context->Wait.Async.ResourceThreadId;

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  Fill in the information field correctedly if this worked.
    //

    if (FT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Zero the difference between filesize and data read if necc. on reads
        //  if it fails just complete the irp - ZeroEndOfBuffer will put the error into the
        //  irp
        //

        if (NtfsZeroEndOfBuffer( Irp, Context )) {
            Irp->IoStatus.Information = Context->Wait.Async.RequestedByteCount;

            //
            //  Go ahead an mark the File object to indicate that we performed
            //  either a read or write.
            //

            if (!FlagOn( Context->Flags, NTFS_IO_CONTEXT_PAGING_IO ) &&
                (IrpSp->FileObject != NULL)) {

                if (IrpSp->MajorFunction == IRP_MJ_READ) {

                    SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );

                } else {

                    SetFlag( IrpSp->FileObject->Flags, FO_FILE_MODIFIED );
                }
            }
        }

    //
    //  If we had an error and will hot fix, we simply post the entire
    //  request.
    //

    } else if (!FlagOn( Context->Flags, NTFS_IO_CONTEXT_PAGING_IO )) {

        PIRP_CONTEXT IrpContext = NULL;

        //
        //  We need an IrpContext and then have to post the request.
        //  Use a try_except in case we fail the request for an IrpContext.
        //

        CompleteRequest = FALSE;
        try {

            NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );
            IrpContext->Union.NtfsIoContext = Context;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

            NtfsPostRequest( IrpContext, Irp );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  Just give up.
            //

            CompleteRequest = TRUE;

            if (IrpContext) {

                //
                //  We cleanup the context below.
                //

                IrpContext->Union.NtfsIoContext = NULL;
                NtfsCleanupIrpContext( IrpContext, TRUE );
            }
        }
    } else if ((Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) &&
               (IrpSp->MajorFunction == IRP_MJ_READ)) {

        //
        //  Track any lower drivers that fail a paging file operation insuff. resources
        //

        NtfsFailedHandedOffPagingReads += 1;
    }

    //
    //  Now release the resource
    //

    if (Resource != NULL) {

        ExReleaseResourceForThreadLite( Resource,
                                    ResourceThreadId );
    }

    //
    //  and finally, free the context record.
    //

    DebugTrace( -1, Dbg, ("NtfsSingleAsyncCompletionRoutine -> STATUS_SUCCESS\n") );

    if (CompleteRequest) {

        ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, Context );
        return STATUS_SUCCESS;

    } else {

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

}


//
//  Local support routine.
//

NTSTATUS
NtfsSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    NtfsSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             NtfsSingleAsynch.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    PNTFS_IO_CONTEXT Context = Contxt;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Track any lower drivers that fail a paging file operation insuff. resources
    //

    if ((Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) &&
        FlagOn( Context->Flags, NTFS_IO_CONTEXT_PAGING_IO ) &&
        (IrpSp->MajorFunction == IRP_MJ_READ)) {

        NtfsFailedHandedOffPagingReads += 1;
    }

    KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );

    DebugTrace( -1, Dbg, ("NtfsSingleCompletionRoutine -> STATUS_MORE_PROCESSING_REQUIRED\n") );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}



//
//  Local support routine.
//

NTSTATUS
NtfsPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    NtfsPagingFileIo.

    The completion routine has has the following responsibility:

        Since the individual request was completed with an error,
        this completion routine must stuff it into the master irp.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    MasterIrp - Pointer to the master Irp.  The low order bit in this value will
        be set if a higher level call is performing a hot-fix.

Return Value:

    Always returns STATUS_SUCCESS.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, ("NtfsPagingFileCompletionRoutine, MasterIrp = %08lx\n", MasterIrp) );

    ASSERT( (Irp->IoStatus.Status != STATUS_INSUFFICIENT_RESOURCES) ||
            (IrpSp->Parameters.Read.Length > PAGE_SIZE) );

    if (!FT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Track any lower drivers that fail a paging file operation insuff. resources
        //

        if (Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) {
            NtfsFailedHandedOffPagingFileOps += 1;
        }

        if (!FsRtlIsTotalDeviceFailure( Irp->IoStatus.Status ) &&
            (Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED) &&
            !FlagOn( (ULONG_PTR) MasterIrp, 0x1 )) {

            if  (Irp->IoStatus.Status == STATUS_FT_READ_RECOVERY_FROM_BACKUP) {

                //
                //  If the volume manager has actually completed the read
                //  from a backup, there's little point in telling MM about that.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            //
            //  We don't want to try to hotfix READ errors on the paging file
            //  because of deadlock possibilities with MM. Instead we'll just
            //  return the error for MM to deal with. Chances are that
            //  MM (eg. MiWaitForInPageComplete) will bugcheck anyway,
            //  but it's still nicer than walking right into the deadlock.
            //  We also only asynchronously fix write errors and just return the error
            //  back for mm to retry elsewhere
            //

            if (IrpSp->MajorFunction != IRP_MJ_READ) {

                VBO BadVbo;

                BadVbo = IrpSp->Parameters.Read.Key;

                NtfsPostHotFix( Irp,
                                &BadVbo,
                                IrpSp->Parameters.Read.ByteOffset.QuadPart,
                                IrpSp->Parameters.Read.Length,
                                FALSE );
            }
        }

        //
        //  If we got an error (or verify required), remember it in the Irp
        //

        ClearFlag( (ULONG_PTR) MasterIrp, 0x1 );
        ((PIRP) MasterIrp)->IoStatus = Irp->IoStatus;
    }

    DebugTrace( -1, Dbg, ("NtfsPagingFileCompletionRoutine => (STATUS_SUCCESS)\n") );

    return STATUS_SUCCESS;
}


//
//  Local support routine.
//

NTSTATUS
NtfsPagingFileNoAllocCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    NtfsPagingFileIoNoAllocation.

    The completion routine signals back to the main routine and stops processing

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Context -  Actually the event to signal

Return Value:

    Always returns STATUS_SUCCESS.

--*/

{
    PKEVENT Event = (PKEVENT) Context;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ASSERT( (Irp->IoStatus.Status != STATUS_INSUFFICIENT_RESOURCES) ||
            (IrpSp->Parameters.Read.Length > PAGE_SIZE) );

    //
    //  Track any lower drivers that fail a paging file operation insuff. resources
    //

    if (Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) {
        NtfsFailedHandedOffPagingFileOps += 1;
    }

    KeSetEvent( Event, IO_NO_INCREMENT, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}


//
//  Local support routine
//

VOID
NtfsSingleNonAlignedSync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PUCHAR Buffer,
    IN VBO Vbo,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    Synchronously, and does so to a buffer that must come from non paged
    pool.  It saves a pointer to the Irp's original Mdl, and creates a new
    one describing the given buffer.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

    Currently, only reads are supported.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to read

    Scb - Supplies the Scb to read

    Buffer - Supplies a buffer from non-paged pool.

    Vbo - Supplies the starting Virtual Block Offset to begin reading from

    Lbo - Supplies the starting Logical Block Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

    Context - Asynchronous I/O context structure

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PMDL Mdl;
    PMDL SavedMdl;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSingleNonAlignedSync\n") );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Vcb           = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Buffer        = %08lx\n", Buffer) );
    DebugTrace( 0, Dbg, ("Lbo           = %016I64x\n", Lbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );

    //
    //  Create a new Mdl describing the buffer, saving the current one in the
    //  Irp
    //

    SavedMdl = Irp->MdlAddress;

    Irp->MdlAddress = 0;

    Mdl = IoAllocateMdl( Buffer,
                         ByteCount,
                         FALSE,
                         FALSE,
                         Irp );

    if (Mdl == NULL) {

        Irp->MdlAddress = SavedMdl;

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    //
    //  Lock the new Mdl in memory.
    //

    try {

        MmProbeAndLockPages( Mdl, KernelMode, IoWriteAccess );

    } finally {

        if (AbnormalTermination()) {

            IoFreeMdl( Mdl );
            Irp->MdlAddress = SavedMdl;
        }
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            &NtfsSingleSyncCompletionRoutine,
                            IrpContext->Union.NtfsIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IrpContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;

    //
    // Initialize the Kernel Event in the context structure so that the
    // caller can wait on it.  Set remaining pointers to NULL.
    //

    KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                       NotificationEvent,
                       FALSE );

    //
    //  Issue the read request
    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    try {

        (VOID)IoCallDriver( Vcb->TargetDeviceObject, Irp );

        NtfsWaitSync( IrpContext );

        //
        //  See if we need to do a hot fix.
        //

        if (!FT_SUCCESS(Irp->IoStatus.Status)) {

            IO_RUN IoRun;

            IoRun.StartingVbo = Vbo;
            IoRun.StartingLbo = Lbo;
            IoRun.BufferOffset = 0;
            IoRun.ByteCount = ByteCount;
            IoRun.SavedIrp = NULL;

            //
            //  Try to fix the problem
            //

            NtfsFixDataError( IrpContext,
                              Scb,
                              Vcb->TargetDeviceObject,
                              Irp,
                              1,
                              &IoRun,
                              0 );
        }

    } finally {

        MmUnlockPages( Mdl );

        IoFreeMdl( Mdl );

        Irp->MdlAddress = SavedMdl;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSingleNonAlignedSync -> VOID\n") );

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsEncryptBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext
    )

/*++

Routine Description:

    This routine is called by NtfsPrepareBuffers during a write
    operation on an encrypted file.  It allocates a compression
    buffer if necessary and calls the encyrption callout routine
    to compress each run of data in the CompressionContext.

Arguments:

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    NumberRuns - The size of the IoRuns array in the compression context.

    CompressionContext - Supplies the CompressionContext for this stream.

Return Value:

    None.

--*/

{
    ULONG Run;
    ULONG BufferSize;
    LARGE_INTEGER OffsetWithinFile;
    PIO_RUN IoRun;

    PUCHAR SourceBuffer;
    PUCHAR DestinationBuffer;

    NTSTATUS Status;

    ASSERT( NumberRuns > 0 );
    ASSERT( IrpContext->MajorFunction == IRP_MJ_WRITE );

    //
    //  These functions are just for debugging purposes.  We need to call them
    //  somewhere so the compiler doesn't optimize them out as unreferenced functions.
    //

#ifdef EFSDBG
    if (CompressionContext->SystemBufferOffset != 0) {

        DebugTrace( 0, Dbg, ("\nEncryptBuffers: SystemBufferOffset = %x", CompressionContext->SystemBufferOffset) );
    }
#endif

    //
    //  If we have not already mapped the user buffer, then do so.
    //

    if (CompressionContext->SystemBuffer == NULL) {

        CompressionContext->SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
    }

    //
    //  For uncompressed files, we may not have a buffer allocated yet.
    //  The buffer needs to be big enough for this entire transfer.
    //  It must be big enough to go from StartingVbo for this
    //  transfer to the end of the last iorun for this transfer.
    //

    BufferSize = (ULONG) ((CompressionContext->IoRuns[NumberRuns-1].StartingVbo +
                            CompressionContext->IoRuns[NumberRuns-1].ByteCount) -
                          StartingVbo);

    if (BufferSize > LARGE_BUFFER_SIZE) {

        BufferSize = LARGE_BUFFER_SIZE;
    }

    //
    //  If the data already got transformed, the buffer should still be allocated.
    //

    ASSERT( (!CompressionContext->DataTransformed) ||
            (CompressionContext->CompressionBuffer != NULL) );

    //
    //  This function conveniently only allocates/reallocates the buffer
    //  if there is not one allocated yet or if the existing one is not
    //  big enough.
    //

    NtfsAllocateCompressionBuffer( IrpContext,
                                   Scb,
                                   Irp,
                                   CompressionContext,
                                   &BufferSize );

    //
    //  If the data has already be transformed into the compression buffer, for
    //  a compressed or sparse file, for instance, we want to work with the
    //  transformed data.  Otherwise, we need to pluck it directly out of the
    //  system buffer.
    //

    if (CompressionContext->DataTransformed) {

        SourceBuffer = DestinationBuffer = CompressionContext->CompressionBuffer;

    } else {

        SourceBuffer = Add2Ptr( CompressionContext->SystemBuffer, CompressionContext->SystemBufferOffset );
        DestinationBuffer = CompressionContext->CompressionBuffer;
    }

    //
    //  Now look at each run of real data heading to the disk and
    //  let the encryption driver encrypt it.
    //

    for (Run = 0; Run < NumberRuns; Run++) {

        IoRun = &CompressionContext->IoRuns[Run];
        OffsetWithinFile.QuadPart = IoRun->StartingVbo;

        Status = NtfsData.EncryptionCallBackTable.BeforeWriteProcess( Add2Ptr(SourceBuffer, IoRun->BufferOffset),
                                                                      Add2Ptr(DestinationBuffer, IoRun->BufferOffset),
                                                                      &OffsetWithinFile,
                                                                      IoRun->ByteCount,
                                                                      Scb->EncryptionContext);
        if (!NT_SUCCESS( Status )) {

            return Status;
        }
    }

    return STATUS_SUCCESS;
}


VOID
NtfsFixDataError (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns,
    IN UCHAR IrpSpFlags
    )

/*

Routine Description:

    This routine is called when a read error, write error, or Usa error
    is received when doing noncached I/O on a stream.  It attempts to
    recover from Usa errors if FT is present.  For bad clusters it attempts
    to isolate the error to one or more bad clusters, for which hot fix
    requests are posted.

Arguments:

    Scb - Supplies the Scb for the stream which got the error

    DeviceObject - Supplies the Device Object for the stream

    MasterIrp - Supplies the original master Irp for the failing read or write

    MultipleIrpCount - Supplies the number of runs in which the current
                       was broken into at the time the error occured.

    IoRuns - Supplies an array describing the runs being accessed at the
             time of the error

    IrpSpFlags - flags to set in irp stack location for the i/o like write_through

Return Value:

    None

-*/

{
    ULONG RunNumber, FtCase;
    ULONG ByteOffset = MAXULONG;
    ULONG ClusterMask;
    ULONG ClustersToRecover;
    ULONG UsaBlockSize;
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb = Scb->Vcb;
    ULONG BytesPerCluster = Vcb->BytesPerCluster;
    NTSTATUS FinalStatus = STATUS_SUCCESS;
    ULONG AlignedRunNumber = 0;
    ULONG AlignedByteOffset = 0;
    NTSTATUS IrpStatus = MasterIrp->IoStatus.Status;
    PTOP_LEVEL_CONTEXT TopLevelContext;

    PNTFS_IO_CONTEXT Context = IrpContext->Union.NtfsIoContext;
    PMULTI_SECTOR_HEADER MultiSectorHeader;

    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * 2];
    PMDL PartialMdl = (PMDL) Buffer;

    LONGLONG LlTemp1;
    LONGLONG LlTemp2;
    ULONG Priority = NormalPagePriority;

    BOOLEAN SecondaryAvailable;
    BOOLEAN FixingUsaError;
    BOOLEAN FinalPass;
    BOOLEAN ReservedMapping = FALSE;

    PAGED_CODE();

    //
    //  First, if the error we got indicates a total device failure, then we
    //  just report it rather than trying to hot fix every sector on the volume!
    //  Also, do not do hot fix for the read ahead thread, because that is a
    //  good way to conceal errors from the App.
    //

    if (FsRtlIsTotalDeviceFailure( MasterIrp->IoStatus.Status ) ||
        (Scb->CompressionUnit != 0)) {

        return;
    }

    //
    //  Get out if we got an error and the current thread is doing read ahead.
    //

    if (!NT_SUCCESS( MasterIrp->IoStatus.Status ) && NtfsIsReadAheadThread()) {

        return;
    }

    //
    //  Also get out if the top level request came from the fast io path.
    //

    TopLevelContext = NtfsGetTopLevelContext();

    if (TopLevelContext->SavedTopLevelIrp == (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP) {

        return;
    }

    //
    //  We can't hot fix the mft mirror or the boot file.  If we're in here
    //  for one of those files, we have to get out now.  We'll make sure we
    //  aren't trying to hot fix the beginning of the mft itself just before
    //  we call NtfsPostHotFix down below.
    //

    ASSERT (Scb != NULL);

    if ((Scb == Vcb->Mft2Scb) ||
        (NtfsEqualMftRef( &Scb->Fcb->FileReference, &BootFileReference ) &&
         (Scb->AttributeTypeCode == $DATA))) {

        return;
    }

    //
    //  Determine whether a secondary device is available
    //

    SecondaryAvailable = (BOOLEAN)!FlagOn( Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE );

    //
    //  Assume that we are recovering from a Usa error, if the MasterIrp has
    //  the success status.
    //

    FixingUsaError = FT_SUCCESS( MasterIrp->IoStatus.Status );

    //
    //  We cannot fix any Usa errors if there is no secondary.  Even if there is
    //  a secondary, Usa errors should only occur during restart.  If it is not
    //  restart we are probably looking at uninitialized data, so don't try to
    //  "fix" it.
    //

    if (FixingUsaError &&
        (!SecondaryAvailable || !FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ))) {
        return;
    }

    //
    //  If there is no secondary available and this is a user non-cached read then simply
    //  return the error.  Give this user a chance to re-write the sector himself using
    //  non-cached io.
    //

    if (!SecondaryAvailable &&
        (IrpContext->MajorFunction == IRP_MJ_READ) &&
        (FlagOn( MasterIrp->Flags, IRP_PAGING_IO | IRP_NOCACHE ) == IRP_NOCACHE)) {

        return;
    }

    //
    //  No hot fixing at all if the volume is read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        return;
    }

    //
    //  Initialize Context, for use in Read/Write Multiple Asynch.
    //

    ASSERT( Context != NULL );

    Context->MasterIrp = MasterIrp;
    KeInitializeEvent( &Context->Wait.SyncEvent, NotificationEvent, FALSE );

    HotFixTrace(("NtfsFixDataError, MasterIrp: %08lx, MultipleIrpCount: %08lx\n", MasterIrp, MultipleIrpCount));
    HotFixTrace(("                  IoRuns: %08lx, UsaError: %02lx\n", IoRuns, FixingUsaError));
    HotFixTrace(("                  Thread: %08lx\n", PsGetCurrentThread()));
    HotFixTrace(("                  Scb:    %08lx   BadClusterScb:  %08lx\n", Scb, Vcb->BadClusterFileScb));

    //
    //  If this is a Usa-protected structure, get the block size now.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT )) {

        //
        //  Get the the number of blocks, based on what type of stream it is.
        //  First check for Mft or Log file.
        //

        if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

            ASSERT( (Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb) );

            UsaBlockSize = Vcb->BytesPerFileRecordSegment;

        } else if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) {

            //
            //  For the log file, we will just go a page at a time, which
            //  is generally what the log file does.  Any USA errors would
            //  tend to be only at the logical end of the log file anyway.
            //

            ASSERT( Scb == Vcb->LogFileScb );

            //
            //  We need to peek at the page so map it in
            //

            MultiSectorHeader = (PMULTI_SECTOR_HEADER) NtfsMapUserBufferNoRaise( MasterIrp, HighPagePriority );

            //
            //  We can't map the user buffer due to low resources - so switch to using the reserved
            //  mapping instead
            //

            if (MultiSectorHeader == NULL) {

                ExAcquireFastMutexUnsafe( &Vcb->ReservedMappingMutex );
                ReservedMapping = TRUE;

                MmInitializeMdl( PartialMdl, NULL, 2 * PAGE_SIZE );
                IoBuildPartialMdl( MasterIrp->MdlAddress, PartialMdl, Add2Ptr( MmGetMdlBaseVa( MasterIrp->MdlAddress ), MmGetMdlByteOffset( MasterIrp->MdlAddress )), Vcb->BytesPerSector );
                MultiSectorHeader = (PMULTI_SECTOR_HEADER) MmMapLockedPagesWithReservedMapping( IrpContext->Vcb->ReservedMapping,
                                                                                                RESERVE_POOL_TAG,
                                                                                                PartialMdl,
                                                                                                MmCached );
                ASSERT( MultiSectorHeader != NULL );
            }

            //
            //  For the log file, assume it is right in the record, use that
            //  if we get a plausible number, else use page size.
            //

            RunNumber = MultiSectorHeader->UpdateSequenceArraySize - 1;
            UsaBlockSize = RunNumber * SEQUENCE_NUMBER_STRIDE;

            if ((UsaBlockSize != 0x1000) && (UsaBlockSize != 0x2000) && (UsaBlockSize != PAGE_SIZE)) {

                UsaBlockSize = PAGE_SIZE;
            }

            //
            //  Drop the reserved mapping - since we're done with the multi-sector header
            //

            if (ReservedMapping) {
                MmUnmapReservedMapping( Vcb->ReservedMapping, RESERVE_POOL_TAG, PartialMdl );
                MmPrepareMdlForReuse( PartialMdl );
                ExReleaseFastMutexUnsafe( &Vcb->ReservedMappingMutex );
                ReservedMapping = FALSE;
                MultiSectorHeader = NULL;
            }

        //
        //  Otherwise it is an index, so we can get the count out of the Scb.
        //

        } else {

            UsaBlockSize = Scb->ScbType.Index.BytesPerIndexBuffer;
        }

        //
        //  Verify the maximum of UsaBlockSize and cluster size.
        //

        if (BytesPerCluster > UsaBlockSize) {

            //
            //  Determine which is smaller the cluster size or the
            //  size of the buffer being read.
            //

            IrpSp = IoGetCurrentIrpStackLocation( MasterIrp );

            UsaBlockSize = IrpSp->Parameters.Read.Length;
            if (UsaBlockSize > BytesPerCluster) {

                UsaBlockSize = BytesPerCluster;
            }
        }
    }

    //
    //  We know we got a failure in the given transfer, which could be any size.
    //  We first want to localize the error to the failing cluster(s).
    //
    //  We do this in the following nested loops:
    //
    //      do (for the entire transfer, 32 clusters at a time)
    //
    //          for (primary, secondary if available, primary again if necessary)
    //
    //              for (each run)
    //
    //                  for (each cluster)
    //
    //  The inner-most two loops above have the ability to restart on successive
    //  32-cluster boundaries, relative to the first cluster in the transfer.
    //  For the Ft case, where there is a secondary device available, clusters
    //  are blocked out of a mask as errors are found and corrected, so they
    //  do not have to be read in successive passes; Usa errors are blocked out
    //  of the mask immediately, while for I/O errors we force ourselves to read
    //  both copies to locate the error, only reading the primary again if the
    //  secondary contained the error.
    //

    //
    //  Loop through the entire transfer, 32 clusters at a time.  The innermost
    //  loops will terminate on 32 cluster boundaries, so the outermost loop
    //  will simply keep looping until we exhaust the IoRuns array.
    //

    do {

        //
        //  Initialize the clusters to recover to "all".
        //

        ClustersToRecover = MAXULONG;
        FinalPass = FALSE;

        //
        //  For these 32 clusters, loop through primary, secondary (if available),
        //  and primary again (only reading when necessary).
        //

        for (FtCase = 0; !FinalPass; FtCase++) {

            //
            //  Calculate whether this is the final pass or not.
            //

            FinalPass = !SecondaryAvailable ||
                        (FtCase == 2) ||
                        (IrpContext->MajorFunction == IRP_MJ_WRITE);

            //
            //  Initialize the current cluster mask for cluster 0
            //

            ClusterMask = 1;

            //
            //  Loop through all of the runs in the IoRuns array, or until the
            //  ClusterMask indicates that we hit a 32 cluster boundary.
            //

            for (RunNumber = AlignedRunNumber;
                 (RunNumber < MultipleIrpCount) && (ClusterMask != 0);
                 (ClusterMask != 0) ? RunNumber++ : 0) {

                //
                //  Loop through all of the clusters within this run, or until
                //  the ClusterMask indicates that we hit a 32 cluster boundary.
                //

                for (ByteOffset = (RunNumber == AlignedRunNumber) ? AlignedByteOffset : 0;
                     (ByteOffset < IoRuns[RunNumber].ByteCount) && (ClusterMask != 0);
                     ByteOffset += BytesPerCluster, ClusterMask <<= 1) {

                    LONGLONG StartingVbo, StartingLbo;
                    PIRP Irp;
                    PMDL Mdl;
                    BOOLEAN LowFileRecord;
                    FT_SPECIAL_READ SpecialRead;
                    ULONG Length;

                    HotFixTrace(("Doing ByteOffset: %08lx for FtCase: %02lx\n",
                                (((ULONG)IoRuns[RunNumber].StartingVbo) + ByteOffset),
                                FtCase));

                    //
                    //  If this cluster no longer needs to be recovered, we can
                    //  skip it.
                    //

                    if ((ClustersToRecover & ClusterMask) == 0) {
                        continue;
                    }

                    //
                    //  Temporarily get the 64-bit byte offset into StartingVbo, then
                    //  calculate the actual StartingLbo and StartingVbo.
                    //

                    StartingVbo = ByteOffset;

                    StartingLbo = IoRuns[RunNumber].StartingLbo + StartingVbo;
                    StartingVbo = IoRuns[RunNumber].StartingVbo + StartingVbo;

                    //
                    //  If the file is compressed, then NtfsPrepareBuffers builds
                    //  an IoRuns array where it compresses contiguous Lcns, and
                    //  the Vcns do not always line up correctly.  But we know there
                    //  must be a corresponding Vcn for every Lcn in the stream,
                    //  and that that Vcn can only be >= to the Vcn we have just
                    //  calculated from the IoRuns array.  Therefore, since performance
                    //  of hotfix is not the issue here, we use the following simple
                    //  loop to sequentially scan the Mcb for a matching Vcn for
                    //  the current Lcn.
                    //

                    if (Scb->CompressionUnit != 0) {

                        VCN TempVcn;
                        LCN TempLcn, LcnOut;

                        TempLcn = LlClustersFromBytes( Vcb, StartingLbo );
                        TempVcn = LlClustersFromBytes( Vcb, StartingVbo );

                        //
                        //  Scan to the end of the Mcb (we assert below this
                        //  did not happen) or until we find a Vcn with the
                        //  Lcn we currently want to read.
                        //

                        while (NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                                       TempVcn,
                                                       &LcnOut,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL )

                                 &&

                               (LcnOut != TempLcn)) {

                            TempVcn = TempVcn + 1;
                        }

                        ASSERT(LcnOut == TempLcn);

                        StartingVbo = LlBytesFromClusters( Vcb, TempVcn );
                    }

                    LowFileRecord = (Scb == Vcb->MftScb) && (((PLARGE_INTEGER)&StartingVbo)->HighPart == 0);

                    //
                    //  Calculate the amount to actually read.
                    //


                    Length = IoRuns[RunNumber].ByteCount - ByteOffset;

                    if (Length > BytesPerCluster) {

                        Length = BytesPerCluster;
                    }

                    //
                    //  Loop while verify required, or we find we really
                    //  do not have an FT device.
                    //

                    while (TRUE) {

                        //
                        //  Create an associated IRP, making sure there is one stack entry for
                        //  us, as well.
                        //

                        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(DeviceObject->StackSize + 1) );

                        if (Irp == NULL) {

                            //
                            //  We return the error status in the Master irp when
                            //  we were called.
                            //

                            MasterIrp->IoStatus.Status = IrpStatus;
                            return;
                        }

                        //
                        // Allocate and build a partial Mdl for the request.
                        //

                        Mdl = IoAllocateMdl( (PCHAR)MasterIrp->UserBuffer + IoRuns[RunNumber].BufferOffset + ByteOffset,
                                             Length,
                                             FALSE,
                                             FALSE,
                                             Irp );

                        if (Mdl == NULL) {

                            IoFreeIrp(Irp);

                            //
                            //  We return the error status in the Master irp when
                            //  we were called.
                            //

                            MasterIrp->IoStatus.Status = IrpStatus;
                            return;
                        }

                        //
                        //  Sanity Check
                        //

                        ASSERT( Mdl == Irp->MdlAddress );

                        IoBuildPartialMdl( MasterIrp->MdlAddress,
                                           Mdl,
                                           (PCHAR)MasterIrp->UserBuffer +
                                             IoRuns[RunNumber].BufferOffset + ByteOffset,
                                           Length );

                        //
                        //  Get the first IRP stack location in the associated Irp
                        //

                        IoSetNextIrpStackLocation( Irp );
                        IrpSp = IoGetCurrentIrpStackLocation( Irp );

                        //
                        //  Setup the Stack location to describe our read.
                        //

                        IrpSp->MajorFunction = IrpContext->MajorFunction;
                        IrpSp->Parameters.Read.Length = Length;
                        IrpSp->Parameters.Read.ByteOffset.QuadPart = StartingVbo;

                        //
                        // Set up the completion routine address in our stack frame.
                        //

                        IoSetCompletionRoutine( Irp,
                                                &NtfsMultiSyncCompletionRoutine,
                                                Context,
                                                TRUE,
                                                TRUE,
                                                TRUE );

                        //
                        //  Setup the next IRP stack location in the associated Irp for the disk
                        //  driver beneath us.
                        //

                        IrpSp = IoGetNextIrpStackLocation( Irp );

                        //
                        //  Setup the Stack location to do a normal read or write.
                        //

                        if ((IrpContext->MajorFunction == IRP_MJ_WRITE) || !SecondaryAvailable) {

                            IrpSp->MajorFunction = IrpContext->MajorFunction;
                            IrpSp->Flags = IrpSpFlags;
                            IrpSp->Parameters.Read.ByteOffset.QuadPart = StartingLbo;
                            IrpSp->Parameters.Read.Length = Length;

                        //
                        //  Otherwise we are supposed to read from the primary or secondary
                        //  on an FT drive.
                        //

                        } else {

                            IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

                            if (FtCase != 1) {
                                IrpSp->Parameters.DeviceIoControl.IoControlCode = FT_PRIMARY_READ;
                            } else {
                                IrpSp->Parameters.DeviceIoControl.IoControlCode = FT_SECONDARY_READ;
                            }

                            Irp->AssociatedIrp.SystemBuffer = &SpecialRead;
                            SpecialRead.ByteOffset.QuadPart = StartingLbo;
                            SpecialRead.Length = Length;
                        }

                        //
                        //  We only need to set the associated IRP count in the master irp to
                        //  make it a master IRP.  But we set the count to one more than our
                        //  caller requested, because we do not want the I/O system to complete
                        //  the I/O.  We also set our own count.
                        //

                        Context->IrpCount = 1;
                        MasterIrp->AssociatedIrp.IrpCount = 2;

                        //
                        //  MtfsMultiCompletionRoutine only modifies the status on errors,
                        //  so we have to reset to success before each call.
                        //

                        MasterIrp->IoStatus.Status = STATUS_SUCCESS;

                        //
                        //  If IoCallDriver returns an error, it has completed the Irp
                        //  and the error will be caught by our completion routines
                        //  and dealt with as a normal IO error.
                        //

                        HotFixTrace(("Calling driver with Irp: %08lx\n", Irp));
                        KeClearEvent( &Context->Wait.SyncEvent );

                        (VOID)IoCallDriver( DeviceObject, Irp );

                        //
                        //  Now wait for it.
                        //

                        NtfsWaitSync( IrpContext );

                        HotFixTrace(("Request completion status: %08lx\n", MasterIrp->IoStatus.Status));

                        //
                        //  If we were so lucky to get a verify required, then
                        //  spin our wheels here a while.
                        //

                        if (MasterIrp->IoStatus.Status == STATUS_VERIFY_REQUIRED) {

                            //
                            //  Otherwise we need to verify the volume, and if it doesn't
                            //  verify correctly then we dismount the volume and report
                            //  our error.
                            //

                            if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                                //**** NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                                ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

                                MasterIrp->IoStatus.Status = STATUS_FILE_INVALID;
                                return;
                            }

                            //
                            //  The volume verified correctly so now clear the verify bit
                            //  and try and I/O again
                            //

                            ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

                        //
                        //  We may have assumed that there was a secondary available
                        //  and there is not.  We can only tell from getting this code.
                        //  Indicate there is no secondary and that we will be only
                        //  making one pass.
                        //

                        } else if (MasterIrp->IoStatus.Status == STATUS_INVALID_DEVICE_REQUEST) {

                            ASSERT((IrpContext->MajorFunction != IRP_MJ_WRITE) && SecondaryAvailable);

                            SetFlag(Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE);
                            SecondaryAvailable = FALSE;
                            FinalPass = TRUE;

                        //
                        //  If the secondary is offline then there is nothing to recover.
                        //

                       } else if (MasterIrp->IoStatus.Status == STATUS_FT_MISSING_MEMBER) {

                           //
                           //  FTDISK will return this error if they are in initialization.
                           //  Then we don't want to set VCB_STATE_NO_SECONDARY_AVAILABLE but
                           //  will need to check whether we really want to hotfix.
                           //

                           SecondaryAvailable = FALSE;
                           FinalPass = TRUE;

                        //
                        //  Otherwise we got success or another error and we should proceed.
                        //

                        } else {
                            break;
                        }
                    }

                    //
                    //  Check again if we really want to perform the hot-fix in the event the status
                    //  of the secondary has changed.
                    //

                    if (!SecondaryAvailable &&
                        (IrpContext->MajorFunction == IRP_MJ_READ) &&
                        (FlagOn( MasterIrp->Flags, IRP_PAGING_IO | IRP_NOCACHE ) == IRP_NOCACHE)) {

                        MasterIrp->IoStatus.Status = IrpStatus;
                        return;
                    }

                    if (!FT_SUCCESS(MasterIrp->IoStatus.Status)) {

                        BOOLEAN IsHotFixPage;

                        //
                        //  Calculate whether or not this is the hot fix thread itself
                        //  (i.e., executing NtfsPerformHotFix).
                        //

                        IsHotFixPage = NtfsIsTopLevelHotFixScb( Scb );

                        LlTemp1 = StartingVbo >> PAGE_SHIFT;                  //**** crock for x86 compiler bug
                        LlTemp2 = NtfsGetTopLevelHotFixVcn() >> PAGE_SHIFT;   //**** crock for x86 compiler bug

                        if (!IsHotFixPage ||
                            LlTemp1 != LlTemp2) {




                            IsHotFixPage = FALSE;
                        }

                        //
                        //  If the entire device manages to fail in the middle of this,
                        //  get out.
                        //

                        if (FsRtlIsTotalDeviceFailure(MasterIrp->IoStatus.Status)) {

                            MasterIrp->IoStatus.Status = IrpStatus;
                            return;
                        }

                        //
                        //  If this is not a write, fill the cluster with -1 for the
                        //  event that we ultimately never find good data.  This is
                        //  for security reasons (cannot show anyone the data that
                        //  happens to be in the buffer now), signature reasons (let
                        //  -1 designate read errors, as opposed to 0's which occur
                        //  on ValidDataLength cases), and finally if we fail to read
                        //  a bitmap, we must consider all clusters allocated if we
                        //  wish to continue to use the volume before chkdsk sees it.
                        //

                        if (IrpContext->MajorFunction == IRP_MJ_READ) {

                            NtfsFillIrpBuffer( IrpContext, MasterIrp, Length, IoRuns[RunNumber].BufferOffset + ByteOffset, 0xFF );

                            //
                            //  If this is file system metadata, then we better mark the
                            //  volume corrupt.
                            //

                            if (FinalPass &&
                                FlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE) &&
                                (!LowFileRecord || (((ULONG)StartingVbo >= PAGE_SIZE) &&
                                                    ((ULONG)StartingVbo >= (ULONG)((VOLUME_DASD_NUMBER + 1) << Vcb->MftShift))))) {

                                NtfsPostVcbIsCorrupt( IrpContext, 0, NULL, NULL );
                            }

                            //
                            //  If this is a Usa-protected file, or the bitmap,
                            //  then we will try to procede with our 0xFF pattern
                            //  above rather than returning an error to our caller.
                            //  The Usa guy will get a Usa error, and the bitmap
                            //  will safely say that everything is allocated until
                            //  chkdsk can fix it up.
                            //

                            if (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) ||
                                (Scb == Vcb->BitmapScb)) {

                                MasterIrp->IoStatus.Status = STATUS_SUCCESS;
                            }
                        }

                        //
                        //  If we are not the page being hot fixed, we want to post the
                        //  hot fix and possibly remember the final status.
                        //

                        if (!IsHotFixPage) {

                            //
                            //  If we got a media error, post the hot fix now.  We expect
                            //  to post at most one hot fix in this routine.  When we post
                            //  it it will serialize on the current stream.  Do not attempt
                            //  hot fixes during restart, or if we do not have the bad
                            //  cluster file yet.
                            //

                            if (!FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                                (Vcb->BadClusterFileScb != NULL) &&
                                (!LowFileRecord ||
                                 ((ULONG)StartingVbo >= Vcb->Mft2Scb->Header.FileSize.LowPart))) {

                                NtfsPostHotFix( MasterIrp,
                                                &StartingVbo,
                                                StartingLbo,
                                                BytesPerCluster,
                                                FALSE );
                            }

                            //
                            //  Now see if we ended up with an error on this cluster, and handle
                            //  it accordingly.
                            //
                            //  If we are the one actually trying to fix this error,
                            //  then we need to get success so that we can make the page
                            //  valid with whatever good data we have and flush data
                            //  to its new location.
                            //
                            //  Currently we will not try to figure out if the error
                            //  is actually on the Scb (not to mention the sector) that
                            //  we are hot fixing, assuming that the best thing is to
                            //  just try to charge on.
                            //


                            if (FinalPass) {

                                //
                                //  Make sure he gets the error (if we still have an
                                //  error (see above).
                                //

                                if (!FT_SUCCESS(MasterIrp->IoStatus.Status)) {
                                    FinalStatus = MasterIrp->IoStatus.Status;
                                }
                            }
                        }
                    }

                    //
                    //  If this is a Usa-protected stream, we now perform end of
                    //  Usa processing.  (Otherwise do end of cluster processing
                    //  below.)
                    //

                    if (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT)) {

                        ULONG NextOffset = IoRuns[RunNumber].BufferOffset + ByteOffset + Length;

                        //
                        //  If we are not at the end of a Usa block, there is no work
                        //  to do now.
                        //

                        if ((NextOffset & (UsaBlockSize - 1)) == 0) {

                            HotFixTrace(("May be verifying UsaBlock\n"));

                            //
                            //  If the Usa block is ok, we may be able to knock the
                            //  corresponding sectors out of the ClustersToRecover mask.
                            //

                            if ((IrpContext->MajorFunction != IRP_MJ_READ) ||
                                 NtfsVerifyAndRevertUsaBlock( IrpContext,
                                                              Scb,
                                                              MasterIrp,
                                                              NULL,
                                                              NextOffset - UsaBlockSize,
                                                              UsaBlockSize,
                                                              StartingVbo - (UsaBlockSize - Length) )) {

                                //
                                //  If we are only fixing a Usa error anyway, or this is
                                //  the final pass or at least not the first pass, then
                                //  we can remove these clusters from the recover mask.
                                //

                                if (FixingUsaError || FinalPass || (FtCase != 0)) {

                                    ULONG ShiftCount = UsaBlockSize >> Vcb->ClusterShift;

                                    ClustersToRecover -= (ClusterMask * 2) -
                                                         (ClusterMask >> (ShiftCount - 1));
                                }

                            //
                            //  Note, that even if we get a Usa error, we want to
                            //  update the byte count on the final pass, because
                            //  our reader expects that.
                            //

                            } else if (FinalPass) {

                                HotFixTrace(("Verify may have failed\n"));
                            }
                        }

                    //
                    //  Perform end of cluster processing if not a Usa-protected stream.
                    //

                    } else {

                        //
                        //  If the read succeeded and this is the final pass or at least
                        //  not the first pass, we can take this cluster out of the cluster
                        //  to recover mask.
                        //

                        if (FT_SUCCESS(MasterIrp->IoStatus.Status) && (FinalPass || (FtCase != 0))) {

                            ClustersToRecover -= ClusterMask;
                        }
                    }
                }
            }
        }

        //
        //  Assume we terminated the inner loops because we hit a 32 cluster boundary,
        //  and advance our alignment points.
        //

        AlignedRunNumber = RunNumber;

        //
        //  We should have updated ByteOffset above (Prefast initialization).
        //

        ASSERT( ByteOffset != MAXULONG );

        AlignedByteOffset = ByteOffset;

    } while (RunNumber < MultipleIrpCount);

    //
    //  Now put the final status in the MasterIrp and return
    //

    MasterIrp->IoStatus.Status = FinalStatus;
    if (!NT_SUCCESS(FinalStatus)) {
        MasterIrp->IoStatus.Information = 0;
    }

    HotFixTrace(("NtfsFixDataError returning IoStatus = %08lx, %08lx\n",
                 MasterIrp->IoStatus.Status,
                 MasterIrp->IoStatus.Information));

    return;
}


VOID
NtfsPostHotFix (
    IN PIRP Irp,
    IN PLONGLONG BadVbo,
    IN LONGLONG BadLbo,
    IN ULONG ByteLength,
    IN BOOLEAN DelayIrpCompletion
    )

/*

Routine Description:

    This routine posts a hot fix request to a worker thread.  It has to be posted,
    because we cannot expect to be able to acquire the resources we need exclusive
    when the bad cluster is discovered.

Arguments:

    Irp - The Irp for a read or write request which got the error

    BadVbo - The Vbo of the bad cluster for the read or write request

    BadLbo - The Lbo of the bad cluster

    ByteLength - Length to hot fix

    DelayIrpCompletion - TRUE if the Irp should not be completed until the hot
                         fix is done.

Return Value:

    None

--*/

{
    PIRP_CONTEXT HotFixIrpContext = NULL;
    PVOLUME_DEVICE_OBJECT VolumeDeviceObject;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    HotFixTrace(("NTFS: Posting hotfix on file object: %08lx\n", FileObject));

    //
    //  Allocate an IrpContext to post the hot fix to a worker thread.
    //

    NtfsInitializeIrpContext( Irp, FALSE, &HotFixIrpContext );

    //
    //  First reference the file object so that it will not go away
    //  until the hot fix is done.  (We cannot increment the CloseCount
    //  in the Scb, since we are not properly synchronized.)
    //

    ObReferenceObject( FileObject );

    HotFixIrpContext->OriginatingIrp = (PIRP)FileObject;
    HotFixIrpContext->ScbSnapshot.AllocationSize = *BadVbo;
    HotFixIrpContext->ScbSnapshot.FileSize = BadLbo;
    ((ULONG)HotFixIrpContext->ScbSnapshot.ValidDataLength) = ByteLength;
    if (DelayIrpCompletion) {

#ifdef _WIN64

        //
        // (fcf) The IrpToComplete pointer is stashed into the high half of a
        // LONGLONG.  This is problematic on WIN64, so we have to store it
        // somewhere else on 64-bit platforms.  IrpContext->SharedScb is unused
        // in this codepath (asserted below), so we'll use that.
        //
        // Its possible that this change could be made for 32-bit platforms as
        // well, if only to avoid this conditional compilation, but I would
        // prefer the original authors to sanity-check this first.
        //
        // See also NtfsPerformHotFix() where this pointer is extracted.
        //

        ASSERT(HotFixIrpContext->SharedScbSize == 0);
        ASSERT(HotFixIrpContext->SharedScb == NULL);

        (PIRP)HotFixIrpContext->SharedScb = Irp;

#else // !_WIN64

        ((PLARGE_INTEGER)&HotFixIrpContext->ScbSnapshot.ValidDataLength)->HighPart = (ULONG)Irp;

#endif // _WIN64

    } else {
        ((PLARGE_INTEGER)&HotFixIrpContext->ScbSnapshot.ValidDataLength)->HighPart = 0;
    }

    //
    //  Locate the volume device object and Vcb that we are trying to access
    //

    VolumeDeviceObject = (PVOLUME_DEVICE_OBJECT)IrpSp->DeviceObject;
    HotFixIrpContext->Vcb = &VolumeDeviceObject->Vcb;

    //
    //  Send it off.....
    //

    RtlZeroMemory( &HotFixIrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ) );
    ExInitializeWorkItem( &HotFixIrpContext->WorkQueueItem,
                          (PWORKER_THREAD_ROUTINE)NtfsPerformHotFix,
                          (PVOID)HotFixIrpContext );

    ExQueueWorkItem( &HotFixIrpContext->WorkQueueItem, CriticalWorkQueue );
}


VOID
NtfsPerformHotFix (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine implements implements a hot fix that was scheduled
    above, extracting its parameters from the IrpContext initialized
    above.  The hot fix must be for a contiguous range of Lcns (usually 1).

Arguments:

    IrpContext - Supplies the IrpContext with the hot fix information

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PSCB BadClusterScb;
    VCN BadVcn;
    LCN LcnTemp, BadLcn;
    LONGLONG ClusterCount;
    NTSTATUS Status;
    PVOID Buffer;
    PIRP IrpToComplete;
    ULONG ClustersToFix;
    PBCB Bcb = NULL;
    ERESOURCE_THREAD BcbOwner = 0;
    BOOLEAN PerformFullCleanup = TRUE;
    NTSTATUS CompletionStatus = STATUS_SUCCESS;
    PSCB OriginalScb = NULL;
    PSCB NewScb = NULL;
    BOOLEAN PagingFile;

    //
    //  Extract a description of the cluster to be fixed.
    //

    PFILE_OBJECT FileObject = (PFILE_OBJECT)IrpContext->OriginatingIrp;
    VBO BadVbo = *(PVBO)&IrpContext->ScbSnapshot.AllocationSize;

    PAGED_CODE();

    //
    //  Reset the shared fields
    //

    InitializeListHead( &IrpContext->RecentlyDeallocatedQueue );
    InitializeListHead( &IrpContext->ExclusiveFcbList );

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );
    ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL ));

    NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

    //
    //  Initialize our local variables
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );
    BadClusterScb = Vcb->BadClusterFileScb;
    BadVcn = LlClustersFromBytesTruncate( Vcb, BadVbo );
    BadLcn = LlClustersFromBytesTruncate( Vcb, IrpContext->ScbSnapshot.FileSize );
    ClustersToFix = ClustersFromBytes( Vcb, ((ULONG)IrpContext->ScbSnapshot.ValidDataLength) );

#ifdef _WIN64

    //
    // See comments in NtfsPostHotFix() regarding the location of IrpToComplete.
    //

    ASSERT(IrpContext->SharedScbSize == 0);
    IrpToComplete = (PIRP)IrpContext->SharedScb;

    //
    // Reset SharedScb back to NULL just to be safe.
    //

    IrpContext->SharedScb = NULL;

#else // !_WIN64

    IrpToComplete = (PIRP)(((PLARGE_INTEGER)&IrpContext->ScbSnapshot.ValidDataLength)->HighPart);

#endif

    //
    //  Remember the status to complete the original Irp with.
    //

    if (IrpToComplete != NULL) {

        CompletionStatus = IrpToComplete->IoStatus.Status;
    }

    NtfsInitializeAttributeContext( &Context );

    //
    //  Set up for synchronous operation
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Show that we are performing a HotFix.  Note we are not processing
    //  an Irp now.
    //

    IrpContext->OriginatingIrp = NULL;

    TopLevelContext.VboBeingHotFixed = BadVbo;
    TopLevelContext.ScbBeingHotFixed = Scb;

    //
    //  Acquire the Vcb before acquiring the paging Io resource.
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
    ASSERT( 1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource ) );

    //
    //  While we're holding the Vcb, let's make sure the volume is still mounted.
    //  If it isn't mounted, we need to clean up and get out.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsReleaseVcb( IrpContext, Vcb );

        NtfsCompleteRequest( IrpContext, IrpToComplete, CompletionStatus );
        return;
    }

    //
    //  Acquire the paging io resource for this Fcb if it exists.
    //

    if (Scb->Header.PagingIoResource != NULL) {

        NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
    }

    //
    //  Just because we are hot fixing one file, it is possible that someone
    //  will log to another file and try to lookup Lcns.  So we will acquire
    //  all files.  Example:  Hot fix is in Mft, and SetFileInfo has only the
    //  file acquired, and will log something to the Mft, and cause Lcns to be
    //  looked up.
    //

    NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );

    //
    //  For the bitmap - acquire again to explicitly get it on the exclsuive list
    //  and release the initial acquire
    //

    if (Scb == Vcb->BitmapScb) {

        ASSERT( NtfsIsExclusiveScb( Scb ) && (NtfsIsSharedScb( Scb ) == 1));

        NtfsAcquireExclusiveFcb( IrpContext, Scb->Fcb, Scb, ACQUIRE_HOLD_BITMAP );
        NtfsReleaseResource( IrpContext, Fcb );

        ASSERT( NtfsIsExclusiveScb( Scb ) && (NtfsIsSharedScb( Scb ) == 1) &&
                (Scb->Fcb->ExclusiveFcbLinks.Flink != NULL));
    }

    //
    //  Don't attempt to hotfix if the scb is deleted
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        //
        //  Catch all exceptions.  Note, we should not get any I/O error exceptions
        //  on our device.
        //

        try {

            PagingFile = FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

            //
            //  Hotfixing the paging file is tricky because paging file i/o acquires no resources
            //  So we create a shadow scb to do the work in
            //

            if (PagingFile) {

                UNICODE_STRING Mirror;
                BOOLEAN Existing;
                VCN Vcn;
                LCN Lcn;

#ifdef BENL_DBG
                KdPrint(( "NTFS: hotfixing pagefile\n "));
#endif

                Mirror.Length = Mirror.MaximumLength = 12;
                Mirror.Buffer = L"Mirror";

                NewScb = NtfsCreateScb( IrpContext, Scb->Fcb, $DATA, &Mirror, FALSE, &Existing );
                ASSERT( Existing == FALSE );
                ASSERT( FlagOn( NewScb->ScbState, SCB_STATE_NONPAGED ));

                //
                //  Null out the name so we think it points to real unnamed $data
                //

                NewScb->AttributeName.Length = 0;

                //
                //  Now update the mirror from the attribute to get the header info and
                //  snapshot it
                //

                NtfsUpdateScbFromAttribute( IrpContext, NewScb, NULL );
                NtfsSnapshotScb( IrpContext, NewScb );

                //
                //  Load the real scb's mcb cluster info into the mirror
                //

                for (Vcn = 0; Vcn < LlClustersFromBytes( Vcb, Scb->Header.AllocationSize.QuadPart ); Vcn += ClusterCount ) {

                    if (NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, &Lcn, &ClusterCount, NULL, NULL, NULL, NULL )) {

                        NtfsAddNtfsMcbEntry( &NewScb->Mcb, Vcn, Lcn, ClusterCount, FALSE );
                    } else {

                        ASSERTMSG( "Missing range in paging file.\n", FALSE );
                        break;
                    }
                }

                OriginalScb = Scb;
                Scb = NewScb;
            }

            for (; ClustersToFix != 0; ClustersToFix -= 1) {

                //
                //  Lookup the bad cluster to see if it is already in the bad cluster
                //  file, and do nothing if it is.
                //

                if (!NtfsLookupAllocation( IrpContext,
                                           BadClusterScb,
                                           BadLcn,
                                           &LcnTemp,
                                           &ClusterCount,
                                           NULL,
                                           NULL ) &&

                    NtfsLookupAllocation( IrpContext,
                                          Scb,
                                          BadVcn,
                                          &LcnTemp,
                                          &ClusterCount,
                                          NULL,
                                          NULL ) &&

                    (LcnTemp == BadLcn)) {

                    //
                    //  Pin the bad cluster in memory, so that we will not lose whatever data
                    //  we have for it.  (This data will be the correct data if we are talking
                    //  to the FT driver or got a write error, otherwise it may be all -1's.)
                    //
                    //  Do not try to do this if we are holding on to the original Irp, as that
                    //  will cause a collided page wait deadlock.
                    //

                    if (IrpToComplete == NULL) {

                        ULONG Count = 100;

                        NtfsCreateInternalAttributeStream( IrpContext,
                                                           Scb,
                                                           FALSE,
                                                           &NtfsInternalUseFile[PERFORMHOTFIX_FILE_NUMBER] );

                        //
                        //  We loop as long as we get an data error.  We want our
                        //  thread to read from the disk because we will recognize
                        //  an I/O request started in PerformHotFix and ignore the
                        //  data error.  The cases where we do get an error will
                        //  probably be from Mm intercepting this request because
                        //  of a collided read with another thread.
                        //


                        do {

                            Status = STATUS_SUCCESS;

                            try {

                                NtfsPinStream( IrpContext, Scb, BadVbo, Vcb->BytesPerCluster, &Bcb, &Buffer );

                            } except ((!FsRtlIsNtstatusExpected( Status = GetExceptionCode())
                                       || FsRtlIsTotalDeviceFailure( Status ))
                                      ? EXCEPTION_CONTINUE_SEARCH
                                      : EXCEPTION_EXECUTE_HANDLER) {

                                NOTHING;
                            }

                        } while (Count-- && (Status != STATUS_SUCCESS));

                        if (Status != STATUS_SUCCESS) {

                            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                        }
                    }

                    //
                    //  If we're hotfixing the logfile set the owner bcb owner to thread & 0x1 so
                    //  we don't run into trouble if the logged changes to it use the same page
                    //  Lfs will also set the bcb owner and our release will fail because the threadowner
                    //  has been changed
                    //

                    if (Scb == Vcb->LogFileScb) {

                        BcbOwner = (ERESOURCE_THREAD) (((ULONG_PTR) PsGetCurrentThread()) | 1);

                        CcSetBcbOwnerPointer( Bcb, (PVOID)BcbOwner );
                    }

                    //
                    //  Now deallocate the bad cluster in this stream in the bitmap only,
                    //  since in general we do not support sparse deallocation in the file
                    //  record.  We will update the allocation below.
                    //

    #if DBG
                    KdPrint(("NTFS:     Freeing Bad Vcn: %08lx, %08lx\n", ((ULONG)BadVcn), ((PLARGE_INTEGER)&BadVcn)->HighPart));
    #endif

                    //
                    //   Deallocate clusters directly - so the change is only in memory
                    //   Because we're not using the normal NtfsDeleteAllocation its necc. to
                    //   manually create the snapshots that will correctly unload the modified range in
                    //   case of a raise
                    //

                    NtfsSnapshotScb( IrpContext, Scb );

                    if (BadVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

                        Scb->ScbSnapshot->LowestModifiedVcn = BadVcn;
                    }

                    if (BadVcn > Scb->ScbSnapshot->HighestModifiedVcn) {

                        Scb->ScbSnapshot->HighestModifiedVcn = BadVcn;
                    }

                    NtfsDeallocateClusters( IrpContext,
                                            Vcb,
                                            Scb,
                                            BadVcn,
                                            BadVcn,
                                            &Scb->TotalAllocated );
                    //
                    //  Look up the bad cluster attribute.
                    //

                    NtfsLookupAttributeForScb( IrpContext, BadClusterScb, NULL, &Context );

                    //
                    //  Now append this cluster to the bad cluster file
                    //

    #if DBG
                    KdPrint(("NTFS:     Retiring Bad Lcn: %08lx, %08lx\n", ((ULONG)BadLcn), ((PLARGE_INTEGER)&BadLcn)->HighPart));
    #endif

                    NtfsAddBadCluster( IrpContext, Vcb, BadLcn );

                    //
                    //  Now update the file record for the bad cluster file to
                    //  show the new cluster.
                    //

                    NtfsAddAttributeAllocation( IrpContext,
                                                BadClusterScb,
                                                &Context,
                                                &BadLcn,
                                                (PVCN)&Li1 );

                    //
                    //  Now reallocate a cluster to the original stream to replace the bad cluster.
                    //

                    HotFixTrace(("NTFS:     Reallocating Bad Vcn\n"));
                    NtfsAddAllocation( IrpContext, NULL, Scb, BadVcn, (LONGLONG)1, FALSE, NULL );

                    //
                    //  Unpin the pages now so that the flush won't block if we are hot-fixing the Mft.
                    //

                    NtfsCleanupAttributeContext( IrpContext, &Context );

                    //
                    //  Now that there is a new home for the data, mark the page dirty, unpin
                    //  it and flush it out to its new home.
                    //

                    if (IrpToComplete == NULL) {

                        LONGLONG BiasedBadVbo = BadVbo;

                        CcSetDirtyPinnedData( Bcb, NULL );

                        if (Scb != Vcb->LogFileScb) {
                            NtfsUnpinBcb( IrpContext, &Bcb );
                        } else {
                            NtfsUnpinBcbForThread( IrpContext, &Bcb, BcbOwner );
                        }

                        //
                        //  Flush the stream.  Ignore the status - if we get something like
                        //  a log file full, the Lazy Writer will eventually write the page.
                        //  Bias the write if this is the Usn Journal.
                        //

                        if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

                            BiasedBadVbo -= Scb->Vcb->UsnCacheBias;
                        }

#ifdef _WIN64
                        //
                        //  Currently, we cannot hotfix the $logfile on ia64 as the
                        //  flush below will cause an AV due to NtfsCheckWriteRange not
                        //  not capable of handling a call all the way from this routine
                        //  as the last flush file offset can be very different from
                        //  the bad vcn file offset.  Instead we let someone else
                        //  do the flush.  The $logfile data will be bad and drive may
                        //  get mark dirty but we will recover on the next round
                        //  as the bad cluster would have been replaced.
                        //

                        if (Scb != Vcb->LogFileScb) {
#endif

                            (VOID)NtfsFlushUserStream( IrpContext, Scb, &BiasedBadVbo, 1 );

#ifdef _WIN64
                        }
#endif

                    }

                    //
                    //  Commit the transaction.
                    //

                    NtfsCommitCurrentTransaction( IrpContext );

                    //
                    //  Now that the data is flushed to its new location, we will write the
                    //  hot fix record.  We don't write the log record if we are
                    //  fixing the logfile.  Instead we explicitly flush the Mft record
                    //  for the log file.  The log file is one file where we expect
                    //  to be able to read the mapping pairs on restart.
                    //

                    if (Scb == Vcb->LogFileScb) {

                        if (Vcb->MftScb->FileObject != NULL) {

                            CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                                          &Li0,
                                          Vcb->BytesPerFileRecordSegment * ATTRIBUTE_DEF_TABLE_NUMBER,
                                          NULL );
                        }

                    } else {

                        (VOID) NtfsWriteLog( IrpContext,
                                             Scb,
                                             NULL,
                                             HotFix,
                                             NULL,
                                             0,
                                             Noop,
                                             NULL,
                                             0,
                                             LlBytesFromClusters( Vcb, BadVcn ),
                                             0,
                                             0,
                                             Vcb->BytesPerCluster );

                        //
                        //  And we have to commit that one, too.
                        //

                        NtfsCommitCurrentTransaction( IrpContext );
                    }

                    //
                    //  Now flush the log to insure that the hot fix gets remembered,
                    //  especially important if this is the paging file.
                    //

                    LfsFlushToLsn( Vcb->LogHandle, LiMax );

                    HotFixTrace(("NTFS:     Bad Cluster replaced\n"));
                }

                //
                //  Get ready for another possible pass through the loop
                //

                BadVcn = BadVcn + 1;
                BadLcn = BadLcn + 1;

                ASSERT( NULL == Bcb );
            }

            //
            //  Move the in memory allocation from the mirror of the paging file
            //  back to the real scb in an atomic matter
            //

            if (NewScb != NULL) {

                NtfsSwapMcbs( &NewScb->Mcb, &OriginalScb->Mcb );
                NtfsDeleteScb( IrpContext, &NewScb );
                Scb = OriginalScb;
            }

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode = GetExceptionCode();

            //
            //  We are not prepared to have our IrpContext requeued, so just
            //  consider these cases to be bad luck.  We will put a status of
            //  data error in the irp context and pass that code to the process
            //  exception routine.
            //

            if ((ExceptionCode == STATUS_LOG_FILE_FULL) ||
                (ExceptionCode == STATUS_CANT_WAIT)) {

                ExceptionCode = IrpContext->ExceptionStatus = STATUS_DATA_ERROR;
            }

            //
            //  We won't be calling ReleaseAllFiles.  Decrement the Acquire count
            //  before releasing the Fcbs.
            //

            ASSERT( Vcb->AcquireFilesCount != 0 );
            Vcb->AcquireFilesCount -= 1;

            //
            //  Cleanup the temporary mirror scb (if there is one) while we have an
            //  irpcontext
            //

            if (NewScb != NULL) {
                NtfsDeleteScb( IrpContext, &NewScb );
                Scb = OriginalScb;
            }

            NtfsProcessException( IrpContext, NULL, ExceptionCode );

            //
            //  The IrpContext is really gone now.
            //

            IrpContext = NULL;
            PerformFullCleanup = FALSE;

            ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
        }
    }

    //
    //  Let any errors be handled in the except clause above, however we
    //  cleanup on the way out, because for example we need the IrpContext
    //  still in the except clause.
    //

    try {

        NtfsCleanupAttributeContext( IrpContext, &Context );

        if (Scb != Vcb->LogFileScb) {
            NtfsUnpinBcb( IrpContext, &Bcb );
        } else {
            NtfsUnpinBcbForThread( IrpContext, &Bcb, BcbOwner );
        }

        //
        //  If we aborted this operation then all of the file resources have
        //  already been released.
        //

        if (PerformFullCleanup) {

            NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );

            NtfsReleaseVcb( IrpContext, Vcb );

        //
        //  The files have been released but not the Vcb or the volume bitmap.
        //

        } else {

            if ((Vcb->BitmapScb != NULL) &&  NtfsIsExclusiveScb( Vcb->BitmapScb )) {

                NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
            }

            //
            //  We need to release the Vcb twice since we specifically acquire
            //  it once and then again with all the files.
            //

            NtfsReleaseVcb( IrpContext, Vcb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        ObDereferenceObject( FileObject );

        //
        //  The IrpContext and Irp will already be NULL if they have been completed already.
        //

        NtfsCompleteRequest( IrpContext, IrpToComplete, CompletionStatus );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
}


BOOLEAN
NtfsGetReservedBuffer (
    IN PFCB ThisFcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    IN UCHAR Need2
    )

/*++

Routine Description:

    This routine allocates the reserved buffers depending on the needs of
    the caller.  If the caller might require two buffers then we will allocate
    buffers 1 or 2.  Otherwise we can allocate any of the three.

Arguments:

    ThisFcb - This is the Fcb where the io is occurring.

    Buffer - Address to store the address of the allocated buffer.

    Length - Address to store the length of the returned buffer.

    Need2 - Zero if only one buffer needed.  Either 1 or 2 if two buffers
        might be needed.  Buffer 2 can be acquired recursively.  If buffer
        1 is needed and the current thread already owns buffer 1 then
        grant buffer three instead.

Return Value:

    BOOLEAN - Indicates whether the buffer was acquired.

--*/

{
    BOOLEAN Allocated = FALSE;
    PVOID CurrentThread;

    //
    //  Capture the current thread and the Fcb for the file we are acquiring
    //  the buffer for.
    //

    CurrentThread = (PVOID) PsGetCurrentThread();

    ExAcquireFastMutexUnsafe( &NtfsReservedBufferMutex );

    //
    //  If we need two buffers then allocate either buffer 1 or buffer 2.
    //  We allow this caller to get a buffer if
    //
    //      - He already owns one of these buffers   (or)
    //
    //      - Neither of the 2 buffers are allocated (and)
    //      - No other thread has a buffer on behalf of this file
    //

    if (Need2) {

        if ((NtfsReservedBufferThread == CurrentThread) ||

            (!FlagOn( NtfsReservedInUse, 3 ) &&
             ((NtfsReserved3Fcb != ThisFcb) ||
              (NtfsReserved3Thread == CurrentThread)))) {

            NtfsReservedBufferThread = CurrentThread;
            NtfsReserved12Fcb = ThisFcb;

            //
            //  Check whether the caller wants buffer 1 or buffer 2.
            //

            if (Need2 == RESERVED_BUFFER_TWO_NEEDED) {

                //
                //  If we don't own buffer 1 then reserve it now.
                //

                if (!FlagOn( NtfsReservedInUse, 1 )) {

                    NtfsReserved1Thread = CurrentThread;
                    SetFlag( NtfsReservedInUse, 1 );
                    *Buffer = NtfsReserved1;
                    *Length = LARGE_BUFFER_SIZE;
                    Allocated = TRUE;

                } else if (!FlagOn( NtfsReservedInUse, 4 )) {

                    NtfsReserved3Fcb = ThisFcb;

                    NtfsReserved3Thread = CurrentThread;
                    SetFlag( NtfsReservedInUse, 4 );
                    *Buffer = NtfsReserved3;
                    *Length = LARGE_BUFFER_SIZE;
                    Allocated = TRUE;
                }

            } else {

                ASSERT( Need2 == RESERVED_BUFFER_WORKSPACE_NEEDED );

                NtfsReserved2Thread = CurrentThread;
                SetFlag( NtfsReservedInUse, 2 );
                *Buffer = NtfsReserved2;
                *Length = WORKSPACE_BUFFER_SIZE;
                NtfsReserved2Count += 1;
                Allocated = TRUE;
            }
        }

    //
    //  We only need 1 buffer.  If this thread is the exclusive owner then
    //  we know it is safe to use buffer 2.  The data in this buffer doesn't
    //  need to be preserved across a recursive call.
    //

    } else if (NtfsReservedBufferThread == CurrentThread) {

        NtfsReserved2Thread = CurrentThread;
        SetFlag( NtfsReservedInUse, 2 );
        *Buffer = NtfsReserved2;
        *Length = LARGE_BUFFER_SIZE;
        NtfsReserved2Count += 1;
        Allocated = TRUE;

    //
    //  We only need 1 buffer.  Try for buffer 3 first.
    //

    } else if (!FlagOn( NtfsReservedInUse, 4)) {

        //
        //  Check if the owner of the first two buffers is operating in the
        //  same file but is a different thread.  We can't grant another buffer
        //  for a different stream in the same file.
        //

        if (ThisFcb != NtfsReserved12Fcb) {

            NtfsReserved3Fcb = ThisFcb;

            NtfsReserved3Thread = CurrentThread;
            SetFlag( NtfsReservedInUse, 4 );
            *Buffer = NtfsReserved3;
            *Length = LARGE_BUFFER_SIZE;
            Allocated = TRUE;
        }

    //
    //  If there is no exclusive owner then we can use either of the first
    //  two buffers.  Note that getting one of the first two buffers will
    //  lock out the guy who needs two buffers.
    //

    } else if (NtfsReservedBufferThread == NULL) {

        if (!FlagOn( NtfsReservedInUse, 2 )) {

            NtfsReserved2Thread = CurrentThread;
            SetFlag( NtfsReservedInUse, 2 );
            *Buffer = NtfsReserved2;
            *Length = LARGE_BUFFER_SIZE;
            NtfsReserved2Count += 1;
            Allocated = TRUE;

        } else if (!FlagOn( NtfsReservedInUse, 1 )) {

            NtfsReserved1Thread = CurrentThread;
            SetFlag( NtfsReservedInUse, 1 );
            *Buffer = NtfsReserved1;
            *Length = LARGE_BUFFER_SIZE;
            Allocated = TRUE;
        }
    }

    ExReleaseFastMutexUnsafe(&NtfsReservedBufferMutex);
    return Allocated;
}

BOOLEAN
NtfsFreeReservedBuffer (
    IN PVOID Buffer
    )
{
    BOOLEAN Deallocated = FALSE;

    ExAcquireFastMutexUnsafe(&NtfsReservedBufferMutex);

    if (Buffer == NtfsReserved1) {
        ASSERT( FlagOn( NtfsReservedInUse, 1 ));

        ClearFlag( NtfsReservedInUse, 1 );
        NtfsReserved1Thread = NULL;
        if (!FlagOn( NtfsReservedInUse, 2)) {
            NtfsReservedBufferThread = NULL;
            NtfsReserved12Fcb = NULL;
        }

        Deallocated = TRUE;

    } else if (Buffer == NtfsReserved2) {
        ASSERT( FlagOn( NtfsReservedInUse, 2 ));

        NtfsReserved2Count -= 1;

        if (NtfsReserved2Count == 0) {

            ClearFlag( NtfsReservedInUse, 2 );
            NtfsReserved2Thread = NULL;
            if (!FlagOn( NtfsReservedInUse, 1)) {
                NtfsReservedBufferThread = NULL;
                NtfsReserved12Fcb = NULL;
            }
        }

        Deallocated = TRUE;

    } else if (Buffer == NtfsReserved3) {
        ASSERT( FlagOn( NtfsReservedInUse, 4 ));
        ClearFlag( NtfsReservedInUse, 4 );
        Deallocated = TRUE;
        NtfsReserved3Thread = NULL;
        NtfsReserved3Fcb = NULL;
    }

    ExReleaseFastMutexUnsafe(&NtfsReservedBufferMutex);
    return Deallocated;
}


NTSTATUS
NtfsDefragFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    Direct defrag.  This routines modifies the input buffer to track progress. So the
    FSCTL must always be buffered.


Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    ULONG FsControlCode;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

#if defined( _WIN64 )
    MOVE_FILE_DATA MoveDataLocal;
#endif

    PMOVE_FILE_DATA MoveData;

    LONGLONG FileOffset;
    PMDL Mdl = NULL;
    BOOLEAN AcquiredScb = FALSE;
    BOOLEAN AcquiredAllFiles = FALSE;
    BOOLEAN AcquiredVcb = FALSE;
    ULONG DeletePendingFailureCountsLeft;

    extern POBJECT_TYPE *IoFileObjectType;

    PVOID Buffer = NULL;
    ULONG BufferLength;
    NTFS_IO_CONTEXT NtfsIoContext;
    BOOLEAN AcquiredBitmap = FALSE;
    BOOLEAN AcquiredMft = FALSE;
    BOOLEAN FreeRecentlyDeallocated = FALSE;
    BOOLEAN IoctlSupported = TRUE;

    PAGED_CODE( );

    //
    //  Always make this synchronous for MoveFile
    //  We should never be in the FSP for this.  Otherwise the user handle
    //  is invalid.  Also disable quota accounting since defrag doesn't affect it
    //  Otherwise we might trigger it while moving attributes around due to mapping pair
    //  changes and deadlock
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT | IRP_CONTEXT_STATE_QUOTA_DISABLE );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    NextIrpSp = IoGetNextIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsMoveFile, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object and check for type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

#if defined(_WIN64)

    //
    //  Win32/64 thunking code
    //

    if (IoIs32bitProcess( Irp )) {

        PMOVE_FILE_DATA32 MoveData32;

        if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MOVE_FILE_DATA32 )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        MoveData32 = (PMOVE_FILE_DATA32) Irp->AssociatedIrp.SystemBuffer;
        MoveDataLocal.ClusterCount = MoveData32->ClusterCount;
        MoveDataLocal.FileHandle = (HANDLE)(ULONG_PTR)(LONG) MoveData32->FileHandle;
        MoveDataLocal.StartingLcn.QuadPart = MoveData32->StartingLcn.QuadPart;
        MoveDataLocal.StartingVcn.QuadPart = MoveData32->StartingVcn.QuadPart;
        MoveData = &MoveDataLocal;

    } else {
#endif

    //
    //  Get the input buffer pointer and check its length.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MOVE_FILE_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    MoveData = Irp->AssociatedIrp.SystemBuffer;

#if defined(_WIN64)
    }
#endif

    //
    //  Try to get a pointer to the file object from the handle passed in.
    //  Remember that we need to dereference this as some point but don't
    //  do it right away in case some gets in before we acquire it.
    //
    //
    //  NOTE: if the rdr ever allows this to be done remotely we'll have to
    //  change our verification since Irp->RequestorNode would be kernel but we'd
    //  still need to verify the handle
    //

    Status = ObReferenceObjectByHandle( MoveData->FileHandle,
                                        0,
                                        *IoFileObjectType,
                                        Irp->RequestorMode,
                                        &FileObject,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Check that this file object is opened on the same volume as the
    //  DASD handle used to call this routine.
    //

    if (FileObject->Vpb != Vcb->Vpb) {

        ObDereferenceObject( FileObject );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Now decode this FileObject. We don't care to raise on dismounts here
    //  because we check for that further down anyway. Hence, RaiseOnError=FALSE.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    //
    //  Limit the files we will allow defragging to.  We can't defrag a file which needs
    //  its own mapping to write log records (volume bitmap).  We also eliminate the
    //  log file and usn journal. For the MFT we disallow moving the first 16 non-user files
    //

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen) &&
         (TypeOfOpen != UserViewIndexOpen)) ||
        FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) ||
        ((NtfsSegmentNumber( &Fcb->FileReference ) < ATTRIBUTE_DEF_TABLE_NUMBER)  &&
         ((NtfsSegmentNumber( &Fcb->FileReference ) != MASTER_FILE_TABLE_NUMBER) ||
          (MoveData->StartingVcn.QuadPart < LlClustersFromBytes( Vcb, FIRST_USER_FILE_NUMBER * Vcb->BytesPerFileRecordSegment )))) ||
        FlagOn( Fcb->FcbState, FCB_STATE_USN_JOURNAL ) ||
        NtfsEqualMftRef( &Fcb->FileReference, &BitmapFileReference )) {

        ObDereferenceObject( FileObject );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Disallow defragging on a read-only volume
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Verify that the start Vcn, Lcn and cluster count are valid values.
    //

    if ((MoveData->StartingVcn.QuadPart < 0) ||
        (MoveData->StartingVcn.QuadPart + MoveData->ClusterCount < MoveData->ClusterCount) ||
        (Vcb->MaxClusterCount < MoveData->StartingVcn.QuadPart + MoveData->ClusterCount) ||
        (MoveData->StartingLcn.QuadPart < 0) ||
        (MoveData->StartingLcn.QuadPart >= Vcb->TotalClusters)) {

        ObDereferenceObject( FileObject );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;

    }

    NtfsInitializeAttributeContext( &AttrContext );

    try {

        //
        //  For system files we need the vcb to test for dismounted volumes
        //

        if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {
            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            AcquiredVcb = TRUE;

            if (!FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }
        }

        //
        //  We now want to acquire the Scb to check if we can continue.  It is
        //  important to test whether this Scb has a paging io resource, not
        //  whether the Fcb has one.  Consider the case where a directory has
        //  a named data stream in it -- the Fcb will have a paging io resource,
        //  but the index root Scb will not.  In that case it would be a mistake
        //  to acquire the Fcb's paging io resource, since that will not serialize
        //  this operation with NtfsAcquireFileForCcFlush.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
        NtfsAcquireFcbWithPaging( IrpContext, Scb->Fcb, 0 );
        AcquiredScb = TRUE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Check for the deny defrag being set
        //

        if (FlagOn( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG ) && !FlagOn( Ccb->Flags, CCB_FLAG_DENY_DEFRAG )) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  Initialize the header if necc. If the attribute doesn't exist
        //  just leave - for instance an index allocation buffer
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       Scb->AttributeTypeCode,
                                       &Scb->AttributeName,
                                       0,
                                       FALSE,
                                       &AttrContext )) {

            try_return( Status = STATUS_SUCCESS );
        }

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {
            NtfsUpdateScbFromAttribute( IrpContext, Scb, NtfsFoundAttribute( &AttrContext ) );
        }

        if ((TypeOfOpen == UserDirectoryOpen) || (TypeOfOpen == UserViewIndexOpen)) {

            //
            //  Initialize the Index information in the Scb if not done yet for indices.
            //

            if (Scb->ScbType.Index.BytesPerIndexBuffer == 0) {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                if (!NtfsLookupAttributeByName( IrpContext,
                                                Fcb,
                                                &Fcb->FileReference,
                                                $INDEX_ROOT,
                                                &Scb->AttributeName,
                                                0,
                                                FALSE,
                                                &AttrContext )) {

                    ASSERTMSG("Could not find Index Root for Scb\n", FALSE);
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                NtfsUpdateIndexScbFromAttribute( IrpContext, Scb, NtfsFoundAttribute(&AttrContext), FALSE );
            }

            //
            //  Mark the irpcontext so we don't recursively push the index root while defragging
            //  the index. If we hit this on retry the force push flag will be set and we can safely
            //  pre-push the index
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_FORCE_PUSH )) {
                NtfsPushIndexRoot( IrpContext, Scb );
            }
            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_PUSH );
        }

        //
        //  Cleanup the attribute context now to remove bcbs
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  If the stream is resident then we can return SUCCESS immediately.
        //  If the starting point is beyond file allocation then we can also
        //  return immediately.
        //

        FileOffset = (LONGLONG) LlBytesFromClusters( Vcb, MoveData->StartingVcn.QuadPart );
        ASSERT( FileOffset >= 0 );

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ) ||
            (Scb->Header.AllocationSize.QuadPart < FileOffset)) {

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  Setup the intermediate buffer
        //

        ASSERT( LARGE_BUFFER_SIZE >= Vcb->BytesPerCluster );

        if (LARGE_BUFFER_SIZE > Vcb->BytesPerCluster) {
            BufferLength = LARGE_BUFFER_SIZE;
        } else {
            BufferLength = Vcb->BytesPerCluster;
        }

        IrpContext->Union.NtfsIoContext = &NtfsIoContext;
        RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));
        KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                           NotificationEvent,
                           FALSE );

        DeletePendingFailureCountsLeft = 10;

        NtfsReleaseFcbWithPaging( IrpContext, Scb->Fcb );
        AcquiredScb = FALSE;

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;
        }

        if (IrpContext->TransactionId != 0) {

            ASSERT( !AcquiredAllFiles );

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
        }

        //
        //  Main loop - while there are more clusters requested to move try to move them
        //

        while (MoveData->ClusterCount > 0) {

            LCN Lcn;
            LONGLONG ClusterCount;
            LONGLONG TransferSize;
            LONGLONG TransferClusters;

            try {

                try {

                    //
                    //  If necc. grab all the files to synchronzie with any transactions
                    //  flush the log and try to free recently deallocated clusters
                    //

                    if (FreeRecentlyDeallocated) {

                        FreeRecentlyDeallocated = FALSE;

                        try {

                            NtfsPurgeFileRecordCache( IrpContext );

                            //
                            //  Acquire all files to flush the log file and free recently deallocated.
                            //  Note the flush may raise, normally log file full, which will get rid of
                            //  the recently deallocated in a less efficient manner.
                            //

                            NtfsAcquireAllFiles( IrpContext, IrpContext->Vcb, FALSE, FALSE, FALSE );
                            AcquiredAllFiles = TRUE;

                            //
                            //  Since we've dropped and reacquired all thes file, we must retest
                            //  whether the volume has been dismounted. Use the vcb since acquireallfiles
                            //  grabs it
                            //

                            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                                //
                                //  Raise we don't try to acquire the Scb exclusive in the try-finally
                                //  below.  We only hold this resource shared from the AcquireAllFiles
                                //  above.  It is OK to clear the REALLOCATE_ON_WRITE bit somewhat
                                //  unsynchronized since we will never touch this file again.
                                //

                                NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                            }

                            LfsFlushToLsn( IrpContext->Vcb->LogHandle, LiMax );
                            NtfsFreeRecentlyDeallocated( IrpContext, IrpContext->Vcb, &LiMax, TRUE );


                        } finally {

                            if (AcquiredAllFiles) {

                                NtfsReleaseAllFiles( IrpContext, IrpContext->Vcb, FALSE );
                                AcquiredAllFiles = FALSE;
                            }
                        }
                    }

                    //
                    //  Purge anything left in cache because we hold nothing at this point
                    //

                    NtfsPurgeFileRecordCache( IrpContext );


                    //
                    //  For system files we need the vcb to test for dismounted volumes
                    //

                    if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {
                        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                        AcquiredVcb = TRUE;

                        if (!FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                            try_return( Status = STATUS_VOLUME_DISMOUNTED );
                        }
                    }

                    //
                    //  Reacquire everything for the defrag mft case + the mft flush
                    //  resource so we know lazy writes aren't active while we're doing stuff
                    //

                    if (NtfsSegmentNumber( &Fcb->FileReference ) == MASTER_FILE_TABLE_NUMBER) {

                        NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
                        AcquiredAllFiles = TRUE;

                        ExAcquireResourceExclusiveLite( &Vcb->MftFlushResource, TRUE );

                    } else {

                        NtfsAcquireFcbWithPaging( IrpContext, Scb->Fcb, 0 );
                        AcquiredScb = TRUE;

                        //
                        //  Since we've dropped and reacquired the Scb, we must retest
                        //  whether the volume has been dismounted.
                        //

                        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                            try_return( Status = STATUS_VOLUME_DISMOUNTED );
                        }
                    }

                    //
                    //  If we acquired all the files above now do the work to check for free space in the mft
                    //

                    if (AcquiredAllFiles && (Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits <= 1)) {

                        MFT_SEGMENT_REFERENCE FileNumber;

#ifdef BENL_DBG
                        KdPrint(( "NTFS: too few mft records: 0x%x\n", Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits ));
#endif

                        FileNumber = NtfsAllocateMftRecord( IrpContext, Vcb, FALSE );
                        ASSERT( 0 == FileNumber.SegmentNumberHighPart );

                        NtfsDeallocateMftRecord( IrpContext, Vcb, FileNumber.SegmentNumberLowPart );
                        NtfsCheckpointCurrentTransaction( IrpContext );
#ifdef BENL_DBG
                        KdPrint(( "NTFS: after corection mft records: 0x%x\n", Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits ));
#endif

                        ASSERT( Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits > 1 );
                    }

                    //
                    //  Check if the attribute was deleted in between
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED)) {
                        try_return( Status = STATUS_FILE_DELETED );
                    }

                    //
                    //  Leave if after regaining the file locks we are out of range
                    //

                    if (MoveData->StartingVcn.QuadPart > LlClustersFromBytes( Vcb, Scb->Header.AllocationSize.QuadPart )) {
                        break;
                    }

                    //
                    //  Check if this range of allocation exists - if not we can skip any work
                    //

                    if (NtfsLookupAllocation( IrpContext, Scb, MoveData->StartingVcn.QuadPart, &Lcn, &ClusterCount, NULL, NULL )) {

                        //
                        //  Now loop over the current range moving pieces of it
                        //

                        while ((MoveData->ClusterCount > 0) && (ClusterCount > 0)) {

                            LONGLONG UpperBound;

                            if (ClusterCount > MoveData->ClusterCount) {
                                TransferSize = LlBytesFromClusters( Vcb, MoveData->ClusterCount );
                            } else {
                                TransferSize = LlBytesFromClusters( Vcb, ClusterCount );
                            }
                            if (TransferSize > BufferLength ) {
                                TransferSize = BufferLength;
                            }
                            TransferClusters = LlClustersFromBytesTruncate( Vcb, TransferSize );

                            //
                            //  Reserve the new cluster if it falls within volume range
                            //

                            if (MoveData->StartingLcn.QuadPart + TransferClusters > Vcb->TotalClusters) {
                                NtfsRaiseStatus( IrpContext, STATUS_ALREADY_COMMITTED, NULL, NULL );
                            }

                            NtfsPreAllocateClusters( IrpContext, Vcb, MoveData->StartingLcn.QuadPart, TransferClusters, &AcquiredBitmap, &AcquiredMft );

                            //
                            //  Only actually transfer ranges within VDD or VDL - for those between
                            //  VDD and allocation size just reallocate. Use VDD for data streams
                            //  for all others that don't update VDD use VDL
                            //

                            if (($DATA == Scb->AttributeTypeCode) &&
                                !FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) &&
                                FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK)) {

                                //
                                //  Modified no write streams don't use VDD. The only data
                                //  stream currently like this is $Secure and $UsnJrnl which are not
                                //  defraggable
                                //

                                UpperBound = LlClustersFromBytes( Vcb, Scb->ValidDataToDisk );

                            } else {
                                UpperBound = LlClustersFromBytes( Vcb, Scb->Header.ValidDataLength.QuadPart );
                            }

                            if (MoveData->StartingVcn.QuadPart <= UpperBound) {

                                //
                                //  Call the storage and see if they support
                                //  the copy data ioctl - this allows lower drivers to
                                //  implement a more efficient version of the copy and participate
                                //  particularly in volsnap's case in the defrag
                                //

                                if (IoctlSupported) {

                                    DISK_COPY_DATA_PARAMETERS CopyData;

                                    CopyData.SourceOffset.QuadPart = LlBytesFromClusters( Vcb, Lcn );
                                    CopyData.DestinationOffset.QuadPart = LlBytesFromClusters( Vcb, MoveData->StartingLcn.QuadPart );
                                    CopyData.CopyLength.QuadPart = TransferSize;
                                    CopyData.Reserved = 0;

                                    Status = NtfsDeviceIoControl( IrpContext,
                                                                  Vcb->TargetDeviceObject,
                                                                  IOCTL_DISK_COPY_DATA,
                                                                  &CopyData,
                                                                  sizeof( CopyData ),
                                                                  NULL,
                                                                  0,
                                                                  NULL );
                                }

                                if (!IoctlSupported || !NT_SUCCESS( Status )) {

                                    Status = STATUS_SUCCESS;
                                    IoctlSupported = FALSE;

                                    NtfsCreateMdlAndBuffer( IrpContext,
                                                            Scb,
                                                            RESERVED_BUFFER_ONE_NEEDED,
                                                            &BufferLength,
                                                            &Mdl,
                                                            &Buffer );
                                    Irp->MdlAddress = Mdl;

                                    //
                                    //  First read the cluster
                                    //

                                    NtfsSingleAsync( IrpContext,
                                                     Vcb->TargetDeviceObject,
                                                     LlBytesFromClusters( Vcb, Lcn ),
                                                     (ULONG)TransferSize,
                                                     Irp,
                                                     IRP_MJ_READ,
                                                     0 );

                                    NtfsWaitSync( IrpContext );

                                    NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                        &Irp->IoStatus.Status,
                                                                        TRUE,
                                                                        STATUS_UNEXPECTED_IO_ERROR );

                                    //
                                    //  Clear return info field
                                    //

                                    Irp->IoStatus.Information = 0;

                                    //
                                    //  Then transfer it to the new location
                                    //

                                    NtfsSingleAsync( IrpContext,
                                                     Vcb->TargetDeviceObject,
                                                     LlBytesFromClusters( Vcb, MoveData->StartingLcn.QuadPart ),
                                                     (ULONG)TransferSize,
                                                     Irp,
                                                     IRP_MJ_WRITE,
                                                     0 );

                                    NtfsWaitSync( IrpContext );


                                    NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                        &Irp->IoStatus.Status,
                                                                        TRUE,
                                                                        STATUS_UNEXPECTED_IO_ERROR );

                                        Irp->IoStatus.Information = 0;

                                    //
                                    //  Release the buffer before calling lfs which may also need the reserved buffer
                                    //

                                    NtfsDeleteMdlAndBuffer( Mdl, Buffer );
                                    Irp->MdlAddress = NULL;
                                    Buffer = NULL;
                                }
                            }

                            //
                            //  Finally reallocate the cluster in the scb and checkpoint it
                            //

                            NtfsReallocateRange( IrpContext, Scb, MoveData->StartingVcn.QuadPart, TransferClusters, MoveData->StartingVcn.QuadPart, TransferClusters, &MoveData->StartingLcn.QuadPart );
                            NtfsCheckpointCurrentTransaction( IrpContext );

                            ASSERT( IrpContext->TransactionId == 0 );

                            if (AcquiredBitmap) {
                                NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
                                AcquiredBitmap = FALSE;
                            }

                            if (AcquiredMft) {
                                NtfsReleaseScb( IrpContext, Vcb->MftScb );
                                AcquiredMft = FALSE;
                            }

                            MoveData->StartingLcn.QuadPart += TransferClusters;
                            MoveData->StartingVcn.QuadPart += TransferClusters;
                            MoveData->ClusterCount -= (ULONG)TransferClusters;
                            ClusterCount -= TransferClusters;
                            Lcn += TransferClusters;

                        } // endwhile loop over lcn range

                    } else {

                        //
                        //  This is a hole skip over it
                        //

                        MoveData->StartingVcn.QuadPart += ClusterCount;
                        if (ClusterCount > MoveData->ClusterCount) {
                            MoveData->ClusterCount = 0;
                        } else {
                            MoveData->ClusterCount -= (ULONG)ClusterCount;
                        }
                    }

                } except( NtfsDefragExceptionFilter( IrpContext, GetExceptionInformation(), &DeletePendingFailureCountsLeft )) {

                    //
                    //  Cleanup the delete pending failure and next time through the loop
                    //  try to free the recently deallocated clusters to allow the cluster to be deleted
                    //

                    NtfsMinimumExceptionProcessing( IrpContext );
                    IrpContext->ExceptionStatus = STATUS_SUCCESS;

                    FreeRecentlyDeallocated = TRUE;

                }

            } finally {

                //
                //  Unlock the file and let anyone else access the file before
                //  looping back.
                //

                if (Buffer != NULL) {
                    NtfsDeleteMdlAndBuffer( Mdl, Buffer );
                    Irp->MdlAddress = NULL;
                    Buffer = NULL;
                }

                if (AcquiredBitmap) {
                    NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
                    AcquiredBitmap = FALSE;
                }

                if (AcquiredMft) {
                    NtfsReleaseScb( IrpContext, Vcb->MftScb );
                    AcquiredMft = FALSE;
                }

                if (AcquiredScb) {
                    NtfsReleaseFcbWithPaging( IrpContext, Scb->Fcb );
                    AcquiredScb = FALSE;
                }

                if (AcquiredAllFiles) {
                    ExReleaseResourceLite( &Vcb->MftFlushResource );
                    NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
                    AcquiredAllFiles = FALSE;
                }

                if (AcquiredVcb) {
                    NtfsReleaseVcb( IrpContext, Vcb );
                    AcquiredVcb = FALSE;
                }
            }
        } // endwhile

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsDefragFile );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        IrpContext->Union.NtfsIoContext = NULL;

        ASSERT( !AbnormalTermination() || (IrpContext->ExceptionStatus != STATUS_SUCCESS) );

        ASSERT( (Buffer == NULL) &&
                !AcquiredBitmap &&
                !AcquiredMft &&
                !AcquiredAllFiles );

        if (AcquiredScb) {
            NtfsReleaseFcbWithPaging( IrpContext, Scb->Fcb );
        }

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;
        }

        //
        //  Remove our reference on the users file object.
        //

        ObDereferenceObject( FileObject );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


LONG
NtfsDefragExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN OUT PULONG DeletePendingFailureCountsLeft
    )

/*++

Routine Description:

    Exception handler for defrag - pass on for all exceptions other than delete pending
    in that case if there the number of retries left is > 0 execute the handler


Arguments:

    ExceptionPointer - Supplies the exception record to being checked.

    DeletePendingFailureCountsLeft - how many more times to retry a delete pending

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or CONTINUE_SEARCH

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    if ((STATUS_DELETE_PENDING == ExceptionPointer->ExceptionRecord->ExceptionCode)) {

        *DeletePendingFailureCountsLeft -= 1;
        if ((*DeletePendingFailureCountsLeft) > 0) {
            return EXCEPTION_EXECUTE_HANDLER;
        } else {
            return EXCEPTION_CONTINUE_SEARCH;
        }

    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

//
//  Because of protocol limitations in CIFS which uses 16 bits,
//  redirector can't currently accept buffer sizes larger than 64K.
//

#define RDR_BUFFER_SIZE_LIMIT    0x00010000L


NTSTATUS
NtfsReadFromPlex(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This implements directed reads from plexes. Given an offset, a length and a plexnumber
    along with a handle to a file or a volume, this coordinates reads from an underlying
    dynamic (mirrored) volume manager.

    Note that we ignore the VcbState flag VCB_STATE_NO_SECONDARY_AVAILABLE altogether
    and let the lower level driver respond.

Arguments:

    IrpContext - Supplies the IrpContext to process
    Irp - Incoming FSCTL IRP.

Return Value:

    Status SUCCESS on success, otherwise the relevant error code.

--*/

{
    PPLEX_READ_DATA_REQUEST ReadData;
    PIO_STACK_LOCATION IrpSp;
    ULONG InputBufferLength;
    ULONG UserBufferLength;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN Wait = TRUE;
    ULONG NumberOfRuns, RemainingByteCount;
    COMPRESSION_CONTEXT CompContext;
    TYPE_OF_OPEN TypeOfOpen;
    IO_RUN IoRuns[NTFS_MAX_PARALLEL_IOS];
    VBO ByteOffset;
    ULONG ByteCount;
    ULONG BytesToEof;
    ULONG LastReadByteCount;
    ULONG CurByteCount;
    LOGICAL AcquiredScb = FALSE;
    VOLUME_READ_PLEX_INPUT NplexRead;
    PVCB Vcb;
    PSCB Scb;
    PFCB Fcb;
    PCCB Ccb;

    //
    //  Extract and decode the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       FALSE );

    //
    //  FileOpens and VolumeOpens are allowed.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserVolumeOpen)) {

        Status = STATUS_INVALID_PARAMETER;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsReadFromPlex -> %08lx\n", Status) );
        return Status;
    }

    //
    //  This FSCTL is of type METHOD_OUT_DIRECT. The Io Manager has already
    //  copied the input parameters into the systembuffer field, probed the
    //  output buffer and locked the Mdls for us. So we can access these fields
    //  without fear.
    //

    ReadData = (PPLEX_READ_DATA_REQUEST)Irp->AssociatedIrp.SystemBuffer;

    if (ReadData == NULL) {

        Status = STATUS_INVALID_PARAMETER;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsReadFromPlex -> %08lx\n", Status) );
        return Status;
    }

    ByteOffset = ReadData->ByteOffset.QuadPart;
    ByteCount = ReadData->ByteLength;

    //
    //  Now, do the grunt work and clean up within a try finally.
    //

    try {

        //
        //  Sanity check the read length.
        //

    check_values:

        CurByteCount = 0;
        BytesToEof = 0;
        Irp->IoStatus.Information = 0;

        if ((ByteCount > MAXLONGLONG - ByteOffset) ||

            //
            //  File offsets should be cluster aligned
            //

            ((TypeOfOpen == UserFileOpen) &&
             ((ByteOffset & Vcb->ClusterMask) || (ByteCount & Vcb->ClusterMask))) ||

            //
            //  Volume offsets should be sector aligned
            //

            ((TypeOfOpen == UserVolumeOpen) &&
             (((ULONG)ByteOffset & (Vcb->BytesPerSector - 1)) || (ByteCount & (Vcb->BytesPerSector - 1))))) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  No-op
        //

        if (ByteCount == 0) {

            ASSERT(Status == STATUS_SUCCESS);
            ASSERT(CurByteCount == ByteCount);
            leave;
        }

        //
        //  Because of protocol limitations in CIFS which uses 16 bits,
        //  redirector can't accept buffer sizes larger than 64K.
        //

        if (ByteCount & ~(RDR_BUFFER_SIZE_LIMIT - 1L)) {

            Status = STATUS_INVALID_BUFFER_SIZE;
            leave;
        }

        //
        //  Sanity check input/output parameters.
        //

        InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        UserBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        if ((InputBufferLength < sizeof( PLEX_READ_DATA_REQUEST )) ||
            (UserBufferLength < ByteCount)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            leave;
        }

        //
        //  For volume DASD reads, we just send an IOCTL down...
        //

        if (TypeOfOpen == UserVolumeOpen) {

            NplexRead.ByteOffset.QuadPart = ByteOffset;
            NplexRead.Length = ByteCount;
            NplexRead.PlexNumber = ReadData->PlexNumber;

            Status = NtfsDeviceIoControl( IrpContext,
                                          Vcb->TargetDeviceObject,
                                          IOCTL_VOLUME_READ_PLEX,
                                          &NplexRead,
                                          sizeof( VOLUME_READ_PLEX_INPUT ),
                                          NtfsMapUserBuffer( Irp, NormalPagePriority ),
                                          ByteCount,
                                          &Irp->IoStatus.Information );

            ASSERT(!NT_SUCCESS( Status ) || Irp->IoStatus.Information != 0);
            DebugTrace( 0, Dbg, ("NtfsReadFromPlex: VolumeRead\n") );
            leave;
        }

        NtfsAcquireSharedScb( IrpContext, Scb );
        AcquiredScb = TRUE;

        //
        //  If the volume isn't mounted then fail immediately.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We don't get along with encrypted/compressed/sparse things.
        //  ISSUE: supw: actually sparse should be ok, now that i'm using preparebuffers.
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED |
                                         ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                         ATTRIBUTE_FLAG_SPARSE )) {

            DebugTrace( 0, Dbg, ("NtfsReadFromPlex: File encrypted or compressed -> %08lx\n",
                                  STATUS_INVALID_PARAMETER) );
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        NtfsAcquireFsrtlHeader( Scb );

        //
        //  Make sure we aren't starting past the end of the file, in which case
        //  we would have nothing to return.
        //

        if (ByteOffset >= Scb->Header.FileSize.QuadPart) {

            DebugTrace( 0, Dbg, ("NtfsReadFromPlex: beyond eof\n") );
            Status = STATUS_END_OF_FILE;
            NtfsReleaseFsrtlHeader( Scb );
            leave;
        }

        //
        //  We can't read beyond filesize.
        //

        if (Scb->Header.FileSize.QuadPart - ByteOffset < ByteCount) {

            BytesToEof = ByteCount = (ULONG)(Scb->Header.FileSize.QuadPart - ByteOffset);
            ByteCount = ClusterAlign( Vcb, ByteCount );

            //
            //  We need to sanity check ByteCount again, since we rounded it up.
            //

            NtfsReleaseFsrtlHeader( Scb );
            ASSERT( AcquiredScb );
            NtfsReleaseScb( IrpContext, Scb );
            goto check_values;
        }

        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Can't deal with resident files.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            Status = STATUS_NOT_IMPLEMENTED;
            leave;
        }

        //
        //  PrepareBuffers needs a CompressionContext for the IO_RUN array.
        //

        RtlZeroMemory( &CompContext, sizeof(COMPRESSION_CONTEXT) );
        CompContext.IoRuns = IoRuns;
        CompContext.AllocatedRuns = NTFS_MAX_PARALLEL_IOS;
        CompContext.FinishBuffersNeeded = FALSE;

        //
        //  Get the run information, and send the IOCTL down.
        //

        while (TRUE) {

            ULONG RunCount;
            ULONG_PTR SizeOfThisRead;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            //  Build an array of io runs to do our reads from.
            //

            RemainingByteCount = NtfsPrepareBuffers( IrpContext,
                                                     Irp,
                                                     Scb,
                                                     &ByteOffset,
                                                     ByteCount,
                                                     0,
                                                     &Wait,
                                                     &NumberOfRuns,
                                                     &CompContext );

            ASSERT( RemainingByteCount < ByteCount );
            ASSERT( Wait == TRUE );
            ASSERT( NumberOfRuns > 0 );
            ASSERT( NumberOfRuns > 1 || RemainingByteCount == 0 );

            //
            //  Send synchronous IOCTLs down to do the plex reads.
            //

            for (RunCount = 0;
                 RunCount < NumberOfRuns;
                 RunCount += 1) {

                NplexRead.ByteOffset.QuadPart = CompContext.IoRuns[RunCount].StartingLbo;
                NplexRead.Length = CompContext.IoRuns[RunCount].ByteCount;
                NplexRead.PlexNumber = ReadData->PlexNumber;

                //
                //  While CurByteCOunt keeps track of the total amount of bytes read,
                //  SizeOfThisRead carries the size of the last read done. This is usually
                //  equal to the IoRuns[].ByteCount.
                //

                SizeOfThisRead = 0;
                ASSERT(CompContext.IoRuns[RunCount].ByteCount > 0);

                Status = NtfsDeviceIoControl( IrpContext,
                                              Vcb->TargetDeviceObject,
                                              IOCTL_VOLUME_READ_PLEX,
                                              &NplexRead,
                                              sizeof(VOLUME_READ_PLEX_INPUT),
                                              Add2Ptr( NtfsMapUserBuffer( Irp, NormalPagePriority ), CurByteCount ),
                                              CompContext.IoRuns[RunCount].ByteCount,
                                              &SizeOfThisRead);

                if (!NT_SUCCESS( Status )) {

                    //
                    //  Success if we read anything at all.
                    //

                    if (CurByteCount != 0) {

                        Status = STATUS_SUCCESS;
                    }

                    leave;
                }

                //
                //  This value was taken from the Iosb.Information field of the subordinate
                //  IRP, and should contain a nonzero value for successful completions.
                //

                ASSERT( (SizeOfThisRead != 0) && ((ULONG) SizeOfThisRead <= CompContext.IoRuns[RunCount].ByteCount) );
                CurByteCount = CurByteCount + (ULONG) SizeOfThisRead;

                //
                //  We don't have any more space left
                //

                if (UserBufferLength <= (ULONG) SizeOfThisRead) {

                    ASSERT( Status == STATUS_SUCCESS );
                    leave;
                }

                UserBufferLength = UserBufferLength - (ULONG) SizeOfThisRead;
            }

            if (RemainingByteCount == 0) {

                ASSERT( Status == STATUS_SUCCESS );
                break;
            }

            //
            //  We have more to read. Make sure we have enough buffer space.
            //

            LastReadByteCount = ByteCount - RemainingByteCount;

            ByteOffset = ByteOffset + LastReadByteCount;
            CompContext.SystemBufferOffset = CompContext.SystemBufferOffset + LastReadByteCount;
            ByteCount = RemainingByteCount;

        }

    } finally {

        if (AcquiredScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        //
        //  If nothing raised then complete the irp.
        //

        if (!AbnormalTermination()) {

            if (NT_SUCCESS( Status )) {

                //
                //  We have to be careful to zero beyond the filesize.
                //

                if (CurByteCount > BytesToEof) {

                    RtlZeroMemory( Add2Ptr( NtfsMapUserBuffer( Irp, NormalPagePriority ), BytesToEof ),
                                   CurByteCount - BytesToEof );
                    Irp->IoStatus.Information = BytesToEof;

                } else {

                    Irp->IoStatus.Information = CurByteCount;

                }
            }

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

    }

    DebugTrace( -1, Dbg, ("NtfsReadPlex-> %08lx\n", Status) );

    return Status;
}

#if EFSDBG

NTSTATUS
NtfsDummyEfsRead (
    IN OUT PUCHAR InOutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    )
{
#ifndef SYSCACHE
    ULONG LocalOffset = 0;
#endif
    UNREFERENCED_PARAMETER( Context );

    //
    //  Exit cleanly if this is the call that is just there to
    //  make sure the compiler doesn't throw this function out.
    //

    if (BufferSize != 0) {

#ifdef SYSCACHE
        if (FALSE && VerifySyscacheData) {

            FsRtlVerifySyscacheData( NULL,
                                     InOutBuffer,
                                     BufferSize,
                                     Offset->LowPart );
        }
#else
        ASSERT( (Offset->QuadPart & 0x1ff) == 0 );
        ASSERT( (BufferSize & 0x1ff) == 0 );

        while((LocalOffset + 8) < BufferSize) {

            *((PLONGLONG) Add2Ptr(InOutBuffer, LocalOffset)) ^= (Offset->QuadPart + (LONGLONG) LocalOffset);
            LocalOffset += 0x200;
        }
//        UNREFERENCED_PARAMETER( InOutBuffer );
//        UNREFERENCED_PARAMETER( Offset );
//        UNREFERENCED_PARAMETER( BufferSize );
#endif

    }

    //
    //  Not much to do, decryption is done in place, so we can just leave the bits
    //  in the buffer.
    //

    return STATUS_SUCCESS;
}

NTSTATUS
NtfsDummyEfsWrite (
    IN PUCHAR InBuffer,
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    )
{
#ifndef SYSCACHE
    ULONG LocalOffset = 0;
#endif
    UNREFERENCED_PARAMETER( Context );

    //
    //  Exit cleanly if this is the call that is just there to
    //  make sure the compiler doesn't throw this function out.
    //

    if (BufferSize != 0) {

        //
        //  Just copy the plaintext to the output buffer.
        //

        RtlCopyMemory( OutBuffer,
                       InBuffer,
                       BufferSize );

#ifdef SYSCACHE
        if (FALSE && VerifySyscacheData) {

            FsRtlVerifySyscacheData( NULL,
                                     OutBuffer,
                                     BufferSize,
                                     Offset->LowPart );
        }
#else
        ASSERT( (Offset->QuadPart & 0x1ff) == 0 );
        ASSERT( (BufferSize & 0x1ff) == 0 );

        while((LocalOffset + 8) < BufferSize) {

            *((PLONGLONG) Add2Ptr(OutBuffer, LocalOffset)) ^= (Offset->QuadPart + (LONGLONG) LocalOffset);
            LocalOffset += 0x200;
        }
//        UNREFERENCED_PARAMETER( Offset );
#endif
    }

    return STATUS_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\filobsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Ntfs File object support routines.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsSetFileObject)
#endif


VOID
NtfsSetFileObject (
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object

Arguments:

    FileObject - Supplies a pointer to the file object being modified.

    TypeOfOpen - Supplies the type of open denoted by the file object.
        This is only used by this procedure for sanity checking.

    Scb - Supplies a pointer to Scb for the file object.

    Ccb - Optionally supplies a pointer to a ccb

Return Value:

    None.

--*/

{
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );
    ASSERT_OPTIONAL_CCB( Ccb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetFileObject, FileObject = %08lx\n", FileObject) );

    //
    //  Load up the FileObject fields.
    //

    FileObject->FsContext = Scb;
    FileObject->FsContext2 = Ccb;
    FileObject->Vpb = Scb->Vcb->Vpb;

    //
    //  Typically the I/O manager has already set this flag correctly.  The notable
    //  exception is when the user did an open by file ID of file record 3, so
    //  we're doing a DASD open, but the I/O manager didn't notice, since it only
    //  checks for a zero length filename.
    //

    if (TypeOfOpen == UserVolumeOpen) {
        SetFlag( FileObject->Flags, FO_VOLUME_OPEN );
    }

    //
    //  Now store TypeOfOpen if there is a Ccb
    //

    ASSERT((Ccb != NULL) || (TypeOfOpen == StreamFileOpen) || (TypeOfOpen == UnopenedFileObject));
    if (Ccb != NULL) {
        Ccb->TypeOfOpen = (UCHAR)TypeOfOpen;
    }

    //
    //  If this file has the temporary attribute bit set, don't lazy
    //  write it unless absolutely necessary.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {
        SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetFileObject -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUpdateScbFromFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN BOOLEAN CheckTimeStamps
    )

/*++

Routine Description:

    This routine is called to update the Scb/Fcb to reflect the changes to
    a file through the fast io path.  It only called with a file object which
    represents a user's handle.

Arguments:

    FileObject - This is the file object used in the fast io path.

    Scb - This is the Scb for this stream.

    CheckTimeStamps - Indicates whether we want to update the time stamps from the
        fast io flags as well.  This will be TRUE if our caller will update the standard information,
        attribute header and duplicate info.  FALSE if only the attribute header and duplicate info.
        The latter case is the valid data length callback from the cache manager.

Return Value:

    None.

--*/

{

    PFCB Fcb = Scb->Fcb;
    ULONG CcbFlags;
    ULONG ScbFlags = 0;
    LONGLONG CurrentTime;

    //
    //  If the size of the main data stream is not part of the Fcb then update it
    //  now and set the correct Fcb flag.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

        if (Fcb->Info.FileSize != Scb->Header.FileSize.QuadPart) {

            Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
        }

        if (Fcb->Info.AllocatedLength != Scb->TotalAllocated) {

            Fcb->Info.AllocatedLength = Scb->TotalAllocated;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
        }

        if (FlagOn( FileObject->Flags, FO_FILE_SIZE_CHANGED )) {

            SetFlag( ScbFlags, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

    //
    //  Remember to update the size in the attribute header for named streams as well.
    //

    } else if (FlagOn( FileObject->Flags, FO_FILE_SIZE_CHANGED )) {

        SetFlag( ScbFlags, SCB_STATE_NOTIFY_RESIZE_STREAM | SCB_STATE_CHECK_ATTRIBUTE_SIZE );
    }

    ClearFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );

    //
    //  Check whether to update the time stamps if our caller requested it.
    //

    if (CheckTimeStamps && !FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {

        BOOLEAN UpdateLastAccess = FALSE;
        BOOLEAN UpdateLastChange = FALSE;
        BOOLEAN UpdateLastModify = FALSE;
        BOOLEAN SetArchive = TRUE;

        //
        //  Copy the Ccb flags to a local variable.  Then we won't have to test
        //  for the existence of the Ccb each time.
        //

        CcbFlags = 0;

        //
        //  Capture the real flags if present and clear them since we will update the Scb/Fcb.
        //

        if (FileObject->FsContext2 != NULL) {

            CcbFlags = ((PCCB) FileObject->FsContext2)->Flags;
            ClearFlag( ((PCCB) FileObject->FsContext2)->Flags,
                       (CCB_FLAG_UPDATE_LAST_MODIFY |
                        CCB_FLAG_UPDATE_LAST_CHANGE |
                        CCB_FLAG_SET_ARCHIVE) );
        }

        NtfsGetCurrentTime( IrpContext, CurrentTime );

        //
        //  If there was a write to the file then update the last change, last access
        //  and last write and the archive bit.
        //

        if (FlagOn( FileObject->Flags, FO_FILE_MODIFIED )) {

            UpdateLastModify =
            UpdateLastAccess =
            UpdateLastChange = TRUE;

        //
        //  Otherwise test each of the individual bits in the file object and
        //  Ccb.
        //

        } else {

            if (FlagOn( FileObject->Flags, FO_FILE_FAST_IO_READ )) {

                UpdateLastAccess = TRUE;
            }

            if (FlagOn( CcbFlags, CCB_FLAG_UPDATE_LAST_CHANGE )) {

                UpdateLastChange = TRUE;

                if (FlagOn( CcbFlags, CCB_FLAG_UPDATE_LAST_MODIFY )) {

                    UpdateLastModify = TRUE;
                }

                if (!FlagOn( CcbFlags, CCB_FLAG_SET_ARCHIVE )) {

                    SetArchive = FALSE;
                }
            }
        }

        //
        //  Now set the correct Fcb bits.
        //

        if (UpdateLastChange) {

            if (SetArchive) {

                ASSERTMSG( "conflict with flush", 
                           ExIsResourceAcquiredSharedLite( Fcb->Resource ) || 
                           (Fcb->PagingIoResource != NULL && 
                            ExIsResourceAcquiredSharedLite( Fcb->PagingIoResource )));

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ARCHIVE );
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
            }

            if (!FlagOn( CcbFlags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME )) {

                Fcb->Info.LastChangeTime = CurrentTime;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
            }

            if (UpdateLastModify) {

                //
                //  Remember a change to a named data stream.
                //

                if (!FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    (Scb->AttributeTypeCode == $DATA)) {

                    SetFlag( ScbFlags, SCB_STATE_NOTIFY_MODIFY_STREAM );
                }

                if (!FlagOn( CcbFlags, CCB_FLAG_USER_SET_LAST_MOD_TIME )) {

                    Fcb->Info.LastModificationTime = CurrentTime;
                    SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_MOD );
                    SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                }
            }
        }

        if (UpdateLastAccess &&
            !FlagOn( CcbFlags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME ) &&
            !FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_LAST_ACCESS )) {

            Fcb->CurrentLastAccess = CurrentTime;
            SetFlag( Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );
        }

        //
        //  Clear all of the fast io flags in the file object.
        //

        ClearFlag( FileObject->Flags, FO_FILE_MODIFIED | FO_FILE_FAST_IO_READ );
    }

    //
    //  Now store the Scb flags into the Scb.
    //

    if (ScbFlags) {

        NtfsAcquireFsrtlHeader( Scb );
        SetFlag( Scb->ScbState, ScbFlags );
        NtfsReleaseFsrtlHeader( Scb );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\flush.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements the flush buffers routine for Ntfs called by the
    dispatch driver.

Author:

    Tom Miller      [TomM]          18-Jan-1992

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_FLUSH)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH)

//
//  Macro to attempt to flush a stream from an Scb.
//

#define FlushScb(IRPC,SCB,IOS) {                                                \
    (IOS)->Status = NtfsFlushUserStream((IRPC),(SCB),NULL,0);                   \
    NtfsNormalizeAndCleanupTransaction( IRPC,                                   \
                                        &(IOS)->Status,                         \
                                        TRUE,                                   \
                                        STATUS_UNEXPECTED_IO_ERROR );           \
    if (FlagOn((SCB)->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {                  \
        NtfsWriteFileSizes( (IRPC),                                             \
                            (SCB),                                              \
                            &(SCB)->Header.ValidDataLength.QuadPart,            \
                            TRUE,                                               \
                            TRUE,                                               \
                            TRUE );                                             \
    }                                                                           \
}

//
//  Local procedure prototypes
//

NTSTATUS
NtfsFlushCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsFlushFcbFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

LONG
NtfsFlushVolumeExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonFlushBuffers)
#pragma alloc_text(PAGE, NtfsFlushAndPurgeFcb)
#pragma alloc_text(PAGE, NtfsFlushAndPurgeScb)
#pragma alloc_text(PAGE, NtfsFlushFcbFileRecords)
#pragma alloc_text(PAGE, NtfsFlushLsnStreams)
#pragma alloc_text(PAGE, NtfsFlushVolume)
#pragma alloc_text(PAGE, NtfsFsdFlushBuffers)
#pragma alloc_text(PAGE, NtfsFlushUserStream)
#endif


NTSTATUS
NtfsFsdFlushBuffers (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of flush buffers.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdFlushBuffers\n") );

    //
    //  Call the common flush buffer routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            Status = NtfsCommonFlushBuffers( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdFlushBuffers -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonFlushBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for flush buffers called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PLCB Lcb = NULL;
    PSCB ParentScb = NULL;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN ParentScbAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonFlushBuffers\n") );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("->FileObject  = %08lx\n", IrpSp->FileObject) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  abort immediately for non files
    //

    if (UnopenedFileObject == TypeOfOpen) {
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Nuthin-doing if the volume is mounted read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonFlushBuffers -> %08lx\n", Status) );
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open that we are trying to flush
        //

        switch (TypeOfOpen) {

        case UserFileOpen:

            DebugTrace( 0, Dbg, ("Flush User File Open\n") );

            //
            //  Acquire the Vcb so we can update the duplicate information as well.
            //

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            VcbAcquired = TRUE;

            //
            //  While we have the Vcb, let's make sure it's still mounted.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            //
            //  Make sure the data gets out to disk.
            //

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );

            //
            //  Acquire exclusive access to the Scb and enqueue the irp
            //  if we didn't get access
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            //
            //  Flush the stream and verify there were no errors.
            //

            FlushScb( IrpContext, Scb, &Irp->IoStatus );

            //
            //  Now commit what we've done so far.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Update the time stamps and file sizes in the Fcb based on
            //  the state of the File Object.
            //

            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

            //
            //  If we are to update standard information then do so now.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                NtfsUpdateStandardInformation( IrpContext, Fcb );
            }

            //
            //  If this is the system hive there is more work to do.  We want to flush
            //  all of the file records for this file as well as for the parent index
            //  stream.  We also want to flush the parent index stream.  Acquire the
            //  parent stream exclusively now so that the update duplicate call won't
            //  acquire it shared first.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_SYSTEM_HIVE )) {

                //
                //  Start by acquiring all of the necessary files to avoid deadlocks.
                //

                if (Ccb->Lcb != NULL) {

                    ParentScb = Ccb->Lcb->Scb;

                    if (ParentScb != NULL) {

                        NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                        ParentScbAcquired = TRUE;
                    }
                }
            }

            //
            //  Update the duplicate information if there are updates to apply.
            //

            if (FlagOn( Fcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS )) {

                Lcb = Ccb->Lcb;

                NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );
                NtfsUpdateDuplicateInfo( IrpContext, Fcb, Lcb, ParentScb );
                NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );

                if (ParentScbAcquired) {

                    NtfsReleaseScb( IrpContext, ParentScb );
                    ParentScbAcquired = FALSE;
                }
            }

            //
            //  Now flush the file records for this stream.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_SYSTEM_HIVE )) {

                //
                //  Flush the file records for this file.
                //

                Status = NtfsFlushFcbFileRecords( IrpContext, Scb->Fcb );

                //
                //  Now flush the parent index stream.
                //

                if (NT_SUCCESS(Status) && (ParentScb != NULL)) {

                    CcFlushCache( &ParentScb->NonpagedScb->SegmentObject, NULL, 0, &Irp->IoStatus );
                    Status = Irp->IoStatus.Status;

                    //
                    //  Finish by flushing the file records for the parent out
                    //  to disk.
                    //

                    if (NT_SUCCESS( Status )) {

                        Status = NtfsFlushFcbFileRecords( IrpContext, ParentScb->Fcb );
                    }
                }
            }

            //
            //  If our status is still success then flush the log file and
            //  report any changes.
            //

            if (NT_SUCCESS( Status )) {

                ULONG FilterMatch;

                LfsFlushToLsn( Vcb->LogHandle, LiMax );

                //
                //  We only want to do this DirNotify if we updated duplicate
                //  info and set the ParentScb.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
                    (Vcb->NotifyCount != 0) &&
                    FlagOn( Fcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS )) {

                    FilterMatch = NtfsBuildDirNotifyFilter( IrpContext, Fcb->InfoFlags );

                    if (FilterMatch != 0) {

                        NtfsReportDirNotify( IrpContext,
                                             Fcb->Vcb,
                                             &Ccb->FullFileName,
                                             Ccb->LastFileNameOffset,
                                             NULL,
                                             ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                               (Ccb->Lcb != NULL) &&
                                               (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FilterMatch,
                                             FILE_ACTION_MODIFIED,
                                             ParentScb->Fcb );
                    }
                }

                ClearFlag( Fcb->InfoFlags,
                           FCB_INFO_NOTIFY_FLAGS | FCB_INFO_DUPLICATE_FLAGS );
            }

            break;

        case UserViewIndexOpen:
        case UserDirectoryOpen:

            //
            //  If the user had opened the root directory then we'll
            //  oblige by flushing the volume.
            //

            if (NodeType(Scb) != NTFS_NTC_SCB_ROOT_INDEX) {

                DebugTrace( 0, Dbg, ("Flush a directory does nothing\n") );
                break;
            }

        case UserVolumeOpen:

            DebugTrace( 0, Dbg, ("Flush User Volume Open\n") );

            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            VcbAcquired = TRUE;

            //
            //  While we have the Vcb, let's make sure it's still mounted.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            NtfsFlushVolume( IrpContext,
                             Vcb,
                             TRUE,
                             FALSE,
                             TRUE,
                             FALSE );

            //
            //  Make sure all of the data written in the flush gets to disk.
            //

            LfsFlushToLsn( Vcb->LogHandle, LiMax );
            break;

        case StreamFileOpen:

            //
            //  Nothing to do here.
            //

            break;

        default:

            //
            //  Nothing to do if we have our driver object.
            //

            break;
        }

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsCommonFlushBuffers );

        //
        //  Release any resources which were acquired.
        //

        if (ScbAcquired) {
            NtfsReleaseScb( IrpContext, Scb );
        }

        if (ParentScbAcquired) {
            NtfsReleaseScb( IrpContext, ParentScb );
        }

        if (VcbAcquired) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  If this is a normal termination then pass the request on
        //  to the target device object.
        //

        if (!AbnormalTermination()) {

            NTSTATUS DriverStatus;
            PIO_STACK_LOCATION NextIrpSp;

            //
            //  Free the IrpContext now before calling the lower driver.  Do this
            //  now in case this fails so that we won't complete the Irp in our
            //  exception routine after passing it to the lower driver.
            //

            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            ASSERT( Vcb != NULL );

            //
            //  Get the next stack location, and copy over the stack location
            //


            NextIrpSp = IoGetNextIrpStackLocation( Irp );

            *NextIrpSp = *IrpSp;


            //
            //  Set up the completion routine
            //

            IoSetCompletionRoutine( Irp,
                                    NtfsFlushCompletionRoutine,
                                    NULL,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Send the request.
            //

            DriverStatus = IoCallDriver(Vcb->TargetDeviceObject, Irp);

            Status = (DriverStatus == STATUS_INVALID_DEVICE_REQUEST) ?
                     Status : DriverStatus;

        }

        DebugTrace( -1, Dbg, ("NtfsCommonFlushBuffers -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsFlushVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN FlushCache,
    IN BOOLEAN PurgeFromCache,
    IN BOOLEAN ReleaseAllFiles,
    IN BOOLEAN MarkFilesForDismount
    )

/*++

Routine Description:

    This routine non-recursively flushes a volume.  This routine will always do
    as much of the operation as possible.  It will continue until getting a logfile
    full.  If any of the streams can't be flushed because of corruption then we
    will try to flush the others.  We will mark the volume dirty in this case.

    We will pass the error code back to the caller because they often need to
    proceed as best as possible (i.e. shutdown).

Arguments:

    Vcb - Supplies the volume to flush

    FlushCache - Supplies TRUE if the caller wants to flush the data in the
        cache to disk.

    PurgeFromCache - Supplies TRUE if the caller wants the data purged from
        the Cache (such as for autocheck!)

    ReleaseAllFiles - Indicates that our caller would like to release all Fcb's
        after TeardownStructures.  This will prevent a deadlock when acquiring
        paging io resource after a main resource which is held from a previous
        teardown.

Return Value:

    STATUS_SUCCESS or else the first error status.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PFCB Fcb;
    PFCB NextFcb;
    PSCB Scb;
    PSCB NextScb;
    IO_STATUS_BLOCK IoStatus;

    ULONG Pass;

    BOOLEAN UserDataFile;
    BOOLEAN RemovedFcb = FALSE;
    BOOLEAN DecrementScbCleanup = FALSE;
    BOOLEAN DecrementNextFcbClose = FALSE;
    BOOLEAN DecrementNextScbCleanup = FALSE;

    BOOLEAN AcquiredFcb = FALSE;
    BOOLEAN PagingIoAcquired = FALSE;
    BOOLEAN ReleaseFiles = FALSE;
    LOGICAL MediaRemoved = FALSE;
    LONG ReleaseVcbCount = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFlushVolume, Vcb = %08lx\n", Vcb) );

    //
    //  This operation must be able to wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  Make sure there is nothing on the delayed close queue.
    //

    NtfsFspClose( Vcb );

    //
    //  Acquire the Vcb exclusive.  The Raise condition cannot happen.
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
    ReleaseVcbCount += 1;

    try {

        //
        //  We won't do any flushes, but we still have to
        //  do the dismount/teardown processing.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_PNP) &&
            (IrpContext->MinorFunction == IRP_MN_SURPRISE_REMOVAL)) {

            MediaRemoved = TRUE;
        }

        //
        //  Don't bother flushing read only volumes
        //

        if (NtfsIsVolumeReadOnly( Vcb )) {
            FlushCache = FALSE;
        }

        //
        //  Set the PURGE_IN_PROGRESS flag if this is a purge operation.
        //

        if (PurgeFromCache) {

            SetFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS);
        }

        //
        //  Start by flushing the log file to assure Write-Ahead-Logging.
        //

        if (!MediaRemoved) {

            LfsFlushToLsn( Vcb->LogHandle, LiMax );
        }

        //
        //  There will be two passes through the Fcb's for the volume.  On the
        //  first pass we just want to flush/purge the user data streams.  On
        //  the second pass we want to flush the other streams.  We hold off on
        //  several of the system files until after these two passes since they
        //  may be modified during the flush phases.
        //

        Pass = 0;

        do {

            PVOID RestartKey;

            //
            //  Loop through all of the Fcb's in the Fcb table.
            //

            RestartKey = NULL;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NextFcb = Fcb = NtfsGetNextFcbTableEntry( Vcb, &RestartKey );
            NtfsReleaseFcbTable( IrpContext, Vcb );

            if (NextFcb != NULL) {

                InterlockedIncrement( &NextFcb->CloseCount );
                DecrementNextFcbClose = TRUE;
            }

            while (Fcb != NULL) {

                //
                //  Acquire Paging I/O first, since we may be deleting or truncating.
                //  Testing for the PagingIoResource is not really safe without
                //  holding the main resource, so we correct for that below.
                //

                if (Fcb->PagingIoResource != NULL) {
                    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                    PagingIoAcquired = TRUE;
                }

                //
                //  Let's acquire this Scb exclusively.
                //

                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                AcquiredFcb = TRUE;

                //
                //  We depend on the state of the RemovedFcb flag to tell us that
                //  we can trust the 'Acquired' booleans above.
                //

                ASSERT( !RemovedFcb );

                //
                //  If we now do not see a paging I/O resource we are golden,
                //  othewise we can absolutely release and acquire the resources
                //  safely in the right order, since a resource in the Fcb is
                //  not going to go away.
                //

                if (!PagingIoAcquired && (Fcb->PagingIoResource != NULL)) {
                    NtfsReleaseFcb( IrpContext, Fcb );
                    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                    PagingIoAcquired = TRUE;
                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }

                //
                //  If this is not one of the special system files then perform
                //  the flush and purge as requested.  Go ahead and test file numbers
                //  instead of walking through the Scbs in the Vcb just in case they
                //  have been deleted.
                //

                if (NtfsSegmentNumber( &Fcb->FileReference ) != MASTER_FILE_TABLE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != LOG_FILE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != VOLUME_DASD_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != BIT_MAP_FILE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != BOOT_FILE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != BAD_CLUSTER_FILE_NUMBER &&
                    !FlagOn( Fcb->FcbState, FCB_STATE_USN_JOURNAL )) {

                    //
                    //  We will walk through all of the Scb's for this Fcb.  In
                    //  the first pass we will only deal with user data streams.
                    //  In the second pass we will do the others.
                    //

                    Scb = NULL;

                    while (TRUE) {

                        Scb = NtfsGetNextChildScb( Fcb, Scb );

                        if (Scb == NULL) { break; }

                        //
                        //  Reference the Scb to keep it from going away.
                        //

                        InterlockedIncrement( &Scb->CleanupCount );
                        DecrementScbCleanup = TRUE;

                        //
                        //  Check whether this is a user data file.
                        //

                        UserDataFile = FALSE;

                        if ((NodeType( Scb ) == NTFS_NTC_SCB_DATA) &&
                            (Scb->AttributeTypeCode == $DATA)) {

                            UserDataFile = TRUE;
                        }

                        //
                        //  Process this Scb in the correct loop.
                        //

                        if ((Pass == 0) == (UserDataFile)) {

                            //
                            //  Initialize the state of the Io to SUCCESS.
                            //

                            IoStatus.Status = STATUS_SUCCESS;

                            //
                            //  Don't put this Scb on the delayed close queue.
                            //

                            ClearFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );

                            //
                            //  Flush this stream if it is not already deleted.
                            //  Also don't flush resident streams for system attributes.
                            //

                            if (FlushCache &&
                                !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) &&
                                (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT) ||
                                 (Scb->AttributeTypeCode == $DATA))) {

                                //
                                //  Enclose the flushes with try-except, so that we can
                                //  react to log file full, and in any case keep on truckin.
                                //

                                try {

                                    FlushScb( IrpContext, Scb, &IoStatus );
                                    NtfsCheckpointCurrentTransaction( IrpContext );

                                //
                                //  We will handle all errors except LOG_FILE_FULL and fatal
                                //  bugcheck errors here.  In the corruption case we will
                                //  want to mark the volume dirty and continue.
                                //

                                } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                                          GetExceptionInformation(),
                                                                          (IoStatus.Status = GetExceptionCode()) )) {

                                    //
                                    //  To make sure that we can access all of our streams correctly,
                                    //  we first restore all of the higher sizes before aborting the
                                    //  transaction.  Then we restore all of the lower sizes after
                                    //  the abort, so that all Scbs are finally restored.
                                    //

                                    NtfsRestoreScbSnapshots( IrpContext, TRUE );
                                    NtfsAbortTransaction( IrpContext, IrpContext->Vcb, NULL );
                                    NtfsRestoreScbSnapshots( IrpContext, FALSE );

                                    //
                                    //  Clear the top-level exception status so we won't raise
                                    //  later.
                                    //

                                    NtfsMinimumExceptionProcessing( IrpContext );
                                    IrpContext->ExceptionStatus = STATUS_SUCCESS;

                                    //
                                    //  Remember the first error.
                                    //

                                    if (Status == STATUS_SUCCESS) {

                                        Status = IoStatus.Status;
                                    }

                                    //
                                    //  If the current status is either DISK_CORRUPT or FILE_CORRUPT then
                                    //  mark the volume dirty.  We clear the IoStatus to allow
                                    //  a corrupt file to be purged.  Otherwise it will never
                                    //  leave memory.
                                    //

                                    if ((IoStatus.Status == STATUS_DISK_CORRUPT_ERROR) ||
                                        (IoStatus.Status == STATUS_FILE_CORRUPT_ERROR)) {

                                        NtfsMarkVolumeDirty( IrpContext, Vcb );
                                        IoStatus.Status = STATUS_SUCCESS;
                                    }
                                }
                            }

                            //
                            //  Proceed with the purge if there are no failures.  We will
                            //  purge if the flush revealed a corrupt file though.
                            //

                            if (PurgeFromCache
                                && IoStatus.Status == STATUS_SUCCESS) {

                                BOOLEAN DataSectionExists;
                                BOOLEAN ImageSectionExists;

                                DataSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL);
                                ImageSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.ImageSectionObject != NULL);

                                //
                                //  Since purging the data section can cause the image
                                //  section to go away, we will flush the image section first.
                                //

                                if (ImageSectionExists) {

                                    (VOID)MmFlushImageSection( &Scb->NonpagedScb->SegmentObject, MmFlushForWrite );
                                }

                                if (DataSectionExists &&
                                    !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                          NULL,
                                                          0,
                                                          FALSE ) &&
                                    (Status == STATUS_SUCCESS)) {


                                    Status = STATUS_UNABLE_TO_DELETE_SECTION;
                                }
                            }

                            if (MarkFilesForDismount) {

                                //
                                //  Set the dismounted flag for this stream so we
                                //  know we have to fail reads & writes to it.
                                //

                                SetFlag( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED );

                                //  Also mark the Scb as not allowing fast io --
                                //  this ensures that the file system will get a
                                //  chance to see all reads & writes to this stream.
                                //

                                NtfsAcquireFsrtlHeader( Scb );
                                Scb->Header.IsFastIoPossible = FastIoIsNotPossible;
                                NtfsReleaseFsrtlHeader( Scb );
                            }
                        }

                        //
                        //  Move to the next Scb.
                        //

                        InterlockedDecrement( &Scb->CleanupCount );
                        DecrementScbCleanup = FALSE;
                    }
                }

                //
                //  If the current Fcb has a USN journal entry and we are forcing a dismount
                //  then generate the close record.
                //

                if (MarkFilesForDismount &&
                    (IoStatus.Status == STATUS_SUCCESS) &&
                    (NextFcb->FcbUsnRecord != NULL) &&
                    (NextFcb->FcbUsnRecord->UsnRecord.Reason != 0) &&
                    (!NtfsIsVolumeReadOnly( Vcb ))) {

                    //
                    //  Try to post the change but don't fail on an error like DISK_FULL.
                    //

                    try {

                        //
                        //  Now try to actually post the change.
                        //

                        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                        //
                        //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                        //  reduce contention.  We force the write now, because the Fcb may get deleted
                        //  before we normally would write the changes when the transaction commits.
                        //

                        NtfsWriteUsnJournalChanges( IrpContext );
                        NtfsCheckpointCurrentTransaction( IrpContext );

                    } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                              GetExceptionInformation(),
                                                              (IoStatus.Status = GetExceptionCode()) )) {

                        NtfsMinimumExceptionProcessing( IrpContext );
                        IoStatus.Status = STATUS_SUCCESS;

                        if (IrpContext->TransactionId != 0) {

                            //
                            //  We couldn't write the commit record, we clean up as
                            //  best we can.
                            //

                            NtfsCleanupFailedTransaction( IrpContext );
                        }
                    }
                }

                //
                //  Remove our reference to the current Fcb.
                //

                InterlockedDecrement( &NextFcb->CloseCount );
                DecrementNextFcbClose = FALSE;

                //
                //  Get the next Fcb and reference it so it won't go away.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                NextFcb = NtfsGetNextFcbTableEntry( Vcb, &RestartKey );
                NtfsReleaseFcbTable( IrpContext, Vcb );

                if (NextFcb != NULL) {

                    InterlockedIncrement( &NextFcb->CloseCount );
                    DecrementNextFcbClose = TRUE;
                }

                //
                //  Flushing the volume can cause new file objects to be allocated.
                //  If we are in the second pass and the Fcb is for a user file
                //  or directory then try to perform a teardown on this.
                //

                if ((Pass == 1) &&
                    !FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

                    ASSERT( IrpContext->TransactionId == 0 );

                    //
                    //  We can actually get failures in this routine if we need to log standard info.
                    //

                    try {

                        NtfsTeardownStructures( IrpContext,
                                                Fcb,
                                                NULL,
                                                FALSE,
                                                0,
                                                &RemovedFcb );

                        //
                        //  TeardownStructures can create a transaction.  Commit
                        //  it if present.
                        //

                        if (IrpContext->TransactionId != 0) {

                            NtfsCheckpointCurrentTransaction( IrpContext );
                        }

                    } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                              GetExceptionInformation(),
                                                              GetExceptionCode() )) {

                          NtfsMinimumExceptionProcessing( IrpContext );

                          if (IrpContext->TransactionId != 0) {

                              //
                              //  We couldn't write the commit record, we clean up as
                              //  best we can.
                              //

                              NtfsCleanupFailedTransaction( IrpContext );
                          }
                    }
                }

                //
                //  If the Fcb is still around then free any of the the other
                //  resources we have acquired.
                //

                if (!RemovedFcb) {

                    //
                    //  Free the snapshots for the current Fcb.  This will keep us
                    //  from having a snapshot for all open attributes in the
                    //  system.
                    //

                    NtfsFreeSnapshotsForFcb( IrpContext, Fcb );

                    if (PagingIoAcquired) {
                        ASSERT( IrpContext->TransactionId == 0 );
                        NtfsReleasePagingIo( IrpContext, Fcb );
                    }

                    if (AcquiredFcb) {
                        NtfsReleaseFcb( IrpContext, Fcb );
                    }
                }

                //
                //  If our caller wants to insure that all files are released
                //  between flushes then walk through the exclusive Fcb list
                //  and free everything.
                //

                if (ReleaseAllFiles) {

                    while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

                        NtfsReleaseFcb( IrpContext,
                                        (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                                                 FCB,
                                                                 ExclusiveFcbLinks ));
                    }

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                                  IRP_CONTEXT_FLAG_RELEASE_MFT );
                }

                PagingIoAcquired = FALSE;
                AcquiredFcb = FALSE;

                //
                //  Always set this back to FALSE to indicate that we can trust the
                //  'Acquired' flags above.
                //

                RemovedFcb = FALSE;

                //
                //  Now move to the next Fcb.
                //

                Fcb = NextFcb;
            }

        } while (++Pass < 2);

        //
        //  The root directory is the only fcb with a mixture of user
        //  streams that should be torn down now and system streams that
        //  can't be torn down now.
        //  When we tried to teardown the whole Fcb, we might have run
        //  into the index root attribute and stopped our teardown, in
        //  which case we may leave a close count on the Vcb which will
        //  keep autochk from being able to lock the volume.  We need to
        //  make sure the root directory indeed exists, and this isn't
        //  the call to flush the volume during mount when we haven't yet
        //  opened the root directory.
        //

        if (Vcb->RootIndexScb != NULL) {

            Fcb = Vcb->RootIndexScb->Fcb;

            //
            //  Get the first Scb for the root directory Fcb.
            //

            Scb = NtfsGetNextChildScb( Fcb, NULL );

            while (Scb != NULL) {

                NextScb = NtfsGetNextChildScb( Fcb, Scb );

                if (NextScb != NULL) {

                    InterlockedIncrement( &NextScb->CleanupCount );
                    DecrementNextScbCleanup = TRUE;
                }

                //
                //  We can actually get failures in this routine if we need to log standard info.
                //

                try {

                    if (NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                        //
                        //  Notice that we don't bother passing RemovedFcb, since
                        //  the root directory Fcb isn't going to go away.
                        //

                        NtfsTeardownStructures( IrpContext,
                                                Scb,
                                                NULL,
                                                FALSE,
                                                0,
                                                NULL );
                    }

                    //
                    //  TeardownStructures can create a transaction.  Commit
                    //  it if present.
                    //

                    if (IrpContext->TransactionId != 0) {

                        NtfsCheckpointCurrentTransaction( IrpContext );
                    }

                } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                          GetExceptionInformation(),
                                                          GetExceptionCode() )) {

                    NtfsMinimumExceptionProcessing( IrpContext );

                    if (IrpContext->TransactionId != 0) {

                        //
                        //  We couldn't write the commit record, we clean up as
                        //  best we can.
                        //

                        NtfsCleanupFailedTransaction( IrpContext );
                    }
                }

                //
                //  Decrement the cleanup count of the next Scb if we incremented it.
                //

                if (DecrementNextScbCleanup) {

                    InterlockedDecrement( &NextScb->CleanupCount );
                    DecrementNextScbCleanup = FALSE;
                }

                //
                //  Move to the next Scb.
                //

                Scb = NextScb;
            }
        }

        //
        //  Make sure that all of the delayed or async closes for this Vcb are gone.
        //

        if (PurgeFromCache) {

            NtfsFspClose( Vcb );
        }

        //
        //  If we are to mark the files for dismount then do the Volume Dasd file now.
        //

        if (MarkFilesForDismount) {

            NtfsAcquireExclusiveFcb( IrpContext, Vcb->VolumeDasdScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
            SetFlag( Vcb->VolumeDasdScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED );
            NtfsReleaseFcb( IrpContext, Vcb->VolumeDasdScb->Fcb );
        }

        //
        //  Now we want to flush/purge the streams for volume bitmap and then the Usn
        //  journal and Scb.
        //

        {
            PFCB SystemFcbs[3];
            PSCB ThisScb;

            //
            //  Store the volume bitmap, usn journal and Mft into the array.
            //

            RtlZeroMemory( SystemFcbs, sizeof( SystemFcbs ));

            if (Vcb->BitmapScb != NULL) {

                SystemFcbs[0] = Vcb->BitmapScb->Fcb;
            }

            if (Vcb->UsnJournal != NULL) {

                SystemFcbs[1] = Vcb->UsnJournal->Fcb;
            }

            if (Vcb->MftScb != NULL) {

                SystemFcbs[2] = Vcb->MftScb->Fcb;
            }

            Pass = 0;

            do {

                Fcb = SystemFcbs[Pass];

                if (Fcb != NULL) {

                    //
                    //  Purge the Mft cache if we are at the Mft.
                    //

                    if (Pass == 2) {

                        //
                        //  If we are operating on the MFT, make sure we don't have any
                        //  cached maps lying around...
                        //

                        NtfsPurgeFileRecordCache( IrpContext );

                        //
                        //  If we are purging the MFT then acquire all files to
                        //  avoid a purge deadlock.  If someone create an MFT mapping
                        //  between the flush and purge then the purge can spin
                        //  indefinitely in CC.
                        //

                        if (PurgeFromCache && !ReleaseFiles) {

                            NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
                            ReleaseFiles = TRUE;

                            //
                            //  NtfsAcquireAllFiles acquired the Vcb one more time.
                            //

                            ReleaseVcbCount += 1;
                        }

                    //
                    //  For the other Fcb's we still need to synchronize the flush and
                    //  purge so acquire and drop the Fcb.
                    //

                    } else {

                        NextFcb = Fcb;
                        InterlockedIncrement( &NextFcb->CloseCount );
                        DecrementNextFcbClose = TRUE;

                        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                        AcquiredFcb = TRUE;
                    }

                    //
                    //  Go through each Scb for each of these Fcb's.
                    //

                    ThisScb = NtfsGetNextChildScb( Fcb, NULL );

                    while (ThisScb != NULL) {

                        Scb = NtfsGetNextChildScb( Fcb, ThisScb );

                        //
                        //  Initialize the state of the Io to SUCCESS.
                        //

                        IoStatus.Status = STATUS_SUCCESS;

                        //
                        //  Reference the next Scb to keep it from going away if
                        //  we purge the current one.
                        //

                        if (Scb != NULL) {

                            InterlockedIncrement( &Scb->CleanupCount );
                            DecrementScbCleanup = TRUE;
                        }

                        if (FlushCache) {

                            //
                            //  Flush the stream.  No need to update file sizes because these
                            //  are all logged streams.
                            //

                            CcFlushCache( &ThisScb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

                            if (!NT_SUCCESS( IoStatus.Status )) {

                                Status = IoStatus.Status;
                            }

                            //
                            //  Use a try-except to commit the current transaction.
                            //

                            try {

                                NtfsCleanupTransaction( IrpContext, IoStatus.Status, TRUE );

                                NtfsCheckpointCurrentTransaction( IrpContext );

                            //
                            //  We will handle all errors except LOG_FILE_FULL and fatal
                            //  bugcheck errors here.  In the corruption case we will
                            //  want to mark the volume dirty and continue.
                            //

                            } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                                      GetExceptionInformation(),
                                                                      (IoStatus.Status = GetExceptionCode()) )) {

                                //
                                //  To make sure that we can access all of our streams correctly,
                                //  we first restore all of the higher sizes before aborting the
                                //  transaction.  Then we restore all of the lower sizes after
                                //  the abort, so that all Scbs are finally restored.
                                //

                                NtfsRestoreScbSnapshots( IrpContext, TRUE );
                                NtfsAbortTransaction( IrpContext, IrpContext->Vcb, NULL );
                                NtfsRestoreScbSnapshots( IrpContext, FALSE );

                                //
                                //  Clear the top-level exception status so we won't raise
                                //  later.
                                //

                                NtfsMinimumExceptionProcessing( IrpContext );
                                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                                //
                                //  Remember the first error.
                                //

                                if (Status == STATUS_SUCCESS) {

                                    Status = IoStatus.Status;
                                }

                                //
                                //  If the current status is either DISK_CORRUPT or FILE_CORRUPT then
                                //  mark the volume dirty.  We clear the IoStatus to allow
                                //  a corrupt file to be purged.  Otherwise it will never
                                //  leave memory.
                                //

                                if ((IoStatus.Status == STATUS_DISK_CORRUPT_ERROR) ||
                                    (IoStatus.Status == STATUS_FILE_CORRUPT_ERROR)) {

                                    NtfsMarkVolumeDirty( IrpContext, Vcb );
                                    IoStatus.Status = STATUS_SUCCESS;
                                }
                            }
                        }

                        //
                        //  Purge this stream if there have been no errors.
                        //

                        if (PurgeFromCache
                            && IoStatus.Status == STATUS_SUCCESS) {

                            if (!CcPurgeCacheSection( &ThisScb->NonpagedScb->SegmentObject,
                                                      NULL,
                                                      0,
                                                      FALSE ) &&
                                (Status == STATUS_SUCCESS)) {

                                Status = STATUS_UNABLE_TO_DELETE_SECTION;
                            }
                        }

                        //
                        //  Remove any reference we have to the next Scb and move
                        //  forward to the next Scb.
                        //

                        if (DecrementScbCleanup) {

                            InterlockedDecrement( &Scb->CleanupCount );
                            DecrementScbCleanup = FALSE;
                        }

                        ThisScb = Scb;
                    }

                    //
                    //  Purge the Mft cache if we are at the Mft.  Do this before and
                    //  after dealing with the Mft.
                    //

                    if (Pass == 2) {

                        //
                        //  If we are operating on the MFT, make sure we don't have any
                        //  cached maps lying around...
                        //

                        NtfsPurgeFileRecordCache( IrpContext );

                        //
                        //  If we are purging the MFT then acquire all files to
                        //  avoid a purge deadlock.  If someone create an MFT mapping
                        //  between the flush and purge then the purge can spin
                        //  indefinitely in CC.
                        //

                        if (PurgeFromCache && !ReleaseFiles) {

                            NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
                            ReleaseFiles = TRUE;

                            //
                            //  NtfsAcquireAllFiles acquired the Vcb one more time.
                            //

                            ReleaseVcbCount += 1;
                        }

                    //
                    //  Release the volume bitmap and Usn journal.
                    //

                    } else {

                        InterlockedDecrement( &NextFcb->CloseCount );
                        DecrementNextFcbClose = FALSE;

                        NtfsReleaseFcb( IrpContext, Fcb );
                        AcquiredFcb = FALSE;
                    }
                }

                Pass += 1;

            } while (Pass != 3);

            //
            //  Also flag as dismounted the usnjournal and volume bitmap.
            //

            if (MarkFilesForDismount) {

                if (Vcb->BitmapScb != NULL) {

                    NtfsAcquireExclusiveFcb( IrpContext, Vcb->BitmapScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    SetFlag( Vcb->BitmapScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED );
                    NtfsReleaseFcb( IrpContext, Vcb->BitmapScb->Fcb );
                }

                if (Vcb->UsnJournal != NULL) {

                    NtfsAcquireExclusiveFcb( IrpContext, Vcb->UsnJournal->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    SetFlag( Vcb->UsnJournal->ScbState, SCB_STATE_VOLUME_DISMOUNTED );
                    NtfsReleaseFcb( IrpContext, Vcb->UsnJournal->Fcb );
                }
            }
        }

    } finally {

        //
        //  If this is a purge then clear the purge flag.
        //

        if (PurgeFromCache) {

            ClearFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );
        }

        //
        //  Restore any counts we may have incremented to reference
        //  in-memory structures.
        //

        if (DecrementScbCleanup) {

            InterlockedDecrement( &Scb->CleanupCount );
        }

        if (DecrementNextFcbClose) {

            InterlockedDecrement( &NextFcb->CloseCount );
        }

        if (DecrementNextScbCleanup) {

            InterlockedDecrement( &NextScb->CleanupCount );
        }

        //
        //  We would've released our resources if we had
        //  successfully removed the fcb.
        //

        if (!RemovedFcb) {

            if (PagingIoAcquired) {
                NtfsReleasePagingIo( IrpContext, Fcb );
            }

            if (AcquiredFcb) {
                NtfsReleaseFcb( IrpContext, Fcb );
            }
        }

        if (ReleaseFiles) {

            //
            //  NtfsReleaseAllFiles is going to release the Vcb.  We'd
            //  better have it acquired at least once.
            //

            ASSERT( ReleaseVcbCount >= 1 );

            NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
            ReleaseVcbCount -= 1;
        }

        //
        //  Release the Vcb now.  We'd better have the Vcb acquired at least once.
        //

        ASSERTMSG( "Ignore this assert, 96773 is truly fixed",
                   (ReleaseVcbCount >= 1) );

        if (ReleaseVcbCount >= 1) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsFlushVolume -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsFlushLsnStreams (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN ForceRemove,
    IN BOOLEAN Partial
    )

/*++

Routine Description:

    This routine non-recursively flushes all of the Lsn streams in the open
    attribute table and removes them from the table.  We assume  the vcb
    has been pre-acquired shared and the open attribute table is preacquired
    
Arguments:

    Vcb - Supplies the volume to flush
    
    ForceRemove - If true remove the open attribute even if the flush fails
    
    OpenAttributeTableAcquired - Set to final state of table on exit - it should be true
        to start off with and we may drop and reacquire it in between 
        
    Partial - if true only flush a few streams 

Return Value:

    STATUS_SUCCESS or else the most recent error status

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatus;
    ULONG Pass = 1;
    ULONG AttrIndex;
    ULONG AttributesToFlush;

    POPEN_ATTRIBUTE_ENTRY AttributeEntry;
    PSCB Scb;
    PFCB Fcb;

    BOOLEAN AcquiredPaging = FALSE;
    BOOLEAN RemovedFcb;
    BOOLEAN FcbTableAcquired = FALSE;
    BOOLEAN ScbValid;

#if DBG || defined( NTFS_FREE_ASSERT )
    BOOLEAN EmptyList = IsListEmpty( &IrpContext->ExclusiveFcbList );
#endif

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFlushLsnStreams, Vcb = %08lx\n", Vcb) );

    ASSERT( NtfsIsSharedVcb( Vcb ) );
    ASSERT( ExIsResourceAcquiredExclusive( &Vcb->OpenAttributeTable.Resource ) );

    try {

        //
        //  This operation must be able to wait. 
        //

        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  Start by flushing the log file to push as much of it out as possible in 1 chunk
        //

        LfsFlushToLsn( Vcb->LogHandle, LiMax );

        //
        //  preacquire the fcbtable mutex to prevent any fcb's from being deleted
        //  

        NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );

        NtfsAcquireFcbTable( IrpContext, Vcb );
        NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );

        if (Partial) {
            AttributesToFlush = Vcb->OpenAttributeTable.Table->NumberAllocated / 2;
            Pass = 2;
        } else {
            Pass = 1;
        }

        //
        //  Scan the table in 2 passes - the first for user files the second for metadata
        //  during each pass files and remove them from the table. We are guaranteed
        //  that all transactions are done at this point so the bitmap will not
        //  be reopened during an abort for example
        //
        //  Partial flushes start in pass 2 so they flush the mft first
        //

        for (; Pass <= 2; Pass++) {

            //
            //  Loop through to flush all of the streams in the open attribute table.
            //

            AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

            while ((AttributeEntry != NULL) && (!Partial || AttributesToFlush > 0)) {

                AttrIndex = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable, AttributeEntry );
                Scb = AttributeEntry->OatData->Overlay.Scb;

                if (Scb != NULL) {

                    ScbValid = TRUE;

                    Fcb = Scb->Fcb;

                    //
                    //  Skip system files during pass 1
                    //

                    if ((Pass == 1) && FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {
                        AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable, AttributeEntry );
                        continue;
                    }

                    //
                    //  The mft is neither going to be torn down nor is it sync'ed on the main resource
                    //  during a flush
                    //  

                    if (Scb != Vcb->MftScb) {

                        //
                        //  Reference the fcb to keep something around - we have the fcbtable mutex
                        //  which is preventing any teardowns
                        //  

                        Fcb->ReferenceCount += 1;

                        //
                        //  If there is an scb to acquire - we must drop the open attr table and fcbtable mutex
                        //  first since they are end resources
                        // 

                        NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                        AttributeEntry = NULL;

                        NtfsReleaseFcbTable( IrpContext, Vcb );

                        //
                        //  Acquire main exclusive for flushing synchronization (this is metadata) and 
                        //  so that we can change the oat info in the non paged scb (see AcquireSharedScbForTransaction
                        //  for what we need to lock out).  Note we need to acquire the file even
                        //  if its deleted. 
                        //

                        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_HOLD_BITMAP ); 

                        //
                        //  We've acquired the fcb so release our ref count
                        //  

                        NtfsAcquireFcbTable( IrpContext, Vcb );
                        Fcb->ReferenceCount -= 1;
                        NtfsReleaseFcbTable( IrpContext, Vcb );

                        //
                        //  Is the scb still relevant? The open attribute table will only be
                        //  decreasing in size due to the drain pending state so check if the 
                        //  scb is still in it now that we're synchronized
                        // 

                        NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                        AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, AttrIndex );

                        if ((AttributeEntry->AllocatedOrNextFree != RESTART_ENTRY_ALLOCATED) ||
                            (AttributeEntry->OatData->Overlay.Scb != Scb)) {

                            //
                            //  If we're not partially draining the table then a new entry should
                            //  not appear in it 
                            // 

                            ASSERT( Partial || (AttributeEntry->AllocatedOrNextFree != RESTART_ENTRY_ALLOCATED) ||
                                    (AttributeEntry->OatData->Overlay.Scb == NULL) );

                            ScbValid = FALSE;
                        }

                    } else {
                        
                        NtfsReleaseFcbTable( IrpContext, Vcb );
                    }

                    IoStatus.Status = STATUS_SUCCESS;

                    //
                    //  Skip flushing the Mft mirror and any deleted streams.  If the header
                    //  is uninitialized for this stream then it means that the
                    //  attribute doesn't exist (INDEX_ALLOCATION where the create failed)
                    //  or the attribute is now resident.  Streams with paging resources
                    //  (except for the volume bitmap) are skipped to prevent a possible
                    //  deadlock (normally only seen in the hot fix path -- that's the
                    //  only time an ordinary user stream ends up in the open attribute
                    //  table) when this routine acquires the main resource without
                    //  holding the paging resource.  The easiest way to avoid this is
                    //  to skip such files, since it's user data, not logged metadata,
                    //  that's going to be flushed anyway, and flushing user data
                    //  doesn't help a checkpoint at all.
                    //

                    if (ScbValid) {

                        if ((Scb != Vcb->Mft2Scb) && 
                            !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) && 
                            FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) && 
                            ((Scb == Vcb->BitmapScb) || (Scb->Header.PagingIoResource == NULL))) {

                            //
                            //  The current attribute entry scb should match what we originally found
                            //  
    
                            ASSERT( AttributeEntry->OatData->Overlay.Scb == Scb );
    
                            //
                            //  Drop the table during the flush
                            //  
    
                            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
    
                            //
                            //  Now flush the stream.  We don't worry about file sizes because
                            //  any logged stream should have the file size already in the log.
                            //
    
                            CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );
    
                            if (!NT_SUCCESS( IoStatus.Status )) {
    
                                Status = IoStatus.Status;
                            }
    
                            NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                        }
    
                        //
                        //  Remove the open attribute entry for this scb from the table and clean it up
                        //  If the flush succeeded or we're forcing removal
                        // 
    
                        if (!Partial && (NT_SUCCESS( IoStatus.Status ) || ForceRemove)) {
    
                            ASSERT( Scb->NonpagedScb->OpenAttributeTableIndex == AttrIndex );
    
                            //
                            //  We now need the mft exclusive (everyone else already has it) to
                            //  zero out the oat info in the nonpaged scb
                            //  
    
                            if (Scb == Vcb->MftScb) {
    
                                NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                                NtfsAcquireExclusiveScb( IrpContext, Scb );
                                NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                            }
    
                            AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, AttrIndex );
    
                            if (AttributeEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
                                NtfsFreeAttributeEntry( Vcb, AttributeEntry );
                            }
    
                            if (Scb == Vcb->MftScb) {
                                NtfsReleaseScb( IrpContext, Scb );
                            }
                        } 
                    }

                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );

                    if (Scb != Vcb->MftScb) {

                        RemovedFcb = FALSE;

                        NtfsTeardownStructures( IrpContext,
                                                Fcb,
                                                NULL,
                                                FALSE,
                                                0,
                                                &RemovedFcb );

                        if (!RemovedFcb) {
                            NtfsReleaseFcb( IrpContext, Fcb ); 
                        }
                    }

#if DBG || defined( NTFS_FREE_ASSERT )
                    //
                    //  We shouldn't own anything more at this point than what we started with
                    //
                    
                    ASSERT( !EmptyList || IsListEmpty( &IrpContext->ExclusiveFcbList ) );
#endif

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );

                } else if (!Partial) {

                    //
                    //  There was no scb so just clean this entry up. Note we still own the table
                    //  unlike above where we had to drop it
                    // 

                    NtfsFreeAttributeEntry( Vcb, AttributeEntry );
                }

                if (Partial) {
                    
                    //
                    //  Find our place in the table since we're not removing any entries
                    //  starting with our old index
                    // 

                    AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, AttrIndex );
                    if (AttributeEntry) {
                        AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable, AttributeEntry );
                    }
                    AttributesToFlush -= 1;
                } else {
                    AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );
                }
            }
        }
    } finally {

        //
        //  We should still have 1 and only 1 owner count on the table
        //  

        ASSERT( ExIsResourceAcquiredSharedLite( &Vcb->OpenAttributeTable.Resource ) == 1 );
        
    }


    //
    //  At this point there should be no entries left in the table unless its a partial flush
    //  

    ASSERT( !NT_SUCCESS( Status ) || (Vcb->OpenAttributeTable.Table->NumberAllocated == 0) || Partial);

    NtfsReleaseFcbTable( IrpContext, Vcb );

    DebugTrace( -1, Dbg, ("NtfsFlushLsnStreams2 -> %08lx\n", Status) );

    return Status;

    UNREFERENCED_PARAMETER( IrpContext );
}


VOID
NtfsFlushAndPurgeFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine will flush and purge all of the open streams for an
    Fcb.  It is indended to prepare this Fcb such that a teardown will
    remove this Fcb for the tree.  The caller has guaranteed that the
    Fcb can't go away.

Arguments:

    Fcb - Supplies the Fcb to flush

Return Value:

    None.  The caller calls teardown structures and checks the result.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN DecrementNextScbCleanup = FALSE;

    PSCB Scb;
    PSCB NextScb;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Get the first Scb for the Fcb.
        //

        Scb = NtfsGetNextChildScb( Fcb, NULL );

        while (Scb != NULL) {

            BOOLEAN DataSectionExists;
            BOOLEAN ImageSectionExists;

            NextScb = NtfsGetNextChildScb( Fcb, Scb );

            //
            //  Save the attribute list for last so we don't purge it
            //  and then bring it back for another attribute.
            //

            if ((Scb->AttributeTypeCode == $ATTRIBUTE_LIST) &&
                (NextScb != NULL)) {

                RemoveEntryList( &Scb->FcbLinks );
                InsertTailList( &Fcb->ScbQueue, &Scb->FcbLinks );

                Scb = NextScb;
                continue;
            }

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                FlushScb( IrpContext, Scb, &IoStatus );
            }

            //
            //  The call to purge below may generate a close call.
            //  We increment the cleanup count of the next Scb to prevent
            //  it from going away in a TearDownStructures as part of that
            //  close.
            //

            DataSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL);
            ImageSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.ImageSectionObject != NULL);

            if (NextScb != NULL) {

                InterlockedIncrement( &NextScb->CleanupCount );
                DecrementNextScbCleanup = TRUE;
            }

            if (ImageSectionExists) {

                (VOID)MmFlushImageSection( &Scb->NonpagedScb->SegmentObject, MmFlushForWrite );
            }

            if (DataSectionExists) {

                CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                     NULL,
                                     0,
                                     FALSE );
            }

            //
            //  Decrement the cleanup count of the next Scb if we incremented
            //  it.
            //

            if (DecrementNextScbCleanup) {

                InterlockedDecrement( &NextScb->CleanupCount );
                DecrementNextScbCleanup = FALSE;
            }

            //
            //  Move to the next Scb.
            //

            Scb = NextScb;
        }

    } finally {

        //
        //  Restore any counts we may have incremented to reference
        //  in-memory structures.
        //

        if (DecrementNextScbCleanup) {

            InterlockedDecrement( &NextScb->CleanupCount );
        }
    }

    return;
}


VOID
NtfsFlushAndPurgeScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PSCB ParentScb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to flush and purge a stream.  It is used
    when there are now only non-cached handles on a file and there is
    a data section.  Flushing and purging the data section will mean that
    the user non-cached io won't have to block for the cache coherency calls.

    We want to remove all of the Fcb's from the exclusive list so that the
    lower level flush will be its own transaction.  We don't want to drop
    any of the resources however so we acquire the Scb's above explicitly
    and then empty the exclusive list.  In all cases we will reacquire the
    Scb's before raising out of this routine.

    Because this routines causes the write out of all data to disk its critical
    that it also updates the filesizes on disk. If NtfsWriteFileSizes raises logfile full
    the caller (create, cleanup etc.) must recall this routine or update the filesizes
    itself. To help with doing this we set the irpcontext state that we attemted a
    flushandpurge. Also note because we purged the section on a retry it may no longer
    be there so a test on (SectionObjectPointer->DataSection != NULL) will miss retrying

Arguments:

    Scb - Scb for the stream to flush and purge.  The reference count on this
        stream will prevent it from going away.

    ParentScb - If specified then this is the parent for the stream being flushed.

Return Value:

    None.

--*/

{
    IO_STATUS_BLOCK Iosb;
    BOOLEAN PurgeResult;

    PAGED_CODE();

    //
    //  Only actually flush and purge if there is a data section
    //

    if (Scb->NonpagedScb->SegmentObject.DataSectionObject) {

        //
        //  Commit the current transaction.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Acquire the Scb explicitly. We don't bother to do the same for the
        //  parent SCB here; we'll just acquire it on our way out.
        //

        NtfsAcquireResourceExclusive( IrpContext, Scb, TRUE );

        //
        //  Walk through and release all of the Fcb's in the Fcb list.
        //

        while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

            NtfsReleaseFcb( IrpContext,
                            (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                                     FCB,
                                                     ExclusiveFcbLinks ));
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                      IRP_CONTEXT_FLAG_RELEASE_MFT );

        //
        //  Use a try-finally to reacquire the Scbs.
        //

        try {

            //
            //  Perform the flush, raise on error.
            //

#ifdef  COMPRESS_ON_WIRE
            if (Scb->Header.FileObjectC != NULL) {

                PCOMPRESSION_SYNC CompressionSync = NULL;

                //
                //  Use a try-finally to clean up the compression sync.
                //

                try {

                    Iosb.Status = NtfsSynchronizeUncompressedIo( Scb,
                                                                 NULL,
                                                                 0,
                                                                 TRUE,
                                                                 &CompressionSync );

                } finally {

                    NtfsReleaseCompressionSync( CompressionSync );
                }

                NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );
            }
#endif

            //
            //  After doing the work of the flush we must update the ondisk sizes either
            //  here or in close if we fail logfile full
            //

            NtfsPurgeFileRecordCache( IrpContext );
            SetFlag( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE );
            CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &Iosb );

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {

                ASSERT( Scb->Fcb->PagingIoResource != NULL );
                ASSERT( NtfsIsExclusiveScbPagingIo( Scb ) );

                FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH, 0, 0, 0, Iosb.Status );
            }
#endif
            NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

            //
            //  If no error, then purge the section
            //

            PurgeResult = CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject, NULL, 0, FALSE );

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {

                ASSERT( (Scb->Fcb->PagingIoResource != NULL) && NtfsIsExclusiveScbPagingIo( Scb ) );

                FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH_AND_PURGE, 0, 0, (DWORD_PTR)(Scb->NonpagedScb->SegmentObject.SharedCacheMap), PurgeResult );
            }
#endif

        } finally {

            //
            //  Reacquire the Scb and it's parent..
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            NtfsReleaseResource( IrpContext, Scb );

            if (ARGUMENT_PRESENT( ParentScb )) {

                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
            }
        }
    } //  endif DataSection existed

    //
    //  Write the file sizes to the attribute.  Commit the transaction since the
    //  file sizes must get to disk.
    //

    ASSERT( FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) );

    NtfsWriteFileSizes( IrpContext, Scb, &Scb->Header.ValidDataLength.QuadPart, TRUE, TRUE, FALSE );
    NtfsCheckpointCurrentTransaction( IrpContext );
    ClearFlag( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE );

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsFlushCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );

    //
    //  Add the hack-o-ramma to fix formats.
    //

    if ( Irp->PendingReturned ) {

        IoMarkIrpPending( Irp );
    }

    //
    //  If the Irp got STATUS_INVALID_DEVICE_REQUEST, normalize it
    //  to STATUS_SUCCESS.
    //

    if (Irp->IoStatus.Status == STATUS_INVALID_DEVICE_REQUEST) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsFlushFcbFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to flush the file records for a given file.  It is
    intended to flush the critical file records for the system hives.

Arguments:

    Fcb - This is the Fcb to flush.

Return Value:

    NTSTATUS - The status returned from the flush operation.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN MoreToGo;

    LONGLONG LastFileOffset = MAXLONGLONG;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &AttrContext );

    IoStatus.Status = STATUS_SUCCESS;

    //
    //  Use a try-finally to cleanup the context.
    //

    try {

        //
        //  Find the first.  It should be there.
        //

        MoreToGo = NtfsLookupAttribute( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        &AttrContext );

        if (!MoreToGo) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        while (MoreToGo) {

            if (AttrContext.FoundAttribute.MftFileOffset != LastFileOffset) {

                LastFileOffset = AttrContext.FoundAttribute.MftFileOffset;

                CcFlushCache( &Fcb->Vcb->MftScb->NonpagedScb->SegmentObject,
                              (PLARGE_INTEGER) &LastFileOffset,
                              Fcb->Vcb->BytesPerFileRecordSegment,
                              &IoStatus );

                if (!NT_SUCCESS( IoStatus.Status )) {

                    IoStatus.Status = FsRtlNormalizeNtstatus( IoStatus.Status,
                                                              STATUS_UNEXPECTED_IO_ERROR );
                    break;
                }
            }

            MoreToGo = NtfsLookupNextAttribute( IrpContext,
                                                Fcb,
                                                &AttrContext );
        }

    } finally {

        DebugUnwind( NtfsFlushFcbFileRecords );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return IoStatus.Status;
}


NTSTATUS
NtfsFlushUserStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine flushes a user stream as a top-level action.  To do so
    it checkpoints the current transaction first and frees all of the
    caller's snapshots.  After doing the flush, it snapshots the input
    Scb again, just in case the caller plans to do any more work on that
    stream.  If the caller needs to modify any other streams (presumably
    metadata), it must know to snapshot them itself after calling this
    routine.

Arguments:

    Scb - Stream to flush

    FileOffset - FileOffset at which the flush is to start, or NULL for
                 entire stream.

    Length - Number of bytes to flush.  Ignored if FileOffset not specified.

Return Value:

    Status of the flush

--*/

{
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN ScbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Checkpoint the current transaction and free all of its snapshots,
    //  in order to treat the flush as a top-level action with his own
    //  snapshots, etc.
    //

    NtfsCheckpointCurrentTransaction( IrpContext );
    NtfsFreeSnapshotsForFcb( IrpContext, NULL );

    //
    //  Set the wait flag in the IrpContext so we don't hit a case where the
    //  reacquire below fails because we can't wait.  If our caller was asynchronous
    //  and we get this far we will continue synchronously.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  We must free the Scb now before calling through MM to prevent
    //  collided page deadlocks.
    //

    //
    //  We are about to flush the stream.  The Scb may be acquired exclusive
    //  and, thus, is linked onto the IrpContext or onto one higher
    //  up in the IoCallDriver stack.  We are about to make a
    //  call back into Ntfs which may acquire the Scb exclusive, but
    //  NOT put it onto the nested IrpContext exclusive queue which prevents
    //  the nested completion from freeing the Scb.
    //
    //  This is only a problem for Scb's without a paging resource.
    //
    //  We acquire the Scb via ExAcquireResourceExclusiveLite, sidestepping
    //  Ntfs bookkeeping, and release it via NtfsReleaseScb.
    //

    ScbAcquired = NtfsIsExclusiveScb( Scb );

    if (ScbAcquired) {
        if (Scb->Header.PagingIoResource == NULL) {
            NtfsAcquireResourceExclusive( IrpContext, Scb, TRUE );
        }
        NtfsReleaseScb( IrpContext, Scb );
    }

#ifdef  COMPRESS_ON_WIRE
    if (Scb->Header.FileObjectC != NULL) {

        PCOMPRESSION_SYNC CompressionSync = NULL;

        //
        //  Use a try-finally to clean up the compression sync.
        //

        try {

            NtfsSynchronizeUncompressedIo( Scb,
                                           NULL,
                                           0,
                                           TRUE,
                                           &CompressionSync );

        } finally {

            NtfsReleaseCompressionSync( CompressionSync );
        }
    }
#endif

    //
    //  Clear the file record cache before doing the flush.  Otherwise FlushVolume may hold this
    //  file and be purging the Mft at the same time this thread has a Vacb in the Mft and is
    //  trying to reacquire the file in the recursive IO thread.
    //

    NtfsPurgeFileRecordCache( IrpContext );

    //
    //  Now do the flush he wanted as a top-level action
    //

    CcFlushCache( &Scb->NonpagedScb->SegmentObject, (PLARGE_INTEGER)FileOffset, Length, &IoStatus );

    //
    //  Now reacquire for the caller.
    //

    if (ScbAcquired) {
        NtfsAcquireExclusiveScb( IrpContext, Scb );
        if (Scb->Header.PagingIoResource == NULL) {
            NtfsReleaseResource( IrpContext, Scb );
        }
    }

    return IoStatus.Status;
}


//
//  Local support routine
//

LONG
NtfsFlushVolumeExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    )

{
    //
    //  Swallow any errors except LOG_FILE_FULL, CANT_WAIT and anything else not expected.
    //

    if ((ExceptionCode == STATUS_LOG_FILE_FULL) ||
        (ExceptionCode == STATUS_CANT_WAIT) ||
        !FsRtlIsNtstatusExpected( ExceptionCode )) {

        return EXCEPTION_CONTINUE_SEARCH;

    } else {

        return EXCEPTION_EXECUTE_HANDLER;
    }

    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( ExceptionPointer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fsctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Ntfs called
    by the dispatch driver.

Author:

    Gary Kimura     [GaryKi]        29-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"
#ifdef NTFSDBG
#include "lockorder.h"
#endif

#ifdef NTFS_CHECK_BITMAP
BOOLEAN NtfsCopyBitmap = TRUE;
#endif

#ifdef SYSCACHE_DEBUG
BOOLEAN NtfsDisableSyscacheLogFile = TRUE;
#endif

ULONG SkipNtOfs = FALSE;

BOOLEAN NtfsForceUpgrade = TRUE;

VOID
NtOfsIndexTest (
    PIRP_CONTEXT IrpContext,
    PFCB TestFcb
    );

//
//  Temporarily reference our local attribute definitions
//

extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

//
//**** The following variable is only for debugging and is used to disable NTFS
//**** from mounting any volumes
//

BOOLEAN NtfsDisable = FALSE;

//
//  The following is used to selectively not mount a particular device.  Used for testing.
//

PDEVICE_OBJECT NtfsDisableDevice = NULL;

//
//  The following is used to determine when to move to compressed files.
//

BOOLEAN NtfsDefragMftEnabled = FALSE;

LARGE_INTEGER NtfsLockDelay = {(ULONG)-10000000, -1};   // 1 second

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_FSCTRL)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)
#define DbgAcl                           (DEBUG_TRACE_FSCTRL|DEBUG_TRACE_ACLINDEX)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('fFtN')

//
//  Local procedure prototypes
//

NTSTATUS
NtfsInitializeDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PVPB Vpb,
    IN PDEVICE_OBJECT DiskDevice,
    OUT PBOOLEAN VcbAcquired,
    OUT PVOLUME_DEVICE_OBJECT * VolDo
    );

NTSTATUS
NtfsMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsUpdateAttributeTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsUserFsRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDirtyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
NtfsGetDiskGeometry (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo,
    IN PDISK_GEOMETRY DiskGeometry,
    IN PLONGLONG PartitionSize
    );

VOID
NtfsReadBootSector (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PSCB *BootScb,
    OUT PBCB *BootBcb,
    OUT PVOID *BootSector
    );

BOOLEAN
NtfsIsBootSectorNtfs (
    IN PPACKED_BOOT_SECTOR BootSector,
    IN PVCB Vcb
    );

VOID
NtfsGetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PVPB Vpb OPTIONAL,
    IN PVCB Vcb,
    OUT PUSHORT VolumeFlags
    );

VOID
NtfsSetAndGetVolumeTimes (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MarkDirty
    );

VOID
NtfsOpenSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb,
    IN PVCB Vcb,
    IN ULONG FileNumber,
    IN LONGLONG Size,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN BOOLEAN ModifiedNoWrite
    );

VOID
NtfsOpenRootDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsChangeAttributeCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVCB Vcb,
    IN PCCB Ccb,
    IN USHORT CompressionState
    );

NTSTATUS
NtfsSetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsMarkAsSystemHive (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetStatistics (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

LONG
NtfsWriteRawExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

#define NtfsMapPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,FALSE)

#define NtfsPinPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,TRUE)

VOID
NtfsMapOrPinPageInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    IN OUT PRTL_BITMAP Bitmap,
    OUT PBCB *BitmapBcb,
    IN BOOLEAN AlsoPinData
    );

#define BYTES_PER_PAGE (PAGE_SIZE)
#define BITS_PER_PAGE (BYTES_PER_PAGE * 8)

NTSTATUS
NtfsGetVolumeData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetVolumeBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetExtendedDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCreateUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadFileRecordUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadFileUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsWriteUsnCloseRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

NTSTATUS
NtfsBulkSecurityIdCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsInitializeSecurityFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsUpgradeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeQuotaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeObjectIdFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeReparseFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA NewJournalData
    );

VOID
NtfsInitializeExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryAllocatedRanges (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetSparse (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp );

NTSTATUS
NtfsGetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp );

NTSTATUS
NtfsDeleteReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp );

NTSTATUS
NtfsEncryptionFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetEncryption (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsWriteRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsFindFilesOwnedBySid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsFindBySidWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

NTSTATUS
NtfsExtendVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsMarkHandle (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsPrefetchFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

LONG
NtfsFsctrlExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN BOOLEAN AccessingUserData,
    IN OUT PNTSTATUS Status
    );

#ifdef BRIANDBG
LONG
NtfsDismountExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    );
#endif

#ifdef SYSCACHE_DEBUG
VOID
NtfsInitializeSyscacheLogFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsBulkSecurityIdCheck)
#pragma alloc_text(PAGE, NtfsChangeAttributeCompression)
#pragma alloc_text(PAGE, NtfsCommonFileSystemControl)
#pragma alloc_text(PAGE, NtfsCreateUsnJournal)
#pragma alloc_text(PAGE, NtfsDeleteReparsePoint)
#pragma alloc_text(PAGE, NtfsDirtyVolume)
#pragma alloc_text(PAGE, NtfsDismountVolume)
#pragma alloc_text(PAGE, NtfsEncryptionFsctl)
#pragma alloc_text(PAGE, NtfsExtendVolume)
#pragma alloc_text(PAGE, NtfsFindBySidWorker)
#pragma alloc_text(PAGE, NtfsFindFilesOwnedBySid)
#pragma alloc_text(PAGE, NtfsFsdFileSystemControl)
#pragma alloc_text(PAGE, NtfsGetCompression)
#pragma alloc_text(PAGE, NtfsGetDiskGeometry)
#pragma alloc_text(PAGE, NtfsGetMftRecord)
#pragma alloc_text(PAGE, NtfsGetReparsePoint)
#pragma alloc_text(PAGE, NtfsGetRetrievalPointers)
#pragma alloc_text(PAGE, NtfsGetStatistics)
#pragma alloc_text(PAGE, NtfsGetTunneledData)
#pragma alloc_text(PAGE, NtfsGetVolumeBitmap)
#pragma alloc_text(PAGE, NtfsGetVolumeData)
#pragma alloc_text(PAGE, NtfsGetVolumeInformation)
#pragma alloc_text(PAGE, NtfsInitializeDevice)
#pragma alloc_text(PAGE, NtfsInitializeExtendDirectory)
#pragma alloc_text(PAGE, NtfsInitializeObjectIdFile)
#pragma alloc_text(PAGE, NtfsInitializeReparseFile)
#pragma alloc_text(PAGE, NtfsInitializeQuotaFile)
#pragma alloc_text(PAGE, NtfsInitializeSecurityFile)
#pragma alloc_text(PAGE, NtfsInitializeUsnJournal)
#pragma alloc_text(PAGE, NtfsIsBootSectorNtfs)
#pragma alloc_text(PAGE, NtfsIsVolumeDirty)
#pragma alloc_text(PAGE, NtfsIsVolumeMounted)
#pragma alloc_text(PAGE, NtfsLockVolume)
#pragma alloc_text(PAGE, NtfsMarkAsSystemHive)
#pragma alloc_text(PAGE, NtfsMarkHandle)
#pragma alloc_text(PAGE, NtfsMountVolume)
#pragma alloc_text(PAGE, NtfsOpenRootDirectory)
#pragma alloc_text(PAGE, NtfsOpenSystemFile)
#pragma alloc_text(PAGE, NtfsOplockRequest)
#pragma alloc_text(PAGE, NtfsPrefetchFile)
#pragma alloc_text(PAGE, NtfsQueryAllocatedRanges)
#pragma alloc_text(PAGE, NtfsQueryRetrievalPointers)
#pragma alloc_text(PAGE, NtfsReadBootSector)
#pragma alloc_text(PAGE, NtfsReadFileRecordUsnData)
#pragma alloc_text(PAGE, NtfsReadFileUsnData)
#pragma alloc_text(PAGE, NtfsReadRawEncrypted)
#pragma alloc_text(PAGE, NtfsReadUsnWorker)
#pragma alloc_text(PAGE, NtfsSetAndGetVolumeTimes)
#pragma alloc_text(PAGE, NtfsSetCompression)
#pragma alloc_text(PAGE, NtfsSetEncryption)
#pragma alloc_text(PAGE, NtfsSetExtendedDasdIo)
#pragma alloc_text(PAGE, NtfsSetReparsePoint)
#pragma alloc_text(PAGE, NtfsSetSparse)
#pragma alloc_text(PAGE, NtfsSetTunneledData)
#pragma alloc_text(PAGE, NtfsUnlockVolume)
#pragma alloc_text(PAGE, NtfsUpdateAttributeTable)
#pragma alloc_text(PAGE, NtfsUpgradeSecurity)
#pragma alloc_text(PAGE, NtfsUserFsRequest)
#pragma alloc_text(PAGE, NtfsVerifyVolume)
#pragma alloc_text(PAGE, NtfsWriteRawEncrypted)
#pragma alloc_text(PAGE, NtfsWriteUsnCloseRecord)
#pragma alloc_text(PAGE, NtfsZeroRange)
#endif

#ifdef BRIANDBG
LONG
NtfsDismountExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    )
{
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( ExceptionPointer->ExceptionRecord->ExceptionCode == STATUS_SUCCESS );

    return EXCEPTION_CONTINUE_SEARCH;
}
#endif


NTSTATUS
NtfsFsdFileSystemControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of File System Control.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;

    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    PIRP_CONTEXT IrpContext = NULL;
    PIO_STACK_LOCATION IrpSp;

    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN Wait;
    BOOLEAN Retry = FALSE;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdFileSystemControl\n") );

    //
    //  Call the common File System Control routine, with blocking allowed if
    //  synchronous.  This opeation needs to special case the mount
    //  and verify suboperations because we know they are allowed to block.
    //  We identify these suboperations by looking at the file object field
    //  and seeing if its null.
    //

    if (IoGetCurrentIrpStackLocation( Irp )->FileObject == NULL) {

        Wait = TRUE;

    } else {

        Wait = CanFsdWait( Irp );
    }

    //
    //  Make the callback if this is not our filesystem device object (i.e., !mount)
    //  and thus a regular fsctrl.  Mounts are handled later via a seperate callback.
    //

    if ((VolumeDeviceObject->DeviceObject.Size != sizeof( DEVICE_OBJECT )) &&
        (NtfsData.EncryptionCallBackTable.PreFileSystemControl != NULL)) {

        Status = NtfsData.EncryptionCallBackTable.PreFileSystemControl( (PDEVICE_OBJECT) VolumeDeviceObject,
                                                                        Irp,
                                                                        IoGetCurrentIrpStackLocation( Irp )->FileObject );

        //
        //  Raise the status if a failure.
        //

        if (Status != STATUS_SUCCESS) {

            //
            //  EFS should never return anything but STATUS_SUCCESS or an error or warning.
            //

            ASSERT( !NT_SUCCESS( Status ));

            NtfsCompleteRequest( NULL, Irp, Status );
            return Status;
        }
    }

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                Retry = TRUE;
                NtfsCheckpointForLogFileFull( IrpContext );

            } else if (Status == STATUS_CANT_WAIT) {

                Retry = TRUE;
            }

            IrpSp = IoGetCurrentIrpStackLocation(Irp);

            if (IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

                Status = NtfsPostRequest( IrpContext, Irp );

            } else {

                //
                //  The SetCompression control is a long-winded function that has
                //  to rewrite the entire stream, and has to tolerate log file full
                //  conditions.  If this is the first pass through we initialize some
                //  fields in the NextIrpSp to allow us to resume the set compression
                //  operation.
                //
                //  David Goebel 1/3/96: Changed to next stack location so that we
                //  don't wipe out buffer length values.  These Irps are never
                //  dispatched, so the next stack location will not be disturbed.
                //

                if ((IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                    (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_COMPRESSION)) {

                    if (!Retry) {

                        PIO_STACK_LOCATION NextIrpSp;
                        NextIrpSp = IoGetNextIrpStackLocation( Irp );

                        NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = MAXULONG;
                        NextIrpSp->Parameters.FileSystemControl.InputBufferLength = MAXULONG;
                    }
                }

                Status = NtfsCommonFileSystemControl( IrpContext, Irp );
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdFileSystemControl -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonFileSystemControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for File System Control called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonFileSystemControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_MOUNT_VOLUME:

        Status = NtfsMountVolume( IrpContext, Irp );
        break;

    case IRP_MN_USER_FS_REQUEST:
    case IRP_MN_KERNEL_CALL:

        Status = NtfsUserFsRequest( IrpContext, Irp );
        break;

    default:

        DebugTrace( -1, Dbg, ("Invalid Minor Function %08lx\n", IrpSp->MinorFunction) );
        NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_INVALID_DEVICE_REQUEST );
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsCommonFileSystemControl -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsInitializeDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PVPB Vpb,
    IN PDEVICE_OBJECT DiskDevice,
    OUT PBOOLEAN VcbAcquired,
    OUT PVOLUME_DEVICE_OBJECT * VolDo
    )

/*++

Routine Description:

    This subroutine creates an initializes a device object for a new volume. It
    is called during mount.  All the work necc. to init the device object fields is done here.
    After completion the volume still may not be ntfs and even it is will still have to be
    run through the main mount process. We get the actual disk geometry to fill in some
    fields and also init the vcb fields dependent on this.

    NOTE: in the long run it might be more efficient to read the boot sector before
    creating the device object

Arguments:

    Vpb - The vpb for the volume being mounted

    DiskDevice - Storage device we mount on - Note: the vpb usually points to the middle of the
                storage stack - this device will be the top of the stack

    VcbAcquired - On return if true the vcb for the volume is acquired exclusive

    VolDo - The newly created volume device object

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    DISK_GEOMETRY DiskGeometry;
    LONGLONG Length;
    ULONG BytesPerSector;
    ULONG Index;
    BOOLEAN WriteProtected;

    PAGED_CODE();

    *VcbAcquired = FALSE;

    Status = IoCreateDevice( NtfsData.DriverObject,
                             sizeof(VOLUME_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                             NULL,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             (PDEVICE_OBJECT *)VolDo );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    //  Our alignment requirement is the larger of the processor alignment requirement
    //  already in the volume device object and that in the DeviceObjectWeTalkTo
    //

    if (DiskDevice->AlignmentRequirement > (*VolDo)->DeviceObject.AlignmentRequirement) {

        (*VolDo)->DeviceObject.AlignmentRequirement = DiskDevice->AlignmentRequirement;
    }

    //
    //  Add one more to the stack size requirements for our device
    //

    (*VolDo)->DeviceObject.StackSize = DiskDevice->StackSize + 1;

    //
    //  Initialize the overflow queue for the volume
    //

    (*VolDo)->OverflowQueueCount = 0;
    InitializeListHead( &((*VolDo)->OverflowQueue) );
    KeInitializeEvent( &((*VolDo)->OverflowQueueEvent), SynchronizationEvent, FALSE );

    //
    //  Get a reference to the Vcb hanging off the end of the volume device object
    //  we just created
    //

    IrpContext->Vcb = &((*VolDo)->Vcb);

    //
    //  Set the device object field in the vpb to point to our new volume device
    //  object
    //

    Vpb->DeviceObject = (PDEVICE_OBJECT)(*VolDo);

    //
    //  Initialize the Vcb.  Set checkpoint
    //  in progress (to prevent a real checkpoint from occuring until we
    //  are done).
    //

    NtfsInitializeVcb( IrpContext, IrpContext->Vcb, DiskDevice, Vpb );
    NtfsAcquireExclusiveVcb( IrpContext, IrpContext->Vcb, TRUE );
    *VcbAcquired= TRUE;

    //
    //  Query the device we talk to for this geometry and setup enough of the
    //  vcb to read in the boot sectors.  This is a temporary setup until
    //  we've read in the actual boot sector and got the real cluster factor.
    //


    WriteProtected = NtfsGetDiskGeometry( IrpContext,
                                          DiskDevice,
                                          &DiskGeometry,
                                          &Length );

    if (WriteProtected) {

        SetFlag( IrpContext->Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY );
    }


    //
    //  If the sector size is greater than the page size, it is probably
    //  a bogus return, but we cannot use the device.  We also verify that
    //  the sector size is a power of two.
    //

    BytesPerSector = DiskGeometry.BytesPerSector;

    if ((BytesPerSector > PAGE_SIZE) ||
        (BytesPerSector == 0)) {
        NtfsRaiseStatus( IrpContext, STATUS_BAD_DEVICE_TYPE, NULL, NULL );
    }

    while (TRUE) {

        if (FlagOn( BytesPerSector, 1 )) {

            if (BytesPerSector != 1) {
                NtfsRaiseStatus( IrpContext, STATUS_BAD_DEVICE_TYPE, NULL, NULL );
            }
            break;
        }

        BytesPerSector >>= 1;
    }

    IrpContext->Vcb->BytesPerSector = DiskGeometry.BytesPerSector;
    IrpContext->Vcb->BytesPerCluster = IrpContext->Vcb->BytesPerSector;
    IrpContext->Vcb->NumberSectors = Length / DiskGeometry.BytesPerSector;

    //
    //  Fail the mount if the number of sectors is less than 16.  Oth
    //  won't work.
    //

    if (IrpContext->Vcb->NumberSectors <= 0x10) {

        Status = STATUS_UNRECOGNIZED_VOLUME;
    }

    IrpContext->Vcb->ClusterMask = IrpContext->Vcb->BytesPerCluster - 1;
    IrpContext->Vcb->InverseClusterMask = ~IrpContext->Vcb->ClusterMask;
    for (IrpContext->Vcb->ClusterShift = 0, Index = IrpContext->Vcb->BytesPerCluster; Index > 1; Index = Index / 2) {
        IrpContext->Vcb->ClusterShift += 1;
    }
    IrpContext->Vcb->ClustersPerPage = PAGE_SIZE >> IrpContext->Vcb->ClusterShift;

    //
    //  Set the sector size in our device object.
    //

    (*VolDo)->DeviceObject.SectorSize = (USHORT) IrpContext->Vcb->BytesPerSector;

    //
    //  Now that all the DeviceObject fields are set clear the initializing flag
    //

    ClearFlag( (*VolDo)->DeviceObject.Flags, DO_DEVICE_INITIALIZING );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

    Its job is to verify that the volume denoted in the IRP is an NTFS volume,
    and create the VCB and root SCB/FCB structures.  The algorithm it uses is
    essentially as follows:

    1. Create a new Vcb Structure, and initialize it enough to do cached
       volume file I/O.

    2. Read the disk and check if it is an NTFS volume.

    3. If it is not an NTFS volume then free the cached volume file, delete
       the VCB, and complete the IRP with STATUS_UNRECOGNIZED_VOLUME

    4. Check if the volume was previously mounted and if it was then do a
       remount operation.  This involves freeing the cached volume file,
       delete the VCB, hook in the old VCB, and complete the IRP.

    5. Otherwise create a root SCB, recover the volume, create Fsp threads
       as necessary, and complete the IRP.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PATTRIBUTE_RECORD_HEADER Attribute;

    PDEVICE_OBJECT DeviceObjectWeTalkTo;
    PVPB Vpb;

    PVOLUME_DEVICE_OBJECT VolDo = NULL;
    PVCB Vcb;

    PFILE_OBJECT RootDirFileObject = NULL;
    PBCB BootBcb = NULL;
    PPACKED_BOOT_SECTOR BootSector;
    PSCB BootScb = NULL;
    PSCB QuotaDataScb = NULL;

    POBJECT_NAME_INFORMATION DeviceObjectName = NULL;
    ULONG DeviceObjectNameLength;

    PBCB Bcbs[8] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
    PMDL Mdls[8] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};

    ULONG FirstNonMirroredCluster;
    ULONG MirroredMftRange;

    PLIST_ENTRY MftLinks;
    PSCB AttributeListScb;

    ULONG i;

    IO_STATUS_BLOCK IoStatus;

    BOOLEAN UpdatesApplied;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN MountFailed = TRUE;
    BOOLEAN CloseAttributes = FALSE;
    BOOLEAN UpgradeVolume = FALSE;
    BOOLEAN CurrentVersion = FALSE;
    BOOLEAN UnrecognizedRestart;
    ULONG RetryRestart;

    USHORT VolumeFlags = 0;

    LONGLONG LlTemp1;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //**** The following code is only temporary and is used to disable NTFS
    //**** from mounting any volumes
    //

    if (NtfsDisable) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Reject floppies
    //

    if (FlagOn( IoGetCurrentIrpStackLocation(Irp)->
                Parameters.MountVolume.Vpb->
                RealDevice->Characteristics, FILE_FLOPPY_DISKETTE ) ) {

        Irp->IoStatus.Information = 0;

        NtfsCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsMountVolume\n") );

    //
    //  Save some references to make our life a little easier
    //

    DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;
    Vpb = IrpSp->Parameters.MountVolume.Vpb;
    ClearFlag( Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

    //
    //  TEMPCODE  Perform the following test for chkdsk testing.
    //

    if (NtfsDisableDevice == IrpSp->Parameters.MountVolume.DeviceObject) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Acquire exclusive global access
    //

    NtfsAcquireExclusiveGlobal( IrpContext, TRUE );

    //
    //  Now is a convenient time to look through the queue of Vcb's to see if there
    //  are any which can be deleted.
    //

    try {

        PLIST_ENTRY Links;

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks );

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
                (Vcb->CloseCount == 0) &&
                FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

                //
                //  Now we can check to see if we should perform the teardown
                //  on this Vcb.  The release Vcb routine below can do all of
                //  the checks correctly.  Make this appear to from a close
                //  call since there is no special biasing for this case.
                //

                IrpContext->Vcb = Vcb;
                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

                if (!FlagOn( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY )) {

                    NtfsReleaseGlobal( IrpContext );

                    NtfsReleaseVcbCheckDelete( IrpContext,
                                               Vcb,
                                               IRP_MJ_CLOSE,
                                               NULL );

                    //
                    //  Only do one since we have lost our place in the Vcb list.
                    //

                    NtfsAcquireExclusiveGlobal( IrpContext, TRUE );

                    break;

                } else {

                    NtfsReleaseVcb( IrpContext, Vcb );
                }
            }
        }

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Make sure we own the global resource for mount.  We can only raise above
        //  in the DeleteVcb path when we don't hold the resource.
        //

        NtfsAcquireExclusiveGlobal( IrpContext, TRUE );
    }

    Vcb = NULL;

    try {

        PFILE_RECORD_SEGMENT_HEADER MftBuffer;
        PVOID Mft2Buffer;
        LONGLONG MftMirrorOverlap;

        //
        //  Create and init a new volume device object.
        //


        Status = NtfsInitializeDevice( IrpContext, Vpb, DeviceObjectWeTalkTo, &VcbAcquired, &VolDo );
        if (!NT_SUCCESS( Status )) {

            leave;
        }

        Vcb = IrpContext->Vcb;

        //
        //  Read in the Boot sector, or spare boot sector, on exit of this try
        //  body we will have set bootbcb and bootsector.
        //

        NtfsReadBootSector( IrpContext, Vcb, &BootScb, &BootBcb, (PVOID *)&BootSector );

        //
        //  Check if this is an NTFS volume
        //

        if (!NtfsIsBootSectorNtfs( BootSector, Vcb )) {

            DebugTrace( 0, Dbg, ("Not an NTFS volume\n") );
            Status = STATUS_UNRECOGNIZED_VOLUME;
            leave;
        }

        //
        //  Now that we have a real boot sector on a real NTFS volume we can
        //  really set the proper Vcb fields.
        //

        {
            BIOS_PARAMETER_BLOCK Bpb;

            NtfsUnpackBios( &Bpb, &BootSector->PackedBpb );

            Vcb->BytesPerSector = Bpb.BytesPerSector;
            Vcb->BytesPerCluster = Bpb.BytesPerSector * Bpb.SectorsPerCluster;
            Vcb->NumberSectors = BootSector->NumberSectors;
            Vcb->MftStartLcn = BootSector->MftStartLcn;
            Vcb->Mft2StartLcn = BootSector->Mft2StartLcn;

            Vcb->ClusterMask = Vcb->BytesPerCluster - 1;
            Vcb->InverseClusterMask = ~Vcb->ClusterMask;
            for (Vcb->ClusterShift = 0, i = Vcb->BytesPerCluster; i > 1; i = i / 2) {
                Vcb->ClusterShift += 1;
            }

            //
            //  If the cluster size is greater than the page size then set this value to 1.
            //

            Vcb->ClustersPerPage = PAGE_SIZE >> Vcb->ClusterShift;

            if (Vcb->ClustersPerPage == 0) {

                Vcb->ClustersPerPage = 1;
            }

            //
            //  File records can be smaller, equal or larger than the cluster size.  Initialize
            //  both ClustersPerFileRecordSegment and FileRecordsPerCluster.
            //
            //  If the value in the boot sector is positive then it signifies the
            //  clusters/structure.  If negative then it signifies the shift value
            //  to obtain the structure size.
            //

            if (BootSector->ClustersPerFileRecordSegment < 0) {

                Vcb->BytesPerFileRecordSegment = 1 << (-1 * BootSector->ClustersPerFileRecordSegment);

                //
                //  Initialize the other Mft/Cluster relationship numbers in the Vcb
                //  based on whether the clusters are larger or smaller than file
                //  records.
                //

                if (Vcb->BytesPerFileRecordSegment < Vcb->BytesPerCluster) {

                    Vcb->FileRecordsPerCluster = Vcb->BytesPerCluster / Vcb->BytesPerFileRecordSegment;

                } else {

                    Vcb->ClustersPerFileRecordSegment = Vcb->BytesPerFileRecordSegment / Vcb->BytesPerCluster;
                }

            } else {

                Vcb->BytesPerFileRecordSegment = BytesFromClusters( Vcb, BootSector->ClustersPerFileRecordSegment );
                Vcb->ClustersPerFileRecordSegment = BootSector->ClustersPerFileRecordSegment;
            }

            for (Vcb->MftShift = 0, i = Vcb->BytesPerFileRecordSegment; i > 1; i = i / 2) {
                Vcb->MftShift += 1;
            }

            //
            //  We want to shift between file records and clusters regardless of which is larger.
            //  Compute the shift value here.  Anyone using this value will have to know which
            //  way to shift.
            //

            Vcb->MftToClusterShift = Vcb->MftShift - Vcb->ClusterShift;

            if (Vcb->ClustersPerFileRecordSegment == 0) {

                Vcb->MftToClusterShift = Vcb->ClusterShift - Vcb->MftShift;
            }

            //
            //  Remember the clusters per view section and 4 gig.
            //

            Vcb->ClustersPer4Gig = (ULONG) LlClustersFromBytesTruncate( Vcb, 0x100000000 );

            //
            //  Compute the default index allocation buffer size.
            //

            if (BootSector->DefaultClustersPerIndexAllocationBuffer < 0) {

                Vcb->DefaultBytesPerIndexAllocationBuffer = 1 << (-1 * BootSector->DefaultClustersPerIndexAllocationBuffer);

                //
                //  Determine whether the index allocation buffer is larger/smaller
                //  than the cluster size to determine the block size.
                //

                if (Vcb->DefaultBytesPerIndexAllocationBuffer < Vcb->BytesPerCluster) {

                    Vcb->DefaultBlocksPerIndexAllocationBuffer = Vcb->DefaultBytesPerIndexAllocationBuffer / DEFAULT_INDEX_BLOCK_SIZE;

                } else {

                    Vcb->DefaultBlocksPerIndexAllocationBuffer = Vcb->DefaultBytesPerIndexAllocationBuffer / Vcb->BytesPerCluster;
                }

            } else {

                Vcb->DefaultBlocksPerIndexAllocationBuffer = BootSector->DefaultClustersPerIndexAllocationBuffer;
                Vcb->DefaultBytesPerIndexAllocationBuffer = BytesFromClusters( Vcb, Vcb->DefaultBlocksPerIndexAllocationBuffer );
            }

            //
            //  Now compute our volume specific constants that are stored in
            //  the Vcb.  The total number of clusters is:
            //
            //      (NumberSectors * BytesPerSector) / BytesPerCluster
            //

            Vcb->PreviousTotalClusters =
            Vcb->TotalClusters = LlClustersFromBytesTruncate( Vcb,
                                                              Vcb->NumberSectors * Vcb->BytesPerSector );

            //
            //  Compute the maximum clusters for a file.
            //

            Vcb->MaxClusterCount = LlClustersFromBytesTruncate( Vcb, MAXFILESIZE );

            //
            //  Compute the attribute flags mask for this volume for this volume.
            //

            Vcb->AttributeFlagsMask = 0xffff;

            if (Vcb->BytesPerCluster > 0x1000) {

                ClearFlag( Vcb->AttributeFlagsMask, ATTRIBUTE_FLAG_COMPRESSION_MASK );
            }

            //
            //  For now, an attribute is considered "moveable" if it is at
            //  least 5/16 of the file record.  This constant should only
            //  be changed i conjunction with the MAX_MOVEABLE_ATTRIBUTES
            //  constant.  (The product of the two should be a little less
            //  than or equal to 1.)
            //

            Vcb->BigEnoughToMove = Vcb->BytesPerFileRecordSegment * 5 / 16;

            //
            //  Set the serial number in the Vcb
            //

            Vcb->VolumeSerialNumber = BootSector->SerialNumber;
            Vpb->SerialNumber = ((ULONG)BootSector->SerialNumber);

            //
            //  Compute the sparse file values.
            //

            Vcb->SparseFileUnit = NTFS_SPARSE_FILE_UNIT;
            Vcb->SparseFileClusters = ClustersFromBytes( Vcb, Vcb->SparseFileUnit );

            //
            //  If this is the system boot partition, we need to remember to
            //  not allow this volume to be dismounted.
            //

            if (FlagOn( Vpb->RealDevice->Flags, DO_SYSTEM_BOOT_PARTITION )) {

                SetFlag( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT );
            }

            //
            //  We should never see the BOOT flag in the device we talk to unless it
            //  is in the real device.
            //

            ASSERT( !FlagOn( DeviceObjectWeTalkTo->Flags, DO_SYSTEM_BOOT_PARTITION ) ||
                    FlagOn( Vpb->RealDevice->Flags, DO_SYSTEM_BOOT_PARTITION ));
        }

        //
        //  Initialize recovery state.
        //

        NtfsInitializeRestartTable( sizeof( OPEN_ATTRIBUTE_ENTRY ),
                                    INITIAL_NUMBER_ATTRIBUTES,
                                    &Vcb->OpenAttributeTable );

        NtfsUpdateOatVersion( Vcb, NtfsDefaultRestartVersion );


        NtfsInitializeRestartTable( sizeof( TRANSACTION_ENTRY ),
                                    INITIAL_NUMBER_TRANSACTIONS,
                                    &Vcb->TransactionTable );

        //
        //  Now start preparing to restart the volume.
        //

        //
        //  Create the Mft and Log File Scbs and prepare to read them.
        //  The Mft and mirror length will be the first 4 file records or
        //  the first cluster.
        //

        FirstNonMirroredCluster = ClustersFromBytes( Vcb, 4 * Vcb->BytesPerFileRecordSegment );
        MirroredMftRange = 4 * Vcb->BytesPerFileRecordSegment;

        if (MirroredMftRange < Vcb->BytesPerCluster) {

            MirroredMftRange = Vcb->BytesPerCluster;
        }

        //
        //  Check the case where the boot sector has an invalid value for either the
        //  beginning of the Mft or the beginning of the Mft mirror.  Specifically
        //  check the they don't overlap.  Otherwise we can corrupt the valid one
        //  as we read and possibly try to correct the invalid one.
        //

        if (Vcb->MftStartLcn > Vcb->Mft2StartLcn) {

            MftMirrorOverlap = Vcb->MftStartLcn - Vcb->Mft2StartLcn;

        } else {

            MftMirrorOverlap = Vcb->Mft2StartLcn - Vcb->MftStartLcn;
        }

        MftMirrorOverlap = LlBytesFromClusters( Vcb, MftMirrorOverlap );

        //
        //  Don't raise corrupt since we don't want to attempt to write the
        //  disk in this state.  Someone who knows how will need to
        //  restore the correct boot sector.
        //

        if (MftMirrorOverlap < (LONGLONG) MirroredMftRange) {

            DebugTrace( 0, Dbg, ("Not an NTFS volume\n") );
            Status = STATUS_UNRECOGNIZED_VOLUME;
            leave;
        }

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->MftScb,
                            Vcb,
                            MASTER_FILE_TABLE_NUMBER,
                            MirroredMftRange,
                            $DATA,
                            TRUE );

        CcSetAdditionalCacheAttributes( Vcb->MftScb->FileObject, TRUE, TRUE );

        LlTemp1 = FirstNonMirroredCluster;

        (VOID)NtfsAddNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                   (LONGLONG)0,
                                   Vcb->MftStartLcn,
                                   (LONGLONG)FirstNonMirroredCluster,
                                   FALSE );

        //
        //  Now the same for Mft2
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->Mft2Scb,
                            Vcb,
                            MASTER_FILE_TABLE2_NUMBER,
                            MirroredMftRange,
                            $DATA,
                            TRUE );

        CcSetAdditionalCacheAttributes( Vcb->Mft2Scb->FileObject, TRUE, TRUE );


        (VOID)NtfsAddNtfsMcbEntry( &Vcb->Mft2Scb->Mcb,
                                   (LONGLONG)0,
                                   Vcb->Mft2StartLcn,
                                   (LONGLONG)FirstNonMirroredCluster,
                                   FALSE );

        //
        //  Create the dasd system file, we do it here because we need to dummy
        //  up the mcb for it, and that way everything else in NTFS won't need
        //  to know that it is a special file.  We need to do this after
        //  cluster allocation initialization because that computes the total
        //  clusters on the volume.  Also for verification purposes we will
        //  set and get the times off of the volume.
        //
        //  Open it now before the Log File, because that is the first time
        //  anyone may want to mark the volume corrupt.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->VolumeDasdScb,
                            Vcb,
                            VOLUME_DASD_NUMBER,
                            LlBytesFromClusters( Vcb, Vcb->TotalClusters ),
                            $DATA,
                            FALSE );

        (VOID)NtfsAddNtfsMcbEntry( &Vcb->VolumeDasdScb->Mcb,
                                   (LONGLONG)0,
                                   (LONGLONG)0,
                                   Vcb->TotalClusters,
                                   FALSE );

        SetFlag( Vcb->VolumeDasdScb->Fcb->FcbState, FCB_STATE_DUP_INITIALIZED );

        Vcb->VolumeDasdScb->Fcb->LinkCount =
        Vcb->VolumeDasdScb->Fcb->TotalLinks = 1;

        //
        //  We want to read the first four record segments of each of these
        //  files.  We do this so that we don't have a cache miss when we
        //  look up the real allocation below.
        //

        for (i = 0; i < 4; i++) {

            FILE_REFERENCE FileReference;
            BOOLEAN ValidRecord;
            ULONG CorruptHint;

            NtfsSetSegmentNumber( &FileReference, 0, i );
            if (i > 0) {
                FileReference.SequenceNumber = (USHORT)i;
            } else {
                FileReference.SequenceNumber = 1;
            }

            NtfsReadMftRecord( IrpContext,
                               Vcb,
                               &FileReference,
                               FALSE,
                               &Bcbs[i*2],
                               &MftBuffer,
                               NULL );

            NtfsMapStream( IrpContext,
                           Vcb->Mft2Scb,
                           (LONGLONG)(i * Vcb->BytesPerFileRecordSegment),
                           Vcb->BytesPerFileRecordSegment,
                           &Bcbs[i*2 + 1],
                           &Mft2Buffer );

            //
            //  First validate the record and if its valid and record 0
            //  do an extra check for whether its the mft.
            //

            ValidRecord = NtfsCheckFileRecord( Vcb, MftBuffer, &FileReference, &CorruptHint );
            if (ValidRecord && (i == 0)) {

                ATTRIBUTE_ENUMERATION_CONTEXT Context;

                NtfsInitializeAttributeContext( &Context );

                try {

                    if (!NtfsLookupAttributeByCode( IrpContext, Vcb->MftScb->Fcb, &Vcb->MftScb->Fcb->FileReference, $ATTRIBUTE_LIST, &Context )) {

                        if (NtfsLookupAttributeByCode( IrpContext, Vcb->MftScb->Fcb, &Vcb->MftScb->Fcb->FileReference, $FILE_NAME, &Context )) {

                            PFILE_NAME FileName;

                            FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ) );
                            if ((FileName->FileNameLength != wcslen( L"MFT" )) ||
                                (!RtlEqualMemory( FileName->FileName, L"$MFT", FileName->FileNameLength * sizeof( WCHAR )))) {

                                ValidRecord = FALSE;
                            }
                        }
                    }

                } finally {
                    NtfsCleanupAttributeContext( IrpContext, &Context );
                }
            }

            //
            //  If any of these file records are bad then try the mirror
            //  (unless we are already looking at the mirror).  If we
            //  can't find a valid record then fail the mount.
            //

            if (!ValidRecord) {

                if ((MftBuffer != Mft2Buffer) &&
                    NtfsCheckFileRecord( Vcb, Mft2Buffer, &FileReference, &CorruptHint ) &&
                    !NtfsIsVolumeReadOnly( Vcb )) {

                    LlTemp1 = MAXLONGLONG;

                    //
                    //  Put a BaadSignature in this file record,
                    //  mark it dirty and then read it again.
                    //  The baad signature should force us to bring
                    //  in the mirror and we can correct the problem.
                    //

                    NtfsPinMappedData( IrpContext,
                                       Vcb->MftScb,
                                       i * Vcb->BytesPerFileRecordSegment,
                                       Vcb->BytesPerFileRecordSegment,
                                       &Bcbs[i*2] );

                    RtlCopyMemory( MftBuffer, Mft2Buffer, Vcb->BytesPerFileRecordSegment );

                    CcSetDirtyPinnedData( Bcbs[i*2], (PLARGE_INTEGER) &LlTemp1 );

                } else {

                    NtfsMarkVolumeDirty( IrpContext, Vcb );
                    Status = STATUS_DISK_CORRUPT_ERROR;
                    leave;
                }
            }
        }

        //
        //  The last file record was the Volume Dasd, so check the version number.
        //

        Attribute = NtfsFirstAttribute(MftBuffer);

        while (TRUE) {

            Attribute = NtfsGetNextRecord(Attribute);

            if (Attribute->TypeCode == $VOLUME_INFORMATION) {

                PVOLUME_INFORMATION VolumeInformation;

                VolumeInformation = (PVOLUME_INFORMATION)NtfsAttributeValue(Attribute);
                VolumeFlags = VolumeInformation->VolumeFlags;

                //
                //  Upgrading the disk on NT 5.0 will use version number 3.0.  Version
                //  number 2.0 was used temporarily when the upgrade was automatic.
                //
                //  NOTE - We use the presence of the version number to indicate
                //  that the first four file records have been validated.  We won't
                //  flush the MftMirror if we can't verify these records.  Otherwise
                //  we might corrupt a valid mirror.
                //

                Vcb->MajorVersion = VolumeInformation->MajorVersion;
                Vcb->MinorVersion = VolumeInformation->MinorVersion;

                if ((Vcb->MajorVersion < 1) || (Vcb->MajorVersion > 3)) {

                    NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
                }

                if (Vcb->MajorVersion > 1) {

                    CurrentVersion = TRUE;

                    ASSERT( (VolumeInformation->MajorVersion != 2) ||
                            !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED ) );

                    if (NtfsDefragMftEnabled) {

                        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
                    }
                }

                break;

            }

            if (Attribute->TypeCode == $END) {

                NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
            }
        }

        //
        //  Create the log file Scb and really look up its size.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->LogFileScb,
                            Vcb,
                            LOG_FILE_NUMBER,
                            0,
                            $DATA,
                            TRUE );

        Vcb->LogFileObject = Vcb->LogFileScb->FileObject;

        CcSetAdditionalCacheAttributes( Vcb->LogFileScb->FileObject, TRUE, TRUE );

        //
        //  Lookup the log file mapping now, since we will not go to the
        //  disk for allocation information any more once we set restart
        //  in progress.
        //

        (VOID)NtfsPreloadAllocation( IrpContext, Vcb->LogFileScb, 0, MAXLONGLONG );

        //
        //  Now we have to unpin everything before restart, because it generally
        //  has to uninitialize everything.
        //

        NtfsUnpinBcb( IrpContext, &BootBcb );

        for (i = 0; i < 8; i++) {
            NtfsUnpinBcb( IrpContext, &Bcbs[i] );
        }

        NtfsPurgeFileRecordCache( IrpContext );

        //
        //  Purge the Mft, since we only read the first four file
        //  records, not necessarily an entire page!
        //

        CcPurgeCacheSection( &Vcb->MftScb->NonpagedScb->SegmentObject, NULL, 0, FALSE );

        //
        //  Now start up the log file and perform Restart.  This calls will
        //  unpin and remap the Mft Bcb's.  The MftBuffer variables above
        //  may no longer point to the correct range of bytes.  This is OK
        //  if they are never referenced.
        //
        //  Put a try-except around this to catch any restart failures.
        //  This is important in order to allow us to limp along until
        //  autochk gets a chance to run.
        //
        //  We set restart in progress first, to prevent us from looking up any
        //  more run information (now that we know where the log file is!)
        //

        SetFlag( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS );

        //
        //  See if we are in the retry process due to an earlier failure
        //  in processing the restart area
        //

        RetryRestart = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_BAD_RESTART );

        if (RetryRestart) {

            //
            //  Pass the bad restart info further down the chain
            //  and mark the volume dirty.
            //  We mark the volume dirty on retry because the
            //  dirty bit will not get flush to the disk thru
            //  NtfsRaiseStatus.  Also LFS calls ExRaiseStatus
            //  directly.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_BAD_RESTART );
            NtfsMarkVolumeDirty( IrpContext, Vcb );
        }

        try {

            Status = STATUS_SUCCESS;
            UnrecognizedRestart = FALSE;

            NtfsStartLogFile( Vcb->LogFileScb,
                              Vcb );

            //
            //  We call the cache manager again with the stream files for the Mft and
            //  Mft mirror as we didn't have a log handle for the first call.
            //

            CcSetLogHandleForFile( Vcb->MftScb->FileObject,
                                   Vcb->LogHandle,
                                   &LfsFlushToLsn );

            CcSetLogHandleForFile( Vcb->Mft2Scb->FileObject,
                                   Vcb->LogHandle,
                                   &LfsFlushToLsn );

            CloseAttributes = TRUE;

            if (!NtfsIsVolumeReadOnly( Vcb )) {

                UpdatesApplied = NtfsRestartVolume( IrpContext, Vcb, &UnrecognizedRestart );
            }

        //
        //  For right now, we will charge ahead with a dirty volume, no
        //  matter what the exception was.  Later we will have to be
        //  defensive and use a filter.
        //

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            Status = GetExceptionCode();

            if ((Status == STATUS_DISK_CORRUPT_ERROR) ||
                (Status == STATUS_FILE_CORRUPT_ERROR)) {

                //
                //  If this is the first time we hit this error during restart,
                //  we will remember it in the irp context so that we can retry
                //  from the top by raising STATUS_CANT_WAIT.
                //

                if (!RetryRestart) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_BAD_RESTART );
                    NtfsFailedLfsRestart++;
                }
            }

            //
            //  If the error is STATUS_LOG_FILE_FULL then it means that
            //  we couldn't complete the restart.  Mark the volume dirty in
            //  this case.  Don't return this error code.
            //

            if (Status == STATUS_LOG_FILE_FULL) {

                Status = STATUS_DISK_CORRUPT_ERROR;
                IrpContext->ExceptionStatus = STATUS_DISK_CORRUPT_ERROR;
            }
        }

        //
        //  If we hit a corruption exception while processing the
        //  logfile, we need to retry and avoid those errors.
        //

        if (!RetryRestart &&
            FlagOn( IrpContext->State, IRP_CONTEXT_STATE_BAD_RESTART )) {

            IrpContext->ExceptionStatus = STATUS_CANT_WAIT;
            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If we hit an error trying to mount this as a readonly volume,
        //  fail the mount. We don't want to do any writes.
        //

        if (Status == STATUS_MEDIA_WRITE_PROTECTED) {

            ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY ) );
            ClearFlag( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY );
            leave;
        }

        //
        //  Mark the volume dirty if we hit an error during restart or if we didn't
        //  recognize the restart area.  In that case also mark the volume dirty but
        //  continue to run.
        //

        if (!NT_SUCCESS( Status ) || UnrecognizedRestart) {

            LONGLONG VolumeDasdOffset;

            NtfsSetAndGetVolumeTimes( IrpContext, Vcb, TRUE );

            //
            //  Now flush it out, so chkdsk can see it with Dasd.
            //  Clear the error in the IrpContext so that this
            //  flush will succeed.  Otherwise CommonWrite will
            //  return FILE_LOCK_CONFLICT.
            //

            IrpContext->ExceptionStatus = STATUS_SUCCESS;

            VolumeDasdOffset = VOLUME_DASD_NUMBER << Vcb->MftShift;

            CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                          (PLARGE_INTEGER)&VolumeDasdOffset,
                          Vcb->BytesPerFileRecordSegment,
                          NULL );

            if (!NT_SUCCESS( Status )) {

                leave;
            }
        }

        //
        //  Now flush the Mft copies, because we are going to shut the real
        //  one down and reopen it for real.
        //

        CcFlushCache( &Vcb->Mft2Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

        if (NT_SUCCESS( IoStatus.Status )) {
            CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );
        }

        NtfsCleanupTransaction( IrpContext, IoStatus.Status, TRUE );

        //
        //  Show that the restart is complete, and it is safe to go to
        //  the disk for the Mft allocation.
        //

        ClearFlag( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS );

        //
        //  Set the Mft sizes back down to the part which is guaranteed to
        //  be contiguous for now.  Important on large page size systems!
        //

        Vcb->MftScb->Header.AllocationSize.QuadPart =
        Vcb->MftScb->Header.FileSize.QuadPart =
        Vcb->MftScb->Header.ValidDataLength.QuadPart = FirstNonMirroredCluster << Vcb->ClusterShift;

        //
        //  Pin the first four file records.  We need to lock the pages to
        //  absolutely guarantee they stay in memory, otherwise we may
        //  generate a recursive page fault, forcing MM to block.
        //

        for (i = 0; i < 4; i++) {

            FILE_REFERENCE FileReference;
            ULONG CorruptHint;

            NtfsSetSegmentNumber( &FileReference, 0, i );
            if (i > 0) {
                FileReference.SequenceNumber = (USHORT)i;
            } else {
                FileReference.SequenceNumber = 1;
            }

            NtfsPinStream( IrpContext,
                           Vcb->MftScb,
                           (LONGLONG)(i << Vcb->MftShift),
                           Vcb->BytesPerFileRecordSegment,
                           &Bcbs[i*2],
                           (PVOID *)&MftBuffer );

            Mdls[i*2] = IoAllocateMdl( MftBuffer,
                                       Vcb->BytesPerFileRecordSegment,
                                       FALSE,
                                       FALSE,
                                       NULL );

            //
            //  Verify that we got an Mdl.
            //

            if (Mdls[i*2] == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            MmProbeAndLockPages( Mdls[i*2], KernelMode, IoReadAccess );

            NtfsPinStream( IrpContext,
                           Vcb->Mft2Scb,
                           (LONGLONG)(i << Vcb->MftShift),
                           Vcb->BytesPerFileRecordSegment,
                           &Bcbs[i*2 + 1],
                           &Mft2Buffer );

            Mdls[i*2 + 1] = IoAllocateMdl( Mft2Buffer,
                                           Vcb->BytesPerFileRecordSegment,
                                           FALSE,
                                           FALSE,
                                           NULL );

            //
            //  Verify that we got an Mdl.
            //

            if (Mdls[i*2 + 1] == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            MmProbeAndLockPages( Mdls[i*2 + 1], KernelMode, IoReadAccess );

            //
            //  If any of these file records are bad then try the mirror
            //  (unless we are already looking at the mirror).  If we
            //  can't find a valid record then fail the mount.
            //

            if (!NtfsCheckFileRecord( Vcb, MftBuffer, &FileReference, &CorruptHint )) {

                if ((MftBuffer != Mft2Buffer) &&
                    NtfsCheckFileRecord( Vcb, Mft2Buffer, &FileReference, &CorruptHint )) {

                    LlTemp1 = MAXLONGLONG;

                    //
                    //  Put a BaadSignature in this file record,
                    //  mark it dirty and then read it again.
                    //  The baad signature should force us to bring
                    //  in the mirror and we can correct the problem.
                    //

                    RtlCopyMemory( MftBuffer, Mft2Buffer, Vcb->BytesPerFileRecordSegment );
                    CcSetDirtyPinnedData( Bcbs[i*2], (PLARGE_INTEGER) &LlTemp1 );

                } else {

                    NtfsMarkVolumeDirty( IrpContext, Vcb );
                    Status = STATUS_DISK_CORRUPT_ERROR;
                    leave;
                }
            }
        }

        //
        //  Now we need to uninitialize and purge the Mft and Mft2.  This is
        //  because we could have only a partially filled page at the end, and
        //  we need to do real reads of whole pages now.
        //

        //
        //  Uninitialize and reinitialize the large mcbs so that we can reload
        //  it from the File Record.
        //

        NtfsUnloadNtfsMcbRange( &Vcb->MftScb->Mcb, (LONGLONG) 0, MAXLONGLONG, TRUE, FALSE );
        NtfsUnloadNtfsMcbRange( &Vcb->Mft2Scb->Mcb, (LONGLONG) 0, MAXLONGLONG, TRUE, FALSE );

        //
        //  Mark both of them as uninitialized.
        //

        ClearFlag( Vcb->MftScb->ScbState, SCB_STATE_FILE_SIZE_LOADED );
        ClearFlag( Vcb->Mft2Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED );

        //
        //  We need to deal with a rare case where the Scb for a non-resident attribute
        //  list for the Mft has been created but the size is not correct.  This could
        //  happen if we logged part of the stream but not the whole stream.  In that
        //  case we really want to load the correct numbers into the Scb.  We will need the
        //  full attribute list if we are to look up the allocation for the Mft
        //  immediately after this.
        //

        MftLinks = Vcb->MftScb->Fcb->ScbQueue.Flink;

        while (MftLinks != &Vcb->MftScb->Fcb->ScbQueue) {

            AttributeListScb = CONTAINING_RECORD( MftLinks,
                                                  SCB,
                                                  FcbLinks );

            if (AttributeListScb->AttributeTypeCode == $ATTRIBUTE_LIST) {

                //
                //  Clear the flags so we can reload the information from disk.
                //  Also unload the allocation.  If we have a log record for a
                //  change to the attribute list for the Mft then the allocation
                //  may only be partially loaded.  Looking up the allocation for the
                //  Mft below could easily hit one of the holes.  This way we will
                //  reload all of the allocation.
                //

                NtfsUnloadNtfsMcbRange( &AttributeListScb->Mcb, 0, MAXLONGLONG, TRUE, FALSE );
                ClearFlag( AttributeListScb->ScbState, SCB_STATE_FILE_SIZE_LOADED | SCB_STATE_HEADER_INITIALIZED );
                NtfsUpdateScbFromAttribute( IrpContext, AttributeListScb, NULL );

                //
                //  Let the cache manager know the sizes if this is cached.
                //

                if (AttributeListScb->FileObject != NULL) {

                    CcSetFileSizes( AttributeListScb->FileObject,
                                    (PCC_FILE_SIZES) &AttributeListScb->Header.AllocationSize );
                }

                break;
            }

            MftLinks = MftLinks->Flink;
        }

        //
        //  Now load up the real allocation from just the first file record.
        //

        if (Vcb->FileRecordsPerCluster == 0) {

            NtfsPreloadAllocation( IrpContext,
                                   Vcb->MftScb,
                                   0,
                                   (FIRST_USER_FILE_NUMBER - 1) << Vcb->MftToClusterShift );

        } else {

            NtfsPreloadAllocation( IrpContext,
                                   Vcb->MftScb,
                                   0,
                                   (FIRST_USER_FILE_NUMBER - 1) >> Vcb->MftToClusterShift );
        }

        NtfsPreloadAllocation( IrpContext, Vcb->Mft2Scb, 0, MAXLONGLONG );

        //
        //  We update the Mft and the Mft mirror before we delete the current
        //  stream file for the Mft.  We know we can read the true attributes
        //  for the Mft and the Mirror because we initialized their sizes
        //  above through the first few records in the Mft.
        //

        NtfsUpdateScbFromAttribute( IrpContext, Vcb->MftScb, NULL );

        //
        //  We will attempt to upgrade the version only if this isn't already
        //  a version 2 or 3 volume, the upgrade bit is set, and we aren't
        //  retrying the mount because the upgrade failed last time.
        //  We will always upgrade a new volume
        //

        if ((Vcb->MajorVersion == 1) &&
            !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED ) &&
           (NtfsForceUpgrade ?
            (!FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_UPGRADE ) ||
             (Vcb->MftScb->Header.FileSize.QuadPart <= FIRST_USER_FILE_NUMBER * Vcb->BytesPerFileRecordSegment))
                                                                        :
            FlagOn( VolumeFlags, VOLUME_UPGRADE_ON_MOUNT ))) {

            //
            //  We can't upgrade R/O volumes, so we can't proceed either.
            //

            if (NtfsIsVolumeReadOnly( Vcb )) {

                Status = STATUS_MEDIA_WRITE_PROTECTED;
                leave;
            }

            UpgradeVolume = TRUE;
        }

        ClearFlag( Vcb->MftScb->ScbState, SCB_STATE_WRITE_COMPRESSED );
        ClearFlag( Vcb->MftScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

        if (!FlagOn( Vcb->MftScb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            Vcb->MftScb->CompressionUnit = 0;
            Vcb->MftScb->CompressionUnitShift = 0;
        }

        NtfsUpdateScbFromAttribute( IrpContext, Vcb->Mft2Scb, NULL );
        ClearFlag( Vcb->Mft2Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
        ClearFlag( Vcb->Mft2Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

        if (!FlagOn( Vcb->Mft2Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            Vcb->Mft2Scb->CompressionUnit = 0;
            Vcb->Mft2Scb->CompressionUnitShift = 0;
        }

        //
        //  Unpin the Bcb's for the Mft files before uninitializing.
        //

        for (i = 0; i < 8; i++) {

            NtfsUnpinBcb( IrpContext, &Bcbs[i] );

            //
            //  Now we can get rid of these Mdls.
            //

            MmUnlockPages( Mdls[i] );
            IoFreeMdl( Mdls[i] );
            Mdls[i] = NULL;
        }

        //
        //  Before we call CcSetAdditionalCacheAttributes to disable write behind,
        //  we need to flush what we can now.
        //

        CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

        //
        //  Now close and purge the Mft, and recreate its stream so that
        //  the Mft is in a normal state, and we can close the rest of
        //  the attributes from restart.  We need to bump the close count
        //  to keep the scb around while we do this little bit of trickery
        //

        {
            Vcb->MftScb->CloseCount += 1;

            NtfsPurgeFileRecordCache( IrpContext );

            NtfsDeleteInternalAttributeStream( Vcb->MftScb, TRUE, FALSE );

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Vcb->MftScb,
                                               FALSE,
                                               &NtfsSystemFiles[MASTER_FILE_TABLE_NUMBER] );

            //
            //  Tell the cache manager the file sizes for the MFT.  It is possible
            //  that the shared cache map did not go away on the DeleteInternalAttributeStream
            //  call above.  In that case the Cache Manager has the file sizes from
            //  restart.
            //

            CcSetFileSizes( Vcb->MftScb->FileObject,
                            (PCC_FILE_SIZES) &Vcb->MftScb->Header.AllocationSize );

            CcSetAdditionalCacheAttributes( Vcb->MftScb->FileObject, TRUE, FALSE );

            Vcb->MftScb->CloseCount -= 1;
        }

        //
        //  We want to read all of the file records for the Mft to put
        //  its complete mapping into the Mcb.
        //

        SetFlag( Vcb->VcbState, VCB_STATE_PRELOAD_MFT );
        NtfsPreloadAllocation( IrpContext, Vcb->MftScb, 0, MAXLONGLONG );
        ClearFlag( Vcb->VcbState, VCB_STATE_PRELOAD_MFT );

        //
        //  Close the boot file (get rid of it because we do not know its proper
        //  size, and the Scb may be inconsistent).
        //

        NtfsDeleteInternalAttributeStream( BootScb, TRUE, FALSE );
        BootScb = NULL;

        //
        //  Closing the attributes from restart has to occur here after
        //  the Mft is clean, because flushing these files will cause
        //  file size updates to occur, etc.
        //

        Status = NtfsCloseAttributesFromRestart( IrpContext, Vcb );
        CloseAttributes = FALSE;

        if (!NT_SUCCESS( Status )) {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        //
        //  The CHECKPOINT flags function the same way whether the volume is mounted
        //  read-only or not. We just ignore the actual checkpointing process.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        //
        //  Show that it is ok to checkpoint now.
        //

        ClearFlag( Vcb->CheckpointFlags,
                   VCB_CHECKPOINT_SYNC_FLAGS |
                   VCB_LAST_CHECKPOINT_CLEAN |
                   VCB_LAST_CHECKPOINT_PSEUDO_CLEAN );

        //
        //  Clear the flag indicating that we won't defrag the volume.
        //

        ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );

        NtfsSetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        //
        //  We always need to write a checkpoint record so that we have
        //  a checkpoint on the disk before we modify any files.
        //

#ifdef PERF_STATS
        IrpContext->LogFullReason = LF_MOUNT;
#endif

        NtfsCheckpointVolume( IrpContext,
                              Vcb,
                              FALSE,
                              UpdatesApplied,
                              UpdatesApplied,
                              0,
                              Vcb->LastRestartArea );

        //
        //  Now set the defrag enabled flag.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

/*      Format is using wrong attribute definitions

        //
        //  At this point we are ready to use the volume normally.  We could
        //  open the remaining system files by name, but for now we will go
        //  ahead and open them by file number.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->AttributeDefTableScb,
                            Vcb,
                            ATTRIBUTE_DEF_TABLE_NUMBER,
                            0,
                            $DATA,
                            FALSE );

        //
        //  Read in the attribute definitions.
        //

        {
            PSCB Scb = Vcb->AttributeDefTableScb;

            if ((Scb->Header.FileSize.HighPart != 0) || (Scb->Header.FileSize.LowPart == 0)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            Vcb->AttributeDefinitions = NtfsAllocatePool(PagedPool, Scb->Header.FileSize.LowPart );

            CcCopyRead( Scb->FileObject,
                        &Li0,
                        Scb->Header.FileSize.LowPart,
                        TRUE,
                        Vcb->AttributeDefinitions,
                        &IoStatus );

            if (!NT_SUCCESS(IoStatus.Status)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }
        }
*/
        //
        //  Just point to our own attribute definitions for now.
        //

        Vcb->AttributeDefinitions = NtfsAttributeDefinitions;

        //
        //  Open the upcase table.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->UpcaseTableScb,
                            Vcb,
                            UPCASE_TABLE_NUMBER,
                            0,
                            $DATA,
                            FALSE );

        //
        //  Read in the upcase table.
        //

        {
            PSCB Scb = Vcb->UpcaseTableScb;

            if ((Scb->Header.FileSize.HighPart != 0) || (Scb->Header.FileSize.LowPart < 512)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            Vcb->UpcaseTable = NtfsAllocatePool(PagedPool, Scb->Header.FileSize.LowPart );
            Vcb->UpcaseTableSize = Scb->Header.FileSize.LowPart / sizeof( WCHAR );

            CcCopyRead( Scb->FileObject,
                        &Li0,
                        Scb->Header.FileSize.LowPart,
                        TRUE,
                        Vcb->UpcaseTable,
                        &IoStatus );

            if (!NT_SUCCESS( IoStatus.Status )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  If we do not have a global upcase table yet then make this one the global one
            //

            if (NtfsData.UpcaseTable == NULL) {

                NtfsData.UpcaseTable = Vcb->UpcaseTable;
                NtfsData.UpcaseTableSize = Vcb->UpcaseTableSize;

            //
            //  Otherwise if this one perfectly matches the global upcase table then throw
            //  this one back and use the global one
            //

            } else if ((NtfsData.UpcaseTableSize == Vcb->UpcaseTableSize)

                            &&

                       (RtlCompareMemory( NtfsData.UpcaseTable,
                                          Vcb->UpcaseTable,
                                          Vcb->UpcaseTableSize) == Vcb->UpcaseTableSize)) {

                NtfsFreePool( Vcb->UpcaseTable );
                Vcb->UpcaseTable = NtfsData.UpcaseTable;
            }
        }

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->BitmapScb,
                            Vcb,
                            BIT_MAP_FILE_NUMBER,
                            0,
                            $DATA,
                            TRUE );

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->BadClusterFileScb,
                            Vcb,
                            BAD_CLUSTER_FILE_NUMBER,
                            0,
                            $DATA,
                            TRUE );

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->MftBitmapScb,
                            Vcb,
                            MASTER_FILE_TABLE_NUMBER,
                            0,
                            $BITMAP,
                            TRUE );

        //
        //  Initialize the bitmap support
        //

        NtfsInitializeClusterAllocation( IrpContext, Vcb );

        NtfsSetAndGetVolumeTimes( IrpContext, Vcb, FALSE );

        //
        //  Initialize the Mft record allocation
        //

        {
            ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
            BOOLEAN FoundAttribute;
            ULONG ExtendGranularity;

            //
            //  Lookup the bitmap allocation for the Mft file.
            //

            NtfsInitializeAttributeContext( &AttrContext );

            //
            //  Use a try finally to cleanup the attribute context.
            //

            try {

                //
                //  CODENOTE    Is the Mft Fcb fully initialized at this point??
                //

                FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                            Vcb->MftScb->Fcb,
                                                            &Vcb->MftScb->Fcb->FileReference,
                                                            $BITMAP,
                                                            &AttrContext );
                //
                //  Error if we don't find the bitmap
                //

                if (!FoundAttribute) {

                    DebugTrace( 0, 0, ("Couldn't find bitmap attribute for Mft\n") );

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  If there is no file object for the Mft Scb, we create it now.
                //

                if (Vcb->MftScb->FileObject == NULL) {

                    NtfsCreateInternalAttributeStream( IrpContext, Vcb->MftScb, TRUE, NULL );
                }

                //
                //  TEMPCODE    We need a better way to determine the optimal
                //              truncate and extend granularity.
                //

                ExtendGranularity = MFT_EXTEND_GRANULARITY;

                if ((ExtendGranularity * Vcb->BytesPerFileRecordSegment) < Vcb->BytesPerCluster) {

                    ExtendGranularity = Vcb->FileRecordsPerCluster;
                }

                NtfsInitializeRecordAllocation( IrpContext,
                                                Vcb->MftScb,
                                                &AttrContext,
                                                Vcb->BytesPerFileRecordSegment,
                                                ExtendGranularity,
                                                ExtendGranularity,
                                                &Vcb->MftScb->ScbType.Index.RecordAllocationContext );

            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }
        }

        //
        //  Get the serial number and volume label for the volume
        //

        NtfsGetVolumeInformation( IrpContext, Vpb, Vcb, &VolumeFlags );

        //
        //  Get the Device Name for this volume.
        //

        Status = ObQueryNameString( Vpb->RealDevice,
                                    NULL,
                                    0,
                                    &DeviceObjectNameLength );

        ASSERT( Status != STATUS_SUCCESS );

        //
        //  Unlike the rest of the system, ObQueryNameString returns
        //  STATUS_INFO_LENGTH_MISMATCH instead of STATUS_BUFFER_TOO_SMALL when
        //  passed too small a buffer.
        //
        //  We expect to get this error here.  Anything else we can't handle.
        //

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            DeviceObjectName = NtfsAllocatePool( PagedPool, DeviceObjectNameLength );

            Status = ObQueryNameString( Vpb->RealDevice,
                                        DeviceObjectName,
                                        DeviceObjectNameLength,
                                        &DeviceObjectNameLength );
        }

        if (!NT_SUCCESS( Status )) {

            leave;
        }

        //
        //  Now that we are successfully mounting, let us see if we should
        //  enable balanced reads.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY )) {

            FsRtlBalanceReads( DeviceObjectWeTalkTo );
        }

        ASSERT( DeviceObjectName->Name.Length != 0 );

        Vcb->DeviceName.MaximumLength =
        Vcb->DeviceName.Length = DeviceObjectName->Name.Length;

        Vcb->DeviceName.Buffer = NtfsAllocatePool( PagedPool, DeviceObjectName->Name.Length );

        RtlCopyMemory( Vcb->DeviceName.Buffer,
                       DeviceObjectName->Name.Buffer,
                       DeviceObjectName->Name.Length );

        //
        //  Now we want to initialize the remaining defrag status values.
        //

        Vcb->MftHoleGranularity = MFT_HOLE_GRANULARITY;
        Vcb->MftClustersPerHole = Vcb->MftHoleGranularity << Vcb->MftToClusterShift;

        if (MFT_HOLE_GRANULARITY < Vcb->FileRecordsPerCluster) {

            Vcb->MftHoleGranularity = Vcb->FileRecordsPerCluster;
            Vcb->MftClustersPerHole = 1;
        }

        Vcb->MftHoleMask = Vcb->MftHoleGranularity - 1;
        Vcb->MftHoleInverseMask = ~(Vcb->MftHoleMask);

        Vcb->MftHoleClusterMask = Vcb->MftClustersPerHole - 1;
        Vcb->MftHoleClusterInverseMask = ~(Vcb->MftHoleClusterMask);

        //
        //  Our maximum reserved Mft space is 0x140, we will try to
        //  get an extra 40 bytes if possible.
        //

        Vcb->MftReserved = Vcb->BytesPerFileRecordSegment / 8;

        if (Vcb->MftReserved > 0x140) {

            Vcb->MftReserved = 0x140;
        }

        Vcb->MftCushion = Vcb->MftReserved - 0x20;

        NtfsScanMftBitmap( IrpContext, Vcb );

#ifdef NTFS_CHECK_BITMAP
        {
            ULONG BitmapSize;
            ULONG Count;

            BitmapSize = Vcb->BitmapScb->Header.FileSize.LowPart;

            //
            //  Allocate a buffer for the bitmap copy and each individual bitmap.
            //

            Vcb->BitmapPages = (BitmapSize + PAGE_SIZE - 1) / PAGE_SIZE;

            Vcb->BitmapCopy = NtfsAllocatePool(PagedPool, Vcb->BitmapPages * sizeof( RTL_BITMAP ));
            RtlZeroMemory( Vcb->BitmapCopy, Vcb->BitmapPages * sizeof( RTL_BITMAP ));

            //
            //  Now get a buffer for each page.
            //

            for (Count = 0; Count < Vcb->BitmapPages; Count += 1) {

                (Vcb->BitmapCopy + Count)->Buffer = NtfsAllocatePool(PagedPool, PAGE_SIZE );
                RtlInitializeBitMap( Vcb->BitmapCopy + Count, (Vcb->BitmapCopy + Count)->Buffer, PAGE_SIZE * 8 );
            }

            if (NtfsCopyBitmap) {

                PUCHAR NextPage;
                PBCB BitmapBcb = NULL;
                ULONG BytesToCopy;
                LONGLONG FileOffset = 0;

                Count = 0;

                while (BitmapSize) {

                    BytesToCopy = PAGE_SIZE;

                    if (BytesToCopy > BitmapSize) {

                        BytesToCopy = BitmapSize;
                    }

                    NtfsUnpinBcb( IrpContext, &BitmapBcb );

                    NtfsMapStream( IrpContext, Vcb->BitmapScb, FileOffset, BytesToCopy, &BitmapBcb, &NextPage );

                    RtlCopyMemory( (Vcb->BitmapCopy + Count)->Buffer,
                                   NextPage,
                                   BytesToCopy );

                    BitmapSize -= BytesToCopy;
                    FileOffset += BytesToCopy;
                    Count += 1;
                }

                NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Otherwise we will want to scan the entire Mft and compare the mapping pairs
            //  with the current volume bitmap.
            //

            }
        }
#endif

        //
        //  Whether this was already an upgraded volume or we want it to
        //  be one now, we need to open all the new indices.
        //

        if ((CurrentVersion || UpgradeVolume) &&
            !SkipNtOfs) {

            BOOLEAN UpdatedVolumeVersion = FALSE;

            try {

                //
                //  Open the Root Directory.
                //

                NtfsOpenRootDirectory( IrpContext, Vcb );

                //
                //  Create/open the security file and initialize security on the volume.
                //

                NtfsInitializeSecurityFile( IrpContext, Vcb );

                //
                //  Create/open the $Extend directory.
                //

                NtfsInitializeExtendDirectory( IrpContext, Vcb );

                //
                //  Create/open the Quota File and initialize quotas.
                //

                NtfsInitializeQuotaFile( IrpContext, Vcb );

                //
                //  Create/open the Object Id File and initialize object ids.
                //

                NtfsInitializeObjectIdFile( IrpContext, Vcb );

                //
                //  Create/open the Mount Points File and initialize it.
                //

                NtfsInitializeReparseFile( IrpContext, Vcb );

                //
                //  Open the Usn Journal only if it is there.  If the volume was mounted
                //  on a 4.0 system then we want to restamp the journal.  Skip the
                //  initialization if the volume flags indicate that the journal
                //  delete has started.
                //  No USN journal if we're mounting Read Only.
                //

                if (FlagOn( VolumeFlags, VOLUME_DELETE_USN_UNDERWAY )) {

                    SetFlag( Vcb->VcbState, VCB_STATE_USN_DELETE );

                } else if (!NtfsIsVolumeReadOnly( Vcb )) {

                    NtfsInitializeUsnJournal( IrpContext,
                                              Vcb,
                                              FALSE,
                                              FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 ),
                                              (PCREATE_USN_JOURNAL_DATA) &Vcb->UsnJournalInstance.MaximumSize );

                    if (FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 )) {

                        NtfsSetVolumeInfoFlagState( IrpContext,
                                                    Vcb,
                                                    VOLUME_MOUNTED_ON_40,
                                                    FALSE,
                                                    TRUE );
                    }
                }

                //
                //  Upgrade all security information
                //

                NtfsUpgradeSecurity( IrpContext, Vcb );

                ASSERT( Vcb->RootIndexScb != NULL );

                NtfsCleanupTransaction( IrpContext, STATUS_SUCCESS, FALSE );

                //
                //  Update version numbers in volinfo
                //

                if (!NtfsIsVolumeReadOnly( Vcb )) {
                    UpdatedVolumeVersion = NtfsUpdateVolumeInfo( IrpContext, Vcb, NTFS_MAJOR_VERSION, NTFS_MINOR_VERSION );
                }

                //
                //  If we've gotten this far during the mount, it's safe to
                //  update the version number on disk if necessary.
                //

                if (UpgradeVolume) {

                    //
                    //  Now enable defragging.
                    //

                    if (NtfsDefragMftEnabled) {

                        NtfsAcquireCheckpoint( IrpContext, Vcb );
                        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
                        NtfsReleaseCheckpoint( IrpContext, Vcb );
                    }

                    //
                    //  Update the on-disk attribute definition table to include the
                    //  new attributes for an upgraded volume.
                    //

                    NtfsUpdateAttributeTable( IrpContext, Vcb );
                }

            } finally {

                if (!NT_SUCCESS( IrpContext->ExceptionStatus ) && UpgradeVolume) {
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED );
                }
            }

            if (UpdatedVolumeVersion) {

                //
                //  If we've upgraded successfully, we should clear the upgrade
                //  bit now so we can use it again in the future.
                //

                NtfsSetVolumeInfoFlagState( IrpContext,
                                            Vcb,
                                            VOLUME_UPGRADE_ON_MOUNT,
                                            FALSE,
                                            TRUE );
            }

        } else {

            //
            //  If we haven't opened the root directory, do so
            //

            ASSERT( Vcb->RootIndexScb == NULL );

            if (Vcb->RootIndexScb == NULL) {
                NtfsOpenRootDirectory( IrpContext, Vcb );
            }

            NtfsCleanupTransaction( IrpContext, STATUS_SUCCESS, FALSE );
        }

        //
        //  Start the usn journal delete operation if the vcb flag is specified.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

            NtfsPostSpecial( IrpContext, Vcb, NtfsDeleteUsnSpecial, &Vcb->DeleteUsnData );
        }

        //
        //  If the last mount was on a 4.0 volume then we need to clean up the quota
        //  and object id indices.
        //

        if ((Vcb->MajorVersion >= 3) &&
            FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 )) {

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_REPAIR_OBJECT_ID,
                                        TRUE,
                                        TRUE );

            SetFlag( VolumeFlags, VOLUME_REPAIR_OBJECT_ID );

            //
            //  Fire off the quota cleanup if quotas are enabled.
            //

            if (FlagOn( Vcb->QuotaFlags, (QUOTA_FLAG_TRACKING_REQUESTED |
                                      QUOTA_FLAG_TRACKING_ENABLED |
                                      QUOTA_FLAG_ENFORCEMENT_ENABLED ))) {

                NtfsMarkQuotaCorrupt( IrpContext, Vcb );
            }
        }

        //
        //  Start the object ID cleanup if we were mounted on 4.0 or had started
        //  in a previous mount.
        //

        if (FlagOn( VolumeFlags, VOLUME_REPAIR_OBJECT_ID )) {

            NtfsPostSpecial( IrpContext, Vcb, NtfsRepairObjectId, NULL );
        }

        //
        //  Clear the MOUNTED_ON_40 and CHKDSK_MODIFIED flags if set.
        //

        if (FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 | VOLUME_MODIFIED_BY_CHKDSK )) {

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_MOUNTED_ON_40 | VOLUME_MODIFIED_BY_CHKDSK,
                                        FALSE,
                                        TRUE );
        }

        //
        //  Looks like this mount will succeed.  Remember the root directory fileobject
        //  so we can use it for the notification later.
        //

        RootDirFileObject = Vcb->RootIndexScb->FileObject;

        //
        //  Dereference the root file object if present.  The absence of this doesn't
        //  indicate whether the volume was upgraded.  Older 4K Mft records can contain
        //  all of the new streams.
        //

        if (RootDirFileObject != NULL) {

            ObReferenceObject( RootDirFileObject );
        }

        //
        //
        //  Set our return status and say that the mount succeeded
        //

        Status = STATUS_SUCCESS;
        MountFailed = FALSE;
        SetFlag( Vcb->VcbState, VCB_STATE_MOUNT_COMPLETED );

#ifdef SYSCACHE_DEBUG
        if (!NtfsIsVolumeReadOnly( Vcb ) && !NtfsDisableSyscacheLogFile) {
            NtfsInitializeSyscacheLogFile( IrpContext, Vcb );
        }
#endif

    } finally {

        DebugUnwind( NtfsMountVolume );

        NtfsUnpinBcb( IrpContext, &BootBcb );

        if (DeviceObjectName != NULL) {

            NtfsFreePool( DeviceObjectName );
        }

        if (CloseAttributes) { NtfsCloseAttributesFromRestart( IrpContext, Vcb ); }

        for (i = 0; i < 8; i++) {

            NtfsUnpinBcb( IrpContext, &Bcbs[i] );

            //
            //  Get rid of the Mdls, if we haven't already.
            //

            if (Mdls[i] != NULL) {

                if (FlagOn( Mdls[i]->MdlFlags, MDL_PAGES_LOCKED )) {
                    MmUnlockPages( Mdls[i] );
                }
                IoFreeMdl( Mdls[i] );
                Mdls[i] = NULL;
            }
        }

        if (BootScb != NULL) {  NtfsDeleteInternalAttributeStream( BootScb, TRUE, FALSE ); }

        if (VolDo != NULL) {

            Vcb = &VolDo->Vcb;

            if (Vcb->MftScb != NULL)               { NtfsReleaseScb( IrpContext, Vcb->MftScb ); }
            if (Vcb->Mft2Scb != NULL)              { NtfsReleaseScb( IrpContext, Vcb->Mft2Scb ); }
            if (Vcb->LogFileScb != NULL)           { NtfsReleaseScb( IrpContext, Vcb->LogFileScb ); }
            if (Vcb->VolumeDasdScb != NULL)        { NtfsReleaseScb( IrpContext, Vcb->VolumeDasdScb ); }
            if (Vcb->AttributeDefTableScb != NULL) { NtfsReleaseScb( IrpContext, Vcb->AttributeDefTableScb );
                                                     NtfsDeleteInternalAttributeStream( Vcb->AttributeDefTableScb, TRUE, FALSE );
                                                     Vcb->AttributeDefTableScb = NULL;}
            if (Vcb->UpcaseTableScb != NULL)       { NtfsReleaseScb( IrpContext, Vcb->UpcaseTableScb );
                                                     NtfsDeleteInternalAttributeStream( Vcb->UpcaseTableScb, TRUE, FALSE );
                                                     Vcb->UpcaseTableScb = NULL;}
            if (Vcb->RootIndexScb != NULL)         { NtfsReleaseScb( IrpContext, Vcb->RootIndexScb ); }
            if (Vcb->BitmapScb != NULL)            { NtfsReleaseScb( IrpContext, Vcb->BitmapScb ); }
            if (Vcb->BadClusterFileScb != NULL)    { NtfsReleaseScb( IrpContext, Vcb->BadClusterFileScb ); }
            if (Vcb->MftBitmapScb != NULL)         { NtfsReleaseScb( IrpContext, Vcb->MftBitmapScb ); }

            //
            //  Drop the security  data
            //

            if (Vcb->SecurityDescriptorStream != NULL) { NtfsReleaseScb( IrpContext, Vcb->SecurityDescriptorStream ); }
            if (Vcb->UsnJournal != NULL) { NtfsReleaseScb( IrpContext, Vcb->UsnJournal ); }
            if (Vcb->ExtendDirectory != NULL) { NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory ); }
            if (QuotaDataScb != NULL) {
                NtfsReleaseScb( IrpContext, QuotaDataScb );
                NtfsDeleteInternalAttributeStream( QuotaDataScb, TRUE, FALSE );
            }

            if (MountFailed) {

                PVPB NewVpb;

                //
                //  Release all resourcess we acquired now - before we delete away the
                //  volume they refer to. We must checkpoint first to remove any partial transactions
                //

                NtfsCheckpointCurrentTransaction( IrpContext );
                NtfsReleaseAllResources( IrpContext );
                NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, &NewVpb );

                //
                //  If the version upgrade failed, we will be coming back in here soon
                //  and we need to have the right vpb when we do.  This is true if the
                //  upgrade failed or if we are processing a log file full condition.
                //

                if ((FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED ) ||
                     (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_LOG_FILE_FULL) ||
                     (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_CANT_WAIT)) &&

                    (NewVpb != NULL)) {

                    IrpSp->Parameters.MountVolume.Vpb = NewVpb;
                }

                //
                //  On abnormal termination, someone will try to abort a transaction on
                //  this Vcb if we do not clear these fields.
                //

                ASSERT( Vcb->TransactionTable.DrainPending == FALSE );

                IrpContext->TransactionId = 0;
                IrpContext->Vcb = NULL;
            }
        }

        if (VcbAcquired) {

            NtfsReleaseVcbCheckDelete( IrpContext, Vcb, IRP_MJ_FILE_SYSTEM_CONTROL, NULL );
        }

        NtfsReleaseGlobal( IrpContext );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    if (RootDirFileObject != NULL) {

        FsRtlNotifyVolumeEvent( RootDirFileObject, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( RootDirFileObject );
    }

    if (NT_SUCCESS( Status )) {

        //
        //  Remove the extra object reference to the target device object
        //  because I/O system has already made one for this mount.
        //

        ObDereferenceObject( Vcb->TargetDeviceObject );
    }

    DebugTrace( -1, Dbg, ("NtfsMountVolume -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsUpdateAttributeTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine updates the on-disk attribute definition table.

Arguments:

    Vcb - Supplies the Vcb whose attribute table should be updated.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_DEFINITION_COLUMNS AttrDefs = NULL;
    PFCB AttributeTableFcb;
    BOOLEAN FoundAttribute;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT( Vcb->AttributeDefTableScb == NULL );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateAttributeTable\n") );

    NtfsOpenSystemFile( IrpContext,
                        &Vcb->AttributeDefTableScb,
                        Vcb,
                        ATTRIBUTE_DEF_TABLE_NUMBER,
                        0,
                        $DATA,
                        FALSE );

    AttributeTableFcb = Vcb->AttributeDefTableScb->Fcb;

    NtfsInitializeAttributeContext( &AttrContext );

    try {

        //
        //  First, we find and delete the old attribute definition table.
        //

        FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                    AttributeTableFcb,
                                                    &AttributeTableFcb->FileReference,
                                                    $DATA,
                                                    &AttrContext );

        if (!FoundAttribute) {

            try_return( Status = STATUS_DISK_CORRUPT_ERROR );
        }

        NtfsDeleteAttributeRecord( IrpContext,
                                   AttributeTableFcb,
                                   DELETE_LOG_OPERATION | DELETE_RELEASE_ALLOCATION,
                                   &AttrContext );

        //
        //  Now we write the current attribute definition table to disk.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  chkdsk for whistler doesn't recognize the attribute table in its current state
        //  so munge it so it does - move the last entry $EFS into the unused piece of the
        //  table 0xF0
        //

        AttrDefs = NtfsAllocatePool( PagedPool, sizeof( ATTRIBUTE_DEFINITION_COLUMNS ) * NtfsAttributeDefinitionsCount );
        RtlCopyMemory( AttrDefs, NtfsAttributeDefinitions, sizeof( ATTRIBUTE_DEFINITION_COLUMNS ) * NtfsAttributeDefinitionsCount );
        RtlMoveMemory( &AttrDefs[ NtfsAttributeDefinitionsCount - 3], &AttrDefs[ NtfsAttributeDefinitionsCount - 2], sizeof( ATTRIBUTE_DEFINITION_COLUMNS ) * 2);

        NtfsCreateAttributeWithValue( IrpContext,
                                      AttributeTableFcb,
                                      $DATA,
                                      NULL,
                                      AttrDefs,
                                      (NtfsAttributeDefinitionsCount - 1) * sizeof(*NtfsAttributeDefinitions),
                                      0,
                                      NULL,
                                      TRUE,
                                      &AttrContext );

    try_exit: NOTHING;
    } finally {

        if (AttrDefs != NULL) {
            NtfsFreePool( AttrDefs );
        }

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsUpdateAttributeTable -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the verify volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsVerifyVolume\n") );

    //
    //  Do nothing for now
    //

    KdPrint(("NtfsVerifyVolume is not yet implemented\n")); //**** DbgBreakPoint();

    NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_NOT_IMPLEMENTED );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsVerifyVolume -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsUserFsRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

    Wait - Indicates if the thread can block for a resource or I/O

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    ULONG FsControlCode;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location, and save some references
    //  to make our life a little easier.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsUserFsRequest, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Case on the control code.
    //

    switch (FsControlCode) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_REQUEST_FILTER_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        Status = NtfsOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_LOCK_VOLUME:

        Status = NtfsLockVolume( IrpContext, Irp );
        break;

    case FSCTL_UNLOCK_VOLUME:

        Status = NtfsUnlockVolume( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME:

        Status = NtfsDismountVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_MOUNTED:

        Status = NtfsIsVolumeMounted( IrpContext, Irp );
        break;

    case FSCTL_MARK_VOLUME_DIRTY:

        Status = NtfsDirtyVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_PATHNAME_VALID:

        //
        //  All names are potentially valid NTFS names
        //

        NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_SUCCESS );
        break;

    case FSCTL_QUERY_RETRIEVAL_POINTERS:
        Status = NtfsQueryRetrievalPointers( IrpContext, Irp );
        break;

    case FSCTL_GET_COMPRESSION:
        Status = NtfsGetCompression( IrpContext, Irp );
        break;

    case FSCTL_SET_COMPRESSION:

        //
        //  Post this request if we can't wait.
        //

        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

            Status = NtfsPostRequest( IrpContext, Irp );

        } else {

            Status = NtfsSetCompression( IrpContext, Irp );
        }

        break;

    case FSCTL_MARK_AS_SYSTEM_HIVE:
        Status = NtfsMarkAsSystemHive( IrpContext, Irp );
        break;

    case FSCTL_FILESYSTEM_GET_STATISTICS:
        Status = NtfsGetStatistics( IrpContext, Irp );
        break;

    case FSCTL_GET_NTFS_VOLUME_DATA:
        Status = NtfsGetVolumeData( IrpContext, Irp );
        break;

    case FSCTL_GET_VOLUME_BITMAP:
        Status = NtfsGetVolumeBitmap( IrpContext, Irp );
        break;

    case FSCTL_GET_RETRIEVAL_POINTERS:
        Status = NtfsGetRetrievalPointers( IrpContext, Irp );
        break;

    case FSCTL_GET_NTFS_FILE_RECORD:
        Status = NtfsGetMftRecord( IrpContext, Irp );
        break;

    case FSCTL_MOVE_FILE:
        Status = NtfsDefragFile( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_DIRTY:
        Status = NtfsIsVolumeDirty( IrpContext, Irp );
        break;

    case FSCTL_ALLOW_EXTENDED_DASD_IO:
        Status = NtfsSetExtendedDasdIo( IrpContext, Irp );
        break;

    case FSCTL_SET_REPARSE_POINT:
        Status = NtfsSetReparsePoint( IrpContext, Irp );
        break;

    case FSCTL_GET_REPARSE_POINT:
        Status = NtfsGetReparsePoint( IrpContext, Irp );
        break;

    case FSCTL_DELETE_REPARSE_POINT:
        Status = NtfsDeleteReparsePoint( IrpContext, Irp );
        break;

    case FSCTL_SET_OBJECT_ID:
        Status = NtfsSetObjectId( IrpContext, Irp );                // In ObjIdSup.c
        break;

    case FSCTL_GET_OBJECT_ID:
        Status = NtfsGetObjectId( IrpContext, Irp );                // In ObjIdSup.c
        break;

    case FSCTL_DELETE_OBJECT_ID:
        Status = NtfsDeleteObjectId( IrpContext, Irp );             // In ObjIdSup.c
        break;

    case FSCTL_SET_OBJECT_ID_EXTENDED:
        Status = NtfsSetObjectIdExtendedInfo( IrpContext, Irp );    // In ObjIdSup.c
        break;

    case FSCTL_CREATE_OR_GET_OBJECT_ID:
        Status = NtfsCreateOrGetObjectId( IrpContext, Irp );
        break;

    case FSCTL_READ_USN_JOURNAL:
        Status = NtfsReadUsnJournal( IrpContext, Irp, TRUE );     //  In UsnSup.c
        break;

    case FSCTL_CREATE_USN_JOURNAL:
        Status = NtfsCreateUsnJournal( IrpContext, Irp );
        break;

    case FSCTL_ENUM_USN_DATA:
        Status = NtfsReadFileRecordUsnData( IrpContext, Irp );
        break;

    case FSCTL_READ_FILE_USN_DATA:
        Status = NtfsReadFileUsnData( IrpContext, Irp );
        break;

    case FSCTL_WRITE_USN_CLOSE_RECORD:
        Status = NtfsWriteUsnCloseRecord( IrpContext, Irp );
        break;

    case FSCTL_QUERY_USN_JOURNAL:
        Status = NtfsQueryUsnJournal( IrpContext, Irp );
        break;

    case FSCTL_DELETE_USN_JOURNAL:
        Status = NtfsDeleteUsnJournal( IrpContext, Irp );
        break;

    case FSCTL_MARK_HANDLE:
        Status = NtfsMarkHandle( IrpContext, Irp );
        break;

    case FSCTL_SECURITY_ID_CHECK:
        Status = NtfsBulkSecurityIdCheck( IrpContext, Irp );
        break;

    case FSCTL_FIND_FILES_BY_SID:
        Status = NtfsFindFilesOwnedBySid( IrpContext, Irp );
        break;

    case FSCTL_SET_SPARSE :
        Status = NtfsSetSparse( IrpContext, Irp );
        break;

    case FSCTL_SET_ZERO_DATA :
        Status = NtfsZeroRange( IrpContext, Irp );
        break;

    case FSCTL_QUERY_ALLOCATED_RANGES :
        Status = NtfsQueryAllocatedRanges( IrpContext, Irp );
        break;

    case FSCTL_ENCRYPTION_FSCTL_IO :
        Status = NtfsEncryptionFsctl( IrpContext, Irp );
        break;

    case FSCTL_SET_ENCRYPTION :
        Status = NtfsSetEncryption( IrpContext, Irp );
        break;

    case FSCTL_READ_RAW_ENCRYPTED:
        Status = NtfsReadRawEncrypted( IrpContext, Irp );
        break;

    case FSCTL_WRITE_RAW_ENCRYPTED:
        Status = NtfsWriteRawEncrypted( IrpContext, Irp );
        break;

    case FSCTL_EXTEND_VOLUME:
        Status = NtfsExtendVolume( IrpContext, Irp );
        break;

    case FSCTL_READ_FROM_PLEX:
        Status = NtfsReadFromPlex( IrpContext, Irp );
        break;

    case FSCTL_FILE_PREFETCH:
        Status = NtfsPrefetchFile( IrpContext, Irp );
        break;

#ifdef SYSCACHE_DEBUG
    case FSCTL_ENABLE_SYSCACHE:
        NtfsSyscacheTrackingActive = 1;
        Status = STATUS_SUCCESS;
        break;
#endif

    default :
        DebugTrace( 0, Dbg, ("Invalid control code -> %08lx\n", FsControlCode) );
        NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_INVALID_DEVICE_REQUEST );
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsUserFsRequest -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;
    ULONG OplockCount = 0;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location, and save some reference to
    //  make life easier
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsOplockRequest, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We only permit oplock requests on files.
    //

    if ((TypeOfOpen != UserFileOpen) ||
        (SafeNodeType( Scb ) == NTFS_NTC_SCB_MFT)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  There should be no output buffer
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength > 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We jam Wait to TRUE in the IrpContext.  This prevents us from returning
    //  STATUS_PENDING if we can't acquire the file.  The caller would
    //  interpret that as having acquired an oplock.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Switch on the function control code.  We grab the Fcb exclusively
    //  for oplock requests, shared for oplock break acknowledgement.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_REQUEST_FILTER_OPLOCK:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );

        if (FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

            if (Scb->ScbType.Data.FileLock != NULL) {

                OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( Scb->ScbType.Data.FileLock );
            }

        } else {

            OplockCount = Scb->CleanupCount;
        }

        break;

    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        NtfsAcquireSharedFcb( IrpContext, Fcb, Scb, 0 );
        break;

    default:

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try finally to free the Fcb.
    //

    try {

        //
        //  Call the FsRtl routine to grant/acknowledge oplock.
        //

        Status = FsRtlOplockFsctrl( &Scb->ScbType.Data.Oplock,
                                    Irp,
                                    OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    } finally {

        DebugUnwind( NtfsOplockRequest );

        //
        //  Release all of our resources
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        //
        //  If this is not an abnormal termination then complete the irp
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, NULL, 0 );
        }

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> %08lx\n", Status) );
    }

    return Status;
}



NTSTATUS
NtfsLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObjectWithVcbLocked,
    IN OUT PULONG Retrying
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  You should be synchronized
    with checkpoints before calling it

Arguments:

    Vcb - Supplies the Vcb to lock

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN VcbAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLockVolumeInternal...\n") );


    try {
#ifdef SYSCACHE_DEBUG
        ULONG SystemHandleCount = 0;
#endif

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

#ifdef SYSCACHE_DEBUG
        if (Vcb->SyscacheScb != NULL) {
            SystemHandleCount = Vcb->SyscacheScb->CleanupCount;
        }
#endif

        //
        //  Check if the Vcb is already locked, or if the open file count
        //  is greater than 1 (which implies that someone else also is
        //  currently using the volume, or a file on the volume).  We also fail
        //  this request if the volume has already gone through the dismount
        //  vcb process.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) ||
#ifdef SYSCACHE_DEBUG
            (Vcb->CleanupCount > 1 + SystemHandleCount))
#else
            (Vcb->CleanupCount > 1))
#endif
        {

            DebugTrace( 0, Dbg, ("Volume is currently in use\n") );

            Status = STATUS_ACCESS_DENIED;

        //
        //  If the volume is already locked then it might have been the result of an
        //  exclusive DASD open.  Allow that user to explictly lock the volume.
        //

        } else if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

            if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {

                DebugTrace( 0, Dbg, ("User has already locked volume\n") );

                Status = STATUS_ACCESS_DENIED;

            } else {

                //
                //  The exclusive dasd open didn't do a partial dismount - do so now
                //  so we look the same at the unlock point
                //

                NtfsPerformDismountOnVcb( IrpContext, Vcb, FALSE, NULL );
                SetFlag( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK );
                Vcb->FileObjectWithVcbLocked = FileObjectWithVcbLocked;
                Status = STATUS_SUCCESS;
            }

        //
        //  We can take this path if the volume has already been locked via
        //  create but has not taken the PerformDismountOnVcb path.  We checked
        //  for this above by looking at the VOLUME_MOUNTED flag in the Vcb.
        //

        } else {

            //
            //  There better be system files objects only at this point.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_LOCK_IN_PROGRESS );

            if (!NT_SUCCESS( NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, FALSE ))) {

                DebugTrace( 0, Dbg, ("Volume has user file objects\n") );

                Status = STATUS_ACCESS_DENIED;

            //
            //  If there are still user files then try another flush.  We're just being kind
            //  here.  If the lazy writer has a flush queued then the file object can't go
            //  away.  Let's raise CANT_WAIT and try one more time.
            //

            } else if (Vcb->CloseCount - Vcb->SystemFileCloseCount > 1) {

                //
                //  Fail this request if we have already gone through before.
                //  Use the next stack location in the Irp as a convenient
                //  place to store this information.
                //

                if (*Retrying != 0) {

                    DebugTrace( 0, Dbg, ("Volume has user file objects\n") );
                    Status = STATUS_ACCESS_DENIED;

                } else {

                    *Retrying = 1;
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

            } else {

                //
                //  We don't really want to do all of the perform dismount here because
                //  that will cause us to remount a new volume before we're ready.
                //  At this time we only want to stop the log file and close up our
                //  internal attribute streams.  When the user (i.e., chkdsk) does an
                //  unlock then we'll finish up with the dismount call
                //

                NtfsPerformDismountOnVcb( IrpContext, Vcb, FALSE, NULL );

                SetFlag( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_EXPLICIT_LOCK );
                Vcb->FileObjectWithVcbLocked = FileObjectWithVcbLocked;

                Status = STATUS_SUCCESS;
            }
        }

    } finally {

        DebugUnwind( NtfsLockVolumeInternal );

        if (VcbAcquired) {

            ClearFlag( Vcb->VcbState, VCB_STATE_LOCK_IN_PROGRESS );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsLockVolumeInternal -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsLockVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsLockVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  If this is the retry path then perform a short delay so that the
    //  lazy writer can finish any queued writes.
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    if (NextIrpSp->Parameters.FileSystemControl.FsControlCode != 0) {

        //
        //  If retrying wait for the lazy write to do any delayed closes
        //

        CcWaitForCurrentLazyWriterActivity();

    } else {

        //
        //  Notify anyone who wants to close their handles when a lock operation
        //  is attempted.  We should only do this once per lock request, so don't
        //  do it in the retry case.
        //

        DebugTrace( 0, Dbg, ("Sending lock notification\n") );
        FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK );
    }

    try {

        NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );

        Status = NtfsLockVolumeInternal( IrpContext,
                                         Vcb,
                                         ((PFILE_OBJECT)(((UINT_PTR)IrpSp->FileObject) + 1)),
                                         &(NextIrpSp->Parameters.FileSystemControl.FsControlCode) );

    } finally {

        DebugUnwind( NtfsLockVolume );

        NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );

        if ((AbnormalTermination() &&
             IrpContext->ExceptionStatus != STATUS_CANT_WAIT &&
             IrpContext->ExceptionStatus != STATUS_LOG_FILE_FULL) ||

            !NT_SUCCESS( Status )) {

            //
            //  This lock operation has failed either by raising a status that
            //  will keep us from retrying, or else by returning an unsuccessful
            //  status.  Notify anyone who wants to reopen their handles now.
            //  If we're about to retry the lock, we can notify everyone when/if
            //  the retry fails.
            //

            DebugTrace( 0, Dbg, ("Sending lock_failed notification\n") );
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsLockVolume -> %08lx\n", Status) );

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


NTSTATUS
NtfsUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.

Arguments:

    Vcb - Supplies the Vcb to unlock

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  Acquire exclusive access to the Vcb
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    try {

        if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {

            NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );

            //
            //  Unlock the volume and complete the Irp
            //

            ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_EXPLICIT_LOCK );
            Vcb->FileObjectWithVcbLocked = NULL;

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_NOT_LOCKED;
        }

    } finally {

        DebugUnwind( NtfsUnlockVolumeInternal );

        //
        //  Release all of our resources
        //

        NtfsReleaseVcb( IrpContext, Vcb );

        DebugTrace( -1, Dbg, ("NtfsUnlockVolumeInternal -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsUnlockVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsUnlockVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }


    Status = NtfsUnlockVolumeInternal( IrpContext, Vcb );

    //
    //  Notify anyone who wants to reopen their handles when after the
    //  volume is unlocked.
    //

    if (NT_SUCCESS(Status)) {

        FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    DebugTrace( -1, Dbg, ("NtfsUnlockVolume -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the dismount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PIO_STACK_LOCATION IrpSp;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN ExplicitDismount = FALSE;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN ClearCheckpointActive = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsDismountVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsDismountVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Don't notify if we are retrying due to log file full.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH )) {

        FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT );
    }

    try {

        //
        //  Serialize this with the volume checkpoints.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        while (FlagOn( Vcb->CheckpointFlags, VCB_STOP_LOG_CHECKPOINT )) {

            //
            //  Release the checkpoint event because we cannot stop the log file now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
            NtfsAcquireCheckpoint( IrpContext, Vcb );
        }

        SetFlag( Vcb->CheckpointFlags, VCB_STOP_LOG_CHECKPOINT );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        ClearCheckpointActive = TRUE;

        //
        //  Acquire the Vcb exclusively.
        //

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

        //
        //  Take special action if there's a pagefile on this volume, or if this is the
        //  system volume.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT )) {

            //
            //  If the volume is not locked then fail immediately.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

                try_return( Status = STATUS_ACCESS_DENIED );

            //
            //  If there are read-only files only then noop the request.  This
            //  allows autochk to access the root volume.
            //

            } else if (Vcb->ReadOnlyCloseCount == ((Vcb->CloseCount - Vcb->SystemFileCloseCount) - 1)) {

                DebugTrace( 0, Dbg, ("Volume has readonly files opened\n") );
                try_return( Status = STATUS_SUCCESS );
            }
        }

        //
        //  Remember that this is an explicit dismount.
        //

        ExplicitDismount = TRUE;

        //
        //  Naturally, we can't dismount the volume if it's already dismounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            //
            //  Return success if the user hasn't done an explicit dismount.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_DISMOUNT )) {

                Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_VOLUME_DISMOUNTED;
            }

            try_return( NOTHING );
        }

        //
        //  Raise LogFile full once per dismount to force a clean checkpoint
        //  freeing logfile space.
        //
        if ((!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH )) &&
            (!NtfsIsVolumeReadOnly( Vcb ))) {

#ifdef PERF_STATS
            IrpContext->LogFullReason = LF_DISMOUNT;
#endif

            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH );
            NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
        }

        //
        //  Get as many cached writes out to disk as we can and mark
        //  all the streams for dismount.
        //

#ifdef BRIANDBG
        try {
#endif

           NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, TRUE );

           //
           //  Call the function that does the real work. We leave the volume locked
           //  so the complete teardown occurs when the handle closes
           //

           NtfsPerformDismountOnVcb( IrpContext, Vcb, FALSE, NULL );

#ifdef BRIANDBG
        } except( NtfsDismountExceptionFilter( GetExceptionInformation() )) {

            NOTHING
        }
#endif

        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        Vcb->FileObjectWithVcbLocked = (PFILE_OBJECT)(((ULONG_PTR)FileObject)+1);

        //
        //  Once we get this far the volume is really dismounted.  We
        //  can ignore errors generated by recursive failures.
        //

        Status = STATUS_SUCCESS;

        //
        //  Mark the volume as needs to be verified.
        //

        SetFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

    try_exit: NOTHING;

        //
        //  Remember that the user did an explicit dismount.
        //

        if ((Status == STATUS_SUCCESS) && ExplicitDismount) {

            SetFlag( Vcb->VcbState, VCB_STATE_EXPLICIT_DISMOUNT );
        }

    } finally {

        DebugUnwind( NtfsDismountVolume );

        if (ClearCheckpointActive) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->CheckpointFlags, VCB_STOP_LOG_CHECKPOINT );
            NtfsSetCheckpointNotify( IrpContext, Vcb );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        //
        //  Release all of our resources
        //

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (!NT_SUCCESS( Status ) &&
            (Status != STATUS_VOLUME_DISMOUNTED)) {

            //
            //  No need to report the error if this is a retryable error.
            //

            if (!AbnormalTermination() ||
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH ) ||
                ((IrpContext->ExceptionStatus != STATUS_LOG_FILE_FULL) &&
                 (IrpContext->ExceptionStatus != STATUS_CANT_WAIT))) {

                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT_FAILED );
            }
        }

        //
        //  If this is an abnormal termination then undo our work, otherwise
        //  complete the irp
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace( -1, Dbg, ("NtfsDismountVolume -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns whether the volume is mounted.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PFILE_OBJECT FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN AcquiredVcb = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsIsVolumeMounted...\n") );

    //
    //  Extract and decode the file object.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen == UnopenedFileObject) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try-finally to release the Vcb if necessary.
    //

    try {

        //
        //  If we know the volume is dismounted, we're all done.
        //  OK to do this without synchronization as the state can
        //  change to unmounted on return to the user.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

             try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Verify the volume if necessary.
        //

        NtfsPingVolume( IrpContext, Vcb, &AcquiredVcb );

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsIsVolumeMounted );

        //
        //  Release the Vcb.
        //

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsIsVolumeMounted -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsDirtyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine marks the specified volume dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsDirtyVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsDirtyVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        //
        //  Fail this request if the volume is not mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;

        }  else if (NtfsIsVolumeReadOnly( Vcb )) {

            Status = STATUS_MEDIA_WRITE_PROTECTED;

        } else {

            NtfsPostVcbIsCorrupt( IrpContext, 0, NULL, NULL );
        }

    } finally {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsDirtyVolume -> STATUS_SUCCESS\n") );

    return Status;
}


//
//  Local support routine
//

BOOLEAN
NtfsGetDiskGeometry (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT RealDevice,
    IN PDISK_GEOMETRY DiskGeometry,
    IN PLONGLONG Length
    )

/*++

Routine Description:

    This procedure gets the disk geometry of the specified device

Arguments:

    RealDevice - Supplies the real device that is being queried

    DiskGeometry - Receives the disk geometry

    Length - Receives the number of bytes in the partition

Return Value:

    BOOLEAN - TRUE if the media is write protected, FALSE otherwise

--*/

{
    NTSTATUS Status;
    PREVENT_MEDIA_REMOVAL Prevent;
    BOOLEAN WriteProtected = FALSE;
    GET_LENGTH_INFORMATION LengthInfo;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetDiskGeometry:\n") );
    DebugTrace( 0, Dbg, ("RealDevice = %08lx\n", RealDevice) );
    DebugTrace( 0, Dbg, ("DiskGeometry = %08lx\n", DiskGeometry) );

    //
    //  Attempt to lock any removable media, ignoring status.
    //

    Prevent.PreventMediaRemoval = TRUE;
    (VOID)NtfsDeviceIoControl( IrpContext,
                                RealDevice,
                                IOCTL_DISK_MEDIA_REMOVAL,
                                &Prevent,
                                sizeof(PREVENT_MEDIA_REMOVAL),
                                NULL,
                                0,
                                NULL );

    //
    //  See if the media is write protected.  On success or any kind
    //  of error (possibly illegal device function), assume it is
    //  writeable, and only complain if he tells us he is write protected.
    //

    Status = NtfsDeviceIoControl( IrpContext,
                                  RealDevice,
                                  IOCTL_DISK_IS_WRITABLE,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  NULL );

    //
    //  Remember if the media is write protected but don't raise the error now.
    //  If the volume is not Ntfs then let another filesystem try.
    //
    if (Status == STATUS_MEDIA_WRITE_PROTECTED) {

        WriteProtected = TRUE;
        Status = STATUS_SUCCESS;
    }

    Status = NtfsDeviceIoControl( IrpContext,
                                  RealDevice,
                                  IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                  NULL,
                                  0,
                                  DiskGeometry,
                                  sizeof(DISK_GEOMETRY),
                                  NULL );

    if (!NT_SUCCESS(Status)) {
        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    Status = NtfsDeviceIoControl( IrpContext,
                                  RealDevice,
                                  IOCTL_DISK_GET_LENGTH_INFO,
                                  NULL,
                                  0,
                                  &LengthInfo,
                                  sizeof( LengthInfo ),
                                  NULL );

    if (!NT_SUCCESS(Status)) {
        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    *Length = LengthInfo.Length.QuadPart;

    DebugTrace( -1, Dbg, ("NtfsGetDiskGeometry->VOID\n") );
    return WriteProtected;
}


NTSTATUS
NtfsDeviceIoControl (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG_PTR IosbInformation OPTIONAL
    )

/*++

Routine Description:

    This procedure issues an Ioctl to the lower device, and waits
    for the answer.

Arguments:

    DeviceObject - Supplies the device to issue the request to

    IoCtl - Gives the IoCtl to be used

    XxBuffer - Gives the buffer pointer for the ioctl, if any

    XxBufferLength - Gives the length of the buffer, if any

Return Value:

    None.

--*/

{
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IoCtl,
                                         DeviceObject,
                                         InputBuffer,
                                         InputBufferLength,
                                         OutputBuffer,
                                         OutputBufferLength,
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if (Irp == NULL) {

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    Status = IoCallDriver( DeviceObject, Irp );

    if (Status == STATUS_PENDING) {

        (VOID)KeWaitForSingleObject( &Event,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     (PLARGE_INTEGER)NULL );

        Status = Iosb.Status;
    }

    //
    //  Get the information field from the completed Irp.
    //

    if ((NT_SUCCESS( Status )) && ARGUMENT_PRESENT( IosbInformation )) {

        *IosbInformation = Iosb.Information;
    }

    return Status;
}


//
//  Local support routine
//

VOID
NtfsReadBootSector (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PSCB *BootScb,
    OUT PBCB *BootBcb,
    OUT PVOID *BootSector
    )

/*++

Routine Description:

    This routine reads and returns a pointer to the boot sector for the volume.

    Volumes formatted under 3.51 and earlier will have a boot sector at sector
    0 and another halfway through the disk.  Volumes formatted with NT 4.0
    will have a boot sector at the end of the disk, in the sector beyond the
    stated size of the volume in the boot sector.  When this call is made the
    Vcb has the sector count from the device driver so we subtract one to find
    the last sector.

Arguments:

    Vcb - Supplies the Vcb for the operation

    BootScb - Receives the Scb for the boot file

    BootBcb - Receives the bcb for the boot sector

    BootSector - Receives a pointer to the boot sector

Return Value:

    None.

--*/

{
    PSCB Scb = NULL;
    BOOLEAN Error = FALSE;

    FILE_REFERENCE FileReference = { BOOT_FILE_NUMBER, 0, BOOT_FILE_NUMBER };

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadBootSector:\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );

    //
    //  Create a temporary scb for reading in the boot sector and initialize the
    //  mcb for it.
    //

    Scb = NtfsCreatePrerestartScb( IrpContext,
                                   Vcb,
                                   &FileReference,
                                   $DATA,
                                   NULL,
                                   0 );

    *BootScb = Scb;

    Scb->Header.AllocationSize.QuadPart =
    Scb->Header.FileSize.QuadPart =
    Scb->Header.ValidDataLength.QuadPart = (PAGE_SIZE * 2) + Vcb->BytesPerSector;

    //
    //  We don't want to look up the size for this Scb.
    //

    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

    SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

    (VOID)NtfsAddNtfsMcbEntry( &Scb->Mcb,
                               (LONGLONG)0,
                               (LONGLONG)0,
                               (LONGLONG)Vcb->ClustersPerPage,
                               FALSE );


    (VOID)NtfsAddNtfsMcbEntry( &Scb->Mcb,
                               (LONGLONG)Vcb->ClustersPerPage,
                               Vcb->NumberSectors >> 1,
                               (LONGLONG)Vcb->ClustersPerPage,
                               FALSE );

    (VOID)NtfsAddNtfsMcbEntry( &Scb->Mcb,
                               Int64ShllMod32( (LONGLONG) Vcb->ClustersPerPage, 1 ),
                               Vcb->NumberSectors - 1,
                               1,
                               FALSE );

    //
    //  Try reading in the first boot sector
    //

    try {

        NtfsMapStream( IrpContext,
                       Scb,
                       (LONGLONG)0,
                       Vcb->BytesPerSector,
                       BootBcb,
                       BootSector );

    //
    //  If we got an exception trying to read the first boot sector,
    //  then handle the exception by trying to read the second boot
    //  sector.  If that faults too, then we just allow ourselves to
    //  unwind and return the error.
    //

    } except (FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        Error = TRUE;
    }

    //
    //  Get out if we didn't get an error.  Otherwise try the middle sector.
    //  We want to read this next because we know that 4.0 format will clear
    //  this before writing the last sector.  Otherwise we could see a
    //  stale boot sector in the last sector even though a 3.51 format was
    //  the last to run.
    //

    if (!Error) { return; }

    Error = FALSE;

    try {

        NtfsMapStream( IrpContext,
                       Scb,
                       (LONGLONG)PAGE_SIZE,
                       Vcb->BytesPerSector,
                       BootBcb,
                       BootSector );

        //
        //  Ignore this sector if not Ntfs.  This could be the case for
        //  a bad sector 0 on a FAT volume.
        //

        if (!NtfsIsBootSectorNtfs( *BootSector, Vcb )) {

            NtfsUnpinBcb( IrpContext, BootBcb );
            Error = TRUE;
        }

    //
    //  If we got an exception trying to read the first boot sector,
    //  then handle the exception by trying to read the second boot
    //  sector.  If that faults too, then we just allow ourselves to
    //  unwind and return the error.
    //

    } except (FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        Error = TRUE;
    }

    //
    //  Get out if we didn't get an error.  Otherwise try the middle sector.
    //

    if (!Error) { return; }

    NtfsMapStream( IrpContext,
                   Scb,
                   (LONGLONG) (PAGE_SIZE * 2),
                   Vcb->BytesPerSector,
                   BootBcb,
                   BootSector );

    //
    //  Clear the header flag in the Scb.
    //

    ClearFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("BootScb > %08lx\n", *BootScb) );
    DebugTrace( 0, Dbg, ("BootBcb > %08lx\n", *BootBcb) );
    DebugTrace( 0, Dbg, ("BootSector > %08lx\n", *BootSector) );
    DebugTrace( -1, Dbg, ("NtfsReadBootSector->VOID\n") );
    return;
}


//
//  Local support routine
//

//
//  First define a local macro to number the tests for the debug case.
//

#ifdef NTFSDBG
#define NextTest ++CheckNumber &&
#else
#define NextTest TRUE &&
#endif

BOOLEAN
NtfsIsBootSectorNtfs (
    IN PPACKED_BOOT_SECTOR BootSector,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks the boot sector to determine if it is an NTFS partition.

    The Vcb must alread be initialized from the device object to contain the
    parts of the device geometry we care about here: bytes per sector and
    total number of sectors in the partition.

Arguments:

    BootSector - Pointer to the boot sector which has been read in.

    Vcb - Pointer to a Vcb which has been initialized with sector size and
          number of sectors on the partition.

Return Value:

    FALSE - If the boot sector is not for Ntfs.
    TRUE - If the boot sector is for Ntfs.

--*/

{
#ifdef NTFSDBG
    ULONG CheckNumber = 0;
#endif

    //  PULONG l;
    //  ULONG Checksum = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsBootSectorNtfs\n") );
    DebugTrace( 0, Dbg, ("BootSector = %08lx\n", BootSector) );

    //
    //  First calculate the boot sector checksum
    //

    //
    //  for (l = (PULONG)BootSector; l < (PULONG)&BootSector->Checksum; l++) {
    //      Checksum += *l;
    //  }

    //
    //  Now perform all the checks, starting with the Name and Checksum.
    //  The remaining checks should be obvious, including some fields which
    //  must be 0 and other fields which must be a small power of 2.
    //

    if (NextTest
        (BootSector->Oem[0] == 'N') &&
        (BootSector->Oem[1] == 'T') &&
        (BootSector->Oem[2] == 'F') &&
        (BootSector->Oem[3] == 'S') &&
        (BootSector->Oem[4] == ' ') &&
        (BootSector->Oem[5] == ' ') &&
        (BootSector->Oem[6] == ' ') &&
        (BootSector->Oem[7] == ' ')

            &&

        //  NextTest
        //  (BootSector->Checksum == Checksum)
        //
        //      &&

        //
        //  Check number of bytes per sector.  The low order byte of this
        //  number must be zero (smallest sector size = 0x100) and the
        //  high order byte shifted must equal the bytes per sector gotten
        //  from the device and stored in the Vcb.  And just to be sure,
        //  sector size must be less than page size.
        //

        NextTest
        (BootSector->PackedBpb.BytesPerSector[0] == 0)

            &&

        NextTest
        ((ULONG)(BootSector->PackedBpb.BytesPerSector[1] << 8) == Vcb->BytesPerSector)

            &&

        NextTest
        (BootSector->PackedBpb.BytesPerSector[1] << 8 <= PAGE_SIZE)

            &&

        //
        //  Sectors per cluster must be a power of 2.
        //

        NextTest
        ((BootSector->PackedBpb.SectorsPerCluster[0] == 0x1) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x2) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x4) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x8) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x10) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x20) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x40) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x80))

            &&

        //
        //  These fields must all be zero.  For both Fat and HPFS, some of
        //  these fields must be nonzero.
        //

        NextTest
        (BootSector->PackedBpb.ReservedSectors[0] == 0) &&
        (BootSector->PackedBpb.ReservedSectors[1] == 0) &&
        (BootSector->PackedBpb.Fats[0] == 0) &&
        (BootSector->PackedBpb.RootEntries[0] == 0) &&
        (BootSector->PackedBpb.RootEntries[1] == 0) &&
        (BootSector->PackedBpb.Sectors[0] == 0) &&
        (BootSector->PackedBpb.Sectors[1] == 0) &&
        (BootSector->PackedBpb.SectorsPerFat[0] == 0) &&
        (BootSector->PackedBpb.SectorsPerFat[1] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[0] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[1] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[2] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[3] == 0) &&
        (BootSector->PackedBpb.LargeSectors[0] == 0) &&
        (BootSector->PackedBpb.LargeSectors[1] == 0) &&
        (BootSector->PackedBpb.LargeSectors[2] == 0) &&
        (BootSector->PackedBpb.LargeSectors[3] == 0)

            &&

        //
        //  Number of Sectors cannot be greater than the number of sectors
        //  on the partition.
        //

        NextTest
        (BootSector->NumberSectors <= Vcb->NumberSectors)

            &&

        //
        //  Check that both Lcn values are for sectors within the partition.
        //

        NextTest
        ((BootSector->MftStartLcn * BootSector->PackedBpb.SectorsPerCluster[0]) <=
            Vcb->NumberSectors)

            &&

        NextTest
        ((BootSector->Mft2StartLcn * BootSector->PackedBpb.SectorsPerCluster[0]) <=
            Vcb->NumberSectors)

            &&

        //
        //  Clusters per file record segment and default clusters for Index
        //  Allocation Buffers must be a power of 2.  A zero indicates that the
        //  size of these structures is the default size.
        //

        NextTest
        (((BootSector->ClustersPerFileRecordSegment >= -31) &&
          (BootSector->ClustersPerFileRecordSegment <= -9)) ||
         (BootSector->ClustersPerFileRecordSegment == 0x1) ||
         (BootSector->ClustersPerFileRecordSegment == 0x2) ||
         (BootSector->ClustersPerFileRecordSegment == 0x4) ||
         (BootSector->ClustersPerFileRecordSegment == 0x8) ||
         (BootSector->ClustersPerFileRecordSegment == 0x10) ||
         (BootSector->ClustersPerFileRecordSegment == 0x20) ||
         (BootSector->ClustersPerFileRecordSegment == 0x40))

            &&

        NextTest
        (((BootSector->DefaultClustersPerIndexAllocationBuffer >= -31) &&
          (BootSector->DefaultClustersPerIndexAllocationBuffer <= -9)) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x1) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x2) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x4) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x8) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x10) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x20) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x40))) {

        DebugTrace( -1, Dbg, ("NtfsIsBootSectorNtfs->TRUE\n") );

        return TRUE;

    } else {

        //
        //  If a check failed, print its check number with Debug Trace.
        //

        DebugTrace( 0, Dbg, ("Boot Sector failed test number %08lx\n", CheckNumber) );
        DebugTrace( -1, Dbg, ("NtfsIsBootSectorNtfs->FALSE\n") );

        return FALSE;
    }
}


//
//  Local support routine
//

VOID
NtfsGetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PVPB Vpb OPTIONAL,
    IN PVCB Vcb,
    OUT PUSHORT VolumeFlags
    )

/*++

Routine Description:

    This routine gets the serial number and volume label for an NTFS volume.  It also
    returns the current volume flags for the volume.

Arguments:

    Vpb - Supplies the Vpb for the volume.  The Vpb will receive a copy of
        the volume label and serial number, if a Vpb is specified.

    Vcb - Supplies the Vcb for the operation.

    VolumeFlags - Address to store the current volume flags.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PVOLUME_INFORMATION VolumeInformation;

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsGetVolumeInformation...\n") );

    *VolumeFlags = 0;

    //
    //  We read in the volume label attribute to get the volume label.
    //

    try {

        if (ARGUMENT_PRESENT(Vpb)) {

            NtfsInitializeAttributeContext( &AttributeContext );

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Vcb->VolumeDasdScb->Fcb,
                                           &Vcb->VolumeDasdScb->Fcb->FileReference,
                                           $VOLUME_NAME,
                                           &AttributeContext )) {

                Vpb->VolumeLabelLength = (USHORT)
                NtfsFoundAttribute( &AttributeContext )->Form.Resident.ValueLength;

                if ( Vpb->VolumeLabelLength > MAXIMUM_VOLUME_LABEL_LENGTH) {

                     Vpb->VolumeLabelLength = MAXIMUM_VOLUME_LABEL_LENGTH;
                }

                RtlCopyMemory( &Vpb->VolumeLabel[0],
                               NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ) ),
                               Vpb->VolumeLabelLength );

            } else {

                Vpb->VolumeLabelLength = 0;
            }

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        NtfsInitializeAttributeContext( &AttributeContext );

        //
        //  Remember if the volume is dirty when we are mounting it.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_INFORMATION,
                                       &AttributeContext )) {

            VolumeInformation =
              (PVOLUME_INFORMATION)NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            if (FlagOn( VolumeInformation->VolumeFlags, VOLUME_DIRTY )) {
                SetFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY );
            } else {
                ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY );
            }

            *VolumeFlags = VolumeInformation->VolumeFlags;
        }

    } finally {

        DebugUnwind( NtfsGetVolumeInformation );

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

VOID
NtfsSetAndGetVolumeTimes (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MarkDirty
    )

/*++

Routine Description:

    This routine reads in the volume times from the standard information attribute
    of the volume file and also updates the access time to be the current
    time

Arguments:

    Vcb - Supplies the vcb for the operation.

    MarkDirty - Supplies TRUE if volume is to be marked dirty

    UpdateInTransaction - Indicates if we should mark the volume dirty in a transaction.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PSTANDARD_INFORMATION StandardInformation;

    LONGLONG MountTime;

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsSetAndGetVolumeTimes...\n") );

    try {

        //
        //  Lookup the standard information attribute of the dasd file
        //

        NtfsInitializeAttributeContext( &AttributeContext );

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Vcb->VolumeDasdScb->Fcb,
                                        &Vcb->VolumeDasdScb->Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttributeContext )) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        StandardInformation = (PSTANDARD_INFORMATION)NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

        //
        //  Get the current time and make sure it differs from the time stored
        //  in last access time and then store the new last access time
        //

        NtfsGetCurrentTime( IrpContext, MountTime );

        if (MountTime == StandardInformation->LastAccessTime) {

            MountTime = MountTime + 1;
        }

        //****
        //****  Hold back on the update for now.
        //****
        //**** NtfsChangeAttributeValue( IrpContext,
        //****                           Vcb->VolumeDasdScb->Fcb,
        //****                           FIELD_OFFSET(STANDARD_INFORMATION, LastAccessTime),
        //****                           &MountTime,
        //****                           sizeof(MountTime),
        //****                           FALSE,
        //****                           FALSE,
        //****                           &AttributeContext );

        //
        //  Now save all the time fields in our vcb
        //

        Vcb->VolumeCreationTime = StandardInformation->CreationTime;
        Vcb->VolumeLastModificationTime = StandardInformation->LastModificationTime;
        Vcb->VolumeLastChangeTime = StandardInformation->LastChangeTime;
        Vcb->VolumeLastAccessTime = StandardInformation->LastAccessTime; //****Also hold back = MountTime;

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

        //
        //  If the volume was mounted dirty, then set the dirty bit here.
        //

        if (MarkDirty) {

            NtfsMarkVolumeDirty( IrpContext, Vcb );
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

VOID
NtfsOpenSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb,
    IN PVCB Vcb,
    IN ULONG FileNumber,
    IN LONGLONG Size,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN BOOLEAN ModifiedNoWrite
    )

/*++

Routine Description:

    This routine is called to open one of the system files by its file number
    during the mount process.  An initial allocation is looked up for the file,
    unless the optional initial size is specified (in which case this size is
    used).

Parameters:

    Scb - Pointer to where the Scb pointer is to be stored.  If Scb pointer
          pointed to is NULL, then a PreRestart Scb is created, otherwise the
          existing Scb is used and only the stream file is set up.

    FileNumber - Number of the system file to open.

    Size - If nonzero, this size is used as the initial size, rather
           than consulting the file record in the Mft.

    AttributeTypeCode - Supplies the attribute to open, e.g., $DATA or $BITMAP

    ModifiedNoWrite - Indicates if the Memory Manager is not to write this
                      attribute to disk.  Applies to streams under transaction
                      control.

Return Value:

    None.

--*/

{
    PSCB NewScb = *Scb;
    FILE_REFERENCE FileReference;
    UNICODE_STRING $BadName;
    PUNICODE_STRING AttributeName = NULL;
    BOOLEAN AcquiredScb = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenSystemFile:\n") );
    DebugTrace( 0, Dbg, ("*Scb = %08lx\n", *Scb) );
    DebugTrace( 0, Dbg, ("FileNumber = %08lx\n", FileNumber) );
    DebugTrace( 0, Dbg, ("ModifiedNoWrite = %04x\n", ModifiedNoWrite) );

    try {

        //
        //  The Bad Cluster data attribute has a name.
        //

        if (FileNumber == BAD_CLUSTER_FILE_NUMBER) {

            RtlInitUnicodeString( &$BadName, L"$Bad" );
            AttributeName = &$BadName;
        }

        //
        //  If the Scb does not already exist, create it.
        //

        if (NewScb == NULL) {

            NtfsSetSegmentNumber( &FileReference, 0, FileNumber );
            FileReference.SequenceNumber = (FileNumber == 0 ? 1 : (USHORT)FileNumber);

            //
            //  Create the Scb.
            //

            NewScb = NtfsCreatePrerestartScb( IrpContext,
                                            Vcb,
                                            &FileReference,
                                            AttributeTypeCode,
                                            AttributeName,
                                            0 );
            NtfsAcquireExclusiveScb( IrpContext, NewScb );
            AcquiredScb = TRUE;
        }

        //
        //  Set the modified-no-write bit in the Scb if necessary.
        //

        if (ModifiedNoWrite) {

            SetFlag( NewScb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
        }

        //
        //  Lookup the file sizes.
        //

        if (Size == 0) {

            NtfsUpdateScbFromAttribute( IrpContext, NewScb, NULL );

            //
            //  Make sure the file size isn't larger than allocation size.
            //

            if (NewScb->Header.FileSize.QuadPart > NewScb->Header.AllocationSize.QuadPart) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NewScb->Fcb );
            }

        //
        //  Otherwise, just set the size we were given.
        //

        } else {

            NewScb->Header.FileSize.QuadPart =
            NewScb->Header.ValidDataLength.QuadPart = Size;

            NewScb->Header.AllocationSize.QuadPart = LlClustersFromBytes( Vcb, Size );
            NewScb->Header.AllocationSize.QuadPart = LlBytesFromClusters( Vcb,
                                                                          NewScb->Header.AllocationSize.QuadPart );

            SetFlag( NewScb->ScbState, SCB_STATE_HEADER_INITIALIZED );
        }

        //
        //  Make sure that our system streams are not marked as compressed.
        //

        if (AttributeTypeCode != $INDEX_ALLOCATION) {

            ClearFlag( NewScb->ScbState, SCB_STATE_WRITE_COMPRESSED );
            ClearFlag( NewScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

            if (!FlagOn( NewScb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                NewScb->CompressionUnit = 0;
                NewScb->CompressionUnitShift = 0;
            }
        }

        //
        //  Finally, create the stream, if not already there.
        //  And check if we should increment the counters
        //  If this is the volume file or the bad cluster file, we only increment the counts.
        //

        if ((FileNumber == VOLUME_DASD_NUMBER) ||
            (FileNumber == BAD_CLUSTER_FILE_NUMBER)) {

            if (NewScb->FileObject == 0) {

                NtfsIncrementCloseCounts( NewScb, TRUE, FALSE );

                NewScb->FileObject = (PFILE_OBJECT) 1;
            }

        } else {

            NtfsCreateInternalAttributeStream( IrpContext,
                                               NewScb,
                                               TRUE,
                                               &NtfsSystemFiles[FileNumber] );
        }

    } finally {

        if (AbnormalTermination()) {

            if (AcquiredScb) {

                BOOLEAN RemovedFcb = FALSE;
                PFCB Fcb = NewScb->Fcb;

                //
                //  We created the Scb / so tear it down in the exceptional case
                //

                NtfsTeardownStructures( IrpContext,
                                        NewScb,
                                        NULL,
                                        FALSE,
                                        0,
                                        &RemovedFcb );

                if (!RemovedFcb) {
                    NtfsReleaseFcb( IrpContext, Fcb );
                }
            }
        }
    }

    *Scb = NewScb;

    DebugTrace( 0, Dbg, ("*Scb > %08lx\n", *Scb) );
    DebugTrace( -1, Dbg, ("NtfsOpenSystemFile -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsOpenRootDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the root directory by file number, and fills in the
    related pointers in the Vcb.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB RootFcb;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    FILE_REFERENCE FileReference;
    BOOLEAN MustBeFalse;

    PAGED_CODE();

    //
    //  Put special code here to do initial open of Root Index.
    //

    RootFcb = NtfsCreateRootFcb( IrpContext, Vcb );

    NtfsSetSegmentNumber( &FileReference, 0, ROOT_FILE_NAME_INDEX_NUMBER );
    FileReference.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

    //
    //  Now create its Scb and acquire it exclusive.
    //

    Vcb->RootIndexScb = NtfsCreateScb( IrpContext,
                                       RootFcb,
                                       $INDEX_ALLOCATION,
                                       &NtfsFileNameIndex,
                                       FALSE,
                                       &MustBeFalse );

    //
    //  Now allocate a buffer to hold the normalized name for the root.
    //

    Vcb->RootIndexScb->ScbType.Index.NormalizedName.Buffer = NtfsAllocatePool( PagedPool, 2 );
    Vcb->RootIndexScb->ScbType.Index.NormalizedName.MaximumLength =
    Vcb->RootIndexScb->ScbType.Index.NormalizedName.Length = 2;
    Vcb->RootIndexScb->ScbType.Index.NormalizedName.Buffer[0] = '\\';

    Vcb->RootIndexScb->ScbType.Index.HashValue = 0;
    NtfsConvertNameToHash( Vcb->RootIndexScb->ScbType.Index.NormalizedName.Buffer,
                           sizeof( WCHAR ),
                           Vcb->UpcaseTable,
                           &Vcb->RootIndexScb->ScbType.Index.HashValue );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->RootIndexScb );

    //
    //  Lookup the attribute and it better be there
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        RootFcb,
                                        &FileReference,
                                        $INDEX_ROOT,
                                        &Context ) ) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  We need to update the duplicated information in the
        //  Fcb.

        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, RootFcb, NULL );

        //
        //  Initialize the Scb.  Force it to refer to a file name.
        //

        NtfsUpdateIndexScbFromAttribute( IrpContext,
                                         Vcb->RootIndexScb,
                                         NtfsFoundAttribute( &Context ),
                                         TRUE );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsInitializeSecurityFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the security file, and initializes the security
    support.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;
    FILE_REFERENCE FileReference;

    //
    //  Set the file number for the security file.
    //

    NtfsSetSegmentNumber( &FileReference, 0, SECURITY_FILE_NUMBER );
    FileReference.SequenceNumber = SECURITY_FILE_NUMBER;

    //
    //  Create the Fcb.
    //

    Fcb = NtfsCreateFcb( IrpContext,
                         Vcb,
                         FileReference,
                         FALSE,
                         TRUE,
                         NULL );

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now call the Security system to initialize itself.
        //

        NtfsInitializeSecurity( IrpContext, Vcb, Fcb );

    } finally {

        //
        //  If some error caused him to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsUpgradeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine upgrades the security descriptors and names for system
    scbs.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb = Vcb->SecurityDescriptorStream->Fcb;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PSCB *ScbPtr;

    //
    //  Get set for some attribute lookups/creates
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        struct {
            FILE_NAME FileName;
            WCHAR FileNameChars[10];
        } FileNameAttr;
        PFILE_NAME CurrentFileName;
        UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );

        //
        //  Initialize a FileName attribute for this file.
        //

        RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
        FileNameAttr.FileName.ParentDirectory = Fcb->FileReference;
        FileNameAttr.FileName.FileNameLength = 7;
        RtlCopyMemory( FileNameAttr.FileName.FileName, L"$Secure", 14 );

        ASSERT_EXCLUSIVE_FCB( Fcb );

        //
        //  If this file still has an unnamed data attribute from format, delete it.
        //

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $DATA,
                                       &NoName,
                                       NULL,
                                       FALSE,
                                       &Context ) ) {

            NtfsDeleteAttributeRecord( IrpContext,
                                       Fcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &Context );
        }

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  If there is an old name from format, remove it and put the right one there.
        //

        NtfsInitializeAttributeContext( &Context );
        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $FILE_NAME,
                                       &Context ) &&

            (((CurrentFileName = (PFILE_NAME)NtfsAttributeValue(NtfsFoundAttribute(&Context)))->FileNameLength != 7) ||
             (RtlCompareMemory(CurrentFileName->FileName, FileNameAttr.FileName.FileName, 14) != 14))) {

            UCHAR FileNameFlags;
            UNICODE_STRING LinkName;

            LinkName.Length = LinkName.MaximumLength = CurrentFileName->FileNameLength * sizeof( WCHAR );
            LinkName.Buffer = CurrentFileName->FileName;

            //
            //  Yank the old name.
            //

            NtfsRemoveLink( IrpContext, Fcb, Vcb->RootIndexScb, LinkName, NULL, NULL );

            //
            //  Create the new name.
            //

            NtfsAddLink( IrpContext,
                         TRUE,
                         Vcb->RootIndexScb,
                         Fcb,
                         (PFILE_NAME)&FileNameAttr,
                         NULL,
                         &FileNameFlags,
                         NULL,
                         NULL,
                         NULL );

        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );

    }

    //
    //  To free some space in our system file records, let's verify that their security
    //  is converted.
    //
    //  ****    conditionalize now until chkdsk supports the new security.
    //

    for (ScbPtr = &Vcb->MftScb; ScbPtr < &Vcb->MftBitmapScb; ScbPtr++) {

        PFCB SystemFcb;

        //
        //  Do only Scb's that are currently open
        //

        if (*ScbPtr == NULL)
            continue;

        SystemFcb = (*ScbPtr)->Fcb;

        //
        //  Skip the root index and volume dasd for backwards compatibility.
        //

        if (SystemFcb == NULL ||
            ScbPtr == &Vcb->RootIndexScb ||
            ScbPtr == &Vcb->VolumeDasdScb) {

            continue;

        }

        //
        //  Initialize the Fcb and load the security descriptor.
        //

        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, SystemFcb, NULL );

        //
        //  Skip this Fcb if we've already given it an Id or if it has no
        //  security whatsoever.
        //

        if (SystemFcb->SecurityId != SECURITY_ID_INVALID ||
            SystemFcb->SharedSecurity == NULL) {

            continue;

        }

        //
        //  Delete the $SECURITY_DESCRIPTOR attribute if it has one
        //

        NtfsInitializeAttributeContext( &Context );

        try {

            //
            //  Find the $SECURITY_DESCRIPTOR attribute.
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                                 SystemFcb,
                                                 &SystemFcb->FileReference,
                                                 $SECURITY_DESCRIPTOR,
                                                 &Context )) {

                UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );
                PSCB Scb;

                DebugTrace( 0, DbgAcl, ("NtfsUpgradeSecurity deleting existing Security Descriptor\n") );

                NtfsDeleteAttributeRecord( IrpContext,
                                           SystemFcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &Context );

                //
                //  If the $SECURITY_DESCRIPTOR was non resident, the above
                //  delete call created one for us under the covers.  We
                //  need to mark it as deleted otherwise, we detect the
                //  volume as being corrupt.
                //

                Scb = NtfsCreateScb( IrpContext,
                                     SystemFcb,
                                     $SECURITY_DESCRIPTOR,
                                     &NoName,
                                     TRUE,
                                     NULL );

                if (Scb != NULL) {
                    ASSERT_EXCLUSIVE_SCB( Scb );
                    SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                }
            }

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Make sure we have a large $STANDARD_INFORMATION for this file
        //

        if (!FlagOn( SystemFcb->FcbState, FCB_STATE_LARGE_STD_INFO ) ) {

            DebugTrace( 0, DbgAcl, ("NtfsUpgradeSecurity growing standard information\n") );

            NtfsGrowStandardInformation( IrpContext, SystemFcb );
        }

        //
        //  Assign a security Id if we don't have one already
        //

        if (SystemFcb->SharedSecurity->Header.HashKey.SecurityId == SECURITY_ID_INVALID) {

            NtfsAcquireFcbSecurity( Vcb );
            try {
                GetSecurityIdFromSecurityDescriptorUnsafe( IrpContext, SystemFcb->SharedSecurity );
            } finally {
                NtfsReleaseFcbSecurity( Vcb );
            }
            ASSERT( SystemFcb->SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID );
        }

        //
        //  Copy the security Id into the Fcb so we can store it out
        //

        SystemFcb->SecurityId = SystemFcb->SharedSecurity->Header.HashKey.SecurityId;

        //
        //  Update the $STANDARD_INFORMATION for the operation
        //

        NtfsUpdateStandardInformation( IrpContext, SystemFcb );

    }

}


//
//  Local support routine
//

VOID
NtfsInitializeExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the $Extend directory by file number, and fills in the
    related pointers in the Vcb.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    struct {
        FILE_NAME FileName;
        WCHAR FileNameChars[10];
    } FileNameAttr;
    PFCB Fcb;
    PFCB PreviousFcb = NULL;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    FILE_REFERENCE FileReference;
    PBCB FileRecordBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG FileRecordOffset;
    UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );

    UNICODE_STRING ExtendName;
    PFILE_NAME ExtendFileNameAttr;
    USHORT ExtendFileNameAttrLength;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    PSTANDARD_INFORMATION StandardInformation;
    ULONG CorruptHint;

    //
    //  Initialize with the known FileReference and name.
    //

    FileReference = ExtendFileReference;

    //
    //  Now create the Fcb.
    //

    Fcb = NtfsCreateFcb( IrpContext,
                         Vcb,
                         FileReference,
                         FALSE,
                         TRUE,
                         NULL );

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    //
    //  Get ready for some attribute lookups/creates.
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check to see if there is an existing $Extend entry in the root.
        //

        RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
        RtlCopyMemory( FileNameAttr.FileName.FileName, NtfsExtendName.Buffer, NtfsExtendName.Length );

        ExtendName.MaximumLength = ExtendName.Length = NtfsExtendName.Length;
        ExtendName.Buffer = FileNameAttr.FileName.FileName;

        ExtendFileNameAttr = (PFILE_NAME) &FileNameAttr;
        ExtendFileNameAttrLength = sizeof( FileNameAttr );

        if (NtfsLookupEntry( IrpContext,
                             Vcb->RootIndexScb,
                             TRUE,
                             &ExtendName,
                             &ExtendFileNameAttr,
                             &ExtendFileNameAttrLength,
                             NULL,
                             &IndexEntry,
                             &IndexEntryBcb,
                             NULL )) {

            //
            //  If this is not for file record 11 then we want to orphan this entry.
            //  The user will have to use chkdsk to recover to a FOUND directory.
            //

            if (NtfsSegmentNumber( &IndexEntry->FileReference ) != EXTEND_NUMBER) {

                //
                //  Now create the Fcb for the previous link.
                //

                PreviousFcb = NtfsCreateFcb( IrpContext,
                                             Vcb,
                                             IndexEntry->FileReference,
                                             FALSE,
                                             FALSE,
                                             NULL );

                ExtendName.Buffer = ((PFILE_NAME) NtfsFoundIndexEntry( IndexEntry ))->FileName;
                NtfsRemoveLink( IrpContext,
                                PreviousFcb,
                                Vcb->RootIndexScb,
                                ExtendName,
                                NULL,
                                NULL );
            }
        }

        //
        //  We better not be trying to deallocate the file name attribute on the stack.
        //

        ASSERT( ExtendFileNameAttr == (PFILE_NAME) &FileNameAttr );

        //
        //  Reinitialize the file name attribute for the FileRecord fixup.
        //

        //
        //  If this file still has an unnamed data attribute from format, delete it.
        //

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &FileReference,
                                       $DATA,
                                       &NoName,
                                       NULL,
                                       FALSE,
                                       &Context ) ) {

            NtfsDeleteAttributeRecord( IrpContext,
                                       Fcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &Context );
        }

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  Capture the standard information values in the Fcb and set the file name index
        //  flag if necessary.
        //

        NtfsInitializeAttributeContext( &Context );
        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &FileReference,
                                        $STANDARD_INFORMATION,
                                        &Context )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &FileReference, NULL );
        }

        //
        //  Check that the $Extend file record is valid.
        //

        if (!NtfsCheckFileRecord( Vcb, NtfsContainingFileRecord( &Context ), &FileReference, &CorruptHint)) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &FileReference, NULL );
        }

        //
        //  Copy the existing standard information into the Fcb and set the file name
        //  index flag.
        //

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

        Fcb->Info.CreationTime = StandardInformation->CreationTime;
        Fcb->Info.LastModificationTime = StandardInformation->LastModificationTime;
        Fcb->Info.LastChangeTime = StandardInformation->LastChangeTime;
        Fcb->Info.LastAccessTime = StandardInformation->LastAccessTime;
        Fcb->CurrentLastAccess = Fcb->Info.LastAccessTime;
        Fcb->Info.FileAttributes = StandardInformation->FileAttributes;
        NtfsCleanupAttributeContext( IrpContext, &Context );

        SetFlag( Fcb->Info.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );

        //
        //  If the name isn't there yet, add it.
        //

        NtfsInitializeAttributeContext( &Context );
        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &FileReference,
                                        $FILE_NAME,
                                        &Context )) {

            UCHAR FileNameFlags;

            //
            //  Update the file name attribute for the create.
            //

            RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
            FileNameAttr.FileName.FileNameLength = NtfsExtendName.Length/2;
            RtlCopyMemory( FileNameAttr.FileName.FileName, NtfsExtendName.Buffer, NtfsExtendName.Length );

            NtfsAddLink( IrpContext,
                         TRUE,
                         Vcb->RootIndexScb,
                         Fcb,
                         (PFILE_NAME)&FileNameAttr,
                         NULL,
                         &FileNameFlags,
                         NULL,
                         NULL,
                         NULL );
        }

        //
        //  Now see if the file name index is there, and if not create it.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsInitializeAttributeContext( &Context );

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &FileReference,
                                        $INDEX_ROOT,
                                        &Context ) ) {

            NtfsCreateIndex( IrpContext,
                             Fcb,
                             $FILE_NAME,
                             COLLATION_FILE_NAME,
                             Vcb->DefaultBytesPerIndexAllocationBuffer,
                             (UCHAR)Vcb->DefaultBlocksPerIndexAllocationBuffer,
                             NULL,
                             0,
                             TRUE,
                             TRUE );

            //
            //  We have to set the index present bit, so read it, save the old data
            //  and set the flag here.
            //

            NtfsPinMftRecord( IrpContext,
                              Vcb,
                              &FileReference,
                              FALSE,
                              &FileRecordBcb,
                              &FileRecord,
                              &FileRecordOffset );

            //
            //  We have to be very careful when using the InitialzeFileRecordSegment
            //  log record.  This action is applied unconditionally.  DoAction doesn't
            //  check the previous LSN in the page.  It may be garbage on a newly initialized
            //  file record.  We log the entire file record to avoid the case where we
            //  might overwrite a later Lsn with this earlier Lsn during restart.
            //

            //
            //  Log the existing file record as the undo action.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            Noop,
                                            NULL,
                                            0,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  Now update the record in place.
            //

            SetFlag( FileRecord->Flags, FILE_FILE_NAME_INDEX_PRESENT );

            //
            //  Log the new file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  Reload it so we can pass the attribute when initializing the Scb.
            //

            NtfsCleanupAttributeContext( IrpContext, &Context );
            NtfsInitializeAttributeContext( &Context );

            NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &FileReference,
                                       $INDEX_ROOT,
                                       &Context );
        }

        //
        //  Initialize the Fcb and load the security descriptor.
        //

        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, Fcb, NULL );

        if (Fcb->SharedSecurity == NULL) {

            NtfsLoadSecurityDescriptor( IrpContext, Fcb );
        }

        ASSERT( Fcb->SharedSecurity != NULL );

        //
        //  Now create its Scb and store it.
        //

        Vcb->ExtendDirectory = NtfsCreateScb( IrpContext,
                                              Fcb,
                                              $INDEX_ALLOCATION,
                                              &NtfsFileNameIndex,
                                              FALSE,
                                              NULL );

        NtfsUpdateIndexScbFromAttribute( IrpContext,
                                         Vcb->ExtendDirectory,
                                         NtfsFoundAttribute( &Context ),
                                         TRUE );

        NtfsCreateInternalAttributeStream( IrpContext,
                                           Vcb->ExtendDirectory,
                                           FALSE,
                                           NULL );

        //
        //  Now allocate a buffer to hold the normalized name for $Extend
        //

        Vcb->ExtendDirectory->ScbType.Index.NormalizedName.Buffer = NtfsAllocatePool( PagedPool, 8 * sizeof( WCHAR ) );
        Vcb->ExtendDirectory->ScbType.Index.NormalizedName.MaximumLength =
        Vcb->ExtendDirectory->ScbType.Index.NormalizedName.Length = 8 * sizeof( WCHAR );
        wcsncpy( Vcb->ExtendDirectory->ScbType.Index.NormalizedName.Buffer, L"\\$Extend", 8 );

        Vcb->ExtendDirectory->ScbType.Index.HashValue = 0;
        NtfsConvertNameToHash( Vcb->ExtendDirectory->ScbType.Index.NormalizedName.Buffer,
                               sizeof( WCHAR ),
                               Vcb->UpcaseTable,
                               &Vcb->ExtendDirectory->ScbType.Index.HashValue );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsUnpinBcb( IrpContext, &FileRecordBcb );
        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  If some error caused us to not get the Scb created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (Vcb->ExtendDirectory == NULL) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeQuotaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the quota file, and initializes the quota support.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;

    //
    //  Create/open the quota file in $Extend
    //


    Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsQuotaName, TRUE, TRUE );

    try {

        //
        //  Initialize the Quota subsystem.
        //

        NtfsInitializeQuotaIndex( IrpContext, Fcb, Vcb );

    } finally {

        //
        //  If some error caused him to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeObjectIdFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the object Id table, and initializes Object Ids.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;

    //
    //  Create/open the quota file in $Extend
    //

    Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsObjectIdName, TRUE, TRUE );

    try {

        //
        //  Initialize the Object Id subsystem.
        //

        NtfsInitializeObjectIdIndex( IrpContext, Fcb, Vcb );

    } finally {

        //
        //  If some error caused him to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeReparseFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the mount file table, creating it if it does not exist.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;

    //
    //  Create/open the quota file in $Extend
    //

    Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsMountTableName, TRUE, TRUE );

    try {

        //
        //  Initialize the Object Id subsystem.
        //

        NtfsInitializeReparsePointIndex( IrpContext, Fcb, Vcb );

    } finally {

        //
        //  If some error caused her to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA JournalData
    )

/*++

Routine Description:

    This routine creates/opens the Usn journal, and initializes it.

Arguments:

    Vcb - Pointer to the Vcb for the volume

    CreateIfNotExist - Supplies TRUE if file should be created if it does not
        already exist, or FALSE if file should not be created.

    Restamp - Indicates if we want to restamp the journal.

    JournalData - This is the allocation and delta to use for the journal, unless
        we read it from disk.

Return Value:

    None.

--*/

{
    FILE_REFERENCE PriorFileReference;
    PFCB Fcb = NULL;
    BOOLEAN ReleaseExtend = FALSE;

    PriorFileReference = Vcb->UsnJournalReference;

    try {

        //
        //  Acquire Mft now to preserve locking order
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );

        //
        //  Create/open the USN file in $Extend
        //

        if ( Vcb->UsnJournal) {

            Fcb = Vcb->UsnJournal->Fcb;

            //
            //  Acquire in canonical order
            //

            NtfsAcquireExclusiveScb( IrpContext, Vcb->UsnJournal );

        } else {

            NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
            ReleaseExtend = TRUE;

            Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsUsnJrnlName, FALSE, CreateIfNotExist );

    #ifdef NTFSDBG

            //
            //  Compensate for misclassification of usnjournal during real create
            //

            if (IrpContext->OwnershipState == NtfsOwns_ExVcb_Mft_Extend_File) {
                IrpContext->OwnershipState = NtfsOwns_ExVcb_Mft_Extend_Journal;
            }
    #endif

        }

        //
        //  We are done if it is not there.
        //

        if (Fcb != NULL) {

            Vcb->UsnJournalReference = Fcb->FileReference;

            //
            //  If we only want to open an existing journal then this is mount.  Make sure
            //  to note that there is a journal on the disk.  We can't depend on the next
            //  call to succeed in that case.
            //

            if (!CreateIfNotExist) {

                ASSERT( (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                        (IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) );

                SetFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_PRESENT );
            }

            //
            //  Open or create the the Usn Journal.
            //

            NtfsSetupUsnJournal( IrpContext, Vcb, Fcb, CreateIfNotExist, Restamp, JournalData );
        }

    } finally {

        if (ReleaseExtend) {
            NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory );
        }

        NtfsReleaseScb( IrpContext, Vcb->MftScb );

        if (AbnormalTermination()) {
            Vcb->UsnJournalReference = PriorFileReference;
        }
    }
}


//
//  Local Support Routine
//

NTSTATUS
NtfsQueryRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the query retrieval pointers operation.
    It returns the retrieval pointers for the specified input
    file from the start of the file to the request map size specified
    in the input buffer.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PLONGLONG RequestedMapSize;
    PLONGLONG *MappingPairs;

    PVOID RangePtr;
    ULONG Index;
    ULONG i;
    LONGLONG SectorCount;
    LONGLONG Lbo;
    LONGLONG Vbo;
    LONGLONG Vcn;
    LONGLONG MapSize;

    //
    //  Always make this synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Only Kernel mode clients may query retrieval pointer information about
    //  a file, and then only the paging file.  Ensure that this is the case
    //  for this caller.
    //

    if (Irp->RequestorMode != KernelMode) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Get the current stack location and extract the input and output
    //  buffer information.  The input contains the requested size of
    //  the mappings in terms of VBO.  The output parameter will receive
    //  a pointer to nonpaged pool where the mapping pairs are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ASSERT( IrpSp->Parameters.FileSystemControl.InputBufferLength == sizeof(LARGE_INTEGER) );
    ASSERT( IrpSp->Parameters.FileSystemControl.OutputBufferLength == sizeof(PVOID) );

    RequestedMapSize = (PLONGLONG)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    MappingPairs = (PLONGLONG *)Irp->UserBuffer;

    //
    //  Decode the file object and assert that it is the paging file
    //
    //

    (VOID)NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Scb
    //

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Check if the mapping the caller requested is too large
        //

        if (*RequestedMapSize > Scb->Header.FileSize.QuadPart) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  Now get the index for the mcb entry that will contain the
        //  callers request and allocate enough pool to hold the
        //  output mapping pairs.
        //

        //
        //  Compute the Vcn which contains the byte just before the offset size
        //  passed in.
        //

        MapSize = *RequestedMapSize - 1;

        if (*RequestedMapSize == 0) {

            Index = 0;

        } else {

            Vcn = Int64ShraMod32( MapSize, Vcb->ClusterShift );
            (VOID)NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, NULL, NULL, NULL, NULL, &RangePtr, &Index );
        }

        *MappingPairs = NtfsAllocatePool( NonPagedPool, (Index + 2) * (2 * sizeof(LARGE_INTEGER)) );

        //
        //  Now copy over the mapping pairs from the mcb
        //  to the output buffer.  We store in [sector count, lbo]
        //  mapping pairs and end with a zero sector count.
        //

        MapSize = *RequestedMapSize;

        i = 0;

        if (MapSize != 0) {

            for (; i <= Index; i += 1) {

                (VOID)NtfsGetNextNtfsMcbEntry( &Scb->Mcb, &RangePtr, i, &Vbo, &Lbo, &SectorCount );

                SectorCount = LlBytesFromClusters( Vcb, SectorCount );

                if (SectorCount > MapSize) {
                    SectorCount = MapSize;
                }

                (*MappingPairs)[ i*2 + 0 ] = SectorCount;
                (*MappingPairs)[ i*2 + 1 ] = LlBytesFromClusters( Vcb, Lbo );

                MapSize = MapSize - SectorCount;
            }
        }

        (*MappingPairs)[ i*2 + 0 ] = 0;

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsQueryRetrievalPointers );

        //
        //  Release all of our resources
        //

        NtfsReleaseScb( IrpContext, Scb );

        //
        //  If this is an abnormal termination then undo our work, otherwise
        //  complete the irp
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the compression state of the opened file/directory

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PUSHORT CompressionState;

    PAGED_CODE();

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the compressed state of the file/directory.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in th
    //  irp first.  Then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        CompressionState = Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        CompressionState = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (CompressionState == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the file isn't compressed
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(USHORT)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *CompressionState = 0;

    //
    //  Decode the file object
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire shared access to the Scb
    //

    NtfsAcquireSharedScb( IrpContext, Scb );

    //
    //  If this is the index allocation Scb and it has not been initialized then
    //  lookup the index root and perform the initialization.
    //

    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
        (Scb->ScbType.Index.BytesPerIndexBuffer == 0)) {

        ATTRIBUTE_ENUMERATION_CONTEXT Context;

        NtfsInitializeAttributeContext( &Context );

        //
        //  Use a try-finally to perform cleanup.
        //

        try {

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Scb->Fcb,
                                            &Scb->Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &Context )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            NtfsUpdateIndexScbFromAttribute( IrpContext,
                                             Scb,
                                             NtfsFoundAttribute( &Context ),
                                             FALSE );

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &Context );

            if (AbnormalTermination()) { NtfsReleaseScb( IrpContext, Scb ); }
        }
    }

    //
    //  Return the compression state and the size of the returned data.
    //

    *CompressionState = (USHORT)(Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);
    if (*CompressionState != 0) {
        *CompressionState += 1;
    }

    Irp->IoStatus.Information = sizeof( USHORT );

    //
    //  Release all of our resources
    //

    NtfsReleaseScb( IrpContext, Scb );

    //
    //  If this is an abnormal termination then undo our work, otherwise
    //  complete the irp
    //

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

VOID
NtfsChangeAttributeCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVCB Vcb,
    IN PCCB Ccb,
    IN USHORT CompressionState
    )

/*++

Routine Description:

    This routine changes the compression state of an attribute on disk,
    from not compressed to compressed, or visa versa.

    To turn compression off, the caller must already have the Scb acquired
    exclusive, and guarantee that the entire file is not compressed.

Arguments:

    Scb - Scb for affected stream

    Vcb - Vcb for volume

    Ccb - Ccb for the open handle

    CompressionState - 0 for no compression or nonzero for Rtl compression code - 1

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG AttributeSizeChange;
    ULONG OriginalFileAttributes;
    UCHAR OriginalCompressionUnitShift;
    ULONG OriginalCompressionUnit;

    PFCB Fcb = Scb->Fcb;

    ULONG NewCompressionUnit;
    UCHAR NewCompressionUnitShift;

    PAGED_CODE( );

    //
    //  Prepare to lookup and change attribute.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    ASSERT( (Scb->Header.PagingIoResource == NULL) ||
            (IrpContext->CleanupStructure == Fcb) ||
            (IrpContext->CleanupStructure == Scb) );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    OriginalFileAttributes = Fcb->Info.FileAttributes;
    OriginalCompressionUnitShift = Scb->CompressionUnitShift;
    OriginalCompressionUnit = Scb->CompressionUnit;

    //
    //  Capture the ccb source information.
    //

    if (Ccb != NULL) {

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;
    }

    try {

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_COMPRESSION_CHANGE );

        //
        //  Lookup the attribute and pin it so that we can modify it.
        //

        if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
            (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

            //
            //  Lookup the attribute record from the Scb.
            //

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
            }

        } else {

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
        }

        NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );

        Attribute = NtfsFoundAttribute( &AttrContext );

        if ((CompressionState != 0) &&
            !NtfsIsAttributeResident(Attribute) &&
            !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            LONGLONG Temp;
            ULONG CompressionUnitInClusters;

            //
            //  If we are turning compression on, then we need to fill out the
            //  allocation of the compression unit containing file size, or else
            //  it will be interpreted as compressed when we fault it in.  This
            //  is peanuts compared to the dual copies of clusters we keep around
            //  in the loop below when we rewrite the file.  We don't do this
            //  work if the file is sparse because the allocation has already
            //  been rounded up.
            //

            CompressionUnitInClusters =
              ClustersFromBytes( Vcb, Vcb->BytesPerCluster << NTFS_CLUSTERS_PER_COMPRESSION );

            Temp = LlClustersFromBytes(Vcb, Scb->Header.AllocationSize.QuadPart);

            //
            //  If FileSize is not already at a cluster boundary, then add
            //  allocation.
            //

            if ((ULONG)Temp & (CompressionUnitInClusters - 1)) {

                NtfsAddAllocation( IrpContext,
                                   NULL,
                                   Scb,
                                   Temp,
                                   CompressionUnitInClusters - ((ULONG)Temp & (CompressionUnitInClusters - 1)),
                                   FALSE,
                                   NULL );

                if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                    Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                    SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                }

                NtfsWriteFileSizes( IrpContext,
                                    Scb,
                                    &Scb->Header.ValidDataLength.QuadPart,
                                    FALSE,
                                    TRUE,
                                    TRUE );

                //
                //  The attribute may have moved.  We will cleanup the attribute
                //  context and look it up again.
                //

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
                NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
                Attribute = NtfsFoundAttribute( &AttrContext );
            }
        }

        //
        //  Remember the current compression values.
        //

        NewCompressionUnit = Scb->CompressionUnit;
        NewCompressionUnitShift = Scb->CompressionUnitShift;

        //
        //  If the attribute is resident, copy it here and remember its
        //  header size.
        //

        if (NtfsIsAttributeResident(Attribute)) {

            RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

            AttributeSizeChange = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

            //
            //  Set the correct compression unit but only for data streams.  We
            //  don't want to change this value for the Index Root.
            //

            if (NtfsIsTypeCodeCompressible( Attribute->TypeCode ) &&
                !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                if (CompressionState != 0) {

                    NewCompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                    NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                } else {

                    NewCompressionUnit = 0;
                    NewCompressionUnitShift = 0;
                }
            }

        //
        //  Else if it is nonresident, copy it here, set the compression parameter,
        //  and remember its size.
        //

        } else {

            AttributeSizeChange = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeSizeChange = Attribute->NameOffset;
            }

            RtlCopyMemory( &NewAttribute, Attribute, AttributeSizeChange );

            //
            //  The compression numbers are already correct if the file is compressed.
            //

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                if (CompressionState != 0) {

                    NewAttribute.Form.Nonresident.CompressionUnit = NTFS_CLUSTERS_PER_COMPRESSION;
                    NewCompressionUnit = Vcb->BytesPerCluster << NTFS_CLUSTERS_PER_COMPRESSION;
                    NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                } else {

                    NewAttribute.Form.Nonresident.CompressionUnit = 0;
                    NewCompressionUnit = 0;
                    NewCompressionUnitShift = 0;
                }
            }

            ASSERT((NewCompressionUnit == 0) ||
                   (Scb->AttributeTypeCode == $INDEX_ALLOCATION) ||
                   NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));
        }

        //
        //  Turn compression on/off.
        //

        NewAttribute.Flags = Scb->AttributeFlags & ~ATTRIBUTE_FLAG_COMPRESSION_MASK;
        SetFlag( NewAttribute.Flags, CompressionState );

        //
        //  Now, log the changed attribute.
        //

        (VOID)NtfsWriteLog( IrpContext,
                            Vcb->MftScb,
                            NtfsFoundBcb(&AttrContext),
                            UpdateResidentValue,
                            &NewAttribute,
                            AttributeSizeChange,
                            UpdateResidentValue,
                            Attribute,
                            AttributeSizeChange,
                            NtfsMftOffset( &AttrContext ),
                            PtrOffset(NtfsContainingFileRecord(&AttrContext), Attribute),
                            0,
                            Vcb->BytesPerFileRecordSegment );

        //
        //  Change the attribute by calling the same routine called at restart.
        //

        NtfsRestartChangeValue( IrpContext,
                                NtfsContainingFileRecord(&AttrContext),
                                PtrOffset(NtfsContainingFileRecord(&AttrContext), Attribute),
                                0,
                                &NewAttribute,
                                AttributeSizeChange,
                                FALSE );

        //
        //  If this is the main stream for a file we want to change the file attribute
        //  for this stream in both the standard information and duplicate
        //  information structure.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

            if (CompressionState != 0) {

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );

            } else {

                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
            }

            ASSERTMSG( "conflict with flush",
                       ExIsResourceAcquiredSharedLite( Fcb->Resource ) ||
                       (Fcb->PagingIoResource != NULL &&
                        ExIsResourceAcquiredSharedLite( Fcb->PagingIoResource )));

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        //
        //  Now lets add or remove the total allocated field in the attribute
        //  header.  Add if going to uncompressed, non-sparse.  Remove if going
        //  to compressed and non-sparse.
        //

        if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            NtfsSetTotalAllocatedField( IrpContext, Scb, CompressionState );
        }

        //
        //  At this point we will change the compression unit in the Scb.
        //

        Scb->CompressionUnit = NewCompressionUnit;
        Scb->CompressionUnitShift = NewCompressionUnitShift;

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb );
            ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        //
        //  Checkpoint the transaction now to secure this change.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update the FastIoField.
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    //
    //  Cleanup on the way out.
    //

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  If this requests aborts then we want to back out any changes to the
        //  in-memory structures.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = OriginalFileAttributes;
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            Scb->CompressionUnitShift = OriginalCompressionUnitShift;
            Scb->CompressionUnit = OriginalCompressionUnit;
        }

        //
        //  This routine is self contained - it commits a transaction and we don't
        //  want to leave with anything extra acquired
        //

        NtfsReleaseScb( IrpContext, Scb );
    }
}


//
//  Local Support Routine
//

NTSTATUS
NtfsSetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine compresses or decompresses an entire stream in place,
    by walking through the stream and forcing it to be written with the
    new compression parameters.  As it writes the stream it sets a flag
    in the Scb to tell NtfsCommonWrite to delete all allocation at the
    outset, to force the space to be reallocated.

Arguments:

    Irp - Irp describing the compress or decompress change.

Return Value:

    NSTATUS - Status of the request.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PUSHORT CompressionStatePtr;

    PFILE_OBJECT FileObject;
    LONGLONG FileOffset;
    LONGLONG ByteCount;
    USHORT CompressionState = 0;
    BOOLEAN PagingIoAcquired = FALSE;
    BOOLEAN FsRtlHeaderLocked = FALSE;
    ULONG ScbRestoreState = SCB_STATE_WRITE_COMPRESSED;
    IO_STATUS_BLOCK Iosb;
    PMDL ReadMdl;
    PMDL WriteMdl;

    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE( );

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the compressed state of the file/directory.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;
    CompressionStatePtr = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Make sure the input buffer is big enough
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(USHORT)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Decode the file object. We don't care to raise on dismounts here
    //  because we check for that further down anyway. So send FALSE.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen)) ||
        FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  See if we are compressing, and only accept the default case or
    //  lznt1.
    //

    if (*CompressionStatePtr != 0) {

        if ((*CompressionStatePtr == COMPRESSION_FORMAT_DEFAULT) ||
            (*CompressionStatePtr == COMPRESSION_FORMAT_LZNT1)) {

            CompressionState = COMPRESSION_FORMAT_LZNT1 - 1;

            //
            //  Check that we can compress on this volume.
            //

            if (!FlagOn( Vcb->AttributeFlagsMask, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                return STATUS_INVALID_DEVICE_REQUEST;
            }

        } else {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    try {

        //
        //  We now want to acquire the Scb to check if we can continue.
        //

        if (Scb->Header.PagingIoResource != NULL) {

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
            PagingIoAcquired = TRUE;
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  compression not allowed on encrypted streams - this mirrors
        //  the error code efs gives for this kind of attempt - initially we
        //  precall efs to weed these out but that still leaves a race that this
        //  plugs
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

            try_return( Status = STATUS_INVALID_DEVICE_REQUEST );
        }

        //
        //  Handle the simple directory case here.
        //

        if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
            (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

            NtfsChangeAttributeCompression( IrpContext, Scb, Vcb, Ccb, CompressionState );

            ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );
            SetFlag( Scb->AttributeFlags, CompressionState );

            try_return( Status = STATUS_SUCCESS );
        }

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
        }

        //
        //  Set the WRITE_ACCESS_SEEN flag so that we will enforce the
        //  reservation strategy.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN )) {

            LONGLONG ClusterCount;

            NtfsAcquireReservedClusters( Vcb );

            //
            //  Does this Scb have reserved space that causes us to exceed the free
            //  space on the volume?
            //

            ClusterCount = LlClustersFromBytesTruncate( Vcb, Scb->ScbType.Data.TotalReserved );

            if ((Scb->ScbType.Data.TotalReserved != 0) &&
                ((ClusterCount + Vcb->TotalReserved) > Vcb->FreeClusters)) {

                NtfsReleaseReservedClusters( Vcb );

                try_return( Status = STATUS_DISK_FULL );
            }

            //
            //  Otherwise tally in the reserved space now for this Scb, and
            //  remember that we have seen write access.
            //

            Vcb->TotalReserved += ClusterCount;
            SetFlag( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN );

            NtfsReleaseReservedClusters( Vcb );
        }

        //
        //  If this is the first pass through SetCompression we need to set this
        //  request up as the top-level change compression operation.  This means
        //  setting the REALLOCATE_ON_WRITE flag, changing the attribute state
        //  and putting the SCB_STATE_WRITE_COMPRESSED flag in the correct state.
        //

        if (NextIrpSp->Parameters.FileSystemControl.OutputBufferLength == MAXULONG) {

            //
            //  If the REALLOCATE_ON_WRITE flag is set it means that someone is
            //  already changing the compression state.  Return STATUS_SUCCESS in
            //  that case.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE )) {

                try_return( Status = STATUS_SUCCESS );
            }

            //
            //  If we are turning off compression and the file is uncompressed then
            //  we can just get out.
            //

            if ((CompressionState == 0) && ((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) == 0)) {

                try_return( Status = STATUS_SUCCESS );
            }

            //
            //  If we are compressing, change the compressed state now.
            //

            if (CompressionState != 0) {

                //
                //  See if we have to create an internal attribute stream.  Do this first even though
                //  we don't need it for the next operation.  We want to find out if we can't
                //  create the stream object (maybe the file is so large mm can't cache it) before
                //  changing the compression state.  Otherwise the user will never be able to
                //  access the file.
                //

                if (Scb->FileObject == NULL) {
                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );
                }

                NtfsChangeAttributeCompression( IrpContext, Scb, Vcb, Ccb, CompressionState );
                Scb->AttributeFlags = (USHORT)((Scb->AttributeFlags & ~ATTRIBUTE_FLAG_COMPRESSION_MASK) |
                                               CompressionState);
                SetFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );

            //
            //  Otherwise, we must clear the compress flag in the Scb to
            //  start writing decompressed.
            //

            } else {

                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
            }

            //
            //  Set ourselves up as the top level request.
            //

            SetFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
            NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
            NextIrpSp->Parameters.FileSystemControl.InputBufferLength = 0;

        //
        //  If we are turning off compression and the file is uncompressed then
        //  we can just get out.  Even if we raised while decompressing.  If
        //  the state is now uncompressed then we have committed the change.
        //

        } else if (CompressionState == 0) {

            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ));

            //
            //  If the flag is set then make sure to start back at offset zero in
            //  the file.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED )) {

                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
                NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
                NextIrpSp->Parameters.FileSystemControl.InputBufferLength = 0;
            }

            if ((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) == 0) {

                try_return( Status = STATUS_SUCCESS );
            }
        }

        //
        //  In the Fsd entry we clear the following two parameter fields in the Irp,
        //  and then we update them to our current position on all abnormal terminations.
        //  That way if we get a log file full, we only have to resume where we left
        //  off.
        //

        ((PLARGE_INTEGER)&FileOffset)->LowPart = NextIrpSp->Parameters.FileSystemControl.OutputBufferLength;
        ((PLARGE_INTEGER)&FileOffset)->HighPart = NextIrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        //  Make sure to flush and purge the compressed stream if present.
        //

#ifdef  COMPRESS_ON_WIRE
        if (Scb->Header.FileObjectC != NULL) {

            PCOMPRESSION_SYNC CompressionSync = NULL;

            //
            //  Use a try-finally to clean up the compression sync.
            //

            try {

                Status = NtfsSynchronizeUncompressedIo( Scb,
                                                        NULL,
                                                        0,
                                                        TRUE,
                                                        &CompressionSync );

            } finally {

                NtfsReleaseCompressionSync( CompressionSync );
            }

            NtfsNormalizeAndCleanupTransaction( IrpContext, &Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

            NtfsDeleteInternalAttributeStream( Scb, TRUE, TRUE );
            ASSERT( Scb->Header.FileObjectC == NULL );
        }
#endif

        //
        //  If the stream is resident there is no need rewrite any of the data.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            //
            //  Release all of the files held by this Irp Context.  The Mft
            //  may have been grabbed to make space for the TotalAllocated field.
            //  This will automatically also release the pageingio
            //

            ASSERT(IrpContext->TransactionId == 0);
            NtfsReleaseAllResources( IrpContext );
            PagingIoAcquired = FALSE;

            while (TRUE) {

                //
                //  We must throttle our writes.
                //

                CcCanIWrite( FileObject, 0x40000, TRUE, FALSE );

                //
                //  Lock the FsRtl header so we can freeze FileSize.
                //  Acquire paging io exclusive if uncompressing so
                //  we can guarantee that all of the pages get written
                //  before we mark the file as uncompressed.  Otherwise a
                //  a competing LazyWrite in a range may block after
                //  going through Mm and Mm will report to this routine
                //  that the flush has occurred.
                //

                if (CompressionState == 0) {

                    ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );

                } else {

                    ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );
                }

                FsRtlLockFsRtlHeader( &Scb->Header );
                IrpContext->CleanupStructure = Scb;
                FsRtlHeaderLocked = TRUE;

                //
                //  Also check if the volume is mounted.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    try_return( Status = STATUS_VOLUME_DISMOUNTED );
                }

                //
                //  Jump out right here if the attribute is resident.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {
                    break;
                }

                //
                //  Let's round the file offset down to a sparse unit boundary to
                //  clean up the sparse file support.
                //

                if (Scb->CompressionUnit != 0) {

                    ((PLARGE_INTEGER)&FileOffset)->LowPart &= ~(Vcb->SparseFileUnit - 1);
                }

                //
                //  See if we have to create an internal attribute stream.  We do
                //  it in the loop, because the Scb must be acquired.
                //

                if (Scb->FileObject == NULL) {
                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );
                }

                //
                //  Loop through the current view looking for deallocated ranges.
                //

                do {

                    //
                    //  Calculate the bytes left in the file to write.
                    //

                    ByteCount = Scb->Header.FileSize.QuadPart - FileOffset;

                    //
                    //  This is how we exit, seeing that we have finally rewritten
                    //  everything.  It is possible that the file was truncated
                    //  between passes through this loop so we test for 0 bytes or
                    //  a negative value.
                    //
                    //  Note that we exit with the Scb still acquired,
                    //  so that we can reliably turn compression off.
                    //

                    if (ByteCount <= 0) {

                        break;
                    }

                    //
                    //  If there is more than our max, then reduce the byte count for this
                    //  pass to our maximum.
                    //

                    if (((ULONG)FileOffset & 0x3ffff) + ByteCount > 0x40000) {

                        ByteCount = 0x40000 - ((ULONG)FileOffset & 0x3ffff);
                    }

                    //
                    //  If the file is sparse then skip any deallocated regions.  Note that
                    //  this is safe even if there are dirty pages in the data section.
                    //  Space will be correctly allocated when the writes occur at some point.
                    //  We are only concerned with ranges that need to be reallocated.
                    //

                    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                        VCN RangeStartVcn;
                        LONGLONG RangeClusterCount;
                        VCN RangeFinalVcn;
                        ULONG RangeByteCount;

                        RangeStartVcn = LlClustersFromBytesTruncate( Vcb, FileOffset );
                        RangeFinalVcn = LlClustersFromBytes( Vcb, FileOffset + ByteCount );

                        //
                        //  Preload the allocation to check for sparse ranges.
                        //

                        NtfsAcquireExclusiveScb( IrpContext, Scb );

                        NtfsPreloadAllocation( IrpContext,
                                               Scb,
                                               RangeStartVcn,
                                               RangeFinalVcn - 1 );

                        do {

                            BOOLEAN IsAllocated;

                            //
                            //  If the current block is allocated then perform
                            //  the compression operation on this range.
                            //

                            IsAllocated = NtfsIsRangeAllocated( Scb,
                                                                RangeStartVcn,
                                                                RangeFinalVcn,
                                                                TRUE,
                                                                &RangeClusterCount );

                            RangeByteCount = BytesFromClusters( Vcb, (ULONG) RangeClusterCount );

                            //
                            //  Remember if the number of bytes to change
                            //  the compression on has shrunk.
                            //
                            if (IsAllocated) {

                                if (ByteCount > RangeByteCount) {
                                    ByteCount = RangeByteCount;
                                }

                                //
                                //  Break out to the outer loop.
                                //

                                break;
                            }

                            //
                            //  Extend ValidDataLength if we the current range leaves no
                            //  gaps.  This will prevent the next write from reallocating
                            //  a previous range in a ZeroData call.
                            //

                            if ((FileOffset + RangeByteCount > Scb->Header.ValidDataLength.QuadPart) &&
                                (FileOffset <= Scb->Header.ValidDataLength.QuadPart)) {

                                Scb->Header.ValidDataLength.QuadPart = FileOffset + RangeByteCount;
                                if (Scb->Header.ValidDataLength.QuadPart > Scb->Header.FileSize.QuadPart) {

                                    Scb->Header.ValidDataLength.QuadPart = Scb->Header.FileSize.QuadPart;
                                }

#ifdef SYSCACHE_DEBUG
                                if (ScbIsBeingLogged( Scb )) {
                                    FsRtlLogSyscacheEvent( Scb, SCE_SETCOMPRESS, SCE_FLAG_SET_VDL, FileOffset, RangeByteCount, Scb->Header.ValidDataLength.QuadPart );
                                }
#endif

                            }

                            //
                            //  If we have found the last requested cluster then break out.
                            //

                            if ((RangeFinalVcn - RangeStartVcn) <= RangeClusterCount) {

                                ByteCount = 0;
                                FileOffset += LlBytesFromClusters( Vcb, RangeFinalVcn - RangeStartVcn );
                                break;

                            //
                            //  The range is not allocated but we need to check whether
                            //  there are any dirty pages in this range.
                            //

                            } else if (NtfsCheckForReservedClusters( Scb,
                                                                     RangeStartVcn,
                                                                     &RangeClusterCount ) &&
                                       (RangeClusterCount < Vcb->SparseFileClusters)) {

                                if (ByteCount > Vcb->SparseFileUnit) {
                                    ByteCount = Vcb->SparseFileUnit;
                                }

                                break;
                            }

                            //
                            //  There is a hole at the current location.  Move
                            //  to the next block to consider.
                            //

                            RangeStartVcn += RangeClusterCount;
                            RangeByteCount = BytesFromClusters( Vcb, (ULONG) RangeClusterCount );
                            ByteCount -= RangeByteCount;
                            FileOffset += RangeByteCount;

                        } while (ByteCount != 0);

                        NtfsReleaseScb( IrpContext, Scb );
                    }

                } while (ByteCount == 0);

                //
                //  Check if have reached the end of the file.
                //  Note that we exit with the Scb still acquired,
                //  so that we can reliably turn compression off.
                //

                if (ByteCount <= 0) {

                    break;
                }

                //
                //  Make sure there are enough available clusters in the range
                //  we want to rewrite.
                //

                NtfsPurgeFileRecordCache( IrpContext );
                if (!NtfsReserveClusters( IrpContext, Scb, FileOffset, (ULONG) ByteCount )) {

                    //
                    //  If this transaction has already deallocated clusters
                    //  then raise log file full to allow those to become
                    //  available.
                    //

                    if (IrpContext->DeallocatedClusters != 0) {

#ifdef PERF_STATS
                        IrpContext->LogFullReason = LF_COMPRESSION;
#endif


                        NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );

                    //
                    //  Otherwise there is insufficient space to guarantee
                    //  we can perform the compression operation.
                    //

                    } else {

                        NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                    }
                }

                //
                //  Map the next range of the file, and make the pages dirty.
                //

#ifdef BENL_DBG
                ASSERT( (FileOffset % Scb->CompressionUnit == 0) && (ByteCount % Scb->CompressionUnit == 0 || FileOffset + ByteCount == Scb->Header.FileSize.QuadPart) );
#endif

                //
                //  Do an empty MDL read and write to lock the range down and set it dirty for the subsequent flushcache
                //

                try {

                    ReadMdl = NULL;
                    WriteMdl = NULL;

                    //
                    //  Page it all in
                    //

                    CcMdlRead( Scb->FileObject, (PLARGE_INTEGER)&FileOffset, (ULONG)ByteCount, &ReadMdl, &Iosb );
                    ASSERT( STATUS_SUCCESS == Iosb.Status );

                    //
                    //  Mark it as modified
                    //

                    CcPrepareMdlWrite( Scb->FileObject, (PLARGE_INTEGER)&FileOffset, (ULONG)ByteCount, &WriteMdl, &Iosb );
                    ASSERT( STATUS_SUCCESS == Iosb.Status );

                } finally {

                    if (WriteMdl) {
                        CcMdlWriteComplete( Scb->FileObject, (PLARGE_INTEGER)&FileOffset, WriteMdl );
                    }
                    if (ReadMdl) {
                        CcMdlReadComplete(  Scb->FileObject, ReadMdl );
                    }
                }

#ifdef SYSCACHE

                //
                //  Clear write mask before the flush
                //

                {
                    PULONG WriteMask;
                    ULONG Len;
                    ULONG Off = (ULONG)FileOffset;

                    WriteMask = Scb->ScbType.Data.WriteMask;
                    if (WriteMask == NULL) {
                        WriteMask = NtfsAllocatePool( NonPagedPool, (((0x2000000) / PAGE_SIZE) / 8) );
                        Scb->ScbType.Data.WriteMask = WriteMask;
                        RtlZeroMemory(WriteMask, (((0x2000000) / PAGE_SIZE) / 8));
                    }

                    if (Off < 0x2000000) {
                        Len = (ULONG)ByteCount;
                        if ((Off + Len) > 0x2000000) {
                            Len = 0x2000000 - Off;
                        }
                        while (Len != 0) {

                            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_SYSCACHE_FILE ) ||
                                    (WriteMask[(Off / PAGE_SIZE)/32] & (1 << ((Off / PAGE_SIZE) % 32))));

                            Off += PAGE_SIZE;
                            if (Len <= PAGE_SIZE) {
                                break;
                            }
                            Len -= PAGE_SIZE;
                        }
                    }
#endif

                //
                //  Now flush these pages to reallocate them.
                //

                Irp->IoStatus.Status = NtfsFlushUserStream( IrpContext,
                                                            Scb,
                                                            &FileOffset,
                                                            (ULONG)ByteCount );

                //
                //  On error get out.
                //

#ifdef PERF_STATS
                if (IrpContext->ExceptionStatus == STATUS_LOG_FILE_FULL) {
                    IrpContext->LogFullReason = LF_RECURSIVE_COMPRESSION;
                }
#endif

                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                    &Irp->IoStatus.Status,
                                                    TRUE,
                                                    STATUS_UNEXPECTED_IO_ERROR );

#ifdef SYSCACHE

                //
                //  Verify writes occurred after the flush
                //

                    Off = (ULONG)FileOffset;

                    WriteMask = Scb->ScbType.Data.WriteMask;

                    if (Off < 0x2000000) {
                        Len = (ULONG)ByteCount;
                        if ((Off + Len) > 0x2000000) {
                            Len = 0x2000000 - Off;
                        }
                        while (Len != 0) {
                            ASSERT(WriteMask[(Off / PAGE_SIZE)/32] & (1 << ((Off / PAGE_SIZE) % 32)));

                            Off += PAGE_SIZE;
                            if (Len <= PAGE_SIZE) {
                                break;
                            }
                            Len -= PAGE_SIZE;
                        }
                    }
                }
#endif

                //
                //  Release any remaing reserved clusters in this range.
                //

                NtfsFreeReservedClusters( Scb, FileOffset, (ULONG) ByteCount );

                //
                //  Advance the FileOffset.
                //

                FileOffset += ByteCount;

                //
                //  If we hit the end of the file then exit while holding the
                //  resource so we can turn compression off.
                //

                if (FileOffset == Scb->Header.FileSize.QuadPart) {

                    break;
                }

                //
                //  Unlock the header an let anyone else access the file before
                //  looping back.
                //

                FsRtlUnlockFsRtlHeader( &Scb->Header );
                ExReleaseResourceLite( Scb->Header.PagingIoResource );
                IrpContext->CleanupStructure = NULL;
                FsRtlHeaderLocked = FALSE;
            }
        }

        //
        //  We have finished the conversion.  Now is the time to turn compression
        //  off.  Note that the compression flag in the Scb is already off.
        //

        if (CompressionState == 0) {

            VCN StartingCluster;

            //
            //  The paging Io resource may already be acquired.
            //

            if (!PagingIoAcquired && !FsRtlHeaderLocked) {
                if (Scb->Header.PagingIoResource != NULL) {
                    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                    PagingIoAcquired = TRUE;
                }
            }

            NtfsAcquireExclusiveScb( IrpContext, Scb );

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            //
            //  Changing the compression state to uncompressed is a ticklish thing.
            //  We need to make sure that all of the compression units are valid for
            //  the entire allocation for the file.  For non-sparse files all compression
            //  units should be fully allocation.  For sparse files all compression
            //  units should be either fully allocated or fully unallocated.  The interesting
            //  case is typically when the file size of a compressed file is dropped but
            //  the allocation remains.  The allocation in that range may be in the compressed
            //  format.  We need to proactively remove it.
            //
            //  In the non-sparse case we have already rewritten the data all the way
            //  through file size.  We only have to remove the allocation past the
            //  cluster containing Eof.
            //
            //  In the sparse case we actually have to deal with allocated ranges
            //  in the range between valid data length and file size as well.  We
            //  didn't rewrite this in the flush path above because we don't want
            //  to allocate clusters for zeroes.
            //
            //  The action of deallocating the clusters past file size must be tied
            //  in with the transaction of flipping the compression state.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  In all cases we can remove the clusters in the compression
                //  units past that containing Eof.
                //

                StartingCluster = BlockAlign( Scb->Header.FileSize.QuadPart, (LONG)Scb->CompressionUnit );

                if (StartingCluster < Scb->Header.AllocationSize.QuadPart) {

                    //
                    //  Deallocate the space past the filesize
                    //

                    NtfsDeleteAllocation( IrpContext,
                                          IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject,
                                          Scb,
                                          LlClustersFromBytesTruncate( Vcb, StartingCluster ),
                                          MAXLONGLONG,
                                          TRUE,
                                          TRUE );
                }

                //
                //  For sparse files we need to handle the allocation between valid data length
                //  and allocation size.
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    //
                    //  Assume that the data up to either ValidDataLength or ValidDataToDisk
                    //  is valid.  Start at the compression unit after that.
                    //

                    StartingCluster = Scb->Header.ValidDataLength.QuadPart;

                    if (Scb->ValidDataToDisk > StartingCluster) {
                        StartingCluster = Scb->ValidDataToDisk;
                    }

                    StartingCluster = BlockAlign( StartingCluster, (LONG)Scb->CompressionUnit );

                    if (StartingCluster < Scb->Header.AllocationSize.QuadPart) {

                        NtfsDeleteAllocation( IrpContext,
                                              IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject,
                                              Scb,
                                              LlClustersFromBytesTruncate( Vcb, StartingCluster ),
                                              LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart ) - 1,
                                              TRUE,
                                              TRUE );
                    }
                }

                //
                //  If total allocated has changed then remember to report it.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    (Scb->Fcb->Info.AllocatedLength != Scb->TotalAllocated)) {

                    Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                    SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                }

                //
                //  Check whether there is more to be truncated when the handle is closed.
                //

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
            }

            NtfsChangeAttributeCompression( IrpContext, Scb, Vcb, Ccb, 0 );
            Scb->AttributeFlags &= (USHORT)~ATTRIBUTE_FLAG_COMPRESSION_MASK;

            //
            //  Reset the VDD since its not used for uncompressed files
            //

            Scb->ValidDataToDisk = 0;

            //
            //  No need to set the WRITE_COMPRESSED flag on error.
            //

            ClearFlag( ScbRestoreState, SCB_STATE_WRITE_COMPRESSED );

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ) &&
                (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ))) {

                if (Scb->ScbType.Data.ReservedBitMap != NULL) {

                    NtfsDeleteReservedBitmap( Scb );
                }
            }

            //
            //  Now clear the REALLOCATE_ON_WRITE flag while holding both resources.
            //

            ClearFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
        }

        //
        //  Unlock the header if we locked it.
        //

        if (FsRtlHeaderLocked) {
            FsRtlUnlockFsRtlHeader( &Scb->Header );
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
            IrpContext->CleanupStructure = NULL;
            FsRtlHeaderLocked = FALSE;
        }

        Status = STATUS_SUCCESS;

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_SETCOMPRESS, 0, Scb->ValidDataToDisk, Scb->Header.ValidDataLength.QuadPart, 0 );
        }
#endif

    try_exit: NOTHING;

        //
        //  Now clear the reallocate flag in the Scb if we set it.
        //

        if (NextIrpSp->Parameters.FileSystemControl.OutputBufferLength != MAXULONG) {

            ClearFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
        }

    } finally {

        DebugUnwind( NtfsSetCompression );

        //
        //  NtfsCompleteRequest will clean up the Fsrtl header but
        //  we still need to release the paging resource if held.
        //

        if (FsRtlHeaderLocked) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            //
            //  If we have started the transformation and are in the exception path
            //  we are either going to continue the operation after a clean
            //  checkpoint or we are done.
            //

            if (NextIrpSp->Parameters.FileSystemControl.OutputBufferLength != MAXULONG) {

                //
                //  If we are continuing the operation, save the current file offset.
                //

                if (IrpContext->ExceptionStatus == STATUS_LOG_FILE_FULL ||
                    IrpContext->ExceptionStatus == STATUS_CANT_WAIT) {

                    NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = (ULONG)FileOffset;
                    NextIrpSp->Parameters.FileSystemControl.InputBufferLength = ((PLARGE_INTEGER)&FileOffset)->HighPart;

                //
                //  Otherwise clear the REALLOCATE_ON_WRITE flag and set the
                //  COMPRESSED flag if needed.
                //

                } else {

                    ClearFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
                    SetFlag( Scb->ScbState, ScbRestoreState );

                    ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
                            (Scb->CompressionUnit != 0) );
                }
            }
        }
    }

    ASSERT( !NT_SUCCESS( Status ) ||
            (CompressionState != 0) ||
            !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
            (Scb->CompressionUnit != 0) );

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsMarkAsSystemHive (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the registry to identify the registry handles.  We
    will mark this in the Ccb and use it during FlushBuffers to know to do a
    careful flush.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Always make this synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Extract and decode the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We only permit this request on files and we must be called from kernel mode.
    //

    if ((Irp->RequestorMode != KernelMode) ||
        (TypeOfOpen != UserFileOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Now acquire the file and mark the Ccb and return SUCCESS.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    SetFlag( Ccb->Flags, CCB_FLAG_SYSTEM_HIVE );

    NtfsReleaseScb( IrpContext, Scb );

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetStatistics (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the filesystem performance counters for the
    volume referred to.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_SYSTEM_STATISTICS Buffer;
    ULONG BufferLength;
    ULONG StatsSize;
    ULONG BytesToCopy;

    PAGED_CODE();

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the performance counters.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract the buffer
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Make sure the buffer is big enough for at least the common part.
    //

    if (BufferLength < sizeof( FILESYSTEM_STATISTICS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Now see how many bytes we can copy.
    //

    StatsSize = sizeof( FILE_SYSTEM_STATISTICS ) * KeNumberProcessors;

    if (BufferLength < StatsSize) {

        BytesToCopy = BufferLength;
        Status = STATUS_BUFFER_OVERFLOW;

    } else {

        BytesToCopy = StatsSize;
        Status = STATUS_SUCCESS;
    }

    //
    //  Decode the file object
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb,
                                       &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen == UnopenedFileObject) {

        Status = STATUS_INVALID_PARAMETER;

    } else {

        //
        //  Fill in the output buffer
        //

        RtlCopyMemory( Buffer, Vcb->Statistics, BytesToCopy );

        Irp->IoStatus.Information = BytesToCopy;
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetVolumeData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    Returns a filled in VOLUME_DATA structure in the user output buffer.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN AcquiredScb = FALSE;
    BOOLEAN AcquiredVcb = FALSE;

    PNTFS_VOLUME_DATA_BUFFER VolumeData;
    PNTFS_EXTENDED_VOLUME_DATA ExtendedBuffer;
    ULONG ExtendedBufferLength;
    ULONG VolumeDataLength;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetVolumeData, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen == UnopenedFileObject) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Get the output buffer length and pointer.
    //

    VolumeDataLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    VolumeData = (PNTFS_VOLUME_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    //
    //  Check for a minimum length on the ouput buffer.
    //

    if (VolumeDataLength < sizeof(NTFS_VOLUME_DATA_BUFFER)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
    AcquiredVcb = TRUE;

    try {

        //
        //  Make sure the volume is still mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Acquire the volume bitmap and fill in the volume data structure.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );
        AcquiredScb = TRUE;

        NtfsReleaseVcb( IrpContext, Vcb );
        AcquiredVcb = FALSE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We may need to rescan the bitmap if there is a chance we have
        //  performed the upgrade to get an accurate count of free clusters.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS ) &&
            FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );
        }

        VolumeData->VolumeSerialNumber.QuadPart = Vcb->VolumeSerialNumber;
        VolumeData->NumberSectors.QuadPart = Vcb->NumberSectors;
        VolumeData->TotalClusters.QuadPart = Vcb->TotalClusters;
        VolumeData->FreeClusters.QuadPart = Vcb->FreeClusters;
        VolumeData->TotalReserved.QuadPart = Vcb->TotalReserved;
        VolumeData->BytesPerSector = Vcb->BytesPerSector;
        VolumeData->BytesPerCluster = Vcb->BytesPerCluster;
        VolumeData->BytesPerFileRecordSegment = Vcb->BytesPerFileRecordSegment;
        VolumeData->ClustersPerFileRecordSegment = Vcb->ClustersPerFileRecordSegment;
        VolumeData->MftValidDataLength = Vcb->MftScb->Header.ValidDataLength;
        VolumeData->MftStartLcn.QuadPart = Vcb->MftStartLcn;
        VolumeData->Mft2StartLcn.QuadPart = Vcb->Mft2StartLcn;
        VolumeData->MftZoneStart.QuadPart = Vcb->MftZoneStart;
        VolumeData->MftZoneEnd.QuadPart = Vcb->MftZoneEnd;

        if (VolumeData->MftZoneEnd.QuadPart > Vcb->TotalClusters) {

            VolumeData->MftZoneEnd.QuadPart = Vcb->TotalClusters;
        }

        //
        //  Check if there is anything to add in the extended data.
        //

        ExtendedBufferLength = VolumeDataLength - sizeof( NTFS_VOLUME_DATA_BUFFER );
        VolumeDataLength = sizeof( NTFS_VOLUME_DATA_BUFFER );
        ExtendedBuffer = (PNTFS_EXTENDED_VOLUME_DATA) Add2Ptr( VolumeData, sizeof( NTFS_VOLUME_DATA_BUFFER ));

        if (ExtendedBufferLength >= sizeof( NTFS_EXTENDED_VOLUME_DATA )) {

            ExtendedBuffer->ByteCount = sizeof( NTFS_EXTENDED_VOLUME_DATA );
            ExtendedBuffer->MajorVersion = Vcb->MajorVersion;
            ExtendedBuffer->MinorVersion = Vcb->MinorVersion;

        } else if (ExtendedBufferLength >= FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MinorVersion )) {

            ExtendedBuffer->ByteCount = FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MinorVersion );
            ExtendedBuffer->MajorVersion = Vcb->MajorVersion;

        } else if (ExtendedBufferLength >= FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MajorVersion )) {

            ExtendedBuffer->ByteCount = FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MajorVersion );

        } else {

            leave;
        }

        VolumeDataLength += ExtendedBuffer->ByteCount;

    } finally {

        if (AcquiredScb) {

            NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
        }

        if (AcquiredVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If nothing raised then complete the irp.
    //

    Irp->IoStatus.Information = VolumeDataLength;

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetVolumeData -> VOID\n") );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetVolumeBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine scans volume bitmap and returns the requested range.

        Input = the GET_BITMAP data structure is passed in through the input buffer.
        Output = the VOLUME_BITMAP data structure is returned through the output buffer.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PSTARTING_LCN_INPUT_BUFFER GetBitmap;
    ULONG GetBitmapLength;

    PVOLUME_BITMAP_BUFFER VolumeBitmap;
    ULONG VolumeBitmapLength;

    ULONG BitsWritten;

    LCN Lcn;
    LCN StartingLcn;
    ULONG Offset;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;
    BOOLEAN AccessingUserBuffer = FALSE;
    BOOLEAN ReleaseScb = FALSE;

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetVolumeBitmap, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object and check for type of open.
    //  Send FALSE to indicate that we don't want to raise on dismounts
    //  because we'll check for that further down anyway.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    //
    //  Get the input & output buffer lengths and pointers.
    //

    GetBitmapLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    GetBitmap = (PSTARTING_LCN_INPUT_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    VolumeBitmapLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    VolumeBitmap = (PVOLUME_BITMAP_BUFFER)NtfsMapUserBuffer( Irp, NormalPagePriority );

    //
    //  Check the type of open and minimum requirements for the IO buffers.
    //

    if ((Ccb == NULL) ||
        !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_ACCESS_DENIED\n") );
        return STATUS_ACCESS_DENIED;

    } else if (VolumeBitmapLength < sizeof( VOLUME_BITMAP_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_BUFFER_TOO_SMALL\n") );
        return STATUS_BUFFER_TOO_SMALL;

    } else if (GetBitmapLength < sizeof( STARTING_LCN_INPUT_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Probe the user's buffers and capture the input values.
    //

    try {

        if (Irp->RequestorMode != KernelMode) {

            ProbeForRead( GetBitmap, GetBitmapLength, sizeof( UCHAR ));
            ProbeForWrite( VolumeBitmap, VolumeBitmapLength, sizeof( UCHAR ));
        }

        StartingLcn = GetBitmap->StartingLcn.QuadPart;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL);
    }

    //
    //  Acquire the volume bitmap and check for a valid requested Lcn.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_VOLUME_DISMOUNTED\n") );
        return STATUS_VOLUME_DISMOUNTED;
    }

    try {

        //
        //  Acquire the volume bitmap and check for a valid requested Lcn.
        //  We no longer care about the Scb we were called with.
        //

        Scb = Vcb->BitmapScb;
        NtfsAcquireSharedScb( IrpContext, Scb );
        NtfsReleaseVcb( IrpContext, Vcb );

        //
        //  Setting this flag to TRUE indicates we have the Scb but not the Vcb.
        //

        ReleaseScb = TRUE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        if ((StartingLcn < 0L) ||
            (StartingLcn >= Vcb->TotalClusters)) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Read in the volume bitmap page by page and copy it into the UserBuffer.
        //

        VolumeBitmapLength -= FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer);

        //
        //  Use a try-except to catch user buffer problems.
        //

        try {

            for (Lcn = StartingLcn, BitsWritten = 0;
                 Lcn < Vcb->TotalClusters;
                 Lcn = Lcn + Bitmap.SizeOfBitMap) {

                ULONG BytesToCopy;

                //
                //  Read in the bitmap page and make sure that we haven't messed up the math.
                //

                DebugTrace( 0, Dbg, ("Mapping bitmap from Lcn %I64x\n", (LONGLONG) Lcn) );

                NtfsUnpinBcb( IrpContext, &BitmapBcb );
                NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &Lcn, &Bitmap, &BitmapBcb );

                //
                //  If this is first iteration, update StartingLcn with actual
                //  starting cluster returned.
                //

                if (BitsWritten == 0) {

                    Offset = (ULONG)(StartingLcn - Lcn) / 8;

                }

                //
                //  Check to see if we have enough user buffer.  If have some but
                //  not enough, copy what we can and return STATUS_BUFFER_OVERFLOW.
                //  If we are down to 0 (i.e. previous iteration used all the
                //  buffer), break right now.
                //

                BytesToCopy = ((Bitmap.SizeOfBitMap + 7) / 8) - Offset;

                if (BytesToCopy > VolumeBitmapLength) {

                    BytesToCopy = VolumeBitmapLength;
                    Status = STATUS_BUFFER_OVERFLOW;

                    if (BytesToCopy == 0) {
                        break;
                    }
                }

                //
                //  Now copy it into the UserBuffer.
                //

                AccessingUserBuffer = TRUE;
                RtlCopyMemory(&VolumeBitmap->Buffer[BitsWritten / 8], (PUCHAR)Bitmap.Buffer + Offset, BytesToCopy);
                AccessingUserBuffer = FALSE;

                //
                //  If this was an overflow, bump up bits written and continue
                //

                if (Status != STATUS_BUFFER_OVERFLOW) {

                    BitsWritten += Bitmap.SizeOfBitMap - (Offset * 8);
                    VolumeBitmapLength -= BytesToCopy;

                } else {

                    BitsWritten += BytesToCopy * 8;
                    break;
                }

                Offset = 0;
            }

            AccessingUserBuffer = TRUE;

            //
            //  Lower StartingLcn to the byte we started on
            //

            VolumeBitmap->StartingLcn.QuadPart = StartingLcn & ~7L;
            VolumeBitmap->BitmapSize.QuadPart = Vcb->TotalClusters - VolumeBitmap->StartingLcn.QuadPart;
            AccessingUserBuffer = FALSE;

            Irp->IoStatus.Information =
                FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer) + (BitsWritten + 7) / 8;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            //
            //  Convert any unexpected error to INVALID_USER_BUFFER if we
            //  are writing in the user's buffer.
            //

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        DebugUnwind( NtfsGetVolumeBitmap );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        if (ReleaseScb) {

            NtfsReleaseScb( IrpContext, Scb );

        } else {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If nothing raised then complete the irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> VOID\n") );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine scans the array of MCBs for the given SCB and builds an extent
    list.  The first run in the output extent list will start at the begining
    of the contiguous run specified by the input parameter.

        Input = STARTING_VCN_INPUT_BUFFER;
        Output = RETRIEVAL_POINTERS_BUFFER.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    VCN Vcn;
    VCN LastVcnInFile;
    LCN Lcn;
    LONGLONG ClusterCount;
    LONGLONG CountFromStartingVcn;
    LONGLONG StartingVcn;

    ULONG FileRunIndex = 0;
    ULONG RangeRunIndex;

    ULONG InputBufferLength;
    ULONG OutputBufferLength;

    PVOID RangePtr;

    PRETRIEVAL_POINTERS_BUFFER OutputBuffer;
    BOOLEAN AccessingUserBuffer = FALSE;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN CleanupAttributeContext = FALSE;


    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsGetRetrievalPointers\n") );

    //
    //  Extract and decode the file object and check for type of open.
    //  If we ever decide to support UserDirectoryOpen also, make sure
    //  to check for Scb->AttributeTypeCode != $INDEX_ALLOCATION when
    //  checking whether the Scb header is initialized.  Otherwise we'll
    //  have trouble with phantom Scbs created for small directories.
    //

    //
    //  Get the input and output buffer lengths and pointers.
    //  Initialize some variables.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    OutputBuffer = (PRETRIEVAL_POINTERS_BUFFER)NtfsMapUserBuffer( Irp, NormalPagePriority );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen) &&
         (TypeOfOpen != UserViewIndexOpen)) ||
        (InputBufferLength < sizeof( STARTING_VCN_INPUT_BUFFER ))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (OutputBufferLength < sizeof( RETRIEVAL_POINTERS_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Acquire exclusive access to the Scb.  We don't want other threads
    //  to extend or move the file while we're trying to return the
    //  retrieval pointers for it.  We need it exclusve to call PreloadAllocation.
    //

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  There are three separate places inside this try/except where we
        //  access the user-supplied buffer.  We want to handle exceptions
        //  differently if they happen while we are trying to access the user
        //  buffer than if they happen elsewhere in the try/except.  We set
        //  this boolean immediately before touching the user buffer, and
        //  clear it immediately after.
        //

        try {

            AccessingUserBuffer = TRUE;
            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              InputBufferLength,
                              sizeof(UCHAR) );

                ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(UCHAR) );
            }

            StartingVcn = ((PSTARTING_VCN_INPUT_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->StartingVcn.QuadPart;

            //
            //  While we have AccessingUserBuffer set to TRUE, let's initialize the
            //  extentcount.  We increment this for each run in the mcb, so we need
            //  to initialize it outside the main do while loop.
            //

            OutputBuffer->ExtentCount = 0;
            OutputBuffer->StartingVcn.QuadPart = 0;
            AccessingUserBuffer = FALSE;

            //
            //  If the Scb is uninitialized, we initialize it now.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                //
                //  Non-index Scb's are trivial to initialize;  index Scb's
                //  do not necessarily have an attribute to back them up:
                //  the index Scb is for the index allocation attribute which
                //  may not be present if the entire index fits in the $INDEX_ROOT.
                //
                //  We look for the attribute on disk.  If it is there, we
                //  update from it.  Otherwise, if it is $INDEX_ALLOCATION we
                //  treat it as a resident attribute.  Finally, we fail it.
                //

                NtfsInitializeAttributeContext( &AttributeContext );
                CleanupAttributeContext = TRUE;

                if (!NtfsLookupAttributeByName( IrpContext,
                                                Scb->Fcb,
                                                &Scb->Fcb->FileReference,
                                                Scb->AttributeTypeCode,
                                                &Scb->AttributeName,
                                                NULL,
                                                FALSE,
                                                &AttributeContext )) {

                    //
                    //  Verify that this is an index allocation attribute.
                    //  If not, raise an error.
                    //

                    if (Scb->AttributeTypeCode != $INDEX_ALLOCATION) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }

                    Irp->IoStatus.Information = 0;
                    Status = STATUS_SUCCESS;
                    leave;

                } else {
                    NtfsUpdateScbFromAttribute( IrpContext,
                                                Scb,
                                                NtfsFoundAttribute( &AttributeContext ));
                }
            }

            //
            //  If the data attribute is resident (typically for a small file),
            //  it is not safe to call NtfsPreloadAllocation.  There won't be
            //  any runs, and we've already set ExtentCount to 0, so we're done.
            //  FAT returns STATUS_END_OF_FILE for a zero-length file, so for
            //  consistency's sake, we'll return that in the resident case.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                Irp->IoStatus.Information = 0;
                Status = STATUS_END_OF_FILE;
                leave;
            }

            //
            //  Check if a starting cluster was specified.
            //

            LastVcnInFile = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart ) - 1;

            if (StartingVcn > LastVcnInFile) {

                //
                //  It's possible that the Vcn we were given is past the end of the file.
                //

                Status = STATUS_END_OF_FILE;
                leave;

            } else if (StartingVcn < 0) {

                //
                //  It's possible that the Vcn we were given is negative, and
                //  NtfsMcbLookupArrayIndex doesn't handle that very well.
                //

                Status = STATUS_INVALID_PARAMETER;
                leave;

            } else {

                //
                //  We need to call NtfsPreloadAllocation to make sure all the
                //  ranges in this NtfsMcb are loaded.
                //

                NtfsPreloadAllocation( IrpContext,
                                       Scb,
                                       StartingVcn,
                                       LastVcnInFile );

                //
                //  Decide which Mcb contains the starting Vcn.
                //

                (VOID)NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                              StartingVcn,
                                              NULL,
                                              &CountFromStartingVcn,
                                              &Lcn,
                                              &ClusterCount,
                                              &RangePtr,
                                              &RangeRunIndex );
            }

            //
            //  Fill in the Vcn where the run containing StartingVcn truly starts.
            //
            AccessingUserBuffer = TRUE;
            OutputBuffer->StartingVcn.QuadPart = Vcn = StartingVcn - (ClusterCount - CountFromStartingVcn);
            AccessingUserBuffer = FALSE;

            //
            //  FileRunIndex is the index of a given run within an entire
            //  file, as opposed to RangeRunIndex which is the index of a
            //  given run within its range.  RangeRunIndex is reset to 0 for
            //  each range, where FileRunIndex is set to 0 once out here.
            //

            FileRunIndex = 0;

            do {

                //
                //  Now copy over the mapping pairs from the mcb
                //  to the output buffer.  We store in [sector count, lbo]
                //  mapping pairs and end with a zero sector count.
                //

                //
                //  Check for an exhausted output buffer.
                //

                if ((ULONG)FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[FileRunIndex+1]) > OutputBufferLength) {

                    //
                    //  We know that we're out of room in the output buffer, so we won't be looking up
                    //  any more runs.  ExtentCount currently reflects how many runs we stored in the
                    //  user buffer, so we can safely quit.  There are indeed ExtentCount extents stored
                    //  in the array, and returning STATUS_BUFFER_OVERFLOW informs our caller that we
                    //  didn't have enough room to return all the runs.
                    //

                    Irp->IoStatus.Information = FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[FileRunIndex]);
                    Status = STATUS_BUFFER_OVERFLOW;
                    leave;
                }

                //
                //  Here's the interesting part -- we fill in the next array element in the ouput buffer
                //  with the current run's information.
                //

                AccessingUserBuffer = TRUE;
                OutputBuffer->Extents[FileRunIndex].NextVcn.QuadPart = Vcn + ClusterCount;
                OutputBuffer->Extents[FileRunIndex].Lcn.QuadPart = Lcn;

                OutputBuffer->ExtentCount += 1;
                AccessingUserBuffer = FALSE;

                FileRunIndex += 1;

                RangeRunIndex += 1;

            } while (NtfsGetSequentialMcbEntry( &Scb->Mcb, &RangePtr, RangeRunIndex, &Vcn, &Lcn, &ClusterCount));

            //
            //  We successfully retrieved extent info to the end of the allocation.
            //

            Irp->IoStatus.Information = FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[FileRunIndex]);
            Status = STATUS_SUCCESS;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        DebugUnwind( NtfsGetRetrievalPointers );

        //
        //  Release resources.
        //

        NtfsReleaseScb( IrpContext, Scb );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        DebugTrace( -1, Dbg, ("NtfsGetRetrievalPointers -> VOID\n") );
    }

    //
    //  If nothing raised then complete the irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns a copy of the requested File Record Segment. A
    hint File Reference Number is passed in. If the hint File Record
    Segment is "not in use" then the MFT bitmap is scanned backwards
    from the hint until an "in use" File Record Segment is found. This
    File Record Segment is then returned along with the identifying File Reference Number.

        Input = the LONGLONG File Reference Number is passed in through the input buffer.
        Output = the FILE_RECORD data structure is returned through the output buffer.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PNTFS_FILE_RECORD_INPUT_BUFFER GetFileRecord;
    ULONG GetFileRecordLength;

    PNTFS_FILE_RECORD_OUTPUT_BUFFER FileRecord;
    ULONG FileRecordLength;

    ULONG FileReferenceNumber;

    PFILE_RECORD_SEGMENT_HEADER MftBuffer;

    PBCB Bcb = NULL;
    PBCB BitmapBcb = NULL;

    BOOLEAN AcquiredMft = FALSE;
    RTL_BITMAP Bitmap;
    LONG BaseIndex;
    LONG Index;
    LONGLONG StartingByte;
    PUCHAR BitmapBuffer;
    ULONG SizeToMap;
    ULONG BytesToCopy;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetMftRecord, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input & output buffer lengths and pointers.
    //

    GetFileRecordLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    GetFileRecord = (PNTFS_FILE_RECORD_INPUT_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    FileRecordLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    FileRecord = (PNTFS_FILE_RECORD_OUTPUT_BUFFER)Irp->AssociatedIrp.SystemBuffer;;

    //
    //  Check for a minimum length on the input and ouput buffers.
    //

    if ((GetFileRecordLength < sizeof(NTFS_FILE_RECORD_INPUT_BUFFER)) ||
        (FileRecordLength < sizeof(NTFS_FILE_RECORD_OUTPUT_BUFFER))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    FileRecordLength -= FIELD_OFFSET(NTFS_FILE_RECORD_OUTPUT_BUFFER, FileRecordBuffer);
    FileReferenceNumber = GetFileRecord->FileReferenceNumber.LowPart;

    //
    //  Make this request synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Acquire the vcb to test for dismounted volume
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        LONGLONG ValidDataLength;

        //
        //  Synchronize the lookup by acquiring the Mft.  First test the  vcb we were
        //  called with in order to check for dismount.  The MftScb may have already been
        //  torn down.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        NtfsAcquireSharedScb( IrpContext, Vcb->MftScb );
        AcquiredMft = TRUE;

        //
        //  Raise if the File Reference Number is not within the MFT valid data length.
        //

        ValidDataLength = Vcb->MftScb->Header.ValidDataLength.QuadPart;

        if (FileReferenceNumber >= (ValidDataLength / Vcb->BytesPerFileRecordSegment)) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }

        //
        //  Fill in the record size and determine how much of it we can copy.
        //

        FileRecord->FileRecordLength = Vcb->BytesPerFileRecordSegment;

        if (FileRecordLength >= Vcb->BytesPerFileRecordSegment) {

            BytesToCopy = Vcb->BytesPerFileRecordSegment;
            Status = STATUS_SUCCESS;

        } else {

            BytesToCopy = FileRecordLength;
            Status = STATUS_BUFFER_OVERFLOW;
        }

        //
        //  If it is the MFT file record then just get it and we are done.
        //

        if (FileReferenceNumber == 0) {

            NTSTATUS ErrorStatus;

            try {
                NtfsMapStream( IrpContext,
                               Vcb->MftScb,
                               0,
                               Vcb->BytesPerFileRecordSegment,
                               &Bcb,
                               (PVOID *)&MftBuffer );

            } except ( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &ErrorStatus )) {

                //
                //  Clear the status field in the IrpContext. We're going to retry in the mirror
                //

                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                NtfsMapStream( IrpContext,
                               Vcb->Mft2Scb,
                               0,
                               Vcb->BytesPerFileRecordSegment,
                               &Bcb,
                               (PVOID *)&MftBuffer );
            }

            //
            //  Return the File Reference Number and the File Record.
            //

            RtlCopyMemory(FileRecord->FileRecordBuffer, MftBuffer, BytesToCopy);
            FileRecord->FileReferenceNumber.QuadPart = 0;

            try_return( Status );
        }

        //
        //  Scan through the MFT Bitmap to find an "in use" file.
        //

        while (FileReferenceNumber > 0) {

            //
            //  Compute some values for the bitmap, convert the index to the offset of
            //  this page and get the base index for the File Reference number. Then
            //  map the page in the bitmap that contains the file record. Note we have to convert
            //  from bits to bytes to find it.
            //

            Index = FileReferenceNumber & (BITS_PER_PAGE - 1);
            BaseIndex = FileReferenceNumber - Index;

            StartingByte = BlockAlignTruncate( FileReferenceNumber / 8 , PAGE_SIZE );
            SizeToMap = min( PAGE_SIZE, (ULONG)(Vcb->MftBitmapScb->Header.ValidDataLength.QuadPart - StartingByte) );

            NtfsMapStream( IrpContext,
                           Vcb->MftBitmapScb,
                           StartingByte,
                           SizeToMap,
                           &BitmapBcb,
                           &BitmapBuffer );

            RtlInitializeBitMap(&Bitmap, (PULONG)BitmapBuffer, SizeToMap * 8);

            //
            //  Scan thru this page for an "in use" File Record.
            //

            for (; Index >= 0; Index --) {

                if (RtlCheckBit(&Bitmap, Index)) {

                    NTSTATUS ErrorStatus;

                    //
                    //  Found one "in use" on this page so get it and we are done.
                    //

                    try {
                        NtfsMapStream( IrpContext,
                                       Vcb->MftScb,
                                       Int64ShllMod32(BaseIndex + Index, Vcb->MftShift),
                                       Vcb->BytesPerFileRecordSegment,
                                       &Bcb,
                                       (PVOID *)&MftBuffer );

                    } except (NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &ErrorStatus)) {

                        //
                        //  Reset status for retry in the mirror
                        //

                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                        NtfsMapStream( IrpContext,
                                       Vcb->Mft2Scb,
                                       Int64ShllMod32(BaseIndex + Index, Vcb->MftShift),
                                       Vcb->BytesPerFileRecordSegment,
                                       &Bcb,
                                       (PVOID *)&MftBuffer );
                    }

                    //
                    //  Return the File Reference Number and the File Record.
                    //

                    RtlCopyMemory(FileRecord->FileRecordBuffer, MftBuffer, BytesToCopy);
                    FileRecord->FileReferenceNumber.QuadPart = BaseIndex + Index;

                    try_return( Status );
                }
            }

            //
            //  Cleanup for next time through and decrement the File Reference Number.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            FileReferenceNumber = BaseIndex - 1;
        }

    try_exit:  NOTHING;

    Irp->IoStatus.Information =
        FIELD_OFFSET(NTFS_FILE_RECORD_OUTPUT_BUFFER, FileRecordBuffer) +
        BytesToCopy;

    } finally {

        //
        //  Release resources and exit.
        //

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
        NtfsUnpinBcb( IrpContext, &Bcb );

        if (AcquiredMft) {

            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

        NtfsReleaseVcb( IrpContext, Vcb );

        DebugTrace( -1, Dbg, ("NtfsGetMftRecord:  Exit\n") );
    }

    //
    //  If nothing raised then complete the Irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetMftRecord -> VOID\n") );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the dirty state of the volume.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PULONG VolumeState;
    PVOLUME_INFORMATION VolumeInfo;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;

    //
    //  Get the current stack location and extract the output
    //  buffer information.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in the
    //  irp first.  Then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        VolumeState = Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        VolumeState = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (VolumeState == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the volume isn't corrupt.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ULONG)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *VolumeState = 0;

    //
    //  Decode the file object. We don't care to raise on dismounts here
    //  because we check for that further down anyway. Hence, RaiseOnError=FALSE.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (TypeOfOpen != UserVolumeOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Scb shared.
    //

    NtfsAcquireSharedScb( IrpContext, Scb );

    //
    //  Make sure the volume is still mounted.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

        NtfsReleaseScb( IrpContext, Scb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Look up the VOLUME_INFORMATION attribute.
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to perform cleanup.
    //

    try {

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Vcb->VolumeDasdScb->Fcb,
                                        &Vcb->VolumeDasdScb->Fcb->FileReference,
                                        $VOLUME_INFORMATION,
                                        &Context )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Return the volume state and the size of the returned data.
        //

        VolumeInfo = (PVOLUME_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

        if (FlagOn( VolumeInfo->VolumeFlags, VOLUME_DIRTY )) {

            SetFlag( *VolumeState, VOLUME_IS_DIRTY );
        }

        if (FlagOn( VolumeInfo->VolumeFlags, VOLUME_UPGRADE_ON_MOUNT )) {

            SetFlag( *VolumeState, VOLUME_UPGRADE_SCHEDULED );
        }

        Irp->IoStatus.Information = sizeof( ULONG );

    } finally {

        NtfsReleaseScb( IrpContext, Scb );
        NtfsCleanupAttributeContext( IrpContext, &Context );
        DebugUnwind( NtfsIsVolumeDirty );
    }

    //
    //  If this is an abnormal termination then undo our work, otherwise
    //  complete the irp
    //

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsSetExtendedDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will mark a Dasd handle to perform IO outside the logical bounds of
    the partition.  Any subsequent IO will be passed to the driver which can either
    complete it or return an error.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Make sure this is a volume open.
    //

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Mark the Ccb for extended Io and return.
    //

    SetFlag( Ccb->Flags, CCB_FLAG_ALLOW_XTENDED_DASD_IO );

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsSetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the reparse point attribute at the file object entry
    specified in the IRP.

    NtfsSetReparsePoint does not care whether the base file object is a user file or a
    user directory.

    If the file object has the FILE_ATTRIBUTE_REPARSE_POINT bit set then the
    $REPARSE_POINT attribute is expected to be in the file.

    If this file object already is a reparse point, and the tag of the incomming
    reparse point request coincides with that present in existing $REPARSE_POINT,
    then the contents of the $REPARSE_POINT attribute present will be overwritten.

    There is to be an IN buffer to bring the caller's data for the call.

    This function inserts an entry into the reparse point table.

Arguments:

    IrpContext - Supplies the Irp context of the call

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PBCB Bcb = NULL;    //  does not get initialized below in NtfsDecodeFileObject

    PREPARSE_DATA_BUFFER ReparseBuffer = NULL;
    PREPARSE_GUID_DATA_BUFFER ReparseGuidBuffer = NULL;
    ULONG ReparseTag;
    USHORT ReparseDataLength = 0;   //  invalid value as it denotes no data
    ULONG InputBufferLength = 0;    //  invalid value as we need an input buffer
    ULONG OutputBufferLength = 0;   //  only valid value as we have no output buffer

    ULONG IncomingFileAttributes = 0;                               //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;   //  invalid value

    BOOLEAN CleanupAttributeContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN PagingIoAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsSetReparsePoint, FsControlCode = %08lx\n", FsControlCode) );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Decode all the relevant File System data structures.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );  // Raise an exeption if error is encountered

    //
    //  Check for the correct type of open.
    //

    //
    //  See that we have a file or a directory open.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid parameter passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  The caller has FILE_SPECIAL_ACCESS. The NTFS driver enforces access checks more stringent
    //  than FILE_ANY_ACCESS:
    //  (a) FILE_WRITE_DATA or FILE_WRITE_ATTRIBUTES_ACCESS
    //

    if (!FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS ) &&

        //
        //  Temporary KLUDGE for DavePr.
        //  The Ccb->AccessFlags and the FileObject->WriteAccess may not coincide as a
        //  filter may change the "visible" file object after the open. The Ccb flags do
        //  not change after open.
        //

        !IrpSp->FileObject->WriteAccess) {


        //
        //  Return access denied.
        //

        Status = STATUS_ACCESS_DENIED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Ccb->AccessFlags %x\n", Ccb->AccessFlags) );
        DebugTrace( 0, Dbg, ("Caller did not have the appropriate access rights.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );
    ASSERT_SCB( Scb );
    ASSERT_CCB( Ccb );

    //
    //  Read only volumes stay read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );
        return Status;
    }

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_REPARSE_POINT_VERSION )) {

        //
        //  Return a volume not upgraded error.
        //

        Status = STATUS_VOLUME_NOT_UPGRADED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-upgraded volume passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the length of the input and output buffers.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DebugTrace( 0, Dbg, ("InputBufferLength %08lx [d]%08d OutputBufferLength %08lx\n", InputBufferLength, InputBufferLength, OutputBufferLength) );

    //
    //  Do not allow output buffer in the set command.
    //

    if (OutputBufferLength > 0) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-null output buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Zero the Information field in IoStatus.
    //

    Irp->IoStatus.Information = 0;

    //
    //  Verify that we have the required system input buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {

        //
        //  Return an invalid buffer error.
        //

        Status = STATUS_INVALID_BUFFER_SIZE;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Null buffer passed by system.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    Status = NtfsValidateReparsePointBuffer( InputBufferLength,
                                             (PREPARSE_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer );

    if (!NT_SUCCESS( Status )) {

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the header information brought in the input buffer.
    //  While all the headers coincide in the layout of the first three fields we are home free.
    //

    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseTag) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseTag) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseDataLength) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseDataLength) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, Reserved) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, Reserved) );

    ReparseBuffer = (PREPARSE_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;
    ReparseTag = ReparseBuffer->ReparseTag;
    ReparseDataLength = ReparseBuffer->ReparseDataLength;
    ReparseGuidBuffer = (PREPARSE_GUID_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    DebugTrace( 0, Dbg, ("ReparseTag = %08lx, ReparseDataLength = [x]%08lx [d]%08ld\n", ReparseTag, ReparseDataLength, ReparseDataLength) );

    //
    //  NTFS directory junctions are only to be set at directories and have a valid buffer.
    //

    if (ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {

        HANDLE TestHandle;
        OBJECT_ATTRIBUTES Oa;
        IO_STATUS_BLOCK Iosb;
        UNICODE_STRING Path;

        //
        //  The tag needs to come together with a UserDirectoryOpen mode.
        //

        if (TypeOfOpen != UserDirectoryOpen) {

            Status = STATUS_NOT_A_DIRECTORY;

            //
            //  Return to caller.
            //

            NtfsCompleteRequest( IrpContext, Irp, Status );

            DebugTrace( 0, Dbg, ("Cannot set a mount point at a non-directory.\n") );
            DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

            return Status;
        }

        //
        //  While we don't hold any of our resources open the target path to
        //  check what it points to. We only allow mount points to local
        //  disks and cdroms
        //

        Path.Length = Path.MaximumLength = ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength;
        Path.Buffer = &ReparseBuffer->MountPointReparseBuffer.PathBuffer[0];

        if (Path.Buffer[ (Path.Length / sizeof( WCHAR )) - 1] == L'\\') {
            Path.Length -= sizeof( WCHAR );
        }

        //
        //  Set the call self flag so status can't wait is handled in the create and
        //  not returned back
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

        InitializeObjectAttributes( &Oa, &Path, OBJ_CASE_INSENSITIVE, NULL, NULL );
        Status = ZwCreateFile( &TestHandle,
                               FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                               &Oa,
                               &Iosb,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0 );

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

        if (NT_SUCCESS( Status )) {

            PFILE_OBJECT TestFileObject;

            Status = ObReferenceObjectByHandle( TestHandle,
                                                FILE_READ_ATTRIBUTES,
                                                *IoFileObjectType,
                                                KernelMode,
                                                (PVOID *) &TestFileObject,
                                                NULL );

            if (NT_SUCCESS( Status )) {

                if ((TestFileObject->DeviceObject->DeviceType != FILE_DEVICE_DISK) &&
                    (TestFileObject->DeviceObject->DeviceType != FILE_DEVICE_CD_ROM) &&
                    (TestFileObject->DeviceObject->DeviceType != FILE_DEVICE_VIRTUAL_DISK) &&
                    (TestFileObject->DeviceObject->DeviceType != FILE_DEVICE_TAPE)) {

                    Status = STATUS_IO_REPARSE_DATA_INVALID;
                }
                ObDereferenceObject( TestFileObject );
            }
            ZwClose( TestHandle );

        } else if (FlagOn( Ccb->AccessFlags, RESTORE_ACCESS)) {

            //
            //  Allow restore operators to create a reparse point - even if the target doesn't
            //  exist
            //

            Status = STATUS_SUCCESS;

        }

        if (!NT_SUCCESS( Status )) {

            //
            //  Return to caller.
            //

            NtfsCompleteRequest( IrpContext, Irp, STATUS_IO_REPARSE_DATA_INVALID );

            DebugTrace( 0, Dbg, ("Name grafting data buffer is incorrect.\n") );
            DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

            return STATUS_IO_REPARSE_DATA_INVALID;
        }
    }

    //
    //  We set the IrpContext flag to indicate that we can wait, making this a synchronous
    //  call.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  The parameters look good. We begin real work.
    //
    //  Now it is time ot use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there is a paging io resource then acquire it exclusively.  This is to
        //  protect us from a collided page wait if we go to convert another stream
        //  to non-resident at the same time a different thread is faulting into it.
        //

        if (Scb->Header.PagingIoResource != NULL) {
            NtfsAcquirePagingResourceExclusive( IrpContext, Scb, TRUE );
            PagingIoAcquired = TRUE;
        }

        //
        //  Acquire the Fcb exclusively. The volume could've gotten dismounted,
        //  so check that too.
        //

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  If the file object is a directory, we want it to be empty and to remain
        //  empty. Thus our check after the Fcb has been acquired. As reparse points
        //  impede the normal flow down through the name hierarchy we want to make
        //  it difficult for a caller to inadvertently block a name subtree by
        //  establishing a reparse point.
        //

        if (TypeOfOpen == UserDirectoryOpen) {

            BOOLEAN NonEmptyIndex;

            //
            //  The directory is deleteable if all the $INDEX_ROOT attributes are empty.
            //  Just what we need to establish a reparse point.
            //

            if (!NtfsIsFileDeleteable( IrpContext, Fcb, &NonEmptyIndex )) {

                //
                //  This directory is not empty.  Do not establish a reparse point in it.
                //  Return to caller an invalid parameter error.
                //

                DebugTrace( 0, Dbg, ("Non-empty directory used by caller.\n") );
                Status = STATUS_DIRECTORY_NOT_EMPTY;

                //
                //  Return to caller.
                //

                try_return( Status );
            }
        }

        //
        //  EA attributes and reparse points are not to exist simultaneously.
        //  If the non-reparse point file object has EA attributes, we do not set
        //  a reparse point.
        //  We verify this condition after the Fcb resource has been acquired to
        //  impede a change in this state till we complete.
        //

        if ((!FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) &&
            (Fcb->Info.PackedEaSize > 0)) {

            //
            //  This non-reparse point file object has EAs.  Do not establish a
            //  reparse point in it.
            //  Return to caller STATUS_EAS_NOT_SUPPORTED.
            //

            DebugTrace( 0, Dbg, ("EAs present, cannot establish reparse point.\n") );
            Status = STATUS_EAS_NOT_SUPPORTED;

            //
            //  Return to caller.
            //

            try_return( Status );
        }

        //
        //  Remember the values of the file attribute flags and of the reparse tag
        //  for abnormal termination recovery.
        //

        IncomingFileAttributes = Fcb->Info.FileAttributes;
        IncomingReparsePointTag = Fcb->Info.ReparsePointTag;

        //
        //  Initialize the context structure to search for the attribute.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        CleanupAttributeContext = TRUE;

        //
        //  Establish whether the file has the $REPARSE_POINT attribute.
        //  If it exists, it will be updated with the new data.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $REPARSE_POINT,
                                       &AttributeContext )) {

            ULONG ValueLength = 0;

            if (!FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The FILE_ATTRIBUTE_REPARSE_POINT flag is not set.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an inconsistent state.
                //  The presence of the $REPARSE_POINT attribute says that the flag has to
                //  be set.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Verify that the incomming tag value matches the tag value present in
            //  the $REPARSE_POINT attribute.
            //

            {
                PREPARSE_GUID_DATA_BUFFER ReparseBufferTwo = NULL;
                PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
                PVOID AttributeData = NULL;

                AttributeHeader = NtfsFoundAttribute( &AttributeContext );

                //
                //  Map the reparse point if the attribute is non-resident.  Otherwise
                //  the attribute is already mapped and we have a Bcb in the attribute
                //  context.
                //

                if (NtfsIsAttributeResident( AttributeHeader )) {

                    //
                    //  Point to the value of the arribute.
                    //

                    AttributeData = NtfsAttributeValue( AttributeHeader );
                    ValueLength = AttributeHeader->Form.Resident.ValueLength;
                    DebugTrace( 0, Dbg, ("Existing attribute is resident.\n") );

                } else {


                    if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {
                        NtfsRaiseStatus( IrpContext,STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    DebugTrace( 0, Dbg, ("Existing attribute is non-resident.\n") );
                    NtfsMapAttributeValue( IrpContext,
                                           Fcb,
                                           &AttributeData,       //  point to the value
                                           &ValueLength,
                                           &Bcb,
                                           &AttributeContext );
                }

                //
                //  Verify that the two tag values match.
                //

                ReparseBufferTwo = (PREPARSE_GUID_DATA_BUFFER)AttributeData;

                DebugTrace( 0, Dbg, ("Existing tag is [d]%03ld - New tag is [d]%03ld\n", ReparseTag, ReparseBufferTwo->ReparseTag) );

                if (ReparseTag != ReparseBufferTwo->ReparseTag) {

                    //
                    //  Return status STATUS_IO_REPARSE_TAG_MISMATCH
                    //

                    DebugTrace( 0, Dbg, ("Tag mismatch with the existing reparse point.\n") );
                    Status = STATUS_IO_REPARSE_TAG_MISMATCH;

                    try_return( Status );
                }

                //
                //  For non-Microsoft tags, verify that the GUIDs match.
                //

                if (!IsReparseTagMicrosoft( ReparseTag )) {

                    if (!((ReparseGuidBuffer->ReparseGuid.Data1 == ReparseBufferTwo->ReparseGuid.Data1) &&
                          (ReparseGuidBuffer->ReparseGuid.Data2 == ReparseBufferTwo->ReparseGuid.Data2) &&
                          (ReparseGuidBuffer->ReparseGuid.Data3 == ReparseBufferTwo->ReparseGuid.Data3) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[0] == ReparseBufferTwo->ReparseGuid.Data4[0]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[1] == ReparseBufferTwo->ReparseGuid.Data4[1]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[2] == ReparseBufferTwo->ReparseGuid.Data4[2]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[3] == ReparseBufferTwo->ReparseGuid.Data4[3]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[4] == ReparseBufferTwo->ReparseGuid.Data4[4]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[5] == ReparseBufferTwo->ReparseGuid.Data4[5]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[6] == ReparseBufferTwo->ReparseGuid.Data4[6]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[7] == ReparseBufferTwo->ReparseGuid.Data4[7]))) {

                        //
                        //  Return status STATUS_REPARSE_ATTRIBUTE_CONFLICT
                        //

                        DebugTrace( 0, Dbg, ("GUID mismatch with the existing reparse point.\n") );
                        Status = STATUS_REPARSE_ATTRIBUTE_CONFLICT;

                        try_return( Status );
                    }
                }

                //
                //  Unpin the Bcb. The unpin routine checks for NULL.
                //

                NtfsUnpinBcb( IrpContext, &Bcb );
            }

            //
            //  If we're growing throttle ourselves through cc, we can't wait because we own resources
            //  here and this would deadlock
            //

            if (InputBufferLength > ValueLength) {
                if (!CcCanIWrite(IrpSp->FileObject,
                                 InputBufferLength - ValueLength,
                                 FALSE,
                                 BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE))) {

                    BOOLEAN Retrying = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE);

                    //
                    //  PrePosting the irp will free the resources so fcb will not be acquired afterwards
                    //

                    NtfsPrePostIrp( IrpContext, Irp );

                    ASSERT( !NtfsIsExclusiveFcb( Fcb ) );

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE );

                    CcDeferWrite( IrpSp->FileObject,
                                  (PCC_POST_DEFERRED_WRITE)NtfsAddToWorkque,
                                  IrpContext,
                                  Irp,
                                  InputBufferLength - ValueLength,
                                  Retrying );

                    try_return( Status = STATUS_PENDING );
                }
            }

            //
            //  Update the value of the attribute.
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      (ULONG) 0,                   //  ValueOffset
                                      (PVOID)(Irp->AssociatedIrp.SystemBuffer),    //  Value
                                      InputBufferLength,           //  ValueLength
                                      TRUE,                        //  SetNewLength
                                      TRUE,                        //  LogNonresidentToo
                                      FALSE,                       //  CreateSectionUnderway
                                      FALSE,                       //  PreserveContext
                                      &AttributeContext );         //  Context

            //
            //  Cleanup the attribute context state
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            CleanupAttributeContext = FALSE;

        } else {

            //
            //  The $REPARSE_POINT attribute is not present.
            //

            if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The FILE_ATTRIBUTE_REPARSE_POINT flag is set.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an inconsistent state.
                //  The absence of the $REPARSE_POINT attribute says that the flag has to
                //  not be set.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  throttle ourselves throuch cc
            //

            if (!CcCanIWrite(IrpSp->FileObject,
                             InputBufferLength,
                             FALSE,
                             BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE))) {

                BOOLEAN Retrying = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE);

                //
                //  PrePosting the irp will free the resources so fcb will not be acquired afterwards
                //

                NtfsPrePostIrp( IrpContext, Irp );

                ASSERT( !NtfsIsExclusiveFcb( Fcb ) );

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE );

                CcDeferWrite( IrpSp->FileObject,
                              (PCC_POST_DEFERRED_WRITE)NtfsAddToWorkque,
                              IrpContext,
                              Irp,
                              InputBufferLength,
                              Retrying );

                try_return( Status = STATUS_PENDING );
            }

            //
            //  Insert the record into the reparse point index.
            //

            {
                INDEX_KEY IndexKey;
                INDEX_ROW IndexRow;
                REPARSE_INDEX_KEY KeyValue;

                //
                //  Acquire the ReparsePointIndex Scb. We still hold the target fcb resource,
                //  so the volume couldn't have gotten dismounted under us.
                //

                NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                ASSERT( NtfsIsExclusiveFcb( Fcb ));
                ASSERT( !FlagOn( Vcb->ReparsePointTableScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ));

                //
                //  Add the file Id to the reparse point index.
                //

                KeyValue.FileReparseTag = ReparseTag;
                KeyValue.FileId = *(PLARGE_INTEGER)&Scb->Fcb->FileReference;

                IndexKey.Key = (PVOID)&KeyValue;
                IndexKey.KeyLength = sizeof(KeyValue);

                IndexRow.KeyPart = IndexKey;
                IndexRow.DataPart.DataLength = 0;
                IndexRow.DataPart.Data = NULL;

                //
                //  NtOfsAddRecords will raise if the file id already belongs in the index.
                //

                NtOfsAddRecords( IrpContext,
                                 Vcb->ReparsePointTableScb,
                                 1,          // adding one record to the index
                                 &IndexRow,
                                 FALSE );    // sequential insert
            }

            //
            //  Create the $REPARSE_POINT attribute with the data being sent in.
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsInitializeAttributeContext( &AttributeContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $REPARSE_POINT,
                                          NULL,
                                          (PVOID) ( Irp->AssociatedIrp.SystemBuffer ),
                                          InputBufferLength,
                                          (USHORT) 0,         //  Attribute flags
                                          NULL,
                                          TRUE,               //  LogIt
                                          &AttributeContext );

            //
            //  Cleanup the attribute context state
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            CleanupAttributeContext = FALSE;

            //
            //  Set the duplicate file attribute to Reparse Point.
            //

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT );

            //
            //  Set the ReparsePointTag field.
            //

            Fcb->Info.ReparsePointTag = ReparseTag;

            //
            //  Set the change attribute flag.
            //

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( Fcb ) ||
                       (Fcb->PagingIoResource != NULL &&
                        NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
        }

        //
        //  Set the archive bit in the Ccb.
        //

        if (!IsDirectory( &Fcb->Info )) {
            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

        //
        //  Flag to set the change time in the Ccb.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Update the standard information in the file record to reflect its a reparse pt.
        //

        NtfsUpdateStandardInformation( IrpContext, Fcb );

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_REPARSE_POINT_CHANGE );

        //
        //  Checkpoint the Txn to commit the changes.
        //

        NtfsCleanupTransactionAndCommit( IrpContext, STATUS_SUCCESS, TRUE );

    try_exit:  NOTHING;

    } finally {

        DebugUnwind( NtfsSetReparsePoint );

        //
        //  Unpin the Bcb. The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );

        //
        //  Clean-up all the pertinent state.
        //

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Need to roll-back the value of the reparse point flag in case of
        //  problems. I leave the archive bit set anyway.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = IncomingFileAttributes;
            Fcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }

        //
        //  Release the paging io resource if held.
        //

        if (PagingIoAcquired) {
            NtfsReleasePagingResource( IrpContext, Fcb );
        }
    }

    if (Status != STATUS_PENDING) {
        NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsGetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine finds the specified reparse point returning the value
    of the corresponding attribute.

    The value of the reparse point attribute is the linearized version of
    the buffer sent in the NtfsSetReparsePoint call including the header
    fields ReparseTag and ReparseDataLength. We retrieve all fields, unmodified,
    so that the caller can decode it using the same buffer template used in the
    set operation.

Arguments:

    IrpContext - Supplies the Irp context of the call

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PBCB Bcb = NULL;    //  does not get initialized below in NtfsDecodeFileObject

    PCHAR OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;   //  invalid value as we need an output buffer
    ULONG InputBufferLength = 0;    //  invalid value as we need an input buffer

    BOOLEAN CleanupAttributeContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
    PATTRIBUTE_LIST_ENTRY AttributeListEntry = NULL;
    ULONG AttributeLengthInBytes = 0;
    PVOID AttributeData = NULL;

    BOOLEAN ScbAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetReparsePoint, FsControlCode = %08lx\n", FsControlCode) );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Decode all the relevant File System data structures.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );  //  Raise an exeption if error is encountered

    //
    //  Check for the correct type of open.
    //

    //
    //  See that we have a file or a directory open.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        //
        //  Return an invalid parameter error
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid parameter passed by caller\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );
    ASSERT_SCB( Scb );
    ASSERT_CCB( Ccb );

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_REPARSE_POINT_VERSION )) {

        //
        //  Return a volume not upgraded error.
        //

        Status = STATUS_VOLUME_NOT_UPGRADED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-upgraded volume passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the length of the output buffer.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DebugTrace( 0, Dbg, ("InputBufferLength %08lx [d]%08d OutputBufferLength %08lx\n", InputBufferLength, InputBufferLength, OutputBufferLength) );

    //
    //  Do not allow input buffer in the get command.
    //

    if (InputBufferLength > 0) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-null input buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get a pointer to the output buffer.  First look at the system buffer field in
    //  the IRP.  Then look in the IRP Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        OutputBuffer = (PCHAR)Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        OutputBuffer = (PCHAR)MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (OutputBuffer == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        //
        //  Return an invalid user buffer error.
        //

        Status = STATUS_INVALID_USER_BUFFER;

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );

        DebugTrace( 0, Dbg, ("User buffer is not good.\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Zero the Information field in IoStatus.
    //

    Irp->IoStatus.Information = 0;

    //
    //  We set the IrpContext flag to indicate that we can wait, making htis a synchronous
    //  call.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Now it is time ot use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We acquire the Scb in shared mode so that the underlying Fcb remains stable.
        //

        NtfsAcquireSharedScb( IrpContext, Scb );
        ScbAcquired = TRUE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  The parameters and boundary conditions look good and we have a reparse point.
        //  We begin real work.
        //
        //  Find the reparse point attribute.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        CleanupAttributeContext = TRUE;

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $REPARSE_POINT,
                                        &AttributeContext )) {

            DebugTrace( 0, Dbg, ("Can't find the $REPARSE_POINT attribute.\n") );

            //
            //  Verify that the information in FileAttributes is consistent.
            //

            if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The Fcb says this IS a reparse point.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an inconsistent state.
                //  The attribute flag says that $REPARSE_POINT has to be present.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Return STATUS_NOT_A_REPARSE_POINT
            //

            Status = STATUS_NOT_A_REPARSE_POINT;

            try_return( Status );
        }

        //
        //  Find the size of the attribute.
        //  Determine whether we have enough buffer to return it to the caller.
        //

        AttributeHeader = NtfsFoundAttribute( &AttributeContext );

        if (NtfsIsAttributeResident( AttributeHeader )) {

            AttributeLengthInBytes = AttributeHeader->Form.Resident.ValueLength;
            DebugTrace( 0, Dbg, ("Resident attribute with length %05lx\n", AttributeLengthInBytes) );

            if (AttributeLengthInBytes > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                DebugTrace( 0, Dbg, ("AttributeLengthInBytes is [x]%08lx is too long.\n", AttributeLengthInBytes) );

                try_return( Status );
            }

            //
            //  Point to the value of the arribute.
            //

            AttributeData = NtfsAttributeValue( AttributeHeader );
            ASSERT( Bcb == NULL );

        } else {

            ULONG Length;

            if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                DebugTrace( 0, Dbg, ("Nonresident.FileSize is too long.\n") );

                try_return( Status );
            }

            //
            //  Note that we coerse different LENGTHs
            //

            AttributeLengthInBytes = (ULONG)AttributeHeader->Form.Nonresident.FileSize;
            DebugTrace( 0, Dbg, ("Non-resident attribute with length %05lx\n", AttributeLengthInBytes) );

            //
            //  Map the attribute list if the attribute is non-resident.  Otherwise the
            //  attribute is already mapped and we have a Bcb in the attribute context.
            //

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   &AttributeData,      //  point to the value
                                   &Length,
                                   &Bcb,
                                   &AttributeContext );

            if (AttributeLengthInBytes != Length) {
                DebugTrace( 0, Dbg, ("AttributeLengthInBytes %05lx and Length %05lx differ.\n", AttributeLengthInBytes, Length) );
            }
            ASSERT( AttributeLengthInBytes == Length );
        }

        DebugTrace( 0, Dbg, ("AttributeLengthInBytes is [d]%06ld %05lx\n", AttributeLengthInBytes, AttributeLengthInBytes) );

        Status = NtfsValidateReparsePointBuffer( AttributeLengthInBytes,
                                                 AttributeData );

        if (!NT_SUCCESS( Status )) {

            leave;
        }

        if (AttributeLengthInBytes > OutputBufferLength) {

            DebugTrace( 0, Dbg, ("Insufficient output buffer passed by caller.\n") );

            //
            //  Check whether the fixed portion will fit.
            //

            if (OutputBufferLength < sizeof( REPARSE_GUID_DATA_BUFFER )) {

                //
                //  This is the error path.  Don't return anything.
                //

                try_return( Status = STATUS_BUFFER_TOO_SMALL );

            } else {

                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            //  Remember the smaller number of returned bytes.
            //

            AttributeLengthInBytes = OutputBufferLength;
        }

        //
        //  Copy the value of the reparse point attribute to the buffer.
        //  Return all the value including the system header fields (e.g., Tag and Length)
        //  stored at the beginning of the value of the reparse point attribute.
        //

        RtlCopyMemory( OutputBuffer,
                       AttributeData,
                       AttributeLengthInBytes );

        //
        //  Set the information field to the length of the buffer returned.
        //  This tells the re-director to do the corresponding data transmission.
        //

        Irp->IoStatus.Information = AttributeLengthInBytes;

        //
        //  Cleanup the attribute context state.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        CleanupAttributeContext = FALSE;

    try_exit:  NOTHING;

    } finally {

        //
        //  Clean-up all the pertinent state.
        //

        DebugUnwind( NtfsGetReparsePoint );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Unpin the Bcb ... in case you needed to pin it above.
        //  The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );

        //
        //  Relase the Fcb.
        //

        if (ScbAcquired) {

            NtfsReleaseScb( IrpContext, Scb );
        } else {

            //
            //  We must have raised an exception in NtfsAcquireSharedFcb.
            //  Because we check for the existence of the file this must mean
            //  that it has been deleted from under us.
            //
            //  Nothing is to be done as exception processing sets the correct
            //  return code.
            //
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsDeleteReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deletes a reparse point at the file object entry
    specified in the IRP.

    The IN buffer specified by the caller has the value of the Tag of the reparse point
    being deleted, and no data, thus needing to have a value of zero for DataLength.
    If the tags do not match the delete fails.

    If the file object has the FILE_ATTRIBUTE_REPARSE_POINT bit set then the
    $REPARSE_POINT attribute is expected to be in the file.

    There is no OUT buffer sent by the caller.

    This function deletes the corresponding entry from the reparse point table.

Arguments:

    IrpContext - Supplies the Irp context of the call

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PSCB NonResidentScb = NULL;
    PCCB Ccb;
    PBCB Bcb = NULL;    //  does not get initialized below in NtfsDecodeFileObject

    PREPARSE_DATA_BUFFER ReparseBuffer = NULL;
    ULONG ReparseTag;
    USHORT ReparseDataLength = 0;   //  only valid value
    ULONG InputBufferLength = 0;    //  invalid value as the header is needed
    ULONG OutputBufferLength = 2;   //  invalid value as no output buffer is used

    ULONG IncomingFileAttributes = 0;                              //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;  //  invalid value

    BOOLEAN CleanupAttributeContext = FALSE;
    PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    MAP_HANDLE MapHandle;

    BOOLEAN NonResidentScbAcquired = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsDeleteReparsePoint, FsControlCode = %08lx\n", FsControlCode) );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Get the length of the input and output buffers.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DebugTrace( 0, Dbg, ("InputBufferLength = %08lx, OutputBufferLength = %08lx\n", InputBufferLength, OutputBufferLength) );

    //
    //  Do not allow output buffer in the delete command.
    //

    if (OutputBufferLength > 0) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-null output buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Decode all the relevant File System data structures.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );  // Raise an exeption if error is encountered

    //
    //  Check for the correct type of open.
    //

    if (
        //
        //  See that we have a file or a directory.
        //

        ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen))) {

        //
        //  Return an invalid parameter error
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid TypeOfOpen\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  The caller has FILE_SPECIAL_ACCESS. The NTFS driver enforces access checks more stringent
    //  than FILE_ANY_ACCESS:
    //  (a) FILE_WRITE_DATA or FILE_WRITE_ATTRIBUTES_ACCESS
    //

    if (!FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS ) &&

        //
        //  Temporary KLUDGE for DavePr.
        //  The Ccb->AccessFlags and the FileObject->WriteAccess may not coincide as a
        //  filter may change the "visible" file object after the open. The Ccb flags do
        //  not change after open.
        //

        !(IrpSp->FileObject->WriteAccess == TRUE)) {

        //
        //  Return access denied.
        //

        Status = STATUS_ACCESS_DENIED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Ccb->AccessFlags %x\n", Ccb->AccessFlags) );
        DebugTrace( 0, Dbg, ("Caller did not have the appropriate access rights.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );
    ASSERT_SCB( Scb );
    ASSERT_CCB( Ccb );

    //
    //  Read only volumes stay read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );
        return Status;
    }

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_REPARSE_POINT_VERSION )) {

        //
        //  Return a volume not upgraded error.
        //

        Status = STATUS_VOLUME_NOT_UPGRADED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-upgraded volume passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Check for invalid conditions in the parameters.
    //

    if (
        //
        //  Verify that we have the required system input buffer.
        //

        (Irp->AssociatedIrp.SystemBuffer == NULL)) {

        //
        //  Return an invalid buffer error.
        //

        Status = STATUS_INVALID_BUFFER_SIZE;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Null buffer passed by system.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  See that the buffer sent in by the caller is the exact header.
    //

    if ((InputBufferLength != REPARSE_DATA_BUFFER_HEADER_SIZE) &&
        (InputBufferLength != REPARSE_GUID_DATA_BUFFER_HEADER_SIZE)) {

        //
        //  Return an invalid reparse data.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid parameter reparse data passed by caller\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the header information brought in the input buffer.
    //  While the first two fields coincide in REPARSE_DATA_BUFFER and REPARSE_GUID_DATA_BUFFER,
    //  a common assignment can be used below.
    //

    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseTag) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseTag) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseDataLength) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseDataLength) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, Reserved) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, Reserved) );

    ReparseBuffer = (PREPARSE_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;
    ReparseTag = ReparseBuffer->ReparseTag;
    ReparseDataLength = ReparseBuffer->ReparseDataLength;

    DebugTrace( 0, Dbg, ("ReparseTag = %08lx, ReparseDataLength = %05lx [d]%d\n", ReparseTag, ReparseDataLength, ReparseDataLength) );

    //
    //  We verify that ReparseDataLength is zero.
    //

    if (ReparseDataLength != 0) {

        //
        //  Return an invalid reparse data.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid header value passed by caller\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We verify that the caller uses one of the non-reserved tags.
    //

    if ((ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO) ||
        (ReparseTag == IO_REPARSE_TAG_RESERVED_ONE)) {

        //
        //  Return an invalid reparse tag.
        //

        Status = STATUS_IO_REPARSE_TAG_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Caller passed in a reserved tag for the reparse data.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We verify that for non-Microsoft tags the caller has the GUID header.
    //

    if (!IsReparseTagMicrosoft( ReparseTag ) &&
        (InputBufferLength != REPARSE_GUID_DATA_BUFFER_HEADER_SIZE)) {

        //
        //  Return an invalid reparse data.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Caller used non-Microsoft tag and did not use the GUID buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We set the IrpContext flag to indicate that we can wait, making this a synchronous
    //  call.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Now it is time ot use a try-finally to facilitate cleanup.
    //

    try {
        //
        //  Acquire exclusive the Fcb.
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Remember the value of the file attribute flags and of the reparse point.
        //

        IncomingFileAttributes = Fcb->Info.FileAttributes;
        IncomingReparsePointTag = Fcb->Info.ReparsePointTag;

        //
        //  All the parameters and boundary conditions look good. We begin real work.
        //
        //  Delete the appropriate system defined reparse point attribute.
        //  First point to it and then nuke it.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        CleanupAttributeContext = TRUE;

        if (!(NtfsLookupAttributeByCode( IrpContext,
                                         Fcb,
                                         &Fcb->FileReference,
                                         $REPARSE_POINT,
                                         &AttributeContext ) ) ) {

            DebugTrace( 0, Dbg, ("Can't find the $REPARSE_POINT attribute\n") );

            //
            //  See if FileAttributes agrees that we do not have a reparse point.
            //

            if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The Fcb says this IS a reparse point.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an
                //  inconsistent state. The attribute flag says that
                //  $REPARSE_POINT has to be present.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Return STATUS_NOT_A_REPARSE_POINT
            //

            Status = STATUS_NOT_A_REPARSE_POINT;

            try_return( Status );
        }

        //
        //  Verify that the incomming tag value matches the tag value present in
        //  the $REPARSE_POINT attribute.
        //

        {
            PREPARSE_GUID_DATA_BUFFER ReparseBufferTwo = NULL;
            PVOID AttributeData = NULL;
            ULONG Length = 0;

            AttributeHeader = NtfsFoundAttribute( &AttributeContext );

            if (NtfsIsAttributeResident( AttributeHeader )) {

                //
                //  Point to the value of the arribute.
                //

                AttributeData = NtfsAttributeValue( AttributeHeader );
                DebugTrace( 0, Dbg, ("Existing attribute is resident.\n") );

            } else {

                //
                //  Map the attribute list if the attribute is non-resident.  Otherwise the
                //  attribute is already mapped and we have a Bcb in the attribute context.
                //

                DebugTrace( 0, Dbg, ("Existing attribute is non-resident.\n") );
                NtfsMapAttributeValue( IrpContext,
                                       Fcb,
                                       &AttributeData,      //  point to the value
                                       &Length,
                                       &Bcb,
                                       &AttributeContext );
            }

            //
            //  Verify that the two tag values match.
            //

            ReparseBufferTwo = (PREPARSE_GUID_DATA_BUFFER)AttributeData;

            DebugTrace( 0, Dbg, ("Existing tag is [d]%03ld - New tag is [d]%03ld\n", ReparseBufferTwo->ReparseTag, ReparseBuffer->ReparseTag) );

            if (ReparseBuffer->ReparseTag != ReparseBufferTwo->ReparseTag) {

                //
                //  Return status STATUS_IO_REPARSE_TAG_MISMATCH
                //

                DebugTrace( 0, Dbg, ("Tag mismatch with the existing reparse point.\n") );
                Status = STATUS_IO_REPARSE_TAG_MISMATCH;

                try_return( Status );
            }

            //
            //  For non-Microsoft tags, verify that the GUIDs match.
            //

            if (!IsReparseTagMicrosoft( ReparseTag )) {

                PREPARSE_GUID_DATA_BUFFER ReparseGuidBuffer = NULL;

                ReparseGuidBuffer = (PREPARSE_GUID_DATA_BUFFER)ReparseBuffer;

                if (!((ReparseGuidBuffer->ReparseGuid.Data1 == ReparseBufferTwo->ReparseGuid.Data1) &&
                      (ReparseGuidBuffer->ReparseGuid.Data2 == ReparseBufferTwo->ReparseGuid.Data2) &&
                      (ReparseGuidBuffer->ReparseGuid.Data3 == ReparseBufferTwo->ReparseGuid.Data3) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[0] == ReparseBufferTwo->ReparseGuid.Data4[0]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[1] == ReparseBufferTwo->ReparseGuid.Data4[1]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[2] == ReparseBufferTwo->ReparseGuid.Data4[2]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[3] == ReparseBufferTwo->ReparseGuid.Data4[3]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[4] == ReparseBufferTwo->ReparseGuid.Data4[4]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[5] == ReparseBufferTwo->ReparseGuid.Data4[5]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[6] == ReparseBufferTwo->ReparseGuid.Data4[6]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[7] == ReparseBufferTwo->ReparseGuid.Data4[7]))) {

                    //
                    //  Return status STATUS_REPARSE_ATTRIBUTE_CONFLICT
                    //

                    DebugTrace( 0, Dbg, ("GUID mismatch with the existing reparse point.\n") );
                    Status = STATUS_REPARSE_ATTRIBUTE_CONFLICT;

                    try_return( Status );
                }
            }

            //
            //  Unpin the Bcb. The unpin routine checks for NULL.
            //

            NtfsUnpinBcb( IrpContext, &Bcb );
        }

        //
        //  Delete the record from the reparse point index.
        //

        {
            INDEX_KEY IndexKey;
            INDEX_ROW IndexRow;
            REPARSE_INDEX_KEY KeyValue;

            //
            //  Acquire the mount table index so that the following two operations on it
            //  are atomic for this call.
            //

            NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );

            //
            //  Verify that this file is in the reparse point index and delete it.
            //

            KeyValue.FileReparseTag = ReparseTag;
            KeyValue.FileId = *(PLARGE_INTEGER)&Scb->Fcb->FileReference;

            IndexKey.Key = (PVOID)&KeyValue;
            IndexKey.KeyLength = sizeof(KeyValue);

            NtOfsInitializeMapHandle( &MapHandle );
            InitializedMapHandle = TRUE;

            //
            //  NtOfsFindRecord will return an error status if the key is not found.
            //

            Status = NtOfsFindRecord( IrpContext,
                                      Vcb->ReparsePointTableScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      NULL );

            if (!NT_SUCCESS(Status)) {

                //
                //  Should not happen. The reparse point should be in the index.
                //

                DebugTrace( 0, Dbg, ("Record not found in the reparse point index.\n") );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Remove the entry from the reparse point index.
            //

            NtOfsDeleteRecords( IrpContext,
                                Vcb->ReparsePointTableScb,
                                1,            // deleting one record from the index
                                &IndexKey );
        }

        //
        //  If the stream is non-resident, then get hold of an Scb for it.
        //

        if (!NtfsIsAttributeResident( AttributeHeader )) {

            NonResidentScb = NtfsCreateScb( IrpContext,
                                            Fcb,
                                            $REPARSE_POINT,
                                            &NtfsEmptyString,
                                            FALSE,
                                            NULL );

            NtfsAcquireExclusiveScb( IrpContext, NonResidentScb );
            NonResidentScbAcquired = TRUE;
        }

        //
        //  Nuke the attribute.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION,
                                   &AttributeContext );

        //
        //  Cleanup the attribute context.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        CleanupAttributeContext = FALSE;

        //
        //  Set the change attribute flag.
        //

        ASSERTMSG( "conflict with flush",
                   NtfsIsSharedFcb( Fcb ) ||
                   (Fcb->PagingIoResource != NULL &&
                    NtfsIsSharedFcbPagingIo( Fcb )) );

        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

        //
        //  Clear the reparse point bit in the duplicate file attribute.
        //

        ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT );

        //
        //  Clear the ReparsePointTag field in the duplicate file attribute.
        //

        Fcb->Info.ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;

        //
        //  Update the standard information in the file record.
        //

        NtfsUpdateStandardInformation( IrpContext, Fcb );

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_REPARSE_POINT_CHANGE );

        //
        //  Checkpoint the Txn to commit the changes.
        //

        NtfsCleanupTransactionAndCommit( IrpContext, STATUS_SUCCESS, TRUE );

        //
        //  Flag the change time change in the Ccb.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Don't set the archive bit on a directory.  Otherwise we break existing
        //  apps that don't expect to see this flag.
        //

        if (!IsDirectory( &Fcb->Info )) {

            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

        //
        //  Reflect that the attribute is gone in the corresponding Scb.
        //

        if (NonResidentScbAcquired) {

            NonResidentScb->AttributeTypeCode = $UNUSED;

            //
            //  If we have acquired the Scb then set the sizes back to zero.
            //  Flag that the attribute has been deleted.
            //

            NonResidentScb->Header.FileSize =
            NonResidentScb->Header.ValidDataLength =
            NonResidentScb->Header.AllocationSize = Li0;

            //
            //  Set the Scb flag to indicate that the attribute is gone.
            //

            SetFlag( NonResidentScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

            //
            //  Go ahead and dereference any internal file object.  No sense in keeping it around.
            //

            NtfsDeleteInternalAttributeStream( NonResidentScb, FALSE, 0 );
        }

    try_exit:  NOTHING;

    } finally {

        DebugUnwind( NtfsDeleteReparsePoint );

        //
        //  Unpin the Bcb. The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Need to roll-back the value of the reparse point flag in case of
        //  problems. I leave the archive bit set anyway.
        //

        if (AbnormalTermination()) {

           Fcb->Info.FileAttributes = IncomingFileAttributes;
           Fcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }

        //
        //  Release the reparse point index Scb and the map handle.
        //

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

    return Status;
}



NTSTATUS
NtfsGetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PNTFS_TUNNELED_DATA TunneledData
    )

/*++

Routine Description:

    This routine will get the tunneled data for the
    given Fcb.  Currently, this means getting the Fcb's
    creation time.

Arguments:

    Fcb - Supplies the Fcb for which to get the data.

    TunneledData - Where to store the tunneled data.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( IrpContext );

    TunneledData->CreationTime = Fcb->Info.CreationTime;

    return STATUS_SUCCESS;
}


NTSTATUS
NtfsSetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PNTFS_TUNNELED_DATA TunneledData
    )

/*++

Routine Description:

    This routine will set the tunneled data for the
    given Fcb.  Currently, this means setting the Fcb's
    creation time and setting its object id, if any.

Arguments:

    Fcb - Supplies the Fcb whose tunneled data should be set.

    TunneledData - Supplies the data to set for the Fcb.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    Fcb->Info.CreationTime = TunneledData->CreationTime;

    if (TunneledData->HasObjectId) {

        try {

            Status = NtfsSetObjectIdInternal( IrpContext,
                                              Fcb,
                                              Fcb->Vcb,
                                              &TunneledData->ObjectIdBuffer );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            NtfsMinimumExceptionProcessing( IrpContext );

            //
            //  If setting the object id failed just because the id is in use
            //  for another file, or if the file already has an object id,
            //  there's no point in failing the entire create operation.
            //  We'll just say that all went well in that case, and only raise
            //  if something unexpected happened.
            //

            if ((Status == STATUS_DUPLICATE_NAME) ||
                (Status == STATUS_OBJECT_NAME_COLLISION)) {

                //
                //  We notify anyone watching the object id index that this
                //  object id couldn't be tunnelled.  This lets a link tracking
                //  service decide for itself how to handle this case.
                //

                if (Fcb->Vcb->ViewIndexNotifyCount != 0) {

                    FILE_OBJECTID_INFORMATION FileObjectIdInfo;

                    RtlCopyMemory( &FileObjectIdInfo.FileReference,
                                   &Fcb->FileReference,
                                   sizeof(FILE_REFERENCE) );

                    RtlCopyMemory( FileObjectIdInfo.ObjectId,
                                   TunneledData->ObjectIdBuffer.ObjectId,
                                   OBJECT_ID_KEY_LENGTH );

                    RtlCopyMemory( FileObjectIdInfo.ExtendedInfo,
                                   TunneledData->ObjectIdBuffer.ExtendedInfo,
                                   OBJECT_ID_EXT_INFO_LENGTH );

                    NtfsReportViewIndexNotify( Fcb->Vcb,
                                               Fcb->Vcb->ObjectIdTableScb->Fcb,
                                               FILE_NOTIFY_CHANGE_FILE_NAME,
                                               (Status == STATUS_DUPLICATE_NAME ?
                                                FILE_ACTION_ID_NOT_TUNNELLED :
                                                FILE_ACTION_TUNNELLED_ID_COLLISION),
                                               &FileObjectIdInfo,
                                               sizeof(FILE_OBJECTID_INFORMATION) );
                }

                IrpContext->ExceptionStatus = Status = STATUS_SUCCESS;

            } else {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL);
            }
        }
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsCreateUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine creates the Usn journal for the first time, and is a noop
    if Usn journal already exists.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    CREATE_USN_JOURNAL_DATA CapturedData;

    //
    //  Don't post this request, we can't lock the input buffer.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    if (Vcb->ExtendDirectory == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Check for a minimum length on the input buffer.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( CREATE_USN_JOURNAL_DATA )) {
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Do the work, if needed.  Acquire the VCB exclusive to lock out creates which
    //  have a locking order vis a vis the usn journal / extend directory / mft opposed
    //  to this path
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    try {

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Also fail if the journal is currently being deleted.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

            NtfsRaiseStatus( IrpContext, STATUS_JOURNAL_DELETE_IN_PROGRESS, NULL, NULL );
        }

        //
        //  Capture the JournalData from the unsafe user buffer.
        //

        try {

            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( CREATE_USN_JOURNAL_DATA ));

            } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                       CREATE_USN_JOURNAL_DATA )){

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            CapturedData = *(PCREATE_USN_JOURNAL_DATA)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL);
        }

        //
        //  Create or change the Usn Journal parameters.
        //

        NtfsInitializeUsnJournal( IrpContext, Vcb, TRUE, FALSE, &CapturedData );

    } finally {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

typedef struct _USN_DATA_CONTEXT {
    USN_RECORD UNALIGNED *UsnRecord;
    ULONG RoomLeft;
    ULONG BytesUsed;
    USN LowUsn;
    USN HighUsn;
    FILE_REFERENCE FileReference;
} USN_DATA_CONTEXT, *PUSN_DATA_CONTEXT;

NTSTATUS
NtfsReadUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine reads the USN data from the file record and returns
    it in the user's buffer.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Pointer to USN_DATA_CONTEXT.

Return Value:

    STATUS_SUCCESS if a record was successfully stored
    STATUS_BUFFER_OVERFLOW if buffer was not big enough for record

--*/
{
    ATTRIBUTE_ENUMERATION_CONTEXT NameContext;
    PUSN_DATA_CONTEXT UsnContext = (PUSN_DATA_CONTEXT) Context;

    PFILE_NAME FileName;
    ULONG RecordLength;
    ULONG FileAttributes;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN MoreToGo;

    //
    //  Find name record; Initialize the context structure.
    //

    try {

        NtfsInitializeAttributeContext( &NameContext );

        //
        //  Locate a file name with the FILE_NAME_NTFS bit set
        //

        MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                              Fcb,
                                              &Fcb->FileReference,
                                              $FILE_NAME,
                                              &NameContext );
        //
        //  While we've found an attribute
        //

        while (MoreToGo) {

            FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &NameContext ));

            //
            //  See if the NTFS name is set for this name.
            //

            if (FlagOn( FileName->Flags, FILE_NAME_NTFS )) {

                break;

            }

            //
            //  The last one wasn't it.  Let's try again.
            //

            MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                      Fcb,
                                                      $FILE_NAME,
                                                      &NameContext );
        }

        if (!MoreToGo) {

            NtfsCleanupAttributeContext( IrpContext, &NameContext );
            NtfsInitializeAttributeContext( &NameContext );

            //
            //  Couldn't find an Ntfs name, check for any hard link.
            //

            MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                                  Fcb,
                                                  &Fcb->FileReference,
                                                  $FILE_NAME,
                                                  &NameContext );
            //
            //  While we've found an attribute
            //

            while (MoreToGo) {

                FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &NameContext ));

                //
                //  See if the DOS name is not set for this name.
                //

                if (!FlagOn( FileName->Flags, FILE_NAME_DOS )) {

                    break;

                }

                //
                //  The last one wasn't it.  Let's try again.
                //

                MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                          Fcb,
                                                          $FILE_NAME,
                                                          &NameContext );
            }

            if (!MoreToGo) {

                ASSERTMSG( "Couldn't find a name string for file\n", FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Check there's enough room for a USN record.
        //
        //  Record length is a function of the filename length and the structure the
        //  user expects.
        //

        RecordLength = FIELD_OFFSET( USN_RECORD, FileName ) + (FileName->FileNameLength * sizeof( WCHAR ));

        RecordLength = QuadAlign( RecordLength );
        if (RecordLength > UsnContext->RoomLeft) {
            Status = STATUS_BUFFER_TOO_SMALL;
            leave;
        }

        if (Fcb->Usn < UsnContext->LowUsn ||
            Fcb->Usn > UsnContext->HighUsn ) {

            leave;
        }

        //
        //  Set up fixed portion of USN record.  The following fields are the
        //  same for either version.
        //

        UsnContext->UsnRecord->RecordLength = RecordLength;
        UsnContext->UsnRecord->FileReferenceNumber = *(PULONGLONG)&Fcb->FileReference;
        UsnContext->UsnRecord->ParentFileReferenceNumber = *(PULONGLONG)&FileName->ParentDirectory;
        UsnContext->UsnRecord->Usn = Fcb->Usn;

        //
        //  Presumably the caller is not interested in the TimeStamp while scanning the Mft,
        //  but if he is, then he may need to go read the Usn we are returning.
        //

        UsnContext->UsnRecord->TimeStamp.QuadPart = 0;
        UsnContext->UsnRecord->Reason = 0;

        //
        //  Build the FileAttributes from the Fcb.
        //

        FileAttributes = Fcb->Info.FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;

        //
        //  We have to generate the DIRECTORY attribute.
        //

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {
            SetFlag( FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
        }

        //
        //  If there are no flags set then explicitly set the NORMAL flag.
        //

        if (FileAttributes == 0) {
            FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        //
        //  Now set the other fields.
        //

        UsnContext->UsnRecord->MajorVersion = 2;
        UsnContext->UsnRecord->MinorVersion = 0;

        UsnContext->UsnRecord->SourceInfo = 0;
        UsnContext->UsnRecord->SecurityId = (ULONG) Fcb->SecurityId;
        UsnContext->UsnRecord->FileAttributes = FileAttributes;

        //
        //  Copy file name to Usn record
        //

        UsnContext->UsnRecord->FileNameLength = (USHORT)(FileName->FileNameLength * sizeof( WCHAR ));
        UsnContext->UsnRecord->FileNameOffset = FIELD_OFFSET( USN_RECORD, FileName );
        RtlCopyMemory( &UsnContext->UsnRecord->FileName[0],
                       &FileName->FileName[0],
                       FileName->FileNameLength * sizeof( WCHAR ));

        //
        //  Adjust context for next record
        //

        UsnContext->UsnRecord = (PUSN_RECORD) Add2Ptr( UsnContext->UsnRecord, RecordLength );
        UsnContext->RoomLeft -= RecordLength;
        UsnContext->BytesUsed += RecordLength;

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &NameContext );

    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsReadFileRecordUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enumerates base file records beginning at a specified
    one and returns USN data from the found records.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;
    USN_DATA_CONTEXT Context;
    MFT_ENUM_DATA UNALIGNED *EnumData = (PMFT_ENUM_DATA) IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    BOOLEAN LockedMdl = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    TYPE_OF_OPEN TypeOfOpen;

    //
    //  Don't post this request.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  We'll catch dismounted volumes explicitly in iterate mft so don't raise on error
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       FALSE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Check for a minimum length on the input and output buffers.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MFT_ENUM_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( FILE_REFERENCE )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    try {

        //
        //  Probe the input and output buffers.
        //

        if (Irp->RequestorMode != KernelMode) {

            ProbeForRead( EnumData,
                          IrpSp->Parameters.FileSystemControl.InputBufferLength,
                          NTFS_TYPE_ALIGNMENT( MFT_ENUM_DATA ));

            ProbeForWrite( Irp->UserBuffer,
               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
               NTFS_TYPE_ALIGNMENT( FILE_REFERENCE ));

        } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                   MFT_ENUM_DATA ) ||
                   !IsTypeAligned( Irp->UserBuffer, FILE_REFERENCE )) {

            Status = STATUS_INVALID_USER_BUFFER;
            leave;
        }

        //
        //  Capture the starting file reference
        //

        Context.FileReference = *(PFILE_REFERENCE) &EnumData->StartFileReferenceNumber;

        if (NtfsFullSegmentNumber( &Context.FileReference ) < FIRST_USER_FILE_NUMBER) {

            NtfsSetSegmentNumber( &Context.FileReference, 0, FIRST_USER_FILE_NUMBER );
        }

        //
        //  Set up for filling output records
        //

        Context.RoomLeft = IrpSp->Parameters.FileSystemControl.OutputBufferLength - sizeof( FILE_REFERENCE );
        Context.UsnRecord = (PUSN_RECORD) Add2Ptr( Irp->UserBuffer, sizeof( FILE_REFERENCE ));
        Context.BytesUsed = sizeof( FILE_REFERENCE );
        Context.LowUsn = EnumData->LowUsn;
        Context.HighUsn = EnumData->HighUsn;

        //
        //  Iterate through the Mft beginning at the specified file reference
        //

        Status = NtfsIterateMft( IrpContext,
                                 Vcb,
                                 &Context.FileReference,
                                 NtfsReadUsnWorker,
                                 &Context );

        if ((Status == STATUS_BUFFER_TOO_SMALL) ||
            ((Status == STATUS_END_OF_FILE) && (Context.BytesUsed != sizeof( FILE_REFERENCE )))) {

            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS( Status )) {

            //
            //  Set the returned file reference number and bytes used. Note: UserBuffer
            //  is a raw user mode ptr and must be in a try-except
            //

            Irp->IoStatus.Information = Context.BytesUsed;
            *((PFILE_REFERENCE) Irp->UserBuffer) = Context.FileReference;
        }

    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

        NtfsRaiseStatus( IrpContext,
                         STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL);
    }

    NtfsCompleteRequest( IrpContext, Irp, Status);
    return Status;
}


//
//  Local Support Routine
//

typedef struct _SID_MATCH_CONTEXT {
    FILE_NAME_INFORMATION UNALIGNED *FileNames;
    ULONG RoomLeft;
    ULONG BytesUsed;
    ULONG OwnerId;
    FILE_REFERENCE Parent;
} SID_MATCH_CONTEXT, *PSID_MATCH_CONTEXT;

NTSTATUS
NtfsFindBySidWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine finds files owned by a Sid in a given context.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Pointer to SID_MATCH_CONTEXT.

Return Value:

    STATUS_SUCCESS if file did not match SID or
        matched sid but wasn't in scope or
        matched sid and was in scope and was stored.
    STATUS_BUFFER_OVERFLOW if buffer was not big enough for record

--*/
{
    PSID_MATCH_CONTEXT SidContext = (PSID_MATCH_CONTEXT) Context;
    SCOPE_CONTEXT ScopeContext;

    NTSTATUS Status;

    //
    //  See if the file is owned by the specified Sid
    //

    if (Fcb->OwnerId != SidContext->OwnerId) {
        return STATUS_SUCCESS;
    }

    //
    //  Find name record; Initialize the context structure.
    //

    try {

        //
        //  If we're at the root of the scope, then build the name directly
        //

        if (NtfsEqualMftRef( &SidContext->Parent, &Fcb->FileReference )) {

            ScopeContext.Name.Buffer = NtfsAllocatePool(PagedPool, 2 );
            ScopeContext.Name.MaximumLength = ScopeContext.Name.Length = 2;
            ScopeContext.Name.Buffer[0] = '\\';

            Status = STATUS_NO_MORE_FILES;

        //
        //  Otherwise, walk up the tree
        //

        } else {
            ScopeContext.IsRoot = NtfsEqualMftRef( &RootIndexFileReference, &SidContext->Parent );
            ScopeContext.Name.Buffer = NULL;
            ScopeContext.Name.Length = 0;
            ScopeContext.Name.MaximumLength = 0;
            ScopeContext.Scope = SidContext->Parent;

            Status = NtfsWalkUpTree( IrpContext, Fcb, NtfsBuildRelativeName, &ScopeContext );
        }

        //
        //  If we either received SUCCESS (i.e., walked to root successfully)
        //  or NO_MORE_FILES (walked to scope successfully)
        //

        if (Status == STATUS_SUCCESS || Status == STATUS_NO_MORE_FILES) {

            ULONG Length =
                QuadAlign( ScopeContext.Name.Length - sizeof( WCHAR ) +
                           sizeof( FILE_NAME_INFORMATION ) - sizeof( WCHAR ));

            //
            //  Verify that there is enough room for this file name
            //

            if (Length > SidContext->RoomLeft) {
                Status = STATUS_BUFFER_TOO_SMALL;
                leave;
            }

            //
            //  Emit the file name to the caller's buffer
            //

            SidContext->FileNames->FileNameLength = ScopeContext.Name.Length - sizeof( WCHAR );
            RtlCopyMemory( SidContext->FileNames->FileName,
                           ScopeContext.Name.Buffer + 1,
                           ScopeContext.Name.Length - sizeof( WCHAR ));

            //
            //  Adjust for next name
            //

            SidContext->BytesUsed += Length;
            SidContext->RoomLeft -= Length;
            SidContext->FileNames = (PFILE_NAME_INFORMATION) Add2Ptr( SidContext->FileNames, Length );
        }

        Status = STATUS_SUCCESS;

    } finally {

        if (ScopeContext.Name.Buffer != NULL) {
            NtfsFreePool( ScopeContext.Name.Buffer );
        }

    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsFindFilesOwnedBySid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enumerates file records, finds entries owned by a
    specified Sid and returns the path relative to the called-on Fcb
    of the found file.

    We hide the details of this Mft-based scan by encapsulating this
    a find-first/next structure.

Arguments:

    IrpContext - context of the call.  The input buffer contains a ULONG
        followed by a SID:
            0 = continue enumeration
            1 = start enumeration

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation



--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FILE_REFERENCE FileReference;
    NTSTATUS Status = STATUS_SUCCESS;
    SID_MATCH_CONTEXT Context;
    PFIND_BY_SID_DATA FindData =
        (PFIND_BY_SID_DATA)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    PFIND_BY_SID_DATA CapturedFindData = NULL;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN ReleaseVcb = FALSE;

    PAGED_CODE();

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Decode the file object, fail this request if not a user data stream.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    if (TypeOfOpen != UserDirectoryOpen || Ccb == NULL) {

        Status = STATUS_INVALID_PARAMETER;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    try {
        try {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            ReleaseVcb = TRUE;

            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( FIND_BY_SID_DATA ));
                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               NTFS_TYPE_ALIGNMENT( FILE_NAME_INFORMATION ));

            } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                       FIND_BY_SID_DATA ) ||
                       !IsTypeAligned( Irp->UserBuffer, FILE_NAME_INFORMATION )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            if (Vcb->OwnerIdTableScb == NULL) {
                Status = STATUS_VOLUME_NOT_UPGRADED;
                leave;
            }

            if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( ULONG )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Allocate a buffer to capture the input buffer.
            //

            CapturedFindData = NtfsAllocatePool( PagedPool,
                                                 IrpSp->Parameters.FileSystemControl.InputBufferLength );

            RtlCopyMemory( CapturedFindData,
                           FindData,
                           IrpSp->Parameters.FileSystemControl.InputBufferLength );

            //
            //  Do some final checks on the input and output buffers.
            //

            if (
                //
                //  The input and output buffers must be aligned
                //

                !IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                FIND_BY_SID_DATA )
                    DebugDoit( && DebugPrint(( "Input buffer not long aligned" ))) ||
                !IsTypeAligned( Irp->UserBuffer, FILE_NAME_INFORMATION )
                    DebugDoit( && DebugPrint(( "Output buffer not long aligned" ))) ||

                //
                //  There must be enough room in the output buffer.
                //  (Input buffer is already verified).
                //

                IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                    sizeof( FILE_NAME_INFORMATION )
                    DebugDoit( && DebugPrint(( "Output buffer shorter than FILE_NAME_INFORMATION" ))) ||

                //
                //  The input flag must be 0 or 1
                //

                CapturedFindData->Restart > 1
                    DebugDoit( && DebugPrint(( "Restart not 0/1" ))) ||

                //
                //  There must be enough room for a SID in the input
                //

                sizeof( ULONG ) + RtlLengthSid( &FindData->Sid ) >
                    IrpSp->Parameters.FileSystemControl.InputBufferLength
                    DebugDoit( && DebugPrint(( "Not enough room for input SID" ))) ||

                //
                //  Also verify the captured data in case our caller is playing games.
                //

                sizeof( ULONG ) + RtlLengthSid( &CapturedFindData->Sid ) >
                    IrpSp->Parameters.FileSystemControl.InputBufferLength
                    DebugDoit( && DebugPrint(( "Not enough room for captured input SID" )))

                ) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Set up starting file reference either from where the user left off
            //  or from the next position
            //

            if (CapturedFindData->Restart) {
                NtfsSetSegmentNumber( &FileReference, 0, ROOT_FILE_NAME_INDEX_NUMBER );
            } else {
                ASSERT( Ccb->NodeByteSize == sizeof( CCB ) );
                FileReference = Ccb->MftScanFileReference;
                if (NtfsSegmentNumber( &FileReference ) < ROOT_FILE_NAME_INDEX_NUMBER) {
                    NtfsSetSegmentNumber( &FileReference, 0, ROOT_FILE_NAME_INDEX_NUMBER );
                }
            }

            //
            //  Set up for filling output records
            //

            Context.RoomLeft = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
            Context.FileNames = (PFILE_NAME_INFORMATION) Irp->UserBuffer;
            Context.BytesUsed = 0;

            //
            //  Convert input Sid into OWNER_ID.  If we haven't seen this SID before
            //  then we are done!  We use the copy of the Sid so we don't take an access
            //  violation in the user frees the memory.  Some of our internal routines
            //  never expect a failure touching this buffer.
            //

            Context.OwnerId = NtfsGetOwnerId( IrpContext, &CapturedFindData->Sid, FALSE, NULL );

            if (Context.OwnerId == QUOTA_INVALID_ID) {
                Status = STATUS_SUCCESS;
                leave;
            }

            Context.Parent = Fcb->FileReference;

            //
            //  Iterate through the Mft beginning at the specified file reference.
            //  Release the Vcb now because the worker routine will acquire and
            //  drop as necessary.  We don't want to block out critical operations
            //  like clean checkpoints during a full Mft scan.
            //

            NtfsReleaseVcb( IrpContext, Vcb );
            ReleaseVcb = FALSE;

            Status = NtfsIterateMft( IrpContext,
                                     Vcb,
                                     &FileReference,
                                     NtfsFindBySidWorker,
                                     &Context );

            //
            //  If we failed due to running out of space and we stored something or
            //  if we ran off the end of the MFT, then this is really a successful
            //  return.
            //

            Irp->IoStatus.Information = Context.BytesUsed;

            if (!NT_SUCCESS( Status )) {
                if ((Status == STATUS_BUFFER_TOO_SMALL && Context.BytesUsed != 0)
                    || Status == STATUS_END_OF_FILE) {
                    Status = STATUS_SUCCESS;
                } else {
                    leave;
                }
            }

            Ccb->MftScanFileReference = FileReference;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL);
        }
    } finally {

        //
        //  Free the Vcb if still held.
        //

        if (ReleaseVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  Free the captured input buffer if allocated.
        //

        if (CapturedFindData != NULL) {

            NtfsFreePool( CapturedFindData );
        }
    }

    //
    //  If nothing raised then complete the irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsReadFileUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enumerates base file records beginning at a specified
    one and returns USN data from the found records.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

    RecordVersion - format for the usn record to return

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;
    USN_DATA_CONTEXT Context;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    //
    //  Don't post this request.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //  We don't want to raise on dismounts here because we check for that further down
    //  anyway. So send FALSE.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Check that the user's buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( USN_RECORD )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Set up for filling output records
    //

    Context.RoomLeft = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    Context.UsnRecord = Irp->UserBuffer;
    Context.BytesUsed = 0;
    Context.LowUsn = 0;
    Context.HighUsn = MAXLONGLONG;

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  Verify the volume is mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Careful access to the user's buffer.
        //

        try {

            //
            //  Probe the output buffer.
            //

            if (Irp->RequestorMode != KernelMode) {

                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               NTFS_TYPE_ALIGNMENT( USN_DATA_CONTEXT ));

            } else if (!IsTypeAligned( Irp->UserBuffer, USN_DATA_CONTEXT )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Now read the Usn data.
            //

            Status = NtfsReadUsnWorker( IrpContext, Fcb, &Context );

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        NtfsReleaseScb( IrpContext, Scb );
    }

    //
    //  On success return bytes in Usn Record.
    //

    if (NT_SUCCESS(Status)) {
        Irp->IoStatus.Information = Context.BytesUsed;
    }

    NtfsCompleteRequest( IrpContext, Irp, Status);

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsWriteUsnCloseRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine writes a close Usn record for the current file, and returns
    its Usn.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PVOID UserBuffer;
    BOOLEAN AccessingUserBuffer = FALSE;

    //
    //  Go ahead and make this operation synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  There must be room in the output buffer.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( USN )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    UserBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Verify the volume is mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Fail this request if the journal is being deleted or is not running.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

            Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
            leave;
        }

        if (!FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

            Status = STATUS_JOURNAL_NOT_ACTIVE;
            leave;
        }

        //
        //  Use a try-except to check our access to the user buffer.
        //

        try {

            //
            //  Probe the output buffer.
            //

            if (Irp->RequestorMode != KernelMode) {

                AccessingUserBuffer = TRUE;
                ProbeForWrite( UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               NTFS_TYPE_ALIGNMENT( USN ));
                AccessingUserBuffer = FALSE;

            } else if (!IsTypeAligned( UserBuffer, USN )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Now write the close record.
            //

            NtfsPostUsnChange( IrpContext, Scb, USN_REASON_CLOSE );

            //
            //  Now, if anything at all is posted to the Usn Journal, we must write it now
            //  so that we do not get a log file full later.
            //

            ASSERT( IrpContext->Usn.NextUsnFcb == NULL );
            if (IrpContext->Usn.CurrentUsnFcb != NULL) {

                //
                //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                //  reduce contention.
                //

                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );
            }

            //
            //  Set the returned Usn.
            //

            AccessingUserBuffer = TRUE;
            *((USN *) UserBuffer) = Fcb->Usn;
            AccessingUserBuffer = FALSE;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status )) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        NtfsReleaseScb( IrpContext, Scb );
    }

    //
    //  On success return bytes in Usn Record.
    //

    if (NT_SUCCESS( Status )) {
        Irp->IoStatus.Information = sizeof( USN );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsBulkSecurityIdCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs a check to see if the current subject is granted access by
    the security descriptors identified by the security Ids.


Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;
    PBULK_SECURITY_TEST_DATA SecurityData =
        (PBULK_SECURITY_TEST_DATA) IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    PNTSTATUS OutputStatus = (PNTSTATUS) Irp->UserBuffer;
    ACCESS_MASK DesiredAccess;
    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    ULONG i, SecurityIdCount;
    SECURITY_SUBJECT_CONTEXT SecurityContext;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBulkSecurityIdCheck...\n") );

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Verify this is a valid type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        Status = STATUS_ACCESS_DENIED;
        DebugTrace( -1, Dbg, ("NtfsBulkSecurityIdCheck -> %08lx\n", Status) );
        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    try {

        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        try {

            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( BULK_SECURITY_TEST_DATA ));
                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               sizeof( ULONG ));

            } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                       BULK_SECURITY_TEST_DATA ) ||
                       !IsTypeAligned( Irp->UserBuffer, ULONG )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            SecurityIdCount =
                (IrpSp->Parameters.FileSystemControl.InputBufferLength
                 - FIELD_OFFSET( BULK_SECURITY_TEST_DATA, SecurityIds )) / sizeof( SECURITY_ID );


            //
            //  The output buffer must contain the same number of NTSTATUS
            //  as SECURITY_IDs
            //

            if (SecurityIdCount * sizeof( NTSTATUS ) != IrpSp->Parameters.FileSystemControl.OutputBufferLength) {

                NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
            }

            //
            //  Capture the desired access so we can modify it
            //

            DesiredAccess = SecurityData->DesiredAccess;
            RtlMapGenericMask( &DesiredAccess, IoGetFileObjectGenericMapping() );

            SeCaptureSubjectContext( &SecurityContext );
            SeLockSubjectContext( &SecurityContext );

            try {
                for (i = 0; i < SecurityIdCount; i++) {

                    PSHARED_SECURITY SharedSecurity;

                    SharedSecurity = NtfsCacheSharedSecurityBySecurityId( IrpContext,
                                                                          Vcb,
                                                                          SecurityData->SecurityIds[i] );

                    //
                    //  Do the access check
                    //

                    AccessGranted = SeAccessCheck( SharedSecurity->SecurityDescriptor,
                                                   &SecurityContext,
                                                   TRUE,                           // Tokens are locked
                                                   DesiredAccess,
                                                   0,
                                                   NULL,
                                                   IoGetFileObjectGenericMapping(),
                                                   UserMode,
                                                   &GrantedAccess,
                                                   &OutputStatus[i] );

                    NtfsAcquireFcbSecurity( Vcb );
                    RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
                    NtfsReleaseFcbSecurity( Vcb );
                }

            } finally {

                SeUnlockSubjectContext( &SecurityContext );
                SeReleaseSubjectContext( &SecurityContext );
            }

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {
        NtfsReleaseVcb( IrpContext, Vcb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status);

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsQueryAllocatedRanges (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routines scans the allocation of the file looking for allocated ranges
    starting from some offset given by our caller.  An allocated range is one
    which either has any allocation within the defined sparse block size (64K) or
    has any clusters reserved within this same block.  Sparse file support is meant
    to optimize the case where the user has a large unallocated range.  We will
    force him to read zeroes from the file where the deallocated ranges are
    smaller than 64K.

    If the file is not marked as sparse then we will return the entire file as
    allocated even for the compressed stream case where large blocks of
    zeroes are represented by holes.

    The Irp contains the input and output buffers for this request.  This fsctrl
    specifies METHOD_NEITHER so we must carefully access these buffers.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN AcquiredScb = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN AccessingUserBuffer = FALSE;
    BOOLEAN Allocated;

    ULONG RemainingBytes;

    LONGLONG StartingOffset;
    LONGLONG Length;

    PFILE_ALLOCATED_RANGE_BUFFER OutputBuffer;
    PFILE_ALLOCATED_RANGE_BUFFER CurrentBuffer;

    VCN NextVcn;
    VCN CurrentVcn;
    LONGLONG RemainingClusters;
    LONGLONG ThisClusterCount;
    LONGLONG TwoGigInClusters;
    BOOLEAN UserMappedView;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Extract and decode the file object.
    //  We only allow this operation on user data files.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    if (NtfsDecodeFileObject( IrpContext,
                              IrpSp->FileObject,
                              &Vcb,
                              &Fcb,
                              &Scb,
                              &Ccb,
                              FALSE ) != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquired exclusive access to the paging Io resource because we might
    //  need to extend the file when flushing the cache
    //

    NtfsAcquireExclusivePagingIo( IrpContext, Scb->Fcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the volume isn't mounted then fail immediately.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Check the length of the input buffer.
        //


        if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Use a try-except to catch any errors accessing the user's buffers.
        //  We will maintain a boolean which indicates if we are accessing
        //  the user's buffer.
        //

        AccessingUserBuffer = TRUE;

        try {

            //
            //  If our caller is not kernel mode then probe the input and
            //  output buffers.
            //

            RemainingBytes = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
            OutputBuffer = (PFILE_ALLOCATED_RANGE_BUFFER) NtfsMapUserBuffer( Irp, NormalPagePriority );
            CurrentBuffer = OutputBuffer - 1;


            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( FILE_ALLOCATED_RANGE_BUFFER ));

                ProbeForWrite( OutputBuffer,
                               RemainingBytes,
                               NTFS_TYPE_ALIGNMENT( FILE_ALLOCATED_RANGE_BUFFER ));

            } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                       FILE_ALLOCATED_RANGE_BUFFER ) ||
                       !IsTypeAligned( OutputBuffer, FILE_ALLOCATED_RANGE_BUFFER )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Carefully extract the starting offset and length from
            //  the input buffer.  If we are beyond the end of the file
            //  or the length is zero then return immediately.  Otherwise
            //  trim the length to file size.
            //

            StartingOffset = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->FileOffset.QuadPart;
            Length = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->Length.QuadPart;
            AccessingUserBuffer = FALSE;

            //
            //  Check that the input parameters are valid.
            //

            if ((Length < 0) ||
                (StartingOffset < 0) ||
                (Length > MAXLONGLONG - StartingOffset)) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            //
            //  Check that the requested range is within file size
            //  and has a non-zero length.
            //

            if (Length == 0) {

                leave;
            }

            //
            //  Lets acquire the Scb for the file as well.
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            AcquiredScb = TRUE;

            NtfsAcquireFsrtlHeader( Scb );

            if (StartingOffset >= Scb->Header.FileSize.QuadPart) {

                NtfsReleaseFsrtlHeader( Scb );
                leave;
            }

            if (Scb->Header.FileSize.QuadPart - StartingOffset < Length) {

                Length = Scb->Header.FileSize.QuadPart - StartingOffset;
            }

            NtfsReleaseFsrtlHeader( Scb );

            //
            //  If the file is not sparse or is resident then show that
            //  the entire requested range is allocated.
            //

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ||
                FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

                    Status = STATUS_BUFFER_TOO_SMALL;

                } else {

                    CurrentBuffer += 1;
                    AccessingUserBuffer = TRUE;
                    CurrentBuffer->FileOffset.QuadPart = StartingOffset;
                    CurrentBuffer->Length.QuadPart = Length;
                    Irp->IoStatus.Information = sizeof( FILE_ALLOCATED_RANGE_BUFFER );
                }

                leave;
            }

            //
            //  Convert the range to check to Vcns so we can use the
            //  allocation routines.
            //

            NextVcn = -1;

            CurrentVcn = LlClustersFromBytesTruncate( Vcb, StartingOffset );
            CurrentVcn = BlockAlignTruncate( CurrentVcn, (LONG)Vcb->SparseFileClusters );

            RemainingClusters = LlClustersFromBytesTruncate( Vcb,
                                                             StartingOffset + Length + Vcb->SparseFileUnit - 1 );

            RemainingClusters = BlockAlignTruncate( RemainingClusters, (LONG)Vcb->SparseFileClusters );
            RemainingClusters -= CurrentVcn;

            TwoGigInClusters = LlClustersFromBytesTruncate( Vcb, (LONGLONG) 0x80000000 );

            //
            //  We will walk through the file in two gigabyte chunks.
            //

            do {

                //
                //  We will try to swallow two gig at a time.
                //

                ThisClusterCount = TwoGigInClusters;

                if (ThisClusterCount > RemainingClusters) {

                    ThisClusterCount = RemainingClusters;
                }

                RemainingClusters -= ThisClusterCount;

                //
                //  Preload two gigabytes of allocation information at our Current Vcn.
                //

                NtfsPreloadAllocation( IrpContext,
                                       Scb,
                                       CurrentVcn,
                                       CurrentVcn + ThisClusterCount );

                //
           