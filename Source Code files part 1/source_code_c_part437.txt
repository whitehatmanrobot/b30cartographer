E;
}


/*++

GetCardInfo:

    This routine finds the given card under the given scope, and returns all
    information associated with it.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szCard supplies the name of the card for which info is to be extracted.

    pbfAtr receives the ATR string of the given card.  This parameter may be
        NULL if the ATR is not desired.

    pbfAtrMask receives the ATR mask of the given card, if any.  This parameter
        may be NULL if the value is not desired.

    pbfInterfaces receives the list of interfaces as an array of GUIDs for the
        given card, if any.  This parameter may be NULL if the value is not
        desired.

    pbfProvider receives the Primary Provider of the given card, if any.  This
        parameter may be NULL if the value is not desired.

Return Value:

    TRUE - The card was found, the returned data is valid.
    FALSE - The supplied card was not found.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/3/1996

--*/

BOOL
GetCardInfo(
    IN DWORD dwScope,
    IN LPCTSTR szCard,
    OUT CBuffer *pbfAtr,
    OUT CBuffer *pbfAtrMask,
    OUT CBuffer *pbfInterfaces,
    OUT CBuffer *pbfProvider)
{
    CRegistry regCard;


    //
    // Find the Card definition closest to the caller.
    //

    try
    {
        FindKey(
            dwScope,
            szCard,
            regCard,
            SCARD_REG_CARDS,
            SCARD_REG_TEMPLATES);
    }
    catch (...)
    {
        return FALSE;
    }


    //
    // Look up all it's values.
    //

    if (NULL != pbfAtr)
    {
        // Card ATR String
        try
        {
            regCard.GetValue(SCARD_REG_ATR, *pbfAtr);
        }
        catch (...)
        {
            pbfAtr->Reset();
        }
    }

    if (NULL != pbfAtrMask)
    {
        // Card ATR Comparison Mask
        try
        {
            regCard.GetValue(SCARD_REG_ATRMASK, *pbfAtrMask);
        }
        catch (...)
        {
            pbfAtrMask->Reset();
        }
    }

    if (NULL != pbfInterfaces)
    {
        // Supported Interface List
        try
        {
            regCard.GetValue(SCARD_REG_GUIDS, *pbfInterfaces);
        }
        catch (...)
        {
            pbfInterfaces->Reset();
        }
    }

    if (NULL != pbfProvider)
    {
        // Card Primary Provider
        try
        {
            regCard.GetValue(SCARD_REG_PPV, *pbfProvider);
        }
        catch (...)
        {
            pbfProvider->Reset();
        }
    }

    return TRUE;
}


#ifdef ENABLE_SCARD_TEMPLATES
/*++

ListCardTypeTemplates:

    This routine searches the template database looking for previously defined
    smart card templates against which the given card ATR matches.  If the ATR
    parameter is NULL, it returns a list of all templates.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    pbAtr supplies the ATR of a card to be matched against the known templates.

    bfTemplates receives a list of matching template names, as a multistring.

Return Value:

    TRUE - At least one template was found.
    FALSE - No matching templates were found.

Throws:

    Errors

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

BOOL
ListCardTypeTemplates(
    IN DWORD dwScope,
    IN LPCBYTE pbAtr,
    OUT CBuffer &bfTemplates)
{
    CRegistry regCard;
    LPCTSTR szCard;
    CBuffer bfCardAtr;
    CBuffer bfCardList;

    bfTemplates.Reset();
    ListKnownKeys(dwScope, bfCardList, SCARD_REG_TEMPLATES);
    for (szCard = FirstString(bfCardList);
         NULL != szCard;
         szCard = NextString(szCard))
    {
        try
        {
            FindKey(dwScope, szCard, regCard, SCARD_REG_TEMPLATES);


            //
            // Does this card match the supplied ATR?
            //

            if ((NULL != pbAtr) && (0 != *pbAtr))
            {
                LPCBYTE pbCardAtr, pbCardMask;
                DWORD cbCardAtr, cbCardMask;

                pbCardAtr = regCard.GetBinaryValue(
                                        SCARD_REG_ATR,
                                        &cbCardAtr);
                bfCardAtr.Set(pbCardAtr, cbCardAtr);
                try
                {
                    pbCardMask = regCard.GetBinaryValue(
                                            SCARD_REG_ATRMASK,
                                            &cbCardMask);
                    if (cbCardAtr != cbCardMask)
                        continue;       // Invalid ATR/Mask combination.
                }
                catch (...)
                {
                    pbCardMask = NULL;  // No mask.
                }

                if (!AtrCompare(pbAtr, bfCardAtr, pbCardMask, cbCardAtr))
                    continue;           // ATRs invalid or don't match.
            }


            //
            // This card passes all the tests -- Include it.
            //

            MStrAdd(bfTemplates, szCard);
        }
        catch (...) {}
    }
    if (0 == bfTemplates.Length())
    {
        bfTemplates.Set((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
        return FALSE;
    }
    else
        return TRUE;
}
#endif  // ENABLE_SCARD_TEMPLATES


//
////////////////////////////////////////////////////////////////////////////////
//
// Support Routines
//

/*++

ListKnownKeys:

    This routine lists all known keys of a given type within the current
    caller's scope.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    bfKeys receives a multistring of existing key names, sorted and stripped
        of duplicates.

    szUserList supplies the primary registry path from which key names are to
        be returned.

    szSystemList supplies an optional secondary path from which key names can
        be returned if the caller is running at system scope.

Return Value:

    TRUE - At least one was found
    FALSE - None were found.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/22/1998

--*/

static BOOL
ListKnownKeys(
    IN  DWORD dwScope,
    OUT CBuffer &bfKeys,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList)
{
    DWORD dwSpace, dwIndex, dwCount;
    CRegistry regScopeKey;
    CBuffer bfMyList;
    LPCTSTR rgszLists[2];


    //
    // Loop through introduced space, then if appropriate, template space.
    //

    rgszLists[0] = szUserList;
    rgszLists[1] = szSystemList;
    for (dwSpace = 0; 2 > dwSpace; dwSpace += 1)
    {
        if (NULL == rgszLists[dwSpace])
            continue;


        //
        // Loop through all the possible scopes, from highest to lowest.
        //

        for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
        {
            if (l_rgRegMap[dwIndex].dwScope >= dwScope)
            {

                //
                // If the caller is under this scope, then look for existing
                // Keys.
                //

                regScopeKey.Open(
                    l_rgRegMap[dwIndex].hKey,
                    rgszLists[dwSpace],
                    KEY_READ);
                if (SCARD_S_SUCCESS != regScopeKey.Status(TRUE))
                    continue;


                //
                // Pull out all it's subkey names.
                //

                for (dwCount = 0;; dwCount += 1)
                {
                    LPCTSTR szKey;

                    szKey = regScopeKey.Subkey(dwCount);
                    if (NULL == szKey)
                        break;

                    bfMyList.Append(
                        (LPBYTE)szKey,
                        (lstrlen(szKey) + 1) * sizeof(TCHAR));
                }
            }
        }


        //
        // Don't go on to the system list unless we're at system scope.
        //

        if (SCARD_SCOPE_SYSTEM != dwScope)
            break;
    }


    //
    // Sort the list, and remove duplicates.
    //

    bfMyList.Append((LPBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
    MStringSort(bfMyList, bfKeys);
    return (2 * sizeof(TCHAR) < bfKeys.Length());
}



/*++

FindKey:

    This routine finds the named key closest in scope to the caller.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szKey supplies the name of the key to be found.

    regKey receives initialization to reference the named key.

    szUserList supplies the primary registry path from which key names are to
        be returned.

    szSystemList supplies an optional secondary path from which key names can
        be returned if the caller is running at system scope.

Return Value:

    TRUE - The key was found.
    FALSE - No such key was found.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/22/1998

--*/

static void
FindKey(
    IN  DWORD dwScope,
    IN LPCTSTR szKey,
    OUT CRegistry &regKey,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList)
{
    DWORD dwSpace, dwIndex;
    CRegistry regScopeKey;
    LPCTSTR rgszLists[2];


    //
    // Loop through introduced space, then if appropriate, template space.
    //

    rgszLists[0] = szUserList;
    rgszLists[1] = szSystemList;
    for (dwSpace = 0; 2 > dwSpace; dwSpace += 1)
    {
        if (NULL == rgszLists[dwSpace])
            continue;


        //
        // Loop through all the possible scopes, from highest to lowest.
        //

        for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
        {
            if (l_rgRegMap[dwIndex].dwScope >= dwScope)
            {

                //
                // If the caller is under this scope, then look for an
                // existing Key.
                //

                regScopeKey.Open(
                    l_rgRegMap[dwIndex].hKey,
                    rgszLists[dwSpace],
                    KEY_READ);
                if (SCARD_S_SUCCESS != regScopeKey.Status(TRUE))
                    continue;

                regKey.Open(regScopeKey, szKey, KEY_READ);
                if (SCARD_S_SUCCESS != regKey.Status(TRUE))
                    continue;

                //
                // We've found such a key.  Return immediately.
                //

                return;
            }
        }


        //
        // Don't go on to the system list unless we're at system scope.
        //

        if (SCARD_SCOPE_SYSTEM != dwScope)
            break;
    }


    //
    // We didn't find any such key.
    //

    throw (DWORD)ERROR_FILE_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\common\misc.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    misc

Abstract:

    This module contains an interesting collection of routines that are
    generally useful in the Calais context, but don't seem to fit anywhere else.

Author:

    Doug Barlow (dbarlow) 11/14/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <Windows.h>
#include <SCardLib.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>


/*++

MemCompare:

    This routine compares memory sections.

Arguments:

    pbOne supplies the address of the first block of memory

    pbTwo supplies the address of the second block of memory

    cbLength supplies the length of the two memory segments.

Return Value:

    the difference between the first two differing bytes, or zero if they're the
    identical.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/26/1996

--*/

int
MemCompare(
    IN LPCBYTE pbOne,
    IN LPCBYTE pbTwo,
    IN DWORD cbLength)
{
    for (DWORD index = 0; index < cbLength; index += 1)
    {
        if (*pbOne++ != *pbTwo++)
            return (int)*(--pbOne) - (int)*(--pbTwo);
    }
    return 0;
}


/*++

MStrAdd:

    This method adds a string to the end of a multistring contained in a
    CBuffer.  The CBuffer may be empty, in which case its value becomes a
    multistring with the single string element.

Arguments:

    bfMsz supplies the multistring to be modified.

    szAdd supplies the string to append.

Return Value:

    the number of strings in the resulting multistring.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/29/1997

--*/

DWORD
MStrAdd(
    IN OUT CBuffer &bfMsz,
    IN LPCSTR szAdd)
{
    DWORD dwLen, dwAddLen;
    CBuffer bfTmp;

    dwLen = bfMsz.Length();
    if (0 < dwLen)
    {
        ASSERT(2 * sizeof(TCHAR) <= dwLen);
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - sizeof(TCHAR))));
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - 2 * sizeof(TCHAR))));
        dwLen -= sizeof(TCHAR);
    }

    dwAddLen = MoveString(bfTmp, szAdd);
    bfMsz.Presize((dwLen + dwAddLen + 1) * sizeof(TCHAR), TRUE);
    bfMsz.Resize(dwLen, TRUE);  // Trim one trailing NULL, if any.
    bfMsz.Append(bfTmp.Access(), dwAddLen * sizeof(TCHAR));
    bfMsz.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
    return MStrLen(bfMsz);
}

DWORD
MStrAdd(
    IN OUT CBuffer &bfMsz,
    IN LPCWSTR szAdd)
{
    DWORD dwLen, dwAddLen;
    CBuffer bfTmp;

    dwLen = bfMsz.Length();
    if (0 < dwLen)
    {
        ASSERT(2 * sizeof(TCHAR) <= dwLen);
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - sizeof(TCHAR))));
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - 2 * sizeof(TCHAR))));
        dwLen -= sizeof(TCHAR);
    }

    dwAddLen = MoveString(bfTmp, szAdd);
    bfMsz.Presize((dwLen + dwAddLen + 2) * sizeof(TCHAR), TRUE);
    bfMsz.Resize(dwLen, TRUE);  // Trim one trailing NULL, if any.
    bfMsz.Append(bfTmp.Access(), dwAddLen * sizeof(TCHAR));
    bfMsz.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
    return MStrLen(bfMsz);
}


/*++

MStrLen:

    This routine determines the length of a Multi-string, in characters.

Arguments:

    mszString supplies the string to compute the length of.

Return Value:

    The length of the string, in characters, including trailing zeroes.

Author:

    Doug Barlow (dbarlow) 11/14/1996

--*/

DWORD
MStrLen(
    LPCSTR mszString)
{
    DWORD dwLen, dwTotLen = 0;

    for (;;)
    {
        dwLen = lstrlenA(&mszString[dwTotLen]);
        dwTotLen += dwLen + 1;
        if (0 == dwLen)
            break;
    }
    if (2 > dwTotLen)
        dwTotLen = 2;  // Include the second trailing null character.
    return dwTotLen;
}

DWORD
MStrLen(
    LPCWSTR mszString)
{
    DWORD dwLen, dwTotLen = 0;

    for (;;)
    {
        dwLen = lstrlenW(&mszString[dwTotLen]);
        dwTotLen += dwLen + 1;
        if (0 == dwLen)
            break;
    }
    if (2 > dwTotLen)
        dwTotLen = 2;  // Include the second trailing null character.
    return dwTotLen;
}


/*++

FirstString:

    This routine returns a pointer to the first string in a multistring, or NULL
    if there aren't any.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the first null-terminated string in the structure, or NULL if
    there are no strings.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

LPCTSTR
FirstString(
    IN LPCTSTR szMultiString)
{
    LPCTSTR szFirst = NULL;

    try
    {
        if (0 != *szMultiString)
            szFirst = szMultiString;
    }
    catch (...) {}

    return szFirst;
}



/*++

NextString:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the current string in a
    multi-string structure, it returns the next string, or NULL if no other
    strings follow the current string.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the next Null-terminated string in the structure, or NULL if
    no more strings follow.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/

LPCTSTR
NextString(
    IN LPCTSTR szMultiString)
{
    LPCTSTR szNext;

    try
    {
        DWORD cchLen = lstrlen(szMultiString);
        if (0 == cchLen)
            szNext = NULL;
        else
        {
            szNext = szMultiString + cchLen + 1;
            if (0 == *szNext)
                szNext = NULL;
        }
    }

    catch (...)
    {
        szNext = NULL;
    }

    return szNext;
}


/*++

StringIndex:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the starting address of a
    multi-string structure, it returns the nth string in the structure, where n
    is a zero-based index.  If the supplied value for n exceeds the number of
    strings in the structure, NULL is returned.

Arguments:

    szMultiString - This supplies the address of the Multi-string structure.

    dwIndex - This supplies the index value into the structure.

Return Value:

    The address of the specified Null-terminated string in the structure, or
    NULL if dwIndex indexes beyond the end of the structure.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/

LPCTSTR
StringIndex(
    IN LPCTSTR szMultiString,
    IN DWORD dwIndex)
{
    LPCTSTR szCurrent = szMultiString;

    try
    {
        DWORD index;
        for (index = 0; (index < dwIndex) && (NULL != szCurrent); index += 1)
            szCurrent = NextString(szCurrent);
    }

    catch (...)
    {
        szCurrent = NULL;
    }

    return szCurrent;
}


/*++

MStringCount:

    This routine returns the count of the number of strings in a multistring

Arguments:

    mszInString supplies the input string to be sorted.

Return Value:

    The count of strings

Throws:

    None

Author:

    Ross Garmoe (v-rossg) 12/05/1996

--*/

DWORD
MStringCount(
    LPCTSTR mszInString)
{
    LPCTSTR szCurrent;
        DWORD   cStr = 0;

    //
    // Count the strings
    //

    for (szCurrent = FirstString(mszInString);
         NULL != szCurrent;
         szCurrent = NextString(szCurrent))
        cStr++;

        return (cStr);
}


/*++

MStringSort:

    This routine rearranges a multistring so that the elements are sorted and
    duplicates are eliminated.

Arguments:

    mszInString supplies the input string to be sorted.

    bfOutString receives the sorted string.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringSort(
    LPCTSTR mszInString,
    CBuffer &bfOutString)
{
    LPCTSTR szCurrent;
    LPCTSTR szTmp;
    CDynamicArray<const TCHAR> rgszElements;
    DWORD ix, jx, kx, nMax;
    int nDiff;


    //
    // Set up for the sort.
    //

    for (szCurrent = FirstString(mszInString);
         NULL != szCurrent;
         szCurrent = NextString(szCurrent))
        rgszElements.Add(szCurrent);


    //
    // Do a simple bubble sort, eliminating duplicates.  (We don't use qsort
    // here, to ensure that the Run-time library doesn't get pulled in.)
    //

    nMax = rgszElements.Count();
    if (0 == nMax)
    {
        bfOutString.Set((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
        return (nMax);     // No elements implies nothing to do.
    }
    for (ix = 0; ix < nMax; ix += 1)
    {
        for (jx = nMax - 1; ix < jx; jx -= 1)
        {
            nDiff = lstrcmpi(rgszElements[jx - 1], rgszElements[jx]);
            if (0 < nDiff)
            {
                szTmp = rgszElements.Get(jx - 1);
                rgszElements.Set(jx - 1, rgszElements.Get(jx));
                rgszElements.Set(jx, szTmp);
            }
            else if (0 == nDiff)
            {
                for (kx = jx; kx < nMax - 1; kx += 1)
                    rgszElements.Set(kx, rgszElements.Get(kx + 1));
                rgszElements.Set(nMax -1, NULL);
                nMax -= 1;
            }
            // else 0 > nDiff, which is what we want.
        }
    }


    //
    // Write the sorted strings to the output buffer.
    //

    jx = 0;
    for (ix = 0; ix < nMax; ix += 1)
        jx += lstrlen(rgszElements[ix]) + 1;
    bfOutString.Presize((jx + 2) * sizeof(TCHAR));
    bfOutString.Reset();

    for (ix = 0; ix < nMax; ix += 1)
    {
        szTmp = rgszElements[ix];
        bfOutString.Append(
                (LPCBYTE)szTmp,
                (lstrlen(szTmp) + 1) * sizeof(TCHAR));
    }
    bfOutString.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));
    return (nMax);
}


/*++

MStringMerge:

    This routine merges two Multistrings into a single multistring without
    duplicate entries.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the combined strings.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringMerge(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    DWORD dwLenOne = (MStrLen(mszOne) - 1) * sizeof(TCHAR);
    DWORD dwLenTwo = MStrLen(mszTwo) * sizeof(TCHAR);
    CBuffer bfTmp;

    bfTmp.Presize((dwLenOne + dwLenTwo) * sizeof(TCHAR));
    bfTmp.Set((LPCBYTE)mszOne, dwLenOne);
    bfTmp.Append((LPCBYTE)mszTwo, dwLenTwo);

    return MStringSort((LPCTSTR)bfTmp.Access(), bfOutString);
}


/*++

MStringCommon:

    This routine finds strings which are common to both supplied multistrings,
    and returns the list of commonalities.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the intersection of the strings.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringCommon(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    CBuffer bfOne, bfTwo;
    LPCTSTR szOne, szTwo;
    DWORD dwStrings = 0;
    int nDiff;

    bfOutString.Reset();
    MStringSort(mszOne, bfOne);
    MStringSort(mszTwo, bfTwo);
    szOne = FirstString(bfOne);
    szTwo = FirstString(bfTwo);

    while ((NULL != szOne) && (NULL != szTwo))
    {
        nDiff = lstrcmpi(szOne, szTwo);
        if (0 > nDiff)
            szOne = NextString(szOne);
        else if (0 < nDiff)
            szTwo = NextString(szTwo);
        else    // a match!
        {
            bfOutString.Append(
                (LPCBYTE)szOne,
                (lstrlen(szOne) + 1) * sizeof(TCHAR));
            szOne = NextString(szOne);
            szTwo = NextString(szTwo);
            dwStrings += 1;
        }
    }
    if (0 == dwStrings)
        bfOutString.Append((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
    else
        bfOutString.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));
    return dwStrings;
}


/*++

MStringRemove:

    This routine scans the first supplied multistring, removing any entries that
    exist in the second string.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the value of the first string without the second
        string.

Return Value:

    Number of strings in output buffer

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringRemove(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    CBuffer bfOne, bfTwo;
    LPCTSTR szOne, szTwo;
    int nDiff;
        DWORD   cStr = 0;

    bfOutString.Reset();
    MStringSort(mszOne, bfOne);
    MStringSort(mszTwo, bfTwo);
    szOne = FirstString(bfOne);
    szTwo = FirstString(bfTwo);

    while ((NULL != szOne) && (NULL != szTwo))
    {
        nDiff = lstrcmpi(szOne, szTwo);
        if (0 > nDiff)
        {
            bfOutString.Append(
                (LPCBYTE)szOne,
                (lstrlen(szOne) + 1) * sizeof(TCHAR));
            szOne = NextString(szOne);
                        cStr++;
        }
        else if (0 < nDiff)
        {
            szTwo = NextString(szTwo);
        }
        else    // a match!
        {
            szOne = NextString(szOne);
            szTwo = NextString(szTwo);
        }
    }
    while (NULL != szOne)
    {
                bfOutString.Append(
                        (LPCBYTE)szOne,
                        (lstrlen(szOne) + 1) * sizeof(TCHAR));
                        szOne = NextString(szOne);
                cStr++;
    }
    bfOutString.Append(
        (LPCBYTE)TEXT("\000"),
        (DWORD)(0 == cStr ? 2 * sizeof(TCHAR) :sizeof(TCHAR)));
    return cStr;
}


/*++

ParseAtr:

    This routine parses an ATR string.

Arguments:

    pbAtr supplies the ATR string.

    pdwAtrLen receives the length of the ATR string.  This is an optional
        parameter, and may be NULL.

    pdwHistOffset receives the offset into the ATR string at which the history
        string starts; i.e., the history string is at pbAtr[*pdwOffset].

    pcbHisory receives the length of the history string, in bytes.

    cbMaxLen supplies the maximum length of this ATR string.  Typically this is
        33, but you can restrict it to less by setting this parameter.

Return Value:

    TRUE - Valid ATR
    FALSE - Invalid ATR

Author:

    Doug Barlow (dbarlow) 11/14/1996

--*/

BOOL
ParseAtr(
    LPCBYTE pbAtr,
    LPDWORD pdwAtrLen,
    LPDWORD pdwHistOffset,
    LPDWORD pcbHistory,
    DWORD cbMaxLen)
{
    static const BYTE rgbYMap[] = {
        0,      // 0000
        1,      // 0001
        1,      // 0010
        2,      // 0011
        1,      // 0100
        2,      // 0101
        2,      // 0110
        3,      // 0111
        1,      // 1000
        2,      // 1001
        2,      // 1010
        3,      // 1011
        2,      // 1100
        3,      // 1101
        3,      // 1110
        4 };    // 1111
    DWORD dwHistLen, dwHistOffset, dwTDLen, dwIndex, dwAtrLen;
    BOOL fTck = FALSE;


    ASSERT(33 >= cbMaxLen);
    try
    {


        //
        // Get the ATR string, if any.
        //

        if ((0x3b != pbAtr[0]) && (0x3f != pbAtr[0]))
            throw (DWORD)ERROR_NOT_SUPPORTED;
        dwHistLen = pbAtr[1] & 0x0f;
        dwIndex = 1;
        dwTDLen = 0;
        for (;;)
        {
            dwIndex += dwTDLen;
            dwTDLen = rgbYMap[(pbAtr[dwIndex] >> 4) & 0x0f];
            if (cbMaxLen < dwIndex + dwTDLen + dwHistLen)
                throw (DWORD)ERROR_INVALID_DATA;
            if (0 == dwTDLen)
                break;
            if (0 != (pbAtr[dwIndex] & 0x80))
            {
                if (0 != (pbAtr[dwIndex + dwTDLen] & 0x0f))
                    fTck = TRUE;
            }
            else
                break;
        }
        dwIndex += dwTDLen + 1;
        dwHistOffset = dwIndex;
        dwAtrLen = dwIndex + dwHistLen + (fTck ? 1 : 0);
        if (cbMaxLen < dwAtrLen)
            throw (DWORD)ERROR_INVALID_DATA;
        if (fTck)
        {
            BYTE bXor = 0;
            for (dwIndex = 1; dwIndex < dwAtrLen; dwIndex += 1)
                bXor ^= pbAtr[dwIndex];
            if (0 != bXor)
                throw (DWORD)ERROR_INVALID_DATA;
        }
    }

    catch (...)
    {
        return FALSE;
    }


    //
    // Let the caller in on what we know.
    //

    if (NULL != pdwAtrLen)
        *pdwAtrLen = dwAtrLen;
    if (NULL != pdwHistOffset)
        *pdwHistOffset = dwHistOffset;
    if (NULL != pcbHistory)
        *pcbHistory = dwHistLen;
    return TRUE;
}


/*++

AtrCompare:

    This routine compares two ATRs for equality, given an optional ATR mask.  If
    the mask is supplied, ATR1 XORed against the mask must match ATR2.

Arguments:

    pbAtr1 supplies the first ATR.

    pbAtr2 supplies the second ATR,

    pbMask supplies the ATR mask associated with the 2nd ATR.  If this
        parameter is NULL, no mask is used.

    cbAtr2 supplies the length of ATR2 and it's mask.  This value may be zero
        if the length should be derived from ATR2.

Return Value:

    TRUE - They are identical
    FALSE - They differ.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

BOOL
AtrCompare(
    LPCBYTE pbAtr1,
    LPCBYTE pbAtr2,
    LPCBYTE pbMask,
    DWORD cbAtr2)
{
    DWORD dwAtr1Len = 0;
    DWORD dwAtr2Len = 0;


    //
    // Trivial checks.
    //

    if (!ParseAtr(pbAtr1, &dwAtr1Len))
        return FALSE;   // Invalid ATR.
    if ((NULL == pbMask) || (0 == cbAtr2))
    {
        if (!ParseAtr(pbAtr2, &dwAtr2Len))
            return FALSE;   // Invalid ATR.
        if ((0 != cbAtr2) && (dwAtr2Len != cbAtr2))
            return FALSE;   // Lengths don't match.
        if (dwAtr1Len != dwAtr2Len)
            return FALSE;   // Different lengths.
    }
    else
    {
        dwAtr2Len = cbAtr2;
        if (dwAtr1Len != dwAtr2Len)
            return FALSE;   // Different lengths.
    }


    //
    // Apply the mask, if any.
    //

    if (NULL != pbMask)
    {
        for (DWORD index = 0; index < dwAtr2Len; index += 1)
        {
            if ((pbAtr1[index] & pbMask[index]) != pbAtr2[index])
                return FALSE;   // Byte mismatch.
        }
    }
    else
    {
        for (DWORD index = 0; index < dwAtr2Len; index += 1)
        {
            if (pbAtr1[index] != pbAtr2[index])
                return FALSE;   // Byte mismatch.
        }
    }


    //
    // If we get here, they match.
    //

    return TRUE;
}



/*++

MoveString:

    This routine moves an ASCII or UNICODE string into a buffer, converting to
    the character set in use.

Arguments:

    bfDst receives the string, converted to TCHARs, and NULL terminated.

    szSrc supplies the original string.

    dwLength supplies the length of the string, with or without trailing
        nulls, in characters.  A -1 value implies the length should be
        computed based on a trailing null.

Return Value:

    The actual number of characters in the resultant string, including the
    trailing null.

Throws:

    Errors encountered, as DWORDS.

Author:

    Doug Barlow (dbarlow) 2/12/1997

--*/

DWORD
MoveString(
    CBuffer &bfDst,
    LPCSTR szSrc,
    DWORD dwLength)
{
    if ((DWORD)(-1) == dwLength)
        dwLength = lstrlenA(szSrc);
    else
    {
        while ((0 < dwLength) && (0 == szSrc[dwLength - 1]))
            dwLength -= 1;
    }

#ifdef UNICODE
    DWORD dwResultLength;

    dwResultLength =
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            dwLength,
            NULL,
            0);
    if (0 == dwLength)
        throw GetLastError();
    bfDst.Presize((dwResultLength + 1) * sizeof(TCHAR));
    dwResultLength =
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            dwLength,
            (LPTSTR)bfDst.Access(),
            bfDst.Space()/sizeof(TCHAR) - 1);
    if (0 == dwLength)
        throw GetLastError();
    bfDst.Resize(dwResultLength * sizeof(TCHAR), TRUE);
    dwLength = dwResultLength;
#else
    bfDst.Presize((dwLength + 1) * sizeof(TCHAR));
    bfDst.Set((LPCBYTE)szSrc, dwLength * sizeof(TCHAR));
#endif
    bfDst.Append((LPCBYTE)(TEXT("\000")), sizeof(TCHAR));
    dwLength += 1;
    return dwLength;
}

DWORD
MoveString(
    CBuffer &bfDst,
    LPCWSTR szSrc,
    DWORD dwLength)
{
    if ((DWORD)(-1) == dwLength)
        dwLength = lstrlenW(szSrc);
    else
    {
        while ((0 < dwLength) && (0 == szSrc[dwLength - 1]))
            dwLength -= 1;
    }

#ifndef UNICODE
    DWORD dwResultLength =
        WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            dwLength,
            NULL,
            0,
            NULL,
            NULL);
    if (0 == dwResultLength)
        throw GetLastError();
    bfDst.Presize((dwResultLength + 1) * sizeof(TCHAR));
    dwResultLength =
        WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            dwLength,
            (LPSTR)bfDst.Access(),
            bfDst.Space()/sizeof(TCHAR) - 1,
            NULL,
            NULL);
    if (0 == dwResultLength)
        throw GetLastError();
    bfDst.Resize(dwResultLength * sizeof(TCHAR), TRUE);
    dwLength = dwResultLength;
#else
    bfDst.Presize((dwLength + 1) * sizeof(TCHAR));
    bfDst.Set((LPCBYTE)szSrc, dwLength * sizeof(TCHAR));
#endif
    bfDst.Append((LPCBYTE)(TEXT("\000")), sizeof(TCHAR));
    dwLength += 1;
    return dwLength;
}


/*++

MoveToAnsiString:

    This routine moves the internal string representation to an ANSI output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToAnsiString(
    LPSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifdef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            cchLength,
            NULL,
            0,
            NULL,
            NULL);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            cchLength,
            szDst,
            cchLength,
            NULL,
            NULL);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    if (0 < cchLength)
    {
        cchLength += 1;
        if (NULL != szDst)
            CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
    }
#endif
    return cchLength;
}


/*++

MoveToUnicodeString:

    This routine moves the internal string representation to a UNICODE output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToUnicodeString(
    LPWSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifndef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            NULL,
            0);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            szDst,
            cchLength);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    cchLength += 1;
    if (NULL != szDst)
        CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
#endif
    return cchLength;
}


/*++

MoveToAnsiMultistring:

    This routine moves the internal multistring representation to an ANSI output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the multistring.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input multistring.

    cchLength supplies the length of the input string, in characters, with or
        without trailing nulls.  A -1 value implies the length should be
        computed based on a double trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    nulls.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
MoveToAnsiMultiString(
    LPSTR mszDst,
    LPCTSTR mszSrc,
    DWORD cchLength)
{
    DWORD dwLen;

    if ((DWORD)(-1) == cchLength)
        cchLength = MStrLen(mszSrc);
    dwLen = MoveToAnsiString(mszDst, mszSrc, cchLength);
    if (0 == dwLen)
    {
        if (NULL != mszDst)
            mszDst[0] = mszDst[1] = 0;
        dwLen = 2;
    }
    else
    {
        if (NULL != mszDst)
            mszDst[dwLen] = 0;
        dwLen += 1;
    }
    return dwLen;
}


/*++

MoveToUnicodeMultistring:

    This routine moves the internal multistring representation to a
    Unicode output buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the multistring.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input multistring.

    cchLength supplies the length of the input string, in characters, with or
        without trailing nulls.  A -1 value implies the length should be
        computed based on a double trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    nulls.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
MoveToUnicodeMultiString(
    LPWSTR mszDst,
    LPCTSTR mszSrc,
    DWORD cchLength)
{
    DWORD dwLen;

    if ((DWORD)(-1) == cchLength)
        cchLength = MStrLen(mszSrc);
    dwLen = MoveToUnicodeString(mszDst, mszSrc, cchLength);
    if (NULL != mszDst)
        mszDst[dwLen] = 0;
    dwLen += 1;
    return dwLen;
}


/*++

ErrorString:

    This routine does it's very best to translate a given error code into a
    text message.  Any trailing non-printable characters are striped from the
    end of the text message, such as carriage returns and line feeds.

Arguments:

    dwErrorCode supplies the error code to be translated.

Return Value:

    The address of a freshly allocated text string.  Use FreeErrorString to
    dispose of it.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

LPCTSTR
ErrorString(
    DWORD dwErrorCode)
{
    LPTSTR szErrorString = NULL;

    try
    {
        DWORD dwLen;
        LPTSTR szLast;

        dwLen = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwErrorCode,
                    LANG_NEUTRAL,
                    (LPTSTR)&szErrorString,
                    0,
                    NULL);
        if (0 == dwLen)
        {
            ASSERT(NULL == szErrorString);
            dwLen = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(NULL),
                        dwErrorCode,
                        LANG_NEUTRAL,
                        (LPTSTR)&szErrorString,
                        0,
                        NULL);
            if (0 == dwLen)
            {
                ASSERT(NULL == szErrorString);
                szErrorString = (LPTSTR)LocalAlloc(
                                        LMEM_FIXED,
                                        32 * sizeof(TCHAR));
                if (NULL == szErrorString)
                    throw (DWORD)SCARD_E_NO_MEMORY;
                _stprintf(szErrorString, TEXT("0x%08x"), dwErrorCode);
            }
        }

        ASSERT(NULL != szErrorString);
        for (szLast = szErrorString + lstrlen(szErrorString) - 1;
             szLast > szErrorString;
             szLast -= 1)
         {
            if (_istgraph(*szLast))
                break;
            *szLast = 0;
         }
    }
    catch (...)
    {
        FreeErrorString(szErrorString);
        throw;
    }

    return szErrorString;
}


/*++

FreeErrorString:

    This routine frees the Error String allocated by the ErrorString service.

Arguments:

    szErrorString supplies the error string to be deallocated.

Return Value:

    None

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}


/*++

SelectString:

    This routine compares a given string to a list of possible strings, and
    returns the index of the string that matches.  The comparison is done case
    insensitive, and abbreviations are allowed, as long as they're unique.

Arguments:

    szSource supplies the string to be compared against all other strings.

    Following strings supply a list of strings against which the source string
        can be compared.  The last parameter must be NULL.

Return Value:

    0 - No match, or ambiguous match.
    1-n - The source string matches the indexed template string.

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

DWORD
SelectString(
    LPCTSTR szSource,
    ...)
{
    va_list vaArgs;
    DWORD cchSourceLen;
    DWORD dwReturn = 0;
    DWORD dwIndex = 1;
    LPCTSTR szTpl;


    va_start(vaArgs, szSource);


    //
    //  Step through each input parameter until we find an exact match.
    //

    cchSourceLen = lstrlen(szSource);
    if (0 == cchSourceLen)
        return 0;       //  Empty strings don't match anything.
    szTpl = va_arg(vaArgs, LPCTSTR);
    while (NULL != szTpl)
    {
        if (0 == _tcsncicmp(szTpl, szSource, cchSourceLen))
        {
            if (0 != dwReturn)
            {
                dwReturn = 0;
                break;
            }
            dwReturn = dwIndex;
        }
        szTpl = va_arg(vaArgs, LPCTSTR);
        dwIndex += 1;
    }
    va_end(vaArgs);
    return dwReturn;
}


/*++

StringFromGuid:

    This routine converts a GUID into its corresponding string representation.
    It's here so that it's not necessary to link all of OleBase into WinSCard.
    Otherwise, we'd just use StringFromCLSID.

Arguments:

    pguidSource supplies the GUID to convert.

    szGuid receives the GUID as a string.  This string is assumed to be at
        least 39 characters long.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/20/1998

--*/

void
StringFromGuid(
    IN LPCGUID pguidResult,
    OUT LPTSTR szGuid)
{

    //
    // The following placement assumes Little Endianness.
    // {1D92589A-91E4-11d1-93AA-00C04FD91402}
    // 0123456789012345678901234567890123456789
    //           1         2         3
    //

    static const WORD wPlace[sizeof(GUID)]
        = { 8, 6, 4, 2, 13, 11, 18, 16, 21, 23, 26, 28, 30, 32, 34, 36 };
    static const WORD wPunct[]
        = { 0,         9,         14,        19,        24,        37,        38 };
    static const TCHAR chPunct[]
        = { TEXT('{'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('}'), TEXT('\000') };
    DWORD dwI, dwJ;
    TCHAR ch;
    LPTSTR pch;
    LPBYTE pbGuid = (LPBYTE)pguidResult;
    BYTE bVal;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        bVal = pbGuid[dwI];
        pch = &szGuid[wPlace[dwI]];
        for (dwJ = 0; dwJ < 2; dwJ += 1)
        {
            ch = bVal & 0x0f;
            ch += TEXT('0');
            if (ch > TEXT('9'))
                ch += TEXT('A') - (TEXT('9') + 1);
            *pch-- = ch;
            bVal >>= 4;
        }
    }

    dwI = 0;
    do
    {
        szGuid[wPunct[dwI]] = chPunct[dwI];
    } while (0 != chPunct[dwI++]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\common\buffers.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    buffers

Abstract:

    This module provides the run time code to support the CBuffer object.

Author:

    Doug Barlow (dbarlow) 11/7/1995

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <SCardLib.h>


/*++

CBuffer:

    This constructor is a special case for use explicitly with the operator+
    routine.  It builds a CBuffer out of the other two with only a single
    allocation.

Arguments:

    bfSourceOne supplies the first part of the new buffer
    bfSourceTwo supplies the second part of the new buffer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 11/7/1995

--*/

CBuffer::CBuffer(           //  Object assignment constructor.
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    Initialize();
    Presize(bfSourceOne.m_cbDataLength + bfSourceTwo.m_cbDataLength);
    Set(bfSourceOne.m_pbBuffer, bfSourceOne.m_cbDataLength);
    Append(bfSourceTwo.m_pbBuffer, bfSourceTwo.m_cbDataLength);
}


/*++

Clear:

    This routine resets a CBuffer to it's initial state, freeing any allocated
    memory.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

void
CBuffer::Clear(
    void)
{
    if (NULL != m_pbBuffer)
        delete[] m_pbBuffer;
    Initialize();
}


/*++

Reset:

    This routine logically empties the CBuffer without actually deallocating
    memory.  It's data lengh goes to zero.

Arguments:

    None

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Reset(
    void)
{
    m_cbDataLength = 0;
    return m_pbBuffer;
}


/*++

Presize:

    This is the primary workhorse of the CBuffer class.  It ensures that the
    size of the buffer is of the proper size.  Data in the buffer may optionally
    be preserved, in which case the data length doesn't change.  If the buffer
    is not preserved, then the data length is reset to zero.

Arguments:

    cbLength supplies the desired length of the buffer.

    fPreserve supplies a flag indicating whether or not to preserve the current
        contents of the buffer.

Return Value:

    The address of the properly sized buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Presize(
    IN DWORD cbLength,
    IN BOOL fPreserve)
{
    LPBYTE pbNewBuf = NULL;
    if (fPreserve && (0 < m_cbDataLength))
    {

        //
        // Increase the buffer length, and preserve the existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                throw (DWORD)ERROR_OUTOFMEMORY;
            memcpy(pbNewBuf, m_pbBuffer, m_cbDataLength);
            delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            m_cbBufferLength = cbLength;
        }
    }
    else
    {

        //
        // Increase the buffer length, but lose any existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                throw (DWORD)ERROR_OUTOFMEMORY;
            if (NULL != m_pbBuffer)
                delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            m_cbBufferLength = cbLength;
        }
        m_cbDataLength = 0;
    }
    return m_pbBuffer;
}


/*++

Resize:

    This method sets the length of the data to the given size.  If the buffer
    isn't big enough to support that data length, it is enlarged.

Arguments:

    cbLength supplies the new length of the data.

    fPreserve supplies a flag indicating whether or not to preserve existing
        data.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Resize(
    DWORD cbLength,
    BOOL fPreserve)
{
    LPBYTE pb = Presize(cbLength, fPreserve);
    m_cbDataLength = cbLength;
    return pb;
}


/*++

Set:

    This method sets the contents of the data to the given value.  If the buffer
    isn't big enough to hold the given data, it is enlarged.

Arguments:

    pbSource supplies the data to place in the data buffer.

    cbLength supplies the length of that data, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Set(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = Presize(cbLength, FALSE);
    if (0 < cbLength)
        memcpy(pb, pbSource, cbLength);
    m_cbDataLength = cbLength;
    return pb;
}


/*++

CBuffer::Append:

    This method appends the supplied data onto the end of the existing data,
    enlarging the buffer if necessary.

Arguments:

    pbSource supplies the data to be appended.

    cbLength supplies the length of the data to be appended, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Append(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = m_pbBuffer;
    if (0 < cbLength)
    {
        pb = Presize(m_cbDataLength + cbLength, TRUE);
        memcpy(&pb[m_cbDataLength], pbSource, cbLength);
        m_cbDataLength += cbLength;
    }
    return pb;
}


/*++

CBuffer::Compare:

    This method compares the contents of another CBuffer to this one, and
    returns a value indicating a comparative value.

Arguments:

    bfSource supplies the other buffer.

Return Value:

    < 0 - The other buffer is less than this one.
    = 0 - The other buffer is identical to this one.
    > 0 - The other buffer is greater than this one.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

int
CBuffer::Compare(
    const CBuffer &bfSource)
const
{
    if (m_cbDataLength < bfSource.m_cbDataLength)
        return -1;
    else if (m_cbDataLength > bfSource.m_cbDataLength)
        return 1;
    else if (0 < m_cbDataLength)
        return memcmp(m_pbBuffer, bfSource.m_pbBuffer, m_cbDataLength);
    else
        return 0;
}


/*++

operator+:

    This routine is a special operator that allows addition of two CBuffers to
    produce a third, a la bfThree = bfOne + bfTwo.  It calls the special
    protected constructor of CBuffer.

Arguments:

    bfSourceOne supplies the first buffer
    bfSourceTwo supplies the second buffer

Return Value:

    A reference to a temporary CBuffer that is the concatenation of the two
    provided buffers.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

#pragma warning (disable : 4172)
CBuffer &
operator+(
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    return CBuffer(bfSourceOne, bfSourceTwo);
}
#pragma warning (default : 4172)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\common\registry.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This module implements the CRegistry Class, simplifying access to the
    Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    The only exceptions thrown are DWORDs, containing the error code.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <SCardLib.h>

#define NTOHL HTONL

static inline DWORD
HTONL(
    DWORD dwInVal)
{
    DWORD   dwOutVal;
    LPBYTE  pbIn = (LPBYTE)&dwInVal,
            pbOut = (LPBYTE)&dwOutVal;
    for (DWORD index = 0; index < sizeof(DWORD); index += 1)
        pbOut[sizeof(DWORD) - 1 - index] = pbIn[index];
    return dwOutVal;
}


//
//==============================================================================
//
//  CRegistry
//

/*++

CRegistry:

    These routines provide for the construction and destruction of Objects of
    this class.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Throws:

    None.  If the registry access fails, the error will be thrown on first use.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

CRegistry::CRegistry(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
:   m_bfResult()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
    Open(hBase, szName, samDesired, dwOptions, lpSecurityAttributes);
}

CRegistry::CRegistry()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
}

CRegistry::~CRegistry()
{
    Close();
}


/*++

Open:

    These methods allow a CRegistry object to attempt to access a given registry
    entry.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Return Value:

    None

Throws:

    None -- errors are saved for follow-on operations, so that Open can be used
            safely in a constructor.

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void CRegistry::Open(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    Close();
    if (REG_OPTION_EXISTS == dwOptions)
    {
        m_lSts = RegOpenKeyEx(
                    hBase,
                    szName,
                    0,
                    samDesired,
                    &m_hKey);
        m_dwDisposition = REG_OPENED_EXISTING_KEY;
    }
    else
        m_lSts = RegCreateKeyEx(
                    hBase,
                    szName,
                    0,
                    TEXT(""),
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    &m_hKey,
                    &m_dwDisposition);
}


/*++

Close:

    Shut down a CRegistry object, making it available for follow-on opens.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void
CRegistry::Close(
    void)
{
    HRESULT hrSts;

    if (NULL != m_hKey)
    {
        hrSts = RegCloseKey(m_hKey);
        ASSERT(ERROR_SUCCESS == hrSts);
        m_hKey = NULL;
    }
    m_lSts = ERROR_BADKEY;
    m_bfResult.Reset();
}


/*++

Status:

    This routine returns the status code from the construction routine.  This is
    useful to check for errors prior to having them thrown.

Arguments:

    fQuiet indicates whether or not to throw an error if the status is not
        ERROR_SUCCESS.

Return Value:

    The status code from the creation.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LONG
CRegistry::Status(
    BOOL fQuiet)
const
{
    if ((ERROR_SUCCESS != m_lSts) && !fQuiet)
        throw (DWORD)m_lSts;
    return m_lSts;
}


/*++

Empty:

    This method cleans out the registry tree under the given key.  All
    underlying keys and values are removed.  This does it's best -- if an error
    occurs, the emptying operation stops, leaving the registry in an
    indeterminate state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Empty(
    void)
{
    LPCTSTR szValue;
    LPCTSTR szKey;


    //
    // Go through all the values and delete them.
    //

    while (NULL != (szValue = Value(0)))
        DeleteValue(szValue, TRUE);


#if 0       // Obsolete code
    //
    // Go through all the Keys and empty them.
    //

    DWORD dwIndex;
    for (dwIndex = 0; NULL != (szKey = Subkey(dwIndex)); dwIndex += 1)
    {
        CRegistry regEmpty;

        regEmpty.Open(*this, szKey);
        regEmpty.Empty();
        regEmpty.Close();
    }
#endif


    //
    // Now delete all the keys.
    //

    while (NULL != (szKey = Subkey(0)))
        DeleteKey(szKey, TRUE);
}


/*++

Copy:

    This method loads the current registry keys with all the subkeys and values
    from the supplied key.  Current keys and values of this key are deleted.

Arguments:

    regSrc supplies the source registry key from which values and keys will be
        loaded.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Copy(
    CRegistry &regSrc)
{
    LPCTSTR szValue;
    LPCTSTR szKey;
    DWORD dwIndex, dwType;
    CRegistry regSrcSubkey, regDstSubkey;
    CBuffer bfValue;


    //
    // Go through all the values and copy them.
    //

    for (dwIndex = 0; NULL != (szValue = regSrc.Value(dwIndex)); dwIndex += 1)
    {
        regSrc.GetValue(szValue, bfValue, &dwType);
        SetValue(szValue, bfValue.Access(), bfValue.Length(), dwType);
    }


    //
    // Now copy all the keys.
    //

    for (dwIndex = 0; NULL != (szKey = regSrc.Subkey(dwIndex)); dwIndex += 1)
    {
        regSrcSubkey.Open(regSrc, szKey, KEY_READ);
        regDstSubkey.Open(
                *this,
                szKey,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
        regDstSubkey.Status();
        regDstSubkey.Copy(regSrcSubkey);
        regDstSubkey.Close();
        regSrcSubkey.Close();
    }
}


/*++

DeleteKey:

    This method deletes a subkey from this key.

Arguments:

    szKey supplies the name of the key to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteKey(
    LPCTSTR szKey,
    BOOL fQuiet)
const
{
    if (ERROR_SUCCESS == m_lSts)
    {
        try
        {
            CRegistry regSubkey(m_hKey, szKey);
            LPCTSTR szSubKey;

            if (ERROR_SUCCESS == regSubkey.Status(TRUE))
            {
                while (NULL != (szSubKey = regSubkey.Subkey(0)))
                    regSubkey.DeleteKey(szSubKey, fQuiet);
            }
        }
        catch (DWORD dwError)
        {
            if (!fQuiet)
                throw dwError;
        }

        LONG lSts = RegDeleteKey(m_hKey, szKey);
        if ((ERROR_SUCCESS != lSts) && !fQuiet)
            throw (DWORD)lSts;
    }
    else if (!fQuiet)
        throw (DWORD)m_lSts;
}


/*++

DeleteValue:

    This method deletes a Value from this key.

Arguments:

    szValue supplies the name of the Value to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteValue(
    LPCTSTR szValue,
    BOOL fQuiet)
const
{
    LONG lSts;

    if (fQuiet)
    {
        if (ERROR_SUCCESS == m_lSts)
            lSts = RegDeleteValue(m_hKey, szValue);
    }
    else
    {
        if (ERROR_SUCCESS != m_lSts)
            throw (DWORD)m_lSts;
        lSts = RegDeleteValue(m_hKey, szValue);
        if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    }
}


/*++

Subkey:

    This method allows for iterating over the names of the subkeys of this key.

Arguments:

    dwIndex supplies the index into the set of subkeys.

Return Value:

    The name of the indexed subkey, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Subkey(
    DWORD dwIndex)
{
    LONG lSts;
    DWORD dwLen;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;
    FILETIME ftLastWrite;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Presize(128);
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumKeyEx(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    NULL,
                    NULL,
                    &ftLastWrite);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Resize((dwLen + 1) * sizeof(TCHAR), TRUE);
            szResult = (LPCTSTR)m_bfResult.Access();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            m_bfResult.Presize((dwLen + 1) * sizeof(TCHAR));
            continue;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

Value:

    This method allows for iterating over the names of the Values of this key.

Arguments:

    dwIndex supplies the index into the set of Values.

    pdwType receives the type of the entry.  This parameter may be NULL.

Return Value:

    The name of the indexed Value, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Value(
    DWORD dwIndex,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Presize(128);    // Force it to not be zero length.
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumValue(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    &dwType,
                    NULL,
                    NULL);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Resize((dwLen + 1) * sizeof(TCHAR), TRUE);
            if (NULL != pdwType)
                *pdwType = dwType;
            szResult = (LPCTSTR)m_bfResult.Access();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            if (dwLen == m_bfResult.Space())
                throw (DWORD)ERROR_INSUFFICIENT_BUFFER; // Won't tell us how big.
            m_bfResult.Presize((dwLen + 1) * sizeof(TCHAR));
            break;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

GetValue:

    These methods provide access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to get.
    pszValue receives the value of the entry as a string.
    pdwValue receives the value of the entry as a DWORD.
    ppbValue receives the value of the entry as a Binary string.
    pcbLength receives the length of the entry when it's a binary string.
    pdwType receives the type of the registry entry.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    CBuffer &bfValue,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType = 0;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    while (!fDone)
    {
        dwLen = bfValue.Space();
        lSts = RegQueryValueEx(
                    m_hKey,
                    szKeyValue,
                    NULL,
                    &dwType,
                    bfValue.Access(),
                    &dwLen);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            bfValue.Resize(dwLen, TRUE);
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            bfValue.Presize(dwLen);
            break;
        default:
            throw (DWORD)lSts;
        }
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}


void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPTSTR *pszValue,
    LPDWORD pdwType)
{
    DWORD dwLen, dwType;
    TCHAR chTmp;
    CBuffer bfUnexpanded;
    LONG lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    switch (dwType)
    {
    case REG_EXPAND_SZ:
        bfUnexpanded.Presize(dwLen);
        GetValue(szKeyValue, bfUnexpanded, &dwType);
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Access(),
                    &chTmp,
                    0);
        if (0 == dwLen)
            throw GetLastError();
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Access(),
                    (LPTSTR)m_bfResult.Resize(dwLen),
                    dwLen);
        if (0 == dwLen)
            throw GetLastError();
        break;

    case REG_BINARY:
    case REG_MULTI_SZ:
    case REG_SZ:
        m_bfResult.Presize(dwLen);
        GetValue(szKeyValue, m_bfResult, &dwType);
        break;

    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    *pszValue = (LPTSTR)m_bfResult.Access();
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwValue,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    CBuffer szExpanded;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = sizeof(DWORD);
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;

    switch (dwType)
    {
    case REG_DWORD_BIG_ENDIAN:
        *pdwValue = NTOHL(*pdwValue);
        break;
    case REG_DWORD:
    // case REG_DWORD_LITTLE_ENDIAN:
        break;
    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPBYTE *ppbValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    DWORD dwType;

    GetValue(szKeyValue, m_bfResult, &dwType);
    *ppbValue = m_bfResult.Access();
    *pcbLength = m_bfResult.Length();
    if (NULL != pdwType)
        *pdwType = dwType;
}


/*++

SetValue:

    These methods provide write access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    szValue supplies the new value of the entry as a string.
    dwValue supplies the new value of the entry as a DWORD.
    pbValue supplies the new value of the entry as a Binary string.
    cbLength supplies the length of the entry when it's a binary string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCTSTR szValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)szValue,
                (lstrlen(szValue) + 1) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    DWORD dwValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    if (REG_DWORD_BIG_ENDIAN == dwType)
        dwValue = HTONL(dwValue);
    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCBYTE pbValue,
    DWORD cbLength,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                pbValue,
                cbLength);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetStringValue:

    This is an alternate mechanism for obtaining a string value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a string pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCTSTR
CRegistry::GetStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}


/*++

GetNumericValue:

    This is an alternate mechanism for obtaining a numeric value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a DWORD.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetNumericValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
const
{
    DWORD dwResult;
    GetValue(szKeyValue, &dwResult, pdwType);
    return dwResult;
}


/*++

GetBinaryValue:

    This is an alternate mechanism for obtaining a binary value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a binary pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCBYTE
CRegistry::GetBinaryValue(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    LPBYTE pbResult;
    DWORD cbLength;
    GetValue(szKeyValue, &pbResult, &cbLength, pdwType);
    if (NULL != pcbLength)
        *pcbLength = cbLength;
    return pbResult;

}


/*++

GetValueLength:

    This routine is designed to work in conjunction with GetBinaryValue, but may
    have other uses as well.  It returns the length of the internal storage
    area, in bytes.  Note DWORDs are not stored internally, so this value will
    not represent the size of a DWORD following a GetNumericValue call.

Arguments:

    none

Return Value:

    The length of the internal storage buffer, in bytes.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetValueLength(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_bfResult.Length();
}


/*++

ValueExists:

    This routine tests for the existance of a given value, and optionally
    returns its type and length.

Arguments:

    none

Return Value:

    A boolean indication as to whether or not the value exists.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

BOOL
CRegistry::ValueExists(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    BOOL fResult = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS == lSts)
    {
        if (NULL != pcbLength)
            *pcbLength = dwLen;
        if (NULL != pdwType)
            *pdwType = dwType;
        fResult = TRUE;
    }
    return fResult;
}


/*++

GetDisposition:

    This routine returns the disposition of creation.

Arguments:

    none

Return Value:

    The return disposition flag from creating the registry entry.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetDisposition(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_dwDisposition;
}


/*++

SetMultiStringValue:

    This method simplifies the work of adding a MultiString value to the
    registry.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    mszValue supplies the new value of the entry as a multi-string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

void
CRegistry::SetMultiStringValue(
    LPCTSTR szKeyValue,
    LPCTSTR mszValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)mszValue,
                MStrLen(mszValue) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetMultiStringValue:

    This method obtains a multi-string value from the registry.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The registry value, as a multi-string.

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

LPCTSTR
CRegistry::GetMultiStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}


/*++

SetAcls:

    This method sets security attributes for a single key, or an entire key
    branch.

Arguments:

    SecurityInformation supplies the SECURITY_INFORMATION value (see
        RegSetKeySecurity in the SDK documentation).
    pSecurityDescriptor supplies the SECURITY_DESCRIPTOR value (see
        RegSetKeySecurity in the SDK documentation).
    fRecurse supplies an indicator as to whether to just set the ACL on this
        key (FALSE), or this key and all subkeys (TRUE).

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/10/1998

--*/

void
CRegistry::SetAcls(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL fRecurse)
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetKeySecurity(
                m_hKey,
                SecurityInformation,
                pSecurityDescriptor);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    if (fRecurse)
    {
        CRegistry regSub;
        LPCTSTR szSubKey;
        DWORD dwIndex;

        for (dwIndex = 0;
             NULL != (szSubKey = Subkey(dwIndex));
             dwIndex += 1)
        {
            regSub.Open(m_hKey, szSubKey);
            regSub.SetAcls(
                SecurityInformation,
                pSecurityDescriptor);
            regSub.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\common\text.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This module provides the runtime code to support the CTextString class.

Author:

    Doug Barlow (dbarlow) 11/7/1995

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <SCardLib.h>


/*++

CTextString::operator=:

    These methods set the CTextString object to the given value, properly
    adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CTextString object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CTextString object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CTextString &
CTextString::operator=(
    const CTextString &tz)
{

    //
    // See what the other CTextString object has that's good, and copy it over
    // here.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing's Good!?!  ?Error?
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.
        m_bfAnsi = tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fBothGood:
        // Everything is good.
        m_bfAnsi = tz.m_bfAnsi;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        // Internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CTextString::operator=(
    LPCSTR sz)
{
    DWORD length;

    //
    // Reset the ANSI buffer.
    //

    if (NULL != sz)
    {
        length = Length(sz) + 1;
        m_bfAnsi.Set((LPBYTE)sz, length * sizeof(CHAR));
    }
    else
        m_bfAnsi.Reset();
    m_fFlags = fAnsiGood;
    return sz;
}

LPCWSTR
CTextString::operator=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Reset the Unicode Buffer.
    //

    if (NULL != wsz)
    {
        length = Length(wsz) + 1;
        m_bfUnicode.Set((LPBYTE)wsz, length * sizeof(WCHAR));
    }
    else
        m_bfUnicode.Reset();
    m_fFlags = fUnicodeGood;
    return wsz;
}


/*++

CTextString::operator+=:

    These methods append the given data to the existing CTextString object
    value, properly adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CTextString object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CTextString object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CTextString &
CTextString::operator+=(
    const CTextString &tz)
{

    //
    // Append the other's good value to our value.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        *this += (LPCSTR)tz.m_bfAnsi.Access();
        break;

    case fUnicodeGood:
        *this += (LPCWSTR)tz.m_bfUnicode.Access();
        break;

    case fBothGood:
#ifdef UNICODE
        *this += (LPCWSTR)tz.m_bfUnicode.Access();
#else
        *this += (LPCSTR)tz.m_bfAnsi.Access();
#endif
        break;

    default:
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CTextString::operator+=(
    LPCSTR sz)
{
    DWORD length;


    //
    // Extend ourself as an ANSI string.
    //

    if (NULL != sz)
    {
        length = Length(sz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(CHAR);
            Ansi();
            if (0 < m_bfAnsi.Length())
                m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE);
            m_bfAnsi.Append((LPBYTE)sz, length);
            m_fFlags = fAnsiGood;
        }
    }
    return (LPCSTR)m_bfAnsi.Access();
}

LPCWSTR
CTextString::operator+=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Extend ourself as a Unicode string.
    //

    if (NULL != wsz)
    {
        length = Length(wsz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(WCHAR);
            Unicode();
            if (0 < m_bfUnicode.Length())
                m_bfUnicode.Resize(m_bfUnicode.Length() - sizeof(WCHAR), TRUE);
            m_bfUnicode.Append((LPBYTE)wsz, length);
            m_fFlags = fUnicodeGood;
        }
    }
    return (LPCWSTR)m_bfUnicode.Access();
}


/*++

Unicode:

    This method returns the CTextString object as a Unicode string.

Arguments:

    None

Return Value:

    The value of the object expressed in Unicode.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCWSTR
CTextString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // No valid values.  Report an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        if (0 < m_bfAnsi.Length())
        {
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    NULL,
                    0);
            if (0 == length)
                throw GetLastError();
            m_bfUnicode.Resize((length + 1) * sizeof(WCHAR));
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    (LPWSTR)m_bfUnicode.Access(),
                    length);
            if (0 == length)
                throw GetLastError();
            *(LPWSTR)m_bfUnicode.Access(length * sizeof(WCHAR)) = 0;
        }
        else
            m_bfUnicode.Reset();
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    default:
        // Internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If we don't have any value, return a null string.
    //

    if (0 == m_bfUnicode.Length())
        return L"\000";     // Double NULLs to support Multistrings
    else
        return (LPCWSTR)m_bfUnicode.Access();
}


/*++

CTextString::Ansi:

    This method returns the value of the object expressed in an ANSI string.

Arguments:

    None

Return Value:

    The value of the object expressed as an ANSI string.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCSTR
CTextString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        if (0 < m_bfUnicode.Length())
        {
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)),
                    NULL,
                    0,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            m_bfAnsi.Resize((length + 1) * sizeof(CHAR));
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)),
                    (LPSTR)m_bfAnsi.Access(),
                    length,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            *(LPSTR)m_bfAnsi.Access(length * sizeof(CHAR)) = 0;
        }
        else
            m_bfAnsi.Reset();
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    default:
        // An internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If there's nothing in the ANSI buffer, return a null string.
    //

    if (0 == m_bfAnsi.Length())
        return "\000";  // Double NULLs to support Multistrings
    else
        return (LPCSTR)m_bfAnsi.Access();
}


/*++

Compare:

    These methods compare the value of this object to another value, and return
    a comparative value.

Arguments:

    tz supplies the value to be compared as a CTextString object.
    sz supplies the value to be compared as an ANSI string.
    wsz supplies the value to be compared as a Unicode string.

Return Value:

    < 0 - The supplied value is less than this object.
    = 0 - The supplied value is equal to this object.
    > 0 - The supplies value is greater than this object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

int
CTextString::Compare(
    const CTextString &tz)
{
    int nResult;


    //
    // See what we've got to compare.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing!?!  Complain.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fBothGood:
    case fAnsiGood:
        // Use the ANSI version for fastest comparison.
        Ansi();
        nResult = CompareStringA(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCSTR)m_bfAnsi.Access(),
                    (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                    (LPCSTR)tz.m_bfAnsi.Access(),
                    (tz.m_bfAnsi.Length() / sizeof(CHAR)) - 1);
        break;

    case fUnicodeGood:
        // The Unicode version is good.
        Unicode();
        nResult = CompareStringW(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPCWSTR)tz.m_bfUnicode.Access(),
                    (tz.m_bfUnicode.Length() / sizeof(WCHAR)) - 1);
        break;

    default:
        // Internal Error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return nResult;
}

int
CTextString::Compare(
    LPCSTR sz)
{
    int nResult;


    //
    // Make sure our ANSI version is good.
    //

    Ansi();


    //
    // Do an ANSI comparison.
    //

    nResult = CompareStringA(
                LOCALE_USER_DEFAULT,
                0,
                (LPCSTR)m_bfAnsi.Access(),
                (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                sz,
                Length(sz));
    return nResult;
}

int
CTextString::Compare(
    LPCWSTR wsz)
{
    int nResult;


    //
    // Make sure our Unicode version is good.
    //

    Unicode();


    //
    // Do the comparison using Unicode.
    //

    nResult = CompareStringW(
                LOCALE_USER_DEFAULT,
                0,
                (LPCWSTR)m_bfUnicode.Access(),
                (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                wsz,
                Length(wsz));
    return nResult;
}


/*++

Length:

    These routines return the length of strings, in Characters, not including
    any trailing null characters.

Arguments:

    sz supplies the value whos length is to be returned as an ANSI string.
    wsz supplies the value whos length is to be returned as a Unicode string.

Return Value:

    The length of the string, in characters, excluding the trailing null.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
CTextString::Length(
    void)
{
    DWORD dwLength = 0;

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            dwLength = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            dwLength = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
        break;

    case fBothGood:
#ifdef UNICODE
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            dwLength = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
#else
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            dwLength = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
#endif
        break;

    default:
        // An internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return dwLength;
}

DWORD
CTextString::Length(
    LPCWSTR wsz)
{
    return lstrlenW(wsz);
}

DWORD
CTextString::Length(
    LPCSTR sz)
{
    return lstrlenA(sz);
}


//
//==============================================================================
//
//  CTextMultistring
//

/*++

Length:

    These routines return the length of strings, in Characters, not including
    any trailing null characters.

Arguments:

    sz supplies the value whos length is to be returned as an ANSI string.
    wsz supplies the value whos length is to be returned as a Unicode string.

Return Value:

    The length of the string, in characters, excluding the trailing null.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
CTextMultistring::Length(
    LPCWSTR wsz)
{
    return MStrLen(wsz) - 1;
}

DWORD
CTextMultistring::Length(
    LPCSTR sz)
{
    return MStrLen(sz) - 1;
}


/*++

Length:

    This routine returns the length of the stored MultiString in characters,
    including the trailing NULL characters.

Arguments:

    None

Return Value:

    The length, in characters, including trailing nulls.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

DWORD
CTextMultistring::Length(
    void)
{
    return CTextString::Length() + 1;
}


/*++

operator=:

    These methods assign values to the MultiString object.

Arguments:

    tz supplies the new value as a CTextMultistring
    sz supplies the new value as an ANSI string
    wsz supplies the new value as a UNICODE string

Return Value:

    The assigned string value, in its original form.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

CTextMultistring &
CTextMultistring::operator=(
    const CTextMultistring &tz)
{
    CTextString::operator=((const CTextString &)tz);
    return *this;
}

LPCSTR
CTextMultistring::operator=(
    LPCSTR sz)
{
    return CTextString::operator=(sz);
}

LPCWSTR
CTextMultistring::operator=(
    LPCWSTR wsz)
{
    return CTextString::operator=(wsz);
}


/*++

operator+=:

    These methods append values to the MultiString object.

Arguments:

    tz supplies the value to be appended as a CTextMultistring
    sz supplies the value to be appended as an ANSI string
    wsz supplies the value to be appended as a UNICODE string

Return Value:

    The concatenated string, in the form of the appended string.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

CTextMultistring &
CTextMultistring::operator+=(
    const CTextMultistring &tz)
{
    CTextString::operator+=((const CTextString &)tz);
    return *this;
}

LPCSTR
CTextMultistring::operator+=(
    LPCSTR sz)
{
    return CTextString::operator+=(sz);
}

LPCWSTR
CTextMultistring::operator+=(
    LPCWSTR wsz)
{
    return CTextString::operator+=(wsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\certprop\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCStatus.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\certprop\certprop.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    PropCert

Abstract:

    This file contains the definitition of the thread
	which propogates digital certificates from smart cards
	to the smart card physical store and My store
    
Author:

    Chris Dudley 5/16/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	Amanda Matlosz 12/05/97	removed the CNewDlg (replaced w/ CWizPropSheet)
	Amanda Matlosz 01/23/97 removed the wizard entirely

Notes:

--*/

#if !defined(__PROPCERT_INCLUDED__)
#define __PROPCERT_INCLUDED__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wincrypt.h>

typedef struct _THREADDATA
{
	SCARDCONTEXT    hSCardContext;	
	HANDLE          hClose;
    HANDLE          hUserToken;
    HANDLE          hThread;
	BOOL			fSuspended;

} THREADDATA;

typedef struct _PROPDATA
{
 	TCHAR szCSPName[MAX_PATH];
    TCHAR szReader[MAX_PATH];
    TCHAR szCardName[MAX_PATH];
    HANDLE hUserToken;

} PROPDATA, *PPROPDATA;

DWORD
WINAPI
PropagateCertificates(
    LPVOID lpParameter
    );

void
StopMonitorReaders(
    THREADDATA *ThreadData
    );

DWORD
WINAPI
StartMonitorReaders( 
    LPVOID lpParameter
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\certprop\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

// Include multi-thread classes
#include <afxmt.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <atlconv.h>		// ATL Conversion macros

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\certprop\certprop.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    PropCert

Abstract:

    This module initiates smart card cert propagation to 'My' store.
    It is loaded and started by winlogon through an entry in the registry.

Author:

    Klaus Schutz

--*/

#include "stdafx.h"
#include <wincrypt.h>
#include <winscard.h>
#include <winwlx.h>

#include "calaislb.h"
#include "scrdcert.h"   // smart card cert store
#include "certprop.h"
#include "StatMon.h"    // smart card reader status monitor
#include "scevents.h"

#include <mmsystem.h>

#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#endif

#define REG_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\ScCertProp"

static THREADDATA l_ThreadData;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if defined(DBG) || defined(DEBUG)
BOOL Debug = TRUE;
#define DebugPrint(a) _DebugPrint a
void
__cdecl
_DebugPrint(
    LPCTSTR szFormat,
    ...
    )
{
    if (Debug) {
     	
        TCHAR szBuffer[512];
        va_list ap;

        va_start(ap, szFormat);
        _vstprintf(szBuffer, szFormat, ap);
        OutputDebugString(szBuffer);
    }
}

#else
#define DebugPrint(a)
#endif

LPCTSTR
FirstString(
    IN LPCTSTR szMultiString
    )
/*++

FirstString:

    This routine returns a pointer to the first string in a multistring, or NULL
    if there aren't any.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the first null-terminated string in the structure, or NULL if
    there are no strings.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/
{
    LPCTSTR szFirst = NULL;

    try
    {
        if (0 != *szMultiString)
            szFirst = szMultiString;
    }
    catch (...) {}

    return szFirst;
}

LPCTSTR
NextString(
    IN LPCTSTR szMultiString)
/*++

NextString:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the current string in a
    multi-string structure, it returns the next string, or NULL if no other
    strings follow the current string.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the next Null-terminated string in the structure, or NULL if
    no more strings follow.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/
{
    LPCTSTR szNext;

    try
    {
        DWORD cchLen = lstrlen(szMultiString);
        if (0 == cchLen)
            szNext = NULL;
        else
        {
            szNext = szMultiString + cchLen + 1;
            if (0 == *szNext)
                szNext = NULL;
        }
    }

    catch (...)
    {
        szNext = NULL;
    }

    return szNext;
}

/*++

MoveToUnicodeString:

    This routine moves the internal string representation to a UNICODE output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToUnicodeString(
    LPWSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifndef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            NULL,
            0);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            szDst,
            cchLength);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    cchLength += 1;
    if (NULL != szDst)
        CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
#endif
    return cchLength;
}

void
StopMonitorReaders(
    THREADDATA *ThreadData
    )
{
    DWORD dwRet;

    _ASSERT(ThreadData != NULL);

    SetEvent(ThreadData->hClose);

    if (ThreadData->hSCardContext) {
     	
        SCardCancel(ThreadData->hSCardContext);  	
    }
}

DWORD
WINAPI
StartMonitorReaders( 
    LPVOID lpParameter
    )
{
    LPCTSTR szCardHandled = "KS";
    LPCTSTR  newPnPReader = SCPNP_NOTIFICATION;
    THREADDATA  *ThreadData = (THREADDATA *) lpParameter;
    HANDLE hCalaisStarted = NULL;
    HANDLE lHandles[2];

    //
    // We use this outer loop to restart in case the 
    // resource manager was stopped
    //
    while (WaitForSingleObject(ThreadData->hClose, 0) == WAIT_TIMEOUT) {
     	
        // Acquire context with resource manager
        LONG lReturn = SCardEstablishContext(
            SCARD_SCOPE_SYSTEM,
            NULL,
            NULL,
            &ThreadData->hSCardContext
            );

        if (SCARD_S_SUCCESS != lReturn) {

            if (SCARD_E_NO_SERVICE == lReturn) {

                // SCRM not started yet. Give it a chance
                hCalaisStarted = CalaisAccessStartedEvent();

                if (hCalaisStarted == NULL) {

                    // no way to recover
                    break;             	
                }

                lHandles[0] = hCalaisStarted;
                lHandles[1] = ThreadData->hClose;

                lReturn = WaitForMultipleObjectsEx(
                    2,
                    lHandles,
                    FALSE,
                    120 * 1000,     // only couple minutes
                    FALSE
                    );         
            
                if (lReturn != WAIT_OBJECT_0) {

                    // We stop if an error occured or if the user logs out
                    break;             	
                }

                // Otherwise the resource manager has started
                DebugPrint(("ScCertProp: Smart card resource manager started\n"));
                continue;
            }

            // The prev. call should never fail
            // It's better to termninate this thread.
            break;
        }

        LPCTSTR szReaderName = NULL;
        DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
        // now list the available readers
        lReturn = SCardListReaders( 
            ThreadData->hSCardContext,
            SCARD_DEFAULT_READERS,
            (LPTSTR)&szReaderName,
            &dwAutoAllocate
            );

        SCARD_READERSTATE   rgReaders[MAXIMUM_SMARTCARD_READERS + 1];
        // First, make sure the array is totally zeroed.
        ZeroMemory((LPVOID) rgReaders, sizeof(rgReaders));

        // add the 'new pnp reader has arrived' reader
        rgReaders[0].szReader = newPnPReader;
        rgReaders[0].dwCurrentState = 0;
        DWORD dwNumReaders = 1;

        // And build a bare-bones readerstatearray IFF there are any readers
        if (SCARD_S_SUCCESS == lReturn)
        {
            szReaderName = FirstString( szReaderName );

            while (NULL != szReaderName && 
                   dwNumReaders < MAXIMUM_SMARTCARD_READERS + 1) {

                DebugPrint(
                    ("ScCertProp: Found reader: '%s'\n", 
                    szReaderName)
                    );

                rgReaders[dwNumReaders].szReader = (LPCTSTR) szReaderName;
                rgReaders[dwNumReaders].dwCurrentState = SCARD_STATE_EMPTY;

                szReaderName = NextString(szReaderName);
                dwNumReaders++;
            }
        }

        if (SCARD_S_SUCCESS != lReturn) {

            DebugPrint(("ScCertProp: No readers found. Waiting for new reader arrival...\n"));
            //
            // We now will call SCardGetStatusChange which 
            // will return upon new reader arrival
            //
        }

        BOOL fNewReader = FALSE;

        // analyze newly inserted cards and prop certs as necessary
        while (WaitForSingleObject(ThreadData->hClose, 0) == WAIT_TIMEOUT &&
               fNewReader == FALSE) {

            //
            // Wait for a change in the system status before continuing; quit if an error occurred
            //
            lReturn = SCardGetStatusChange( 
                ThreadData->hSCardContext,
                INFINITE,
                rgReaders,
                dwNumReaders
                );

#ifdef DEBUG_VERBOSE
            DebugPrint(
                ("ScCertProp: SCardGetStatusChange returned %lx\n",
                lReturn)
                );
#endif

            if (SCARD_E_SYSTEM_CANCELLED == lReturn) {

                DebugPrint(("ScCertProp: Smart card resource manager stopped\n"));

                // Clean up
                if (NULL != szReaderName)
                {
                    SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szReaderName);
                    szReaderName = NULL;
                }
                if (NULL != ThreadData->hSCardContext)                 
                {
                    SCardReleaseContext(ThreadData->hSCardContext);
                    ThreadData->hSCardContext = NULL;
                }

                //
                // The resource manager has been stopped.
                // Wait until it restarted or until the user logs out
                //
                hCalaisStarted = CalaisAccessStartedEvent();

                if (hCalaisStarted == NULL) {

                    // no way to recover. stop cert prop
                    StopMonitorReaders(ThreadData);
                    break;             	
                }

                lHandles[0] = hCalaisStarted;
                lHandles[1] = ThreadData->hClose;

                lReturn = WaitForMultipleObjectsEx(
                    2,
                    lHandles,
                    FALSE,
                    INFINITE,
                    FALSE
                    );         
            
                if (lReturn != WAIT_OBJECT_0) {

                    // We stop if an error occured or if the user logs out
                    StopMonitorReaders(ThreadData);
                    break;             	
                }

                // Otherwise the resource manager has been restarted
                DebugPrint(("ScCertProp: Smart card resource manager re-started\n"));
                break;
            }

            if (SCARD_S_SUCCESS != lReturn)
            {
                if (SCARD_E_CANCELLED != lReturn)
                    StopMonitorReaders(ThreadData);
			    break;
            }

#ifdef DEBUG_VERBOSE
            DebugPrint(
                ("ScCertProp: Reader(PnP) state %lx/%lx\n",
                rgReaders[0].dwCurrentState, 
                rgReaders[0].dwEventState)
                );
#endif
            // check if a new reader showed up
            if ((dwNumReaders == 1 || rgReaders[0].dwCurrentState != 0) && 
                rgReaders[0].dwEventState & SCARD_STATE_CHANGED) {
                
                DebugPrint(("ScCertProp: New reader reported...\n"));
                fNewReader = TRUE;
                break;
            }

            rgReaders[0].dwCurrentState = rgReaders[0].dwEventState;

            //
            // Enumerate the readers and for every recognized card that's been
            // inserted and has an associated CSP, get a cert (if there is one)
            // off the default container and prop it to the 'My' store
            //            
            for (DWORD dwIndex = 1; dwIndex < dwNumReaders; dwIndex++)
            {
#ifdef DEBUG_VERBOSE
                DebugPrint(
                    ("ScCertProp: Reader(%s) state %lx/%lx\n",
                    rgReaders[dwIndex].szReader,
                    rgReaders[dwIndex].dwCurrentState, 
                    rgReaders[dwIndex].dwEventState)
                    );
#endif

                if ((rgReaders[dwIndex].dwCurrentState & SCARD_STATE_EMPTY) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_PRESENT)) {
                     	
                    // play sound for card insertion
                    PlaySound(
                        TEXT("SmartcardInsertion"),
                        NULL,
                        SND_ASYNC | SND_ALIAS | SND_NODEFAULT
                        );
                }

                if ((rgReaders[dwIndex].dwCurrentState & SCARD_STATE_PRESENT) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_EMPTY)) {
                     	
                    // play sound for card removal
                    PlaySound(
                        TEXT("SmartcardRemoval"),
                        NULL,
                        SND_ASYNC | SND_ALIAS | SND_NODEFAULT
                        );
                }

                if ((rgReaders[dwIndex].dwCurrentState & SCARD_STATE_EMPTY) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_PRESENT) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_CHANGED) &&
                    (rgReaders[dwIndex].pvUserData != (PVOID) szCardHandled))
                {

                    // Get the name of the card
                    LPCSTR szCardName = NULL;
                    dwAutoAllocate = SCARD_AUTOALLOCATE;
                    lReturn = SCardListCards(   
                        ThreadData->hSCardContext,
                        rgReaders[dwIndex].rgbAtr,
                        NULL,
                        0,
                        (LPTSTR)&szCardName,
                        &dwAutoAllocate
                        );

                    LPCSTR szCSPName = NULL;
                    if (SCARD_S_SUCCESS == lReturn)
                    {
                        dwAutoAllocate = SCARD_AUTOALLOCATE;
                        lReturn = SCardGetCardTypeProviderName(
                            ThreadData->hSCardContext,
                            szCardName,
                            SCARD_PROVIDER_CSP,
                            (LPTSTR)&szCSPName,
                            &dwAutoAllocate
                            );
                    }

                    DebugPrint(
                        ("ScCertProp: Smart Card '%s' inserted into reader '%s'\n", 
                        (strlen(szCardName) ? szCardName : "<Unknown>"),
                        rgReaders[dwIndex].szReader)
                        );

                    if (SCARD_S_SUCCESS == lReturn)
                    {
                        PPROPDATA PropData = (PPROPDATA) LocalAlloc(LPTR, sizeof(PROPDATA));
                        if (PropData) {
                         	
                            _tcscpy(PropData->szReader, rgReaders[dwIndex].szReader);
                            _tcscpy(PropData->szCardName, szCardName);
                            _tcscpy(PropData->szCSPName, szCSPName);
                            PropData->hUserToken = ThreadData->hUserToken;

                            //
                            // Create a thread to propagate this cert.
                            // The thread is responsible to free PropData
                            //
                            HANDLE hThread = CreateThread(
                                NULL,
                                0,
                                PropagateCertificates,
                                (LPVOID) PropData,         
	                            0,
                                NULL
                                );

                            if (hThread == NULL) {

                                LocalFree(PropData);                             	
                            }
                            else {

                                CloseHandle(hThread);
                            }

                        }
                    }

                    //
                    // Clean up
                    //
                    if (NULL != szCSPName)
                    {
                        SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szCSPName);
                        szCSPName = NULL;
                    }
                    if (NULL != szCardName)
                    {
                        SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szCardName);
                        szCardName = NULL;
                    }

                    // Record that we're done with this card
                    rgReaders[dwIndex].pvUserData = (PVOID) szCardHandled;

                }
                else
                {
                    // there's no card to handle in this reader; reset pvUserData
                    rgReaders[dwIndex].pvUserData = NULL;
                }

                // Update the "current state" of this reader
                rgReaders[dwIndex].dwCurrentState = rgReaders[dwIndex].dwEventState;
            }
        }

        // Clean up
        if (NULL != szReaderName)
        {
            SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szReaderName);
            szReaderName = NULL;
        }
        if (NULL != ThreadData->hSCardContext)                 
        {
            SCardReleaseContext(ThreadData->hSCardContext);
            ThreadData->hSCardContext = NULL;
        }
    }

    return TRUE;
}

DWORD
WINAPI
PropagateCertificates(
    LPVOID lpParameter
    )
/*++

Routine Description:
	This function propagates the cert of a card.
    It runs as a seperate thread

--*/
{
    PPROPDATA PropData = (PPROPDATA) lpParameter;
    BOOL    fSts = FALSE;
    long    lErr = 0;
    DWORD   dwIndex = 0;

    DWORD   cbContainerName = 0;
    LPSTR   szContainerName = NULL;
    LPWSTR  lpwszContainerName = NULL;
    LPWSTR  lpwszCSPName = NULL;
    LPWSTR  lpwszCardName = NULL;
    LPSTR lpszContainerName = NULL;
    DWORD   dwCertLen = 0;
    LPBYTE  pbCert = NULL;

    CRYPT_KEY_PROV_INFO keyProvInfo;
    HCERTSTORE hCertStore = NULL;
    HCRYPTKEY  hKey = NULL;
    HCRYPTPROV hCryptProv = NULL;

    LPCTSTR szCSPName = PropData->szCSPName;
    LPCTSTR szCardName = PropData->szCardName;

    static const DWORD rgdwKeys[] = { AT_KEYEXCHANGE , AT_SIGNATURE };
    static const DWORD cdwKeys = sizeof(rgdwKeys) / sizeof(DWORD);

#if defined(DBG) || defined(DEBUG)
    time_t start = time(NULL);
#endif

    lpszContainerName = (LPSTR) LocalAlloc(
        LPTR, 
        strlen(PropData->szReader) + 10
        );

    if (lpszContainerName == NULL) {
     	
        lErr = NTE_NO_MEMORY;
        goto ErrorExit;
    }

    sprintf(lpszContainerName, "\\\\.\\%s\\", PropData->szReader);

    fSts = CryptAcquireContext(
        &hCryptProv,
        lpszContainerName, 
        PropData->szCSPName,
        PROV_RSA_FULL,
        CRYPT_SILENT
        );

    DebugPrint(
        ("ScCertProp(%s): CryptAcquireContext took %ld seconds to return %lx\n", 
        PropData->szCardName,
        (time(NULL) - start),
        GetLastError())
        );

    LocalFree(lpszContainerName);

    if (fSts == FALSE) {

        lErr = GetLastError();
        goto ErrorExit;   	
    }

    // the following struct is always empty, for I_CryptAddSmartCardCertToStore
    CRYPT_DATA_BLOB scCryptData;
    memset(&scCryptData, 0, sizeof(CRYPT_DATA_BLOB));

    //
    // Get the default container name, so we can use it
    //
    fSts = CryptGetProvParam(
        hCryptProv,
        PP_CONTAINER,
        NULL,
        &cbContainerName,
        0
        );

    if (!fSts)
    {
        lErr = GetLastError();
        goto ErrorExit;
    }

    szContainerName = (LPSTR) LocalAlloc(LPTR, cbContainerName);
    if (NULL == szContainerName)
    {
        lErr = NTE_NO_MEMORY;
        goto ErrorExit;
    }

    fSts = CryptGetProvParam(
        hCryptProv,
        PP_CONTAINER,
        (PBYTE)szContainerName,
        &cbContainerName,
        0
        );

    if (!fSts)
    {
        lErr = GetLastError();
        goto ErrorExit;
    }

    //
    // Prepare the key prov info that's generic to all keysets
    //
    lpwszContainerName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (lstrlen(szContainerName) + 1));
    lpwszCSPName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (lstrlen(szCSPName) + 1));
    lpwszCardName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (lstrlen(szCardName) + 1));
    if ((NULL == lpwszCSPName) || (NULL == lpwszCardName) || (NULL == lpwszContainerName))
    {
        lErr = NTE_NO_MEMORY;
        goto ErrorExit;
    }

    MoveToUnicodeString(lpwszContainerName, szContainerName, lstrlen(szContainerName) + 1);
    MoveToUnicodeString(lpwszCSPName, szCSPName, lstrlen(szCSPName) + 1);
    MoveToUnicodeString(lpwszCardName, szCardName, lstrlen(szCardName) + 1);

    memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
    keyProvInfo.pwszContainerName   = lpwszContainerName;
    keyProvInfo.pwszProvName        = lpwszCSPName;
    keyProvInfo.dwProvType          = PROV_RSA_FULL;
    keyProvInfo.dwFlags             = 0;
    keyProvInfo.cProvParam          = 0;
    keyProvInfo.rgProvParam         = NULL;

    //
    // For each keyset in this container, get the cert and make
    // a cert context, then prop the cert to the My store
    //
    for (dwIndex = 0; dwIndex < cdwKeys; dwIndex += 1)
    {
        try
        {
            //
            // Note which key we're working with and get the key handle.
            //
            keyProvInfo.dwKeySpec = rgdwKeys[dwIndex];

            fSts = CryptGetUserKey(
                hCryptProv,
                rgdwKeys[dwIndex],
                &hKey
                );

            if (!fSts)
            {
                lErr = GetLastError();
                if (NTE_NO_KEY != lErr)
                {
                    throw lErr;
                }
            }

            //
            // Upload the certificate & prep CertData blob
            //
            if (fSts)
            {
                fSts = CryptGetKeyParam(
                    hKey,
                    KP_CERTIFICATE,
                    NULL,
                    &dwCertLen,
                    0
                    );

                if (!fSts)
                {
                    lErr = GetLastError();
                    if (ERROR_MORE_DATA == lErr)
                    {
                        // There's a certificate -- this means SUCCESS!
                        fSts = TRUE;
                    }
                    //
                    // otherwise, there may be a key but no cert
                    // this just means that there's nothing to do.
                    //
                }
            }

            if (!fSts) {
             	
                DebugPrint(
                    ("ScCertProp(%s): No %s certificate on card\n",
                    PropData->szCardName,
                    (dwIndex == 0 ? "key exchange" : "signature"))
                    );
            }

            if (fSts)
            {
                pbCert = (LPBYTE) LocalAlloc(LPTR, dwCertLen);
                if (NULL == pbCert)
                {
                    throw ERROR_OUTOFMEMORY;
                }

                fSts = CryptGetKeyParam(
                    hKey,
                    KP_CERTIFICATE,
                    pbCert,
                    &dwCertLen,
                    0
                    );

                if (!fSts)
                {
                    throw (long) GetLastError();
                }
            }

            if (fSts)
            {
                CRYPT_DATA_BLOB cdbCertData;
                cdbCertData.cbData = dwCertLen;
                cdbCertData.pbData = pbCert;

                if (PropData->hUserToken && !ImpersonateLoggedOnUser( PropData->hUserToken )) {

                    DebugPrint(("ScCertProp: ImpersonateLoggedOnUser failed\n"));
                    throw (long) GetLastError();
                }

                try
                {
                    //
                    // Open the MyStore -- and add the cert if it's not there
                    //
                    hCertStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,               // "My store"
                        0,                                      // not applicable
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG |
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        L"MY"
                        );

                    if (NULL == hCertStore)
                    {
                        throw((long)GetLastError());
                    }
                    // is the cert already there?
                    SMART_CARD_CERT_FIND_DATA sccfd;
                    memset(&sccfd, 0, sizeof(SMART_CARD_CERT_FIND_DATA));
                    sccfd.cbSize = sizeof(SMART_CARD_CERT_FIND_DATA);
                    sccfd.pwszProvider = keyProvInfo.pwszProvName;
                    sccfd.dwProviderType = keyProvInfo.dwProvType;
                    sccfd.pwszContainer = keyProvInfo.pwszContainerName;
                    sccfd.dwKeySpec = keyProvInfo.dwKeySpec;

                    PCCERT_CONTEXT pCCtx = NULL;
                    pCCtx = I_CryptFindSmartCardCertInStore (
                        hCertStore,
                        pCCtx, 
                        &sccfd,
                        NULL
                        );

                    BOOL fSame = FALSE;

                    if (pCCtx != NULL)
                    {
                        if ((pCCtx->cbCertEncoded == dwCertLen) &&
                            (memcmp(pCCtx->pbCertEncoded, pbCert, dwCertLen) == 0))
                        {
                            fSame = TRUE;
                        }

                        CertFreeCertificateContext(pCCtx);
                        pCCtx = NULL;

                        DebugPrint(
                            ("ScCertProp(%s): %s certificate already in store\n",
                            PropData->szCardName,
                            (dwIndex == 0 ? "Key exchange" : "Signature"))
                            );

                        fSts = TRUE;
                    }

                    if (!fSame)
                    {
                        // this by default does "replace existing"
                        fSts = I_CryptAddSmartCardCertToStore(
                            hCertStore,
                            &cdbCertData,
                            NULL,   
                            &scCryptData, 
                            &keyProvInfo
                            );

                        DebugPrint(
                            ("ScCertProp(%s): %s certificate %s propagated\n",
                            PropData->szCardName,
                            (dwIndex == 0 ? "Key exchange" : "Signature"),
                            (fSts ? "successfully" : "NOT"))
                            );

                    }

                    if (NULL != hCertStore)
                    {
                        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
                        hCertStore = NULL;
                    }
                    if (!fSts)
                    {
                        throw((long) GetLastError());
                    }
                    RevertToSelf();
                }
                catch(...)
                {
                    RevertToSelf();
                    throw;
                }
            }
        }
        catch (...)
        {
        }

        // clean up each time around...

        if (NULL != hKey)
        {
            CryptDestroyKey(hKey);
            hKey = NULL;
        }
        if (NULL != pbCert)
        {
            LocalFree(pbCert);
            pbCert = NULL;
            dwCertLen = 0;
        }
    }

ErrorExit:

    if (NULL != szContainerName)
    {
        LocalFree(szContainerName);
    }
    if (NULL != lpwszContainerName)
    {
        LocalFree(lpwszContainerName);
    }
    if (NULL != lpwszCSPName)
    {
        LocalFree(lpwszCSPName);
    }
    if (NULL != lpwszCardName)
    {
        LocalFree(lpwszCardName);
    }
    if (NULL != pbCert)
    {
        LocalFree(pbCert);                                    
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != hCryptProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }

    DebugPrint(
        ("ScCertProp(%s): Certificate propagation took %ld seconds\n", 
        PropData->szCardName,
        (time(NULL) - start))
        );

    LocalFree(PropData);

    return ERROR_SUCCESS;
}

DWORD WINAPI
SCardStartCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
    Starts cert. propagation after the user logged on.

--*/
{
    PWLX_NOTIFICATION_INFO User = (PWLX_NOTIFICATION_INFO) lpvParam;
    HKEY hKey;
    DWORD fEnabled = TRUE;

    //
    // First check if cert. prop. is enabled.
    //
    if (RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REG_KEY,
        &hKey) == ERROR_SUCCESS) {

        ULONG uBufferLen = sizeof(fEnabled);
        DWORD dwKeyType;

        RegQueryValueEx(
            hKey,
            "Enabled",
            NULL,
            &dwKeyType,
            (PUCHAR) &fEnabled,
            &uBufferLen);

        RegCloseKey(hKey);
    }

    if (FALSE == fEnabled) {

        DebugPrint(("ScCertProp: Smart card certificate propagation is disabled\n"));
        return ERROR_SUCCESS;     	
    }

    __try {

        if(User) {
         	
            l_ThreadData.hUserToken = User->hToken;
        }

        l_ThreadData.hClose = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (l_ThreadData.hClose == NULL) {

            __leave;         	
        }

        l_ThreadData.hThread = CreateThread(
            NULL,
            0,
            StartMonitorReaders,
            (LPVOID) &l_ThreadData,         
	        CREATE_SUSPENDED,
            NULL
            );

        if (l_ThreadData.hThread == NULL) {

            CloseHandle(l_ThreadData.hClose);
            __leave;         	
        }

		l_ThreadData.fSuspended = FALSE;	// was initially suspended, not anymore

        ResumeThread(l_ThreadData.hThread);

        DebugPrint(("ScCertProp: Smart card certificate propagation started\n"));
    }

    __finally {

    }

    return ERROR_SUCCESS;
}

DWORD WINAPI
SCardStopCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
    Stops cert. propagation when the user logs out.

Arguments:
    lpvParam - Winlogon notification info.

--*/
{
    UNREFERENCED_PARAMETER(lpvParam);

	if(NULL != l_ThreadData.hThread)
	{
        DWORD dwStatus;

			// If the user that unlocks the workstation is different from the one
			// that locked it, Logoff occurs without an Unlock, thus the thread is
			// still suspended. This should take care of it.
		if (l_ThreadData.fSuspended)
		{
			ResumeThread(l_ThreadData.hThread);
	        l_ThreadData.fSuspended = FALSE;
		}
        
        StopMonitorReaders(&l_ThreadData);
        dwStatus = WaitForSingleObject(
            l_ThreadData.hThread, 
            INFINITE
            );
        _ASSERT(dwStatus == WAIT_OBJECT_0);
        CloseHandle(l_ThreadData.hClose);
        l_ThreadData.hClose = NULL;
        CloseHandle(l_ThreadData.hThread);
        l_ThreadData.hThread = NULL;
        DebugPrint(("ScCertProp: Smart card certificate propagation stopped\n"));
	}

    return ERROR_SUCCESS;
}

DWORD WINAPI
SCardSuspendCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
    Suspens cert. propagation when the workstation will be locked
    	
Arguments:
    lpvParam - Winlogon notification info.

--*/
{
    UNREFERENCED_PARAMETER(lpvParam);

		// The suspended flag should take care of the following scenario:
		// Winlogon generates lock notification each time the locked dialog appears
		// (vs. only once when the wks is locked) and the thread would get suspended
		// amny times. This happens when the screen saver is kicking on & off while
		// the wks is locked (Bug 105852)
    if ((NULL != l_ThreadData.hThread) && (!l_ThreadData.fSuspended)){

        SuspendThread(l_ThreadData.hThread);
        l_ThreadData.fSuspended = TRUE;
        DebugPrint(("ScCertProp: Smart card certificate propagation suspended\n"));
    }
    return ERROR_SUCCESS;     	
}

DWORD WINAPI
SCardResumeCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
	Resumes cert. propagation after unlocking the workstation

Arguments:
    lpvParam - Winlogon notification info.

--*/
{     	
    UNREFERENCED_PARAMETER(lpvParam);

    if (NULL != l_ThreadData.hThread) {

        ResumeThread(l_ThreadData.hThread);
        l_ThreadData.fSuspended = FALSE;
        DebugPrint(("ScCertProp: Smart card certificate propagation resumed\n"));
    }
    return ERROR_SUCCESS;     	
}

DWORD WINAPI
SCardEnableCertProp(
    BOOL On
    )
/*++

Routine Description:
    Allows cert. propagation to be turned off/on 
	
Arguments:
    On - TRUE turn on, else off

--*/
{
    HKEY l_hKey;
    LONG l_lResult;
	
    if ((l_lResult = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REG_KEY,
        &l_hKey)) == ERROR_SUCCESS) {

        l_lResult = RegSetValueEx(  
            l_hKey,     
            "Enabled",
            0,
            REG_DWORD,
            (PUCHAR) &On,
            sizeof(DWORD)
            );

        RegCloseKey(l_hKey);
    }

    return l_lResult;
}

#ifdef test
__cdecl
main(
    int argc,
    char ** argv
    )
{
    EnableScCertProp(TRUE);
    StartScCertProp(NULL);
    getchar();
    StopScCertProp(&l_ThreadData);

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\common\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

buffers.cpp: ..\..\common\buffers.cpp
	copy $** $@

misc.cpp: ..\..\common\misc.cpp
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\statmon.h ===
// statmon.h

/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    StatMon

Abstract:

    This file contains the implementation of CScStatusMonitor
	(an object that watches for status changes of readers recognized 
	by the smart card service, handling PNP and requests for copies of
	the status array)

Author:

    Amanda Matlosz	02/26/98

Environment:

    Win32, C++ with exceptions

Revision History:

Notes:

  In order to use this class, first declare an object, then initialize it w/ 
  your HWND and a UINT indicating the message you want to receive when a 
  change in the system reader status has occurred.  Handle that message 
  simply by calling GetReaderStatus().  When the object is destroyed, any 
  outstanding threads will be stopped.

	CScStatusMonitor m_monitor; 
	m_monitor.Start(hWnd, STATUS_MONITOR_CHANGE, NULL) // use default reader group
	on STATUS_MONITOR_CHANGE() 
	{
	m_monitor.GetStatus(); ???????
	m_monitor.GetReaderStatus(ReaderStatusArray); // check return val for system errors
	}
	m_monitor.Stop(); // also in ~CScStatusMonitor(); closes threads

  The monitor object maintains a separate thread to signal and record changes in
  reader status, as well as an enhanced record of that status that is available
  to the object's caller via GetReaderStatus().  The enhnced record includes the
  first card name associated with the inserted card's ATR.

  In the event that the resource manager service is stopped, the monitor will
  move to a stopped state and send the status_change message to the caller's hWnd.
  The caller is responsible for starting the monitor again (if it so wishes)
  when the service is back up.

--*/

#ifndef _STATUS_MONITOR
#define _STATUS_MONITOR

#include <afxwin.h>
#include "afxtempl.h"
#include <afxmt.h>
#include "winscard.h"
#include "calaislb.h"

// Status of reader
#define SC_STATUS_FIRST			SC_STATUS_NO_CARD

#define SC_STATUS_NO_CARD       0	// SCARD_STATE_EMPTY
#define SC_STATUS_UNKNOWN		1	// SCARD_STATE_PRESENT | SCARD_STATE_MUTE
#define SC_SATATUS_AVAILABLE	2	// SCARD_STATE_PRESENT (| SCARD_STATE_UNPOWERED)
#define SC_STATUS_SHARED		3	// SCARD_SATATE_PRESENT | SCARD_STATE_INUSE
#define SC_STATUS_EXCLUSIVE		4	// "" | SCARD_STATE_EXCLUSIVE
#define SC_STATUS_ERROR			5	// SCARD_STATE_UNAVAILABLE (reader or card error)

#define SC_STATUS_LAST			SC_STATUS_ERROR

class CSCardReaderState
{
public:

	CSCardReaderState(const CSCardReaderState* pCRS=NULL)
	{
		if(NULL != pCRS)
		{
			strReader = (LPCTSTR)pCRS->strReader;
			dwCurrentState = pCRS->dwCurrentState;
			dwEventState = pCRS->dwEventState;
			cbAtr = pCRS->cbAtr;
			memcpy(rgbAtr, pCRS->rgbAtr, pCRS->cbAtr);
			strCard = (LPCTSTR)pCRS->strCard;
			dwState = pCRS->dwState;
			fOK = pCRS->fOK;
		}
		else
		{
			strReader = _T("");
			dwCurrentState = 0;
			dwEventState = 0;
			ZeroMemory(rgbAtr, sizeof(rgbAtr));
			cbAtr = 0;
			strCard = _T("");
			dwState = 0;
			fOK = FALSE;
		}
	}

	// used to talk w/ Resource Manager

    CString     strReader;		// reader name
    DWORD       dwCurrentState; // current state of reader at time of call
    DWORD       dwEventState;   // state of reader after state change
    DWORD       cbAtr;          // Number of bytes in the returned ATR.
    BYTE        rgbAtr[36];     // Atr of inserted card, (extra alignment bytes)

	// used by caller for easier user-friendly UI

	CString		strCard;		// first card name RM returns for ATR
	DWORD		dwState;		// simplified reader state; see #defines above

	// BOOL for Smart Card Common Dialog's use (not used by status monitor)
	BOOL		fOK;
};

typedef CTypedPtrArray<CPtrArray, CSCardReaderState*> CSCardReaderStateArray;


class CScStatusMonitor
{
public:

	// status
	enum status{	uninitialized=0, 
					stopped, 
					running,
					no_service,
					no_readers,
					unknown};

	// constructors
	CScStatusMonitor() 
	{ 
		m_status = CScStatusMonitor::uninitialized; 
		m_uiStatusChangeMsg=0; 
		m_pStatusThrd=NULL;
		m_szReaderNames = NULL;
		m_pInternalReaderStatus = NULL;
		m_dwInternalNumReaders = 0;
	}

	~CScStatusMonitor();

	// operations & attributes
	LONG Start(HWND hWnd, UINT uiMsg, LPCTSTR szGroupNames=NULL);
	void Stop();

	void GetReaderStatus(CSCardReaderStateArray& aReaderStatus);
	void SetReaderStatus(); // uses same lock as above... 

	status GetStatus() { return m_status; }

	UINT GetStatusChangeProc();

private:

	LONG InitInternalReaderStatus();
	LONG UpdateInternalReaderStatus();
	void EmptyExternalReaderStatus();

	// members

	status m_status;

	HWND m_hwnd;
	UINT m_uiStatusChangeMsg;
	CWinThread* m_pStatusThrd;
	HANDLE m_hEventKillStatus;
	SCARDCONTEXT m_hContext;
	SCARDCONTEXT m_hInternalContext;

	CTextMultistring m_strGroupNames;

	CCriticalSection m_csRdrStsLock;
	CSCardReaderStateArray m_aReaderStatus;

	// internally maintained -- does not include card name, rebuilt during each SetReaderStatus
	CCriticalSection m_csInternalRdrStsLock;
	SCARD_READERSTATE* m_pInternalReaderStatus;
	DWORD m_dwInternalNumReaders;
	LPTSTR m_szReaderNames;

};

#endif // _STATUS_MONITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\statmon.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    StatMon

Abstract:

    This file contains the implementation of CScStatusMonitor
    (an object that watches for status changes of readers recognized
    by the smart card service, handling PNP and requests for copies of
    the status array)

Author:

    Amanda Matlosz      02/26/98

Environment:

    Win32, C++ with exceptions

Revision History:

Notes:

--*/
#include "statmon.h"

// forward declarations of private functions
UINT ScStatusChangeProc(LPVOID pParam);


/////
// CScStatusMonitor

CScStatusMonitor::~CScStatusMonitor()
{
    if (stopped != m_status)
    {
        Stop();
    }
}


/*++

Start:

    The monitor will fail to start if:

        Any of the arguments are missing.
        Two SCARDCONTEXTs could not be acquired from the RM.
        An error occurs while retrieving a list of readers from the RM.
        Or the status thread fails to start.

Arguments:

    hWnd -- The monitor's owner's HWND, for sending notification messages.

    uiMsg -- The message that will be posted to the hWnd of the monitor's owner
                     when a change in status has occurred.

    szGroupNames -- Reader groups we're interested in.  see "winscard.h"

Return Value:

    LONG.

Author:

    Amanda Matlosz      02/26/98

Notes:

  If already started, causes a restart.
  All the arguments are required.

--*/
LONG CScStatusMonitor::Start(HWND hWnd, UINT uiMsg, LPCTSTR szGroupNames)
{
    LONG lReturn = SCARD_S_SUCCESS;

    // the monitor must be uninitialized or stopped before it can start
    if (uninitialized != m_status && stopped != m_status)
    {
        Stop();
    }

    if (NULL == hWnd || 0 == uiMsg)
    {
        // invalid parameters
        m_status = uninitialized;
        return ERROR_INVALID_PARAMETER;
    }

    m_hwnd = hWnd;
    m_uiStatusChangeMsg = uiMsg;

    if (NULL == szGroupNames || 0 == _tcslen(szGroupNames))
    {
        m_strGroupNames = SCARD_DEFAULT_READERS;
    }

    //
    // Get two contexts from the resource manager to use,
    // one for the monitor itself, and one for it's status-watching thread
    //

    m_hContext = NULL;
    m_hInternalContext = NULL;

    lReturn = SCardEstablishContext(SCARD_SCOPE_USER,
                                    NULL,
                                    NULL,
                                    &m_hContext);

    if (SCARD_S_SUCCESS == lReturn)
    {
        lReturn = SCardEstablishContext(SCARD_SCOPE_USER,
                                        NULL,
                                        NULL,
                                        &m_hInternalContext);
    }

    if (SCARD_S_SUCCESS != lReturn)
    {
        m_status = no_service;

        if (NULL != m_hContext)
        {
            SCardReleaseContext(m_hContext);
            m_hContext = NULL;
        }
        if (NULL != m_hInternalContext)
        {
            SCardReleaseContext(m_hInternalContext);
            m_hInternalContext = NULL;
        }
    }
    //
    // If we successfully got a context, go ahead and initialize
    // the internal reader status array & kick off status thread
    //
    else
    {
        lReturn = InitInternalReaderStatus();
    }

    if (SCARD_S_SUCCESS == lReturn)
    {
        m_status = running;

        // kick off status thread
        m_pStatusThrd = AfxBeginThread((AFX_THREADPROC)ScStatusChangeProc,
										(LPVOID)this,
										THREAD_PRIORITY_NORMAL,
										0,
										CREATE_SUSPENDED);

        if (NULL == m_pStatusThrd)
        {
            m_status = stopped;
            return GetLastError();
        }

		m_pStatusThrd->m_bAutoDelete = FALSE; // don't delete the thread on completion
		m_pStatusThrd->ResumeThread();
    }

    return lReturn;
}


/*++

Stop:

    In order to stop the monitor, the SCARDCONTEXTS are canceled, the
    status thread is shut down, and data members that are only valid while
    running are cleaned up.

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::Stop()
{
    m_status = stopped;

    // tell thread to stop now
    SCardCancel(m_hInternalContext);

    if (NULL != m_pStatusThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_pStatusThrd->m_hThread, INFINITE); // for testing: 10000
        _ASSERTE(WAIT_OBJECT_0 == dwRet);

		delete m_pStatusThrd;
        m_pStatusThrd = NULL;
    }

	// clear out internal scardcontext

    SCardReleaseContext(m_hInternalContext);
	m_hInternalContext = NULL;

    // Empty external readerstatusarray

    EmptyExternalReaderStatus();

    // Empty internal readerstatusarray

    if (NULL != m_pInternalReaderStatus)
    {
        delete[] m_pInternalReaderStatus;
        m_pInternalReaderStatus = NULL;
    }
    m_dwInternalNumReaders = 0;

    // Close main scardcontext so nothing can happen 'til restart
    SCardReleaseContext(m_hContext);
	m_hContext = NULL;
}


/*++

EmptyExternalReaderStatus:

    This empties out the external CSCardReaderStateArray, deleting
    all CSCardReaderState objects it has pointers to.

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::EmptyExternalReaderStatus(void)
{
    for (int nIndex = (int)m_aReaderStatus.GetUpperBound(); 0 <= nIndex; nIndex--)
    {
        delete m_aReaderStatus[nIndex];
    }

    m_aReaderStatus.RemoveAll();
}


/*++

GetReaderStatus:

    This returns copies of the Readers (CSCardReaderState) in the
    "external" array.

    It is assumed that the user is handing us an empty
    CSCardReaderStateArray, or one that is safe to be emptied.

Arguments:

    aReaderStatus -- a reference to a CSCardReaderStateArray that will
    receive the values of the new array.  If it is not empty, all the objects
    pointed to will be deleted and removed.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::GetReaderStatus(CSCardReaderStateArray& aReaderStatus)
{
    m_csRdrStsLock.Lock();

    // Make sure they gave us an empty array;
    // empty it out for them politely if they didn't.

    if (0 != aReaderStatus.GetSize())
    {
        for (int i = (int)aReaderStatus.GetUpperBound(); i>=0; i--)
        {
            delete aReaderStatus[i];
        }

        aReaderStatus.RemoveAll();
    }

    // build external copy of internal readerstatusarray
    CSCardReaderState* pReader = NULL;
    for (int i = 0; i <= m_aReaderStatus.GetUpperBound(); i++)
    {
        pReader = new CSCardReaderState(m_aReaderStatus[i]);
        ASSERT(NULL != pReader); // otherwise, fudge
        if (NULL != pReader)
		{
            aReaderStatus.Add(pReader);
		}
    }

    m_csRdrStsLock.Unlock();
}


/*++

SetReaderStatus:

    The external ReaderStatus array is set to mirror the internal
    READERSTATUSARRAY, with some embellishment.

    If the external ReaderStatus array is empty, it will be built.
    It if it not empty, it is assumed to be the correct length.

    The CScStatusMonitor's parent is notified before returning.

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::SetReaderStatus()
{
    m_csRdrStsLock.Lock();

    long lReturn = SCARD_S_SUCCESS;
    CSCardReaderState* pReader = NULL;

    //
    // if ext readerstatusarray is empty, initialize it
    //

    if (0 == m_aReaderStatus.GetSize())
    {
        for (DWORD dwIndex=0; dwIndex<m_dwInternalNumReaders; dwIndex++)
        {
            pReader = new CSCardReaderState();
            ASSERT(NULL != pReader);    // If not, fudge.
            if (NULL != pReader)
            {
                pReader->strReader = (LPCTSTR)m_pInternalReaderStatus[dwIndex].szReader;
                pReader->dwCurrentState = m_pInternalReaderStatus[dwIndex].dwCurrentState;
                pReader->dwEventState = m_pInternalReaderStatus[dwIndex].dwEventState;
                pReader->cbAtr = 0;
                pReader->strCard = _T("");
                pReader->dwState = 0;

                m_aReaderStatus.Add(pReader);
            }
        }
        pReader = NULL;
    }

    //
    // Set everything in the external array to match the internal.
    // It's safe to assume that both the internal and external
    // arrays match reader for reader.
    //

    for (DWORD dwIndex=0; dwIndex<m_dwInternalNumReaders; dwIndex++)
    {

        pReader = m_aReaderStatus.GetAt(dwIndex);
        bool fNewCard = false;

        if (NULL == pReader)
        {
            ASSERT(FALSE);  // this should be initialized at this point!
            TRACE(_T("CScStatusMonitor::SetReaderStatus external array does not match internal array."));
            break;
        }

        // set state
        pReader->dwEventState = m_pInternalReaderStatus[dwIndex].dwEventState;
        pReader->dwCurrentState = m_pInternalReaderStatus[dwIndex].dwCurrentState;

        // NO CARD
        if(pReader->dwEventState & SCARD_STATE_EMPTY)
        {
            pReader->dwState = SC_STATUS_NO_CARD;
        }
        // CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?
        else if(pReader->dwEventState & SCARD_STATE_PRESENT)
        {
            if (pReader->dwEventState & SCARD_STATE_MUTE)
            {
                pReader->dwState = SC_STATUS_UNKNOWN;
            }
            else if (pReader->dwEventState & SCARD_STATE_INUSE)
            {
                if(pReader->dwEventState & SCARD_STATE_EXCLUSIVE)
                {
                    pReader->dwState = SC_STATUS_EXCLUSIVE;
                }
                else
                {
                    pReader->dwState = SC_STATUS_SHARED;
                }
            }
            else
            {
                pReader->dwState = SC_SATATUS_AVAILABLE;
            }
        }
        // READER ERROR: at this point, something's gone wrong
        else // m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE
        {
            pReader->dwState = SC_STATUS_ERROR;
        }

        //
        // ATR and CardName: reset to empty if card is not available/responding
        // else, query RM for first card name to match ATR
        //

        if (SC_STATUS_NO_CARD == pReader->dwState ||
                SC_STATUS_UNKNOWN == pReader->dwState ||
                SC_STATUS_ERROR == pReader->dwState )
        {
            pReader->strCard.Empty();
            pReader->cbAtr = 0;
        }
        else
        {
            LPTSTR szCardName = NULL;
            DWORD dwNumChar = SCARD_AUTOALLOCATE;

            pReader->cbAtr = m_pInternalReaderStatus[dwIndex].cbAtr;
            memcpy(pReader->rgbAtr,
                    m_pInternalReaderStatus[dwIndex].rgbAtr,
                    m_pInternalReaderStatus[dwIndex].cbAtr);

            lReturn = SCardListCards(m_hInternalContext,
                                    (LPCBYTE)pReader->rgbAtr,
                                    NULL,
                                    (DWORD)0,
                                    (LPTSTR)&szCardName,
                                    &dwNumChar);

            if (SCARD_S_SUCCESS == lReturn)
            {
                pReader->strCard = (LPCTSTR)szCardName;
                SCardFreeMemory(m_hInternalContext, (LPVOID)szCardName);
            }
            else
            {
                pReader->strCard.Empty();
            }
        }
    }       // Now the two arrays are in sync

    m_csRdrStsLock.Unlock();

    ::PostMessage(m_hwnd, m_uiStatusChangeMsg, 0, (LONG)lReturn);
}


/*++

InitInternalReaderStatus:

    This resets the internal READERSTATUSARRAY to <empty> before calling
    SCardListReaders; if there are no readers, the array will remain empty;
    if the RM is down, an error will be returned.

Arguments:

    None.

Return Value:

    0 on success; WIN32 error message otherwise.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
LONG CScStatusMonitor::InitInternalReaderStatus()
{
    LONG lReturn = SCARD_S_SUCCESS;

    //
    // Get list of readers from Resource manager
    //
    if (NULL != m_pInternalReaderStatus)
    {
        delete[] m_pInternalReaderStatus;
    }

    DWORD dwNameLength = SCARD_AUTOALLOCATE;
    m_szReaderNames = NULL;
    m_dwInternalNumReaders = 0;

    lReturn = SCardListReaders(m_hContext,
								(LPTSTR)(LPCTSTR)m_strGroupNames,
								(LPTSTR)&m_szReaderNames,
								&dwNameLength);

    if(SCARD_S_SUCCESS == lReturn)
    {
        // make a readerstatusarray big enough for all readers
        m_dwInternalNumReaders = MStringCount(m_szReaderNames);
        _ASSERTE(0 != m_dwInternalNumReaders);
        m_pInternalReaderStatus = new SCARD_READERSTATE[m_dwInternalNumReaders];
        if (NULL != m_pInternalReaderStatus)
        {
            // use the list of readers to build a readerstate array
            LPCTSTR pchReader = m_szReaderNames;
            int nIndex = 0;
            while(0 != *pchReader)
            {
                m_pInternalReaderStatus[nIndex].szReader = pchReader;
                m_pInternalReaderStatus[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
                pchReader += lstrlen(pchReader)+1;
                nIndex++;
            }
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }
    else if (SCARD_E_NO_READERS_AVAILABLE == lReturn)
    {
        m_status = no_readers;
        if(NULL != m_szReaderNames)
        {
            SCardFreeMemory(m_hContext, (LPVOID)m_szReaderNames);
            m_szReaderNames = NULL;
        }
    }
    // else m_status == unknown?

    // this array, and the m_szReaderNames used to build it, are now property of
    // the StatusChangeProc...

    return lReturn;
}


/*++

ScStatusChangeProc:


Arguments:

    pParam - CScStatusMonitor*

Return Value:

    0 on success; WIN32 error message otherwise.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
UINT ScStatusChangeProc(LPVOID pParam)
{
    UINT uiReturn = 0;

    if(NULL != pParam)
    {
        return ((CScStatusMonitor*)pParam)->GetStatusChangeProc();
    }

    return SCARD_E_INVALID_PARAMETER;
}


UINT CScStatusMonitor::GetStatusChangeProc()
{
    LONG lReturn = SCARD_S_SUCCESS;

    while (stopped != m_status)
    {
        // Wait for change in status (safe to use pMonitor's internal vars)
        lReturn = SCardGetStatusChange(m_hInternalContext,
                                        INFINITE,
                                        m_pInternalReaderStatus,
                                        m_dwInternalNumReaders);

        // inform monitor that given status has changed (Only on success!)
        if (SCARD_S_SUCCESS == lReturn)
        {
            SetReaderStatus();
        }
        else
        {
            //
            // If the context has been cancelled, quit quietly
            // Otherwise, announce that the thread is aborting prematurely
            //
			m_status = stopped;

            if(SCARD_E_CANCELLED != lReturn)
            {
                // TODO: ? wrap in critsec ?
                m_pStatusThrd = NULL;
                // TODO: ? end crit sec ?

                ::PostMessage(m_hwnd, m_uiStatusChangeMsg, 0, (LONG)lReturn);
            }

            break;
        }

        // Prep the array for the next GetStatusChange call
        for(DWORD dwIndex=0; dwIndex<m_dwInternalNumReaders; dwIndex++)
        {
            m_pInternalReaderStatus[dwIndex].dwCurrentState =
                m_pInternalReaderStatus[dwIndex].dwEventState;
        }
    }

    // Clean Up
    if(NULL != m_szReaderNames)
    {
        SCardFreeMemory(m_hContext, (LPVOID)m_szReaderNames);
        m_szReaderNames = NULL;
    }


    return (UINT)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\inc\cmnuilb.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cmnuilb.h

Abstract:

	This file includes headers used for the cmnuilb.lib
	
	
Author:

    Chris Dudley 7/28/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

--*/

#ifndef __CMNUILB_H__
#define __CMNUILB_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include <cmnui.h>
#include <rdrstate.h>
#include <senv.h>


/////////////////////////////////////////////////////////////////////////////

#endif // __CMNUILB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\common\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCardDlg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\inc\cmnui.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Common

Abstract:

    This file contains common includes, data structures, defines, etc. used
    throughtout the common dialog

Author:

    Chris Dudley 3/15/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:
    
    Chris Dudley 5/13/1997

Notes:

--*/

#ifndef __COMMON_H__
#define __COMMON_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include <winscard.h>
#include <SCardLib.h>
#include <scarderr.h> //Smartcard errors

//////////////////////////////////////////////////////////////////////////////
//
// Defines
//

// Status of reader
#define SC_STATUS_NO_CARD       0	// SCARD_STATE_EMPTY
#define SC_STATUS_UNKNOWN		1	// SCARD_STATE_PRESENT | SCARD_STATE_MUTE
#define SC_SATATUS_AVAILABLE	2	// SCARD_STATE_PRESENT (| SCARD_STATE_UNPOWERED)
#define SC_STATUS_SHARED		3	// SCARD_SATATE_PRESENT | SCARD_STATE_INUSE
#define SC_STATUS_EXCLUSIVE		4	// "" | SCARD_STATE_EXCLUSIVE
#define SC_STATUS_ERROR			5	// SCARD_STATE_UNAVAILABLE (reader or card error)

/*
#define SC_STATUS_NO_CARD       0	
#define SC_STATUS_NOT_IN_USE    1
#define SC_STATUS_ERROR         2
#define SC_STATUS_IN_USE        3
*/

/////////////////////////////////////////////////////////////////////////////
//
// Structures
//
#ifndef __READERINFO__
#define __READERINFO__
typedef struct _READERINFO {
    CTextString     sReaderName;    // Reader name
    CTextString     sCardName;      // Card name if inserted
    BOOL            fCardInserted;  // Flag indicating card in reader
    BOOL            fCardLookup;    // Flag indicating inserted card is being looked for
    BOOL            fChecked;       // Flag indicating inserted card has been checked by callers code
    DWORD           dwState;        // State of reader
    DWORD           dwInternalIndex;// Indicates this readerinfo's position in a ReaderStateArray
    BYTE            rgbAtr[36];     // RFU!!
    DWORD           dwAtrLength;    // RFU!!
} SCARD_READERINFO;
typedef SCARD_READERINFO* LPSCARD_READERINFO;
#endif

// Structure used for thread-to-thread communication.
// Note: "Might" want to encapsulate these in class!!
#ifndef __STATUS__
#define __STATUS__
typedef struct _STATUS {
    HWND        hwnd;
    // Event handles
    HANDLE      hEventKillStatus;
    // Smartcard Info
    SCARDCONTEXT hContext;
    LPSCARD_READERSTATE rgReaderState;
    DWORD       dwNumReaders;
} SCSTATUS, *LPSCSTATUS;
#endif //STATUS

////////////////////////////////////////////////////////////////////////////////
//
// Constants
//
#define SCARD_NO_MORE_READERS       -1
const char SCARD_DEFAULT_A[] = "SCard$DefaultReaders\0\0";
const WCHAR SCARD_DEFAULT_W[] = L"SCard$DefaultReaders\0\0";

//////////////////////////////////////////////////////////////////////////
//
// Macros
//
#ifndef SCARDFAILED
    #define SCARDFAILED(r)      ((r != SCARD_S_SUCCESS) ? TRUE : FALSE)
#endif

#ifndef SCARDSUCCESS
    #define SCARDSUCCESS(r)     ((r == SCARD_S_SUCCESS) ? TRUE : FALSE)
#endif

//////////////////////////////////////////////////////////////////////////////

#endif //__SCDLGCMN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\common\senv.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

	SEnv

Abstract:

	This file contains the outline implementation of the Smartcard Common
	dialog CSCardEnv class. This class encapsulates current Smartcard
	environment information (i.e. given groups, readers, cards, etc.)
	
Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	Chris Dudley (cdudley) 4/15/97
	Amanda Matlosz (amatlosz) 1/29/98 Combined CSCardEnv and CSCardGroup,
										added unicode support

Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "stdafx.h"
#include "senv.h"
#include <querydb.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// local macros
#ifdef _DEBUG
	#define TRACE_STR(name,sz) \
				TRACE(_T("CmnUILb.lib: %s: %s\n"), name, sz)
	#define TRACE_CODE(name,code) \
				TRACE(_T("CmnUILb.lib: %s: error = 0x%x\n"), name, code)
	#define TRACE_CATCH(name,code)		TRACE_CODE(name,code)
	#define TRACE_CATCH_UNKNOWN(name)	TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
	#define TRACE_STR(name,sz)			((void)0)
	#define TRACE_CODE(name,code)		((void)0)
	#define TRACE_CATCH(name,code)		((void)0)
	#define TRACE_CATCH_UNKNOWN(name)	((void)0)
#endif  // _DEBUG


/////////////////////////////////////////////////////////////////////////////
//
// CSCardEnv Implementation
//


/*++
GetDialogTitle:

	Routine returns a new title for the dialog if needed

Arguments:

	pstzTitle -- pointer to a CTextString to contain the dialog's title
		
Return Value:
	
    A CTextString object containing the new dialog text or empty string
	if no new title required.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz	1/28/98	Add unicode support/code cleanup

Notes:

--*/
void CSCardEnv::GetDialogTitle( CTextString *pstzTitle )
{
	// check & empty params

	ASSERT(NULL != pstzTitle);
	pstzTitle->Clear();

	*pstzTitle = m_strTitle;
}


/*++

LONG CardMeetsSearchCriteria:

    Routine determines if a selected reader has a card inserted which
	meets the search criteria defined by the caller.

Arguments:

	dwSelectedReader - index used to select which reader to query.
		
Return Value:
	
    A BOOL value indicating whether or not the card meets the search criteria.

Author:

	Amanda Matlosz	3/16/1998	created

Revisions:


--*/
BOOL CSCardEnv::CardMeetsSearchCriteria(DWORD dwSelectedReader)
{
	BOOL fReturn = FALSE;
	CSCardReaderState* pReaderState = NULL;
	SCARD_READERINFO ReaderInfo;

	try
	{
		// check params
		if(dwSelectedReader >= (DWORD)NumberOfReaders())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsContextValid())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		
		// get the reader object
		pReaderState = m_rgReaders[dwSelectedReader];

		// is it valid, matches the search list, and passes the check?
		if (NULL != pReaderState)
		{
			ReaderInfo.fCardLookup = FALSE;
			ReaderInfo.fChecked = FALSE;

			pReaderState->GetReaderInfo(&ReaderInfo);

			fReturn = (ReaderInfo.fCardLookup && ReaderInfo.fChecked);
		}
	}
	catch(LONG lErr)
	{
		TRACE_CATCH(_T("CardMeetsSearchCriteria"), lErr);
	}
	catch(...)
	{
		TRACE_CATCH_UNKNOWN(_T("CardMeetsSearchCriteria"));
	}

	return fReturn;
}
/*++

LONG ConnectToReader:

    Routine connects to a selected reader, and sets the user-provided structs
	to contain the reader&cardname.  returns an error if the user-provided struct's
	buffers aren't long enough.

Arguments:

	dwSelectedReader - index used to select which reader to connect to.
		
Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz	1/28/1998	code cleanup

--*/
LONG CSCardEnv::ConnectToReader(DWORD dwSelectedReader)
{
	LONG lReturn = SCARD_S_SUCCESS;
	LPSTR szName = NULL;
	LPWSTR wszName = NULL;

	try
	{
		if (!IsContextValid())
		{
			throw (LONG)E_FAIL;
		}

		//
		// If user has indicated to make a connection, do so
		// through callbacks or internally.
		// m_strReader and m_strCard are set as a side effect of these connect calls
		//

		if(IsCallbackValid())
		{
			lReturn = ConnectUser(	dwSelectedReader,
									&m_hCardHandle,
									&m_strReader,
									&m_strCard);
		}
		else
		{
			if (0 != m_dwShareMode)
			{
				lReturn = ConnectInternal(	dwSelectedReader,
											&m_hCardHandle,
											m_dwShareMode,
											m_dwPreferredProtocols,
											&m_dwActiveProtocol,
											&m_strReader,
											&m_strCard);
			}
			else
			{
				//
				// MUST set m_strReader and m_strCard manually
				//
				CSCardReaderState* pReaderState = NULL;
				pReaderState = m_rgReaders[dwSelectedReader];
				if (NULL != pReaderState)
				{
					lReturn = pReaderState->GetReaderCardInfo(	&m_strReader,
																&m_strCard);
				}
			}
		}
		if (SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}

		//
		// Set the user's OCN struct to contain return information
		//

		if(NULL != m_pOCNW)
		{
			m_pOCNW->hCardHandle = m_hCardHandle;
			m_pOCNW->dwActiveProtocol = m_dwActiveProtocol;

			wszName = (LPWSTR)(LPCWSTR)m_strReader;
			if (m_pOCNW->nMaxRdr >= m_strReader.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNW->lpstrRdr,
								(CONST LPVOID)wszName,
								((m_strReader.Length()+1) * sizeof(WCHAR)) );
			}
			else
			{
				m_pOCNW->nMaxRdr = m_strReader.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			};

			wszName = (LPWSTR)(LPCWSTR)m_strCard;
			if (m_pOCNW->nMaxCard >= m_strCard.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNW->lpstrCard,
								(CONST LPVOID)wszName,
								((m_strCard.Length()+1) * sizeof(WCHAR)) );
			}
			else
			{
				m_pOCNW->nMaxCard = m_strCard.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			};
		}
		else if (NULL != m_pOCNA)
		{
			m_pOCNA->hCardHandle = m_hCardHandle;
			m_pOCNA->dwActiveProtocol = m_dwActiveProtocol;

			szName = (LPSTR)(LPCSTR)m_strReader;
			if (m_pOCNA->nMaxRdr >= m_strReader.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNA->lpstrRdr,
								(CONST LPVOID)szName,
								m_strReader.Length()+1);
			}
			else
			{
				m_pOCNA->nMaxRdr = m_strReader.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			}
	
			szName = (LPSTR)(LPCSTR)m_strCard;
			if (m_pOCNA->nMaxCard >= m_strCard.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNA->lpstrCard,
								(CONST LPVOID)szName,
								m_strCard.Length()+1);
			}
			else
			{
				m_pOCNA->nMaxCard = m_strCard.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			}
		}
		else
		{
			// Error!  One of them must be valid!
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("ConnectToReader"), lErr);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("ConnectToReader"));
	}

	return lReturn;
}


/*++

LONG Search:

    This routine is called to search for a card when the calling application
	requests SC_DLG_NO_UI or SC_DLG_MINIMAL_UI.
		
Arguments:

	pcMatches - pointer to a counter containing the number of matches found for
	the given searched for card.

	pdwIndex - index of the first card found that matches the search criteria.

Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

Author:

    Chris Dudley (cdudley) 4/15/97

--*/
LONG CSCardEnv::Search(int *pcMatches, DWORD *pdwIndex)
{
	// Locals
	LONG	lReturn = SCARD_S_SUCCESS;
	LONG	lMoreReaders = SCARD_S_SUCCESS;
	int		cMatches = 0;
	DWORD	dwIndex = 0;
	BOOL	fIndexStored = FALSE;
	SCARD_READERINFO	ReaderInfo;

	try
	{
		// Check params
		if(pcMatches == NULL || pdwIndex == NULL)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}

		// Initialize reader array
		lReturn = UpdateReaders();
		if(SCARDFAILED(lReturn))
		{
			throw lReturn;
		}

		//
		// Walk through cards testing if this is a seached for card
		//

		lMoreReaders = FirstReader(&ReaderInfo);
		while (SCARD_NO_MORE_READERS != lMoreReaders)
		{
			// Check card search status
			if((ReaderInfo.fCardLookup) && (ReaderInfo.fChecked))
			{
				// We've found a card being searched for...Update
				cMatches++;

				// Save the index of this card
				if (!fIndexStored)
				{
					dwIndex = ReaderInfo.dwInternalIndex;
					fIndexStored = TRUE;
				}
			}
			
			// Must clean up CTextString members before calling again
			ReaderInfo.sReaderName.Clear();
			ReaderInfo.sCardName.Clear();

			// Get Next struct
			lMoreReaders = NextReader( &ReaderInfo );
		}

		// Package for return
		*pcMatches = cMatches;
		*pdwIndex = dwIndex;
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("Search"), lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("Search"));
	}

	return lReturn;
}


/*++

InitializeAllPossibleCardNames:

    Stores all known card names matching the ATRs of the cardnames provided by
	the OPENCARDNAME struct to search for.
*/
void CSCardEnv::InitializeAllPossibleCardNames( void )
{
	LPCSTR szCards = NULL;
	LONG lResult = SCARD_S_SUCCESS;
	CBuffer bfAtr, bfAtrMask, bfInterfaces, bfProvider;

	if (0 == MStringCount(m_strCardNames))
	{
		// No card names to check
		m_strAllPossibleCardNames = m_strCardNames;
		return;
	}

	szCards = m_strCardNames;

	szCards = FirstString(szCards);
	while (szCards != NULL)
	{
		//
		// get all possible names for this card's ATR
		//

		if (! GetCardInfo(
					SCARD_SCOPE_USER,
					szCards,
					&bfAtr,
					&bfAtrMask,
					&bfInterfaces,
					&bfProvider ) )
		{
			// it's weird that this failed, but assume that the name is still OK
			m_strAllPossibleCardNames += szCards;
		}
		else
		{
			LPTSTR szListCards = NULL;
			DWORD dwCards = SCARD_AUTOALLOCATE;

			lResult = SCardListCards(
						m_hContext,
						bfAtr,
						NULL,
						0,
						(LPTSTR)&szListCards,
						&dwCards);

			if (SCARD_S_SUCCESS == lResult)
			{
				// append them to the list of all possible card names
				m_strAllPossibleCardNames += szListCards;
			}
			else
			{
				// it's weird that this failed, but assume that the name is still OK
				m_strAllPossibleCardNames += szCards;
			}

			if (NULL != szListCards)
			{
				SCardFreeMemory(m_hContext, (PVOID)szListCards);
			}
		}

		szCards = NextString(szCards);
	}

}


/*++

LONG SetOCN:

    Stores the user OpenCardName info in the encapsulated data for UNICODE and
	ANSI.
		
Arguments:

	LPOPENCARDNAMEA - pointer to ANSI Open card name data.
	LPOPENCARDNAMEW - pointer to UNICODE Open card name data.

Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz	1/28/98	code cleanup, use charset-generic m_OCN,
							move EnableUI code to separate function

--*/
LONG CSCardEnv::SetOCN(LPOPENCARDNAMEA	pOCNA)
{
	// Locals
	LONG		lReturn = SCARD_S_SUCCESS;
	int			cMatches = 0;
	DWORD		dwIndex = 0;

	try
	{
		// Check params
		if(NULL == pOCNA)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if( pOCNA->dwStructSize != sizeof (OPENCARDNAMEA) )
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}

		// TODO: ?? remove this test when Interfaces search is implemented ??
		if( (pOCNA->rgguidInterfaces != NULL) || (pOCNA->cguidInterfaces != 0) )
		{
			throw (LONG)SCARD_E_INVALID_VALUE;	// NYI
		}

		//
		// Set UNICODE-specific members to NULL!
		//

		m_pOCNW = NULL;
		m_lpfnConnectW = NULL;

		//
		// Set appropriate charset-correct member, and copy to charset-generic
		//

		m_pOCNA = pOCNA;

		m_hwndOwner = m_pOCNA->hwndOwner;
		m_hContext = m_pOCNA->hSCardContext;
		m_strCardNames = m_pOCNA->lpstrCardNames;
		m_rgguidInterfaces = m_pOCNA->rgguidInterfaces;
		m_cguidInterfaces = m_pOCNA->cguidInterfaces;
		m_strReader = m_pOCNA->lpstrRdr;
		m_strCard = m_pOCNA->lpstrCard;
		m_strTitle = m_pOCNA->lpstrTitle;
		m_dwFlags = m_pOCNA->dwFlags;
		m_pvUserData = m_pOCNA->pvUserData;
		m_dwShareMode = m_pOCNA->dwShareMode;
		m_dwPreferredProtocols = m_pOCNA->dwPreferredProtocols;
		m_dwActiveProtocol = m_pOCNA->dwActiveProtocol;
		m_lpfnConnectA = m_pOCNA->lpfnConnect;
		m_lpfnCheck = m_pOCNA->lpfnCheck;
		m_lpfnDisconnect = m_pOCNA->lpfnDisconnect;
		m_lpUserData = m_pOCNA->pvUserData;
		m_hCardHandle = m_pOCNA->hCardHandle;

		// special case: lpstrGroupNames==NULL -> use default
		if (NULL != m_pOCNA->lpstrGroupNames)
		{
			m_strGroupNames = m_pOCNA->lpstrGroupNames;
		}
		else
		{
			m_strGroupNames = "SCard$DefaultReaders";
		}

		InitializeAllPossibleCardNames();
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("SetOCN - ANSI"),lReturn);
	}
	catch(...)
	{
		lReturn = (LONG)SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("SetOCN - ANSI"));
	}


	// Release memory if required
	RemoveReaders();

	return lReturn;
}


// UNICODE
LONG CSCardEnv::SetOCN(LPOPENCARDNAMEW	pOCNW)
{
	LONG lReturn = SCARD_S_SUCCESS;

	try
	{
		// Check params
		if (NULL == pOCNW)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if (pOCNW->dwStructSize != sizeof(OPENCARDNAMEW) )
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if ((pOCNW->rgguidInterfaces != NULL) || (pOCNW->cguidInterfaces != 0))
		{
			throw (LONG)SCARD_E_INVALID_VALUE; // NYI
		}

		//
		// Set ANSI-specific members to NULL!
		//

		m_pOCNA = NULL;
		m_lpfnConnectA = NULL;

		//
		// Set appropriate charset-correct member, and copy to charset-generic
		//

		m_pOCNW = pOCNW;

		m_hwndOwner = m_pOCNW->hwndOwner;
		m_hContext = m_pOCNW->hSCardContext;
		m_strCardNames = m_pOCNW->lpstrCardNames;
		m_rgguidInterfaces = m_pOCNW->rgguidInterfaces;
		m_cguidInterfaces = m_pOCNW->cguidInterfaces;
		m_strReader = m_pOCNW->lpstrRdr;
		m_strCard = m_pOCNW->lpstrCard;
		m_strTitle = m_pOCNW->lpstrTitle;
		m_dwFlags = m_pOCNW->dwFlags;
		m_pvUserData = m_pOCNW->pvUserData;
		m_dwShareMode = m_pOCNW->dwShareMode;
		m_dwPreferredProtocols = m_pOCNW->dwPreferredProtocols;
		m_dwActiveProtocol = m_pOCNW->dwActiveProtocol;
		m_lpfnConnectW = m_pOCNW->lpfnConnect;
		m_lpfnCheck = m_pOCNW->lpfnCheck;
		m_lpfnDisconnect = m_pOCNW->lpfnDisconnect;
		m_lpUserData = m_pOCNW->pvUserData;
		m_hCardHandle = m_pOCNW->hCardHandle;

		// special case: lpstrGroupNames=="" -> use default
		if (NULL != m_pOCNW->lpstrGroupNames && 0 != *(m_pOCNW->lpstrGroupNames))
		{
			m_strGroupNames = m_pOCNW->lpstrGroupNames;
		}
		else
		{
			m_strGroupNames = L"SCard$DefaultReaders";
		}

		InitializeAllPossibleCardNames();
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("SetOCN - UNICODE"),lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("SetOCN - UNICODE"));
	}

	return lReturn;
}


/*++

LONG NoUISearch:

    If the user has not set SC_DLG_FORCE_UI, perform a search for all
	possible cards.  If only one card is the result, then the search has
	succeeded and no UI is necessary.

		
Arguments:

	BOOL* pfEnableUI.
		
Return Value:
	
    A LONG indicating the success of the search.  If SC_DLG_FORCE_UI is set,
	pfEnableUI is always TRUE; if SC_DLG_NO_UI is set, the pfEnableUI is always
	FALSE.

Author:

    Amanda Matlosz	02/01/1998	

Revisions:

--*/
LONG CSCardEnv::NoUISearch(BOOL* pfEnableUI)
{
	//
	// Must search so we can check all the cards, even if we have to show UI
	//

	*pfEnableUI = FALSE;
	long lResult = SCARD_S_SUCCESS;
	int cMatches = 0;
	DWORD dwIndex = 0;

	try
	{
		// Search for the card
		lResult = Search(&cMatches, &dwIndex);
		if(SCARDFAILED(lResult))
		{
			throw lResult;
		}

		// Determine if UI should be used...

		if(m_dwFlags & SC_DLG_FORCE_UI)
		{
			*pfEnableUI = TRUE;
		}
		else if((m_dwFlags & SC_DLG_MINIMAL_UI) && (cMatches != 1))
		{
			*pfEnableUI = TRUE;
		}

		// Connect to the reader if 1 matching card found

		if(cMatches == 1)
		{
			lResult = ConnectToReader(dwIndex);
			if (SCARDFAILED(lResult))
			{
				*pfEnableUI = TRUE; // an error occurred with the reader?  eep.
				throw lResult;
			}
		}
	}
	catch(LONG lErr)
	{
		TRACE_CATCH(_T("NoUISearch"),lErr);
	}
	catch(...)
	{
		TRACE_CATCH_UNKNOWN(_T("NoUISearch"));
		lResult = SCARD_F_UNKNOWN_ERROR;
	}

	// Release memory if required
	RemoveReaders();

	return lResult;
}


/*++

LONG BuildReaderArray:

    Builds an array of CSCardReader objects. 1 object per reader.
		
Arguments:

	szReaderNames - an LPTSTR (A/W) multistring containing a list of readers.
		
Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

Author:

    Chris Dudley 3/5/1997

Revisions:

	Amanda Matlosz 1/29/98	added unicode support
--*/
LONG CSCardEnv::BuildReaderArray( LPTSTR szReaderNames )
{
	LONG		lReturn = SCARD_S_SUCCESS;
	LPCTSTR		szReaderName = szReaderNames;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		// Check Params
		if (NULL == szReaderNames || NULL == *szReaderNames)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		
		//
		// Store a reader object in the array for each reader
		//

		szReaderName = FirstString( szReaderName );
		while (NULL != szReaderName)
		{
			pReaderState = new CSCardReaderState;
			if (NULL == pReaderState)
			{
				throw (LONG)SCARD_E_NO_MEMORY;
			}

			pReaderState->SetContext(m_hContext);
			pReaderState->StoreName(szReaderName);

			if (NULL != m_pOCNA)
			{
				lReturn = pReaderState->SetReaderState(	m_lpfnConnectA,
														m_lpfnCheck,
														m_lpfnDisconnect,
														m_lpUserData);
			}
			else if (NULL != m_pOCNW)
			{
				lReturn = pReaderState->SetReaderState(	m_lpfnConnectW,
														m_lpfnCheck,
														m_lpfnDisconnect,
														m_lpUserData);

			}
			else
			{
				// Either m_pOCNA or m_pOCNW *must* be valid!
				throw (long)SCARD_F_INTERNAL_ERROR;
			}

			if (SCARDFAILED(lReturn))
			{
				throw (lReturn);
			}

			// Check if card inserted and set flag if it contains the search card
			if (pReaderState->IsCardInserted())
			{
				// TODO: ?? fix readerstate so it's nicer w/ W ??
				lReturn = pReaderState->CheckCard(m_strAllPossibleCardNames);
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}
			}

			m_rgReaders.Add(pReaderState);
			szReaderName = NextString(szReaderName);
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("BuildReaderArray"), lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("BuildReaderArray"));
	}

	return lReturn;
}


/*++

LONG ConnectInternal:

    Connect internally to the reader

Arguments:

	dwSelectedIndex - index used to select which reader to connect to.
	pHandle - pointer to an SCARDHANDLE that will be set on  return.
	dwShareMode - contains share mode to use when connecting
	dwProtocols - contains requested protocol(s) to use when connecting
	pdwActiveProtocl - returns active protocol on successful connection
	szReaderName - returned name of the reader being connected

Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revisions:

	Amanda Matlosz 1/30/98	code cleanup
--*/
LONG CSCardEnv::ConnectInternal(	DWORD dwSelectedReader,
									SCARDHANDLE *pHandle,
									DWORD dwShareMode,
									DWORD dwProtocols,
									DWORD *pdwActiveProtocol,
									CTextString *pszReaderName,//=NULL
									CTextString *pszCardName//=NULL
									)
{
	LONG lReturn = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		// Check Params
		if (NULL == pHandle)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		if (NULL == pdwActiveProtocol)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		if (dwSelectedReader >= (DWORD)NumberOfReaders())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsContextValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}
		
		// Clear handle
		*pHandle = NULL;

		// get the object & connect
		pReaderState = m_rgReaders[dwSelectedReader];
		lReturn = pReaderState->Connect(pHandle,
										dwShareMode,
										dwProtocols,
										pdwActiveProtocol,
										pszReaderName,
										pszCardName);
		if (SCARDFAILED(lReturn))
		{
			throw lReturn;
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("ConnectInternal"), lReturn);
	}
	catch(...)
	{
		lReturn = SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("ConnectInternal"));
	}

	return lReturn;
}


/*++

LONG ConnectUser:

    Connect to the reader using user supplied callback

Arguments:

	dwSelectedReader - index to reader to connect
	lpfnConnect - user supplied callback function.
	pHandle - pointer to an SCARDHANDLE that will be set on  return.
	lpUserData - pointer to user data.

Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revisions:

	Amanda Matlosz 1//30/98	code cleanup

--*/
LONG CSCardEnv::ConnectUser(	DWORD dwSelectedReader,
								SCARDHANDLE *pHandle,
								CTextString *pszReaderName, //=NULL
								CTextString *pszCardName //=NULL
								)
{
	LONG lReturn = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		// Check Params
		if(NULL == pHandle)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		if(dwSelectedReader >= (DWORD)NumberOfReaders())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsContextValid())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		
		// Clear handle
		*pHandle = NULL;

		// get the reader object & connect
		pReaderState = m_rgReaders[dwSelectedReader];
		lReturn = pReaderState->UserConnect(pHandle,
											pszReaderName,
											pszCardName);
		if (SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("ConnectUser"), lReturn);
	}
	catch(...)
	{
		lReturn = SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("ConnectUser"));
	}

	return lReturn;
}


/*++

void GetCardList:
	
	Returns a multistring containing the list cards being searched for.
		
Arguments:

	LPCTSTR* - pointer->pointer for the list
		
Return Value:
	
	none

Author:

    Chris Dudley 3/7/1997

Notes:
	
--*/
void CSCardEnv::GetCardList( LPCTSTR* pszCardList )
{
	// Check params
	if (NULL != pszCardList)
	{
		*pszCardList = m_strCardNames;
	}
}


/*++

BOOL IsCallbackValid:

    This routine checks the user callback functions.
		
Arguments:

	None
		
Return Value:
	
	TRUE if calbacks are valid. FALSE otherwise.

Author:

    Chris Dudley 3/15/1997

--*/
BOOL CSCardEnv::IsCallbackValid ( void )
{
	BOOL fValid = FALSE;

	fValid = ((NULL != m_lpfnConnectA || NULL != m_lpfnConnectW) &&
				(m_lpfnCheck != NULL) && (m_lpfnDisconnect != NULL));

	return fValid;
}


/*++

LONG CreateReaderStateArray:
	
	Returns an array of SCARD_READERSTATE structs.
		
Arguments:

	LPSCARD_READERSTATE* - pointer->pointer to an SCARDREADERSTATE struct
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revisions:

	Amanda Matlosz 1/30/98	added unicode support, code cleanup

--*/
LONG CSCardEnv::CreateReaderStateArray(	LPSCARD_READERSTATE* prgReaderStates )
{
	// Locals
	LONG	lReturn = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;
	LPSCARD_READERSTATE	rgReader;

	try
	{
		// Check params, etc.
		if (prgReaderStates == NULL)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsArrayValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

		// Clean up the destination
		DeleteReaderStateArray(prgReaderStates);

		// Build a temp array, set the destination array
		rgReader = new SCARD_READERSTATE[(size_t)m_rgReaders.GetSize()];
		if (rgReader == NULL)
		{
			throw (LONG)SCARD_E_NO_MEMORY;
		}
		
		for (int ix =0; ix < m_rgReaders.GetSize(); ix++)
		{
			pReaderState = m_rgReaders[ix];
			pReaderState->GetReaderState(&(rgReader[ix]));	// TODO: ?? looks funny ??
		}

		// Asign the pointer
		*prgReaderStates = rgReader;
	}

	catch (LONG err) {
		lReturn = err;
		TRACE_CATCH(_T("GetReaderStateArray"),err);
	}

	catch (...) {
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("GetReaderStateArray"));
	}

	return lReturn;
}


/*++

void DeleteReaderStateArray:

    Frees the memory associated with a previously created SCARD_READERSTATE
	array.
		
Arguments:

	rgReaderStateArray - pointer to the array.
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/7/1997

--*/
void CSCardEnv::DeleteReaderStateArray(LPSCARD_READERSTATE* prgReaderStateArray)
{
	if (NULL != *prgReaderStateArray)
	{
		delete [] (*prgReaderStateArray);
		*prgReaderStateArray = NULL;
	}
}


/*++

LONG FirstReader:

    Retrieves information on the first reader in the reader array.
		
Arguments:

	None
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

	A return value of SCARD_NO_MORE_READERS means no readers available.

Author:

    Chris Dudley 3/7/1997

Notes:

	1. This routine 0's the memory pointed to by pReaderInfo. The calling app should be
	careful (i.e. clean up LSCARD_READERINFO struct) before each call to this routine.

--*/
LONG CSCardEnv::FirstReader(LPSCARD_READERINFO pReaderInfo)
{
	// Locals
	LONG	lResult = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		if (NULL == pReaderInfo)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;	
		}

		// Give up if there are no readers
		if (m_rgReaders.GetSize() <= 0)
		{
			throw (LONG)SCARD_NO_MORE_READERS;
		}

		// Get the first reader
		m_dwReaderIndex = 0;
		pReaderState = m_rgReaders[m_dwReaderIndex];
		if (!pReaderState->IsStateValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

		// Prepare the return struct
		::ZeroMemory( (LPVOID)pReaderInfo, (DWORD)sizeof(SCARD_READERINFO));
		lResult = pReaderState->GetReaderInfo(pReaderInfo);
		if (SCARDFAILED(lResult))
		{
			throw (lResult);
		}
		// Update the index
		pReaderInfo->dwInternalIndex = m_dwReaderIndex;
	}
	catch(LONG lErr)
	{
		lResult = lErr;
		TRACE_CATCH(_T("FirstReader"), lResult);
	}
	catch(...)
	{
		lResult = SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("FirstReader"));
	}

	return lResult;
}


/*++

LONG NextReader:

    Retrieves information on the next reader (using internal index) in the
	reader array.
		
Arguments:

	None
		
Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

	A return value of SCARD_NO_MORE_READERS means no readers available.

Author:

    Chris Dudley 3/7/1997

Notes:

	1. This routine 0's the memory pointed to by pReaderInfo. The calling app should be
	careful (i.e. clean up LSCARD_READERINFO struct) before each call to this routine.

--*/
LONG CSCardEnv::NextReader(LPSCARD_READERINFO pReaderInfo)
{
	LONG	lResult = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;
	DWORD dwTotalReaders = (DWORD)m_rgReaders.GetUpperBound();

	try
	{
		// Check params
		if (NULL == pReaderInfo)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;	
		}

		// Is there a next reader to retrieve?
		m_dwReaderIndex++;
		if (m_dwReaderIndex > dwTotalReaders)
		{
			throw (LONG)SCARD_NO_MORE_READERS;
		}

		// Fetch the reader state from our array
		pReaderState = m_rgReaders[m_dwReaderIndex];
		if (!pReaderState->IsStateValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

		// Setup the struct to return

		::ZeroMemory((LPVOID)pReaderInfo, (DWORD)sizeof(SCARD_READERINFO));
		lResult = pReaderState->GetReaderInfo(pReaderInfo);
		if (SCARDFAILED(lResult))
		{
			throw (lResult);
		}

		// Update the index
		pReaderInfo->dwInternalIndex = m_dwReaderIndex;
	}
	catch(LONG lErr)
	{
		lResult = lErr;
		TRACE_CATCH(_T("NextReader"), lResult);
	}
	catch(...)
	{
		lResult = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("NextReader"));
	}

	return lResult;
}


/*++

void RemoveReaderArray:

    Deletes the array of CSCardReader objects.
		
Arguments:

	None
		
Return Value:

	None

Author:

    Chris Dudley 3/5/1997

Revisions:

	Amanda Matlosz 1/29/98	code cleanup

--*/
void CSCardEnv::RemoveReaders( void )
{
	if (IsArrayValid())
	{
		// Delete the attached reader objects
		for (int ix=0; ix <= m_rgReaders.GetUpperBound(); ix++)
		{
			delete m_rgReaders[ix];
		}

		// Free array memory
		m_rgReaders.RemoveAll();
	}
}


/*++

void SetContext:

    Sets the card context, performs no checking.
		
Arguments:

	hContext - card context handle
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/3/1997

--*/
void CSCardEnv::SetContext(SCARDCONTEXT hContext)
{
	m_hContext = hContext;
}


/*++

LONG UpdateReaders:

    Updates the reader array using m_GroupName member.
		
Arguments:

	None.
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz 1/29/98	added Unicode support

Note:
	
--*/
LONG CSCardEnv::UpdateReaders( void )
{
	TRACE("\tCSCardEnv::UpdateReaders\r\n");	// TODO: ?? remove this ??

	LONG		lReturn = SCARD_S_SUCCESS;
	LPTSTR		szReaderNames = NULL;
	DWORD		dwNameLength = SCARD_AUTOALLOCATE;

	if (!IsContextValid())
	{
		TRACE_CODE(_T("UpdateReaders"),E_FAIL);
		return (LONG)E_FAIL;
	}

	RemoveReaders();	// deletes current array if required

	try
	{
		// Call Resource manager for list of readers
		lReturn = SCardListReaders(m_hContext,
									m_strGroupNames,
									(LPTSTR)&szReaderNames,
									&dwNameLength);

		if(SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}

		// SCardListReaders will succeed in a PnP world even if there are currently no
		// readers for this group.
		_ASSERTE(NULL != szReaderNames && NULL != *szReaderNames);

		lReturn = BuildReaderArray(szReaderNames);
		if (SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("UpdateReaders"),lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("UpdateReaders"));
	}

	// Clean Up
	if(NULL != szReaderNames)
	{
		SCardFreeMemory(m_hContext, (LPVOID)szReaderNames);
	}

	return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\common\rdrstate.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    RdrState

Abstract:

    This file contains the outline implementation of the Smartcard Common
    dialog CSCardReaderState class. This class encapsulates Smartcard
    Reader information.

Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "stdafx.h"
#include "rdrstate.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Local Macros
//

#ifdef _DEBUG
    #define TRACE_STR(name,sz) \
                TRACE(_T("CmnUILb.lib: %s: %s\n"), name, sz)
    #define TRACE_CODE(name,code) \
                TRACE(_T("CmnUILb.lib: %s: error = 0x%x\n"), name, code)
    #define TRACE_CATCH(name,code)      TRACE_CODE(name,code)
    #define TRACE_CATCH_UNKNOWN(name)   TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
    #define TRACE_STR(name,sz)          ((void)0)
    #define TRACE_CODE(name,code)       ((void)0)
    #define TRACE_CATCH(name,code)      ((void)0)
    #define TRACE_CATCH_UNKNOWN(name)   ((void)0)
#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
// CSCardReaderState Implementation
//

/*++

void CheckCard:

    Routine sets an internal flag if the given card name is the currently
    in this reader.

Arguments:

    LPCTSTR - string containing the card name or names if multistring.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/10/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::CheckCard( LPCTSTR szCardName )
{
    // Locals
    LPCTSTR      szCards = szCardName;
    LPCTSTR      szCard = m_sCardName;
    LONG        lReturn = SCARD_S_SUCCESS;

    try
	{
        m_fCardLookup = FALSE;
        m_fChecked = FALSE;

		//
        // Set "Lookup" flag if card name is one we're looking for
		//

		if (0 == MStringCount(szCards))
		{
			// if we havn't indicated preferred card names, any
			// card name is considered...
			m_fCardLookup = TRUE;
		}
		else
		{
			szCards = FirstString(szCards);
			while ((szCards != NULL) && (!m_fCardLookup)) 
			{
				m_fCardLookup = ( _stricmp(szCards, szCard) == 0 );
				szCards = NextString(szCards);
			}
		}

        // If there's a match, does the card pass the check?
        if (m_fCardLookup)
		{
			// Call the user's callbacks if they're available
			if (IsCallbackValid())
			{
				lReturn = UserConnect(&m_hCard);
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}

				lReturn = UserCheck(); // this is where m_fChecked gets set.
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}

				lReturn = UserDisconnect();
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}
			}
			// Otherwise the card automatically checks out OK!
			else
			{
				m_fChecked = TRUE;
			}
        }
    }

    catch (LONG err) {
        lReturn = err;
        TRACE_CATCH(_T("CheckCard"), err);
    }

    catch (...) {
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("CheckCard"));
    }

    return lReturn;
}


/*++

LONG Connect:

    Attempts to connect to the reader

Arguments:

    pHandle - pointer to an SCARDHANDLE that will be returned.
    dwShareMode - preferred share.
    dwProtocols - preferred protocol
    dwActiveProtocol - returned actual protocol in use.
    pszReaderName - returned name of reader connecting to.
    pszCardName - returned name of card connecting to.

Return Value:

    A LONG value indicating the status of the requested action. 
    See the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
LONG CSCardReaderState::Connect(SCARDHANDLE *pHandle,
                                DWORD dwShareMode,
                                DWORD dwProtocols,
                                DWORD *pdwActiveProtocol,
                                CTextString *pszReaderName, //=NULL
                                CTextString *pszCardName //=NUL
                                )
{
    // Locals
    LONG        lReturn = SCARD_S_SUCCESS;

    try
	{
        // Check Params
        if (NULL == pHandle)
		{
            throw (LONG)SCARD_E_INVALID_VALUE;
		}
        if (NULL == pdwActiveProtocol)
		{
            throw (LONG)SCARD_E_INVALID_VALUE;
		}

        if (!IsCardInserted())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}
        if (!IsContextValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Clear handle
        *pHandle = NULL;

        if (!m_fConnected)
		{
            // Attempt to connect
            lReturn = SCardConnect( m_hContext,
                                    (LPCTSTR)m_sReaderName,
                                    dwShareMode,
                                    dwProtocols,
                                    &m_hCard,
                                    pdwActiveProtocol);
            if (SCARDFAILED(lReturn))
                throw (lReturn);

            // Return reader/card names
            if (pszReaderName != NULL)
                (*pszReaderName) = m_sReaderName;
            if (pszCardName != NULL)
                (*pszCardName) = m_sCardName;
        }

        *pHandle = m_hCard;
        m_fConnected = TRUE;
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("Connect"), lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("Connect"));
    }

    return lReturn;
}


/*++

LONG GetReaderCardInfo:

    Provides a way for user to set two CTextStrings to the reader and card name.

	This function is essentially a dummy connect routine -- it is used when the caller
	does not wish to actually connect to a card selected by the user, but would like
	to be able to know which card was selected, providing the same UI.

	Note that this is only of interest to the Common Dialog.

Arguments:

	pszReaderName - the Reader;
	pszCardName - the Card;

Return Value:

    A LONG value indicating the status of the requested action. 
    ALWAYS SCARD_S_SUCESS.

Author:

    Amanda Matlosz 3/24/98

Revision History:


--*/
LONG CSCardReaderState::GetReaderCardInfo(CTextString* pszReaderName,
											CTextString* pszCardName)
{
    if (NULL != pszReaderName)
	{
        (*pszReaderName) = m_sReaderName;
	}

    if (NULL != pszCardName)
	{
        (*pszCardName) = m_sCardName;
	}

	return SCARD_S_SUCCESS;
}



/*++

LONG GetReaderInfo:

    Retrieves the current state information of the object and returns.

Arguments:

    pReaderInfo - pointer to LPSCARD_READERINFO structure

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
LONG CSCardReaderState::GetReaderInfo( LPSCARD_READERINFO pReaderInfo )
{
    // Locals
    LONG    lReturn = SCARD_S_SUCCESS;

    try {
        // Check params, etc..
        if (NULL == pReaderInfo)
		{
            throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
        if (!IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Setup the struct
        ::ZeroMemory( (LPVOID)pReaderInfo, (DWORD)sizeof(SCARD_READERINFO));
        pReaderInfo->sReaderName = m_sReaderName;
        pReaderInfo->fCardLookup = m_fCardLookup;
        if (IsCardInserted())
		{
            pReaderInfo->sCardName = m_sCardName;
            pReaderInfo->fCardInserted = TRUE;
            pReaderInfo->fChecked = m_fChecked;
        }

        // Set the atr
        ::CopyMemory(   &(pReaderInfo->rgbAtr),
                        &(m_ReaderState.rgbAtr),
                        m_ReaderState.cbAtr);
        pReaderInfo->dwAtrLength = m_ReaderState.cbAtr;

		//
        // Set the state
		//

		// NO CARD
        if(m_ReaderState.dwEventState & SCARD_STATE_EMPTY)
		{
			pReaderInfo->dwState = SC_STATUS_NO_CARD;
		}
		// CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?
		else if(m_ReaderState.dwEventState & SCARD_STATE_PRESENT)
		{
			if (m_ReaderState.dwEventState & SCARD_STATE_MUTE)
			{
				pReaderInfo->dwState = SC_STATUS_UNKNOWN;
			}
			else if (m_ReaderState.dwEventState & SCARD_STATE_INUSE)
			{
				if(m_ReaderState.dwEventState & SCARD_STATE_EXCLUSIVE)
				{
					pReaderInfo->dwState = SC_STATUS_EXCLUSIVE;
				}
				else
				{
					pReaderInfo->dwState = SC_STATUS_SHARED;
				}
			}
			else
			{
				pReaderInfo->dwState = SC_SATATUS_AVAILABLE;
			}
        }
		// READER ERROR?  at this point, something's gone wrong
		else // if(m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE)
		{
			pReaderInfo->dwState = SC_STATUS_ERROR;
        }

    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("GetReaderInfo"), lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("GetReaderInfo"));
    }

    return lReturn;
}


/*++

LONG GetReaderState:

    Retrieves the current state information of the object and returns in
    given SCARD_READERSTATE struct.

Arguments:

    pReaderState - pointer to SCARD_READERSTATE_A or SCARD_READERSTATE_W struct

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revision History:

    Chris Dudley 5/13/1997
	Amanda Matlosz 2/01/98 A/W code cleanup

--*/
LONG CSCardReaderState::GetReaderState( LPSCARD_READERSTATE pReaderState )
{
    LONG lReturn = SCARD_S_SUCCESS;

    try
	{
        // Check params, etc..
        if (NULL == pReaderState)
		{
            throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
        if (!IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Setup the struct
        ::ZeroMemory(   (LPVOID)pReaderState,
                        (DWORD)sizeof(SCARD_READERSTATE));
        pReaderState->szReader = m_sReaderName;
        pReaderState->dwEventState = m_ReaderState.dwEventState;
        pReaderState->dwCurrentState = m_ReaderState.dwCurrentState;
        pReaderState->cbAtr = m_ReaderState.cbAtr;
        ::CopyMemory(   (LPVOID)pReaderState->rgbAtr,
                        (CONST LPVOID)m_ReaderState.rgbAtr,
                        (DWORD)pReaderState->cbAtr );
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("FirstReader"), lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("FirstReader"));
    }

    return lReturn;
}


/*++

BOOL IsCallbackValid:

    This routine checks the user callback functions.

Arguments:

    None

Return Value:

    TRUE if calbacks are valid. FALSE otherwise.

Author:

    Chris Dudley 3/15/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
BOOL CSCardReaderState::IsCallbackValid ( void )
{
    // Locals
    BOOL    fValid = FALSE;

    fValid =  (((m_lpfnConnectA != NULL) || (m_lpfnConnectW != NULL)) &&
				(m_lpfnCheck != NULL) && 
				(m_lpfnDisconnect != NULL) );

    return fValid;
}


/*++

BOOL IsCardInserted:

    This routine determines if a card is inserted into this object's reader.

Arguments:

    None

Return Value:

    TRUE if card inserted. FALSE otherwise.

Author:

    Chris Dudley 3/3/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
BOOL CSCardReaderState::IsCardInserted ( void )
{
    // Locals
    BOOL    fReturn = FALSE;

    if (!IsStateValid())
        return fReturn;

    // Check for card in appropriate struct
    fReturn = (m_ReaderState.dwEventState & SCARD_STATE_PRESENT);

    return fReturn;
}


/*++

BOOL IsStateValid:

    This routine determines if the information in the object is in a valid/usable
    state.

Arguments:

    None

Return Value:

    TRUE if state information is valid. FALSE otherwise.

Author:

    Chris Dudley 3/3/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
BOOL CSCardReaderState::IsStateValid ( void )
{
    // Locals
    BOOL    fReturn = TRUE;

    fReturn = (IsContextValid()) && (NULL != m_ReaderState.szReader);

    return fReturn;
}


/*++

void SetContext:

    Sets the card context

Arguments:

    hContext - card context handle

Return Value:

    None.

Author:

    Chris Dudley 3/3/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
void CSCardReaderState::SetContext( SCARDCONTEXT hContext )
{
    // Locals

    // Store it
    m_hContext = hContext;
}


/*++

LONG SetReaderState:

    Sets the internal SCARD_READERSTATE structure for the reader.

Arguments:

    lpfnConnectA - pointer to user's connect callback function (ANSI).
    lpfnConnectW - pointer to user's conenct callback function (UNICODE).
    lpfnCheck - pointer to user's check callback function.
    lpfnDisconnect - pointer to user's disconnect callback function.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/5/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
// ANSI
LONG CSCardReaderState::SetReaderState( LPOCNCONNPROCA lpfnConnectA, // = NULL
                                        LPOCNCHKPROC lpfnCheck, // = NULL
                                        LPOCNDSCPROC lpfnDisconnect, // = NULL
                                        LPVOID lpUserData // = NULL
                                        )
{
    LONG lReturn = SCARD_S_SUCCESS;
    LPSTR szCardName = NULL;
    DWORD dwNumChar = SCARD_AUTOALLOCATE;

    try
	{
        // Check Param,etc.
        if (!IsContextValid() || !IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Get current status of this reader
        lReturn = SCardGetStatusChangeA(m_hContext,
                                        (DWORD)0,
                                        &m_ReaderState,
                                        (DWORD)1);
        if(SCARDFAILED(lReturn))
		{
            throw (lReturn);
		}

        // Check for inserted card and get card name
        if (IsCardInserted())
		{
            // Is the reader in a state where this is useful?
            if ((m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE) ||
                (m_ReaderState.dwEventState & SCARD_STATE_MUTE) )
			{
                m_sCardName = szCardName;
            }
            else
			{
                lReturn = SCardListCardsA(  m_hContext,
                                            (LPCBYTE)m_ReaderState.rgbAtr,
                                            NULL,
                                            (DWORD) 0,
                                            (LPSTR)&szCardName,
                                            &dwNumChar);
                if(SCARDFAILED(lReturn))
				{
                    throw (lReturn);
				}

                // Save the name of the card
                m_sCardName = szCardName;
            }
        }

        // Set the current state
		m_lpfnConnectW = NULL;

        m_ReaderState.dwCurrentState = m_ReaderState.dwEventState;
        m_lpfnConnectA = lpfnConnectA;
        m_lpfnCheck = lpfnCheck;
        m_lpfnDisconnect = lpfnDisconnect;
        m_lpUserData = lpUserData;
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("SetReaderState"),lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("SetReaderState"));
    }

    // Clean Up
    if (NULL != szCardName)
	{
        SCardFreeMemory(m_hContext, (LPVOID)szCardName);
	}

    return lReturn;
}


// UNICODE
LONG CSCardReaderState::SetReaderState( LPOCNCONNPROCW lpfnConnectW, // = NULL
                                        LPOCNCHKPROC lpfnCheck, // = NULL
                                        LPOCNDSCPROC lpfnDisconnect, // = NULL
                                        LPVOID lpUserData // = NULL
                                        )
{
    LONG lReturn = SCARD_S_SUCCESS;
    LPWSTR szCardName = NULL;
    DWORD dwNumChar = SCARD_AUTOALLOCATE;

    try
	{
        // Check Param
        if (!IsContextValid() || !IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Get current status of this reader
        lReturn = SCardGetStatusChange(m_hContext,
										(DWORD) 0,
										&m_ReaderState,
										(DWORD) 1);
        if(SCARDFAILED(lReturn))
		{
            throw (lReturn);
		}

        // Check for inserted card and get card name
        if(IsCardInserted())
		{
            // Is the reader in a state where this is useful?
            if ((m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE) ||
                (m_ReaderState.dwEventState & SCARD_STATE_MUTE))
			{
                m_sCardName = szCardName;
            }
            else
			{
                lReturn = SCardListCardsW(	m_hContext,
											(LPCBYTE)m_ReaderState.rgbAtr,
											NULL,
											(DWORD)0,
                                            (LPWSTR)&szCardName,
                                            &dwNumChar);
                if (SCARDFAILED(lReturn))
                    throw (lReturn);
                // Save the name of the card
                m_sCardName = szCardName;
            }
        }

        // Set the current state
		m_lpfnConnectA = NULL;
        m_ReaderState.dwCurrentState = m_ReaderState.dwEventState;
        m_lpfnConnectW = lpfnConnectW;
        m_lpfnCheck = lpfnCheck;
        m_lpfnDisconnect = lpfnDisconnect;
        m_lpUserData = lpUserData;
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("SetReaderState -- UNICODE"),lReturn);
    }

    catch(...)
	{
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("SetReaderState -- UNICODE"));
    }

    // Clean Up
    if (NULL != szCardName)
	{
        SCardFreeMemory(m_hContext, (LPVOID)szCardName);
	}

    return lReturn;
}


/*++

void StoreName:

    Stores a name for the reader associated with this object.

Arguments:

    szGroupName - Group name in ANSI or UNICODE

Return Value:

    None.

Author:

    Chris Dudley 3/3/1997

--*/
void CSCardReaderState::StoreName( LPCTSTR szReaderName )
{
    // Store it
    m_sReaderName = szReaderName;
    m_ReaderState.szReader = m_sReaderName;
}


/*++

LONG UserCheck:

    Attempts to check a card using the user callback routine.

Arguments:

    None.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::UserCheck( void )
{
    // Locals
    LONG        lReturn = SCARD_S_SUCCESS;

    try {
        // Check Params, etc.
        if (!IsContextValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardInserted())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardConnected())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCallbackValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );

        if (!m_fConnected) {
            lReturn = UserConnect( &m_hCard );
            if (FAILED(lReturn))
                throw (lReturn);
        };
        // Attempt to Check
        m_fChecked = m_lpfnCheck (  m_hContext,
                                    m_hCard,
                                    m_lpUserData);
    }

    catch (LONG err) {
        lReturn = err;
        TRACE_CATCH(_T("UserCheck"), err);
    }

    catch (...) {
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("UserCheck"));
    }

    return lReturn;
}


/*++

LONG UserConnect:

    Attempts to connect to the reader using a user callback function.

Arguments:

    pCard - pointer to a SCARDHANDLE

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::UserConnect(LPSCARDHANDLE pCard,
                                    CTextString *pszReaderName, //=NULL
                                    CTextString *pszCardName //=NULL
                                    )
{
    LONG lReturn = SCARD_S_SUCCESS;

    try
	{
        // Check Params, etc.
        if (!IsContextValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardInserted())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCallbackValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );

        // Clear handle
        (*pCard) = NULL;

        if (!m_fConnected)
		{
			if (NULL != m_lpfnConnectA)
			{
				m_hCard = m_lpfnConnectA(	m_hContext,
											(LPSTR)((LPCSTR)m_sReaderName),
											(LPSTR)((LPCSTR)m_sCardName),
											m_lpUserData);
				if ( m_hCard == NULL )
					throw ( (LONG) SCARD_F_INTERNAL_ERROR );
				// Return reader/card names
				if (pszReaderName != NULL)
					(*pszReaderName) = m_sReaderName;
				if (pszCardName != NULL)
					(*pszCardName) = m_sCardName;
			}
			else if (NULL != m_lpfnConnectW)
			{
				m_hCard = m_lpfnConnectW(	m_hContext,
											(LPWSTR)((LPCWSTR)m_sReaderName),
											(LPWSTR)((LPCWSTR)m_sCardName),
											m_lpUserData);
				if ( m_hCard == NULL )
					throw ( (LONG) SCARD_F_INTERNAL_ERROR );
				// Return reader/card names
				if (pszReaderName != NULL)
					(*pszReaderName) = (LPCWSTR)m_sReaderName;	// force the unicode version
				if (pszCardName != NULL)
					(*pszCardName) = (LPCWSTR)m_sCardName;	// force the unicode version
			}
			else
			{
				throw ( (LONG) SCARD_F_INTERNAL_ERROR ); // should never have gotten here!
			}
        }

        *pCard = m_hCard;
        m_fConnected = TRUE;
    }

    catch(LONG err)
	{
        lReturn = err;
        TRACE_CATCH(_T("UserConnect"), err);
    }
    catch(...)
	{
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("UserConnect"));
    }

    return lReturn;
}


/*++

LONG UserDisconnect:

    Attempts to disconnect a card using the user callback routine.

Arguments:

    None.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/16/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::UserDisconnect( void )
{
    // Locals
    LONG        lReturn = SCARD_S_SUCCESS;

    try {
        // Check Params, etc.
        if (!IsContextValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardInserted())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardConnected())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCallbackValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );

        if (m_fConnected)
		{
            // Attempt to Disconnect
            m_lpfnDisconnect (  m_hContext,
                                m_hCard,
                                m_lpUserData);
            // Clear handle
            m_hCard = NULL;
            m_fConnected = FALSE;
        };
    }

    catch (LONG err) {
        lReturn = err;
        TRACE_CATCH(_T("UserDisconnect"), err);
    }

    catch (...) {
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("UserDisconnect"));
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\inc\rdrstate.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

	RdrState

Abstract:

	This file contains the definition of the Smartcard Common 
	dialog CSCardReaderState class. This class encapsulates Smartcard 
	Reader information.
	
Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:
	
	Chris Dudley 5/13/1997
	Amanda Matlosz 1/30/98 unicode support, code cleanup

Notes:

--*/

#ifndef __RDRSTATE_H__
#define __RDRSTATE_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "cmnui.h"

/////////////////////////////////////////////////////////////////////////////
//
// CSCardReaderState Class - encapsulates reader state 
//
class CSCardReaderState
{
	// members
private:
	SCARDCONTEXT	m_hContext;			// Context handle w/Calais
	SCARDHANDLE		m_hCard;			// Handle to smartcard in Reader
	CTextString		m_sReaderName;		// Reader name
	CTextString		m_sCardName;		// Card name actually inserted into Reader
	BOOL			m_fCardInReader;	// Flag for card currently in reader
	BOOL			m_fCardLookup;		// Indicates card is being looked for.
	BOOL			m_fConnected;		// Flag connected to card in reader
	BOOL			m_fChecked;			// Flag that this card has been user verified
	SCARD_READERSTATE m_ReaderState;	// Handle to ANSI reader status
	LPOCNCONNPROCA	m_lpfnConnectA;		// User call back functions
	LPOCNCONNPROCW	m_lpfnConnectW;		// User call back functions
	LPOCNCHKPROC	m_lpfnCheck;
	LPOCNDSCPROC	m_lpfnDisconnect;
	LPVOID			m_lpUserData;

	// RFU AS INDICATED!!!
	BOOL			m_fUpdated;			// RFU!!! Flag for change in name, group, etc.
	CTextMultistring	m_sGroupName;	// RFU!!! Groups this reader belongs to.

public:

	// Construction/Destruction
public:
	CSCardReaderState()
	{
		::ZeroMemory(	(LPVOID)&m_ReaderState, 
						(DWORD)sizeof(SCARD_READERSTATE) );

		m_hContext = NULL;
		m_hCard = NULL;
		m_fCardInReader = FALSE;
		m_fCardLookup = FALSE;
		m_fChecked = FALSE;
		m_fConnected = FALSE;
		m_fUpdated = FALSE;
		m_lpfnConnectA = NULL;		// User call back functions
		m_lpfnConnectW = NULL;
		m_lpfnCheck = NULL;
		m_lpfnDisconnect = NULL;
		m_lpUserData = NULL;
	}
				
	~CSCardReaderState()
	{	
		m_sReaderName.Clear();
		m_sCardName.Clear();
	}

	// Implementation
private:

public:
	// initialization
	void SetContext(SCARDCONTEXT hContext);
	void StoreName(LPCTSTR szReaderName);
	LONG SetReaderState(LPOCNCONNPROCA lpfnConnectA = NULL,
						LPOCNCHKPROC lpfnCheck = NULL,
						LPOCNDSCPROC lpfnDisconnect = NULL,
						LPVOID lpUserData = NULL);
	LONG SetReaderState(LPOCNCONNPROCW lpfnConnectW = NULL,
						LPOCNCHKPROC lpfnCheck = NULL,
						LPOCNDSCPROC lpfnDisconnect = NULL,
						LPVOID lpUserData = NULL);

	// attributes
	LONG GetReaderInfo(LPSCARD_READERINFO pReaderInfo);
	LONG GetReaderState(LPSCARD_READERSTATE pReaderState);
	BOOL IsCallbackValid(void);
	BOOL IsCardConnected() { return (m_fConnected); }
	BOOL IsCardInserted(void);
	BOOL IsContextValid() { return (NULL != m_hContext); }
	BOOL IsStateValid(void);

	// methods
	LONG CheckCard(LPCTSTR szCardName);
	LONG Connect(	SCARDHANDLE *pHandle, 
					DWORD dwShareMode, 
					DWORD dwProtocols,
					DWORD* pdwActiveProtocols,
					CTextString* pszReaderName = NULL,
					CTextString* pszCardName = NULL);
	LONG UserCheck(void);
	LONG UserConnect(	LPSCARDHANDLE pCard,
						CTextString* pszReaderName = NULL,
						CTextString* pszCardName = NULL);
	LONG UserDisconnect(void);
	LONG GetReaderCardInfo(	CTextString* pszReaderName = NULL,
							CTextString* pszCardName = NULL);

};

/////////////////////////////////////////////////////////////////////////////

#endif // __RDRSTATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

SCSTFILES=scstmsg.h scstmsg.rc msg00001.bin

SCSTMSG: $(SCSTFILES)

res\scstatus.rc2: $(SCSTFILES)

$(SCSTFILES): scstmsg.mc
    mc scstmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\miscdef.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MiscDef.h

Abstract:

	This file contains miscellanious definitions, including the debug trace macros
	written by Chris Dudley
	
Author:

    Amanda Matlosz 12/15/97

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

  intended only for use in the scstatus project

--*/

#ifndef __MISC_H__
#define __MISC_H__

#ifdef _DEBUG
	#define TRACE_STR(name,sz) \
				TRACE(_T("SCStatus.EXE: %s: %s\n"), name, sz)
	#define TRACE_CODE(name,code) \
				TRACE(_T("SCStatus.EXE: %s: error = 0x%x\n"), name, code)
	#define TRACE_CATCH(name,code)		TRACE_CODE(name,code)
	#define TRACE_CATCH_UNKNOWN(name)	TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
	#define TRACE_STR(name,sz)			((void)0)
	#define TRACE_CODE(name,code)		((void)0)
	#define TRACE_CATCH(name,code)		((void)0)
	#define TRACE_CATCH_UNKNOWN(name)	((void)0)
#endif  // _DEBUG


#endif  // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\inc\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\notfywin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       notfywin.cpp
//
//--------------------------------------------------------------------------

// NotfyWin.cpp : implementation file
//

#include "stdafx.h"
#include <winsvc.h> // PnP awareness
#include <dbt.h>    //      " "
#include <mmsystem.h>
#include <scEvents.h>

#include "notfywin.h"
#include "SCAlert.h"
#include "miscdef.h"
#include "cmnstat.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin Window
//


BEGIN_MESSAGE_MAP(CNotifyWin, CWnd)
	//{{AFX_MSG_MAP(CNotifyWin)
	ON_MESSAGE( WM_DEVICECHANGE, OnDeviceChange )
	ON_MESSAGE( WM_SCARD_NOTIFY, OnSCardNotify )
	ON_MESSAGE( WM_SCARD_STATUS_DLG_EXITED, OnSCardStatusDlgExit )
	ON_MESSAGE( WM_SCARD_RESMGR_EXIT, OnResMgrExit )
	ON_MESSAGE( WM_SCARD_RESMGR_STATUS, OnResMgrStatus )
	ON_MESSAGE( WM_SCARD_NEWREADER, OnNewReader )
	ON_MESSAGE( WM_SCARD_NEWREADER_EXIT, OnNewReaderExit )
	ON_MESSAGE( WM_SCARD_CARDSTATUS, OnCardStatus )
	ON_MESSAGE( WM_SCARD_CARDSTATUS_EXIT, OnCardStatusExit )
	ON_MESSAGE( WM_SCARD_REMOPT_CHNG, OnRemovalOptionsChange )
	ON_MESSAGE( WM_SCARD_REMOPT_EXIT, OnRemovalOptionsExit )
	ON_COMMAND( IDM_CLOSE, OnContextClose )
	ON_COMMAND( IDM_STATUS, OnContextStatus)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin Class
//


/*++

FinalConstruct:

    This method implements the constructor for this window

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
BOOL CNotifyWin::FinalConstruct(void)
{
    BOOL fResult = FALSE;

    // Initialize
    m_fCalaisUp = FALSE;

    // Register a new class for this window
    m_sClassName = AfxRegisterWndClass(CS_NOCLOSE);

    // Load the context menu resource
    fResult = m_ContextMenu.LoadMenu((UINT)IDR_STATUS_MENU);

    return fResult;
}


/*++

FinalRelease:

    This method implements the final destructor for this window

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CNotifyWin::FinalRelease( void )
{
    //
    // Clean up anything init'd in the FinalContruct(or)
    //

    m_ContextMenu.DestroyMenu();
}


/////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin message handlers
//


/*++

void OnCreate:

    Called after windows is created but before it is shown. Used here
    to set task bar icon.

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
int CNotifyWin::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    BOOL fReturn = TRUE;
    int nReturn = 0;
    CString strStatusText;

    try
    {
        if (CWnd::OnCreate(lpCreateStruct) == -1)
            throw (int)-1;

        // Set the menu
        if (!SetMenu(&m_ContextMenu))
        {
            throw (long)GetLastError();
        }

        // Set the task bar icon
        m_pApp = (CSCStatusApp*)AfxGetApp();
        ASSERT(NULL != m_pApp);

        // Setup notify struct
        ZeroMemory((PVOID)&m_nidIconData, sizeof(NOTIFYICONDATA));
        m_nidIconData.cbSize = sizeof(NOTIFYICONDATA);
        m_nidIconData.hWnd = m_hWnd;
        m_nidIconData.uID = 1;  // this is our #1 (only) icon
        m_nidIconData.uFlags = 0
            |   NIF_ICON    // The hIcon member is valid
            |   NIF_MESSAGE // The uCallbackMessage message is valid
            |   NIF_TIP;    // The szTip member is valid
        m_nidIconData.uCallbackMessage = WM_SCARD_NOTIFY;
        m_nidIconData.hIcon = m_pApp->m_hIconCard; // this will be set later
        strStatusText.LoadString(IDS_SYSTEM_UP);
        lstrcpy(m_nidIconData.szTip, strStatusText);

        if (!Shell_NotifyIcon(NIM_ADD, &m_nidIconData))
        {
            _ASSERTE(FALSE);    // Why can't we modify the taskbar icon???
        }

        // Determine Smart Card service status (sets task bar icon & threads)
        CheckSystemStatus(TRUE);

    }
    catch(long lErr)
    {
        nReturn = 0;
        TRACE_CATCH_UNKNOWN(_T("OnCreate"));
    }
    catch(int nErr)
    {
        nReturn = nErr;
        TRACE_CATCH_UNKNOWN(_T("OnCreate"));
    }

    return nReturn;
}


/*++

void OnContextClose:

    This message handler is when the popup menu's Close is called

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CNotifyWin::OnContextClose( void )
{
    //
    // Remove task bar notification area icon first
    //

    if (!Shell_NotifyIcon(NIM_DELETE, &m_nidIconData))
    {
        _ASSERTE(FALSE); // the icon will be cleaned up when app exits, anyway
    }

    //
    // Note that we're shutting down, so CheckSystemStatus will do no work.
    //
    m_fShutDown = TRUE;

    //
    // Shut down threads one at a time
    //
    m_ThreadLock.Lock();

    if (NULL != m_lpStatusDlgThrd)
    {
        m_lpStatusDlgThrd->Close();
        DWORD dwRet = WaitForSingleObject(m_lpStatusDlgThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpStatusDlgThrd;
        m_lpStatusDlgThrd = NULL;
    }

    if (NULL != m_lpCardStatusThrd)
    {
        m_lpCardStatusThrd->Close();
        DWORD dwRet = WaitForSingleObject(m_lpCardStatusThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpCardStatusThrd;
        m_lpCardStatusThrd = NULL;
    }

	if (NULL != m_lpNewReaderThrd)
	{
		// signal m_lpNewReaderThrd to close
		SetEvent(m_hKillNewReaderThrd);
		DWORD dwRet = WaitForSingleObject(m_lpNewReaderThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpNewReaderThrd;
		m_lpNewReaderThrd = NULL;
		CloseHandle(m_hKillNewReaderThrd);
		m_hKillNewReaderThrd = NULL;
	}

	if (NULL != m_lpRemOptThrd)
	{
		// signal m_lpRemOptThrd to close
		SetEvent(m_hKillRemOptThrd);
		DWORD dwRet = WaitForSingleObject(m_lpRemOptThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpRemOptThrd;
		m_lpRemOptThrd = NULL;
		CloseHandle(m_hKillRemOptThrd);
		m_hKillRemOptThrd = NULL;
	}

	if (NULL != m_lpResMgrStsThrd)
	{
		// signal m_lpNewReaderThrd to close
		SetEvent(m_hKillResMgrStatusThrd);
		DWORD dwRet = WaitForSingleObject(m_lpResMgrStsThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpResMgrStsThrd;
		m_lpResMgrStsThrd = NULL;
		CloseHandle(m_hKillResMgrStatusThrd);
		m_hKillResMgrStatusThrd = NULL;
	}

    m_ThreadLock.Unlock();

    // Post the quit message for this thread
    ::PostQuitMessage(0);
}


/*++

void OnContextStatus:

    This message handler is when the popup menu's Status is called.
    Thie displays the dialog.

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CNotifyWin::OnContextStatus( void )
{
    if (!m_fCalaisUp)
    {
        // The user should not have been able to request "Status"
        // when the system is down.  Toss up an error...

        AfxMessageBox(IDS_NO_SYSTEM_STATUS);
        return;
    }

    //
    // Start a thread for the status dialog if needed
    //

    m_ThreadLock.Lock();

    if (NULL != m_lpCardStatusThrd)
    {
        m_lpCardStatusThrd->CopyIdleList(&m_aIdleList);
    }

    if (m_lpStatusDlgThrd == NULL)
    {
        m_lpStatusDlgThrd = (CSCStatusDlgThrd*)AfxBeginThread(
                                    RUNTIME_CLASS(CSCStatusDlgThrd),
                                    THREAD_PRIORITY_NORMAL,
                                    0,
                                    CREATE_SUSPENDED);

        if (NULL != m_lpStatusDlgThrd)
        {
            m_lpStatusDlgThrd->m_hCallbackWnd = m_hWnd;
            m_lpStatusDlgThrd->ResumeThread();
            m_lpStatusDlgThrd->UpdateStatus(&m_aIdleList);
        }
    }
    else
    {
        // ShowDialog should start the dialog if it's not currently open...
        m_lpStatusDlgThrd->ShowDialog(SW_SHOWNORMAL, &m_aIdleList);
    }

    m_ThreadLock.Unlock();
}


/*++

void OnSCardNotify:

    This message handler is called when action is taken on the task bar icon.

Arguments:

    wParam - wparam of message
    lParam - lparam of message.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
LONG CNotifyWin::OnSCardNotify( UINT wParam, LONG lParam)
{
    // Locals
    BOOL fResult = FALSE;
    CMenu *pMenu = NULL;
    POINT point;

    try
    {
        // Switch on mouse button notification types.
        switch ((UINT) lParam)
        {
        case WM_LBUTTONUP:
            // same thing as if user selected context menu:Status
            OnContextStatus();
            break;

        case WM_RBUTTONUP:

            //
            // Display context menu where user clicked
            //

            // Set the foregrouond window to fix menu track problem.
            SetForegroundWindow();

            fResult = GetCursorPos(&point);

            if (fResult)
            {
                // Display the pop-up menu
                pMenu = m_ContextMenu.GetSubMenu(0);
                ASSERT(NULL != pMenu);

                if (NULL != pMenu)
                {
                    fResult = pMenu->TrackPopupMenu(    TPM_RIGHTALIGN |
                                                        TPM_BOTTOMALIGN |
                                                        TPM_LEFTBUTTON |
                                                        TPM_RIGHTBUTTON,
                                                        point.x,
                                                        point.y,
                                                        this,
                                                        NULL);
                }
            }

            if (!fResult)
            {
                throw (fResult);
            }

            // Force a task switch by sending message to fix menu track problem
            PostMessage(WM_NULL);
            break;

        default:
            break;
        }
    }
    catch(LONG err)
    {
        TRACE_CATCH(_T("OnSCardNotify"),err);
    }
    catch(...)
    {
        TRACE_CATCH_UNKNOWN(_T("OnSCardNotify"));
    }

    return 0;
}


/*++

void OnSCardStatusDlgExit:

    This message handler is called when the status dialog is closed.

Arguments:

    wParam - wparam of message
    lParam - lparam of message.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
LONG CNotifyWin::OnSCardStatusDlgExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // Clear for creation of another dialog
    if (NULL != m_lpStatusDlgThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpStatusDlgThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpStatusDlgThrd;
        m_lpStatusDlgThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // Did the resource manager go down?
    CheckSystemStatus();

    return 0;
}


/*++

void OnResMgrExit:

    This message handler signals "resmgr thread gone" & calls CheckSystemStatus

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnResMgrExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // close the killthread event handle
    if (NULL != m_hKillResMgrStatusThrd)
    {
        CloseHandle(m_hKillResMgrStatusThrd);
        m_hKillResMgrStatusThrd = NULL;
    }

    // delete the old (dead) thread
    if (NULL != m_lpResMgrStsThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpResMgrStsThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpResMgrStsThrd;
        m_lpResMgrStsThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // What is the status of the RM now?
    CheckSystemStatus();
    return 0;
}


/*++

void OnNewReaderExit:

    This message handler signals "resmgr thread gone" & calls CheckSystemStatus

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnNewReaderExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // close the killthread event handle
    if (NULL != m_hKillNewReaderThrd)
    {
        CloseHandle(m_hKillNewReaderThrd);
        m_hKillNewReaderThrd = NULL;
    }

    // delete the old (dead) thread
    if (NULL != m_lpNewReaderThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpNewReaderThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpNewReaderThrd;
        m_lpNewReaderThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // What is the status of the RM now?
    CheckSystemStatus();
    return 0;
}


/*++

void OnCardStatusExit:

    This message handler signals "cardstatus thread gone" & calls CheckSystemStatus

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnCardStatusExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // Clear for creation of another CardStatusThrd
    if (NULL != m_lpCardStatusThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpCardStatusThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpCardStatusThrd;
        m_lpCardStatusThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // What is the status of the RM now?
    CheckSystemStatus();
    return 0;
}


/*++

void OnResMgrStatus:

    This message handler catches RM system status updates from the
    ResMGrThread, and calls SetSystemStatus accordingly

Arguments:

    ui - WPARAM (BOOL - true if calais is running)
    l - not used.

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnResMgrStatus( UINT ui, LONG l)
{
    // Is the resource manager back?
    BOOL fCalaisUp = (ui != 0);
    SetSystemStatus(fCalaisUp);

    return 0;
}


/*++

void OnNewReader:

    This message handler tells the two threads that use reader lists to
    update those lists.

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnNewReader( UINT, LONG )
{
    m_ThreadLock.Lock();

    if (NULL != m_lpStatusDlgThrd)
    {
        m_lpStatusDlgThrd->Update();
    }

    m_ThreadLock.Unlock();

    return 0;
}



/*++

void OnCardStatus:

    This message handler tells the two threads that use reader lists to
    update those lists.

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnCardStatus( UINT uStatus, LONG )
{
    bool fNotify = false;

    //
    // Need to notify user at end of OnCardStatus if a new card has gone IDLE
    //

    if (k_State_CardIdle == uStatus)
    {
        if (k_State_CardIdle != m_pApp->m_dwState)
        {
            fNotify = true;
        }
        else
        {
            CStringArray astrTemp;
            m_ThreadLock.Lock();
            {
                if (NULL != m_lpCardStatusThrd)
                {
                    m_lpCardStatusThrd->CopyIdleList(&astrTemp);
                }
            }
            m_ThreadLock.Unlock();

            // compare new list of idle cards w/ current list
            for (int n1=(int)astrTemp.GetUpperBound(); n1>=0; n1--)
            {
                for (int n2=(int)m_aIdleList.GetUpperBound(); n2>=0; n2--)
                {
                    if (m_aIdleList[n2] == astrTemp[n1]) break;
                }
                if (n2<0) // a match was not found!
                {
                    fNotify = true;
                }
            }
        }
    }

    //
    // At least, update the status dialog with the new idle list
    //

    m_ThreadLock.Lock();
    {
        if (NULL != m_lpCardStatusThrd)
        {
            m_lpCardStatusThrd->CopyIdleList(&m_aIdleList);

            if (NULL != m_lpStatusDlgThrd)
            {
                m_lpStatusDlgThrd->UpdateStatus(&m_aIdleList);
            }
        }
    }
    m_ThreadLock.Unlock();

    //
    // Set the new status
    //

    SetSystemStatus(true, false, (DWORD)uStatus);

    //
    // If there is a newly idle card, notify user according to alert options
    //

    if(fNotify)
    {
        switch(m_pApp->m_dwAlertOption)
        {
        case k_AlertOption_IconOnly:
            // Do nothing
            break;
        case k_AlertOption_IconSound:
            // MessageBeep(MB_ICONINFORMATION);
            PlaySound( TEXT("SmartcardIdle"), NULL, SND_ASYNC | SND_ALIAS | SND_NODEFAULT );
            break;
        case k_AlertOption_IconSoundMsg:
            // MessageBeep(MB_ICONINFORMATION);
            PlaySound( TEXT("SmartcardIdle"), NULL, SND_ASYNC | SND_ALIAS | SND_NODEFAULT );
        case k_AlertOption_IconMsg:
            OnContextStatus(); // raise status dialog
            break;
        default:
            MessageBeep(MB_ICONQUESTION);
            break;
        }
    }

    return 0;
}



/*++

void OnRemovalOptionsChange:

    This message handler tells the status dialog to update its
	logon/lock reader designation
		
Arguments:

	Not Used
	
Return Value:
	
	None

Author:

    Amanda Matlosz	4/28/98

Note:

--*/
LONG CNotifyWin::OnRemovalOptionsChange( UINT, LONG )
{
	ASSERT(NULL != m_pApp);

	//
	// Need to update RemovalOptions
	//

	m_pApp->SetRemovalOptions();

	//
	// Tell stat dialog to update status if neccessary
	//
	m_ThreadLock.Lock();
	{
		if (NULL != m_lpCardStatusThrd)
		{
			m_lpCardStatusThrd->CopyIdleList(&m_aIdleList);

			if (NULL != m_lpStatusDlgThrd)
			{
				m_lpStatusDlgThrd->UpdateStatus(&m_aIdleList);
			}
		}
	}
	m_ThreadLock.Unlock();

    return 0;
}


/*++

void OnRemovalOptionsExit:

    This message handler signals "remoptions thread gone" & calls CheckSystemStatus
		
Arguments:

	Not Used
	
Return Value:
	
	None

Author:

    Amanda Matlosz	4/28/98

Note:

--*/
LONG CNotifyWin::OnRemovalOptionsExit( UINT, LONG )
{
	m_ThreadLock.Lock();

	// close the killthread event handle
	if (NULL != m_hKillRemOptThrd)
	{
		CloseHandle(m_hKillRemOptThrd);
		m_hKillRemOptThrd = NULL;
	}

	// delete the old (dead) thread
	if (NULL != m_lpRemOptThrd)
	{
		DWORD dwRet = WaitForSingleObject(m_lpRemOptThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpRemOptThrd;
		m_lpRemOptThrd = NULL;
	}

	m_ThreadLock.Unlock();

	// What is the status of the RM now?
	CheckSystemStatus();
	return 0;
}



/*++

void SetSystemStatus:

    This is called to set UI & behavior according to RM status.

Arguments:

    fCalaisUp -- TRUE if the RM is running

Return Value:

    None

Author:

    Amanda Matlosz  5/28/98

Note:

--*/
void CNotifyWin::SetSystemStatus(BOOL fCalaisUp, BOOL fForceUpdate, DWORD dwState)
{
    ASSERT(NULL != m_pApp);

    //
    // Update UI & behavior & threads only if there has actually been a change
    //

    if (!fForceUpdate && fCalaisUp == m_fCalaisUp && m_pApp->m_dwState == dwState)
    {
        return;
    }

    m_fCalaisUp = fCalaisUp;
    if (dwState != k_State_Unknown)
    {
        m_pApp->m_dwState = dwState;
    }

    //
    // Set appearance of taskbar icon
    //

    CString strStatusText;

    if (!m_fCalaisUp)
    {
        // Get new icon & tooltip for taskbar
        strStatusText.LoadString(IDS_SYSTEM_DOWN);
        m_nidIconData.hIcon = m_pApp->m_hIconCalaisDown;

        // disable "Status" Context menuitem
        m_ContextMenu.EnableMenuItem(IDM_STATUS, MF_DISABLED | MF_GRAYED);
        m_pApp->m_dwState = k_State_Unknown;
    }
    else
    {
        // Get new icon & tooltip for taskbar
        strStatusText.LoadString(IDS_SYSTEM_UP);

        switch(m_pApp->m_dwState)
        {
        case k_State_CardAvailable:
            m_nidIconData.hIcon = m_pApp->m_hIconCard;
            break;
        case k_State_CardIdle:
            m_nidIconData.hIcon = m_pApp->m_hIconCardInfo;
            break;
        default:
        case k_State_NoCard:
            m_nidIconData.hIcon = m_pApp->m_hIconRdrEmpty;
            break;
        }

        // enable "Status" Context menuitem
        m_ContextMenu.EnableMenuItem(IDM_STATUS, MF_ENABLED);
    }

    lstrcpy(m_nidIconData.szTip, strStatusText);
    if (!Shell_NotifyIcon(NIM_MODIFY, &m_nidIconData))
    {
        _ASSERTE(FALSE);    // Why can't we modify the taskbar icon???
                            // Ultimately, though, we don't care about this error.
    }

    //
    // Start or stop threads as appropriate
    //

    m_ThreadLock.Lock();

	// the RemoveOptionsChange thread should always be running
	if (NULL == m_lpRemOptThrd)
	{
		// reset the KillThread event if possible; if not, recreate it.
		if (NULL != m_hKillRemOptThrd)
		{
			// reset event to non-signalled
			if (!ResetEvent(m_hKillRemOptThrd))
			{
				CloseHandle(m_hKillRemOptThrd);
				m_hKillRemOptThrd = NULL;
			}
		}

		if (NULL == m_hKillRemOptThrd)
		{
			m_hKillRemOptThrd = CreateEvent(
				NULL,
				TRUE,  // must call ResetEvent() to set non-signaled
				FALSE, // not signaled when it starts
				NULL);
		}

		m_lpRemOptThrd = (CRemovalOptionsThrd*)AfxBeginThread(
									RUNTIME_CLASS(CRemovalOptionsThrd),
									THREAD_PRIORITY_NORMAL,
									0,
									CREATE_SUSPENDED);

		if (NULL != m_lpRemOptThrd)
		{
			m_lpRemOptThrd->m_hCallbackWnd = m_hWnd;
			m_lpRemOptThrd->m_hKillThrd = m_hKillRemOptThrd;
			m_lpRemOptThrd->ResumeThread();
		}
	}

	if (!m_fCalaisUp)
	{
		if (NULL != m_lpNewReaderThrd)
		{
			// signal m_lpNewReaderThrd to close
			SetEvent(m_hKillNewReaderThrd);
			DWORD dwRet = WaitForSingleObject(m_lpNewReaderThrd->m_hThread, INFINITE);
			_ASSERTE(WAIT_OBJECT_0 == dwRet);
			delete m_lpNewReaderThrd;
			m_lpNewReaderThrd = NULL;
			CloseHandle(m_hKillNewReaderThrd);
			m_hKillNewReaderThrd = NULL;
		}

        if (NULL != m_lpCardStatusThrd)
        {
            // close down m_lpCardStatusThrd
            m_lpCardStatusThrd->Close();
            DWORD dwRet = WaitForSingleObject(m_lpCardStatusThrd->m_hThread, INFINITE);
            _ASSERTE(WAIT_OBJECT_0 == dwRet);
            delete m_lpCardStatusThrd;
            m_lpCardStatusThrd = NULL;
        }

        // Start ResMgrSts to poll/wait for RM startup
        if (NULL == m_lpResMgrStsThrd)
        {
            // reset the KillThread event if possible; if not, recreate it.
            if (NULL != m_hKillResMgrStatusThrd)
            {
                // reset event to non-signalled
                if (!ResetEvent(m_hKillResMgrStatusThrd))
                {
                    CloseHandle(m_hKillResMgrStatusThrd);
                    m_hKillResMgrStatusThrd = NULL;
                }
            }

            if (NULL == m_hKillResMgrStatusThrd)
            {
                m_hKillResMgrStatusThrd = CreateEvent(
                    NULL,
                    TRUE,  // must call ResetEvent() to set non-signaled
                    FALSE, // not signaled when it starts
                    NULL);
            }

            m_lpResMgrStsThrd = (CResMgrStatusThrd*)AfxBeginThread(
                                        RUNTIME_CLASS(CResMgrStatusThrd),
                                        THREAD_PRIORITY_NORMAL,
                                        0,
                                        CREATE_SUSPENDED);

            if (NULL != m_lpResMgrStsThrd)
            {
                m_lpResMgrStsThrd->m_hCallbackWnd = m_hWnd;
                m_lpResMgrStsThrd->m_hKillThrd = m_hKillResMgrStatusThrd;
                m_lpResMgrStsThrd->ResumeThread();
            }
        }

    }
    else
    {
        // shut down res mgr status thread
        if (NULL != m_lpResMgrStsThrd)
        {
            // signal m_lpResMgrStsThrd to close
            SetEvent(m_hKillResMgrStatusThrd);
            DWORD dwRet = WaitForSingleObject(m_lpResMgrStsThrd->m_hThread, INFINITE);
            _ASSERTE(WAIT_OBJECT_0 == dwRet);
            delete m_lpResMgrStsThrd;
            m_lpResMgrStsThrd = NULL;
            CloseHandle(m_hKillResMgrStatusThrd);
            m_hKillResMgrStatusThrd = NULL;
        }

        // start newreader thread
        if (NULL == m_lpNewReaderThrd)
        {
            // reset the KillThread event if possible; if not, recreate it.
            if (NULL != m_hKillNewReaderThrd)
            {
                // reset event to non-signalled
                if (!ResetEvent(m_hKillNewReaderThrd))
                {
                    CloseHandle(m_hKillNewReaderThrd);
                    m_hKillNewReaderThrd = NULL;
                }
            }

            if (NULL == m_hKillNewReaderThrd)
            {
                m_hKillNewReaderThrd = CreateEvent(
                    NULL,
                    TRUE,  // must call ResetEvent() to set non-signaled
                    FALSE, // not signaled when it starts
                    NULL);
            }

            if (NULL != m_hKillNewReaderThrd)
            {
                m_lpNewReaderThrd = (CNewReaderThrd*)AfxBeginThread(
                                        RUNTIME_CLASS(CNewReaderThrd),
                                        THREAD_PRIORITY_NORMAL,
                                        0,
                                        CREATE_SUSPENDED);
            }

            if (NULL != m_lpNewReaderThrd)
            {
                m_lpNewReaderThrd->m_hCallbackWnd = m_hWnd;
                m_lpNewReaderThrd->m_hKillThrd = m_hKillNewReaderThrd;
                m_lpNewReaderThrd->ResumeThread();
            }
        }

        // start CardStatus thread
        if (NULL == m_lpCardStatusThrd)
        {
            m_lpCardStatusThrd = (CCardStatusThrd*)AfxBeginThread(
                                        RUNTIME_CLASS(CCardStatusThrd),
                                        THREAD_PRIORITY_NORMAL,
                                        0,
                                        CREATE_SUSPENDED);

			if (NULL != m_lpCardStatusThrd)
			{
				m_lpCardStatusThrd->m_hCallbackWnd = m_hWnd;
				m_lpCardStatusThrd->m_paIdleList = &m_aIdleList;
				m_lpCardStatusThrd->m_pstrLogonReader = &(((CSCStatusApp*)AfxGetApp())->m_strLogonReader);
				m_lpCardStatusThrd->ResumeThread();
			}
		}
		else // better be NULL!
		{
			_ASSERTE(FALSE);
		}

        // StatDlg may need to be updated
        if (NULL != m_lpStatusDlgThrd)
        {
            m_lpStatusDlgThrd->Update();
        }

    }

    m_ThreadLock.Unlock();

}


/*++

void CheckSystemStatus:

    This is called as a result of a thread exiting.  Check to see whether the
    MS Smart Card Resource Manager (Calais) is running or not, and set
    UI & behavior accordingly.

Arguments:

    None

Return Value:

    None

Author:

    Amanda Matlosz  3/18/98

Note:

--*/
void CNotifyWin::CheckSystemStatus(BOOL fForceUpdate)
{
    //
    // We only care about this status if we're
    // NOT in the middle of shutting down
    //

    if (m_fShutDown)
    {
        return;
    }

    //
    // Query the service manager for the RM's status
    //

    DWORD dwReturn = ERROR_SUCCESS;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    SERVICE_STATUS ssStatus;    // current status of the service
    ZeroMemory((PVOID)&ssStatus, sizeof(ssStatus));

    schSCManager = OpenSCManager(
                        NULL,                 // machine (NULL == local)
                        NULL,                 // database (NULL == default)
                        SC_MANAGER_CONNECT);  // access required
    if (NULL == schSCManager)
    {
        dwReturn = (DWORD)GetLastError();
    }

    if (ERROR_SUCCESS == dwReturn)
    {
        schService = OpenService(
                            schSCManager,
                            TEXT("SCardSvr"),
                            SERVICE_QUERY_STATUS);
        if (NULL == schService)
        {
            dwReturn = (DWORD)GetLastError();
        }
        else if (!QueryServiceStatus(schService, &ssStatus))
        {
            dwReturn = (DWORD)GetLastError();
        }
    }

    // if the service is running, say it's up
    // if the service is stopped, paused, or pending action,
    // say it's down.  NOTE: may want to consider graying out
    // the taskbar icon to indicate paused, or some other err.
    if (ERROR_SUCCESS == dwReturn)
    {
        if (SERVICE_RUNNING == ssStatus.dwCurrentState)
        {
            dwReturn = SCARD_S_SUCCESS;
        }
        else
        {
            dwReturn = SCARD_E_NO_SERVICE;
        }
    }

    if (NULL != schService)
    {
        CloseServiceHandle(schService);
        schService = NULL;
    }
    if (NULL != schSCManager)
    {
        CloseServiceHandle(schSCManager);
        schSCManager = NULL;
    }
    CalaisReleaseStartedEvent();

    //
    // Change state, log event as necessary,
    // and kick off appropriate threads
    //

    SetSystemStatus((SCARD_S_SUCCESS == dwReturn), fForceUpdate);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\inc\senv.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SEnv

Abstract:

    This file contains the definition of the Smartcard Common
    dialog CSCardEnv class. This class encapsulates Smartcard
    Environment information.

Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    Amanda Matlosz 1/29/98  Changed class structure; added Unicode support

Notes:

--*/

#ifndef __SENV_H__
#define __SENV_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "cmnui.h"
#include "rdrstate.h"

/////////////////////////////////////////////////////////////////////////////
//
// CSCardEnv Class - encapsulates current smartcard environment regarding
//                   groups of readers and associated cards/status
//
class CSCardEnv
{

    // Construction/Destruction

public:
    CSCardEnv()
    {
            m_pOCNA = NULL;
            m_pOCNW = NULL;
            m_dwReaderIndex = 0;
            m_hContext = NULL;
    }
    ~CSCardEnv()
    {
        // Release any attached readers
        RemoveReaders();
    }

    // Implementation

public:
    // Initialization / completion routines
    LONG SetOCN(LPOPENCARDNAMEA pOCNA);
    LONG SetOCN(LPOPENCARDNAMEW pOCNW);
    LONG UpdateOCN();

    void SetContext( SCARDCONTEXT hContext );

    // Attributes / properties
    SCARDCONTEXT GetContext() { return m_hContext; }
    void GetCardList(LPCTSTR* pszCardList);
    void GetDialogTitle(CTextString *pstzTitle);
    HWND GetParentHwnd() { return (m_hwndOwner); }
    BOOL IsOCNValid() { return (NULL != m_pOCNA || NULL != m_pOCNW); }
    BOOL IsCallbackValid( void );
    BOOL IsContextValid() { return (m_hContext != NULL); }
    BOOL IsArrayValid() { return (m_rgReaders.GetSize() > 0); }
    int NumberOfReaders() { return (int)m_rgReaders.GetSize(); }
	BOOL CardMeetsSearchCriteria(DWORD dwSelectedReader);

    // Reader array management
    LONG CreateReaderStateArray( LPSCARD_READERSTATE_A* prgReaderStateArray );  // TODO: ?? A/W ??
    void DeleteReaderStateArray( LPSCARD_READERSTATE_A* prgReaderStateArray );  // TODO: ?? A/W ??
    LONG FirstReader( LPSCARD_READERINFO pReaderInfo );
    LONG NextReader( LPSCARD_READERINFO pReaderInfo );
    void RemoveReaders( void );
    LONG UpdateReaders( void );

    // Methods
    LONG NoUISearch( BOOL* pfEnableUI );                        // try this search first...
    LONG Search( int* pcMatches, DWORD* pdwIndex );
    LONG ConnectToReader(DWORD dwSelectedReader);
    LONG ConnectInternal(   DWORD dwSelectedReader,
                            SCARDHANDLE *pHandle,
                            DWORD dwShareMode,
                            DWORD dwProtocols,
                            DWORD* pdwActiveProtocols,
                            CTextString* pszReaderName = NULL,
                            CTextString* pszCardName = NULL);
    LONG ConnectUser(   DWORD dwSelectedReader,
                        SCARDHANDLE *pHandle,
                        CTextString* pszReaderName = NULL,
                        CTextString* pszCardName = NULL);


private:
    LONG BuildReaderArray( LPSTR szReaderNames );   // TODO: ?? A/W ??
	void InitializeAllPossibleCardNames( void );


    // Members

private:

    // Reader information
    CTypedPtrArray<CPtrArray, CSCardReaderState*> m_rgReaders;
    DWORD m_dwReaderIndex;

    // external representation of OpenCardName structs are not touched unless
    // SCardEnv->UpdateOCN explicitly called.
    LPOPENCARDNAMEA     m_pOCNA;
    LPOPENCARDNAMEW     m_pOCNW;

    // internal representation of OpenCardName struct combines ansi/
    // unicode information from whichever kind of OCN user provided
    CTextMultistring     m_strGroupNames;
    CTextMultistring     m_strCardNames;
	CTextMultistring	 m_strAllPossibleCardNames;
    CTextString     m_strReader;
    CTextString     m_strCard;
    CTextString     m_strTitle;

    // only LPOCNCONNPROC needs to differentiate between A/W
    LPOCNCONNPROCA  m_lpfnConnectA;
    LPOCNCONNPROCW  m_lpfnConnectW;
    LPOCNCHKPROC    m_lpfnCheck;
    LPOCNDSCPROC    m_lpfnDisconnect;
    LPVOID          m_lpUserData;

    SCARDCONTEXT    m_hContext;
    HWND            m_hwndOwner;
    LPCGUID         m_rgguidInterfaces;
    DWORD           m_cguidInterfaces;
    DWORD           m_dwFlags;
    LPVOID          m_pvUserData;
    DWORD           m_dwShareMode;
    DWORD           m_dwPreferredProtocols;
    DWORD           m_dwActiveProtocol;
    SCARDHANDLE     m_hCardHandle;

};

///////////////////////////////////////////////////////////////////////////////////////

#endif //__SENV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\notfywin.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NotfyWin

Abstract:

	This file contains the definition of the CNotifyWind class.
	
Author:

    Chris Dudley 7/28/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	Amanda Matlosz	4/30/1998	-- threading redone, PnP awareness added,
									replaced CSCardEnv, et. al with CScStatusMonitor

	Amanda Matlosz	12/21/1998	-- removed certificate propagation code
	
Notes:

--*/

#ifndef __NOTFYWIN_H__
#define __NOTFYWIN_H__


/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "ScAlert.h"
#include "statdlg.h"
#include "ResMgrSt.h"

// forward decl
class CSCStatusApp;

/////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin dialog
//

class CNotifyWin :	public CWnd
{
	// Construction
public:
	CNotifyWin()
	{
		m_pApp = NULL;

		// state management
		m_fShutDown = FALSE;

		m_lpStatusDlgThrd = NULL;
		m_lpResMgrStsThrd = NULL;
		m_lpNewReaderThrd = NULL;
		m_lpCardStatusThrd = NULL;
		m_lpRemOptThrd = NULL;

		m_hKillNewReaderThrd = NULL;
		m_hKillResMgrStatusThrd = NULL;
		m_hKillRemOptThrd= NULL;

		// other mem.vars
		m_aIdleList.RemoveAll();
	}
	
	~CNotifyWin() { FinalRelease(); }

	BOOL FinalConstruct(void);		// Implements two phase construction
	void FinalRelease(void);


	// Implementation
protected:
	HICON m_hIcon;
	NOTIFYICONDATA m_nidIconData;
	CSCStatusApp* m_pApp;

	// Generated message map functions
	//{{AFX_MSG(CSCStatusDlg)
	afx_msg LONG OnSCardStatusDlgExit( UINT , LONG ); 
	afx_msg LONG OnCertPropThrdExit( UINT , LONG ); 
    afx_msg LONG OnSCardNotify( UINT , LONG );	// task bar notification
    afx_msg LONG OnResMgrExit( UINT , LONG );
	afx_msg LONG OnResMgrStatus( UINT ui, LONG l); // ui is the WPARAM
	afx_msg LONG OnNewReader( UINT , LONG );
	afx_msg LONG OnNewReaderExit( UINT , LONG );
	afx_msg LONG OnCardStatus( UINT uStatus, LONG );
	afx_msg LONG OnCardStatusExit( UINT , LONG );
	afx_msg LONG OnRemovalOptionsChange ( UINT, LONG );
	afx_msg LONG OnRemovalOptionsExit ( UINT, LONG );
	afx_msg void OnContextClose();
	afx_msg void OnContextStatus();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void CheckSystemStatus(BOOL fForceUpdate=FALSE);
	void SetSystemStatus(BOOL fCalaisUp, BOOL fForceUpdate=FALSE, DWORD dwState=k_State_Unknown);

	// members
protected: 
	CMenu			m_ContextMenu;		// Context/pop-up menu pointer

	// state management 
	BOOL			m_fCalaisUp;		// TRUE if Smart card stack is running
	DWORD			m_dwCardState;		// one of four: see cmnstat.h
	BOOL			m_fShutDown;		// for state checkin
	CStringArray	m_aIdleList;
	CCriticalSection	m_ThreadLock;

	// child threads to do the dirty work
	CSCStatusDlgThrd*	m_lpStatusDlgThrd;	// Pointer to the status dlg thread
	CResMgrStatusThrd*	m_lpResMgrStsThrd;	// Pointer to IsResMgrBackUpYet? thread
	CNewReaderThrd*		m_lpNewReaderThrd;	// Pointer to AreThereNewReaders? thread
	CCardStatusThrd*	m_lpCardStatusThrd;	// Pointer to the status dlg thread
	CRemovalOptionsThrd*	m_lpRemOptThrd;	// Pointer to the RemovalOptions change thread

	// kill-thread events
	HANDLE			m_hKillNewReaderThrd;
	HANDLE			m_hKillResMgrStatusThrd;
	HANDLE			m_hKillRemOptThrd;

public:
	CString		m_sClassName;				// The Window class name for this window
};


/////////////////////////////////////////////////////////////////////////////////////////

#endif // __NOTFYWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\cmnstat.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    comstat

Abstract:

	This file contains the definition of the common types, etc. used in
	the status application
	
Author:

    Chris Dudley 7/28/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

--*/

#ifndef __COMSTAT_H__
#define __COMSTAT_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//


////////////////////////////////////////////////////////////////////////////
//
// Constants
// 

// system state
static const DWORD k_State_Unknown = 0;
static const DWORD k_State_NoCard = 1;
static const DWORD k_State_CardAvailable = 2;
static const DWORD k_State_CardIdle = 3;

// alert options
static const UINT_PTR k_AlertOption_IconOnly = 0;
static const UINT_PTR k_AlertOption_IconSound = 1;
static const UINT_PTR k_AlertOption_IconSoundMsg = 2;
static const UINT_PTR k_AlertOption_IconMsg = 3;

// RegKeys
static const LPCTSTR szAlertOptionsKey = TEXT("Software\\Microsoft\\Cryptography\\Calais\\Smart Card Alert");
static const LPCTSTR szScRemoveOptionKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");

// messages

static const UINT WM_SCARD_NOTIFY = WM_USER + 1;
static const UINT WM_SCARD_STATUS_DLG_EXITED = WM_USER + 2;
static const UINT WM_SCARD_CERTPROP_EXITED = WM_USER + 3;
static const UINT WM_READERSTATUSCHANGE = WM_USER + 4;
static const UINT WM_SCARD_RESMGR_EXIT = WM_USER + 5;
static const UINT WM_SCARD_RESMGR_STATUS = WM_USER + 6;
static const UINT WM_SCARD_NEWREADER = WM_USER + 7;
static const UINT WM_SCARD_NEWREADER_EXIT = WM_USER + 8;
static const UINT WM_SCARD_CARDSTATUS = WM_USER + 9;
static const UINT WM_SCARD_CARDSTATUS_EXIT = WM_USER + 10;
static const UINT WM_SCARD_REMOPT_CHNG = WM_USER + 11;
static const UINT WM_SCARD_REMOPT_EXIT = WM_USER + 12;
////////////////////////////////////////////////////////////////////////////

#endif // __COMSTAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scalert.rc
//
#define IDS_SC_UNKNOWN_NO               1
#define IDS_SC_KNOWN_INCORRECT          2
#define IDS_SC_DEAD                     3
#define IDFINISH_NEXT                   3
#define IDS_SC_BUSY                     4
#define IDBACK                          4
#define IDS_SC_STATUS_NO_CARD           5
#define IDS_SC_STATUS_NOT_IN_USE        6
#define IDS_SC_STATUS_ERROR             7
#define IDS_SC_STATUS_IN_USE            8
#define IDS_SC_NAME_UNKNOWN             9
#define IDS_SC_CONNECT_FAILED           10
#define IDS_SC_STATUS_AVAILABLE         10
#define IDS_SC_SELECT                   11
#define IDS_SC_STATUS_UNKNOWN           11
#define IDS_SC_TITLE_ERROR              12
#define IDS_SC_STATUS_SHARED            12
#define IDS_SC_FOUND                    13
#define IDS_SC_REMOVAL_LOCK             13
#define IDS_SC_FOUND_BUSY               14
#define IDS_SC_REMOVAL_LOGOFF           14
#define IDD_SCSTATUS_DIALOG             102
#define IDS_PROPSHT_CAPTION             103
#define IDD_PROPPAGE1                   104
#define IDS_WELCOME_CAPTION             104
#define IDD_PROPPAGE2                   105
#define IDS_WELCOME_TEXT                105
#define IDD_PROPPAGE3                   106
#define IDD_PROPPAGE4                   107
#define IDS_PP2_Reader                  107
#define IDD_PROPPAGE5                   108
#define IDS_PP2_CardName                108
#define IDS_PP3_GenerateCert            109
#define IDS_PP3_UseKeys                 110
#define IDS_PP3_YesCert                 111
#define IDS_PP3_NoCert                  112
#define IDS_PP3_YesKeys                 113
#define IDS_PP3_NoKeys                  114
#define IDS_PP3_Header_Caption          117
#define IDS_PP3_Header_Text             118
#define IDS_PP2_Header_Caption          119
#define IDS_PP2_Header_Text             120
#define IDS_PP2_ERR_NoName              121
#define IDS_PP2_ERR_NonuniqueName       122
#define IDS_PP4_Header_Caption          123
#define IDS_PP4_Header_Text             124
#define IDS_PP2_CSP                     125
#define IDS_COMPLETE_CAPTION            126
#define IDS_COMPLETE_SUCCESS            127
#define IDR_MAINFRAME                   128
#define IDS_COMPLETE_FAIL               128
#define IDB_WELCOME                     129
#define IDS_PP2_CSP_Default             129
#define IDI_SCARD_UP                    130
#define IDB_HEADER                      130
#define IDS_COMPLETE_ERR_NoMessage      130
#define IDI_SCARD_DOWN                  131
#define IDS_CERTREQ_ERROR               131
#define IDI_SC_RIGHTARROW               132
#define IDS_CERTREQ_DENIED              132
#define IDR_STATUS_MENU                 133
#define IDI_SC_CHECKED                  133
#define IDS_CERTREQ_SEPARATE            133
#define IDI_SC_INSERT                   134
#define IDS_CERTREQ_UNDERSUBMISSION     134
#define IDI_SC_READEREMPTY              135
#define IDB_WIZARD                      135
#define IDS_CERTREQ_UNKNOWN             135
#define IDI_SC_READERLOADED             136
#define IDB_LINE                        136
#define IDS_CERT_UNKNOWN                136
#define IDI_SC_REMOVE                   137
#define IDS_CERT_TRY_AGAIN              137
#define IDD_NEW_CARD_DLG                138
#define IDS_ICTFT_ERR                   138
#define IDI_SC_READERLOADED_V2          138
#define IDI_SC_READEREMPTY_V2           139
#define IDS_ERR_CSP                     139
#define IDI_SC_READERERR                140
#define IDS_ERR_KEYSET                  140
#define IDS_CREATECERT_FAIL             141
#define IDI_SC_INFO                     141
#define IDS_ERR_CERTCTX                 142
#define IDD_OPTIONSDLG                  142
#define IDI_SC_CARD                     143
#define IDS_CERTPROP_OK                 143
#define IDI_SC_LOGONLOCK                143
#define IDS_CERTPROP_UNKNOWN            144
#define IDS_CREATECERT_SUCCESS          145
#define IDS_OPENSTORE_ERR               146
#define IDS_CERTTOSTORE_ERR             147
#define IDC_HEADER_TEXT                 1001
#define IDC_HEADER_CAPTION              1002
#define IDC_MAIN_GRAPHIC                1003
#define IDC_WELCOME_CAPTION             1004
#define IDC_WELCOME_TEXT                1005
#define IDC_SCARD_LIST                  1006
#define IDC_COMPLETE_TEXT               1006
#define IDC_HEADER_GRAPHIC              1007
#define IDC_USE_CERT                    1009
#define IDC_USE_KEYS                    1012
#define IDC_PROMPT_CSP                  1013
#define IDC_PROMPT_CARDTYPE             1013
#define IDC_CSP                         1014
#define IDC_CARDTYPE                    1014
#define IDC_CERTTYPE_PROMPT             1015
#define IDC_RADIO1                      1016
#define IDC_CARD_NAME                   1017
#define IDC_RADIO2                      1017
#define IDC_SCARD_NAME                  1018
#define IDC_LIST_CARDS                  1018
#define IDC_RADIO3                      1018
#define IDC_READER_NAME                 1019
#define IDC_RADIO4                      1019
#define IDC_READER_LIST                 1020
#define IDC_PROMPT_CARD_NAME            1020
#define IDC_CERTTYPE_DD                 1020
#define IDC_COMPLETE_CAPTION            1021
#define IDC_ALERT                       1025
#define IDC_DIALOG                      1026
#define IDC_SOUND                       1027
#define IDC_INFO                        1027
#define ID_STATUS                       32773
#define ID_CERTIFICATE                  32774
#define IDS_SYSTEM_DOWN                 32775
#define IDS_SYSTEM_UP                   32776
#define IDS_NOTIFY_WIN_NAME             32777
#define IDS_SC_READER                   32778
#define IDS_SC_CARDSTATUS               32779
#define IDS_SC_CARD                     32780
#define IDM_STATUS                      32781
#define IDS_NO_SYSTEM_STATUS            32781
#define IDM_CERTIFICATES                32782
#define IDS_UNKNOWN_ERROR               32782
#define IDM_CLOSE                       32783
#define IDS_TITLE_ERROR                 32783

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        145
#define _APS_NEXT_COMMAND_VALUE         32784
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\resmgrst.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ResMgrSt

Abstract:

    This file contains definititions of threads
	used by scstatus.exe to monitor the status of
	the Smart Card Resource Manager and report changes.
    
Author:

    Amanda Matlosz	10/28/98

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:


Notes:

--*/

#if !defined(_RES_MGR_STATUS)
#define _RES_MGR_STATUS

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include "cmnstat.h"


///////////////////////////////////////////////////////////////////////////
//
// CResMgrStatusThrd - is Calais running or stopped?
//

class CResMgrStatusThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CResMgrStatusThrd)

public:
	// Construction / Destruction
	CResMgrStatusThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
	}

	~CResMgrStatusThrd() {}

	// Implementation
public:
	virtual BOOL InitInstance();

	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;

};

///////////////////////////////////////////////////////////////////////////
//
// CNewReaderThrd - has a new reader been made available to Calais?
//

class CNewReaderThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CNewReaderThrd)

public:
	// Construction / Destruction
	CNewReaderThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
	}

	~CNewReaderThrd() {}

	// Implementation
public:
	virtual BOOL InitInstance();

	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;
};

///////////////////////////////////////////////////////////////////////////
//
// CRemovalOptionsThrd - has user changed removal options? (via lock/unlock)
//

class CRemovalOptionsThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CRemovalOptionsThrd)

public:
	// Construction / Destruction
	CRemovalOptionsThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
	}

	~CRemovalOptionsThrd() {}

	// Implementation
public:
	virtual BOOL InitInstance();

	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;

};

///////////////////////////////////////////////////////////////////////////
//
// CCardStatusThrd - has a card been idle for X seconds?
//

class CCardStatusThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CCardStatusThrd)

public:
	// Construction / Destruction
	CCardStatusThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
		m_paIdleList = NULL;

		m_hCtx = NULL;

		m_pstrLogonReader = NULL;
	}

	~CCardStatusThrd() { }

	// Implementation
public:
	virtual BOOL InitInstance();
	void CopyIdleList(CStringArray* paStr);

	void Close()
	{
		if (m_hCtx != NULL)
		{
			SCardCancel(m_hCtx);
		}

		// supress messages
		m_hCallbackWnd = NULL;
	}


	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;
	SCARDCONTEXT m_hCtx;
	CStringArray* m_paIdleList;
	CCriticalSection m_csLock;
	CString* m_pstrLogonReader;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _RES_MGR_STATUS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\scalert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scalert.h
//
//--------------------------------------------------------------------------

// SCStatus.h : main header file for the SCSTATUS application
//

#if !defined(AFX_SCSTATUS_H__2F127492_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_SCSTATUS_H__2F127492_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <winscard.h>
#include "resource.h"		// main symbols
#include "cmnstat.h"		// Common headers/defines,etc.
#include "notfywin.h"

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp:
// See SCStatus.cpp for the implementation of this class
//

class CSCStatusApp : public CWinApp
{
public:

	// Construction
	CSCStatusApp();

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSCStatusApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

	// Implementation
	//{{AFX_MSG(CSCStatusApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Members
public:
	void SetRemovalOptions(void);

private:

	void SetAlertOptions(bool fRead = true);
	SCARDCONTEXT	m_hSCardContext;	// Context with smartcard resource manager

public:

	HICON	m_hIconCard;
	HICON	m_hIconRdrEmpty;
	HICON	m_hIconCardInfo;
	HICON	m_hIconCalaisDown;			// Icons for Calais system state

	DWORD	m_dwState;
	DWORD	m_dwAlertOption;

	CString	m_strLogonReader;		// strings for handling ScRemovalOptions
	CString	m_strRemovalText;		// removal -> log off, removal -> lock wks.
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCSTATUS_H__2F127492_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\resmgrst.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ResMgrSt

Abstract:

    This file contains the implementation of threads that monitor
	the status of the smart card resource manager, and notify the
	application when that state has changed via callbacks.

Author:

    Amanda Matlosz      03/18/1998

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    5/28/98 AMatlosz    Previously, this thread just watched for the RM to move
                        from a 'down' state to an 'up' state.  Now it keeps on
                        eye on the state to make up for the fact that the other
                        two threads who previously monitored status must shut
                        themselves down if the RM is up but there are no readers
                        available.

	10/28/98 AMatlosz	Added thread to watch for new readers.

Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "stdafx.h"
#include <winsvc.h>
#include <winscard.h>
#include <calaislb.h>
#include <scEvents.h>

#include "SCAlert.h"
#include "ResMgrSt.h"
#include "miscdef.h"


////////////////////////////////////////////////////////////////////////////
//
// Globals
//

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////////////
//
// CResMgrStatusThrd
//

IMPLEMENT_DYNCREATE(CResMgrStatusThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses two callbacks to inform the caller of its status:

    WM_SCARD_RESMGR_STATUS -- WPARAM is bool indicating RM status: true == up
    WM_SCARD_RESMGR_EXIT -- indicates thread has been shut down or is shutting
                            down.
--*/
BOOL CResMgrStatusThrd::InitInstance(void)
{
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    SERVICE_STATUS ssStatus;    // current status of the service
    DWORD dwSts;
    DWORD dwReturn = ERROR_SUCCESS;

    //
    // Take a short break, then ping the service manager to see if the resource
    // manager is running.  If not, wait a long time for it to start.  Repeat
    // until the thread has been asked to die.
    //

	BOOL fContinue = TRUE;

    while (fContinue)
    {
        try
        {
            if (NULL == schSCManager)
            {
                schSCManager = OpenSCManager(
                                    NULL,                   // machine (NULL == local)
                                    NULL,                   // database (NULL == default)
                                    SC_MANAGER_CONNECT);  // access required
                if (NULL == schSCManager)
                    throw (DWORD)GetLastError();
            }
            if (NULL == schService)
            {
                schService = OpenService(
                                    schSCManager,
                                    TEXT("SCardSvr"),
                                    SERVICE_QUERY_STATUS);
                if (NULL == schService)
                    throw (DWORD)GetLastError();
            }
            if (!QueryServiceStatus(schService, &ssStatus))
                throw (DWORD)GetLastError();

			switch (ssStatus.dwCurrentState)
			{
			case SERVICE_CONTINUE_PENDING:
			case SERVICE_PAUSE_PENDING:
			case SERVICE_PAUSED:
				continue;
				break;
			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			case SERVICE_STOPPED:
				dwReturn = SCARD_E_NO_SERVICE;
				break;
			case SERVICE_RUNNING:
				dwReturn = SCARD_S_SUCCESS;
				break;
			default:
				throw (DWORD)SCARD_F_INTERNAL_ERROR;
			}
        }

        catch (DWORD dwErr)
        {
            _ASSERTE(FALSE);  // For debugging.
            if (NULL != schService)
            {
                CloseServiceHandle(schService);
                schService = NULL;
            }
            if (NULL != schSCManager)
            {
                CloseServiceHandle(schSCManager);
                schSCManager = NULL;
            }
            dwReturn = dwErr;
        }

        catch (...)
        {
            _ASSERTE(FALSE);  // For debugging.
            if (NULL != schService)
            {
                CloseServiceHandle(schService);
                schService = NULL;
            }
            if (NULL != schSCManager)
            {
                CloseServiceHandle(schSCManager);
                schSCManager = NULL;
            }
            dwReturn = ERROR_INVALID_PARAMETER;
        }

        if (SCARD_S_SUCCESS == dwReturn)
        {
			// say it's UP!
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_RESMGR_STATUS,
                          TRUE,
                          0);
        }
        else
        {
			// say it's DOWN!
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_RESMGR_STATUS,
                          FALSE,
                          0);
		}

		//
		// Wait for ~30 seconds, continuing on Start or timeout
		// and stopping immediately if the stop event is signaled
		//

		HANDLE rgHandle[2];
		int nHandle = 2;
		rgHandle[0] = CalaisAccessStartedEvent();
		rgHandle[1] = m_hKillThrd;

 		dwSts = WaitForMultipleObjects(
					nHandle,
					rgHandle,
					FALSE,
					300000);
		if (WAIT_OBJECT_0 != dwSts && WAIT_TIMEOUT != dwSts)
		{
			fContinue = FALSE;
		}

        CalaisReleaseStartedEvent();

    }

    //
    // Clean up & let our caller know that we're shutting down.
    //

    if (NULL != schService)
    {
        CloseServiceHandle(schService);
        schService = NULL;
    }
    if (NULL != schSCManager)
    {
        CloseServiceHandle(schSCManager);
        schSCManager = NULL;
    }
    CalaisReleaseStartedEvent();
    if (NULL != m_hCallbackWnd)
    {
        ::PostMessage(m_hCallbackWnd,
                      WM_SCARD_RESMGR_EXIT,
                      0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}



/////////////////////////////////////////////////////////////////////////////////////
//
// CRemovalOptionsThrd
//

IMPLEMENT_DYNCREATE(CRemovalOptionsThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses one message to inform the caller of a change in
	the user's removal options:

    WM_SCARD_REMOPT_CHNG -- re-query smart card removal options

--*/
BOOL CRemovalOptionsThrd::InitInstance(void)
{
    DWORD dwSts = WAIT_FAILED;
    LONG lResult = ERROR_SUCCESS;
	BOOL fContinue = TRUE;
	int nHandle = 2;
	HANDLE rgHandle[2] = {NULL, NULL};
	rgHandle[1] = m_hKillThrd;
	HKEY hKey = NULL;

    while (fContinue)
    {
		// open regkey
		lResult = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			szScRemoveOptionKey,
			0,
			KEY_ALL_ACCESS,
			&hKey);
		if (ERROR_SUCCESS != lResult)
		{
			goto ErrorExit;
		}

		// reset/create event
		if (NULL != rgHandle[0])
		{
			if (!ResetEvent(rgHandle[0]))
			{
				CloseHandle(rgHandle[0]);
				rgHandle[0] = NULL;
			}
		}
		if (NULL == rgHandle[0])
		{
			rgHandle[0] = CreateEvent(
				NULL,
				TRUE,  // must call ResetEvent() to set non-signaled
				FALSE, // not signaled when it starts
				NULL);
			if (NULL == rgHandle[0])
			{
				// give up!
				goto ErrorExit;
			}
		}

		lResult = RegNotifyChangeKeyValue(
			hKey,
			TRUE,
			REG_NOTIFY_CHANGE_LAST_SET,
			rgHandle[0],
			TRUE);
		if (ERROR_SUCCESS != lResult)
		{
			goto ErrorExit;
		}


 		dwSts = WaitForMultipleObjects(
					nHandle,
					rgHandle,
					FALSE,
					INFINITE);

		if (WAIT_OBJECT_0 == dwSts)
		{
			// announce the change
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_REMOPT_CHNG,
                          0, 0);
		}
		else if (WAIT_OBJECT_0+1 == dwSts || WAIT_FAILED == dwSts)
		{
			// Time for thread to quit
			fContinue = FALSE;
		}
		else
		{
			_ASSERTE(WAIT_TIMEOUT == dwSts);
		}


    }

    //
    // Clean up & let our caller know that we're shutting down.
    //
ErrorExit:

	if (NULL != hKey)
	{
		RegCloseKey(hKey);
	}

	if (NULL != rgHandle[0])
	{
		CloseHandle(rgHandle[0]);
	}

    if (NULL != m_hCallbackWnd)
    {
			// announce thread's exit
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_REMOPT_EXIT,
                          0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}



/////////////////////////////////////////////////////////////////////////////////////
//
// CNewReaderThrd
//

IMPLEMENT_DYNCREATE(CNewReaderThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses one callback to inform the caller of an addition to
	the active reader list.

    WM_SCARD_NEWREADER -- indicates that Calais reports a reader just added

--*/
BOOL CNewReaderThrd::InitInstance(void)
{
	if (NULL == m_hCallbackWnd)
	{
		_ASSERTE(FALSE);
		return TRUE; // for compiler
	}

	DWORD dwSts = 0;
	BOOL fContinue = TRUE;

    while (fContinue)
    {
		HANDLE rgHandle[2];
		int nHandle = 2;
		rgHandle[0] = CalaisAccessNewReaderEvent();
		rgHandle[1] = m_hKillThrd;

 		dwSts = WaitForMultipleObjects(
					nHandle,
					rgHandle,
					FALSE,
					300000);

		if (WAIT_OBJECT_0 == dwSts)
		{
			// a new reader event happened!  Fire off the notice
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_NEWREADER,
                          TRUE,
                          0);
		}
		else if (WAIT_OBJECT_0+1 == dwSts || WAIT_FAILED == dwSts)
		{
			// Time for thread to quit
			fContinue = FALSE;
		}
		else
		{
			_ASSERTE(WAIT_TIMEOUT == dwSts);
		}

		CalaisReleaseNewReaderEvent();
    }

    if (NULL != m_hCallbackWnd)
    {
        ::PostMessage(m_hCallbackWnd,
                      WM_SCARD_NEWREADER_EXIT,
                      0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}


/////////////////////////////////////////////////////////////////////////////////////
//
// CCardStatusThrd
//

IMPLEMENT_DYNCREATE(CCardStatusThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses one callback to inform the caller of a change in
	smart card status -- a card is available, no cards are available,
	or a card has been idle for >30 seconds.

    WM_SCARD_CARDSTATUS -- indicates a new card status
	WM_SCARD_CARDSTATUS_EXIT -- indicates imminent thread death.

--*/
BOOL CCardStatusThrd::InitInstance(void)
{
	LONG lResult = SCardEstablishContext(SCARD_SCOPE_USER,NULL,NULL,&m_hCtx);

	if (SCARD_S_SUCCESS != lResult)
	{
		CString str;
		str.Format(_T("CCardStatusThrd:: SCardEstablishContext returned 0x%x."), lResult);
	}

	BOOL fContinue = TRUE;
	LPTSTR szReaders = NULL;
	LPCTSTR pchReader = NULL;
	DWORD dwReadersLen = SCARD_AUTOALLOCATE;
    SCARD_READERSTATE rgReaderStates[MAXIMUM_SMARTCARD_READERS];
	int nIndex = 0, nCnReaders = 0;
	BOOL fLogonLock = (NULL != m_pstrLogonReader && !m_pstrLogonReader->IsEmpty());

    lResult = SCardListReaders(
        m_hCtx,
        SCARD_ALL_READERS,
        (LPTSTR)&szReaders,
        &dwReadersLen
        );

    if(SCARD_S_SUCCESS != lResult ||
	  (0 == dwReadersLen || NULL == szReaders || 0 == *szReaders) )
    {
		fContinue = FALSE;
    }

	if (fContinue)
	{
		// use the list of readers to build a readerstate array
		for (nIndex = 0, pchReader = szReaders;
			 nIndex < MAXIMUM_SMARTCARD_READERS && 0 != *pchReader;
			 nIndex++)
		{
			rgReaderStates[nIndex].szReader = pchReader;
			rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
			pchReader += lstrlen(pchReader)+1;
		}
	    nCnReaders = nIndex;
	}

    while (fContinue)
    {
		UINT uState = (UINT)k_State_NoCard;

        lResult = SCardGetStatusChange(
            m_hCtx,
            10000,			//  IN      DWORD dwTimeout (10 seconds)
            rgReaderStates, //  IN OUT  LPSCARD_READERSTATE
            nCnReaders      //  IN      DWORD cReaders
            );

		// IF return is success, determine if there are any cards inserted
		// if YES, send a messge to notfywnd saying "card in"
		// if NO, send a message to notfywnd saying "no card"
		if (SCARD_S_SUCCESS == lResult)
		{
			// Determine if
			//   (a) any card is present in the system and
			//   (b) if each idle card has ceased to be idle or present
			BOOL fIdle = FALSE;

			for(nIndex=0; nIndex < nCnReaders; nIndex++)
			{
				if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_PRESENT)
				{
					uState = (UINT)k_State_CardAvailable;
				}

				if (k_State_CardIdle == (UINT_PTR)(rgReaderStates[nIndex].pvUserData))
				{
					if ( !(rgReaderStates[nIndex].dwEventState & SCARD_STATE_PRESENT) ||
						  (rgReaderStates[nIndex].dwEventState & SCARD_STATE_INUSE) )
					{
						rgReaderStates[nIndex].pvUserData = NULL;
					}
					else
					{
						fIdle = TRUE;
					}
				}

				rgReaderStates[nIndex].dwCurrentState = rgReaderStates[nIndex].dwEventState;
			}

			if (fIdle) uState = k_State_CardIdle;

		}
		// IF return indicates timeout, determine if any cards are idle.
		else if (SCARD_E_TIMEOUT == lResult)
		{
			BOOL fIdle = FALSE;

			// is there an idle card?
			for(nIndex=0; nIndex < nCnReaders; nIndex++)
			{
				if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_PRESENT)
				{
					uState = k_State_CardAvailable;

					if (!(rgReaderStates[nIndex].dwEventState & SCARD_STATE_INUSE))
					{
						// card used for logon & logoff or lock is not considered idle
						if (!fLogonLock ||
							0 != m_pstrLogonReader->Compare(rgReaderStates[nIndex].szReader))
						{
							rgReaderStates[nIndex].pvUserData = ULongToPtr(k_State_CardIdle);
							fIdle = TRUE;
						}
					}
					rgReaderStates[nIndex].dwCurrentState = rgReaderStates[nIndex].dwEventState;
				}
			}

			// there's an overdue idle card!  Fire off the notification.
			if (fIdle) uState = k_State_CardIdle;
		}
		else
		{
			fContinue = FALSE;
		}

		// update list of readers w/idle cards
		m_csLock.Lock();
		{
			m_paIdleList->RemoveAll();
			
			for(nIndex=0; nIndex < nCnReaders; nIndex++)
			{
				if (k_State_CardIdle == (UINT_PTR)rgReaderStates[nIndex].pvUserData)
				{
					m_paIdleList->Add(rgReaderStates[nIndex].szReader);
				}
			}
		}
		m_csLock.Unlock();

		// inform caller
		if (NULL != m_hCallbackWnd)
		{
			::PostMessage(m_hCallbackWnd,
						  WM_SCARD_CARDSTATUS,
						  uState,
						  0);
		}

    }

    if (NULL != m_hCallbackWnd)
    {
        ::PostMessage(m_hCallbackWnd,
                      WM_SCARD_CARDSTATUS_EXIT,
                      0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}

void CCardStatusThrd::CopyIdleList(CStringArray* paStr)
{
	if (NULL == paStr)
	{
		return;
	}

	m_csLock.Lock();
	{
		paStr->Copy(*m_paIdleList);
	}
	m_csLock.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\statdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statdlg.cpp
//
//--------------------------------------------------------------------------

// StatDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ScAlert.h"
#include "miscdef.h"
#include "statmon.h"
#include "StatDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {                    // Assume C declarations for C++
#endif  // __cplusplus

#ifdef __cplusplus
}
#endif  /* __cplusplus */


/////////////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlgThrd
//

IMPLEMENT_DYNCREATE(CSCStatusDlgThrd, CWinThread)

/*++

InitInstance

    Must override init instance to perform UI thread initialization
		
Arguments:

		
Return Value:
	
	TRUE on build start message loop. FALSE otherwise

	
Author:

    Chris Dudley 2/27/1997

--*/
BOOL CSCStatusDlgThrd::InitInstance( void )
{
	INT_PTR nResult = -1; // error creating dialog
	LONG lReturn = SCARD_S_SUCCESS;
	SCARDCONTEXT hSCardContext = NULL;

	// Acquire context with resource manager
	lReturn = SCardEstablishContext(	SCARD_SCOPE_USER,
										NULL,
										NULL,
										&hSCardContext);
	if (lReturn != SCARD_S_SUCCESS)
	{
		nResult = IDCANCEL;
	}
	else
	{
		m_StatusDlg.SetContext(hSCardContext);

		// Run the dialog as Modal

		m_fStatusDlgUp = TRUE;

		nResult = m_StatusDlg.DoModal();// if the dialog is shut down by a
										// cancellation of the SCARDCONTEXT,
										// it will return IDCANCEL
		m_fStatusDlgUp = FALSE;
	}

	// Release context
	if (NULL != hSCardContext)
	{
		SCardReleaseContext(hSCardContext);
	}

	// Post message that the thread is exiting, based on return...
	if (NULL != m_hCallbackWnd)
	{
		::PostMessage(	m_hCallbackWnd,
						WM_SCARD_STATUS_DLG_EXITED, // CANCELLATION (0), or ERROR (1)
						0, 0);
	}

	AfxEndThread(0);
	return TRUE;	// to make compiler happy
}


/*++

void ShowDialog:

	Brings dialog to front if already open

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::ShowDialog( int nCmdShow, CStringArray* paIdleList )
{
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.ShowWindow(nCmdShow);
		m_StatusDlg.SetIdleList(paIdleList);
	}
}


/*++

void UpdateStatus:

	If the dialog is up, updates idle list and status text

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::UpdateStatus( CStringArray* paIdleList )
{
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.UpdateLogonLockInfo();
		m_StatusDlg.SetIdleList(paIdleList);
		m_StatusDlg.UpdateStatusText();
	}
}


/*++

void UpdateStatusText:

	If the dialog is up, updates Status Text and 

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::UpdateStatusText( void )
{
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.UpdateStatusText();
	}
}


/*++

void Close:

	Closes modal dialog if already open

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::Close( void )
{
	// Setup for close
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.EndDialog(IDOK);
	}
	m_fStatusDlgUp = FALSE;
}


/*++

void Update:

	This routine updates the UI.

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::Update( void )
{
	// Tell the dialog to update its statmonitor, if it's up.
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.RestartMonitor();
	}

	// Do other updating
	UpdateStatusText();
}


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg dialog
//

CSCStatusDlg::CSCStatusDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSCStatusDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSCStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDI_SC_READERLOADED_V2);

	// Other initialization
	m_fEventsGood = FALSE;
	m_hSCardContext = NULL;
	m_aIdleList.RemoveAll();

	UpdateLogonLockInfo();
}

void CSCStatusDlg::UpdateLogonLockInfo(void)
{
	m_pstrLogonReader = &(((CSCStatusApp*)AfxGetApp())->m_strLogonReader);
	m_pstrRemovalText = &(((CSCStatusApp*)AfxGetApp())->m_strRemovalText);
	m_fLogonLock = (!(m_pstrLogonReader->IsEmpty()));
}

void CSCStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSCStatusDlg)
	DDX_Control(pDX, IDC_SCARD_LIST, m_SCardList);
	DDX_Control(pDX, IDC_ALERT, m_btnAlert);
	DDX_Control(pDX, IDC_INFO, m_ediInfo);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSCStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CSCStatusDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_CLOSE()
	ON_MESSAGE( WM_READERSTATUSCHANGE, OnReaderStatusChange )
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_ALERT, OnAlertOptions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg Implementation


/*++

BOOL SetContext:

	Sets the Context with the resource manager
	
Arguments:

	SCardContext - the context
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/6/1997

Revision History:

	Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::SetContext(SCARDCONTEXT hSCardContext)
{
	m_hSCardContext = hSCardContext;
}


/*++

void CleanUp:

	Routine cleans up for exit
	
Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/11/1997

Revision History:

	Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::CleanUp ( void )
{
	m_monitor.Stop();

	m_SCardList.DeleteAllItems();
}



/*++

void SetIdleList:

    Make a local copy of the app's list of readers with idle cards.

Notes:
--*/
void CSCStatusDlg::SetIdleList(CStringArray* paIdleList)
{
	m_aIdleList.Copy(*paIdleList);
	long lResult = UpdateSCardListCtrl();
}


/*++

void UpdateStatusText:

    Reflect card usage status in text.  (alert message, howto, etc.)

Notes:
	Not localization friendly.  Move strings to resources.
--*/
void CSCStatusDlg::UpdateStatusText( void )
{
	CString str;
	if (k_State_CardIdle == ((CSCStatusApp*)AfxGetApp())->m_dwState)
	{
		str = _T("A smart card has been left idle.  You may safely remove it now.");
	}
	else
	{
		str = _T("Click the button on the left to change your alert options.");
	}
	m_ediInfo.SetWindowText(str);
}


/*++

void InitSCardListCtrl:

    This routine sets up the CListCtrl properly for display
		
Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/6/1997

Revision History:

	Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::InitSCardListCtrl( void )
{
	CString strHeader;
	CImageList imageList;
	HICON hicon;

	// Create columns in list control
	strHeader.LoadString(IDS_SC_READER);
	m_SCardList.InsertColumn(READER_COLUMN,
							strHeader,
							LVCFMT_LEFT,
							100,
							-1);

	strHeader.LoadString(IDS_SC_CARDSTATUS);
	m_SCardList.InsertColumn(STATUS_COLUMN,
							strHeader,
							LVCFMT_LEFT,
							600,
							-1);

	strHeader.LoadString(IDS_SC_CARD);
	m_SCardList.InsertColumn(CARD_COLUMN,
							strHeader,
							LVCFMT_LEFT,
							100,
							-1);

	// Create the image list & give it to the list control
	imageList.Create (	IMAGE_WIDTH,
						IMAGE_HEIGHT,
						TRUE,				// list does not include masks
						NUMBER_IMAGES,
						0);					// list won't grow

	// Build the list
	for (int ix = 0; ix < NUMBER_IMAGES; ix++ )
	{
		// Load icon and add it to image list
		hicon = ::LoadIcon(AfxGetInstanceHandle(),
							MAKEINTRESOURCE(IMAGE_LIST_IDS[ix]) );
		imageList.Add(hicon);
	}

	// Be sure that all the small icons were added.
	_ASSERTE(imageList.GetImageCount() == NUMBER_IMAGES);

	m_SCardList.SetImageList(&imageList, (int) LVSIL_SMALL);

	imageList.Detach();	// leave the images intact when we go out of scope
}


/*++

LONG UpdateSCardListCtrl:

    This routine updates the list box display.
		
Arguments:

	None.
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revision History:

	Chris Dudley 5/13/1997

Notes:
	
	1. Strings need to be converted from type stored in the smartcard
	thread help classes to this dialog's build type (i.e. UNICODE/ANSI)!!!!

--*/
LONG CSCStatusDlg::UpdateSCardListCtrl( void )
{
	LONG lReturn = SCARD_S_SUCCESS;
	LONG lMoreReaders = SCARD_S_SUCCESS;
	CSCardReaderState* pReader;
	int nImage = 0;
	LV_ITEM	lv_item;
	CString strCardStatus, strCardName;

	//
	// If the status monitor is not running,
	// Don't bother to update SCardListCtrl
	// If there used to be readers, display an error and shut down dialog
	//

	if (CScStatusMonitor::running != m_monitor.GetStatus())
	{
		m_SCardList.EnableWindow(FALSE);

		DoErrorMessage();
		return lReturn;
	}

	// Setup LV_ITEM struct
	lv_item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;

	// Remove old items from list if required
	m_SCardList.DeleteAllItems();

	//
	// Update the reader information
	//

	m_monitor.GetReaderStatus(m_aReaderState);

	//
	// Recreate the items in the reader list (UI)
	//

	int nNumReaders = (int)m_aReaderState.GetSize();
	for(int nIndex = 0; nIndex < nNumReaders; nIndex++)
	{
		// Setup struct for system reader list
		pReader = m_aReaderState[nIndex];

		lv_item.state = 0;
		lv_item.stateMask = 0;
		lv_item.iItem = nIndex;
		lv_item.iSubItem = 0;
		lv_item.pszText = _T("");
		lv_item.cchTextMax = MAX_ITEMLEN;
		lv_item.iImage = (int)READEREMPTY;

		if (NULL != pReader)
		{
			lv_item.pszText = (LPTSTR)(LPCTSTR)((m_aReaderState[nIndex])->strReader);

			// Get the card status: image
			DWORD dwState = (m_aReaderState[nIndex])->dwState;
			if (dwState == SC_STATUS_NO_CARD)
			{
				lv_item.iImage = (int)READEREMPTY;
			}
			else if (dwState == SC_STATUS_ERROR)
			{
				lv_item.iImage = (int)READERERROR;
			}
			else
			{
				// normally, this would be a "card loaded"...
				lv_item.iImage = (int)READERLOADED;

				// ...unless the card is the logon/locked card or idle
				if (m_fLogonLock && 
					(0 == m_pstrLogonReader->Compare((m_aReaderState[nIndex])->strReader)))
				{
					lv_item.iImage = (int)READERLOCK;
				}
				else
				{
					for (int n1=(int)m_aIdleList.GetUpperBound(); n1>=0; n1--)
					{
						if (m_aIdleList[n1] == (m_aReaderState[nIndex])->strReader)
						{
							lv_item.iImage = (int)READERINFO;
							break;
						}
					}
				}
			}

			// Add Reader Item
			m_SCardList.InsertItem(&lv_item);

			// Add Card Name sub item
			if (dwState != SC_STATUS_NO_CARD && dwState != SC_STATUS_ERROR)
			{
				// Set card name if not available
				strCardName = (LPCTSTR)(m_aReaderState[nIndex])->strCard;
				if (strCardName.IsEmpty())
				{
					strCardName.LoadString(IDS_SC_NAME_UNKNOWN);
				}
				m_SCardList.SetItemText(nIndex,
										CARD_COLUMN,
										strCardName);
			}

			// Add Card Status sub item
			ASSERT(dwState >= SC_STATUS_FIRST && dwState <= SC_STATUS_LAST);
			strCardStatus.LoadString(CARD_STATUS_IDS[dwState]);

			if (m_fLogonLock && 
				(0 == m_pstrLogonReader->Compare((m_aReaderState[nIndex])->strReader)))
			{
				CString strTemp = *m_pstrRemovalText + strCardStatus;
				strCardStatus = strTemp;
			}

			m_SCardList.SetItemText(nIndex,
									STATUS_COLUMN,
									strCardStatus);

			strCardStatus.Empty();
			strCardName.Empty();
		}		

	}

	// If we got this far, things are OK.  Make sure the window is enabled.
	m_SCardList.EnableWindow(TRUE);

	return lReturn;
}


/*++

void RestartMonitor:

    This routine forces the monitor to refresh its list of readers.
		
Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Amanda Matlosz 11/04/1998

Notes:
	

--*/
void CSCStatusDlg::RestartMonitor( void )
{
	m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);
}


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg message handlers
//


/*++

void OnInitDialog:

	Performs dialog initialization.

Arguments:

	None.
		
Return Value:
	
	TRUE if successful and dialog should be displayed. FALSE otherwise.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
BOOL CSCStatusDlg::OnInitDialog()
{
	LONG lReturn = SCARD_S_SUCCESS;

	CDialog::OnInitDialog();

	//
	// Initialize the CScStatusMonitor
	//

	m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);

	//
	// Initialize the list control -- whether or not the monitor has started!
	//

	InitSCardListCtrl();

	lReturn = UpdateSCardListCtrl();

	//
	// Show the dialog IFF the above succeeded
	//

	if (SCARD_S_SUCCESS == lReturn)
	{
		// Set the status text
		UpdateStatusText();

		// Set the icon for this dialog.  The framework does this automatically
		//  when the application's main window is not a dialog

		SetIcon(m_hIcon, TRUE);			// Set big icon
		SetIcon(m_hIcon, FALSE);		// Set small icon
		
		// set icon for Alerts button
		HICON hIcon = AfxGetApp()->LoadIcon(IDI_SC_INFO);
		SendDlgItemMessage(IDC_ALERT, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

		// Center the dialog and bring it to top
		CenterWindow();
		SetWindowPos(	&wndTop,
						0,0,0,0,
						SWP_NOMOVE | SWP_NOSIZE);
		SetActiveWindow();

		// Set Parent to desktop
		SetParent(NULL);
	}
	else
	{
		//
		// If any of the initialization depending on the resource manager failed,
		// give up and report a death-due-to-some-error to the caller
		//

		PostMessage(WM_CLOSE, 0, 0);  // need to CANCEL, instead of close...
		TRACE_CATCH_UNKNOWN(_T("OnInitDialog"));
	}

	return TRUE;  // return TRUE  unless you set the focus to a control
}


/*++

void OnPaint:

	Used to paint dialog. In this case, used to draw the icon for the dialog
	while minimized/maximized.

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}


/*++

void OnQueryDragIcon:

	The system calls this to obtain the cursor to display while the user drags
	the minimized window.		

Arguments:

	None.
		
Return Value:
	
	HCURSOR handle to cursor to display

Author:

    Chris Dudley 7/30/1997

Note:

--*/
HCURSOR CSCStatusDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


/*++

void DestroyWindow:

	This is called by MFC whenever the dialog is closed, whether that is
	through WM_CLOSE (sysmenu "X") or EndDialog(IDOK/IDCANCEL)...

Arguments:

	None.
		
Return Value:
	
	Base class version of DestroyWindow.

Author:

	Amanda Matlosz 4/29/98

Note:

--*/
BOOL CSCStatusDlg::DestroyWindow()
{
	CleanUp();

	return CDialog::DestroyWindow();
}


/*++

void OnReaderStatusChange:

    This message handler is called by the status thread when smartcard status
	has changed.
		
Arguments:

	None.
		
Return Value:
	
	None

Author:

    Chris Dudley 3/9/1997

Revision History:

	Chris Dudley 5/13/1997

Note:

	1. No formal parameters are declared. These are not used and
	will stop compiler warnings from being generated.

--*/
LONG CSCStatusDlg::OnReaderStatusChange( UINT , LONG )
{

	// Update the display
	UpdateSCardListCtrl();

	return 0;
}



/*++
allow user to set alert options (sound, pop-up, neither)
--*/
void CSCStatusDlg::OnAlertOptions()
{
	COptionsDlg dlg;
	dlg.DoModal();
}
/*++

void DoErrorMessage:

    This is a helper routine to keep the UI stuff in one place and make sure
	the same error messages are handled consistently throughout.
		
Arguments:

	None.
		
Return Value:
	
	None

Author:

	Amanda Matlosz	5/21/98

Revision History:


Note:

	1. Consider taking an error code as well as m_monitor.GetStatus()

--*/
void CSCStatusDlg::DoErrorMessage( void )
{
	CString strMsg;
	BOOL fShutDownDlg = FALSE;

	switch(m_monitor.GetStatus())
	{
	case CScStatusMonitor::no_service:
		fShutDownDlg = TRUE;
		strMsg.LoadString(IDS_NO_SYSTEM_STATUS);
		break;

	case CScStatusMonitor::no_readers:
		// for now, do nothing!
		break;

	case CScStatusMonitor::stopped:
		// do nothing!  This is a clean stop on the way to shutting down.
		break;

	case CScStatusMonitor::uninitialized:
	case CScStatusMonitor::unknown:
	case CScStatusMonitor::running:
		fShutDownDlg = TRUE;
		strMsg.LoadString(IDS_UNKNOWN_ERROR);	
	}

	if (!strMsg.IsEmpty())
	{
		CString strTitle;
		strTitle.LoadString(IDS_TITLE_ERROR);
		MessageBox(strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
	}

	if (fShutDownDlg)
	{
		PostMessage(WM_CLOSE, 0, 0);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog


COptionsDlg::COptionsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COptionsDlg::IDD, pParent)
{
	BOOL fSound = FALSE;
	BOOL fDlg = FALSE;

	switch(((CSCStatusApp*)AfxGetApp())->m_dwAlertOption)
	{
		case k_AlertOption_IconSound:
			fSound = TRUE;
			break;
		case k_AlertOption_IconSoundMsg:
			fSound = TRUE;
		case k_AlertOption_IconMsg:
			fDlg = TRUE;
			break;
	}

	//{{AFX_DATA_INIT(COptionsDlg)
	m_fDlg = fDlg;
	m_fSound = fSound;
	//}}AFX_DATA_INIT
}


void COptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COptionsDlg)
	DDX_Check(pDX, IDC_DIALOG, m_fDlg);
	DDX_Check(pDX, IDC_SOUND, m_fSound);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsDlg, CDialog)
	//{{AFX_MSG_MAP(COptionsDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg message handlers

void COptionsDlg::OnOK() 
{
	// use status of check boxes to set alert options state for app
	UpdateData(TRUE);

	if (TRUE == m_fSound)
	{
		if (TRUE == m_fDlg)
		{
			((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconSoundMsg;
		}
		else
		{
			((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconSound;
		}
	}
	else if (TRUE == m_fDlg)
	{
		((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconMsg;
	}
	else
	{
		((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconOnly;
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\scalert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scalert.cpp
//
//--------------------------------------------------------------------------

// SCAlert.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "SCAlert.h"
#include "miscdef.h"
#include "cmnstat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


LPTSTR szAlertOptionsValue = TEXT("AlertOptions");
LPTSTR szScRemoveOptionsValue = TEXT("ScRemoveOption");
LPTSTR szScLogonReaderValue = TEXT("ScLogonReader");

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp

BEGIN_MESSAGE_MAP(CSCStatusApp, CWinApp)
    //{{AFX_MSG_MAP(CSCStatusApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// The one and only CSCStatusApp object

CSCStatusApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp construction

CSCStatusApp::CSCStatusApp()
{
	m_strLogonReader.Empty();
	m_strRemovalText.Empty();
}

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp initialization

BOOL CSCStatusApp::InitInstance()
{
    // Locals
    BOOL fReturn = TRUE;
    DWORD dwStatus = 0;
    CNotifyWin* pNotifyWin = NULL;
    CString     sWindowName;

    try
    {
        // set params
        m_hSCardContext = NULL;
        m_pMainWnd = NULL;
        m_dwState = k_State_Unknown;

        SetAlertOptions();
		SetRemovalOptions();	

        // Enable ActiveX control usage
        AfxEnableControlContainer();

        // Enable 3D Contols
        #ifdef _AFXDLL
            Enable3dControls();         // Call this when using MFC in a shared DLL
        #else
            Enable3dControlsStatic();   // Call this when linking to MFC statically
        #endif

        // Load the icons
        m_hIconCard = LoadIcon(MAKEINTRESOURCE(IDI_SC_READERLOADED_V2));
        m_hIconCalaisDown = LoadIcon(MAKEINTRESOURCE(IDI_SC_READERERR));
        m_hIconRdrEmpty = LoadIcon(MAKEINTRESOURCE(IDI_SC_READEREMPTY_V2));
        m_hIconCardInfo = LoadIcon(MAKEINTRESOURCE(IDI_SC_INFO));

        // Create the "main" window for this app
        m_pMainWnd = (CWnd*)new(CNotifyWin);
        if (m_pMainWnd == NULL)
            throw (FALSE);

        // Get pointer to CNotifyWin class
        pNotifyWin = (CNotifyWin*)m_pMainWnd;

        if (!pNotifyWin->FinalConstruct())
        {
            delete pNotifyWin;
            m_pMainWnd = NULL;
            throw (FALSE);
        }

        // Get the window name
        fReturn = sWindowName.LoadString(IDS_NOTIFY_WIN_NAME);
        if (!fReturn)
            throw (fReturn);

        // Create the window
        fReturn = m_pMainWnd->CreateEx( 0,
                                        pNotifyWin->m_sClassName,
                                        sWindowName,
                                        0,
                                        0,0,0,0,
                                        NULL,
                                        NULL,
                                        NULL);
        if (!fReturn)
            throw (fReturn);

    }
    catch (...) {
        fReturn = FALSE;
        TRACE_CATCH_UNKNOWN(_T("CSCStatusApp::InitInstance"));
    }

    return fReturn;
}


/*++

void SetAlertOptions:

    Set User's alert options according to regkey settings (or default)

Arguments:
Return Value:

    None.

Author:

    Amanda Matlosz  5/13/99

--*/
void CSCStatusApp::SetAlertOptions(bool fRead)
{
    long lSts = ERROR_SUCCESS;
    HKEY hKey = NULL;

    // Either read the AlertOptions from the registry...
    if (fRead)
    {
        DWORD dwOption = -1;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = 0;

        lSts = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    szAlertOptionsKey,
                    0,
                    KEY_READ,
                    &hKey);

        if (ERROR_SUCCESS == lSts)
        {

            lSts = RegQueryValueEx(
                        hKey,
                        szAlertOptionsValue,
                        0,
                        &dwType,
                        (PBYTE)&dwOption,
                        &dwSize
                        );
        }

        if (k_AlertOption_IconMsg < dwOption)
        {
            // default value is "IconSoundMessage"
            m_dwAlertOption = k_AlertOption_IconSoundMsg;
        }
        else
        {
            m_dwAlertOption = dwOption;
        }

    }
    // Or set the value of the registry "AlertOptions"
    else
    {
        DWORD dw = 0; // don't really care about this param

        lSts = RegCreateKeyEx(
                    HKEY_CURRENT_USER,
                    szAlertOptionsKey,
                    0,
                    TEXT(""),
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dw);

        if (ERROR_SUCCESS == lSts)
        {
            RegSetValueEx(
                hKey,
                szAlertOptionsValue,
                0,
                REG_DWORD,
                (PBYTE)&m_dwAlertOption,
                sizeof(DWORD)
                );
        }

    }

    // cleanup
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
}


/*++

void SetRemovalOptions:

    Determine if user has set ScremoveOption for smart card logon, and
	set behavior for ScAlert accordingly.
		
Arguments:
Return Value:

	None.
		
Author:

	Amanda Matlosz	6/02/99

--*/
void CSCStatusApp::SetRemovalOptions()
{
	long lSts = ERROR_SUCCESS;
	HKEY hKey = NULL;
	DWORD dwType = 0;
	DWORD dwSize = 2*sizeof(TCHAR);

	TCHAR szRemoveOption[2];
    lSts = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szScRemoveOptionKey,
                0,
                KEY_READ,
                &hKey);

	if (ERROR_SUCCESS == lSts)
	{
		// this value must be either '0', '1', '2', or nonexistent.
		lSts = RegQueryValueEx(
					hKey,
					szScRemoveOptionsValue,
					0,
					&dwType,
					(PBYTE)szRemoveOption,
					&dwSize
					);
	}

	if (ERROR_SUCCESS == lSts)
	{
		// if '1' or '2' find out what reader was used for logon, if any.
		if('1' == *szRemoveOption)
		{
			m_strRemovalText.LoadString(IDS_SC_REMOVAL_LOCK);
		}
		else if ('2' == *szRemoveOption)
		{
			m_strRemovalText.LoadString(IDS_SC_REMOVAL_LOGOFF);
		}
	}

	if (!m_strRemovalText.IsEmpty())
	{
		dwSize = 0;
		LPTSTR szLogonReader = NULL;

		lSts = RegQueryValueEx(
					hKey,
					szScLogonReaderValue,
					0,
					&dwType,
					NULL,
					&dwSize
					);

		if (ERROR_SUCCESS == lSts)
		{
			szLogonReader = m_strLogonReader.GetBuffer(dwSize);

			lSts = RegQueryValueEx(
						hKey,
						szScLogonReaderValue,
						0,
						&dwType,
						(PBYTE)szLogonReader,
						&dwSize
						);
			
			m_strLogonReader.ReleaseBuffer();
		}
	}

	// cleanup
	if (NULL != hKey)
	{
		RegCloseKey(hKey);
	}
}



/*++

void ExitInstance:

    Does instance uninitialization

Arguments:

    None.

Return Value:

    Win32 error codes. 0 indicates no error occured.

Author:

    Chris Dudley 7/30/1997

Note:

--*/

int CSCStatusApp::ExitInstance()
{
    // save the alert options
    SetAlertOptions(false);

    // Release calais if required
    if (m_hSCardContext != NULL)
    {
        SCardReleaseContext(m_hSCardContext);
    }

    // Make sure the window is deleted
    if (m_pMainWnd != NULL)
    {
        delete m_pMainWnd;
    }

    return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\statdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statdlg.h
//
//--------------------------------------------------------------------------

// StatDlg.h : header file
//

#if !defined(AFX_STATDLG_H__2F127494_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STATDLG_H__2F127494_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "cmnstat.h"
#include "statmon.h"

/////////////////////////////////////////////////////////////////////////////
//
// Constants for dialog
//

// Columns in list view
#define     READER_COLUMN       0           
#define     CARD_COLUMN         1
#define     STATUS_COLUMN       2
#define     MAX_ITEMLEN         255

// Image list properties
#define     IMAGE_WIDTH         16
#define     IMAGE_HEIGHT        16
#define     NUMBER_IMAGES       5
const UINT  IMAGE_LIST_IDS[] = {IDI_SC_READERLOADED_V2,
                                IDI_SC_READEREMPTY_V2,
                                IDI_SC_READERERR,
								IDI_SC_INFO,
								IDI_SC_LOGONLOCK };
// Image list indicies
#define     READERLOADED        0
#define     READEREMPTY         1
#define     READERERROR         2
#define		READERINFO			3
#define		READERLOCK			4

// Card status string IDs
const UINT CARD_STATUS_IDS[] = {IDS_SC_STATUS_NO_CARD,
								IDS_SC_STATUS_UNKNOWN,
								IDS_SC_STATUS_AVAILABLE,
                                IDS_SC_STATUS_SHARED,
                                IDS_SC_STATUS_IN_USE,
								IDS_SC_STATUS_ERROR};
#define MAX_INDEX               255


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg dialog
//

class CSCStatusDlg : public CDialog
{
	// members
private:
	BOOL				m_fEventsGood;		// is the thread alive?
	SCARDCONTEXT		m_hSCardContext;	// Context with smartcard resource manager

	CScStatusMonitor	m_monitor;			// see statmon.h
	CSCardReaderStateArray	m_aReaderState; //  ""
	CStringArray		m_aIdleList;
	CString*			m_pstrLogonReader;	// from scalert.h
	CString*			m_pstrRemovalText;	//	""
	BOOL				m_fLogonLock;

	// Construction
public:
	CSCStatusDlg(CWnd* pParent = NULL);	// standard constructor

	// Dialog Data
	//{{AFX_DATA(CSCStatusDlg)
	enum { IDD = IDD_SCSTATUS_DIALOG };
	CListCtrl	m_SCardList;
	CButton		m_btnAlert;
	CEdit		m_ediInfo;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSCStatusDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

	// Implementation
private:

    // UI routines
    void CleanUp( void );

	void DoErrorMessage( void ); // TODO: maybe take an error code?

    // Smartcard related routines
    void InitSCardListCtrl( void );
    LONG UpdateSCardListCtrl( void );

public:
	void SetContext(SCARDCONTEXT hSCardContext);
	void RestartMonitor( void );
	void UpdateStatusText( void );
	void SetIdleList(CStringArray* paIdleList);
	void UpdateLogonLockInfo( void );

protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CSCStatusDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
    afx_msg LONG OnReaderStatusChange( UINT , LONG );
	afx_msg void OnAlertOptions();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlgThrd
//

class CSCStatusDlgThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CSCStatusDlgThrd)

public:
	// Construction / Destruction
	CSCStatusDlgThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_fStatusDlgUp = FALSE;
	}

	~CSCStatusDlgThrd() {}


	// Implementation
	void Close( void );
	virtual BOOL InitInstance();
	void ShowDialog( int nCmdShow, CStringArray* paIdleList );
	void Update( void );
	void UpdateStatus( CStringArray* paIdleList );
	void UpdateStatusText( void );

	// members

private:
	CSCStatusDlg	m_StatusDlg;
	BOOL			m_fStatusDlgUp;

public:
	HWND			m_hCallbackWnd;


};


/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog

class COptionsDlg : public CDialog
{
// Construction
public:
	COptionsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(COptionsDlg)
	enum { IDD = IDD_OPTIONSDLG };
	BOOL	m_fDlg;
	BOOL	m_fSound;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COptionsDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STATDLG_H__2F127494_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\longhorn\scalert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scalert.cpp
//
//--------------------------------------------------------------------------

// SCAlert.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "SCAlert.h"
#include "miscdef.h"
#include "cmnstat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


LPTSTR szAlertOptionsValue = TEXT("AlertOptions");
LPTSTR szScRemoveOptionsValue = TEXT("ScRemoveOption");
LPTSTR szScLogonReaderValue = TEXT("ScLogonReader");

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp

BEGIN_MESSAGE_MAP(CSCStatusApp, CWinApp)
    //{{AFX_MSG_MAP(CSCStatusApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// The one and only CSCStatusApp object

CSCStatusApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp construction

CSCStatusApp::CSCStatusApp()
{
	m_strLogonReader.Empty();
	m_strRemovalText.Empty();
}

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp initialization

BOOL CSCStatusApp::InitInstance()
{
    // Locals
    BOOL fReturn = TRUE;
    DWORD dwStatus = 0;
    CNotifyWin* pNotifyWin = NULL;
    CString     sWindowName;

    try
    {
        // set params
        m_hSCardContext = NULL;
        m_pMainWnd = NULL;
        m_dwState = k_State_Unknown;

#ifdef ISOLATION_AWARE_ENABLED
        SHFusionInitializeFromModuleID (m_hInstance, 2);
#endif
        SetAlertOptions();
		SetRemovalOptions();	

        // Enable ActiveX control usage
        AfxEnableControlContainer();

        // Enable 3D Contols
        #ifdef _AFXDLL
            Enable3dControls();         // Call this when using MFC in a shared DLL
        #else
            Enable3dControlsStatic();   // Call this when linking to MFC statically
        #endif

        // Load the icons
        m_hIconCard = LoadIcon(MAKEINTRESOURCE(IDI_SC_READERLOADED_V2));
        m_hIconCalaisDown = LoadIcon(MAKEINTRESOURCE(IDI_SC_READERERR));
        m_hIconRdrEmpty = LoadIcon(MAKEINTRESOURCE(IDI_SC_READEREMPTY_V2));
        m_hIconCardInfo = LoadIcon(MAKEINTRESOURCE(IDI_SC_INFO));

        // Create the "main" window for this app
        m_pMainWnd = (CWnd*)new(CNotifyWin);
        if (m_pMainWnd == NULL)
            throw (FALSE);

        // Get pointer to CNotifyWin class
        pNotifyWin = (CNotifyWin*)m_pMainWnd;

        if (!pNotifyWin->FinalConstruct())
        {
            delete pNotifyWin;
            m_pMainWnd = NULL;
            throw (FALSE);
        }

        // Get the window name
        fReturn = sWindowName.LoadString(IDS_NOTIFY_WIN_NAME);
        if (!fReturn)
            throw (fReturn);

        // Create the window
        fReturn = m_pMainWnd->CreateEx( 0,
                                        pNotifyWin->m_sClassName,
                                        sWindowName,
                                        0,
                                        0,0,0,0,
                                        NULL,
                                        NULL,
                                        NULL);
        if (!fReturn)
            throw (fReturn);

    }
    catch (...) {
        fReturn = FALSE;
        TRACE_CATCH_UNKNOWN(_T("CSCStatusApp::InitInstance"));
    }

    return fReturn;
}


/*++

void SetAlertOptions:

    Set User's alert options according to regkey settings (or default)

Arguments:
Return Value:

    None.

Author:

    Amanda Matlosz  5/13/99

--*/
void CSCStatusApp::SetAlertOptions(bool fRead)
{
    long lSts = ERROR_SUCCESS;
    HKEY hKey = NULL;

    // Either read the AlertOptions from the registry...
    if (fRead)
    {
        DWORD dwOption = -1;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = 0;

        lSts = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    szAlertOptionsKey,
                    0,
                    KEY_READ,
                    &hKey);

        if (ERROR_SUCCESS == lSts)
        {

            lSts = RegQueryValueEx(
                        hKey,
                        szAlertOptionsValue,
                        0,
                        &dwType,
                        (PBYTE)&dwOption,
                        &dwSize
                        );
        }

        if (k_AlertOption_IconMsg < dwOption)
        {
            // default value is "IconSoundMessage"
            m_dwAlertOption = k_AlertOption_IconSoundMsg;
        }
        else
        {
            m_dwAlertOption = dwOption;
        }

    }
    // Or set the value of the registry "AlertOptions"
    else
    {
        DWORD dw = 0; // don't really care about this param

        lSts = RegCreateKeyEx(
                    HKEY_CURRENT_USER,
                    szAlertOptionsKey,
                    0,
                    TEXT(""),
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dw);

        if (ERROR_SUCCESS == lSts)
        {
            RegSetValueEx(
                hKey,
                szAlertOptionsValue,
                0,
                REG_DWORD,
                (PBYTE)&m_dwAlertOption,
                sizeof(DWORD)
                );
        }

    }

    // cleanup
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
}


/*++

void SetRemovalOptions:

    Determine if user has set ScremoveOption for smart card logon, and
	set behavior for ScAlert accordingly.
		
Arguments:
Return Value:

	None.
		
Author:

	Amanda Matlosz	6/02/99

--*/
void CSCStatusApp::SetRemovalOptions()
{
	long lSts = ERROR_SUCCESS;
	HKEY hKey = NULL;
	DWORD dwType = 0;
	DWORD dwSize = 2*sizeof(TCHAR);

	TCHAR szRemoveOption[2];
    lSts = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szScRemoveOptionKey,
                0,
                KEY_READ,
                &hKey);

	if (ERROR_SUCCESS == lSts)
	{
		// this value must be either '0', '1', '2', or nonexistent.
		lSts = RegQueryValueEx(
					hKey,
					szScRemoveOptionsValue,
					0,
					&dwType,
					(PBYTE)szRemoveOption,
					&dwSize
					);
	}

	if (ERROR_SUCCESS == lSts)
	{
		// if '1' or '2' find out what reader was used for logon, if any.
		if('1' == *szRemoveOption)
		{
			m_strRemovalText.LoadString(IDS_SC_REMOVAL_LOCK);
		}
		else if ('2' == *szRemoveOption)
		{
			m_strRemovalText.LoadString(IDS_SC_REMOVAL_LOGOFF);
		}
	}

	if (!m_strRemovalText.IsEmpty())
	{
		dwSize = 0;
		LPTSTR szLogonReader = NULL;

		lSts = RegQueryValueEx(
					hKey,
					szScLogonReaderValue,
					0,
					&dwType,
					NULL,
					&dwSize
					);

		if (ERROR_SUCCESS == lSts)
		{
			szLogonReader = m_strLogonReader.GetBuffer(dwSize);

			lSts = RegQueryValueEx(
						hKey,
						szScLogonReaderValue,
						0,
						&dwType,
						(PBYTE)szLogonReader,
						&dwSize
						);
			
			m_strLogonReader.ReleaseBuffer();
		}
	}

	// cleanup
	if (NULL != hKey)
	{
		RegCloseKey(hKey);
	}
}



/*++

void ExitInstance:

    Does instance uninitialization

Arguments:

    None.

Return Value:

    Win32 error codes. 0 indicates no error occured.

Author:

    Chris Dudley 7/30/1997

Note:

--*/

int CSCStatusApp::ExitInstance()
{
    // save the alert options
    SetAlertOptions(false);

    // Release calais if required
    if (m_hSCardContext != NULL)
    {
        SCardReleaseContext(m_hSCardContext);
    }

    // Make sure the window is deleted
    if (m_pMainWnd != NULL)
    {
        delete m_pMainWnd;
    }

#ifdef ISOLATION_AWARE_ENABLED
    SHFusionUninitialize();
#endif

    return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

// Include multi-thread classes
#include <afxmt.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <atlconv.h>		// ATL Conversion macros

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCStatus.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\chngpdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       chngpdlg.cpp
//
//--------------------------------------------------------------------------

// chngpdlg.cpp : implementation file
//

#include "stdafx.h"
#include "scuidlg.h"
#include "scdlg.h"
#include "chngpdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog


CChangePinDlg::CChangePinDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CChangePinDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CChangePinDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CChangePinDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChangePinDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangePinDlg, CDialog)
	//{{AFX_MSG_MAP(CChangePinDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg message handlers
/////////////////////////////////////////////////////////////////////////////
// CGetPinDlg dialog


CGetPinDlg::CGetPinDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGetPinDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGetPinDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CGetPinDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetPinDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetPinDlg, CDialog)
	//{{AFX_MSG_MAP(CGetPinDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetPinDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\longhorn\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

// Include multi-thread classes
#include <afxmt.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#ifdef ISOLATION_AWARE_ENABLED
#include <shfusion.h>

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif

#include <atlconv.h>		// ATL Conversion macros

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scalert\longhorn\statdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statdlg.cpp
//
//--------------------------------------------------------------------------

// StatDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ScAlert.h"
#include "miscdef.h"
#include "statmon.h"
#include "StatDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {                    // Assume C declarations for C++
#endif  // __cplusplus

#ifdef __cplusplus
}
#endif  /* __cplusplus */


/////////////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlgThrd
//

IMPLEMENT_DYNCREATE(CSCStatusDlgThrd, CWinThread)

/*++

InitInstance

    Must override init instance to perform UI thread initialization
        
Arguments:

        
Return Value:
    
    TRUE on build start message loop. FALSE otherwise

    
Author:

    Chris Dudley 2/27/1997

--*/
BOOL CSCStatusDlgThrd::InitInstance( void )
{
    INT_PTR nResult = -1; // error creating dialog
    LONG lReturn = SCARD_S_SUCCESS;
    SCARDCONTEXT hSCardContext = NULL;

    // Acquire context with resource manager
    lReturn = SCardEstablishContext(    SCARD_SCOPE_USER,
                                        NULL,
                                        NULL,
                                        &hSCardContext);
    if (lReturn != SCARD_S_SUCCESS)
    {
        nResult = IDCANCEL;
    }
    else
    {
#ifdef ISOLATION_AWARE_ENABLED
        CThemeContextActivator activator;
#endif

        m_StatusDlg.SetContext(hSCardContext);

        // Run the dialog as Modal

        m_fStatusDlgUp = TRUE;

        nResult = m_StatusDlg.DoModal();// if the dialog is shut down by a
                                        // cancellation of the SCARDCONTEXT,
                                        // it will return IDCANCEL
        m_fStatusDlgUp = FALSE;
    }

    // Release context
    if (NULL != hSCardContext)
    {
        SCardReleaseContext(hSCardContext);
    }

    // Post message that the thread is exiting, based on return...
    if (NULL != m_hCallbackWnd)
    {
        ::PostMessage(  m_hCallbackWnd,
                        WM_SCARD_STATUS_DLG_EXITED, // CANCELLATION (0), or ERROR (1)
                        0, 0);
    }

    AfxEndThread(0);
    return TRUE;    // to make compiler happy
}


/*++

void ShowDialog:

    Brings dialog to front if already open

Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::ShowDialog( int nCmdShow, CStringArray* paIdleList )
{
    if (m_fStatusDlgUp)
    {
        m_StatusDlg.ShowWindow(nCmdShow);
        m_StatusDlg.SetIdleList(paIdleList);
    }
}


/*++

void UpdateStatus:

    If the dialog is up, updates idle list and status text

Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::UpdateStatus( CStringArray* paIdleList )
{
    if (m_fStatusDlgUp)
    {
        m_StatusDlg.UpdateLogonLockInfo();
        m_StatusDlg.SetIdleList(paIdleList);
        m_StatusDlg.UpdateStatusText();
    }
}


/*++

void UpdateStatusText:

    If the dialog is up, updates Status Text and 

Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::UpdateStatusText( void )
{
    if (m_fStatusDlgUp)
    {
        m_StatusDlg.UpdateStatusText();
    }
}


/*++

void Close:

    Closes modal dialog if already open

Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::Close( void )
{
    // Setup for close
    if (m_fStatusDlgUp)
    {
        m_StatusDlg.EndDialog(IDOK);
    }
    m_fStatusDlgUp = FALSE;
}


/*++

void Update:

    This routine updates the UI.

Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::Update( void )
{
    // Tell the dialog to update its statmonitor, if it's up.
    if (m_fStatusDlgUp)
    {
        m_StatusDlg.RestartMonitor();
    }

    // Do other updating
    UpdateStatusText();
}


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg dialog
//

CSCStatusDlg::CSCStatusDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CSCStatusDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSCStatusDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDI_SC_READERLOADED_V2);

    // Other initialization
    m_fEventsGood = FALSE;
    m_hSCardContext = NULL;
    m_aIdleList.RemoveAll();

    UpdateLogonLockInfo();
}

void CSCStatusDlg::UpdateLogonLockInfo(void)
{
    m_pstrLogonReader = &(((CSCStatusApp*)AfxGetApp())->m_strLogonReader);
    m_pstrRemovalText = &(((CSCStatusApp*)AfxGetApp())->m_strRemovalText);
    m_fLogonLock = (!(m_pstrLogonReader->IsEmpty()));
}

void CSCStatusDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSCStatusDlg)
    DDX_Control(pDX, IDC_SCARD_LIST, m_SCardList);
    DDX_Control(pDX, IDC_ALERT, m_btnAlert);
    DDX_Control(pDX, IDC_INFO, m_ediInfo);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSCStatusDlg, CDialog)
    //{{AFX_MSG_MAP(CSCStatusDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_WM_CLOSE()
    ON_MESSAGE( WM_READERSTATUSCHANGE, OnReaderStatusChange )
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_ALERT, OnAlertOptions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg Implementation


/*++

BOOL SetContext:

    Sets the Context with the resource manager
    
Arguments:

    SCardContext - the context
        
Return Value:
    
    None.

Author:

    Chris Dudley 3/6/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::SetContext(SCARDCONTEXT hSCardContext)
{
    m_hSCardContext = hSCardContext;
}


/*++

void CleanUp:

    Routine cleans up for exit
    
Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 3/11/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::CleanUp ( void )
{
    m_monitor.Stop();

    m_SCardList.DeleteAllItems();
}



/*++

void SetIdleList:

    Make a local copy of the app's list of readers with idle cards.

Notes:
--*/
void CSCStatusDlg::SetIdleList(CStringArray* paIdleList)
{
    m_aIdleList.Copy(*paIdleList);
    long lResult = UpdateSCardListCtrl();
}


/*++

void UpdateStatusText:

    Reflect card usage status in text.  (alert message, howto, etc.)

Notes:
    Not localization friendly.  Move strings to resources.
--*/
void CSCStatusDlg::UpdateStatusText( void )
{
    CString str;
    if (k_State_CardIdle == ((CSCStatusApp*)AfxGetApp())->m_dwState)
    {
        str = _T("A smart card has been left idle.  You may safely remove it now.");
    }
    else
    {
        str = _T("Click the button on the left to change your alert options.");
    }
    m_ediInfo.SetWindowText(str);
}


/*++

void InitSCardListCtrl:

    This routine sets up the CListCtrl properly for display
        
Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 3/6/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::InitSCardListCtrl( void )
{
    CString strHeader;
    CImageList imageList;
    HICON hicon;

    // Create columns in list control
    strHeader.LoadString(IDS_SC_READER);
    m_SCardList.InsertColumn(READER_COLUMN,
                            strHeader,
                            LVCFMT_LEFT,
                            100,
                            -1);

    strHeader.LoadString(IDS_SC_CARDSTATUS);
    m_SCardList.InsertColumn(STATUS_COLUMN,
                            strHeader,
                            LVCFMT_LEFT,
                            600,
                            -1);

    strHeader.LoadString(IDS_SC_CARD);
    m_SCardList.InsertColumn(CARD_COLUMN,
                            strHeader,
                            LVCFMT_LEFT,
                            100,
                            -1);

    // Create the image list & give it to the list control
    imageList.Create (  IMAGE_WIDTH,
                        IMAGE_HEIGHT,
                        TRUE,               // list does not include masks
                        NUMBER_IMAGES,
                        0);                 // list won't grow

    // Build the list
    for (int ix = 0; ix < NUMBER_IMAGES; ix++ )
    {
        // Load icon and add it to image list
        hicon = ::LoadIcon(AfxGetInstanceHandle(),
                            MAKEINTRESOURCE(IMAGE_LIST_IDS[ix]) );
        imageList.Add(hicon);
    }

    // Be sure that all the small icons were added.
    _ASSERTE(imageList.GetImageCount() == NUMBER_IMAGES);

    m_SCardList.SetImageList(&imageList, (int) LVSIL_SMALL);

    imageList.Detach(); // leave the images intact when we go out of scope
}


/*++

LONG UpdateSCardListCtrl:

    This routine updates the list box display.
        
Arguments:

    None.
        
Return Value:
    
    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:
    
    1. Strings need to be converted from type stored in the smartcard
    thread help classes to this dialog's build type (i.e. UNICODE/ANSI)!!!!

--*/
LONG CSCStatusDlg::UpdateSCardListCtrl( void )
{
    LONG lReturn = SCARD_S_SUCCESS;
    LONG lMoreReaders = SCARD_S_SUCCESS;
    CSCardReaderState* pReader;
    int nImage = 0;
    LV_ITEM lv_item;
    CString strCardStatus, strCardName;

    //
    // If the status monitor is not running,
    // Don't bother to update SCardListCtrl
    // If there used to be readers, display an error and shut down dialog
    //

    if (CScStatusMonitor::running != m_monitor.GetStatus())
    {
        m_SCardList.EnableWindow(FALSE);

        DoErrorMessage();
        return lReturn;
    }

    // Setup LV_ITEM struct
    lv_item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;

    // Remove old items from list if required
    m_SCardList.DeleteAllItems();

    //
    // Update the reader information
    //

    m_monitor.GetReaderStatus(m_aReaderState);

    //
    // Recreate the items in the reader list (UI)
    //

    int nNumReaders = (int)m_aReaderState.GetSize();
    for(int nIndex = 0; nIndex < nNumReaders; nIndex++)
    {
        // Setup struct for system reader list
        pReader = m_aReaderState[nIndex];

        lv_item.state = 0;
        lv_item.stateMask = 0;
        lv_item.iItem = nIndex;
        lv_item.iSubItem = 0;
        lv_item.pszText = _T("");
        lv_item.cchTextMax = MAX_ITEMLEN;
        lv_item.iImage = (int)READEREMPTY;

        if (NULL != pReader)
        {
            lv_item.pszText = (LPTSTR)(LPCTSTR)((m_aReaderState[nIndex])->strReader);

            // Get the card status: image
            DWORD dwState = (m_aReaderState[nIndex])->dwState;
            if (dwState == SC_STATUS_NO_CARD)
            {
                lv_item.iImage = (int)READEREMPTY;
            }
            else if (dwState == SC_STATUS_ERROR)
            {
                lv_item.iImage = (int)READERERROR;
            }
            else
            {
                // normally, this would be a "card loaded"...
                lv_item.iImage = (int)READERLOADED;

                // ...unless the card is the logon/locked card or idle
                if (m_fLogonLock && 
                    (0 == m_pstrLogonReader->Compare((m_aReaderState[nIndex])->strReader)))
                {
                    lv_item.iImage = (int)READERLOCK;
                }
                else
                {
                    for (int n1=(int)m_aIdleList.GetUpperBound(); n1>=0; n1--)
                    {
                        if (m_aIdleList[n1] == (m_aReaderState[nIndex])->strReader)
                        {
                            lv_item.iImage = (int)READERINFO;
                            break;
                        }
                    }
                }
            }

            // Add Reader Item
            m_SCardList.InsertItem(&lv_item);

            // Add Card Name sub item
            if (dwState != SC_STATUS_NO_CARD && dwState != SC_STATUS_ERROR)
            {
                // Set card name if not available
                strCardName = (LPCTSTR)(m_aReaderState[nIndex])->strCard;
                if (strCardName.IsEmpty())
                {
                    strCardName.LoadString(IDS_SC_NAME_UNKNOWN);
                }
                m_SCardList.SetItemText(nIndex,
                                        CARD_COLUMN,
                                        strCardName);
            }

            // Add Card Status sub item
            ASSERT(dwState >= SC_STATUS_FIRST && dwState <= SC_STATUS_LAST);
            strCardStatus.LoadString(CARD_STATUS_IDS[dwState]);

            if (m_fLogonLock && 
                (0 == m_pstrLogonReader->Compare((m_aReaderState[nIndex])->strReader)))
            {
                CString strTemp = *m_pstrRemovalText + strCardStatus;
                strCardStatus = strTemp;
            }

            m_SCardList.SetItemText(nIndex,
                                    STATUS_COLUMN,
                                    strCardStatus);

            strCardStatus.Empty();
            strCardName.Empty();
        }       

    }

    // If we got this far, things are OK.  Make sure the window is enabled.
    m_SCardList.EnableWindow(TRUE);

    return lReturn;
}


/*++

void RestartMonitor:

    This routine forces the monitor to refresh its list of readers.
        
Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Amanda Matlosz 11/04/1998

Notes:
    

--*/
void CSCStatusDlg::RestartMonitor( void )
{
    m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);
}


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg message handlers
//


/*++

void OnInitDialog:

    Performs dialog initialization.

Arguments:

    None.
        
Return Value:
    
    TRUE if successful and dialog should be displayed. FALSE otherwise.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
BOOL CSCStatusDlg::OnInitDialog()
{
    LONG lReturn = SCARD_S_SUCCESS;

    CDialog::OnInitDialog();

    //
    // Initialize the CScStatusMonitor
    //

    m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);

    //
    // Initialize the list control -- whether or not the monitor has started!
    //

    InitSCardListCtrl();

    lReturn = UpdateSCardListCtrl();

    //
    // Show the dialog IFF the above succeeded
    //

    if (SCARD_S_SUCCESS == lReturn)
    {
        // Set the status text
        UpdateStatusText();

        // Set the icon for this dialog.  The framework does this automatically
        //  when the application's main window is not a dialog

        SetIcon(m_hIcon, TRUE);         // Set big icon
        SetIcon(m_hIcon, FALSE);        // Set small icon
        
        // set icon for Alerts button
        HICON hIcon = AfxGetApp()->LoadIcon(IDI_SC_INFO);
        SendDlgItemMessage(IDC_ALERT, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

        // Center the dialog and bring it to top
        CenterWindow();
        SetWindowPos(   &wndTop,
                        0,0,0,0,
                        SWP_NOMOVE | SWP_NOSIZE);
        SetActiveWindow();

        // Set Parent to desktop
        SetParent(NULL);
    }
    else
    {
        //
        // If any of the initialization depending on the resource manager failed,
        // give up and report a death-due-to-some-error to the caller
        //

        PostMessage(WM_CLOSE, 0, 0);  // need to CANCEL, instead of close...
        TRACE_CATCH_UNKNOWN(_T("OnInitDialog"));
    }

    return TRUE;  // return TRUE  unless you set the focus to a control
}


/*++

void OnPaint:

    Used to paint dialog. In this case, used to draw the icon for the dialog
    while minimized/maximized.

Arguments:

    None.
        
Return Value:
    
    None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}


/*++

void OnQueryDragIcon:

    The system calls this to obtain the cursor to display while the user drags
    the minimized window.       

Arguments:

    None.
        
Return Value:
    
    HCURSOR handle to cursor to display

Author:

    Chris Dudley 7/30/1997

Note:

--*/
HCURSOR CSCStatusDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}


/*++

void DestroyWindow:

    This is called by MFC whenever the dialog is closed, whether that is
    through WM_CLOSE (sysmenu "X") or EndDialog(IDOK/IDCANCEL)...

Arguments:

    None.
        
Return Value:
    
    Base class version of DestroyWindow.

Author:

    Amanda Matlosz 4/29/98

Note:

--*/
BOOL CSCStatusDlg::DestroyWindow()
{
    CleanUp();

    return CDialog::DestroyWindow();
}


/*++

void OnReaderStatusChange:

    This message handler is called by the status thread when smartcard status
    has changed.
        
Arguments:

    None.
        
Return Value:
    
    None

Author:

    Chris Dudley 3/9/1997

Revision History:

    Chris Dudley 5/13/1997

Note:

    1. No formal parameters are declared. These are not used and
    will stop compiler warnings from being generated.

--*/
LONG CSCStatusDlg::OnReaderStatusChange( UINT , LONG )
{

    // Update the display
    UpdateSCardListCtrl();

    return 0;
}



/*++
allow user to set alert options (sound, pop-up, neither)
--*/
void CSCStatusDlg::OnAlertOptions()
{
    COptionsDlg dlg;
#ifdef ISOLATION_AWARE_ENABLED
    CThemeContextActivator activator;
#endif

    dlg.DoModal();
}
/*++

void DoErrorMessage:

    This is a helper routine to keep the UI stuff in one place and make sure
    the same error messages are handled consistently throughout.
        
Arguments:

    None.
        
Return Value:
    
    None

Author:

    Amanda Matlosz  5/21/98

Revision History:


Note:

    1. Consider taking an error code as well as m_monitor.GetStatus()

--*/
void CSCStatusDlg::DoErrorMessage( void )
{
    CString strMsg;
    BOOL fShutDownDlg = FALSE;

    switch(m_monitor.GetStatus())
    {
    case CScStatusMonitor::no_service:
        fShutDownDlg = TRUE;
        strMsg.LoadString(IDS_NO_SYSTEM_STATUS);
        break;

    case CScStatusMonitor::no_readers:
        // for now, do nothing!
        break;

    case CScStatusMonitor::stopped:
        // do nothing!  This is a clean stop on the way to shutting down.
        break;

    case CScStatusMonitor::uninitialized:
    case CScStatusMonitor::unknown:
    case CScStatusMonitor::running:
        fShutDownDlg = TRUE;
        strMsg.LoadString(IDS_UNKNOWN_ERROR);   
    }

    if (!strMsg.IsEmpty())
    {
        CString strTitle;
        strTitle.LoadString(IDS_TITLE_ERROR);
        MessageBox(strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
    }

    if (fShutDownDlg)
    {
        PostMessage(WM_CLOSE, 0, 0);
    }
}

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog


COptionsDlg::COptionsDlg(CWnd* pParent /*=NULL*/)
    : CDialog(COptionsDlg::IDD, pParent)
{
    BOOL fSound = FALSE;
    BOOL fDlg = FALSE;

    switch(((CSCStatusApp*)AfxGetApp())->m_dwAlertOption)
    {
        case k_AlertOption_IconSound:
            fSound = TRUE;
            break;
        case k_AlertOption_IconSoundMsg:
            fSound = TRUE;
        case k_AlertOption_IconMsg:
            fDlg = TRUE;
            break;
    }

    //{{AFX_DATA_INIT(COptionsDlg)
    m_fDlg = fDlg;
    m_fSound = fSound;
    //}}AFX_DATA_INIT
}


void COptionsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COptionsDlg)
    DDX_Check(pDX, IDC_DIALOG, m_fDlg);
    DDX_Check(pDX, IDC_SOUND, m_fSound);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsDlg, CDialog)
    //{{AFX_MSG_MAP(COptionsDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg message handlers

void COptionsDlg::OnOK() 
{
    // use status of check boxes to set alert options state for app
    UpdateData(TRUE);

    if (TRUE == m_fSound)
    {
        if (TRUE == m_fDlg)
        {
            ((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconSoundMsg;
        }
        else
        {
            ((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconSound;
        }
    }
    else if (TRUE == m_fDlg)
    {
        ((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconMsg;
    }
    else
    {
        ((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconOnly;
    }
    
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\miscdef.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MiscDef.h

Abstract:

	This file contains miscellanious definitions, including the debug trace macros
	written by Chris Dudley

Author:

    Amanda Matlosz 12/15/97

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

  intended only for use in the scarddlg project

--*/

#ifndef __MISC_H__
#define __MISC_H__

#ifdef _DEBUG
	#define TRACE_STR(name,sz) \
				TRACE(_T("SCardDlg.DLL: %s: %s\n"), name, sz)
	#define TRACE_CODE(name,code) \
				TRACE(_T("SCardDlg.DLL: %s: error = 0x%x\n"), name, code)
	#define TRACE_CATCH(name,code)		TRACE_CODE(name,code)
	#define TRACE_CATCH_UNKNOWN(name)	TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
	#define TRACE_STR(name,sz)			((void)0)
	#define TRACE_CODE(name,code)		((void)0)
	#define TRACE_CATCH(name,code)		((void)0)
	#define TRACE_CATCH_UNKNOWN(name)	((void)0)
#endif  // _DEBUG

#endif // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\chngpdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       chngpdlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_CHANGEPINDLG_H__0CB030DC_0631_11D2_BEDB_0000F87A49E0__INCLUDED_)
#define AFX_CHANGEPINDLG_H__0CB030DC_0631_11D2_BEDB_0000F87A49E0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// chngpdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog

class CChangePinDlg : public CDialog
{
// Construction
public:
	CChangePinDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CChangePinDlg)
	enum { IDD = IDD_CHANGE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

public:
	bool SetAttributes(LPCHANGEPIN pPinPrompt) { return false; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangePinDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CChangePinDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CGetPinDlg dialog

class CGetPinDlg : public CDialog
{
// Construction
public:
	CGetPinDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGetPinDlg)
	enum { IDD = IDD_ENTER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

public:
	bool SetAttributes(LPPINPROMPT pPinPrompt) { return false; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetPinDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

protected:

	// Generated message map functions
	//{{AFX_MSG(CGetPinDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHANGEPINDLG_H__0CB030DC_0631_11D2_BEDB_0000F87A49E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scarddlg.rc
//
#define IDS_SC_UNKNOWN_NO               1
#define IDS_SC_KNOWN_INCORRECT          2
#define IDS_SC_DEAD                     3
#define IDS_SC_BUSY                     4
#define IDS_SC_STATUS_NOT_IN_USE        6
#define IDS_SC_NAME_UNKNOWN             7
#define IDHELP                          9
#define IDS_SC_CONNECT_FAILED           10
#define IDS_SC_SELECT                   11
#define IDS_SC_TITLE_ERROR              12
#define IDS_SC_FOUND                    13
#define IDS_SC_FOUND_BUSY               14
#define IDS_SC_READER                   15
#define IDS_SC_CARDSTATUS               16
#define IDS_SC_CARD                     17
#define IDS_SC_NOMATCH                  18
#define IDS_DETAILS_SHOW                21
#define IDS_DETAILS_HIDE                22
#define IDS_DETAILS_CAP                 23
#define IDS_READERS_CAP                 24
#define IDS_NAME_CAP                    25
#define IDS_STATUS_CAP                  26
#define IDS_SC_RM_ERR                   27
#define IDS_UNKNOWN_ERROR               28
#define IDS_SC_NO_READERS               29
#define IDS_SC_STATUS_NO_CARD           30
#define IDS_SC_STATUS_UNKNOWN           31
#define IDS_SC_STATUS_AVAILABLE         32
#define IDS_SC_STATUS_SHARED            33
#define IDS_SC_STATUS_IN_USE            34
#define IDS_SC_STATUS_ERROR             35
#define IDS_PROMPT_ONECARD              36
#define IDS_PROMPT_CARDS                37
#define IDS_SC_CANT_USE                 38
#define IDS_SC_PROMPT_ANYCARD           39
#define IDD_SCARDDLG_BAR                104
#define IDD_SCARDDLG1                   105
#define IDD_SCARDDLG                    129
#define IDI_SC_WRONGCARD                140
#define IDI_SC_READERERR                141
#define IDI_SC_READEREMPTY_V2           142
#define IDI_SC_READERLOADED_V2          143
#define IDI_SC_CARD                     144
#define IDI_SC_CARDUNKNOWN              145
#define IDD_ENTER                       146
#define IDD_CHANGE                      147
#define IDC_DLGBAR                      1000
#define IDC_BUTTON_BOTTOM               1001
#define IDC_READERS                     1001
#define IDC_NAME                        1003
#define IDC_STATUS                      1004
#define IDC_DETAILS                     1005
#define IDC_SCARD_LIST                  1006
#define IDC_CARDNAME                    1007
#define IDC_GROUPDROPLIST               1008
#define IDC_SEARCH_LIST                 1009
#define IDC_HELP_TEXT                   1010
#define IDC_CARD_PIC                    1013
#define IDC_PROMPT                      1014
#define IDC_USERICON                    1015
#define IDC_DETAILS_CAPTION             1016
#define IDC_READERS_CAPTION             1017
#define IDC_NAME_CAPTION                1018
#define IDC_STATUS_CAPTION              1019
#define IDC_EDIT1                       1020
#define IDC_CHECK1                      1021
#define IDC_EDIT2                       1021
#define IDC_EDIT3                       1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        148
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scdlg.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCDlg

Abstract:

	This file defines the CSCardDlgApp class for the SmartCard
	Common Control DLL
	
Author:

    Chris Dudley 2/27/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:


Notes:

--*/

#ifndef __SCDLG_H__
#define __SCDLG_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
//
// CSCardDlgApp
//

class CSCardDlgApp : public CWinApp
{
public:
	CSCardDlgApp();

// Overrides

	BOOL InitInstance();

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSCardDlgApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CSCardDlgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

#endif //__SCDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\schlparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       schlparr.h
//
//--------------------------------------------------------------------------

#ifndef _SC_HELP_ARR_
#define _SC_HELP_ARR_

#define	IDH_DLG1_DETAILS_BTN	70009050
#define	IDH_SCBAR_NAME	70009076
#define	IDH_SCBAR_READERS	70009075
#define	IDH_SCBAR_STATUS	70009077


const DWORD g_aHelpIDs_IDD_SCARDDLG_BAR[]=
{
	IDC_STATUS,IDH_SCBAR_STATUS,
	IDC_NAME,IDH_SCBAR_NAME,
	IDC_READERS,IDH_SCBAR_READERS,
	0,0
};

const DWORD g_aHelpIDs_IDD_SCARDDLG1[]=
{
	IDC_DETAILS,IDH_DLG1_DETAILS_BTN,
	0,0
};

#endif // _SC_HELP_ARR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scarddlg.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardDlg

Abstract:

    This file contains the outline implementation of the DLL exports
    for the Smartcard Common Dialogs
    
Author:

    Chris Dudley 2/27/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    Amanda Matlosz 07/09/1998   incorporated new select card,
                                get pin and change pin dlgs.

Notes:

--*/


/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include "stdafx.h"
#include <atlconv.cpp>
#include "resource.h"
#include "miscdef.h"
#include "SCDlg.h"
#include "ScSearch.h"
#include "ScInsDlg.h"
#include "chngpdlg.h"

#include "ScUIDlg.h" // will someday be just <winscard.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Decls -- Helper functions defined @ eof
void MString2CommaList(CString& str, LPWSTR szmString);
void MString2CommaList(CString& str, LPSTR szmString);

/////////////////////////////////////////////////////////////////////////////
// CSCardDlgApp

BEGIN_MESSAGE_MAP(CSCardDlgApp, CWinApp)
    //{{AFX_MSG_MAP(CSCardDlgApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*++

CSCardDlgApp:

    Construction.
        
Arguments:

        
Return Value:

    
Author:

    Chris Dudley 2/27/1997

--*/
CSCardDlgApp::CSCardDlgApp()
{

}

/////////////////////////////////////////////////////////////////////////////
//
// The one CSCardDlgApp object
//

CSCardDlgApp theApp;


/*++

InitInstance:

    Override for the instance initializaion.
        
Arguments:

    None
        
Return Value:

    TRUE on success; FALSE otherwise resulting in DLL NOT be loaded.
    
Author:

    Chris Dudley 2/27/1997

--*/
BOOL CSCardDlgApp::InitInstance()
{
    BOOL fResult = FALSE;

    // Disable all DLL notifications...Force exported API entry point.
    fResult = DisableThreadLibraryCalls(m_hInstance);

    _ASSERTE(fResult); // DisableThreadLibraryCalls failed; can't init dll

    return fResult;
}

/////////////////////////////////////////////////////////////////////////////
//
// Exported APIs from the DLL
//


/*++

GetOpenCardName:

    This is the SDK v1.0 entry point routine to open the common dialog box.
    It has been retained for backwards compatibility; it is now a wrapper
    call for GetOpenCardNameEx().
        
Arguments:

    pOCNA - Pointer to an ANSI open card name structure.
    -or-
    pOCNW - Popinter to a UNICODE open card name structure
        
Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.
    
Author:

    Chris Dudley 2/27/1997

--*/

LONG WINAPI GetOpenCardNameA(LPOPENCARDNAMEA pOCNA)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    USES_CONVERSION;

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    OPENCARDNAMEA_EX openCardNameEx;
    OPENCARD_SEARCH_CRITERIAA openCardSearchCriteria;

    try
    {
        // Check Params
        if (NULL == pOCNA)
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }
        if (pOCNA->dwStructSize != sizeof(OPENCARDNAMEA))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }


        // Translate the OPENCARDNAME struct to OPENCARDNAME_EX
        ZeroMemory((PVOID)&openCardNameEx, sizeof(openCardNameEx));
        openCardNameEx.dwStructSize = sizeof(openCardNameEx);

        openCardNameEx.hwndOwner = pOCNA->hwndOwner;
        openCardNameEx.hSCardContext = pOCNA->hSCardContext;
        openCardNameEx.lpstrTitle = pOCNA->lpstrTitle;
        openCardNameEx.dwFlags = pOCNA->dwFlags;
        openCardNameEx.lpstrRdr = pOCNA->lpstrRdr;
        openCardNameEx.nMaxRdr = pOCNA->nMaxRdr;
        openCardNameEx.lpstrCard = pOCNA->lpstrCard;
        openCardNameEx.nMaxCard = pOCNA->nMaxCard;
        openCardNameEx.lpfnConnect = pOCNA->lpfnConnect;
        openCardNameEx.pvUserData = pOCNA->pvUserData;
        openCardNameEx.dwShareMode = pOCNA->dwShareMode;
        openCardNameEx.dwPreferredProtocols = pOCNA->dwPreferredProtocols;

        // Build a OPENCARD_SEARCH_CRITERIA struct
        ZeroMemory((PVOID)&openCardSearchCriteria, sizeof(openCardSearchCriteria));
        openCardSearchCriteria.dwStructSize = sizeof(openCardSearchCriteria);

        openCardSearchCriteria.lpstrGroupNames = pOCNA->lpstrGroupNames;
        openCardSearchCriteria.nMaxGroupNames = pOCNA->nMaxGroupNames;
        openCardSearchCriteria.rgguidInterfaces = pOCNA->rgguidInterfaces;
        openCardSearchCriteria.cguidInterfaces = pOCNA->cguidInterfaces;
        openCardSearchCriteria.lpstrCardNames = pOCNA->lpstrCardNames;
        openCardSearchCriteria.nMaxCardNames = pOCNA->nMaxCardNames;
        openCardSearchCriteria.lpfnCheck = pOCNA->lpfnCheck;
        openCardSearchCriteria.lpfnConnect = pOCNA->lpfnConnect;
        openCardSearchCriteria.lpfnDisconnect = pOCNA->lpfnDisconnect;
        openCardSearchCriteria.pvUserData = pOCNA->pvUserData;
        openCardSearchCriteria.dwShareMode = pOCNA->dwShareMode;
        openCardSearchCriteria.dwPreferredProtocols = pOCNA->dwPreferredProtocols;

        openCardNameEx.pOpenCardSearchCriteria = &openCardSearchCriteria;

        // Create a "search description" based on requested card names
        CString strPrompt;
        strPrompt.Empty();
        if (NULL != pOCNA->lpstrCardNames)
        {
            DWORD cNames = AnsiMStringCount(pOCNA->lpstrCardNames);

            if (1 == cNames)
            {
                strPrompt.Format(
                    IDS_PROMPT_ONECARD,
                    A2W(pOCNA->lpstrCardNames));
            }
            else if (1 < cNames)
            {

                CString strCommaList;
                MString2CommaList(strCommaList, pOCNA->lpstrCardNames);

                strPrompt.Format(
                    IDS_PROMPT_CARDS,
                    strCommaList);
            }
        }
        if (!strPrompt.IsEmpty())
        {
            openCardNameEx.lpstrSearchDesc = (LPCSTR)W2A(strPrompt);
        }

        // Call the updated routine
        lReturn = SCardUIDlgSelectCardA(&openCardNameEx);

        // Update the (const) return values of the OPENCARDNAME struct
        pOCNA->nMaxRdr = openCardNameEx.nMaxRdr;
        pOCNA->nMaxCard = openCardNameEx.nMaxCard;
        pOCNA->dwActiveProtocol = openCardNameEx.dwActiveProtocol;
        pOCNA->hCardHandle = openCardNameEx.hCardHandle;

    }
    catch (LONG hr)
    {
        lReturn = hr;
        TRACE_CATCH(_T("GetOpenCardNameA"),hr);
    }

    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("GetOpenCardNameA"));
    }

    return lReturn;
}

LONG WINAPI GetOpenCardNameW(LPOPENCARDNAMEW pOCNW)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    OPENCARDNAMEW_EX openCardNameEx;
    OPENCARD_SEARCH_CRITERIAW openCardSearchCriteria;

    try
    {
        // Check Params
        if (NULL == pOCNW)
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }
        if (pOCNW->dwStructSize != sizeof(OPENCARDNAMEW))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }

        // Translate the OPENCARDNAME struct to OPENCARDNAME_EX
        ZeroMemory((PVOID)&openCardNameEx, sizeof(openCardNameEx));
        openCardNameEx.dwStructSize = sizeof(openCardNameEx);

        openCardNameEx.hwndOwner = pOCNW->hwndOwner;
        openCardNameEx.hSCardContext = pOCNW->hSCardContext;
        openCardNameEx.lpstrTitle = pOCNW->lpstrTitle;
        openCardNameEx.dwFlags = pOCNW->dwFlags;
        openCardNameEx.lpstrRdr = pOCNW->lpstrRdr;
        openCardNameEx.nMaxRdr = pOCNW->nMaxRdr;
        openCardNameEx.lpstrCard = pOCNW->lpstrCard;
        openCardNameEx.nMaxCard = pOCNW->nMaxCard;
        openCardNameEx.lpfnConnect = pOCNW->lpfnConnect;
        openCardNameEx.pvUserData = pOCNW->pvUserData;
        openCardNameEx.dwShareMode = pOCNW->dwShareMode;
        openCardNameEx.dwPreferredProtocols = pOCNW->dwPreferredProtocols;

        // Build a OPENCARD_SEARCH_CRITERIA struct
        ZeroMemory((PVOID)&openCardSearchCriteria, sizeof(openCardSearchCriteria));
        openCardSearchCriteria.dwStructSize = sizeof(openCardSearchCriteria);

        openCardSearchCriteria.lpstrGroupNames = pOCNW->lpstrGroupNames;
        openCardSearchCriteria.nMaxGroupNames = pOCNW->nMaxGroupNames;
        openCardSearchCriteria.rgguidInterfaces = pOCNW->rgguidInterfaces;
        openCardSearchCriteria.cguidInterfaces = pOCNW->cguidInterfaces;
        openCardSearchCriteria.lpstrCardNames = pOCNW->lpstrCardNames;
        openCardSearchCriteria.nMaxCardNames = pOCNW->nMaxCardNames;
        openCardSearchCriteria.lpfnCheck = pOCNW->lpfnCheck;
        openCardSearchCriteria.lpfnConnect = pOCNW->lpfnConnect;
        openCardSearchCriteria.lpfnDisconnect = pOCNW->lpfnDisconnect;
        openCardSearchCriteria.pvUserData = pOCNW->pvUserData;
        openCardSearchCriteria.dwShareMode = pOCNW->dwShareMode;
        openCardSearchCriteria.dwPreferredProtocols = pOCNW->dwPreferredProtocols;

        openCardNameEx.pOpenCardSearchCriteria = &openCardSearchCriteria;

        // Create a "search description" based on requested card names
        CString strPrompt;
        strPrompt.Empty();
        if (NULL != pOCNW->lpstrCardNames)
        {
            DWORD cNames = MStringCount(pOCNW->lpstrCardNames);

            if (1 == cNames)
            {
                strPrompt.Format(
                    IDS_PROMPT_ONECARD,
                    pOCNW->lpstrCardNames);
            }
            else if (1 < cNames)
            {

                CString strCommaList;
                MString2CommaList(strCommaList, pOCNW->lpstrCardNames);

                strPrompt.Format(
                    IDS_PROMPT_CARDS,
                    strCommaList);
            }
        }
        if (!strPrompt.IsEmpty())
        {
            openCardNameEx.lpstrSearchDesc = (LPCWSTR)strPrompt;
        }

        // Call the updated routine
        lReturn = SCardUIDlgSelectCardW(&openCardNameEx);

        // Update the (const) return values of the OPENCARDNAME struct
        pOCNW->nMaxRdr = openCardNameEx.nMaxRdr;
        pOCNW->nMaxCard = openCardNameEx.nMaxCard;
        pOCNW->dwActiveProtocol = openCardNameEx.dwActiveProtocol;
        pOCNW->hCardHandle = openCardNameEx.hCardHandle;

    }
    catch (LONG hr)
    {
        lReturn = hr;
        TRACE_CATCH(_T("GetOpenCardNameW"),hr);
    }

    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("GetOpenCardNameW"));
    }

    return lReturn;
}


/*++

LONG SCardDlgExtendedError:

    This is an old entry point for getting extended errors from the
    dialog. Please use the lLastError member of the OPENCARDNAME struct.
        
Arguments:

    None.
        
Return Value:

    None.
    
Author:

    Chris Dudley 2/27/1997

--*/
LONG WINAPI SCardDlgExtendedError (void)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LONG        lReturn = E_NOTIMPL;

    // NO LONGER IMPLEMENTED

    return lReturn;
}


/*++

SCardUIDlgSelectCard:

    This is the entry point routine to open the common dialog box, introduced
    in the Microsoft Smart Card SDK v1.x.
        
Arguments:

    pOCNA - Pointer to an ANSI open card name (ex) structure.
    -or-
    pOCNW - Pointer to a UNICODE open card name (ex) structure.
        
Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.
    
Author:

    Amanda Matlosz  6/11/98

--*/

LONG WINAPI SCardUIDlgSelectCardA(LPOPENCARDNAMEA_EX pOCNA)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    CWnd wndParent;
    BOOL fEnableUI = FALSE;
    INT_PTR nResponse = IDCANCEL;
    int nResult = 0;
    DWORD dwOKCards = 0;

    try
    {
        // Check Params
        if (!CheckOCN(pOCNA))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }

        // Determine names of all acceptable cards
        CTextMultistring mstrOKCards;
        ListAllOKCardNames(pOCNA, mstrOKCards);
                
        //
        // Do a silent search intially to determine # of suitable cards
        // currently available and/or connect to a card if min or no UI
        //
        lReturn = NoUISearch(pOCNA, &dwOKCards, (LPCSTR)mstrOKCards);

        //
        // If we haven't successfully selected a card and we can show UI,
        // raise the dialog
        //
        if (SCARD_S_SUCCESS != lReturn && !(pOCNA->dwFlags & SC_DLG_NO_UI))
        {
            // Now we can init the common dialog
            wndParent.Attach(pOCNA->hwndOwner);
            CScInsertDlg dlgCommon(&wndParent);

            lReturn = dlgCommon.Initialize(pOCNA, dwOKCards, (LPCSTR)mstrOKCards);
            if(SCARD_S_SUCCESS != lReturn)
            {
                throw lReturn;
            }

            nResponse = dlgCommon.DoModal();

            // If cancel/closed return error
            switch (nResponse)
            {
            case IDOK: // absolutely sure of total success!
                break;
            case IDCANCEL:
                lReturn = dlgCommon.m_lLastError;
                if (0 == lReturn)
                    lReturn = SCARD_W_CANCELLED_BY_USER; // not SCARD_E_CANCELLED
                break;
            default:
                _ASSERTE(FALSE);
            case -1:
            case IDABORT:
                lReturn = dlgCommon.m_lLastError;
                if (0 == lReturn)
                    lReturn = SCARD_F_UNKNOWN_ERROR;
                break;
            }
        }
    }
    catch (LONG hr)
    {
        lReturn = hr;
        TRACE_CATCH(_T("SCardUIDlgSelectCardA"),hr);
    }

    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("SCardUIDlgSelectCardA"));
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return lReturn;
}


LONG WINAPI SCardUIDlgSelectCardW(LPOPENCARDNAMEW_EX pOCNW)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    CWnd wndParent;
    BOOL fEnableUI = FALSE;
    INT_PTR nResponse = IDCANCEL;
    DWORD dwOKCards = 0;

    try
    {
        // Check Params
        if (!CheckOCN(pOCNW))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }

        // Determine names of all acceptable cards
        CTextMultistring mstrOKCards;
        ListAllOKCardNames(pOCNW, mstrOKCards);

        //
        // Do a silent search intially to determine # of suitable cards and/or
        // connect to a card according to display mode (min or no UI)
        //
        lReturn = NoUISearch(pOCNW, &dwOKCards, (LPCWSTR)mstrOKCards);

        //
        // If we haven't successfully selected a card and we can show UI,
        // raise the dialog
        //
        if (SCARD_S_SUCCESS != lReturn && !(pOCNW->dwFlags & SC_DLG_NO_UI))
        {

            // Now we can init the common dialog
            wndParent.Attach(pOCNW->hwndOwner);
            CScInsertDlg dlgCommon(&wndParent);

            // Store Pointer and open dialog
            lReturn = dlgCommon.Initialize(pOCNW, dwOKCards, (LPCWSTR)mstrOKCards);
            if (SCARD_S_SUCCESS != lReturn)
            {
                throw (lReturn);
            }

            nResponse = dlgCommon.DoModal();

            // If cancel/closed return error
            switch (nResponse)
            {
            case IDOK:  // absolutely sure of total success!
                break;
            case IDCANCEL:
                if (ERROR_SUCCESS == dlgCommon.m_lLastError)
                    lReturn = SCARD_W_CANCELLED_BY_USER;
                else
                    lReturn = dlgCommon.m_lLastError;
                break;
            default:
                _ASSERTE(FALSE);
            case -1:
            case IDABORT:
                lReturn = dlgCommon.m_lLastError;
                if (0 == lReturn)
                    lReturn = SCARD_F_UNKNOWN_ERROR;
                break;
            }
        }
    }
    catch (LONG lErr)
    {
        lReturn = lErr;
        TRACE_CATCH(_T("SCardUIDlgSelectCardW"),lReturn);
    }
    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("SCardUIDlgSelectCardW"));
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return lReturn;
}


/*++

SCardUIDlgGetPIN:

        
Arguments:

        
Return Value:

    A LONG value indicating the status of the requested action.
    
Author:

    Amanda Matlosz  06/18/1998

--*/

LONG WINAPI SCardUIDlgGetPINA(LPPINPROMPT pPinPrompt)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INT_PTR nResponse = IDCANCEL; // result of DoModal.

    CWnd wndParent;
    wndParent.Attach(pPinPrompt->hwndOwner);

    CGetPinDlg dlgGetPin(&wndParent);
    if (dlgGetPin.SetAttributes(pPinPrompt))
    {
        nResponse = dlgGetPin.DoModal();
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return (LONG)nResponse;
}


/*++

SCardUIDlgChangePIN:

        
Arguments:

        
Return Value:

    A LONG value indicating the status of the requested action.
    
Author:

    Amanda Matlosz  06/18/1998

--*/

LONG WINAPI SCardUIDlgChangePINA(LPCHANGEPIN pChangePin)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INT_PTR nResponse = IDCANCEL; // result of DoModal.

    CWnd wndParent;
    wndParent.Attach(pChangePin->hwndOwner);

    CChangePinDlg dlgChangePin(&wndParent);
    if (dlgChangePin.SetAttributes(pChangePin))
    {
        nResponse = dlgChangePin.DoModal();
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return (LONG)nResponse;
}



///////////////////////////////////////////////////////////////////////////////
// Helper functions

void MString2CommaList(CString& str, LPWSTR szmString)
{
    str.Empty();

    if (NULL == szmString)
    {
        return;
    }

    LPCWSTR szm = szmString;
    szm = FirstString(szm);
    str = szm;
    for(szm = NextString(szm); NULL != szm; szm = NextString(szm))
    {
        str += ", ";
        str += szm;
    }
}

void MString2CommaList(CString& str, LPSTR szmString)
{
    DWORD cchLength = 0;
    DWORD cchConverted = 0;
    DWORD dwSts = ERROR_SUCCESS;
    LPWSTR wszStr = NULL;

    USES_CONVERSION;

    str.Empty();

    if (NULL == szmString)
        goto Ret;
    
    cchLength = MStrLen(szmString);

    cchConverted = 
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szmString,
            cchLength,
            NULL,
            0);

    wszStr = (LPWSTR) HeapAlloc(
        GetProcessHeap(), 0, cchConverted * sizeof(WCHAR));

    if (NULL == wszStr)
        goto Ret;

    MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED | MB_USEGLYPHCHARS,
        szmString,
        cchLength,
        wszStr,
        cchConverted);

    MString2CommaList(str, wszStr);

Ret:
    if (wszStr)
        HeapFree(GetProcessHeap(), 0, wszStr);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCardDlg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scinsbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsBar.cpp
//
//--------------------------------------------------------------------------

// ScInsBar.cpp : implementation file
//

#include "stdafx.h"
#include "scdlg.h"
#include "scinsdlg.h"
#include "ScInsBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScEdit special edit boxes (CardName, CardStatus)

BEGIN_MESSAGE_MAP(CScEdit, CEdit)
    //{{AFX_MSG_MAP(CScEdit)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CScEdit::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    ::WinHelp(m_hWnd, _T("SCardDlg.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG_BAR);
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertBar dialog


CScInsertBar::CScInsertBar(CWnd* pParent /*=NULL*/)
    : CDialog(CScInsertBar::IDD, pParent)
{
    m_paReaderState = NULL;
    //{{AFX_DATA_INIT(CScInsertBar)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

void CScInsertBar::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CScInsertBar)
    DDX_Control(pDX, IDC_NAME, m_ediName);
    DDX_Control(pDX, IDC_STATUS, m_ediStatus);
    DDX_Control(pDX, IDC_READERS, m_lstReaders);
    //}}AFX_DATA_MAP
}


void CScInsertBar::OnCancel()
{
    CScInsertDlg* pParent = (CScInsertDlg*)GetParent();
    _ASSERTE(NULL != pParent);
    if (NULL != pParent)
    {
        pParent->PostMessage(IDCANCEL);
    }
}

BEGIN_MESSAGE_MAP(CScInsertBar, CDialog)
    //{{AFX_MSG_MAP(CScInsertBar)
    ON_WM_DESTROY()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_READERS, OnReaderItemChanged)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScInsertBar UI & smart card methods


/*++

InitializeReaderList:

    Initialize the list control w/ large images, and set up the
    CStringArray of image (reader/card status) descriptions...

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz 07/14/1998

--*/
void CScInsertBar::InitializeReaderList(void)
{
    HICON hicon;
    CImageList imageList;
    CString str;

    // Create the image list & give it to the list control
    imageList.Create (
                        IMAGE_WIDTH,
                        IMAGE_HEIGHT,
                        TRUE,       // list does include masks
                        NUMBER_IMAGES,
                        0);                 // list won't grow

    // Build the image list
    for (int i = 0; i < NUMBER_IMAGES; i++ )
    {
        // Load icon and add it to image list
        hicon = NULL;
        hicon = ::LoadIcon (    AfxGetInstanceHandle(),
                                MAKEINTRESOURCE(IMAGE_LIST_IDS[i]) );
        if (NULL==hicon) {
            break; // what can we do?
        }
        imageList.Add (hicon);

    }

    // Be sure that all the small icons were added.
    _ASSERTE(imageList.GetImageCount() == NUMBER_IMAGES);

    m_lstReaders.SetImageList(&imageList, (int) LVSIL_NORMAL);
    imageList.Detach();
}


/*++

UpdateStatusList:

    This routine resets the list box display

Arguments:

    None.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Amanda Matlosz  06/15/1998

Notes:

    Strings need to be converted from type stored in the smartcard
    thread help classes to this dialog's build type (i.e. UNICODE/ANSI)!!!!

--*/
void CScInsertBar::UpdateStatusList(CSCardReaderStateArray* paReaderState)
{

    CString strCardStatus, strCardName;
    CSCardReaderState* pReader = NULL;
    CSCardReaderState* pSelectedRdr = NULL;
    LV_ITEM lv_item;

    //
    // Update the reader information
    //

    m_paReaderState = paReaderState;

    // reset previous knowledge re: reader/card status
    m_ediName.SetWindowText(_T(""));
    m_ediStatus.SetWindowText(_T(""));
    m_lstReaders.DeleteAllItems();

    if (NULL != m_paReaderState)
    {
        // Insert (new) items

        lv_item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lv_item.cchTextMax = MAX_ITEMLEN;

        int nNumReaders = (int)m_paReaderState->GetSize();
        for(int nIndex = 0; nIndex < nNumReaders; nIndex++)
        {
            // Setup struct for system reader list
            pReader = m_paReaderState->GetAt(nIndex);
            _ASSERTE(NULL != pReader);

            lv_item.iItem = nIndex;
            lv_item.stateMask = 0;
            lv_item.state = 0;
            lv_item.iSubItem = 0;
            lv_item.iImage = (int)READEREMPTY;
            lv_item.pszText = NULL;
            // set lparam to the reader ptr so we can fetch the readerinfo later
            lv_item.lParam = (LPARAM)pReader;

            //
            // Get the card status: image, and select OK card
            //

            if (NULL != pReader)
            {
                lv_item.pszText = (LPTSTR)(LPCTSTR)(pReader->strReader);

                DWORD dwState = pReader->dwState;
                if (dwState == SC_STATUS_NO_CARD)
                {
                    lv_item.iImage = (int)READEREMPTY;
                }
                else if (dwState == SC_STATUS_ERROR)
                {
                    lv_item.iImage = (int)READERERROR;
                }
                else
                {
                    if (pReader->fOK)
                    {
                        lv_item.iImage = (int)READERLOADED;
                    }
                    else
                    {
                        lv_item.iImage = (int)WRONGCARD;
                    }
                }

                // Select if this is a search card
                if (pReader->fOK && (NULL==pSelectedRdr))
                {
                    lv_item.state = LVIS_SELECTED | LVIS_FOCUSED;

                    // Set that a selection has occurred
                    pSelectedRdr = pReader;
                }
            }

            // Add Item
            m_lstReaders.InsertItem(&lv_item);
        }

        // indicate that the reader selection has changed
        if (NULL != pSelectedRdr)
        {
            OnReaderSelChange(pSelectedRdr);
        }
        else
        {
            // select the first item in the list
            m_lstReaders.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, 0);
            OnReaderSelChange(m_paReaderState->GetAt(0));
        }
        m_lstReaders.SetFocus(); // TODO: ?? Remove this? ??
    }
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertBar message handlers


/*++

void ShowHelp:

    Helper function for OnHelpInfo and OnContextMenu.

BOOL OnHelpInfo:

    Called by the MFC framework when the user hits F1.

void OnContextMenu

    Called by the MFC framework when the user right-clicks.

Author:

    Amanda Matlosz  03/04/1999

Note:

    These three functions work together to provide context-sensitive
    help for the insertdlg.

--*/
void CScInsertBar::ShowHelp(HWND hWnd, UINT nCommand)
{

    ::WinHelp(hWnd, _T("SCardDlg.hlp"), nCommand, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG_BAR);
}

afx_msg BOOL CScInsertBar::OnHelpInfo(LPHELPINFO lpHelpInfo)
{
    _ASSERTE(NULL != lpHelpInfo);

    ShowHelp((HWND)lpHelpInfo->hItemHandle, HELP_WM_HELP);

    return TRUE;
}

afx_msg void CScInsertBar::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    _ASSERTE(NULL != pWnd);

    ShowHelp(pWnd->m_hWnd, HELP_CONTEXTMENU);
}

void CScInsertBar::OnDestroy()
{
    // clean up image list
    m_SCardImages.DeleteImageList();

    CDialog::OnDestroy();
}


BOOL CScInsertBar::OnInitDialog()
{

    CDialog::OnInitDialog();

    //
    // prepare list control
    //

    InitializeReaderList();

    //
    // TODO: try SubclassWindow() trick. What's up with MFC?
    //
    CWnd* pEdit = NULL;
    pEdit = GetDlgItem(IDC_NAME);
    if (NULL != pEdit) m_ediName.SubclassWindow(pEdit->m_hWnd);
    pEdit = NULL;
    pEdit = GetDlgItem(IDC_STATUS);
    if (NULL != pEdit) m_ediStatus.SubclassWindow(pEdit->m_hWnd);

    return  TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*++

OnReaderItemChanged:

    Routine processes a selection change in the list control --
    if a card name is selected, it is displayed in a separate control

Arguments:

    pNMHDR - pointer to notification structure
    pResult - pointer to LRESULT

Return Value:

    Returns TRUE on success; FALSE otherwise.

Author:

    Amanda Matlosz  09/26/1998

Revision History:

--*/
void CScInsertBar::OnReaderItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    int nItem = m_lstReaders.GetNextItem(-1, LVNI_SELECTED);

    if (nItem != -1)
    {
        CSCardReaderState* pRdrSt = (CSCardReaderState*)m_lstReaders.GetItemData(nItem);
        OnReaderSelChange(pRdrSt);
    }

    *pResult = 0;
}


void CScInsertBar::OnReaderSelChange(CSCardReaderState* pSelectedRdr)
{
    _ASSERTE(pSelectedRdr);
    if (NULL != pSelectedRdr)
    {
        //
        // Change UI to show selection details
        //

        CString strStatus, strName;
        DWORD dwState = pSelectedRdr->dwState;

        strStatus.LoadString(IDS_SC_STATUS_NO_CARD + dwState - SC_STATUS_NO_CARD);

        if (dwState != SC_STATUS_NO_CARD)
        {
            strName = pSelectedRdr->strCard;
            strName.TrimLeft();
            if (strName.IsEmpty() || dwState == SC_STATUS_UNKNOWN)
            {
                strName.LoadString(IDS_SC_NAME_UNKNOWN);
            }

            if (!pSelectedRdr->fOK && (dwState >= SC_SATATUS_AVAILABLE && dwState <= SC_STATUS_EXCLUSIVE))
            {
                CString strAdd;
                strAdd.LoadString(IDS_SC_CANT_USE);
                strStatus += "  ";
                strStatus += strAdd;
            }
        }

        m_ediName.SetWindowText(strName);
        m_ediStatus.SetWindowText(strStatus);
    }

    //
    // Inform parent of change in selection, even if that sel is "NULL"
    //

    CScInsertDlg* pParent = (CScInsertDlg*)GetParent();
    _ASSERTE(NULL != pParent);
    if (NULL != pParent)
    {
        pParent->SetSelection(pSelectedRdr);
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scinsdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsDlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SCINSDLG_H__D7E6F001_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
#define AFX_SCINSDLG_H__D7E6F001_DDE8_11D1_803B_0000F87A49E0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ScInsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
//#include "statthrd.h"
#include "ScUIDlg.h" // includes winscard.h
#include "statmon.h"
#include "ScInsBar.h"


/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg dialog

class CScInsertDlg : public CDialog
{
// Construction
public:
    CScInsertDlg(CWnd* pParent = NULL);
    ~CScInsertDlg();

// Dialog Data
    //{{AFX_DATA(CScInsertDlg)
    enum { IDD = IDD_SCARDDLG1 };
    CButton m_btnDetails;
    CListCtrl m_lstReaders;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScInsertDlg)
    public:
    virtual BOOL DestroyWindow();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    LONG Initialize(LPOPENCARDNAMEA_EX pOCNA, DWORD dwNumOKCards, LPCSTR mszOKCards);
    LONG Initialize(LPOPENCARDNAMEW_EX pOCNW, DWORD dwNumOKCards, LPCWSTR mszOKCards);
    void SetSelection(CSCardReaderState* pRdrSt);

protected:

    // UI routines
    void DisplayError(UINT uiErrorMsg=IDS_UNKNOWN_ERROR);

    // data routines
    bool IsSelectionOK()
    {
        return (((NULL==m_pSelectedReader)?false:m_pSelectedReader->fOK) != 0);
    }
    bool MatchesSelection(CSCardReaderState* pRdrSt)
    {
        return (pRdrSt == m_pSelectedReader);
    }

protected:

    // UI
    HICON m_hIcon;          // Handle to the ICON
    BOOL m_fDetailsShown;
    int m_yMargin, m_SmallHeight, m_BigHeight;
    CString m_strTitle;
    CString m_strPrompt;

    CWnd* m_ParentHwnd;
    CScInsertBar* m_pSubDlg;    // a CDialog-derived object

    void MoveButton(UINT nID, int newBottom);
    void ToggleSubDialog();
    void EnableOK(BOOL fEnabled=TRUE);

    // Data
public:
    LONG                m_lLastError;       // Last error

protected:
    LPOPENCARDNAMEA_EX  m_pOCNA;
    LPOPENCARDNAMEW_EX  m_pOCNW;

    CTextMultistring m_mstrAllCards;

    CScStatusMonitor    m_monitor;          // see statmon.h
    CSCardReaderStateArray  m_aReaderState; //  "
    CSCardReaderState* m_pSelectedReader;

    CCriticalSection*   m_pCritSec;

    // Generated message map functions
    //{{AFX_MSG(CScInsertDlg)
    afx_msg LONG OnReaderStatusChange(UINT uint, LONG lParam);
    afx_msg void OnDetails();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg BOOL OnHelpInfo(LPHELPINFO lpHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
//  afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // helper function
    BOOL SameCard(CSCardReaderState* p1, CSCardReaderState* p2);
    void ShowHelp(HWND hWnd, UINT nCommand);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCINSDLG_H__D7E6F001_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scinsbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsBar.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SCINSBAR_H__D7E6F002_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
#define AFX_SCINSBAR_H__D7E6F002_DDE8_11D1_803B_0000F87A49E0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ScInsBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "statmon.h"
#include "scHlpArr.h"

/////////////////////////////////////////////////////////////////////////////
//
// Constants for (sub)dialog
//
#define     MAX_ITEMLEN         255

// Image list properties
#define     IMAGE_WIDTH         32
#define     IMAGE_HEIGHT        32
#define     NUMBER_IMAGES       5
const UINT  IMAGE_LIST_IDS[] = {IDI_SC_READERLOADED_V2,
                                IDI_SC_READEREMPTY_V2,
                                IDI_SC_WRONGCARD,
                                IDI_SC_READERERR,
                                IDI_SC_CARDUNKNOWN};
#define     READERLOADED    0
#define     READEREMPTY     1
#define     WRONGCARD       2
#define     READERERROR     3
#define     UKNOWNCARD      4

/////////////////////////////////////////////////////////////////////////////
// CScEdit -- Edit boxes that pass OnContextMenu messages to parent
class CScEdit : public CEdit
{
protected:
    // Generated message map functions
    //{{AFX_MSG(CScEdit)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CScInsertBar dialog

class CScInsertBar : public CDialog
{
// Construction
public:
    CScInsertBar(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CScInsertBar)
    enum { IDD = IDD_SCARDDLG_BAR };
    CScEdit m_ediName;
    CScEdit m_ediStatus;
    CListCtrl   m_lstReaders;
    //}}AFX_DATA

    void ResetReaderList(void);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScInsertBar)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    // UI routines
    void EnableStatusList(bool f) { m_lstReaders.EnableWindow(f); }
    void UpdateStatusList(CSCardReaderStateArray* paReaderState);

protected:

    // UI routines
    void InitializeReaderList(void);
    void OnReaderSelChange(CSCardReaderState* pSelectedRdr);

    // Data
    CImageList  m_SCardImages;
    CSCardReaderStateArray* m_paReaderState;

    // Generated message map functions
    //{{AFX_MSG(CScInsertBar)
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg void OnReaderItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
    virtual void OnCancel();
    afx_msg BOOL OnHelpInfo(LPHELPINFO lpHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // helper function
    void ShowHelp(HWND hWnd, UINT nCommand);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCINSBAR_H__D7E6F002_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scinsdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsDlg.cpp
//
//--------------------------------------------------------------------------

// ScInsDlg.cpp : implementation file
//

#include "stdafx.h"
#include <atlconv.h>
#include "resource.h"
#include "scdlg.h"
#include "ScSearch.h"
#include "ScInsDlg.h"
#include "statmon.h"
#include "scHlpArr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg dialog


CScInsertDlg::CScInsertDlg(CWnd* pParent/*=NULL*/)
    : CDialog(CScInsertDlg::IDD, pParent)
{

    // Member Initialization
    m_lLastError = SCARD_S_SUCCESS;
    m_ParentHwnd = pParent;
    m_pOCNW = NULL;
    m_pOCNA = NULL;
    m_pSelectedReader = NULL;
    m_pSubDlg = NULL;

    m_strTitle.Empty();
    m_strPrompt.Empty();
    m_mstrAllCards = "";

    //{{AFX_DATA_INIT(CScInsertDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


CScInsertDlg::~CScInsertDlg()
{
    // Stop status monitor
    m_monitor.Stop();

    // Clean up status list!
    if (0 != m_aReaderState.GetSize())
    {
        for (int i = (int)m_aReaderState.GetUpperBound(); i>=0; i--)
        {
            delete m_aReaderState[i];
        }

        m_aReaderState.RemoveAll();
    }
}


void CScInsertDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CScInsertDlg)
    DDX_Control(pDX, IDC_DETAILS, m_btnDetails);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScInsertDlg, CDialog)
    //{{AFX_MSG_MAP(CScInsertDlg)
    ON_MESSAGE( WM_READERSTATUSCHANGE, OnReaderStatusChange )
    ON_BN_CLICKED(IDC_DETAILS, OnDetails)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg data methods

/*++

LONG Initialize:

    Stores the open card name pointer in the proper internal struct.
    Determines whether to show the dialog in details or brief mode.

Arguments:

    pOCN(x) - pointer to an open card name ex struct

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Amanda Matlosz  07/09/1998

--*/

// ANSI
LONG CScInsertDlg::Initialize(LPOPENCARDNAMEA_EX pOCNA, DWORD dwNumOKCards, LPCSTR mszOKCards)
{
    _ASSERTE(NULL != pOCNA);
    if (NULL == pOCNA)
    {
        return SCARD_F_UNKNOWN_ERROR;
    }

    m_pOCNA = pOCNA;

    m_strTitle = m_pOCNA->lpstrTitle;
    m_strPrompt = m_pOCNA->lpstrSearchDesc;
    m_mstrAllCards = mszOKCards;
    m_hIcon = pOCNA->hIcon;

    // hide details if no suitable cards available, else show details
    m_fDetailsShown = (0==dwNumOKCards) ? FALSE : TRUE;

    // prepare critical section for UI routines
    m_pCritSec = new CCriticalSection();
    if (NULL == m_pCritSec)
    {
        return ERROR_OUTOFMEMORY; // TODO: is another errorcode more appropriate?
    }

	// put dialog on top
	SetForegroundWindow();

    return SCARD_S_SUCCESS;
}

//UNICODE
HRESULT CScInsertDlg::Initialize(LPOPENCARDNAMEW_EX pOCNW, DWORD dwNumOKCards, LPCWSTR mszOKCards)
{
    _ASSERTE(NULL != pOCNW);
    if (NULL == pOCNW)
    {
        return SCARD_F_UNKNOWN_ERROR;
    }

    m_pOCNW = pOCNW;

    m_strTitle = m_pOCNW->lpstrTitle;
    m_strPrompt = m_pOCNW->lpstrSearchDesc;
    m_mstrAllCards = mszOKCards;
    m_hIcon = pOCNW->hIcon;

    // hide details if no suitable cards available, else show details
    m_fDetailsShown = (0==dwNumOKCards) ? FALSE : TRUE;

    // prepare critical section for UI routines
    m_pCritSec = new CCriticalSection();
    if (NULL == m_pCritSec)
    {
        return ERROR_OUTOFMEMORY; // TODO: is another errorcode more appropriate?
    }

	// put dialog on top
	SetForegroundWindow();

    return SCARD_S_SUCCESS;
}


void CScInsertDlg::EnableOK(BOOL fEnabled)
{
    CButton* pBtn = (CButton*)GetDlgItem(IDOK);
    _ASSERTE(NULL != pBtn);

    pBtn->EnableWindow(fEnabled);

    //
    // Change prompt text accordingly and set the OK button
    // to be default if it's enabled
    //

    CString strPrompt;

    if (fEnabled)
    {
        strPrompt.LoadString(IDS_SC_FOUND);

        // set <OK> default, remove <Cancel> default
        pBtn->SetButtonStyle(BS_DEFPUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDCANCEL);
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_PUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDC_DETAILS); // details can sometimes get set to default
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_PUSHBUTTON);

    }
    else
    {
        _ASSERTE(!m_strPrompt.IsEmpty());
        strPrompt = m_strPrompt;

        // remove <OK> default, set <Cancel> default
        pBtn->SetButtonStyle(BS_PUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDCANCEL);
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_DEFPUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDC_DETAILS); // details can sometimes get set to default
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_PUSHBUTTON);
    }

    CWnd* pDlgItem = GetDlgItem(IDC_PROMPT);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->SetWindowText(strPrompt);
}


void CScInsertDlg::DisplayError(UINT uiErrorMsg)
{
    CString strTitle, strMsg;

    strTitle.LoadString(IDS_SC_TITLE_ERROR);
    strMsg.LoadString(uiErrorMsg);

    MessageBox(strMsg, strTitle, MB_OK | MB_ICONEXCLAMATION);
}


void CScInsertDlg::SetSelection(CSCardReaderState* pRdrSt)
{
    m_pSelectedReader = pRdrSt;
    EnableOK(IsSelectionOK());
}


BOOL CScInsertDlg::SameCard(CSCardReaderState* p1, CSCardReaderState* p2)
{
    _ASSERTE(NULL != p1);
    _ASSERTE(NULL != p2);

    if ((NULL == p1) && (NULL == p2))
    {
        return TRUE;
    }

    if ((NULL == p1) || (NULL == p2))
    {
        return FALSE;
    }

    // same reader & card?
    if ((0 == p1->strReader.Compare(p2->strReader)) &&
        (0 == p1->strCard.Compare(p2->strCard)))
    {
        // no drastic state change?
        if(p1->dwState == p2->dwState)
        {
            return TRUE;
        }

        if(((p1->dwState == SC_SATATUS_AVAILABLE) ||
            (p1->dwState == SC_STATUS_SHARED) ||
            (p1->dwState == SC_STATUS_EXCLUSIVE)) &&
           ((p2->dwState == SC_SATATUS_AVAILABLE) ||
            (p2->dwState == SC_STATUS_SHARED) ||
            (p2->dwState == SC_STATUS_EXCLUSIVE)) )
        {
            return TRUE;
        }
    }
    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg message handlers

/*++

void ShowHelp:

    Helper function for OnHelpInfo and OnContextMenu.

BOOL OnHelpInfo:

    Called by the MFC framework when the user hits F1.

void OnContextMenu

    Called by the MFC framework when the user right-clicks.

Author:

    Amanda Matlosz  03/04/1999

Note:

    These three functions work together to provide context-sensitive
    help for the insertdlg.  Similar functions are declared for
    CScInsertBar

--*/
void CScInsertDlg::ShowHelp(HWND hWnd, UINT nCommand)
{

    ::WinHelp(hWnd, _T("SCardDlg.hlp"), nCommand, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG1);
}

afx_msg BOOL CScInsertDlg::OnHelpInfo(LPHELPINFO lpHelpInfo)
{
    _ASSERTE(NULL != lpHelpInfo);

    ShowHelp((HWND)lpHelpInfo->hItemHandle, HELP_WM_HELP);

    return TRUE;
}

afx_msg void CScInsertDlg::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    _ASSERTE(NULL != pWnd);

    ShowHelp(pWnd->m_hWnd, HELP_CONTEXTMENU);
}


/*++

void OnReaderStatusChange:

    This message handler is called by the status thread when smartcard status
    has changed.

Arguments:

    None.

Return Value:

    IGNORED BY CALLER. Long indicating status of ResMgr calls.

Author:

    Amanda Matlosz  07/09/1998

Note:

    No formal parameters are declared. These are not used and
    will stop compiler warnings from being generated.
    The long param takes the result of no_service or stopped

--*/
LONG CScInsertDlg::OnReaderStatusChange(UINT uint, LONG lParam)
{
    // Is monitor still alive?

    CScStatusMonitor::status status = m_monitor.GetStatus();
    if (CScStatusMonitor::running != status)
    {
        m_pSubDlg->EnableStatusList(FALSE);
        SetSelection(NULL); // JIC

        // display appropriate error & set m_lLastError
        switch(status)
        {
        case CScStatusMonitor::no_service:
        case CScStatusMonitor::stopped:
            m_lLastError = lParam;
            DisplayError(IDS_SC_RM_ERR);
            break;
        case CScStatusMonitor::no_readers:
            m_lLastError = SCARD_E_NO_READERS_AVAILABLE;
            DisplayError(IDS_SC_NO_READERS);
            break;
        default:
            m_lLastError = SCARD_F_UNKNOWN_ERROR;
            DisplayError(IDS_UNKNOWN_ERROR);
            break;
        }
    }
    else
    {
        // crit section around member reader/card status array
        _ASSERTE(m_pCritSec);
        if (m_pCritSec)
        {
            m_pCritSec->Lock();
        }

        // make local copy of recent reader state array,
        // so we know which cards have already been checked
        CSCardReaderStateArray aPreviousReaderState;
        aPreviousReaderState.RemoveAll();
        for (int nCopy = (int)m_aReaderState.GetUpperBound(); nCopy>=0; nCopy--)
        {
            CSCardReaderState* pReader = NULL;
            pReader = new CSCardReaderState(m_aReaderState[nCopy]);
            if (NULL != pReader)
            {
                aPreviousReaderState.Add(pReader);
            }
        }

        // udpate array from CStatusMonitor
        // check cards that have not been previously checked,
        // & update UI

        m_monitor.GetReaderStatus(m_aReaderState);
        for (int n = (int)m_aReaderState.GetUpperBound(); n>=0; n--)
        {
            CSCardReaderState* pReader = m_aReaderState[n];
            BOOL fAlreadyChecked = FALSE;

            // have we checked this card before?
            for (int nPrev = (int)aPreviousReaderState.GetUpperBound();
                 (nPrev>=0 && !fAlreadyChecked);
                 nPrev--)
            {
                if (SameCard(pReader, aPreviousReaderState[nPrev]))
                {
                    pReader->fOK = (aPreviousReaderState[nPrev])->fOK;
                    fAlreadyChecked = TRUE;
                }
            }

            // if this is a new card, or if the card's status has changed
            // drastically since we last looked at it, check it again
            if (!fAlreadyChecked)
            {
                if (NULL != m_pOCNW)
                {
                    m_aReaderState[n]->fOK = CheckCardAll(
                                                m_aReaderState[n],
                                                m_pOCNW,
                                                (LPCWSTR)m_mstrAllCards);
                }
                else
                {
                    _ASSERTE(NULL != m_pOCNA);
                    m_aReaderState[n]->fOK = CheckCardAll(
                                                m_aReaderState[n],
                                                m_pOCNA,
                                                (LPCWSTR)m_mstrAllCards);
                }
            }
        }

        // the subdialog will handle automatic reader selection
        m_pSubDlg->UpdateStatusList(&m_aReaderState);

        // clean up
        for (int nX = (int)aPreviousReaderState.GetUpperBound(); nX>=0; nX--)
        {
            delete aPreviousReaderState[nX];
        }
        aPreviousReaderState.RemoveAll();

        // end crit section
        if (m_pCritSec)
        {
            m_pCritSec->Unlock();
        }

    }

    return (long)SCARD_S_SUCCESS; // there's no one to receive this.
}


void CScInsertDlg::OnDetails()
{
    //
    // If the details are currently shown, hide them...
    // otherwise, show them.
    //
    CRect rectWin;

    GetWindowRect(&rectWin);

    CRect rectButtonBottom;

    CString strDetailsCaption;

    //
    // Determine the new height of the dialog & resize
    //

    int nNewHeight = 0;
    if (m_fDetailsShown)
    {
        nNewHeight = m_SmallHeight;
        strDetailsCaption.LoadString(IDS_DETAILS_SHOW);
    }
    else
    {
        nNewHeight = m_BigHeight;
        strDetailsCaption.LoadString(IDS_DETAILS_HIDE);
    }

    ScreenToClient(&rectButtonBottom);
    rectWin.bottom = rectWin.top + nNewHeight;

    SetWindowPos(NULL,
                    rectWin.left,
                    rectWin.top,
                    rectWin.Width(),
                    rectWin.Height(),
                    SWP_NOMOVE | SWP_NOZORDER);

    //
    // change captions, move buttons, show or hide the details section
    //

    m_btnDetails.SetWindowText(strDetailsCaption);

    MoveButton(IDC_DETAILS, nNewHeight - m_yMargin);
    MoveButton(IDOK, nNewHeight - m_yMargin);
    MoveButton(IDCANCEL, nNewHeight - m_yMargin);

    ToggleSubDialog();

    //
    // remember our new state
    //

    m_fDetailsShown = !m_fDetailsShown;
}


BOOL CScInsertDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // Initialize bits to query RM; if these fail, there's no point to go on
    // but the user should see an error message.
    //

    // kick off CSCStatusMonitor
    m_lLastError = m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);

    // if not running or no readers available
    CScStatusMonitor::status status = m_monitor.GetStatus();

    if (SCARD_S_SUCCESS != m_lLastError)
    {
        switch(status)
        {
        case CScStatusMonitor::no_service:
            DisplayError(IDS_SC_RM_ERR);
            break;
        case CScStatusMonitor::no_readers:
//            DisplayError(IDS_SC_NO_READERS);	// Bug 15742 -> will die quietly (no UI)
            break;
        case CScStatusMonitor::running:
            _ASSERTE(FALSE); // How can this be running if an error was returned??????
            // no break; go ahead an report an 'unknown error'
        default:
            DisplayError(IDS_UNKNOWN_ERROR);
            break;
        }

        PostMessage(WM_CLOSE, 0, 0);
        return TRUE;
    }
    _ASSERTE(status == CScStatusMonitor::running);

    //
    // Determine constant offsets for resizing window (on details)
    //

    CRect rectWin, rectDlgItem;
    GetWindowRect(&rectWin);

    m_SmallHeight = rectWin.Height();

    CWnd* pDlgItem = GetDlgItem(IDOK);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->GetWindowRect(&rectDlgItem);
    ScreenToClient(rectDlgItem);

    m_yMargin = m_SmallHeight - rectDlgItem.bottom;

    pDlgItem = GetDlgItem(IDC_BUTTON_BOTTOM);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->GetWindowRect(&rectDlgItem);
    ScreenToClient(rectDlgItem);

    m_BigHeight = rectDlgItem.bottom + m_yMargin;

    //
    // Add user-provided or ReaderLoaded icon
    //

    if (NULL == m_hIcon)
    {
        m_hIcon = AfxGetApp()->LoadIcon(IDI_SC_READERLOADED_V2);
    }
    _ASSERTE(NULL != m_hIcon);

    pDlgItem = GetDlgItem(IDC_USERICON);
    _ASSERTE(NULL != pDlgItem);

    pDlgItem->SetIcon(m_hIcon, TRUE); // TRUE: 32x32 icon

    //
    // Add other User-Customization bits
    //

    if (!m_strTitle.IsEmpty())
    {
        SetWindowText(m_strTitle);
    }

    if (m_strPrompt.IsEmpty())
    {
        // Use the default prompt text.
        m_strPrompt.LoadString(IDS_SC_PROMPT_ANYCARD);
    }
    pDlgItem = GetDlgItem(IDC_PROMPT);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->SetWindowText(m_strPrompt);

    // by default, <OK> is not enabled (subdlg's OnInitDlg might change that)
    EnableOK(FALSE);

    //
    // Set HELP ID(s) for context help
    //

    pDlgItem = GetDlgItem(IDC_DETAILS);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->SetWindowContextHelpId(IDH_DLG1_DETAILS_BTN);

    //
    // Add CScInsertBar (actually, a CDialog-derivative) to our dialog
    //

    pDlgItem = GetDlgItem(IDC_DLGBAR);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->GetWindowRect(&rectDlgItem);
    ScreenToClient(rectDlgItem);

    m_pSubDlg = new CScInsertBar(this);
    _ASSERTE(NULL != m_pSubDlg);
    if (NULL == m_pSubDlg)
    {
        m_lLastError = ERROR_OUTOFMEMORY;
        PostMessage(WM_CLOSE, 0, 0);
        return TRUE;
    }

    m_pSubDlg->Create(IDD_SCARDDLG_BAR, this);
    m_pSubDlg->SetWindowPos(NULL,
                rectDlgItem.left,
                rectDlgItem.top,
                0,
                0,
                SWP_NOSIZE | SWP_NOACTIVATE); // TODO: SWP_NOZORDER ??

    //
    // Set the dialog to alter itself to match how it was called
    //

    m_fDetailsShown = !m_fDetailsShown;
    OnDetails();

    if (m_fDetailsShown)
    {
        return FALSE; // focus should be set to list control
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CScInsertDlg::MoveButton(UINT nID, int newBottom)
{
    CWnd* pBtn = GetDlgItem(nID);
    _ASSERTE(NULL != pBtn);

    CRect rect;
    pBtn->GetWindowRect(&rect);
    ScreenToClient(&rect);
    rect.top = newBottom - rect.Height();

    pBtn->SetWindowPos(NULL,
                rect.left,
                rect.top,
                0,
                0,
                SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
}


void CScInsertDlg::ToggleSubDialog()
{
    //
    // All you need to do to toggle the sub dialog's accessibility
    // is to hide&disable or show&enable the window.
    //

    if (m_fDetailsShown)
    {
        m_pSubDlg->ShowWindow(SW_HIDE);
        m_pSubDlg->EnableWindow(FALSE);
    }
    else
    {
        m_pSubDlg->ShowWindow(SW_SHOW);
        m_pSubDlg->EnableWindow(TRUE);
    }
}


BOOL CScInsertDlg::DestroyWindow()
{
    if (NULL != m_pSubDlg)
    {
        m_pSubDlg->DestroyWindow();
        delete m_pSubDlg;
    }

    return CDialog::DestroyWindow();
}


/*++

void OnOK:

    Handle user's <OK>, error if can't complete

Arguments:

    None.

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98
--*/
void CScInsertDlg::OnOK()
{
    USES_CONVERSION;

    // Must have something selected to exit

    if (NULL == m_pSelectedReader || m_pSelectedReader->strCard.IsEmpty())
    {
        DisplayError(IDS_SC_SELECT);
        return;
    }

    // Must have selected something we're looking for...

    if (!(m_pSelectedReader->fOK))
    {
        DisplayError(IDS_SC_NOMATCH);
        return;
    }

    // Call the correct method to set the *real* card selection

    if(NULL != m_pOCNA)
    {

        LPSTR szCard = W2A(m_pSelectedReader->strCard);
        LPSTR szReader = W2A(m_pSelectedReader->strReader);

        m_lLastError = SetFinalCardSelection(szReader, szCard, m_pOCNA);
    }
    else
    {
        _ASSERTE(NULL != m_pOCNW);

        LPWSTR szCard = m_pSelectedReader->strCard.GetBuffer(1);
        LPWSTR szReader = m_pSelectedReader->strReader.GetBuffer(1);

        m_lLastError = SetFinalCardSelection(szReader, szCard, m_pOCNW);

        m_pSelectedReader->strCard.ReleaseBuffer();
        m_pSelectedReader->strReader.ReleaseBuffer();
    }

    if (SCARD_S_SUCCESS != m_lLastError)
    {
        DisplayError(IDS_SC_CONNECT_FAILED); // Either connect failed or out of memory - close enough.
        return;
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scuidlg.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    ScUIDlg

Abstract:

    This header file provides the definitions and symbols necessary for an
    Application or Smart Card Service Provider to use the Microsoft Smart
	Card dialogs.

Author:

    Amanda Matlosz (amatlosz) 06/11/1998

Environment:

    Win32

Notes:

	This will be added to winscard.h.

--*/

#ifndef _SCUIDLG_H_
#define _SCUIDLG_H_

#include <winscard.h>

//
// SCardUIDlgGetPIN
//

/*
	GetPIN dialog contains: large icon-sized bitmap for brand name
	standard prompt (caller can't change)
	checkbox for "Change PIN" (like Schlumberger CSP's)

	OnOK() calls lpfnVerifyPIN, raises some error message for 
	"BAD_PIN" and "CARD_LOCKED"

	lpfnVerifyPIN returns a code meaning "OK" "TRY_AGAIN" "CARD_LOCKED"

	returns standard dialog codes: IDOK, IDCANCEL, or ID_ABORT
*/
typedef LONG (WINAPI *LPVERIFYPINPROC) (IN LPSTR, IN PVOID);

typedef struct {
	DWORD			dwStructSize;		// REQUIRED
	HWND			hwndOwner;			// OPTIONAL
	HBITMAP			hBitmap;			// OPTIONAL 32x32 bmp for your brand insignia
	DWORD			dwFlags;			// OPTIONAL only SC_DLG_NOCHANGEPIN currently defined
	BOOL			fChangePin;			// OUT user checked change pin checkbox
	LPVERIFYPINPROC	lpfnVerifyPIN;		// REQUIRED
} PINPROMPT, *PPINPROMPT, *LPPINPROMPT;

extern WINSCARDAPI LONG WINAPI
SCardUIDlgGetPIN(
	LPPINPROMPT);

//
// SCardUIDlgChangePIN
//

/*
	ChangePIN dialog contains: large icon-sized bitmap for brand name
	Some Standard Prompt,
	boxes for old pin, new pin, and confirm new pin

	lpfnChangePIN takes szOldPIN, szNewPIN, and pvUserData; 
	returns a code "OK" "BAD_PIN" (incorrect old pin) "CARD LOCKED" "INVALID_PIN" (new pin is not long enough, etc.)

// TODO: should lpfnChangePIN respond with exact error messages re: invalid (new) pin,
// TODO: like "too short, too long, min length is:X, max length is:X, used invalid characters" etc.???
// TODO: should caller have option of returning an error message to be displayed? (localization issues?)

	returns standard dialog codes: IDOK, IDCANCEL, or ID_ABORT
*/
typedef LONG (WINAPI *LPCHANGEPINPROC) (IN LPSTR, IN LPSTR, IN PVOID);

typedef struct {
	DWORD			dwStructSize;		// REQUIRED
	HWND			hwndOwner;			// OPTIONAL
	HBITMAP			hBitmap;			// OPTIONAL 32x32 bmp for your brand insignia
	LPCHANGEPINPROC	lpfnChangePIN;		// REQUIRED
} CHANGEPIN, *PCHANGEPIN, *LPCHANGEPIN;

extern WINSCARDAPI LONG WINAPI
SCardUIDLgChangePIN(
	LPCHANGEPIN);


#endif // _SCUIDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scsearch.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScSearch

Abstract:

	header for miscellaneous smart card search and check functions
	See ScSearch.cpp for details.
	
Author:

	Amanda Matlosz	5/7/98

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

  Ansi and Widechar versions
--*/

#include "ScUIDlg.h" // winscard.h
#include "statmon.h"

DWORD AnsiMStringCount(LPCSTR msz);	// ansi-only

BOOL CheckOCN(LPOPENCARDNAMEA_EX pOCNA); // ansi-only
BOOL CheckOCN(LPOPENCARDNAMEW_EX pOCNW); // unicode-only

void ListAllOKCardNames(LPOPENCARDNAMEA_EX pOCNA, CTextMultistring& mstrAllCards); // ansi-only
void ListAllOKCardNames(LPOPENCARDNAMEW_EX pOCNW, CTextMultistring& mstrAllCards); // unicode-only

LONG NoUISearch(OPENCARDNAMEA_EX* pOCN, DWORD* pdwOKCards, LPCSTR mszCards); // ansi-only
LONG NoUISearch(OPENCARDNAMEW_EX* pOCN, DWORD* pdwOKCards, LPCWSTR mszCards); // unicode-only

BOOL CheckCardCallback(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN); // Does the callback stuff
BOOL CheckCardCallback(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN); // Does the callback stuff

BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEA_EX* pOCN, LPCWSTR mszCards); // ditto
BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEW_EX* pOCN, LPCWSTR mszCards); // ditto

LONG SetFinalCardSelection(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN);
LONG SetFinalCardSelection(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scuisupp\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCStatus.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\scsearch.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScSearch

Abstract:

    This file contains the outline implementation of
    miscellaneous smart card search and check functions
    for the Microsoft Smart Card Common Dialog

Author:

    Amanda Matlosz  5/7/98

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:


Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include "stdafx.h"
// #include <atlconv.cpp>
#include <winscard.h>
#include "ScSearch.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Helpers
//

LPSTR GetCardNameA(SCARDCONTEXT hSCardContext, LPBYTE pbAtr)
{
    LPSTR szCard = NULL;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    LONG lReturn = SCardListCardsA(
                        hSCardContext,
                        pbAtr,
                        NULL,
                        0,
                        (LPSTR)&szCard,
                        &dwNameLength);

    if (SCARD_S_SUCCESS != lReturn)
    {
        if (NULL != szCard)
        {
            SCardFreeMemory(hSCardContext, (PVOID)szCard);
            szCard = NULL;
        }
    }

    return szCard;
}


LPWSTR GetCardNameW(SCARDCONTEXT hSCardContext, LPBYTE pbAtr)
{
    LPWSTR szCard = NULL;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    LONG lReturn = SCardListCardsW(
                        hSCardContext,
                        pbAtr,
                        NULL,
                        0,
                        (LPWSTR)&szCard,
                        &dwNameLength);

    if (SCARD_S_SUCCESS != lReturn)
    {
        if (NULL != szCard)
        {
            SCardFreeMemory(hSCardContext, (PVOID)szCard);
            szCard = NULL;
        }
    }

    return szCard;
}


DWORD AnsiMStringCount(LPCSTR msz)
{
    DWORD dwRet = 0;

    while (NULL != msz)
    {
        if (NULL == *msz)
        {
            msz = NULL;
        }
        else
        {
            DWORD cchLen = strlen(msz);
            msz = msz+(sizeof(CHAR)*(cchLen+1));
            dwRet++;
        }
    }

    return dwRet;
}


void
MatchInterfacesW(
    SCARDCONTEXT hSCardContext,
    LPCGUID pGUIDInterfaces,
    DWORD cGUIDInterfaces,
    CTextMultistring& mstrAllCards)
{
    //
    // Append all cards that support the requested guidInterfaces
    //

    if (NULL != pGUIDInterfaces && 0 < cGUIDInterfaces)
    {
        LONG lResult = SCARD_S_SUCCESS;
        LPWSTR szListCards = NULL;
        DWORD dwCards = SCARD_AUTOALLOCATE;

        lResult = SCardListCardsW(
        hSCardContext,
        NULL,
        pGUIDInterfaces,
        cGUIDInterfaces,
        (LPWSTR) &szListCards,
        &dwCards);


        if (SCARD_S_SUCCESS == lResult)
        {
            // append them to the list of all possible card names
            mstrAllCards += szListCards;
        }

        if (NULL != szListCards)
        {
            SCardFreeMemory(hSCardContext, (PVOID)szListCards);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Methods
//

__inline BOOL CheckProtocols(
    IN DWORD dwProtocols)
{
    return 
        SCARD_PROTOCOL_T0 == (SCARD_PROTOCOL_T0 & dwProtocols) ||
        SCARD_PROTOCOL_T1 == (SCARD_PROTOCOL_T1 & dwProtocols) ||
        (SCARD_PROTOCOL_Tx) == ((SCARD_PROTOCOL_Tx) & dwProtocols) ||
        SCARD_PROTOCOL_RAW == (SCARD_PROTOCOL_RAW & dwProtocols) ||
        SCARD_PROTOCOL_DEFAULT == (SCARD_PROTOCOL_DEFAULT & dwProtocols) ||
        SCARD_PROTOCOL_OPTIMAL == (SCARD_PROTOCOL_OPTIMAL & dwProtocols);
}

/*++

BOOL CheckOCN:

    Routine performs simple parameter checks on OPENCARDNAME and
    OPENCARD_SEARCH_CRITERIA structs

Return Value:

    FALSE if invalid parameter, otherwise TRUE.

Author:

    Amanda Matlosz  09/16/1998

--*/
BOOL CheckOCN(LPOPENCARDNAMEA_EX pOCNA)
{
    if (NULL == pOCNA)
    {
        return FALSE;
    }

    if (pOCNA->dwStructSize != sizeof(OPENCARDNAMEA_EX))
    {
        return FALSE;
    }

    if (NULL == pOCNA->hSCardContext)
    {
        return FALSE;
    }

    if (0 == pOCNA->nMaxRdr || NULL == pOCNA->lpstrRdr)
    {
        return FALSE;
    }

    if (0 == pOCNA->nMaxCard || NULL == pOCNA->lpstrCard)
    {
        return FALSE;
    }

    BOOL fOneFlagOnly = FALSE;
    if (0 != (pOCNA->dwFlags & SC_DLG_MINIMAL_UI))
    {
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNA->dwFlags & SC_DLG_FORCE_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNA->dwFlags & SC_DLG_NO_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }

    // Now check POPENCARD_SEARCH_CRITERIAA, if applicable
    if (NULL != pOCNA->pOpenCardSearchCriteria)
    {
        DWORD dwShareMode = pOCNA->pOpenCardSearchCriteria->dwShareMode;
        DWORD dwPreferredProtocols = pOCNA->pOpenCardSearchCriteria->dwPreferredProtocols;

        if (NULL != pOCNA->pOpenCardSearchCriteria->lpfnCheck)
        {
            // either lpfnConnect and lpfnDisconnect must be set
            if ( (NULL != pOCNA->pOpenCardSearchCriteria->lpfnConnect) &&
                (NULL != pOCNA->pOpenCardSearchCriteria->lpfnDisconnect) )
            {
                return TRUE;
            }

            if ( (  SCARD_SHARE_EXCLUSIVE == dwShareMode ||
                    SCARD_SHARE_SHARED == dwShareMode ||
                    SCARD_SHARE_DIRECT == dwShareMode ) &&
                    CheckProtocols(dwPreferredProtocols)
                    )
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    // if all the tests have passed, it must be OK.
    return TRUE;
}


BOOL CheckOCN(LPOPENCARDNAMEW_EX pOCNW)
{
    if (NULL == pOCNW)
    {
        return FALSE;
    }

    if (pOCNW->dwStructSize != sizeof(OPENCARDNAMEW_EX))
    {
        return FALSE;
    }

    if (NULL == pOCNW->hSCardContext)
    {
        return FALSE;
    }

    if (0 == pOCNW->nMaxRdr || NULL == pOCNW->lpstrRdr)
    {
        return FALSE;
    }

    if (0 == pOCNW->nMaxCard || NULL == pOCNW->lpstrCard)
    {
        return FALSE;
    }

    BOOL fOneFlagOnly = FALSE;
    if (0 != (pOCNW->dwFlags & SC_DLG_MINIMAL_UI))
    {
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNW->dwFlags & SC_DLG_FORCE_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNW->dwFlags & SC_DLG_NO_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }

    // Now check POPENCARD_SEARCH_CRITERIAW, if applicable
    if (NULL != pOCNW->pOpenCardSearchCriteria)
    {
        DWORD dwShareMode = pOCNW->pOpenCardSearchCriteria->dwShareMode;
        DWORD dwPreferredProtocols = pOCNW->pOpenCardSearchCriteria->dwPreferredProtocols;

        if (NULL != pOCNW->pOpenCardSearchCriteria->lpfnCheck)
        {
            // either lpfnConnect and lpfnDisconnect must be set
            if ( (NULL != pOCNW->pOpenCardSearchCriteria->lpfnConnect) &&
                (NULL != pOCNW->pOpenCardSearchCriteria->lpfnDisconnect) )
            {
                return TRUE;
            }

            if ( (  SCARD_SHARE_EXCLUSIVE == dwShareMode ||
                    SCARD_SHARE_SHARED == dwShareMode ||
                    SCARD_SHARE_DIRECT == dwShareMode ) &&
                    CheckProtocols(dwPreferredProtocols)
                )
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    // if all the tests have passed, it must be OK.
    return TRUE;
}


/*++

void ListAllOKCardNames:

    Routine creates a multistring list of card names that match the
    search criteria for both ATR (as determined by the list of card
    names) and supported interfaces.  This list of card names is not
    displayed to the user, but is used internally.

    This is a complete list of possible cards.  Note that the list of
    supported interfaces is an _additive_ criteria, not a restrictive
    one.

    TODO: ?? recheck that assumption re: additive vs. restrictive. ??

Arguments:

    pOCSC - POPENCARD_SEARCH_CRITERIAA

    mstrAllCards - referece to a CTextMultistring to take list of all OK cards

Return Value:

    None.

Author:

    Amanda Matlosz  09/16/1998

--*/
void ListAllOKCardNames(LPOPENCARDNAMEA_EX pOCNA, CTextMultistring& mstrAllCards) // ANSI
{
    POPENCARD_SEARCH_CRITERIAA pOCSC = pOCNA->pOpenCardSearchCriteria;

    if ((NULL == pOCSC) || (NULL == pOCSC->lpstrCardNames))
    {
        // No cards specified
        return;
    }
    mstrAllCards = pOCSC->lpstrCardNames;

    //
    // List all cards that support the requested guidInterfaces
    //

    MatchInterfacesW(
        pOCNA->hSCardContext,
        pOCSC->rgguidInterfaces,
        pOCSC->cguidInterfaces,
        mstrAllCards);

}


void ListAllOKCardNames(LPOPENCARDNAMEW_EX pOCNW, CTextMultistring& mstrAllCards) // UNICODE
{
    POPENCARD_SEARCH_CRITERIAW pOCSC = pOCNW->pOpenCardSearchCriteria;

    if ((NULL == pOCSC) || (NULL == pOCSC->lpstrCardNames))
    {
        // No cards specified
        return;
    }
    mstrAllCards = pOCSC->lpstrCardNames;

    //
    // List all cards that support the requested guidInterfaces
    //

    MatchInterfacesW(
        pOCNW->hSCardContext,
        pOCSC->rgguidInterfaces,
        pOCSC->cguidInterfaces,
        mstrAllCards);
}


// pdwOKCards is used so the caller can decide what additional actions to take
// based on how many suitable cards were found
LONG NoUISearch(OPENCARDNAMEA_EX* pOCN, DWORD* pdwOKCards, LPCSTR mszCards) // ansi-only
{
    USES_CONVERSION;

    _ASSERTE(pOCN != NULL);

    *pdwOKCards = 0;

    LONG lReturn = SCARD_S_SUCCESS;

    SCARD_READERSTATEA* pReaderStatus = NULL;
    DWORD dwReaders = 0;

    const DWORD dwMeetsCriteria = 1;
    LPSTR szGroupNames = NULL;
    LPSTR szReaderNames = NULL;
    DWORD dw=0;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    //
    // get list of readers we'll consider
    //

    if (NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpstrGroupNames)
    {
        szGroupNames = pOCN->pOpenCardSearchCriteria->lpstrGroupNames;
    }
    else
    {
        szGroupNames = W2A(SCARD_DEFAULT_READERS);
    }

    lReturn = SCardListReadersA(pOCN->hSCardContext,
        szGroupNames,
        (LPSTR)&szReaderNames,
        &dwNameLength);

    if(SCARD_S_SUCCESS == lReturn)
    {
        //
        // use the list of readers to build a readerstate array
        //
        dwReaders = AnsiMStringCount(szReaderNames);
        _ASSERTE(0 != dwReaders);
        pReaderStatus = new SCARD_READERSTATEA[dwReaders];
        if (NULL != pReaderStatus)
        {
            LPCSTR pchReader = szReaderNames;
            int nIndex = 0;

            memset(pReaderStatus, 0, sizeof(SCARD_READERSTATEA) * dwReaders);

            while(0 != *pchReader)
            {
                pReaderStatus[nIndex].szReader = pchReader;
                pReaderStatus[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
                pchReader += strlen(pchReader)+1;
                nIndex++;
            }
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }

    //
    // If there are no readers, there's no point to go on.
    //

    if (0 == dwReaders || SCARD_S_SUCCESS != lReturn)
    {
        goto CleanUp;
    }

    //
    // Search for cards: use SCardLocateCards to find cards that match
    // ATR & interfaces supported if mszCards is not empty,
    // otherwise use SCardGetStatusChange() to look for any card
    //

    if (0 < AnsiMStringCount(mszCards))
    {
        lReturn = SCardLocateCardsA(pOCN->hSCardContext,
        mszCards,
        pReaderStatus,
        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_ATRMATCH set & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_ATRMATCH) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }
    else
    {
        lReturn = SCardGetStatusChangeA(
                        pOCN->hSCardContext,
                        0,
                        pReaderStatus,
                        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_PRESENT & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_PRESENT) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }

    //
    // check each card to see if it's OK (meets callback criteria)
    //

    for (dw=0; dw<dwReaders; dw++)
    {
        if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dw].pvUserData))
        {
            pReaderStatus[dw].pvUserData = NULL;

            // get the card name for CheckCardCallback;
            // if there's no name, don't accept it

            LPSTR szCard = NULL;
            szCard = GetCardNameA(pOCN->hSCardContext, pReaderStatus[dw].rgbAtr);

            if (NULL != szCard && NULL != *szCard)
            {
                if (CheckCardCallback((LPSTR)pReaderStatus[dw].szReader, szCard, pOCN))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                    (*pdwOKCards)++;
                }
            }

            if (NULL != szCard)
            {
                SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
            }
        }
    }

    //
    // if SC_DLG_MIN_UI and only found one OK card, connect to that one
    // if SC_DLG_NO_UI and found one or more OK card, connect to the first
    //

    if ((0 != (pOCN->dwFlags & SC_DLG_MINIMAL_UI) && 1 == *pdwOKCards) ||
        (0 != (pOCN->dwFlags & SC_DLG_NO_UI) && 1 <= *pdwOKCards))
    {
        DWORD dwSel = 0;
        while (dwSel < dwReaders)
        {
            if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dwSel].pvUserData))
            {
                break;
            }

            dwSel++;
        }

        _ASSERTE(dwSel<dwReaders); // Why didn't it find any OK cards?

        // get the card name for SetFinalCardSelection; can be NULL
        LPSTR szCard = NULL;
        szCard = GetCardNameA(pOCN->hSCardContext, pReaderStatus[dwSel].rgbAtr);

        lReturn = SetFinalCardSelection((LPSTR)(pReaderStatus[dwSel].szReader), szCard, pOCN);

        // let go of CardName
        if (NULL != szCard)
        {
            SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
        }
    }
    else
    {
        if (SCARD_S_SUCCESS == lReturn)
        {
            lReturn = SCARD_E_CANCELLED; // any non-SCARD_S_SUCCESS return val will do
        }
    }

CleanUp:

    //
    // Clean up
    //

    if (NULL != pReaderStatus)
    {
        delete [] pReaderStatus;
    }
    if (NULL != szReaderNames)
    {
        SCardFreeMemory(pOCN->hSCardContext, (PVOID)szReaderNames);
    }

    return lReturn;
}


LONG NoUISearch(OPENCARDNAMEW_EX* pOCN, DWORD* pdwOKCards, LPCWSTR mszCards) // UNICODE
{
    _ASSERTE(pOCN != NULL);

    *pdwOKCards = 0;

    LONG lReturn = SCARD_S_SUCCESS;

    SCARD_READERSTATEW* pReaderStatus = NULL;
    DWORD dwReaders = 0;

    const DWORD dwMeetsCriteria = 1;
    LPWSTR szGroupNames = NULL;
    LPWSTR szReaderNames = NULL;
    DWORD dw=0;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    //
    // get list of readers we'll consider
    //

    if (NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpstrGroupNames)
    {
        szGroupNames = pOCN->pOpenCardSearchCriteria->lpstrGroupNames;
    }
    else
    {
        szGroupNames = SCARD_DEFAULT_READERS;
    }

    lReturn = SCardListReadersW(pOCN->hSCardContext,
                szGroupNames,
                (LPWSTR)&szReaderNames,
                &dwNameLength);

    if(SCARD_S_SUCCESS == lReturn)
    {
        //
        // use the list of readers to build a readerstate array
        //
        dwReaders = MStringCount(szReaderNames);
        _ASSERTE(0 != dwReaders);
        pReaderStatus = new SCARD_READERSTATEW[dwReaders];
        if (NULL != pReaderStatus)
        {
            LPCWSTR pchReader = szReaderNames;
            int nIndex = 0;

            memset(pReaderStatus, 0, sizeof(SCARD_READERSTATEW) * dwReaders);

            while(0 != *pchReader)
            {
                pReaderStatus[nIndex].szReader = pchReader;
                pReaderStatus[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
                pchReader += lstrlen(pchReader)+1;
                nIndex++;
            }
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }

    //
    // If there are no readers, there's no point to go on.
    //

    if (0 == dwReaders)
    {
        goto CleanUp;
    }

    //
    // Search for cards: use SCardLocateCards to find cards that match
    // ATR & interfaces supported if mszCards is not empty,
    // otherwise use SCardGetStatusChange() to look for any card
    //

    if (0 < MStringCount(mszCards))
    {
        lReturn = SCardLocateCardsW(pOCN->hSCardContext,
        mszCards,
        pReaderStatus,
        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_ATRMATCH set & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_ATRMATCH) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }
    else
    {
        lReturn = SCardGetStatusChangeW(
        pOCN->hSCardContext,
        0,
        pReaderStatus,
        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_PRESENT & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_PRESENT) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }

    //
    // check each card to see if it's OK (meets callback criteria)
    //

    for (dw=0; dw<dwReaders; dw++)
    {
        if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dw].pvUserData))
        {
            pReaderStatus[dw].pvUserData = NULL;

            // get the card name for CheckCardCallback;
            // if there's no name, don't accept it

            LPWSTR szCard = NULL;
            szCard = GetCardNameW(pOCN->hSCardContext, pReaderStatus[dw].rgbAtr);

            if (NULL != szCard && 0 != lstrlen(szCard))
            {
                if (CheckCardCallback((LPWSTR)pReaderStatus[dw].szReader, szCard, pOCN))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                    (*pdwOKCards)++;
                }
            }

            // let go of CardName
            if (NULL != szCard)
            {
                SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
            }
        }
    }

    //
    // if SC_DLG_MIN_UI and only found one OK card, connect to that one
    // if SC_DLG_NO_UI and found one or more OK card, connect to the first
    //

    if ((0 != (pOCN->dwFlags & SC_DLG_MINIMAL_UI) && 1 == *pdwOKCards) ||
        (0 != (pOCN->dwFlags & SC_DLG_NO_UI) && 1 <= *pdwOKCards))
    {
        DWORD dwSel = 0;
        while (dwSel < dwReaders)
        {
            if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dwSel].pvUserData))
            {
                break;
            }

            dwSel++;
        }

        _ASSERTE(dwSel<dwReaders); // Why didn't it find any OK cards?

        // get the card name for SetFinalCardSelection; can be NULL
        LPWSTR szCard = NULL;
        szCard = GetCardNameW(pOCN->hSCardContext, pReaderStatus[dwSel].rgbAtr);

        lReturn = SetFinalCardSelection((LPWSTR)(pReaderStatus[dwSel].szReader), szCard, pOCN);

        // let go of CardName
        if (NULL != szCard)
        {
            SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
        }
    }
    else
    {
        if (SCARD_S_SUCCESS == lReturn)
        {
            lReturn = SCARD_E_CANCELLED; // any non-SCARD_S_SUCCESS return val will do
        }
    }

CleanUp:

    //
    // Clean up
    //

    if (NULL != pReaderStatus)
    {
        delete [] pReaderStatus;
    }
    if (NULL != szReaderNames)
    {
        SCardFreeMemory(pOCN->hSCardContext, (PVOID)szReaderNames);
    }

    return lReturn;
}


/*++

BOOL CheckCardCallback:

    Routine connects to the indicated card/reader, calls user-
    supplied "check" function, and disconnects from card
    according to search criteria members.

Arguments:

    szReader - indicated reader.

    szCard - indicated card name.

    pOCN - OPENCARDNAME_EX struct containing search criteria

Return Value:

    TRUE if connection, check, and disconnection succeeds, otherwise
    FALSE.

Author:

    Amanda Matlosz  07/09/1998

--*/
BOOL CheckCardCallback(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN)
{
    BOOL fReturn = FALSE;

    //
    // Check parameters
    //

    // if no check callback, succeed by default
    if (!(NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpfnCheck))
    {
        return TRUE;
    }

    // in order to connect, we either need to have dwShareMode set to non-0
    // or both the conenct and disconnect callbacks have to be valid.
    // This should have been caught in SetOCN()!
    if (0 == pOCN->pOpenCardSearchCriteria->dwShareMode &&
        (NULL == pOCN->pOpenCardSearchCriteria->lpfnConnect
        || NULL == pOCN->pOpenCardSearchCriteria->lpfnDisconnect))
    {
        return FALSE;
    }

    LPOCNCONNPROCA lpfnConnect = pOCN->pOpenCardSearchCriteria->lpfnConnect;
    LPOCNCHKPROC lpfnCheck = pOCN->pOpenCardSearchCriteria->lpfnCheck;
    LPOCNDSCPROC lpfnDisconnect = pOCN->pOpenCardSearchCriteria->lpfnDisconnect;
    PVOID pvUserData = pOCN->pOpenCardSearchCriteria->pvUserData;

    //
    // Connect, preferably through the callback
    //

    SCARDHANDLE hCard = NULL;

    if (NULL != lpfnConnect)
    {
        hCard = lpfnConnect(pOCN->hSCardContext,
                    szReader,
                    szCard,
                    pvUserData);
    }
    else
    {
        DWORD dw = 0; // Don't need to know the active protocol

        LONG lReturn = SCardConnectA(pOCN->hSCardContext,
                            (LPCSTR)szReader,
                            pOCN->pOpenCardSearchCriteria->dwShareMode,
                            pOCN->pOpenCardSearchCriteria->dwPreferredProtocols,
                            &hCard,
                            &dw);

        // TODO: ?? maybe want to trace failure of lReturn... ??
    }

    // if the connect failed, there's no way we can check the card!
    if (NULL == hCard)
    {
        return fReturn;
    }

    //
    // Check the card
    //

    fReturn = lpfnCheck(pOCN->hSCardContext,
                        hCard,
                        pvUserData);

    //
    // Disconnect from the card and clean up.
    //

    if (NULL != lpfnDisconnect)
    {
        lpfnDisconnect(pOCN->hSCardContext,
                        hCard,
                        pvUserData);
    }
    else
    {
        SCardDisconnect(hCard, SCARD_UNPOWER_CARD);
    }

    return fReturn;
}


BOOL CheckCardCallback(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN)
{
    BOOL fReturn = FALSE;

    //
    // Check parameters
    //

    // if no check callback, succeed by default
    if (!(NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpfnCheck))
    {
        return TRUE;
    }

    // in order to connect, we either need to have dwShareMode set to non-0
    // or both the conenct and disconnect callbacks have to be valid.
    // This should have been caught in SetOCN()!
    if (0 == pOCN->pOpenCardSearchCriteria->dwShareMode &&
        (NULL == pOCN->pOpenCardSearchCriteria->lpfnConnect
        || NULL == pOCN->pOpenCardSearchCriteria->lpfnDisconnect))
    {
        return FALSE;
    }

    LPOCNCONNPROCW lpfnConnect = pOCN->pOpenCardSearchCriteria->lpfnConnect;
    LPOCNCHKPROC lpfnCheck = pOCN->pOpenCardSearchCriteria->lpfnCheck;
    LPOCNDSCPROC lpfnDisconnect = pOCN->pOpenCardSearchCriteria->lpfnDisconnect;
    PVOID pvUserData = pOCN->pOpenCardSearchCriteria->pvUserData;

    //
    // Connect, preferably through the callback
    //

    SCARDHANDLE hCard = NULL;

    if (NULL != lpfnConnect)
    {
        hCard = lpfnConnect(pOCN->hSCardContext,
                            szReader,
                            szCard,
                            pvUserData);
    }
    else
    {
        DWORD dw = 0; // Don't need to know the active protocol

        LONG lReturn = SCardConnectW(pOCN->hSCardContext,
                            (LPCWSTR)szReader,
                            pOCN->pOpenCardSearchCriteria->dwShareMode,
                            pOCN->pOpenCardSearchCriteria->dwPreferredProtocols,
                            &hCard,
                            &dw);

        // TODO: ?? maybe want to trace failure of lReturn... ??
    }

    // if the connect failed, there's no way we can check the card!
    if (NULL == hCard)
    {
        return fReturn;
    }

    //
    // Check the card
    //

    fReturn = lpfnCheck(pOCN->hSCardContext,
                hCard,
                pvUserData);

    //
    // Disconnect from the card and clean up.
    //

    if (NULL != lpfnDisconnect)
    {
        lpfnDisconnect(pOCN->hSCardContext,
                        hCard,
                        pvUserData);
    }
    else
    {
        SCardDisconnect(hCard, SCARD_UNPOWER_CARD);
    }

    return fReturn;
}


/*++

BOOL CheckCardAll:

    Routine checks to see whether or not the indicated card meets
    the search criteria.  ATR, supported interfaces, and callbacks
    are all checked.

Arguments:

    pReader - Reader containing card to check acceptability of

    pOCN - OPENCARDNAME[A|W]_EX struct containing search criteria, etc.

    mszCards - a multistring containing names of ALL acceptable cards

Return Value:

    A BOOL value indicating the acceptibility of the given card.

Author:

    Amanda Matlosz  07/09/1998

--*/
BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEA_EX* pOCN, LPCWSTR mszCards) // ANSI
{
    USES_CONVERSION;

    BOOL fReturn = FALSE; // assume no match

    _ASSERTE(NULL != pReader && NULL != pOCN);
    if (NULL == pReader || NULL == pOCN)
    {
        return FALSE;
    }

    // Check Name & interfaces

    if (!pReader->strCard.IsEmpty())
    {
        LPCWSTR msz = mszCards;
        if (0 < MStringCount(msz))
        {
            msz = FirstString(mszCards);
            while (!fReturn && msz != NULL)
            {
                // compare if OK fReturn = TRUE;
                if (0 == pReader->strCard.Compare(msz) || 0==lstrlen(msz))
                {
                    fReturn = TRUE;
                }
                else
                {
                    msz = NextString(msz);
                }
            }
        }
        else
        {
            fReturn = TRUE;
        }
    }

    // Check Callback

    if (fReturn)
    {
        // turn CStrings into LPSTRs
        LPSTR szReader = W2A(pReader->strReader);
        LPSTR szCard = W2A(pReader->strCard);

        fReturn = CheckCardCallback(szReader, szCard, pOCN);
    }

    // note in readerstate whether or not the card passed all tests
    pReader->fOK = fReturn;

    return fReturn;
}


BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEW_EX* pOCN, LPCWSTR mszCards) // UNICODE
{
    BOOL fReturn = FALSE; // assume no match

    _ASSERTE(NULL != pReader && NULL != pOCN);
    if (NULL == pReader || NULL == pOCN)
    {
        return FALSE;
    }

    // Check Name & interfaces

    if (!pReader->strCard.IsEmpty())
    {
        LPCWSTR msz = mszCards;
        if (0 < MStringCount(msz))
        {
            msz = FirstString(mszCards);
            while (!fReturn && msz != NULL)
            {
                // compare if OK fReturn = TRUE;
                if (0 == pReader->strCard.Compare(msz) || 0==lstrlen(msz))
                {
                    fReturn = TRUE;
                }
                else
                {
                    msz = NextString(msz);
                }
            }
        }
        else
        {
            fReturn = TRUE;
        }
    }

    // Check Callback

    if (fReturn)
    {
        // turn CStrings into LPSTRs
        LPWSTR szReader = pReader->strReader.GetBuffer(1);
        LPWSTR szCard = pReader->strCard.GetBuffer(1);

        fReturn = CheckCardCallback(szReader, szCard, pOCN);

        pReader->strReader.ReleaseBuffer();
        pReader->strCard.ReleaseBuffer();
    }

    // note in readerstate whether or not the card passed all tests
    pReader->fOK = fReturn;

    return fReturn;
}


/*++

LONG SetFinalCardSelection:

    Routine connects to a selected reader, and sets the user-provided structs
    to contain the reader&cardname.  Returns an error if the user-provided struct's
    buffers aren't long enough.

Arguments:

    dwSelectedReader - index used to select which reader to connect to.

Return Value:

    A LONG value indicating the status of the requested action.
    See the Smartcard header files for additional information.

Author:

    Amanda Matlosz  07/09/1998

--*/
LONG SetFinalCardSelection(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN) // ANSI
{
    _ASSERTE(NULL != pOCN);

    pOCN->hCardHandle = NULL;
    LONG lReturn = SCARD_S_SUCCESS;

    //
    // Set return values in OCN
    //

    if (NULL == szReader)
    {
        lReturn = SCARD_F_INTERNAL_ERROR;
    }
    else
    {
        if (pOCN->nMaxRdr >= strlen(szReader)+1)
        {
            ::CopyMemory(   (LPVOID)pOCN->lpstrRdr,
                            (CONST LPVOID)szReader,
                            strlen(szReader)+1);
        }
        else
        {
            pOCN->nMaxRdr = strlen(szReader)+1;
            lReturn = SCARD_E_NO_MEMORY;
        }
    }

    if (SCARD_S_SUCCESS == lReturn)
    {
        if (NULL == szCard)
        {
            lReturn = SCARD_F_INTERNAL_ERROR;
        }
        else
        {
            if (pOCN->nMaxCard >= strlen(szCard)+1)
            {
                ::CopyMemory(   (LPVOID)pOCN->lpstrCard,
                                (CONST LPVOID)szCard,
                                strlen(szCard)+1);
            }
            else
            {
                pOCN->nMaxCard = strlen(szCard)+1;
                lReturn = SCARD_E_NO_MEMORY;
            }
        }
    }
    //
    // Connect to card only if we're still in a successful state,
    //

    if (SCARD_S_SUCCESS == lReturn)
    {
        if(NULL != pOCN->lpfnConnect)
        {
            pOCN->hCardHandle = pOCN->lpfnConnect(
            pOCN->hSCardContext,
            szReader,
            szCard,
            pOCN->pvUserData);
        }
        else if (0 != pOCN->dwShareMode)
        {
            lReturn = SCardConnectA(pOCN->hSCardContext,
            (LPCSTR)szReader,
            pOCN->dwShareMode,
            pOCN->dwPreferredProtocols,
            &pOCN->hCardHandle,
            &pOCN->dwActiveProtocol);

            if (SCARD_S_SUCCESS != lReturn)
            {
                // must return hCardHandle of NULL
                pOCN->hCardHandle = NULL;
            }
        }
    }

    return lReturn;
}


LONG SetFinalCardSelection(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN) // UNICODE
{
    _ASSERTE(NULL != pOCN);

    pOCN->hCardHandle = NULL;
    LONG lReturn = SCARD_S_SUCCESS;

    //
    // Set return values in OCN
    //

    if (NULL == szReader)
    {
        lReturn = SCARD_F_INTERNAL_ERROR;
    }
    else
    {
        if (pOCN->nMaxRdr >= (DWORD)lstrlen(szReader)+1)
        {
            ::CopyMemory(   (LPVOID)pOCN->lpstrRdr,
                            (CONST LPVOID)szReader,
                            sizeof(WCHAR)*(lstrlen(szReader)+1));
        }
        else
        {
            pOCN->nMaxRdr = lstrlen(szReader)+1;
            lReturn = SCARD_E_NO_MEMORY;
        }
    }

    if (SCARD_S_SUCCESS == lReturn)
    {
        if (NULL == szCard)
        {
            lReturn = SCARD_F_INTERNAL_ERROR;
        }
        else
        {
            if (pOCN->nMaxCard >= (DWORD)lstrlen(szCard)+1)
            {
                ::CopyMemory(   (LPVOID)pOCN->lpstrCard,
                                (CONST LPVOID)szCard,
                                sizeof(WCHAR)*(lstrlen(szCard)+1));
            }
            else
            {
                pOCN->nMaxCard = lstrlen(szCard)+1;
                lReturn = SCARD_E_NO_MEMORY;
            }
        }
    }

    //
    // Connect to card only if we're still in a successful state,
    //

    if (SCARD_S_SUCCESS == lReturn)
    {
        if(NULL != pOCN->lpfnConnect)
        {
            pOCN->hCardHandle = pOCN->lpfnConnect(
            pOCN->hSCardContext,
            szReader,
            szCard,
            pOCN->pvUserData);
        }
        else if (0 != pOCN->dwShareMode)
        {
            lReturn = SCardConnectW(pOCN->hSCardContext,
            (LPCWSTR)szReader,
            pOCN->dwShareMode,
            pOCN->dwPreferredProtocols,
            &pOCN->hCardHandle,
            &pOCN->dwActiveProtocol);

            if (SCARD_S_SUCCESS != lReturn)
            {
                // must return hCardHandle of NULL
                pOCN->hCardHandle = NULL;
            }
        }
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>

// Define local message for notification
#ifndef _WM_READERSTATUSCHANGE
#define WM_READERSTATUSCHANGE		(WM_USER+1)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scuisupp\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

// Include multi-thread classes
#include <afxmt.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <atlconv.h>		// ATL Conversion macros

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\buffers.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    buffers

Abstract:

    This header file provides dynamic buffer and string classes for general use.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32, C++ w/ Exception Handling

Notes:



--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_


//
//==============================================================================
//
//  CBuffer
//

class CBuffer
{
public:

    //  Constructors & Destructor

    CBuffer()           // Default Initializer
    { Initialize(); };

    CBuffer(            // Initialize with starting length.
        IN DWORD cbLength)
    { Initialize();
      Presize(cbLength, FALSE); };

    CBuffer(            // Initialize with starting data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength)
    { Initialize();
      Set(pbSource, cbLength); };

    virtual ~CBuffer()  // Tear down.
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void);        // Free up any allocated memory.

    LPBYTE
    Reset(void);        // Return to default state (don't loose memory.)

    LPBYTE
    Presize(            // Make sure the buffer is big enough.
        IN DWORD cbLength,
        IN BOOL fPreserve = FALSE);

    LPBYTE
    Resize(         // Make sure the buffer & length are the right size.
        DWORD cbLength,
        BOOL fPreserve = FALSE);

    LPBYTE
    Set(            // Load a value.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    LPBYTE
    Append(         // Append more data to the existing data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    DWORD
    Length(         // Return the length of the data.
        void) const
    { return m_cbDataLength; };

    DWORD
    Space(          // Return the length of the buffer.
        void) const
    { return m_cbBufferLength; };

    LPBYTE
    Access(         // Return the data, starting at an offset.
        DWORD offset = 0)
    const
    {
        if (m_cbBufferLength <= offset)
            return (LPBYTE)TEXT("\x00");
        else
            return &m_pbBuffer[offset];
    };

    int
    Compare(
        const CBuffer &bfSource)
    const;


    //  Operators

    CBuffer &
    operator=(
        IN const CBuffer &bfSource)
    { Set(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    CBuffer &
    operator+=(
        IN const CBuffer &bfSource)
    { Append(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    BYTE &
    operator[](
        DWORD offset)
        const
    { return *Access(offset); };

    int
    operator==(
        IN const CBuffer &bfSource)
        const
    { return 0 == Compare(bfSource); };

    int
    operator!=(
        IN const CBuffer &bfSource)
        const
    { return 0 != Compare(bfSource); };

    operator LPCBYTE(void)
    { return (LPCBYTE)Access(); };

    operator LPCTSTR(void)
    { return (LPCTSTR)Access(); };


protected:

    //  Properties

    LPBYTE m_pbBuffer;
    DWORD m_cbDataLength;
    DWORD m_cbBufferLength;


    //  Methods

    void
    Initialize(void)
    {
        m_pbBuffer = NULL;
        m_cbDataLength = 0;
        m_cbBufferLength = 0;
    };

    CBuffer(           //  Object assignment constructor.
        IN const CBuffer &bfSourceOne,
        IN const CBuffer &bfSourceTwo);

    friend
        CBuffer &
        operator+(
            IN const CBuffer &bfSourceOne,
            IN const CBuffer &bfSourceTwo);
};

#endif // _BUFFERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\longhorn\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>

// Define local message for notification
#ifndef _WM_READERSTATUSCHANGE
#define WM_READERSTATUSCHANGE		(WM_USER+1)
#endif

#ifdef ISOLATION_AWARE_ENABLED
#include <shfusion.h>

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\longhorn\scinsbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsBar.cpp
//
//--------------------------------------------------------------------------

// ScInsBar.cpp : implementation file
//

#include "stdafx.h"
#include "scdlg.h"
#include "scinsdlg.h"
#include "ScInsBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScEdit special edit boxes (CardName, CardStatus)

BEGIN_MESSAGE_MAP(CScEdit, CEdit)
    //{{AFX_MSG_MAP(CScEdit)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CScEdit::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    ::WinHelp(m_hWnd, _T("SCardDlg.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG_BAR);
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertBar dialog


CScInsertBar::CScInsertBar(CWnd* pParent /*=NULL*/)
    : CDialog(CScInsertBar::IDD, pParent)
{
    m_paReaderState = NULL;
    //{{AFX_DATA_INIT(CScInsertBar)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

void CScInsertBar::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CScInsertBar)
    DDX_Control(pDX, IDC_NAME, m_ediName);
    DDX_Control(pDX, IDC_STATUS, m_ediStatus);
    DDX_Control(pDX, IDC_READERS, m_lstReaders);
    //}}AFX_DATA_MAP
}


void CScInsertBar::OnCancel()
{
    CScInsertDlg* pParent = (CScInsertDlg*)GetParent();
    _ASSERTE(NULL != pParent);
    if (NULL != pParent)
    {
        pParent->PostMessage(IDCANCEL);
    }
}

BEGIN_MESSAGE_MAP(CScInsertBar, CDialog)
    //{{AFX_MSG_MAP(CScInsertBar)
    ON_WM_DESTROY()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_READERS, OnReaderItemChanged)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScInsertBar UI & smart card methods


//
// Hack for fixing Fusion problems caused by the CImageList being created
// by mfc42u.dll instead of comctl32.dll.  I'll force the create call to be
// made in comctl32 and then pass the result to mfc42u.  
//
// Without this change, the ImageList icons don't get displayed when launched
// in the context of the MMC Certificate snap-in.
//
BOOL MyCreateImageList(CImageList &This, int cx, int cy, UINT nFlags, int nInitial, int nGrow)
{
    return This.Attach(ImageList_Create(cx, cy, nFlags, nInitial, nGrow));
}

/*++

InitializeReaderList:

    Initialize the list control w/ large images, and set up the
    CStringArray of image (reader/card status) descriptions...

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz 07/14/1998

--*/
void CScInsertBar::InitializeReaderList(void)
{
    HICON hicon;
    CImageList imageList;
    CString str;

    // Create the image list & give it to the list control
    MyCreateImageList(imageList, IMAGE_WIDTH, IMAGE_HEIGHT, TRUE, NUMBER_IMAGES, 0);

    // Build the image list
    for (int i = 0; i < NUMBER_IMAGES; i++ )
    {
        // Load icon and add it to image list
        hicon = NULL;
        hicon = ::LoadIcon (    AfxGetInstanceHandle(),
                                MAKEINTRESOURCE(IMAGE_LIST_IDS[i]) );
        if (NULL==hicon) {
            break; // what can we do?
        }
        imageList.Add (hicon);

    }

    // Be sure that all the small icons were added.
    _ASSERTE(imageList.GetImageCount() == NUMBER_IMAGES);

    m_lstReaders.SetImageList(&imageList, (int) LVSIL_NORMAL);
    imageList.Detach();
}


/*++

UpdateStatusList:

    This routine resets the list box display

Arguments:

    None.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Amanda Matlosz  06/15/1998

Notes:

    Strings need to be converted from type stored in the smartcard
    thread help classes to this dialog's build type (i.e. UNICODE/ANSI)!!!!

--*/
void CScInsertBar::UpdateStatusList(CSCardReaderStateArray* paReaderState)
{

    CString strCardStatus, strCardName;
    CSCardReaderState* pReader = NULL;
    CSCardReaderState* pSelectedRdr = NULL;
    LV_ITEM lv_item;

    //
    // Update the reader information
    //

    m_paReaderState = paReaderState;

    // reset previous knowledge re: reader/card status
    m_ediName.SetWindowText(_T(""));
    m_ediStatus.SetWindowText(_T(""));
    m_lstReaders.DeleteAllItems();

    if (NULL != m_paReaderState)
    {
        // Insert (new) items

        lv_item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lv_item.cchTextMax = MAX_ITEMLEN;

        int nNumReaders = (int)m_paReaderState->GetSize();
        for(int nIndex = 0; nIndex < nNumReaders; nIndex++)
        {
            // Setup struct for system reader list
            pReader = m_paReaderState->GetAt(nIndex);
            _ASSERTE(NULL != pReader);

            lv_item.iItem = nIndex;
            lv_item.stateMask = 0;
            lv_item.state = 0;
            lv_item.iSubItem = 0;
            lv_item.iImage = (int)READEREMPTY;
            lv_item.pszText = NULL;
            // set lparam to the reader ptr so we can fetch the readerinfo later
            lv_item.lParam = (LPARAM)pReader;

            //
            // Get the card status: image, and select OK card
            //

            if (NULL != pReader)
            {
                lv_item.pszText = (LPTSTR)(LPCTSTR)(pReader->strReader);

                DWORD dwState = pReader->dwState;
                if (dwState == SC_STATUS_NO_CARD)
                {
                    lv_item.iImage = (int)READEREMPTY;
                }
                else if (dwState == SC_STATUS_ERROR)
                {
                    lv_item.iImage = (int)READERERROR;
                }
                else
                {
                    if (pReader->fOK)
                    {
                        lv_item.iImage = (int)READERLOADED;
                    }
                    else
                    {
                        lv_item.iImage = (int)WRONGCARD;
                    }
                }

                // Select if this is a search card
                if (pReader->fOK && (NULL==pSelectedRdr))
                {
                    lv_item.state = LVIS_SELECTED | LVIS_FOCUSED;

                    // Set that a selection has occurred
                    pSelectedRdr = pReader;
                }
            }

            // Add Item
            m_lstReaders.InsertItem(&lv_item);
        }

        // indicate that the reader selection has changed
        if (NULL != pSelectedRdr)
        {
            OnReaderSelChange(pSelectedRdr);
        }
        else
        {
            // select the first item in the list
            m_lstReaders.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, 0);
            OnReaderSelChange(m_paReaderState->GetAt(0));
        }
        m_lstReaders.SetFocus(); // TODO: ?? Remove this? ??
    }
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertBar message handlers


/*++

void ShowHelp:

    Helper function for OnHelpInfo and OnContextMenu.

BOOL OnHelpInfo:

    Called by the MFC framework when the user hits F1.

void OnContextMenu

    Called by the MFC framework when the user right-clicks.

Author:

    Amanda Matlosz  03/04/1999

Note:

    These three functions work together to provide context-sensitive
    help for the insertdlg.

--*/
void CScInsertBar::ShowHelp(HWND hWnd, UINT nCommand)
{

    ::WinHelp(hWnd, _T("SCardDlg.hlp"), nCommand, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG_BAR);
}

afx_msg BOOL CScInsertBar::OnHelpInfo(LPHELPINFO lpHelpInfo)
{
    _ASSERTE(NULL != lpHelpInfo);

    ShowHelp((HWND)lpHelpInfo->hItemHandle, HELP_WM_HELP);

    return TRUE;
}

afx_msg void CScInsertBar::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    _ASSERTE(NULL != pWnd);

    ShowHelp(pWnd->m_hWnd, HELP_CONTEXTMENU);
}

void CScInsertBar::OnDestroy()
{
    // clean up image list
    m_SCardImages.DeleteImageList();

    CDialog::OnDestroy();
}


BOOL CScInsertBar::OnInitDialog()
{

    CDialog::OnInitDialog();

    //
    // prepare list control
    //

    InitializeReaderList();

    //
    // TODO: try SubclassWindow() trick. What's up with MFC?
    //
    CWnd* pEdit = NULL;
    pEdit = GetDlgItem(IDC_NAME);
    if (NULL != pEdit) m_ediName.SubclassWindow(pEdit->m_hWnd);
    pEdit = NULL;
    pEdit = GetDlgItem(IDC_STATUS);
    if (NULL != pEdit) m_ediStatus.SubclassWindow(pEdit->m_hWnd);

    return  TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*++

OnReaderItemChanged:

    Routine processes a selection change in the list control --
    if a card name is selected, it is displayed in a separate control

Arguments:

    pNMHDR - pointer to notification structure
    pResult - pointer to LRESULT

Return Value:

    Returns TRUE on success; FALSE otherwise.

Author:

    Amanda Matlosz  09/26/1998

Revision History:

--*/
void CScInsertBar::OnReaderItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    int nItem = m_lstReaders.GetNextItem(-1, LVNI_SELECTED);

    if (nItem != -1)
    {
        CSCardReaderState* pRdrSt = (CSCardReaderState*)m_lstReaders.GetItemData(nItem);
        OnReaderSelChange(pRdrSt);
    }

    *pResult = 0;
}


void CScInsertBar::OnReaderSelChange(CSCardReaderState* pSelectedRdr)
{
    _ASSERTE(pSelectedRdr);
    if (NULL != pSelectedRdr)
    {
        //
        // Change UI to show selection details
        //

        CString strStatus, strName;
        DWORD dwState = pSelectedRdr->dwState;

        strStatus.LoadString(IDS_SC_STATUS_NO_CARD + dwState - SC_STATUS_NO_CARD);

        if (dwState != SC_STATUS_NO_CARD)
        {
            strName = pSelectedRdr->strCard;
            strName.TrimLeft();
            if (strName.IsEmpty() || dwState == SC_STATUS_UNKNOWN)
            {
                strName.LoadString(IDS_SC_NAME_UNKNOWN);
            }

            if (!pSelectedRdr->fOK && (dwState >= SC_SATATUS_AVAILABLE && dwState <= SC_STATUS_EXCLUSIVE))
            {
                CString strAdd;
                strAdd.LoadString(IDS_SC_CANT_USE);
                strStatus += "  ";
                strStatus += strAdd;
            }
        }

        m_ediName.SetWindowText(strName);
        m_ediStatus.SetWindowText(strStatus);
    }

    //
    // Inform parent of change in selection, even if that sel is "NULL"
    //

    CScInsertDlg* pParent = (CScInsertDlg*)GetParent();
    _ASSERTE(NULL != pParent);
    if (NULL != pParent)
    {
        pParent->SetSelection(pSelectedRdr);
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\longhorn\scarddlg.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardDlg

Abstract:

    This file contains the outline implementation of the DLL exports
    for the Smartcard Common Dialogs
    
Author:

    Chris Dudley 2/27/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    Amanda Matlosz 07/09/1998   incorporated new select card,
                                get pin and change pin dlgs.

Notes:

--*/


/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include "stdafx.h"
#include <atlconv.cpp>
#include "resource.h"
#include "miscdef.h"
#include "SCDlg.h"
#include "ScSearch.h"
#include "ScInsDlg.h"
#include "chngpdlg.h"

#include "ScUIDlg.h" // will someday be just <winscard.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Decls -- Helper functions defined @ eof
void MString2CommaList(CString& str, LPWSTR szmString);
void MString2CommaList(CString& str, LPSTR szmString);

/////////////////////////////////////////////////////////////////////////////
// CSCardDlgApp

BEGIN_MESSAGE_MAP(CSCardDlgApp, CWinApp)
    //{{AFX_MSG_MAP(CSCardDlgApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*++

CSCardDlgApp:

    Construction.
        
Arguments:

        
Return Value:

    
Author:

    Chris Dudley 2/27/1997

--*/
CSCardDlgApp::CSCardDlgApp()
{

}

/////////////////////////////////////////////////////////////////////////////
//
// The one CSCardDlgApp object
//

CSCardDlgApp theApp;


/*++

InitInstance:

    Override for the instance initializaion.
        
Arguments:

    None
        
Return Value:

    TRUE on success; FALSE otherwise resulting in DLL NOT be loaded.
    
Author:

    Chris Dudley 2/27/1997

--*/
BOOL CSCardDlgApp::InitInstance()
{
    BOOL fResult = FALSE;

#ifdef ISOLATION_AWARE_ENABLED
    SHFusionInitializeFromModuleID (m_hInstance, 2);
#endif

    // Disable all DLL notifications...Force exported API entry point.
    fResult = DisableThreadLibraryCalls(m_hInstance);

    _ASSERTE(fResult); // DisableThreadLibraryCalls failed; can't init dll

    return fResult;
}

int CSCardDlgApp::ExitInstance()
{
#ifdef ISOLATION_AWARE_ENABLED
    SHFusionUninitialize();
#endif

    return CWinApp::ExitInstance();

}

/////////////////////////////////////////////////////////////////////////////
//
// Exported APIs from the DLL
//


/*++

GetOpenCardName:

    This is the SDK v1.0 entry point routine to open the common dialog box.
    It has been retained for backwards compatibility; it is now a wrapper
    call for GetOpenCardNameEx().
        
Arguments:

    pOCNA - Pointer to an ANSI open card name structure.
    -or-
    pOCNW - Popinter to a UNICODE open card name structure
        
Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.
    
Author:

    Chris Dudley 2/27/1997

--*/

LONG WINAPI GetOpenCardNameA(LPOPENCARDNAMEA pOCNA)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    USES_CONVERSION;

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    OPENCARDNAMEA_EX openCardNameEx;
    OPENCARD_SEARCH_CRITERIAA openCardSearchCriteria;

    try
    {
        // Check Params
        if (NULL == pOCNA)
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }
        if (pOCNA->dwStructSize != sizeof(OPENCARDNAMEA))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }


        // Translate the OPENCARDNAME struct to OPENCARDNAME_EX
        ZeroMemory((PVOID)&openCardNameEx, sizeof(openCardNameEx));
        openCardNameEx.dwStructSize = sizeof(openCardNameEx);

        openCardNameEx.hwndOwner = pOCNA->hwndOwner;
        openCardNameEx.hSCardContext = pOCNA->hSCardContext;
        openCardNameEx.lpstrTitle = pOCNA->lpstrTitle;
        openCardNameEx.dwFlags = pOCNA->dwFlags;
        openCardNameEx.lpstrRdr = pOCNA->lpstrRdr;
        openCardNameEx.nMaxRdr = pOCNA->nMaxRdr;
        openCardNameEx.lpstrCard = pOCNA->lpstrCard;
        openCardNameEx.nMaxCard = pOCNA->nMaxCard;
        openCardNameEx.lpfnConnect = pOCNA->lpfnConnect;
        openCardNameEx.pvUserData = pOCNA->pvUserData;
        openCardNameEx.dwShareMode = pOCNA->dwShareMode;
        openCardNameEx.dwPreferredProtocols = pOCNA->dwPreferredProtocols;

        // Build a OPENCARD_SEARCH_CRITERIA struct
        ZeroMemory((PVOID)&openCardSearchCriteria, sizeof(openCardSearchCriteria));
        openCardSearchCriteria.dwStructSize = sizeof(openCardSearchCriteria);

        openCardSearchCriteria.lpstrGroupNames = pOCNA->lpstrGroupNames;
        openCardSearchCriteria.nMaxGroupNames = pOCNA->nMaxGroupNames;
        openCardSearchCriteria.rgguidInterfaces = pOCNA->rgguidInterfaces;
        openCardSearchCriteria.cguidInterfaces = pOCNA->cguidInterfaces;
        openCardSearchCriteria.lpstrCardNames = pOCNA->lpstrCardNames;
        openCardSearchCriteria.nMaxCardNames = pOCNA->nMaxCardNames;
        openCardSearchCriteria.lpfnCheck = pOCNA->lpfnCheck;
        openCardSearchCriteria.lpfnConnect = pOCNA->lpfnConnect;
        openCardSearchCriteria.lpfnDisconnect = pOCNA->lpfnDisconnect;
        openCardSearchCriteria.pvUserData = pOCNA->pvUserData;
        openCardSearchCriteria.dwShareMode = pOCNA->dwShareMode;
        openCardSearchCriteria.dwPreferredProtocols = pOCNA->dwPreferredProtocols;

        openCardNameEx.pOpenCardSearchCriteria = &openCardSearchCriteria;

        // Create a "search description" based on requested card names
        CString strPrompt;
        strPrompt.Empty();
        if (NULL != pOCNA->lpstrCardNames)
        {
            DWORD cNames = AnsiMStringCount(pOCNA->lpstrCardNames);

            if (1 == cNames)
            {
                strPrompt.Format(
                    IDS_PROMPT_ONECARD,
                    A2W(pOCNA->lpstrCardNames));
            }
            else if (1 < cNames)
            {

                CString strCommaList;
                MString2CommaList(strCommaList, pOCNA->lpstrCardNames);

                strPrompt.Format(
                    IDS_PROMPT_CARDS,
                    strCommaList);
            }
        }
        if (!strPrompt.IsEmpty())
        {
            openCardNameEx.lpstrSearchDesc = (LPCSTR)W2A(strPrompt);
        }

        // Call the updated routine
        lReturn = SCardUIDlgSelectCardA(&openCardNameEx);

        // Update the (const) return values of the OPENCARDNAME struct
        pOCNA->nMaxRdr = openCardNameEx.nMaxRdr;
        pOCNA->nMaxCard = openCardNameEx.nMaxCard;
        pOCNA->dwActiveProtocol = openCardNameEx.dwActiveProtocol;
        pOCNA->hCardHandle = openCardNameEx.hCardHandle;

    }
    catch (LONG hr)
    {
        lReturn = hr;
        TRACE_CATCH(_T("GetOpenCardNameA"),hr);
    }

    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("GetOpenCardNameA"));
    }

    return lReturn;
}

LONG WINAPI GetOpenCardNameW(LPOPENCARDNAMEW pOCNW)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    OPENCARDNAMEW_EX openCardNameEx;
    OPENCARD_SEARCH_CRITERIAW openCardSearchCriteria;

    try
    {
        // Check Params
        if (NULL == pOCNW)
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }
        if (pOCNW->dwStructSize != sizeof(OPENCARDNAMEW))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }

        // Translate the OPENCARDNAME struct to OPENCARDNAME_EX
        ZeroMemory((PVOID)&openCardNameEx, sizeof(openCardNameEx));
        openCardNameEx.dwStructSize = sizeof(openCardNameEx);

        openCardNameEx.hwndOwner = pOCNW->hwndOwner;
        openCardNameEx.hSCardContext = pOCNW->hSCardContext;
        openCardNameEx.lpstrTitle = pOCNW->lpstrTitle;
        openCardNameEx.dwFlags = pOCNW->dwFlags;
        openCardNameEx.lpstrRdr = pOCNW->lpstrRdr;
        openCardNameEx.nMaxRdr = pOCNW->nMaxRdr;
        openCardNameEx.lpstrCard = pOCNW->lpstrCard;
        openCardNameEx.nMaxCard = pOCNW->nMaxCard;
        openCardNameEx.lpfnConnect = pOCNW->lpfnConnect;
        openCardNameEx.pvUserData = pOCNW->pvUserData;
        openCardNameEx.dwShareMode = pOCNW->dwShareMode;
        openCardNameEx.dwPreferredProtocols = pOCNW->dwPreferredProtocols;

        // Build a OPENCARD_SEARCH_CRITERIA struct
        ZeroMemory((PVOID)&openCardSearchCriteria, sizeof(openCardSearchCriteria));
        openCardSearchCriteria.dwStructSize = sizeof(openCardSearchCriteria);

        openCardSearchCriteria.lpstrGroupNames = pOCNW->lpstrGroupNames;
        openCardSearchCriteria.nMaxGroupNames = pOCNW->nMaxGroupNames;
        openCardSearchCriteria.rgguidInterfaces = pOCNW->rgguidInterfaces;
        openCardSearchCriteria.cguidInterfaces = pOCNW->cguidInterfaces;
        openCardSearchCriteria.lpstrCardNames = pOCNW->lpstrCardNames;
        openCardSearchCriteria.nMaxCardNames = pOCNW->nMaxCardNames;
        openCardSearchCriteria.lpfnCheck = pOCNW->lpfnCheck;
        openCardSearchCriteria.lpfnConnect = pOCNW->lpfnConnect;
        openCardSearchCriteria.lpfnDisconnect = pOCNW->lpfnDisconnect;
        openCardSearchCriteria.pvUserData = pOCNW->pvUserData;
        openCardSearchCriteria.dwShareMode = pOCNW->dwShareMode;
        openCardSearchCriteria.dwPreferredProtocols = pOCNW->dwPreferredProtocols;

        openCardNameEx.pOpenCardSearchCriteria = &openCardSearchCriteria;

        // Create a "search description" based on requested card names
        CString strPrompt;
        strPrompt.Empty();
        if (NULL != pOCNW->lpstrCardNames)
        {
            DWORD cNames = MStringCount(pOCNW->lpstrCardNames);

            if (1 == cNames)
            {
                strPrompt.Format(
                    IDS_PROMPT_ONECARD,
                    pOCNW->lpstrCardNames);
            }
            else if (1 < cNames)
            {

                CString strCommaList;
                MString2CommaList(strCommaList, pOCNW->lpstrCardNames);

                strPrompt.Format(
                    IDS_PROMPT_CARDS,
                    strCommaList);
            }
        }
        if (!strPrompt.IsEmpty())
        {
            openCardNameEx.lpstrSearchDesc = (LPCWSTR)strPrompt;
        }

        // Call the updated routine
        lReturn = SCardUIDlgSelectCardW(&openCardNameEx);

        // Update the (const) return values of the OPENCARDNAME struct
        pOCNW->nMaxRdr = openCardNameEx.nMaxRdr;
        pOCNW->nMaxCard = openCardNameEx.nMaxCard;
        pOCNW->dwActiveProtocol = openCardNameEx.dwActiveProtocol;
        pOCNW->hCardHandle = openCardNameEx.hCardHandle;

    }
    catch (LONG hr)
    {
        lReturn = hr;
        TRACE_CATCH(_T("GetOpenCardNameW"),hr);
    }

    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("GetOpenCardNameW"));
    }

    return lReturn;
}


/*++

LONG SCardDlgExtendedError:

    This is an old entry point for getting extended errors from the
    dialog. Please use the lLastError member of the OPENCARDNAME struct.
        
Arguments:

    None.
        
Return Value:

    None.
    
Author:

    Chris Dudley 2/27/1997

--*/
LONG WINAPI SCardDlgExtendedError (void)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LONG        lReturn = E_NOTIMPL;

    // NO LONGER IMPLEMENTED

    return lReturn;
}


/*++

SCardUIDlgSelectCard:

    This is the entry point routine to open the common dialog box, introduced
    in the Microsoft Smart Card SDK v1.x.
        
Arguments:

    pOCNA - Pointer to an ANSI open card name (ex) structure.
    -or-
    pOCNW - Pointer to a UNICODE open card name (ex) structure.
        
Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.
    
Author:

    Amanda Matlosz  6/11/98

--*/

LONG WINAPI SCardUIDlgSelectCardA(LPOPENCARDNAMEA_EX pOCNA)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    CWnd wndParent;
    BOOL fEnableUI = FALSE;
    INT_PTR nResponse = IDCANCEL;
    int nResult = 0;
    DWORD dwOKCards = 0;

    try
    {
        // Check Params
        if (!CheckOCN(pOCNA))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }

        // Determine names of all acceptable cards
        CTextMultistring mstrOKCards;
        ListAllOKCardNames(pOCNA, mstrOKCards);
                
        //
        // Do a silent search intially to determine # of suitable cards
        // currently available and/or connect to a card if min or no UI
        //
        lReturn = NoUISearch(pOCNA, &dwOKCards, (LPCSTR)mstrOKCards);

        //
        // If we haven't successfully selected a card and we can show UI,
        // raise the dialog
        //
        if (SCARD_S_SUCCESS != lReturn && !(pOCNA->dwFlags & SC_DLG_NO_UI))
        {
            // Now we can init the common dialog
            wndParent.Attach(pOCNA->hwndOwner);
            CScInsertDlg dlgCommon(&wndParent);

#ifdef ISOLATION_AWARE_ENABLED
            CThemeContextActivator activator;
#endif

            lReturn = dlgCommon.Initialize(pOCNA, dwOKCards, (LPCSTR)mstrOKCards);
            if(SCARD_S_SUCCESS != lReturn)
            {
                throw lReturn;
            }

            nResponse = dlgCommon.DoModal();

            // If cancel/closed return error
            switch (nResponse)
            {
            case IDOK: // absolutely sure of total success!
                break;
            case IDCANCEL:
                lReturn = dlgCommon.m_lLastError;
                if (0 == lReturn)
                    lReturn = SCARD_W_CANCELLED_BY_USER; // not SCARD_E_CANCELLED
                break;
            default:
                _ASSERTE(FALSE);
            case -1:
            case IDABORT:
                lReturn = dlgCommon.m_lLastError;
                if (0 == lReturn)
                    lReturn = SCARD_F_UNKNOWN_ERROR;
                break;
            }
        }
    }
    catch (LONG hr)
    {
        lReturn = hr;
        TRACE_CATCH(_T("SCardUIDlgSelectCardA"),hr);
    }

    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("SCardUIDlgSelectCardA"));
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return lReturn;
}


LONG WINAPI SCardUIDlgSelectCardW(LPOPENCARDNAMEW_EX pOCNW)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Locals
    LONG lReturn = SCARD_S_SUCCESS;
    CWnd wndParent;
    BOOL fEnableUI = FALSE;
    INT_PTR nResponse = IDCANCEL;
    DWORD dwOKCards = 0;

    try
    {
        // Check Params
        if (!CheckOCN(pOCNW))
        {
            throw (LONG)SCARD_E_INVALID_VALUE;
        }

        // Determine names of all acceptable cards
        CTextMultistring mstrOKCards;
        ListAllOKCardNames(pOCNW, mstrOKCards);

        //
        // Do a silent search intially to determine # of suitable cards and/or
        // connect to a card according to display mode (min or no UI)
        //
        lReturn = NoUISearch(pOCNW, &dwOKCards, (LPCWSTR)mstrOKCards);

        //
        // If we haven't successfully selected a card and we can show UI,
        // raise the dialog
        //
        if (SCARD_S_SUCCESS != lReturn && !(pOCNW->dwFlags & SC_DLG_NO_UI))
        {

            // Now we can init the common dialog
            wndParent.Attach(pOCNW->hwndOwner);
            CScInsertDlg dlgCommon(&wndParent);

#ifdef ISOLATION_AWARE_ENABLED
            CThemeContextActivator activator;
#endif

            // Store Pointer and open dialog
            lReturn = dlgCommon.Initialize(pOCNW, dwOKCards, (LPCWSTR)mstrOKCards);
            if (SCARD_S_SUCCESS != lReturn)
            {
                throw (lReturn);
            }

            nResponse = dlgCommon.DoModal();

            // If cancel/closed return error
            switch (nResponse)
            {
            case IDOK:  // absolutely sure of total success!
                break;
            case IDCANCEL:
                lReturn = SCARD_W_CANCELLED_BY_USER; // not SCARD_E_CANCELLED
                break;
            default:
                _ASSERTE(FALSE);
            case -1:
            case IDABORT:
                lReturn = dlgCommon.m_lLastError;
                if (0 == lReturn)
                    lReturn = SCARD_F_UNKNOWN_ERROR;
                break;
            }
        }
    }
    catch (LONG lErr)
    {
        lReturn = lErr;
        TRACE_CATCH(_T("SCardUIDlgSelectCardW"),lReturn);
    }
    catch (...) {
        lReturn = (LONG) SCARD_E_UNEXPECTED;
        TRACE_CATCH_UNKNOWN(_T("SCardUIDlgSelectCardW"));
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return lReturn;
}


/*++

SCardUIDlgGetPIN:

        
Arguments:

        
Return Value:

    A LONG value indicating the status of the requested action.
    
Author:

    Amanda Matlosz  06/18/1998

--*/

LONG WINAPI SCardUIDlgGetPINA(LPPINPROMPT pPinPrompt)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INT_PTR nResponse = IDCANCEL; // result of DoModal.

    CWnd wndParent;
    wndParent.Attach(pPinPrompt->hwndOwner);

    CGetPinDlg dlgGetPin(&wndParent);
    if (dlgGetPin.SetAttributes(pPinPrompt))
    {
#ifdef ISOLATION_AWARE_ENABLED
        CThemeContextActivator activator;
#endif

        nResponse = dlgGetPin.DoModal();
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return (LONG)nResponse;
}


/*++

SCardUIDlgChangePIN:

        
Arguments:

        
Return Value:

    A LONG value indicating the status of the requested action.
    
Author:

    Amanda Matlosz  06/18/1998

--*/

LONG WINAPI SCardUIDlgChangePINA(LPCHANGEPIN pChangePin)
{
    // Setup the correct module state information
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INT_PTR nResponse = IDCANCEL; // result of DoModal.

    CWnd wndParent;
    wndParent.Attach(pChangePin->hwndOwner);

    CChangePinDlg dlgChangePin(&wndParent);
    if (dlgChangePin.SetAttributes(pChangePin))
    {
#ifdef ISOLATION_AWARE_ENABLED
        CThemeContextActivator activator;
#endif
        nResponse = dlgChangePin.DoModal();
    }

    if (NULL != wndParent.m_hWnd)
    {
        wndParent.Detach();
    }

    return (LONG)nResponse;
}



///////////////////////////////////////////////////////////////////////////////
// Helper functions

void MString2CommaList(CString& str, LPWSTR szmString)
{
    str.Empty();

    if (NULL == szmString)
    {
        return;
    }

    LPCWSTR szm = szmString;
    szm = FirstString(szm);
    str = szm;
    for(szm = NextString(szm); NULL != szm; szm = NextString(szm))
    {
        str += ", ";
        str += szm;
    }
}

void MString2CommaList(CString& str, LPSTR szmString)
{
    USES_CONVERSION;

    str.Empty();

    if (NULL == szmString)
    {
        return;
    }

    LPCSTR szm = szmString;
    str += A2W(szm);
    szm = szm + (sizeof(CHAR)*(strlen(szm)+1));
    while (NULL != szm && NULL != *szm)
    {
        str += ", ";
        str += A2W(szm);
        szm = szm + (sizeof(CHAR)*(strlen(szm)+1));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scarddlg\longhorn\scdlg.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCDlg

Abstract:

	This file defines the CSCardDlgApp class for the SmartCard
	Common Control DLL
	
Author:

    Chris Dudley 2/27/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:


Notes:

--*/

#ifndef __SCDLG_H__
#define __SCDLG_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
//
// CSCardDlgApp
//

class CSCardDlgApp : public CWinApp
{
public:
	CSCardDlgApp();

// Overrides

	BOOL InitInstance();
	int ExitInstance();

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSCardDlgApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CSCardDlgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

#endif //__SCDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\controls\scuisupp\scuisupp.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    scuisupp

Abstract:

    Support for smart card certificate selection UI

Author:

    Klaus Schutz

--*/

#include "stdafx.h"
#include <wincrypt.h>
#include <winscard.h>
#include <winwlx.h>
#include <string.h>

#include "calaislb.h"
#include "scuisupp.h"
#include "StatMon.h"    // smart card reader status monitor
#include "scevents.h"

#include <mmsystem.h>

typedef struct _READER_DATA 
{
	CERT_ENUM			CertEnum;
	LPTSTR				pszReaderName;
	LPTSTR				pszCardName;
	LPTSTR				pszCSPName;

} READER_DATA, *PREADER_DATA;

typedef struct _THREAD_DATA
{
	// handle to heap of this thread
	HANDLE				hHeap;

	// the smart card context we use
	SCARDCONTEXT		hSCardContext;	

	// the window we send messages to
	HWND				hWindow;

	// event to signal that the monitor thread can terminate
	HANDLE				hClose;

	// thread handle for the monitor thread
    HANDLE				hThread;

	// number of readers detected
	DWORD				dwNumReaders;

	// messages to be sent to parent
	UINT				msgReaderArrival;
	UINT				msgReaderRemoval;
	UINT				msgSmartCardInsertion;
	UINT				msgSmartCardRemoval;
	UINT				msgSmartCardStatus;
	UINT				msgSmartCardCertAvail;

	// reader state array
	PSCARD_READERSTATE	rgReaders;

	// number of removed readers
	DWORD				dwRemovedReaders;

	// pointer array of removed reader data 
	PREADER_DATA		*ppRemovedReaderData;

} THREAD_DATA, *PTHREAD_DATA;

#ifndef TEST

#define SC_DEBUG(a) 

#else

#define SC_DEBUG(a) _DebugPrint a

#undef PostMessage
#define PostMessage(a,b,c,d) _PostMessage(a, b, c, d)

#undef RegisterWindowMessage
#define RegisterWindowMessage(a) _RegisterWindowMessage(a)

void
__cdecl
_DebugPrint(
    LPCTSTR szFormat,
    ...
    )
{
    TCHAR szBuffer[1024];
    va_list ap;

    va_start(ap, szFormat);
    _vstprintf(szBuffer, szFormat, ap);
    OutputDebugString(szBuffer); 
	_tprintf(szBuffer);
}

#define MAX_MESSAGES 10

static struct {

	UINT	dwMessage;
	LPCTSTR lpMessage;

} Messages[MAX_MESSAGES];

UINT
_RegisterWindowMessage(
	LPCTSTR lpString
	)
{
	for (DWORD dwIndex = 0; dwIndex < MAX_MESSAGES; dwIndex += 1) {

		if (Messages[dwIndex].lpMessage == NULL) {

			break;
		}

		if (_tcscmp(lpString, Messages[dwIndex].lpMessage) == 0) {

			return Messages[dwIndex].dwMessage;
		}
	}

	Messages[dwIndex].lpMessage = lpString;
	Messages[dwIndex].dwMessage = dwIndex;

	return dwIndex;
}

LPCTSTR
_GetWindowMessageString(
	UINT dwMessage
	)
{
	for (DWORD dwIndex = 0; dwIndex < MAX_MESSAGES; dwIndex += 1) {

		if (Messages[dwIndex].lpMessage == NULL) {

			return  TEXT("(NOT DEFINED)");
		}

		if (dwMessage == Messages[dwIndex].dwMessage) {

			return Messages[dwIndex].lpMessage;
		}
	}

	return TEXT("(INTERNAL ERROR)");
}

LRESULT
_PostMessage(
	HWND hWindow,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam
	)
{
	SC_DEBUG((TEXT("Received message %s\n"), _GetWindowMessageString(Msg)));

	return 0;	
}

#endif

static 
LPCTSTR
FirstString(
    IN LPCTSTR szMultiString
    )
/*++

FirstString:

    This routine returns a pointer to the first string in a multistring, or NULL
    if there aren't any.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the first null-terminated string in the structure, or NULL if
    there are no strings.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/
{
    LPCTSTR szFirst = NULL;

    try
    {
        if (0 != *szMultiString)
            szFirst = szMultiString;
    }
    catch (...) {}

    return szFirst;
}

static
LPCTSTR
NextString(
    IN LPCTSTR szMultiString)
/*++

NextString:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the current string in a
    multi-string structure, it returns the next string, or NULL if no other
    strings follow the current string.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the next Null-terminated string in the structure, or NULL if
    no more strings follow.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/
{
    LPCTSTR szNext;

    try
    {
        DWORD cchLen = lstrlen(szMultiString);
        if (0 == cchLen)
            szNext = NULL;
        else
        {
            szNext = szMultiString + cchLen + 1;
            if (0 == *szNext)
                szNext = NULL;
        }
    }

    catch (...)
    {
        szNext = NULL;
    }

    return szNext;
}

static 
void
FreeReaderData(
	PTHREAD_DATA pThreadData,
	PREADER_DATA pReaderData
	)
{
	if (pThreadData->hSCardContext && pReaderData->pszCardName) {

		SCardFreeMemory(pThreadData->hSCardContext, pReaderData->pszCardName);
		pReaderData->pszCardName = NULL;
		pReaderData->CertEnum.pszCardName = NULL;
	}

	if (pThreadData->hSCardContext && pReaderData->pszCSPName) {

		SCardFreeMemory(pThreadData->hSCardContext, pReaderData->pszCSPName);
		pReaderData->pszCSPName = NULL;
	}

	if (pReaderData->CertEnum.pCertContext) {

		CertFreeCertificateContext(pReaderData->CertEnum.pCertContext);
		pReaderData->CertEnum.pCertContext = NULL;
	}

	pReaderData->CertEnum.dwStatus = 0;
}

static
void 
UpdateCertificates(
	PTHREAD_DATA pThreadData,
	PSCARD_READERSTATE pReaderState
	)
{
	PREADER_DATA pReaderData = (PREADER_DATA) pReaderState->pvUserData;

	FreeReaderData(pThreadData, pReaderData);

	SC_DEBUG((TEXT("Enumerating certificates on %s...\n"), pReaderState->szReader));

	LPTSTR pszContainerName = NULL;
	LPTSTR pszDefaultContainerName = NULL;
	PBYTE pbCert = NULL;
	HCRYPTKEY hKey = NULL;
	HCRYPTPROV hCryptProv = NULL;

	__try {

		pReaderData->CertEnum.dwStatus = SCARD_F_UNKNOWN_ERROR;

		// Get the name of the card
		DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
		LONG lReturn = SCardListCards(   
			pThreadData->hSCardContext,
			pReaderState->rgbAtr,
			NULL,
			0,
			(LPTSTR)&pReaderData->pszCardName,
			&dwAutoAllocate
			);

		if (lReturn != SCARD_S_SUCCESS) {

			SC_DEBUG((TEXT("Failed to get card name for card in %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = lReturn;
			__leave;
		}

		pReaderData->CertEnum.pszCardName = pReaderData->pszCardName;

		dwAutoAllocate = SCARD_AUTOALLOCATE;
		lReturn = SCardGetCardTypeProviderName(
			pThreadData->hSCardContext,
			pReaderData->pszCardName,
			SCARD_PROVIDER_CSP,
			(LPTSTR)&pReaderData->pszCSPName,
			&dwAutoAllocate
			);

		if (lReturn != SCARD_S_SUCCESS) {

			SC_DEBUG((TEXT("Failed to get CSP name from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = SCARD_E_UNKNOWN_CARD;
			__leave;
		}

		pszContainerName = (LPTSTR) HeapAlloc(
			pThreadData->hHeap,
			HEAP_ZERO_MEMORY, 
			(_tcslen(pReaderState->szReader) + 10) * sizeof(TCHAR)
			);

		if (pszContainerName == NULL) {

			pReaderData->CertEnum.dwStatus = SCARD_E_NO_MEMORY;
			__leave;
		}

		_stprintf(
			pszContainerName, 
			TEXT("\\\\.\\%s\\"),  
			pReaderState->szReader);

		BOOL fSuccess = CryptAcquireContext(
			&hCryptProv,
			pszContainerName, 
			pReaderData->pszCSPName,
			PROV_RSA_FULL,
			CRYPT_SILENT 
			);

		if (fSuccess == FALSE) {

			SC_DEBUG((
				TEXT("Failed to acquire context on %s (%lx)\n"), 
				pReaderState->szReader, GetLastError()
				));

			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		// Get the default container name, so we can use it
		DWORD cbDefaultContainerName;
		fSuccess = CryptGetProvParam(
			hCryptProv,
			PP_CONTAINER,
			NULL,
			&cbDefaultContainerName,
			0
			);

		if (!fSuccess) {

			SC_DEBUG((TEXT("Failed to get default container name from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		pszDefaultContainerName = 
			(LPTSTR) HeapAlloc(pThreadData->hHeap, HEAP_ZERO_MEMORY, cbDefaultContainerName * sizeof(TCHAR));

		if (NULL == pszContainerName) {

			pReaderData->CertEnum.dwStatus = SCARD_E_NO_MEMORY;
			__leave;
		}

		fSuccess = CryptGetProvParam(
			hCryptProv,
			PP_CONTAINER,
			(PBYTE)pszDefaultContainerName,
			&cbDefaultContainerName,
			0
			);

		if (!fSuccess) {

			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		fSuccess = CryptGetUserKey(
			hCryptProv,
			AT_KEYEXCHANGE,
			&hKey
			);

		if (fSuccess == FALSE) {

			SC_DEBUG((TEXT("Failed to get key from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		// get length of certificate
		DWORD cbCertLen = 0;
		fSuccess = CryptGetKeyParam(
			hKey,
			KP_CERTIFICATE,
			NULL,
			&cbCertLen, 
			0
			);

		DWORD dwError = GetLastError();

		if (fSuccess == FALSE && dwError != ERROR_MORE_DATA) {

			SC_DEBUG((TEXT("Failed to get certificate from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		pbCert = (LPBYTE) HeapAlloc(pThreadData->hHeap, HEAP_ZERO_MEMORY, cbCertLen);

		if (pbCert == NULL)
		{
			pReaderData->CertEnum.dwStatus = SCARD_E_NO_MEMORY;
			__leave;
		}

		// read the certificate off the card
		fSuccess = CryptGetKeyParam(
			hKey,
			KP_CERTIFICATE,
			pbCert,
			&cbCertLen,
			0
			);

		if (fSuccess == FALSE) {

			SC_DEBUG((TEXT("Failed to get certificate from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		PCERT_CONTEXT pCertContext = (PCERT_CONTEXT) CertCreateCertificateContext(
			X509_ASN_ENCODING,
			pbCert,
			cbCertLen
			);

		if (pCertContext == NULL) {

			__leave;
		}

		pReaderData->CertEnum.dwStatus = SCARD_S_SUCCESS;
		pReaderData->CertEnum.pCertContext = pCertContext;
		SC_DEBUG((TEXT("Found new certificate on %s\n"), pReaderState->szReader));

		PostMessage(
			pThreadData->hWindow, 
			pThreadData->msgSmartCardCertAvail, 
			(WPARAM) &pReaderData->CertEnum,
			0 
			);
    } 

	__finally {

		//
		// free all allocated memory
		//
 		if (NULL != pszContainerName)
		{
			HeapFree(pThreadData->hHeap, 0, pszContainerName);
		}

		if (NULL != pszDefaultContainerName)
		{
			HeapFree(pThreadData->hHeap, 0, pszDefaultContainerName);
		}

		if (NULL != pbCert)
		{
			HeapFree(pThreadData->hHeap, 0, pbCert);                                    
		}

		if (NULL != hKey)
		{
			CryptDestroyKey(hKey);
		}

		if (NULL != hCryptProv)
		{
			CryptReleaseContext(hCryptProv, 0);
		}
	}
}

static
void
StopMonitorReaders(
    PTHREAD_DATA pThreadData
    )
{
    _ASSERT(pThreadData != NULL);

    SetEvent(pThreadData->hClose);

    if (pThreadData->hSCardContext) {
     	
        SCardCancel(pThreadData->hSCardContext);  	
    }
}

static 
void
RemoveCard(
	PTHREAD_DATA pThreadData,
	PREADER_DATA pReaderData
	)
{
	SC_DEBUG((TEXT("Smart Card removed from %s\n"), pReaderData->CertEnum.pszReaderName));

	PostMessage(
		pThreadData->hWindow, 
		pThreadData->msgSmartCardRemoval, 
		(WPARAM) &pReaderData->CertEnum,
		0					
		);
}

static
BOOL
AddReader(
	PTHREAD_DATA pThreadData,
	LPCTSTR pszNewReader
	)
{
	PSCARD_READERSTATE pScardReaderState = 
		(PSCARD_READERSTATE) HeapReAlloc(
		   pThreadData->hHeap,
		   HEAP_ZERO_MEMORY,
		   pThreadData->rgReaders, 
		   (pThreadData->dwNumReaders + 1) * (sizeof(SCARD_READERSTATE))
		   );

	if (pScardReaderState == NULL) {

		return FALSE;
	}

	pThreadData->rgReaders = pScardReaderState;

	PREADER_DATA pReaderData = 
		(PREADER_DATA) HeapAlloc(
			pThreadData->hHeap, 
			HEAP_ZERO_MEMORY, 
			sizeof(READER_DATA)
			);

	if (pReaderData == NULL) {

		return FALSE;
	}

	pThreadData->rgReaders[pThreadData->dwNumReaders].pvUserData = 
		pReaderData;

	LPTSTR pszReaderName = 
		(LPTSTR) HeapAlloc(
			pThreadData->hHeap, 
			HEAP_ZERO_MEMORY, 
			(_tcslen(pszNewReader) + 1) * sizeof(TCHAR)
			);

	if (pszReaderName == NULL) {

		return FALSE;		
	}

	_tcscpy(pszReaderName, pszNewReader);

	pReaderData->pszReaderName = pszReaderName;

	pThreadData->rgReaders[pThreadData->dwNumReaders].szReader = 
		pszReaderName;

	pThreadData->rgReaders[pThreadData->dwNumReaders].dwCurrentState = 
		SCARD_STATE_EMPTY;

	pReaderData->CertEnum.pszReaderName = (LPTSTR) pszReaderName;
	pThreadData->dwNumReaders++;

	PostMessage(
		pThreadData->hWindow,
		pThreadData->msgReaderArrival,
		(WPARAM) &pReaderData->CertEnum,
		0
		);

	return TRUE;
}

static
BOOL
RemoveReader(
	PTHREAD_DATA pThreadData,
	PSCARD_READERSTATE pReaderState
	)
{
	PREADER_DATA pReaderData = 
		(PREADER_DATA) pReaderState->pvUserData;

	if (pReaderState->dwCurrentState & SCARD_STATE_PRESENT) {

		RemoveCard(
			pThreadData,
			pReaderData
			);
	}

	SC_DEBUG((TEXT("Reader %s removed\n"), pReaderData->CertEnum.pszReaderName));

	PostMessage(
		pThreadData->hWindow,
		pThreadData->msgReaderRemoval,
		(WPARAM) &pReaderData->CertEnum,
		0
		);

	// build an array of reader data that needs to be deleted on exit
	PREADER_DATA *ppRemovedReaderData = NULL;

	if (pThreadData->dwRemovedReaders == 0) {

		ppRemovedReaderData = (PREADER_DATA *) HeapAlloc(
			pThreadData->hHeap,
			HEAP_ZERO_MEMORY, 
			sizeof(PREADER_DATA)
			);

	} else {

		ppRemovedReaderData = (PREADER_DATA *) HeapReAlloc(
			pThreadData->hHeap,
			HEAP_ZERO_MEMORY,
			pThreadData->ppRemovedReaderData, 
			(pThreadData->dwRemovedReaders + 1) * sizeof(PREADER_DATA)
			);
	}

	if (ppRemovedReaderData == NULL) {

		return FALSE;
	}

	// add the reader data to the list of stuff that needs to be freed on exit
	pThreadData->ppRemovedReaderData = ppRemovedReaderData;
	pThreadData->ppRemovedReaderData[pThreadData->dwRemovedReaders] = pReaderData;

	for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; dwIndex += 1) {

		if (pReaderState == &pThreadData->rgReaders[dwIndex]) {

			// check if the reader we remove is not the last or the only one.
			if (pThreadData->dwNumReaders > 1 && dwIndex != pThreadData->dwNumReaders - 1) {

				// put the reader from the end of the list into this available slot
				pThreadData->rgReaders[dwIndex] = 
					pThreadData->rgReaders[pThreadData->dwNumReaders - 1];
			}

			// shrink the reader state array
			PSCARD_READERSTATE pReaders = (PSCARD_READERSTATE) HeapReAlloc(
				pThreadData->hHeap,
				0,
				pThreadData->rgReaders,
				(pThreadData->dwNumReaders - 1) * sizeof(SCARD_READERSTATE)
				);

			if (pReaders == NULL) {

				 return FALSE;
			}

			pThreadData->rgReaders = pReaders;

			break;
		}
	}

	pThreadData->dwNumReaders -= 1;
	pThreadData->dwRemovedReaders += 1;

	return TRUE;
}

static
BOOL
RemoveAllReaders(
	PTHREAD_DATA pThreadData
	)
{
	if (pThreadData->rgReaders == NULL) {

		return TRUE;
	}

		// This loop will destroy all the readers starting with the first one
		// dwIndex doesn't have to be incremented. pThreadData->dwNumReaders is
		// decremented in RemoveReader
	for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; ) {

		if (RemoveReader(
			   pThreadData,
			   &pThreadData->rgReaders[dwIndex]
			   ) == FALSE) {

			return FALSE;
		}
	}

		// Remove the PnP pseudo reader
	HeapFree(
		pThreadData->hHeap, 
		0, 
		pThreadData->rgReaders
		);
	pThreadData->rgReaders = NULL;

	return TRUE;
}

static 
DWORD
StartMonitorReaders( 
	LPVOID pData
    )
{
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pData;
	LPCTSTR szReaderNameList = NULL;

    //
    // We use this outer loop to restart in case the 
    // resource manager was stopped
    //
	__try {

		pThreadData->rgReaders = 
			(PSCARD_READERSTATE) HeapAlloc(
				pThreadData->hHeap, 
				HEAP_ZERO_MEMORY, 
				sizeof(SCARD_READERSTATE)
				);

		if (pThreadData->rgReaders == NULL) {

			__leave;
		}

		pThreadData->rgReaders[0].szReader = SCPNP_NOTIFICATION;
		pThreadData->rgReaders[0].dwCurrentState = 0;
		pThreadData->dwNumReaders = 1;

		while (WaitForSingleObject(pThreadData->hClose, 0) == WAIT_TIMEOUT) {

			// Acquire context with resource manager
			LONG lReturn = SCardEstablishContext(
				SCARD_SCOPE_USER,
				NULL,
				NULL,
				&pThreadData->hSCardContext
				);

			if (SCARD_S_SUCCESS != lReturn) {

				// The prev. call should never fail
				// It's better to terminate this thread.
				__leave;
			}

			szReaderNameList = NULL;
			DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
			// now list the available readers
			lReturn = SCardListReaders( 
				pThreadData->hSCardContext,
				SCARD_DEFAULT_READERS,
				(LPTSTR)&szReaderNameList,
				&dwAutoAllocate
				);

			if (SCARD_S_SUCCESS == lReturn)
			{
				// bugbug - this pointer should not be modified
				for (LPCTSTR szReader = FirstString( szReaderNameList ); 
					 szReader != NULL; 
					 szReader = NextString(szReader)) {

					BOOL fFound = FALSE;

					// now check if this reader is already in the reader array
					for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; dwIndex++) {

						if (lstrcmp(
							   szReader, 
							   pThreadData->rgReaders[dwIndex].szReader
							   ) == 0) {

							fFound = TRUE;
							break;
						}
					}

					if (fFound == FALSE) {

						if (AddReader(pThreadData, szReader) == FALSE) {

							__leave;
						}
					}
				}
			}

			BOOL fNewReader = FALSE;

			// analyze newly inserted cards 
			while (WaitForSingleObject(pThreadData->hClose, 0) == WAIT_TIMEOUT &&
				   fNewReader == FALSE) {

				lReturn = SCardGetStatusChange( 
					pThreadData->hSCardContext,
					INFINITE,
					pThreadData->rgReaders,
					pThreadData->dwNumReaders
					);

				if (SCARD_E_SYSTEM_CANCELLED == lReturn) {

					// the smart card system has been stopped
					// send notification that all readers are gone
					if (RemoveAllReaders(pThreadData) == FALSE) {

						__leave;
					}

					// Wait until it restarted
					HANDLE hCalaisStarted = CalaisAccessStartedEvent();

					if (hCalaisStarted == NULL) {

						// no way to recover. stop cert prop
						StopMonitorReaders(pThreadData);
						break;             	
					}

					HANDLE lHandles[2] = { hCalaisStarted, pThreadData->hClose };

					lReturn = WaitForMultipleObjectsEx(
						2,
						lHandles,
						FALSE,
						INFINITE,
						FALSE
						);         
            
					if (lReturn != WAIT_OBJECT_0) {

						// We stop if an error occured
						StopMonitorReaders(pThreadData);
						break;             	
					}

					// Otherwise the resource manager has been restarted
					break;
				}

				if (SCARD_S_SUCCESS != lReturn)
				{
					StopMonitorReaders(pThreadData);
					break;
				}

				// Enumerate the readers and for every card change send a message
 				for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; dwIndex++)
				{
					// Check if the reader has been removed
					if ((pThreadData->rgReaders[dwIndex].dwEventState & SCARD_STATE_UNAVAILABLE)) {

						if (RemoveReader(
							   pThreadData,
							   &pThreadData->rgReaders[dwIndex]
							   ) == FALSE) {

							__leave;
						}

							// Continue the loop with the same index
						dwIndex--;
						continue;
					}

					// check if this is a card insertion
					if ((pThreadData->rgReaders[dwIndex].dwCurrentState & SCARD_STATE_EMPTY) &&
						(pThreadData->rgReaders[dwIndex].dwEventState & SCARD_STATE_PRESENT)) {

						PREADER_DATA pReaderData = 
							(PREADER_DATA) pThreadData->rgReaders[dwIndex].pvUserData;

						SC_DEBUG((TEXT("Smart Card inserted into %s\n"), pThreadData->rgReaders[dwIndex].szReader));

						PostMessage(
							pThreadData->hWindow, 
							pThreadData->msgSmartCardInsertion, 
							(WPARAM) &pReaderData->CertEnum,
							0 
							);

						// read in all certificates
						UpdateCertificates(
							pThreadData,
							&pThreadData->rgReaders[dwIndex]
							);

						PostMessage(
							pThreadData->hWindow, 
							pThreadData->msgSmartCardStatus, 
							(WPARAM) &pReaderData->CertEnum,
							0 
							);
					}

					// check if this is a card removal
					if ((pThreadData->rgReaders[dwIndex].dwCurrentState & SCARD_STATE_PRESENT) &&
						(pThreadData->rgReaders[dwIndex].dwEventState & SCARD_STATE_EMPTY)) {

						PREADER_DATA pReaderData = (PREADER_DATA) pThreadData->rgReaders[dwIndex].pvUserData;

						RemoveCard(pThreadData,	pReaderData);

						// we can't update the certificates because it would delete
						// some memory data that the caller could reference.
					}

					// Update the "current state" of this reader
					pThreadData->rgReaders[dwIndex].dwCurrentState = 
						pThreadData->rgReaders[dwIndex].dwEventState;
				}

				// check if a new reader showed up
				if ((pThreadData->dwNumReaders == 1 || 
					 pThreadData->rgReaders[0].dwCurrentState != 0) && 
					 pThreadData->rgReaders[0].dwEventState & SCARD_STATE_CHANGED) {
                
					fNewReader = TRUE;
				}

				pThreadData->rgReaders[0].dwCurrentState = 
					pThreadData->rgReaders[0].dwEventState;

			}

			// Clean up
			if (NULL != szReaderNameList)
			{
				SCardFreeMemory(pThreadData->hSCardContext, (PVOID) szReaderNameList);
				szReaderNameList = NULL;
			}

			if (NULL != pThreadData->hSCardContext)                 
			{
				SCardReleaseContext(pThreadData->hSCardContext);
				pThreadData->hSCardContext = NULL;
			}
		}
	}
	__finally {

		if (NULL != szReaderNameList)
		{
			SCardFreeMemory(pThreadData->hSCardContext, (PVOID) szReaderNameList);
		}

		if (NULL != pThreadData->hSCardContext)                 
		{
			SCardReleaseContext(pThreadData->hSCardContext);
			pThreadData->hSCardContext = NULL;
		}

		RemoveAllReaders(pThreadData);

		SC_DEBUG((TEXT("Terminating monitor thread\n")));
	}

    return TRUE;
}

HSCARDUI 
WINAPI
SCardUIInit(
    HWND hWindow
    )
{
	PTHREAD_DATA pThreadData = 
		(PTHREAD_DATA) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(THREAD_DATA));

	BOOL fSuccess = FALSE;

    __try {

		if (pThreadData == NULL) {

			__leave;
		}

		pThreadData->hHeap = GetProcessHeap();

		pThreadData->hWindow = hWindow;

		pThreadData->msgReaderArrival = 
			RegisterWindowMessage(TEXT(SCARDUI_READER_ARRIVAL));
		pThreadData->msgReaderRemoval = 
			RegisterWindowMessage(TEXT(SCARDUI_READER_REMOVAL));
		pThreadData->msgSmartCardInsertion = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_INSERTION));
		pThreadData->msgSmartCardRemoval = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_REMOVAL));
		pThreadData->msgSmartCardStatus = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_STATUS));
 		pThreadData->msgSmartCardCertAvail = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_CERT_AVAIL));

       pThreadData->hClose = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (pThreadData->hClose == NULL) {

            __leave;         	
        }

        pThreadData->hThread = CreateThread(
            NULL,
            0,
            StartMonitorReaders,
            (LPVOID) pThreadData,         
	        CREATE_SUSPENDED,
            NULL
            );

        if (pThreadData->hThread == NULL) {

            __leave;         	
        }

        ResumeThread(pThreadData->hThread);

		fSuccess = TRUE;
    }

    __finally {

		if (fSuccess == FALSE) {

			if (pThreadData && pThreadData->hClose) {

				CloseHandle(pThreadData->hClose);
			}

			if (pThreadData) {

				HeapFree(pThreadData->hHeap, 0, pThreadData);
				pThreadData = NULL;
			}
		}
    }

    return (HSCARDUI) pThreadData;
}

DWORD 
WINAPI
SCardUIExit(
	HSCARDUI hSCardUI
    )
/*++

Routine Description:
    Stops cert. propagation when the user logs out.

Arguments:
    lpvParam - Winlogon notification info.

--*/
{
	PTHREAD_DATA pThreadData = (PTHREAD_DATA) hSCardUI;

	if(NULL != pThreadData->hThread)
	{
        DWORD dwStatus;

        StopMonitorReaders(pThreadData);

        dwStatus = WaitForSingleObject(
            pThreadData->hThread, 
            INFINITE
            );
        _ASSERT(dwStatus == WAIT_OBJECT_0);

        CloseHandle(pThreadData->hClose);

		// now free all data
		for (DWORD dwIndex = 0; dwIndex < pThreadData->dwRemovedReaders; dwIndex++) {

			FreeReaderData(
				pThreadData,
				pThreadData->ppRemovedReaderData[dwIndex]
				);

			HeapFree(
				pThreadData->hHeap, 
				0, 
				pThreadData->ppRemovedReaderData[dwIndex]->pszReaderName
				);

			HeapFree(
				pThreadData->hHeap, 
				0, 
				pThreadData->ppRemovedReaderData[dwIndex]
				);
		}

		HeapFree(pThreadData->hHeap, 0, pThreadData);
	}

    return ERROR_SUCCESS;
}

#ifdef TEST
#include <conio.h>
__cdecl
main(
    int argc,
    char ** argv
    )
{
	HSCARDUI hScardUi;

	hScardUi = SCardUIInit(NULL);

	while (TRUE) {

		_sleep(1000);

		if (_kbhit()) {

			_getch();
			SCardUIExit(hScardUi);
			break;
		}
	}

	hScardUi = SCardUIInit(NULL);

	while (TRUE) {

		_sleep(1000);

		if (_kbhit()) {

			SCardUIExit(hScardUi);
			return 0;
		}
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\calaislb.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CalaisLb

Abstract:

    This header file incorporates the various other header files of classes
    supported by the Calais Library, and provides for common definitions.
    Things defined by this header file shouldn't be shared with the public.

Author:

    Doug Barlow (dbarlow) 7/16/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _CALAISLB_H_
#define _CALAISLB_H_

#include "SCardLib.h"
#include "QueryDB.h"
#include "ChangeDB.h"
#include "NTacls.h"


//
////////////////////////////////////////////////////////////////////////////////
//
//  Registry access names.
//

static const TCHAR
    SCARD_REG_SCARD[]     = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais"),
    SCARD_REG_READERS[]   = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"),
    SCARD_REG_CARDS[]     = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
    SCARD_REG_DEVICE[]    = TEXT("Device"),
    SCARD_REG_GROUPS[]    = TEXT("Groups"),
    SCARD_REG_ATR[]       = TEXT("ATR"),
    SCARD_REG_ATRMASK[]   = TEXT("ATRMask"),
    SCARD_REG_GUIDS[]     = TEXT("Supported Interfaces"),
    SCARD_REG_PPV[]       = TEXT("Primary Provider"),
    SCARD_REG_CSP[]       = TEXT("Crypto Provider"),
    SCARD_REG_OEMCFG[]    = TEXT("OEM Configuration");
#ifdef ENABLE_SCARD_TEMPLATES
static const TCHAR
    SCARD_REG_TEMPLATES[] = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCard Templates");
#else
#define SCARD_REG_TEMPLATES NULL
#endif // ENABLE_SCARD_TEMPLATES
#endif // _CALAISLB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\changedb.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    changeDB

Abstract:

    This header file defines the internal Calais Database modification routines.

Author:

    Doug Barlow (dbarlow) 1/29/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CHANGEDB_H_
#define _CHANGEDB_H_

extern void
IntroduceReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName);

extern void
ForgetReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName);

extern void
IntroduceReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName);

extern void
ForgetReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName);

extern void
AddReaderToGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName);

extern void
RemoveReaderFromGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName);

extern void
IntroduceCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen);

extern void
SetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider);

extern void
ForgetCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName);

#ifdef ENABLE_SCARD_TEMPLATES
extern void
IntroduceCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen);

extern void
SetCardTypeTemplateProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szTemplateName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider);

extern void
ForgetCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName);

extern void
IntroduceCardTypeFromTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCTSTR szFriendlyName = NULL);
#endif // ENABLE_SCARD_TEMPLATES

#endif // _CHANGEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\ntacls.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NTacls

Abstract:

    This header file describes the classes used in managing ACLs within Calais.

Author:

    Doug Barlow (dbarlow) 1/24/1997

Environment:

    Windows NT, Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _NTACLS_H_
#define _NTACLS_H_

#include <wtypes.h>
#include <Malloc.h>
#include "buffers.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor

class CSecurityDescriptor
{
public:

    typedef struct {
        SID_IDENTIFIER_AUTHORITY sid;
        DWORD dwRidCount;   // Actual number of RIDs following
        DWORD rgRids[2];
    } SecurityId;

    static const SecurityId
        SID_Null,
        SID_World,
        SID_Owner,
        SID_Group,
        SID_Admins,
        SID_SrvOps,
        SID_DialUp,
        SID_Network,
        SID_Batch,
        SID_Interactive,
        SID_Service,
        SID_System,
        SID_LocalService,
        SID_SysDomain,
        SID_RemoteInteractive;

    CSecurityDescriptor();
    ~CSecurityDescriptor();

public:
    PSECURITY_DESCRIPTOR m_pSD;
    PSID m_pOwner;
    PSID m_pGroup;
    PACL m_pDACL;
    PACL m_pSACL;
    SECURITY_ATTRIBUTES m_saAttrs;
    BOOL m_fInheritance;


public:
    HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
    HRESULT AttachObject(HANDLE hObject);
    HRESULT Initialize();
    HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
    HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
    HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
    HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
    HRESULT Allow(const SecurityId *psidPrincipal, DWORD dwAccessMask);
    HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
    HRESULT AllowOwner(DWORD dwAccessMask);
    HRESULT Deny(const SecurityId *psidPrincipal, DWORD dwAccessMask);
    HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
    HRESULT Revoke(LPCTSTR pszPrincipal);
    void    SetInheritance (BOOL fInheritance) {m_fInheritance = fInheritance;};

    HRESULT AddAccessAllowedACEToACL(PACL *Acl, DWORD dwAccessMask);

    // utility functions
    // Any PSID you get from these functions should be free()ed
    static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
    static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
    static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
    static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
    static HRESULT CopyACL(PACL pDest, PACL pSrc);
    static HRESULT GetCurrentUserSID(PSID *ppSid);
    static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
    static HRESULT AddAccessAllowedACEToACL(PACL *Acl, const SecurityId *psidPrincipal, DWORD dwAccessMask);
    static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
    static HRESULT AddAccessDeniedACEToACL(PACL *Acl, const SecurityId *psidPrincipal, DWORD dwAccessMask);
    static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
    static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

    operator PSECURITY_DESCRIPTOR()
    {
        return m_pSD;
    }

    operator LPSECURITY_ATTRIBUTES();

};



#endif // _NTACLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\handles.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    handles

Abstract:

    This header file describes the handle management service.

Author:

    Doug Barlow (dbarlow) 5/9/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _HANDLES_H_
#define _HANDLES_H_

#ifndef HANDLE_TYPE
#define HANDLE_TYPE DWORD_PTR
#endif

#if defined(_WIN64) || defined(WIN64)
static const DWORD_PTR
    HANDLE_INDEX_MASK   = 0x000000007fffffff,
    HANDLE_COUNT_MASK   = 0x00ffffff00000000,
    HANDLE_ID_MASK      = 0xff00000000000000;
static const DWORD
    HANDLE_INDEX_OFFSET = 0,
    HANDLE_COUNT_OFFSET = 32,
    HANDLE_ID_OFFSET    = 56;
#elif defined(_WIN32) || defined(WIN32)
static const DWORD_PTR
    HANDLE_INDEX_MASK   = 0x0000ffff,
    HANDLE_COUNT_MASK   = 0x00ff0000,
    HANDLE_ID_MASK      = 0xff000000;
static const DWORD
    HANDLE_INDEX_OFFSET = 0,
    HANDLE_COUNT_OFFSET = 16,
    HANDLE_ID_OFFSET    = 24;
#else
#error "Unsupported handle type length"
#endif

class CHandleList;


//
//==============================================================================
//
//  CCritSect
//

class CCritSect
{
public:
    CCritSect(LPCRITICAL_SECTION pCritSect)
    {
        m_pCritSect = pCritSect;
        EnterCriticalSection(m_pCritSect);
    };

    ~CCritSect()
    {
        LeaveCriticalSection(m_pCritSect);
    };

protected:
    LPCRITICAL_SECTION m_pCritSect;
};


//
//==============================================================================
//
//  CHandle
//

class CHandle
{
public:
    BOOL IsBad(void)
    { return m_fIsBad;};

protected:
    //  Constructors & Destructor

    CHandle()
    {
        m_dwCount = 0;
        m_dwIndex = (DWORD)(HANDLE_INDEX_MASK >> HANDLE_INDEX_OFFSET);
        m_fIsBad = FALSE;
    };

    virtual ~CHandle() { /* Mandatory Base Class Destructor */ };


    //  Properties

    DWORD m_dwCount;
    DWORD m_dwIndex;
    BOOL m_fIsBad;


    //  Methods

    virtual void Cancel(void) {};
    virtual void ClosePipes(void) {};
    virtual void MarkAsBad(BOOL fCancel)
    {
        m_fIsBad = TRUE;

        if (fCancel)
        {
            Cancel();

            //
            // Close the pipes too.
            //
            ClosePipes();
        }

    };

    friend class CHandleList;
};


//
//==============================================================================
//
//  CHandleList
//

class CHandleList
{
public:

    //  Constructors & Destructor

    CHandleList(DWORD dwHandleId)
    {
        m_dwId = dwHandleId;
        m_Max = m_Mac = 0;
        m_phList = NULL;
        m_fInitFailed = FALSE;

        try {
            if (! InitializeCriticalSectionAndSpinCount(
                    &m_critSect, 0x80000000))
                m_fInitFailed = TRUE;
        }
        catch (HRESULT hr) {
            m_fInitFailed = TRUE;
        }
    };

    virtual ~CHandleList()
    {
        if (m_fInitFailed)
            return;

        Clear();
        DeleteCriticalSection(&m_critSect);
    };


    //  Properties
    //  Methods

    DWORD Count(void)
    {
        CCritSect csLock(&m_critSect);
        return m_Mac;
    };

    void
    Clear(void)
    {
        CCritSect csLock(&m_critSect);
        if (NULL != m_phList)
        {
            for (DWORD index = 0; index < m_Mac; index += 1)
                if (NULL != m_phList[index].phObject)
                    delete m_phList[index].phObject;
            delete[] m_phList;
            m_phList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    CHandle *
    Close(
        IN HANDLE_TYPE hItem);

    HANDLE_TYPE
    Add(
        IN CHandle *phItem);

    CHandle * const
    GetQuietly(
        IN HANDLE_TYPE hItem);

    CHandle * const
    Get(
        IN HANDLE_TYPE hItem);

    HANDLE_TYPE
    IndexHandle(
        DWORD nItem);

    BOOL
    InitFailed(void)
    { return m_fInitFailed; }


    //  Operators

    CHandle * const
    operator[](HANDLE_TYPE hItem)
    { return Get(hItem); };

    void MarkContentAsBad(BOOL fCancel)
    {
        CCritSect csLock(&m_critSect);
        if (NULL != m_phList)
        {
            for (DWORD index = 0; index < m_Mac; index += 1)
            {
                if (NULL != m_phList[index].phObject)
                    m_phList[index].phObject->MarkAsBad(fCancel);
            }
        }
    }

    CHandle *
    GetFirst()
    {
        DWORD index = 0;

        while (index < m_Mac)
        {
            if (NULL != m_phList[index].phObject)
                return (m_phList[index].phObject);

            index++;
        }

        return NULL;
    }

    CHandle * 
    GetNext(
        IN CHandle * phObject)
    {
        DWORD index = 0;

        while (index < m_Mac)
        {
            if (phObject == m_phList[index].phObject)
                break;

            index++;
        }

        if (index < m_Mac)
        {
            index++;

            while (index < m_Mac)
            {
                if (NULL != m_phList[index].phObject)
                    return (m_phList[index].phObject);
    
                index++;
            }  
        }

        return NULL;
    }

protected:

    struct HandlePtr
    {
        CHandle *phObject;
        DWORD dwCount;
    };

    //  Properties


    DWORD
        m_dwId;          // Id number of handle list.
    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    HandlePtr *
        m_phList;       // The elements.
    CRITICAL_SECTION
        m_critSect;     // Handle list access control.
    BOOL
        m_fInitFailed;  // InitCritSec failed in constructor

    //  Methods

    HandlePtr *
    GetHandlePtr(
        IN HANDLE_TYPE hItem)
    const;
};


/*++

Close:

    This routine closes an item in the handle array.

Arguments:

    hItem - Supplies the handle to the object to be closed.

Throws:

    ERROR_INVALID_HANDLE - The supplied handle value is invalid.


Return Value:

    The referenced object.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle *
CHandleList::Close(
    IN HANDLE_TYPE hItem)
{
    CHandle *phItem;
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        throw (DWORD)ERROR_INVALID_HANDLE;

    phItem = pHandlePtr->phObject;
    if (NULL == phItem)
        throw (DWORD)ERROR_INVALID_HANDLE;
    pHandlePtr->phObject = NULL;
    pHandlePtr->dwCount += 1;
    return phItem;
}


/*++

Add:

    This method adds an item to the Handle list.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The resultant handle of the Add operation.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

inline HANDLE_TYPE
CHandleList::Add(
    IN CHandle *phItem)
{
    DWORD index;
    HandlePtr * pHndl = NULL;


    //
    // Look for a vacant handle slot.  We look through m_Max instead of m_Mac,
    // so that if all the official ones are used, we fall into unused territory.
    //

    CCritSect csLock(&m_critSect);
    for (index = 0; index < m_Max; index += 1)
    {
        pHndl = &m_phList[index];
        if (NULL == pHndl->phObject)
            break;
        pHndl = NULL;
    }


    //
    // Make sure the array was big enough.
    //

    if (NULL == pHndl)
    {
        DWORD newSize = (0 == m_Max ? 4 : m_Max * 2);
        if ((HANDLE_INDEX_MASK >> HANDLE_INDEX_OFFSET) < newSize)
            throw (DWORD)ERROR_OUTOFMEMORY;
        pHndl = new HandlePtr[newSize];
        if (NULL == pHndl)
            throw (DWORD)ERROR_OUTOFMEMORY;
        if (NULL != m_phList)
        {
            CopyMemory(pHndl, m_phList, sizeof(HandlePtr) * m_Mac);
            delete[] m_phList;
        }
        ZeroMemory(&pHndl[m_Mac], sizeof(HandlePtr) * (newSize - m_Mac));
        m_phList = pHndl;
        m_Max = (DWORD)newSize;
        index = m_Mac++;
        pHndl = &m_phList[index];
    }
    else
    {
        if (m_Mac <= index)
            m_Mac = index + 1;
    }


    //
    // Cross index the list element and the object.
    //

    ASSERT(NULL == pHndl->phObject);
    pHndl->phObject = phItem;
    if (0 == pHndl->dwCount)
        pHndl->dwCount = 1;
    phItem->m_dwCount = (DWORD)(pHndl->dwCount
                                & (HANDLE_COUNT_MASK >> HANDLE_COUNT_OFFSET));
    phItem->m_dwIndex = index;
    return (HANDLE_TYPE)(
                  ((((HANDLE_TYPE)m_dwId)          << HANDLE_ID_OFFSET)   & HANDLE_ID_MASK)
                | ((((HANDLE_TYPE)pHndl->dwCount) << HANDLE_COUNT_OFFSET) & HANDLE_COUNT_MASK)
                | ((((HANDLE_TYPE)index)          << HANDLE_INDEX_OFFSET) & HANDLE_INDEX_MASK));
}


/*++

GetQuietly:

    This method returns the element at the given handle.  If the handle is
    invalid, it returns NULL.  It does not expand the array.

Arguments:

    hItem - Supplies the index into the list.

Return Value:

    The value stored at that handle in the list, or NULL if the handle is
    invalid.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle * const
CHandleList::GetQuietly(
    HANDLE_TYPE hItem)
{
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        return NULL;
    return pHandlePtr->phObject;
}


/*++

Get:

    This method returns the element at the given handle.  If the handle is
    invalid, it throws an error.  It does not expand the array.

Arguments:

    hItem - Supplies the index into the list.

Return Value:

    The value stored at that handle in the list.

Throws:

    ERROR_INVALID_HANDLE - Invalid handle value.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle * const
CHandleList::Get(
    HANDLE_TYPE hItem)
{
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        throw (DWORD)ERROR_INVALID_HANDLE;
    return pHandlePtr->phObject;
}


/*++

GetHandlePtr:

    This routine finds the HandlePtr structure corresponding to a given handle.

Arguments:

    hItem supplies the handle to look up.

Return Value:

    The address of the HandlePtr structure corresponding to the handle, or NULL
    if none exists.

Author:

    Doug Barlow (dbarlow) 5/9/1996

--*/

inline CHandleList::HandlePtr *
CHandleList::GetHandlePtr(
    HANDLE_TYPE hItem)
    const
{
    try
    {
        HandlePtr *pHandlePtr;
        DWORD_PTR dwItem  = (DWORD_PTR)hItem;
        DWORD dwId    = (DWORD)((dwItem & HANDLE_ID_MASK)    >> HANDLE_ID_OFFSET);
        DWORD dwCount = (DWORD)((dwItem & HANDLE_COUNT_MASK) >> HANDLE_COUNT_OFFSET);
        DWORD dwIndex = (DWORD)((dwItem & HANDLE_INDEX_MASK) >> HANDLE_INDEX_OFFSET);

        if (dwId != (m_dwId & (HANDLE_ID_MASK >> HANDLE_ID_OFFSET))
                || (m_Mac <= dwIndex))
            return NULL;

        pHandlePtr = &m_phList[dwIndex];
        if (dwCount
                != (pHandlePtr->dwCount
                    & (HANDLE_COUNT_MASK >> HANDLE_COUNT_OFFSET)))
            return NULL;

        return pHandlePtr;
    }
    catch (...)
    {
        // Swallow the error.
    }
    return NULL;
}


/*++

IndexHandle:

    This method converts an index into a handle.  The handle is NULL if there is
    no element stored at that index.

Arguments:

    nItem supplies the index of the object to reference.

Return Value:

    The handle of the object, or NULL if there is no object at that index.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/3/1997

--*/

inline HANDLE_TYPE
CHandleList::IndexHandle(
    DWORD nItem)
{
    HANDLE_TYPE hItem = NULL;
    HandlePtr * pHndl;

    CCritSect csLock(&m_critSect);
    if (m_Mac > nItem)
    {
        pHndl = &m_phList[nItem];
        if (NULL != pHndl->phObject)
        {
            hItem =
                  ((((HANDLE_TYPE)m_dwId)         << HANDLE_ID_OFFSET) & HANDLE_ID_MASK)
                | ((((HANDLE_TYPE)pHndl->dwCount) << HANDLE_COUNT_OFFSET) & HANDLE_COUNT_MASK)
                | ((((HANDLE_TYPE)nItem)          << HANDLE_INDEX_OFFSET) & HANDLE_INDEX_MASK);
        }
    }
    return hItem;
}

#endif // _HANDLES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\clbmisc.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ClbMisc

Abstract:

    This header file describes the miscellaneous services of the Calais Library.

Author:

    Doug Barlow (dbarlow) 7/16/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _CLBMISC_H_
#define _CLBMISC_H_

#include <stdio.h>
#include <tchar.h>

//
// Miscellaneous definitions.
//

extern int
MemCompare(             // Non CRTL memory compare routine.
    IN LPCBYTE pbOne,
    IN LPCBYTE pbTwo,
    IN DWORD cbLength);

extern DWORD
MStrAdd(                // Add an ANSI string to a multistring.
    IN OUT CBuffer &bfMsz,
    IN LPCSTR szAdd);
extern DWORD
MStrAdd(                // Add a wide string to a multistring.
    IN OUT CBuffer &bfMsz,
    IN LPCWSTR szAdd);

extern DWORD
MStrLen(               // Return the length of an ANSI Multistring, in chars.
    LPCSTR mszString);
extern DWORD
MStrLen(               // Return the length of a wide Multistring, in chars.
    LPCWSTR mszString);

extern LPCTSTR
FirstString(            // Return first string segment in a multistring.
    IN LPCTSTR szMultiString);

extern LPCTSTR
NextString(             // Return next string segment in a multistring.
    IN LPCTSTR szMultiString);

extern LPCTSTR
StringIndex(            // Return n'th string segment in a multistring.
    IN LPCTSTR szMultiString,
    IN DWORD dwIndex);

extern DWORD
MStringCount(
        LPCTSTR mszInString);   // count strings in multistring

extern DWORD
MStringSort(            // Sort multistring, removing duplicates.
    LPCTSTR mszInString,
    CBuffer &bfOutString);

extern DWORD
MStringMerge(           // Merge two multistrings, eliminating duplicates.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern DWORD
MStringCommon(          // Get the intersection of two multistrings.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern DWORD
MStringRemove(          // Remove 2nd string entries from 1st string.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern BOOL
ParseAtr(               // Parse a smartcard ATR string.
    LPCBYTE pbAtr,
    LPDWORD pdwAtrLen = NULL,
    LPDWORD pdwHistOffset = NULL,
    LPDWORD pcbHistory = NULL,
    DWORD cbMaxLen = 33);

extern BOOL
AtrCompare(             // Compare an ATR to an ATR/Mask pair.
    LPCBYTE pbAtr1,
    LPCBYTE pbAtr2,
    LPCBYTE pbMask,  // = NULL
    DWORD cbAtr2);  // = 0

extern DWORD
MoveString(             // Move an ANSI string into a buffer, converting to
    CBuffer &bfDst,     // TCHARs.
    LPCSTR szSrc,
    DWORD dwLength = (DWORD)(-1));

extern DWORD
MoveString(             // Move a UNICODE string into a buffer, converting to
    CBuffer &bfDst,     // TCHARs.
    LPCWSTR szSrc,
    DWORD dwLength = (DWORD)(-1));

extern DWORD
MoveToAnsiString(       // Move a string into a UNICODE buffer, converting from
    LPSTR szDst,        // TCHARs.
    LPCTSTR szSrc,
    DWORD cchLength);

extern DWORD
MoveToUnicodeString(    // Move a string into an ANSI buffer, converting from
    LPWSTR szDst,       // TCHARs.
    LPCTSTR szSrc,
    DWORD cchLength);

extern DWORD
MoveToAnsiMultiString(  // Move a multistring into an ANSI buffer, converting
    LPSTR mszDst,       // from TCHARs.
    LPCTSTR mszSrc,
    DWORD cchLength);

extern DWORD
MoveToUnicodeMultiString(   // Move a multistring into a UNICODE buffer,
    LPWSTR mszDst,          // converting from TCHARs.
    LPCTSTR mszSrc,
    DWORD cchLength);

extern LPCTSTR
ErrorString(                // Convert an error code into a string.
    DWORD dwErrorCode);

extern void
FreeErrorString(            // Free the string returned from ErrorString.
    LPCTSTR szErrorString);

extern DWORD
SelectString(               // Index a given string against a list of possible
    LPCTSTR szSource,       // strings.  Last parameter is NULL.
    ...);

extern void
StringFromGuid(
    IN LPCGUID pguidResult, // GUID to convert to text
    OUT LPTSTR szGuid);     // 39+ character buffer to receive GUID as text.


//
//==============================================================================
//
//  CErrorString
//
//  A trivial class to simplify the use of the ErrorString service.
//

class CErrorString
{
public:

    //  Constructors & Destructor
    CErrorString(DWORD dwError = 0)
    {
        m_szErrorString = NULL;
        SetError(dwError);
    };

    ~CErrorString()
    {
		if (m_szErrorString != m_szHexError)
			FreeErrorString(m_szErrorString);
    };

    //  Properties
    //  Methods
    void SetError(DWORD dwError)
    {
        m_dwError = dwError;
    };

    LPCTSTR Value(void)
    {
		LPCTSTR szErr = NULL;
		if (m_szErrorString != m_szHexError)
	        FreeErrorString(m_szErrorString);
		try {
			szErr = ErrorString(m_dwError);
		} catch (...) {}
		if (NULL == szErr)
		{
			_stprintf(m_szHexError, _T("0x%08x"), m_dwError);
			m_szErrorString = m_szHexError;
		}
		else
			m_szErrorString = szErr;
        return m_szErrorString;
    };

    //  Operators
    operator LPCTSTR(void)
    {
        return Value();
    };

protected:
    //  Properties
    DWORD m_dwError;
    LPCTSTR m_szErrorString;
	TCHAR m_szHexError[11];		// Big enough to hold 0x%08x\0

    //  Methods
};

#endif // _CLBMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\querydb.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    QueryDB

Abstract:

    This header file provides the definitions of the Calais Query Database
    utility routines.

Author:

    Doug Barlow (dbarlow) 11/25/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _QUERYDB_H_
#define _QUERYDB_H_

extern void
ListReaderGroups(
    IN DWORD dwScope,
    OUT CBuffer &bfGroups);

extern void
ListReaders(
    IN DWORD dwScope,
    IN LPCTSTR mszGroups,
    OUT CBuffer &bfReaders);

extern void
ListReaderNames(
    IN DWORD dwScope,
    IN LPCTSTR szDevice,
    OUT CBuffer &bfNames);

extern void
ListCards(
    DWORD dwScope,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT CBuffer &bfCards);

extern BOOL
GetReaderInfo(
    IN DWORD dwScope,
    IN LPCTSTR szReader,
    OUT CBuffer *pbfGroups = NULL,
    OUT CBuffer *pbfDevice = NULL);

extern BOOL
GetCardInfo(
    IN DWORD dwScope,
    IN LPCTSTR szCard,
    OUT CBuffer *pbfAtr,
    OUT CBuffer *pbfAtrMask,
    OUT CBuffer *pbfInterfaces,
    OUT CBuffer *pbfProvider);

extern void
GetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    OUT CBuffer &bfProvider);

#ifdef ENABLE_SCARD_TEMPLATES
extern BOOL
ListCardTypeTemplates(
    IN  DWORD dwScope,
    IN  LPCBYTE pbAtr,
    OUT CBuffer &bfTemplates);
#endif // ENABLE_SCARD_TEMPLATES

#endif // _QUERYDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\dynarray.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    dynarray

Abstract:

    This header file implements a Dynamic Array.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32, C++ /w Exception Handling

Notes:



--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_


//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicArray
{
public:

    //  Constructors & Destructor

    CDynamicArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicArray()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T *
    Set(
        IN int nItem,
        IN T *pvItem);

    T *
    Insert(
        IN int nItem,
        IN T *pvItem);

    T *
    Add(
        IN T *pvItem);

    T * const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };

    T ** const
    Array(void) const
    { return m_pvList; };

    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T **newList = new T*[newSize];
        if (NULL == newList)
            throw (DWORD)ERROR_OUTOFMEMORY;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Insert(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;
    for (index = nItem; index < m_Mac; index += 1)
        if (NULL == Set(index + 1, Get(index)))
            return NULL;    // Only the first one can fail, so no change
                            // happens on errors.
    return Set(nItem, pvItem);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The value of the added value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Add(
    IN T *pvItem)
{
    return Set(Count(), pvItem);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CDynamicArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}

#endif // _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\scevents.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scEvents

Abstract:

    This header file describes the services to access the Calais Resource
    Manager special events.

Author:

    Doug Barlow (dbarlow) 7/1/1998

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _SCEVENTS_H_
#define _SCEVENTS_H_
#ifdef __cplusplus
extern "C" {
#endif

typedef HANDLE (*LPCALAISACCESSEVENT)(void);
typedef void (*LPCALAISRELEASEEVENT)(void);

#ifdef __cplusplus
}
#endif

//
// Special SCardGetStatusChange Reader Name definitions.
//

#define SCPNP_NOTIFICATION TEXT("\\\\?PnP?\\Notification")


//
//  NOTE -- The following definitions intentionally use the ANSI versions
//          of the corresponding strings.
//

inline HANDLE
CalaisAccessStartedEvent(
    void)
{
    HANDLE hReturn = NULL;

    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISACCESSEVENT pfCalais =
				(LPCALAISACCESSEVENT)GetProcAddress(hWinScard,
													"SCardAccessStartedEvent");
			if (NULL != pfCalais)
			{
				hReturn = (*pfCalais)();
			}
		}
    }
    catch (...)
    {
        hReturn = NULL;
    }

    return hReturn;
}

inline HANDLE
CalaisAccessNewReaderEvent(
    void)
{
    HANDLE hReturn = NULL;

    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISACCESSEVENT pfCalais =
				(LPCALAISACCESSEVENT)GetProcAddress(hWinScard,
													"SCardAccessNewReaderEvent");
			if (NULL != pfCalais)
			{
				hReturn = (*pfCalais)();
			}
		}
    }
    catch (...)
    {
        hReturn = NULL;
    }

    return hReturn;
}

inline void
CalaisReleaseStartedEvent(
    void)
{
    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISRELEASEEVENT pfCalais =
				(LPCALAISRELEASEEVENT)GetProcAddress(hWinScard,
													 "SCardReleaseStartedEvent");
			if (NULL != pfCalais)
			{
				(*pfCalais)();
			}
		}
    }
    catch (...) {}
}

inline void
CalaisReleaseNewReaderEvent(
    void)
{
    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISRELEASEEVENT pfCalais =
				(LPCALAISRELEASEEVENT)GetProcAddress(hWinScard,
													 "SCardReleaseNewReaderEvent");
			if (NULL != pfCalais)
			{
				(*pfCalais)();
			}
		}
    }
    catch (...) {}
}

inline void
CalaisReleaseAllEvents(
    void)
{
    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISRELEASEEVENT pfCalais =
				(LPCALAISRELEASEEVENT)GetProcAddress(hWinScard,
													 "SCardReleaseAllEvents");
			if (NULL != pfCalais)
			{
		        (*pfCalais)();
			}
		}
    }
    catch (...) {}
}

#endif // _SCEVENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\registry.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This header file defines a class to provide simple interaction to values in
    the Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include <winreg.h>

#define REG_OPTION_EXISTS (~REG_LEGAL_OPTION)


//
//==============================================================================
//
//  CRegistry
//

class CRegistry
{
public:

    //  Constructors & Destructor
    CRegistry(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
		LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);
    CRegistry(void);
    ~CRegistry();

    //  Properties
    //  Methods
    void 
    Open(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
		LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);

    void Close(void);
    LONG Status(BOOL fQuiet = FALSE) const;
    void Empty(void);
    void Copy(CRegistry &regSrc);
    void DeleteKey(LPCTSTR szKey, BOOL fQuiet = FALSE) const;
    void DeleteValue(LPCTSTR szValue, BOOL fQuiet = FALSE) const;
    LPCTSTR Subkey(DWORD dwIndex);
    LPCTSTR Value(DWORD dwIndex, LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPTSTR *pszValue,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwValue,
        LPDWORD pdwType = NULL)
    const;
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPBYTE *ppbValue,
        LPDWORD pcbLength,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        CBuffer &bfValue,
        LPDWORD pdwType = NULL);
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCTSTR szValue,
        DWORD dwType = REG_SZ)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        DWORD dwValue,
        DWORD dwType = REG_DWORD)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCBYTE pbValue,
        DWORD cbLength,
        DWORD dwType = REG_BINARY)
    const;
    void
    SetAcls(
        IN SECURITY_INFORMATION SecurityInformation,
        IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
        IN BOOL fRecurse = TRUE);
    void
    SetMultiStringValue(
        LPCTSTR szKeyValue,
        LPCTSTR mszValue,
        DWORD dwType = REG_MULTI_SZ)
    const;
    LPCTSTR
    GetStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetNumericValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL)
    const;
    LPCBYTE
    GetBinaryValue(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL);
    LPCTSTR
    GetMultiStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetValueLength(
        void)
    const;
    BOOL
    ValueExists(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL)
    const;
    DWORD
    GetDisposition(
        void)
    const;

    //  Operators
    operator HKEY(
        void)
    const
    { Status();
      return m_hKey; };

protected:
    //  Properties

    HKEY m_hKey;
    DWORD m_dwDisposition;
    CBuffer m_bfResult;
    LONG m_lSts;


    //  Methods

};


#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\inc\scarddat.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scarddat

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scarddat.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\inc\scardmgr.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scardmgr

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scardmgr.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\text.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This header file provides a text handling class.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _TEXT_H_
#define _TEXT_H_

//#include <string.h>
//#include <mbstring.h>
#include "buffers.h"


//
//==============================================================================
//
//  CTextString
//

class CTextString
{
public:

    //  Constructors & Destructor
    CTextString()
    :   m_bfUnicode(),
        m_bfAnsi()
    { m_fFlags = fBothGood; };
    virtual ~CTextString() {};

    //  Properties
    //  Methods
    void Clear(void)
    {
        m_bfUnicode.Clear();
        m_bfAnsi.Clear();
        m_fFlags = fBothGood;
    };
    void Reset(void)
    {
        m_bfUnicode.Reset();
        m_bfAnsi.Reset();
        m_fFlags = fBothGood;
    };
    virtual DWORD Length(void);

    //  Operators
    CTextString &operator=(const CTextString &tz);
    LPCSTR operator=(LPCSTR sz);
    LPCWSTR operator=(LPCWSTR wsz);
    CTextString &operator+=(const CTextString &tz);
    LPCSTR operator+=(LPCSTR sz);
    LPCWSTR operator+=( LPCWSTR wsz);
    BOOL operator==(const CTextString &tz)
    { return (0 == Compare(tz)); };
    BOOL operator==(LPCSTR sz)
    { return (0 == Compare(sz)); };
    BOOL operator==(LPCWSTR wsz)
    { return (0 == Compare(wsz)); };
    BOOL operator!=(const CTextString &tz)
    { return (0 != Compare(tz)); };
    BOOL operator!=(LPCSTR sz)
    { return (0 != Compare(sz)); };
    BOOL operator!=(LPCWSTR wsz)
    { return (0 != Compare(wsz)); };
    BOOL operator<=(const CTextString &tz)
    { return (0 <= Compare(tz)); };
    BOOL operator<=(LPCSTR sz)
    { return (0 <= Compare(sz)); };
    BOOL operator<=(LPCWSTR wsz)
    { return (0 <= Compare(wsz)); };
    BOOL operator>=(const CTextString &tz)
    { return (0 >= Compare(tz)); };
    BOOL operator>=(LPCSTR sz)
    { return (0 >= Compare(sz)); };
    BOOL operator>=(LPCWSTR wsz)
    { return (0 >= Compare(wsz)); };
    BOOL operator<(const CTextString &tz)
    { return (0 < Compare(tz)); };
    BOOL operator<(LPCSTR sz)
    { return (0 < Compare(sz)); };
    BOOL operator<(LPCWSTR wsz)
    { return (0 < Compare(wsz)); };
    BOOL operator>(const CTextString &tz)
    { return (0 > Compare(tz)); };
    BOOL operator>(LPCSTR sz)
    { return (0 > Compare(sz)); };
    BOOL operator>(LPCWSTR wsz)
    { return (0 > Compare(wsz)); };
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };

protected:
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Properties
    CBuffer
        m_bfUnicode,
        m_bfAnsi;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
    int Compare(const CTextString &tz);
    int Compare(LPCSTR sz);
    int Compare(LPCWSTR wsz);
    virtual DWORD Length(LPCSTR szString);
    virtual DWORD Length(LPCWSTR szString);
};


//
//==============================================================================
//
//  CTextMultistring
//

class CTextMultistring
:   public CTextString
{
public:

    //  Constructors & Destructor

    CTextMultistring()
    :   CTextString()
    {};

    //  Properties
    //  Methods
    virtual DWORD Length(void);

    //  Operators
    CTextMultistring &operator=(const CTextMultistring &tz);
    CTextMultistring &operator+=(const CTextMultistring &tz);
    LPCSTR operator=(LPCSTR sz);
    LPCWSTR operator=(LPCWSTR wsz);
    LPCSTR operator+=(LPCSTR sz);
    LPCWSTR operator+=( LPCWSTR wsz);

protected:
    //  Properties
    //  Methods
    virtual DWORD Length(LPCSTR szString);
    virtual DWORD Length(LPCWSTR szString);
};

#endif // _TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\inc\sspguid.h ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    sspguid

Abstract:

    CLSID definitions from the scardssp project.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _SSPGUID_H_
#define _SSPGUID_H_

#define IID_DEFINED

#include "scardssp_i.c"

#ifndef CLSCTX_LOCAL
#define CLSCTX_LOCAL            (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)
#endif

#endif // _SSPGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\inc\scardlib.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardLib

Abstract:

    This header file incorporates the various other header files and provides
    common definitions that we are willing to share with the public.

Author:

    Doug Barlow (dbarlow) 1/15/1998

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _SCARDLIB_H_
#define _SCARDLIB_H_
#include <crtdbg.h>

#ifndef ASSERT
#if defined(_DEBUG)
#define ASSERT(x) _ASSERTE(x)
#if !defined(DBG)
#define DBG
#endif
#elif defined(DBG)
#define ASSERT(x)
#else
#define ASSERT(x)
#endif
#endif

#ifndef breakpoint
#if defined(_DEBUG)
#define breakpoint _CrtDbgBreak();
#elif defined(DBG)
#define breakpoint DebugBreak();
#else
#define breakpoint
#endif
#endif

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif
#ifndef _LPCGUID_DEFINED
#define _LPCGUID_DEFINED
typedef const GUID *LPCGUID;
#endif
#ifndef _LPGUID_DEFINED
#define _LPGUID_DEFINED
typedef GUID *LPGUID;
#endif

#include "buffers.h"
#include "dynarray.h"
#include "Registry.h"
#include "Text.h"
#include "Handles.h"
#include "clbmisc.h"

#endif // _SCARDLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\inc\scardsrv.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scardsrv

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scardsrv.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\inc\sspserr.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SspsErr

Abstract:

    This header file describes the error codes that are generated by
    the Microsoft Smartcard Service Provider (SSP).

Author:

    Michael Gallagher (a-mgalla) 10/21/1996

Environment:

    Win32

Revision History:

    Mike Gallagher (a-mgalla) 12/19/1996

Notes:

--*/


#ifndef __SSPSERR_H__
#define __SSPSERR_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#ifndef SCARD_S_SUCCESS
#include "scarderr.h"
#endif
#ifdef _DEBUG
#pragma message("sspserr.h is obsolete.")
#endif


/////////////////////////////////////////////////////////////////////////////

#endif  // __SSPSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\inc\sspsidl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       sspsidl.h
//
//--------------------------------------------------------------------------

#include "scardssp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\conversion.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Conversion

Abstract:

    This header file describes the format conversion services.

Author:

    Doug Barlow (dbarlow) 6/21/1999

Remarks:


Notes:


--*/

#ifndef _CONVERSION_H_
#define _CONVERSION_H_

#include <winscard.h>
#include <scardlib.h>

#define APDU_EXTENDED_LENGTH    0x01    // Force an extended value for Lc and/or Le
#define APDU_MAXIMUM_LE         0x02    // Request the maximum Le value
#define APDU_REQNAD_VALID       0x04    // The Request NaD is valid.
#define APDU_RSPNAD_VALID       0x08    // The Response NaD is valid.
#define APDU_NO_GET_RESPONSE    0x10    // Don't do automatic Get Responses
#define APDU_ALTCLA_VALID       0x20    // The Alternate CLA is valid.

extern void
ConstructRequest(
    IN  BYTE bCla,
    IN  BYTE bIns,
    IN  BYTE bP1,
    IN  BYTE bP2,
    IN  CBuffer &bfData,
    IN  WORD wLe,
    IN  DWORD dwFlags,
    OUT CBuffer &bfApdu);

extern void
ParseRequest(
    IN  LPCBYTE pbApdu,
    IN  DWORD cbApdu,
    OUT LPBYTE pbCla,
    OUT LPBYTE pbIns,
    OUT LPBYTE pbP1,
    OUT LPBYTE pbP2,
    OUT LPCBYTE *pbfData,
    OUT LPWORD pwLc,
    OUT LPWORD pwLe,
    OUT LPDWORD pdwFlags);

extern void
ParseReply(
    IN  CBuffer &bfApdu,
    OUT LPBYTE pbSW1,
    OUT LPBYTE pbSW2);

extern void
MultiStringToSafeArray(
    IN LPCTSTR msz,
    IN OUT SAFEARRAY **pprgsz);

extern void
GuidArrayToSafeArray(
    IN LPCGUID pGuids,
    IN DWORD cguids,
    IN OUT SAFEARRAY **pprgguids);

extern void
SafeArrayToGuidArray(
    IN LPSAFEARRAY prgGuids,
    OUT CBuffer &bfGuids,
    OUT LPDWORD pcGuids);

extern void
SafeArrayToGuidArray(
    IN LPSAFEARRAY prgGuids,
    OUT CBuffer &bfGuids,
    OUT LPDWORD pcGuids);

extern void
SafeArrayToMultiString(
    IN LPSAFEARRAY prgsz,
    IN OUT CTextMultistring &msz);

extern void
ApduToTpdu_T0(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply,
    IN LPCBYTE pbAltCla);

extern void
ApduToTpdu_T1(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply);

extern LONG
ByteBufferToBuffer(
    IN LPBYTEBUFFER pby,
    OUT CBuffer &bf);

extern LONG
BufferToByteBuffer(
    IN  CBuffer &bf,
    OUT LPBYTEBUFFER *ppby);


//
//  NOTE
//  
//      The following inline routines assume a little endian architecture,
//      and must be changed for other platforms.
//

inline WORD
NetToLocal(
    IN LPCBYTE pb)
{
    return (pb[0] << 8) + pb[1];
}

inline void
LocalToNet(
    OUT LPBYTE pb,
    IN  WORD w)
{
    pb[0] = (BYTE)((w >> 8) & 0xff);
    pb[1] = (BYTE)(w & 0xff);
}

inline BYTE
LeastSignificantByte(
    IN WORD w)
{
    return (BYTE)(w & 0xff);
}

#endif // _CONVERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\bytebuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ByteBuffer.h
//
//--------------------------------------------------------------------------


// ByteBuffer.h : Declaration of the CByteBuffer

#ifndef __BYTEBUFFER_H_
#define __BYTEBUFFER_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CByteBuffer
class ATL_NO_VTABLE CByteBuffer :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CByteBuffer, &CLSID_CByteBuffer>,
    public IDispatchImpl<IByteBuffer, &IID_IByteBuffer, &LIBID_SCARDSSPLib>
{
public:
    CByteBuffer()
    {
        m_pUnkMarshaler = NULL;
        m_pStreamBuf = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_BYTEBUFFER)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CByteBuffer)
    COM_INTERFACE_ENTRY(IByteBuffer)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
        if (NULL != m_pStreamBuf)
            m_pStreamBuf->Release();
    }

    LPSTREAM Stream(void)
    {
        if (NULL == m_pStreamBuf)
        {
            HRESULT hr;

            hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pStreamBuf);
            if (FAILED(hr))
                throw hr;
        }
        return m_pStreamBuf;
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// IByteBuffer
public:
    STDMETHOD(get_Stream)(
        /* [retval][out] */ LPSTREAM __RPC_FAR *ppStream);

    STDMETHOD(put_Stream)(
        /* [in] */ LPSTREAM pStream);

    STDMETHOD(Clone)(
        /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer);

    STDMETHOD(Commit)(
        /* [in] */ LONG grfCommitFlags);

    STDMETHOD(CopyTo)(
        /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer,
        /* [in] */ LONG cb,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead = 0,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbWritten = 0);

    STDMETHOD(Initialize)(
        /* [defaultvalue][in] */ LONG lSize = 1,
        /* [defaultvalue][in] */ BYTE __RPC_FAR *pData = 0);

    STDMETHOD(LockRegion)(
        /* [in] */ LONG libOffset,
        /* [in] */ LONG cb,
        /* [in] */ LONG dwLockType);

    STDMETHOD(Read)(
        /* [out][in] */ BYTE __RPC_FAR *pByte,
        /* [in] */ LONG cb,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead = 0);

    STDMETHOD(Revert)(void);

    STDMETHOD(Seek)(
        /* [in] */ LONG dLibMove,
        /* [in] */ LONG dwOrigin,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pLibnewPosition = 0);

    STDMETHOD(SetSize)(
        /* [in] */ LONG libNewSize);

    STDMETHOD(Stat)(
        /* [out][in] */ LPSTATSTRUCT pstatstg,
        /* [in] */ LONG grfStatFlag);

    STDMETHOD(UnlockRegion)(
        /* [in] */ LONG libOffset,
        /* [in] */ LONG cb,
        /* [in] */ LONG dwLockType);

    STDMETHOD(Write)(
        /* [out][in] */ BYTE __RPC_FAR *pByte,
        /* [in] */ LONG cb,
        /* [out][in] */ LONG __RPC_FAR *pcbWritten);

protected:
    LPSTREAM m_pStreamBuf;
};

inline CByteBuffer *
NewByteBuffer(
    void)
{
    return (CByteBuffer *)NewObject(CLSID_CByteBuffer, IID_IByteBuffer);
}

#endif //__BYTEBUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\bytebuffer.cpp ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    ByteBuffer

Abstract:

    The IByteBuffer interface is provided to read, write and manage stream
    objects. This object essentially is a wrapper for the IStream object.

Author:

    Doug Barlow (dbarlow) 6/16/1999

Notes:

    This is a rewrite of the original code by Mike Gallagher and Chris Dudley.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include "stdafx.h"
#include "ByteBuffer.h"
#include "Conversion.h"
#define SetXL(xl, low, high) do { xl.LowPart = low; xl.HighPart = high; } while (0)


/////////////////////////////////////////////////////////////////////////////
// CByteBuffer

STDMETHODIMP
CByteBuffer::get_Stream(
    /* [retval][out] */ LPSTREAM __RPC_FAR *ppStream)
{
    HRESULT hReturn = S_OK;

    try
    {
        *ppStream = Stream();
        (*ppStream)->AddRef();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP CByteBuffer::put_Stream(
    /* [in] */ LPSTREAM pStream)
{
    HRESULT hReturn = S_OK;
    LPSTREAM pOldStream = m_pStreamBuf;

    try
    {
        pStream->AddRef();
        m_pStreamBuf = pStream;
        if (NULL != pOldStream)
            pOldStream->Release();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Clone:

    The Clone method creates a new object with its own seek pointer that
    references the same bytes as the original IByteBuffer object.

Arguments:

    ppByteBuffer [out] When successful, points to the location of an
        IByteBuffer pointer to the new stream object. If an error occurs, this
        parameter is NULL.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method creates a new stream object for accessing the same bytes but
    using a separate seek pointer.  The new stream object sees the same data as
    the source stream object.  Changes written to one object are immediately
    visible in the other. Range locking is shared between the stream objects.

    The initial setting of the seek pointer in the cloned stream instance is
    the same as the current setting of the seek pointer in the original stream
    at the time of the clone operation.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Clone")

STDMETHODIMP
CByteBuffer::Clone(
    /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pNewBuf = NULL;
    LPSTREAM pNewStream = NULL;

    try
    {
        HRESULT hr;

        *ppByteBuffer = NULL;
        pNewBuf = NewByteBuffer();
        if (NULL == pNewBuf)
            throw (HRESULT)E_OUTOFMEMORY;
        hr = Stream()->Clone(&pNewStream);
        if (FAILED(hr))
            throw hr;
        hr = pNewBuf->put_Stream(pNewStream);
        if (FAILED(hr))
            throw hr;
        pNewStream->Release();
        pNewStream = NULL;
        *ppByteBuffer = pNewBuf;
        pNewBuf = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pNewBuf)
        pNewBuf->Release();
    if (NULL != pNewStream)
        pNewStream->Release();
    return hReturn;
}


/*++

Commit:

    The Commit method ensures that any changes made to an object open in
    transacted mode are reflected in the parent storage.

Arguments:

    grfCommitFlags [in] Controls how the changes for the stream object are
        committed.  See the STGC enumeration for a definition of these values.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method ensures that changes to a stream object opened in transacted
    mode are reflected in the parent storage.  Changes that have been made to
    the stream since it was opened or last committed are reflected to the
    parent storage object.  If the parent is opened in transacted mode, the
    parent may still revert at a later time rolling back the changes to this
    stream object.  The compound file implementation does not support opening
    streams in transacted mode, so this method has very little effect other
    than to flush memory buffers.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Commit")

STDMETHODIMP
CByteBuffer::Commit(
    /* [in] */ LONG grfCommitFlags)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Commit(grfCommitFlags);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CopyTo:

    The CopyTo method copies a specified number of bytes from the current seek
    pointer in the object to the current seek pointer in another object.

Arguments:

    pByteBuffer [in] Points to the destination stream. The stream pointed to by
        pByteBuffer can be a new stream or a clone of the source stream.

    cb [in] Specifies the number of bytes to copy from the source stream.

    pcbRead [out] Pointer to the location where this method writes the actual
        number of bytes read from the source.  You can set this pointer to NULL
        to indicate that you are not interested in this value.  In this case,
        this method does not provide the actual number of bytes read.

    pcbWritten [out] Pointer to the location where this method writes the
        actual number of bytes written to the destination.  You can set this
        pointer to NULL to indicate that you are not interested in this value.
        In this case, this method does not provide the actual number of bytes
        written.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method copies the specified bytes from one stream to another.  It can
    also be used to copy a stream to itself.  The seek pointer in each stream
    instance is adjusted for the number of bytes read or written.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::CopyTo")

STDMETHODIMP
CByteBuffer::CopyTo(
    /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer,
    /* [in] */ LONG cb,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbWritten)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;
    LPSTREAM pStream = NULL;

    try
    {
        HRESULT hr;
        ULARGE_INTEGER xulcb, xulRead, xulWritten;

        if (NULL == *ppByteBuffer)
        {
            *ppByteBuffer = pMyBuffer = NewByteBuffer();
            if (NULL == *ppByteBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppByteBuffer)->get_Stream(&pStream);
        if (FAILED(hr))
            throw hr;
        SetXL(xulcb, cb, 0);
        SetXL(xulRead, 0, 0);
        SetXL(xulWritten, 0, 0);
        hr = Stream()->CopyTo(pStream, xulcb, &xulRead, &xulWritten);
        if (FAILED(hr))
            throw hr;
        pStream->Release();
        pStream = NULL;
        if (NULL != pcbRead)
            *pcbRead = xulRead.LowPart;
        if (NULL != pcbWritten)
            *pcbWritten = xulWritten.LowPart;
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppByteBuffer = NULL;
    }
    if (NULL != pStream)
        pStream->Release();
    return hReturn;
}


/*++

Initialize:

    The Initialize method prepares the IByteBuffer object for use.  This method
    must be called prior to calling any other methods in the IByteBuffer
    interface.

Arguments:

    lSize - The initial size in bytes of the data the stream is to contain.

    pData - If not NULL, the initial data to write to the stream.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    When using a new IByteBuffer stream, call this method prior to using any of
    the other IByteBuffer methods.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Initialize")

STDMETHODIMP
CByteBuffer::Initialize(
    /* [defaultvalue][in] */ LONG lSize,
    /* [defaultvalue][in] */ BYTE __RPC_FAR *pData)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;
        ULARGE_INTEGER xul;
        LARGE_INTEGER xl;

        SetXL(xul, 0, 0);
        SetXL(xl, 0, 0);

        hr = Stream()->SetSize(xul);
        if (FAILED(hr))
            throw hr;
        hr = Stream()->Seek(xl, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;
        if ((0 != lSize) && (NULL != pData))
        {
            hr = Stream()->Write(pData, lSize, NULL);
            if (FAILED(hr))
                throw hr;
        }
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

LockRegion:

    The LockRegion method restricts access to a specified range of bytes in the
    buffer object.

Arguments:

    libOffset [in] Integer that specifies the byte offset for the beginning of
        the range.

    cb [in] Integer that specifies the length of the range, in bytes, to be
        restricted.

    dwLockType [in] Specifies the restrictions being requested on accessing the
        range.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The byte range can extend past the current end of the stream.  Locking
    beyond the end of a stream is useful as a method of communication between
    different instances of the stream without changing data that is actually
    part of the stream.

    Three types of locking can be supported: locking to exclude other writers,
    locking to exclude other readers or writers, and locking that allows only
    one requestor to obtain a lock on the given range, which is usually an
    alias for one of the other two lock types.  A given stream instance might
    support either of the first two types, or both.  The lock type is specified
    by dwLockType, using a value from the LOCKTYPE enumeration.

    Any region locked with IByteBuffer::LockRegion must later be explicitly
    unlocked by calling IByteBuffer::UnlockRegion with exactly the same values
    for the libOffset, cb, and dwLockType parameters.  The region must be
    unlocked before the stream is released.  Two adjacent regions cannot be
    locked separately and then unlocked with a single unlock call.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::LockRegion")

STDMETHODIMP
CByteBuffer::LockRegion(
    /* [in] */ LONG libOffset,
    /* [in] */ LONG cb,
    /* [in] */ LONG dwLockType)
{
    HRESULT hReturn = S_OK;

    try
    {
        ULARGE_INTEGER xulOffset, xulcb;

        SetXL(xulOffset, libOffset, 0);
        SetXL(xulcb, cb, 0);
        hReturn = Stream()->LockRegion(xulOffset, xulcb, dwLockType);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Read:

    The Read method reads a specified number of bytes from the buffer object
    into memory starting at the current seek pointer.

Arguments:

    pByte [out] Points to the buffer into which the stream data is read.  If an
        error occurs, this value is NULL.

    cb [in] Specifies the number of bytes of data to attempt to read from the
        stream object.

    pcbRead [out] Address of a LONG variable that receives the actual number of
        bytes read from the stream object.  You can set this pointer to NULL to
        indicate that you are not interested in this value.  In this case, this
        method does not provide the actual number of bytes read.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method reads bytes from this stream object into memory.  The stream
    object must be opened in STGM_READ mode.  This method adjusts the seek
    pointer by the actual number of bytes read.

    The number of bytes actually read is also returned in the pcbRead
    parameter.

    Notes to Callers

    The actual number of bytes read can be fewer than the number of bytes
    requested if an error occurs or if the end of the stream is reached during
    the read operation.

    Some implementations might return an error if the end of the stream is
    reached during the read.  You must be prepared to deal with the error
    return or S_OK return values on end of stream reads.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Read")

STDMETHODIMP
CByteBuffer::Read(
    /* [out][in] */ BYTE __RPC_FAR *pByte,
    /* [in] */ LONG cb,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Read(pByte, cb, (LPDWORD)pcbRead);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Revert:

    The Revert method discards all changes that have been made to a transacted
    stream since the last IByteBuffer::Commit call.

Arguments:

    None.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful and the stream was reverted to its previous version.

Remarks:

    This method discards changes made to a transacted stream since the last
    commit operation.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Revert")

STDMETHODIMP
CByteBuffer::Revert(
    void)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Revert();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Seek:

    The Seek method changes the seek pointer to a new location relative to the
    beginning of the buffer, to the end of the buffer, or to the current seek
    pointer.

Arguments:

    dLibMove [in] Displacement to be added to the location indicated by
        dwOrigin.  If dwOrigin is STREAM_SEEK_SET, this is interpreted as an
        unsigned value rather than signed.

    dwOrigin [in] Specifies the origin for the displacement specified in
        dlibMove.  The origin can be the beginning of the file, the current
        seek pointer, or the end of the file.  See the STREAM_SEEK enumeration
        for the values.

    pLibnewPosition [out] Pointer to the location where this method writes the
        value of the new seek pointer from the beginning of the stream.  You
        can set this pointer to NULL to indicate that you are not interested in
        this value.  In this case, this method does not provide the new seek
        pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::Seek changes the seek pointer so subsequent reads and writes
    can take place at a different location in the stream object.  It is an
    error to seek before the beginning of the stream.  It is not, however, an
    error to seek past the end of the stream.  Seeking past the end of the
    stream is useful for subsequent writes, as the stream will at that time be
    extended to the seek position immediately before the write is done.

    You can also use this method to obtain the current value of the seek
    pointer by calling this method with the dwOrigin parameter set to
    STREAM_SEEK_CUR and the dlibMove parameter set to 0 so the seek pointer is
    not changed.  The current seek pointer is returned in the plibNewPosition
    parameter.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Seek")

STDMETHODIMP
CByteBuffer::Seek(
    /* [in] */ LONG dLibMove,
    /* [in] */ LONG dwOrigin,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pLibnewPosition)
{
    HRESULT hReturn = S_OK;

    try
    {
        LARGE_INTEGER xlMove;
        ULARGE_INTEGER xulNewPos;

        SetXL(xlMove, dLibMove, 0);
        SetXL(xulNewPos, 0, 0);
        hReturn = Stream()->Seek(xlMove, dwOrigin, &xulNewPos);
        if (NULL != pLibnewPosition)
            *pLibnewPosition = xulNewPos.LowPart;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

SetSize:

    The SetSize method changes the size of the stream object.

Arguments:

    libNewSize [in] Specifies the new size of the stream as a number of bytes

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::SetSize changes the size of the stream object.  Call this
    method to preallocate space for the stream.  If the libNewSize parameter is
    larger than the current stream size, the stream is extended to the
    indicated size by filling the intervening space with bytes of undefined
    value.  This operation is similar to the IByteBuffer::Write method if the
    seek pointer is past the current end-of-stream.

    If the libNewSize parameter is smaller than the current stream, then the
    stream is truncated to the indicated size.

    The seek pointer is not affected by the change in stream size.

    Calling IByteBuffer::SetSize can be an effective way of trying to obtain a
    large chunk of contiguous space.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::SetSize")

STDMETHODIMP
CByteBuffer::SetSize(
    /* [in] */ LONG libNewSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        ULARGE_INTEGER xul;

        SetXL(xul, libNewSize, 0);
        hReturn = Stream()->SetSize(xul);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Stat:

    The Stat method retrieves statistical information from the stream object.

Arguments:

    pstatstg [out] Points to a STATSTG structure where this method places
        information about this stream object.  This data in this structure
        is meaningless if an error occurs.

    grfStatFlag [in] Ignored.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::Stat retrieves a pointer to the STATSTG structure that
    contains information about this open stream.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Stat")

STDMETHODIMP
CByteBuffer::Stat(
    /* [out][in] */ LPSTATSTRUCT pstatstg,
    /* [in] */ LONG grfStatFlag)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;
        STATSTG stg;

        hr = Stream()->Stat(&stg, STATFLAG_NONAME);
        if (FAILED(hr))
            throw hr;
        pstatstg->type = stg.type;
        pstatstg->cbSize = stg.cbSize.LowPart;
        pstatstg->grfMode = stg.grfMode;
        pstatstg->grfLocksSupported = stg.grfLocksSupported;
        pstatstg->grfStateBits = stg.grfStateBits;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

UnlockRegion:

    The UnlockRegion method removes the access restriction on a range of bytes
    previously restricted with IByteBuffer::LockRegion.

Arguments:

    libOffset [in] Specifies the byte offset for the beginning of the range.

    cb [in] Specifies, in bytes, the length of the range to be restricted.

    dwLockType [in] Specifies the access restrictions previously placed on the
        range.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::UnlockRegion unlocks a region previously locked with the
    IByteBuffer::LockRegion method.  Locked regions must later be explicitly
    unlocked by calling IByteBuffer::UnlockRegion with exactly the same values
    for the libOffset, cb, and dwLockType parameters.  The region must be
    unlocked before the stream is released.  Two adjacent regions cannot be
    locked separately and then unlocked with a single unlock call.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::UnlockRegion")

STDMETHODIMP
CByteBuffer::UnlockRegion(
    /* [in] */ LONG libOffset,
    /* [in] */ LONG cb,
    /* [in] */ LONG dwLockType)
{
    HRESULT hReturn = S_OK;

    try
    {
        ULARGE_INTEGER xulOffset, xulcb;

        SetXL(xulOffset, libOffset, 0);
        SetXL(xulcb, cb, 0);
        hReturn = Stream()->UnlockRegion(xulOffset, xulcb, dwLockType);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Write:

    The Write method writes a specified number from bytes into the stream
    object starting at the current seek pointer.

Arguments:

    pByte [in] Address of the buffer containing the data that is to be written
        to the stream.  A valid pointer must be provided for this parameter
        even when cb is zero.

    cb [in] The number of bytes of data to attempt to write into the stream.
        Can be zero.

    pcbWritten [out] Address of a LONG variable where this method writes the
        actual number of bytes written to the stream object.  The caller can
        set this pointer to NULL, in which case, this method does not provide
        the actual number of bytes written.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::Write writes the specified data to a stream object.  The seek
    pointer is adjusted for the number of bytes actually written.  The number
    of bytes actually written is returned in the pcbWritten parameter.  If the
    byte count is zero bytes, the write operation has no effect.

    If the seek pointer is currently past the end of the stream and the byte
    count is nonzero, this method increases the size of the stream to the seek
    pointer and writes the specified bytes starting at the seek pointer.  The
    fill bytes written to the stream are not initialized to any particular
    value.  This is the same as the end-of-file behavior in the MS-DOS FAT file
    system.

    With a zero byte count and a seek pointer past the end of the stream, this
    method does not create the fill bytes to increase the stream to the seek
    pointer.  In this case, you must call the IByteBuffer::SetSize method to
    increase the size of the stream and write the fill bytes.

    The pcbWritten parameter can have a value even if an error occurs.

    In the COM-provided implementation, stream objects are not sparse.  Any
    fill bytes are eventually allocated on the disk and assigned to the stream.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Write")

STDMETHODIMP
CByteBuffer::Write(
    /* [out][in] */ BYTE __RPC_FAR *pByte,
    /* [in] */ LONG cb,
    /* [out][in] */ LONG __RPC_FAR *pcbWritten)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Write(pByte, cb, (LPDWORD)pcbWritten);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\database.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       Database.h
//
//--------------------------------------------------------------------------

// Database.h : Declaration of the CSCardDatabase

#ifndef __SCARDDATABASE_H_
#define __SCARDDATABASE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardDatabase
class ATL_NO_VTABLE CSCardDatabase :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardDatabase, &CLSID_CSCardDatabase>,
    public IDispatchImpl<ISCardDatabase, &IID_ISCardDatabase, &LIBID_SCARDSSPLib>
{
public:
    CSCardDatabase()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDDATABASE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardDatabase)
    COM_INTERFACE_ENTRY(ISCardDatabase)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISCardDatabase
public:
    STDMETHOD(GetProviderCardId)(
        /* [in] */ BSTR bstrCardName,
        /* [retval][out] */ LPGUID __RPC_FAR *ppguidProviderId);

    STDMETHOD(ListCardInterfaces)(
        /* [in] */ BSTR bstrCardName,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppInterfaceGuids);

    STDMETHOD(ListCards)(
        /* [defaultvalue][in] */ LPBYTEBUFFER pAtr,
        /* [defaultvalue][in] */ LPSAFEARRAY pInterfaceGuids,
        /* [defaultvalue][lcid][in] */ long localeId,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppCardNames);

    STDMETHOD(ListReaderGroups)(
        /* [defaultvalue][lcid][in] */ long localeId,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaderGroups);

    STDMETHOD(ListReaders)(
        /* [defaultvalue][lcid][in] */ long localeId,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaders);
};

inline CSCardDatabase *
NewSCardDatabase(
    void)
{
    return (CSCardDatabase *)NewObject(
                                    CLSID_CSCardDatabase,
                                    IID_ISCardDatabase);
}

#endif //__SCARDDATABASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\database.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Database

Abstract:

    The ISCardDatabase interface provides the methods for performing the smart
    card resource manager's database operations.  These operations include
    listing known smart cards, readers, and reader groups, plus retrieving the
    interfaces supported by a smart card and its primary service provider.

Author:

    Doug Barlow (dbarlow) 6/21/1999

Notes:

    The identifier of the primary service provider is a COM GUID that can be
    used to instantiate and use the COM objects for a specific card.

    This is a rewrite of the original code by Mike Gallagher and Chris Dudley.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include "stdafx.h"
#include "Conversion.h"
#include "Database.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardDatabase


/*++

GetProviderCardId:

    The GetProviderCardId method retrieves the identifier (GUID) of the primary
    service provider for the specified smart card.

Arguments:

    bstrCardName [in] Name of the smart card.

    ppguidProviderId [out, retval] Pointer to the primary service provider's
        identifier (GUID) if successful; NULL if operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve all known smart cards, readers and reader groups call ListCard,
    ListReaders, and ListReaderGroups respectively.

    For a list of all the methods provided by the ISCardDatabase interface, see
    ISCardDatabase.

    In addition to the COM error codes listed above, this interface may return
    a smart card error code if a smart card function was called to complete the
    request. For information on smart card error codes, see Error Codes.

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::GetProviderCardId")

STDMETHODIMP
CSCardDatabase::GetProviderCardId(
    /* [in] */ BSTR bstrCardName,
    /* [retval][out] */ LPGUID __RPC_FAR *ppguidProviderId)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwSts;
        CTextString tzCard;

        tzCard = bstrCardName;
        dwSts = SCardGetProviderId(
                    NULL,
                    tzCard,
                    *ppguidProviderId);
        hReturn = HRESULT_FROM_WIN32(dwSts);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardDatabase::ListCardInterfaces:

    The ListCardInterfaces method retrieves the identifiers (GUIDs) of all the
    interfaces supported for the specified smart card.

Arguments:

    bstrCardName [in] Name of the smart card.

    ppInterfaceGuids [out, retval] Pointer to the interface GUIDs if
        successful; NULL if operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve the primary service provider of the smart card, call
    GetProviderCardId.

    To retrieve all known smart cards, readers, and reader groups call
    ListCard, ListReaders, and ListReaderGroups respectively.

    For a list of all the methods provided by the ISCardDatabase interface, see
    ISCardDatabase.

    In addition to the COM error codes listed above, this interface may return
    a smart card error code if a smart card function was called to complete the
    request. For information on smart card error codes, see Error Codes.

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListCardInterfaces")

STDMETHODIMP
CSCardDatabase::ListCardInterfaces(
    /* [in] */ BSTR bstrCardName,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppInterfaceGuids)
{
    HRESULT hReturn = S_OK;
    LPGUID pGuids = NULL;

    try
    {
        DWORD dwSts;
        DWORD cguid = SCARD_AUTOALLOCATE;
        CTextString tzCard;

        tzCard = bstrCardName;
        dwSts = SCardListInterfaces(
                    NULL,
                    tzCard,
                    (LPGUID)&pGuids,
                    &cguid);
        if (SCARD_S_SUCCESS == dwSts)
        {
            GuidArrayToSafeArray(pGuids, cguid, ppInterfaceGuids);
        }
        hReturn = HRESULT_FROM_WIN32(dwSts);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pGuids)
        SCardFreeMemory(NULL, pGuids);
    return hReturn;
}


/*++

CSCardDatabase::ListCards:

    The ListCards method retrieves all of the smart card names that match the
    specified interface identifiers (GUIDs), the specified ATR string, or both.

Arguments:

    pAtr [in, defaultvalue(NULL) ] Pointer to a smart card ATR string. The ATR
        string must be packaged into an IByteBuffer.

    pInterfaceGuids [in, defaultvalue(NULL)] Pointer to a SAFEARRAY of COM
        interface identifiers (GUIDs) in BSTR format.

    localeId [in, lcid, defaultvalue(0x0409)] Language localization identifier.

    ppCardNames [out, retval] Pointer to a SAFEARRAY of BSTRs that contains the
        names of the smart cards that satisfied the search parameters if
        successful; NULL if the operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve all known readers or reader groups, call ListReaders or
    ListReaderGroups respectively.

    To retrieve the primary service provider or the interfaces of a specific
    card GetProviderCardId or ListCardInterfaces respectively.

    For a list of all the methods provided by the ISCardDatabase interface, see
    ISCardDatabase.

    In addition to the COM error codes listed above, this interface may return
    a smart card error code if a smart card function was called to complete the
    request. For information on smart card error codes, see Error Codes.

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListCards")

STDMETHODIMP
CSCardDatabase::ListCards(
    /* [defaultvalue][in] */ LPBYTEBUFFER pAtr,
    /* [defaultvalue][in] */ LPSAFEARRAY pInterfaceGuids,
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppCardNames)
{
    HRESULT hReturn = S_OK;
    LPTSTR szCards = NULL;

    try
    {
        LONG lSts;
        CBuffer bfGuids, bfAtr(36);
        LPCGUID pGuids = NULL;
        LPCBYTE pbAtr = NULL;
        DWORD cguids = 0;
        DWORD dwLen;

        if (NULL != pInterfaceGuids)
        {
            SafeArrayToGuidArray(pInterfaceGuids, bfGuids, &cguids);
            pGuids = (LPCGUID)bfGuids.Access();
        }

        ByteBufferToBuffer(pAtr, bfAtr);

        dwLen = SCARD_AUTOALLOCATE;
        lSts = SCardListCards(
                    NULL,
                    pbAtr,
                    pGuids,
                    cguids,
                    (LPTSTR)&szCards,
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);

        MultiStringToSafeArray(szCards, ppCardNames);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != szCards)
        SCardFreeMemory(NULL, szCards);
    return hReturn;
}


/*++

CSCardDatabase::ListReaderGroups:

    The ListReaderGroups method retrieves the names of the reader groups
    registered in the smart card database.

Arguments:

    localeId [in, lcid, defaultvalue(0x0409)] Language localization ID.

    ppReaderGroups [out, retval] Pointer to a SAFEARRAY of BSTRs that contains
        the names of the smart card reader groups that satisfied the search
        parameters if successful; NULL if the operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListReaderGroups")

STDMETHODIMP
CSCardDatabase::ListReaderGroups(
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaderGroups)
{
    HRESULT hReturn = S_OK;
    LPTSTR szGroups = NULL;

    try
    {
        LONG lSts;
        DWORD dwLen;

        dwLen = SCARD_AUTOALLOCATE;
        lSts = SCardListReaderGroups(NULL, (LPTSTR)&szGroups, &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        MultiStringToSafeArray(szGroups, ppReaderGroups);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != szGroups)
        SCardFreeMemory(NULL, szGroups);
    return hReturn;
}


/*++

CSCardDatabase::ListReaders:

    The ListReaders method retrieves the names of the smart card readers
    registered in the smart card database.

Arguments:

    localeId [in, lcid, defaultvalue(0x0409)] Language localization ID.

    ppReaders [out, retval] Pointer to a SAFEARRAY of BSTRs that contains the
        names of the smart card readers if successful; NULL if the operation
        failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListReaders")

STDMETHODIMP
CSCardDatabase::ListReaders(
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaders)
{
    HRESULT hReturn = S_OK;
    LPTSTR szReaders = NULL;

    try
    {
        LONG lSts;
        DWORD dwLen;

        dwLen = SCARD_AUTOALLOCATE;
        lSts = SCardListReaders(NULL, NULL, (LPTSTR)&szReaders, &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        MultiStringToSafeArray(szReaders, ppReaders);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != szReaders)
        SCardFreeMemory(NULL, szReaders);
    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\dlldatax.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dlldatax.c
//
//--------------------------------------------------------------------------

// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400 //for WinNT 4.0 or Win95 with DCOM
#endif
#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "scardssp_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\conversion.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Conversion

Abstract:

    This module contains simple conversion routines.

Author:

    Doug Barlow (dbarlow) 6/20/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include "stdafx.h"
#include "ByteBuffer.h"
#include "Conversion.h"

static BOOL
GuidFromString(
    LPCTSTR szGuid,
    LPGUID pGuid);


/*++

ConstructRequest:

    This routine builds an APDU Request.

Arguments:

    bCla supplies the Class byte

    cIns supplies the Instance byte

    bP1 supplies P1

    bP2 supplies P2

    bfData supplies the data

    wLe supplies the expected return length

    dwFlags supplies any special processing flags:

        APDU_EXTENDED_LC - Force an extended value for Lc
        APDU_EXTENDED_LE - Force an externded value for Le
        APDU_MAXIMUM_LE - Request the maximum Le value

    bfApdu receives the constructed APDU

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/26/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ConstructRequest")

void
ConstructRequest(
    IN  BYTE bCla,
    IN  BYTE bIns,
    IN  BYTE bP1,
    IN  BYTE bP2,
    IN  CBuffer &bfData,
    IN  WORD wLe,
    IN  DWORD dwFlags,
    OUT CBuffer &bfApdu)
{
    WORD wLc;
    BOOL fExtended;
    BYTE b, rgLen[2];


    //
    // Quick prep work
    //

    if (0xffff < bfData.Length())
        throw (HRESULT)E_INVALIDARG;
    wLc = (WORD)bfData.Length();
    bfApdu.Presize(4 + 3 + 3 + wLc);    // Worst case
    fExtended = (0 != (dwFlags & APDU_EXTENDED_LENGTH))
                || (0xff < wLe)
                || (0xff < wLc);


    //
    // Fill in the buffer with the easy stuff.
    //

    bfApdu.Set(&bCla, 1);
    bfApdu.Append(&bIns, 1);
    bfApdu.Append(&bP1, 1);
    bfApdu.Append(&bP2, 1);


    //
    // Is there data to be sent?
    //

    if (0 != wLc)
    {
        if (fExtended)
        {
            LocalToNet(rgLen, wLc);
            bfApdu.Append((LPCBYTE)"", 1);      // Append a zero byte
            bfApdu.Append(rgLen, 2);
        }
        else
        {
            b = LeastSignificantByte(wLc);
            bfApdu.Append(&b, 1);
        }
        bfApdu.Append(bfData.Access(), wLc);
    }


    //
    // Do we expect data back?
    //

    if ((0 != wLe) || (0 != (dwFlags & APDU_MAXIMUM_LE)))
    {
        if (fExtended)
        {
            if (0 == wLc)
                bfApdu.Append((LPCBYTE)"", 1);  // Append a zero byte
            LocalToNet(rgLen, wLe);
            bfApdu.Append(rgLen, 2);
        }
        else
        {
            b = LeastSignificantByte(wLe);
            bfApdu.Append(&b, 1);
        }
    }
}


/*++

ParseRequest:

    This routine parses an APDU into it's components.

Arguments:

    bfApdu supplies the APDU to be parsed.

    pbCla receives the Class

    pbIns receives the Instance

    pbP1 receives P1

    pbP2 receives P2

    pbfData receives the data

    pwLc receives the supplied data length

    pwLe receives the expected length

    pdwFlags receives the construction flags

        APDU_EXTENDED_LC - There was an extended value for Lc
        APDU_EXTENDED_LE - There was an externded value for Le
        APDU_MAXIMUM_LE - There was a maximum Le value

Return Value:

    None

Throws:

    Errors are thrown as an HRESULT status code.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/26/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ParseRequest")

void
ParseRequest(
    IN  LPCBYTE pbApdu,
    IN  DWORD cbApdu,
    OUT LPBYTE pbCla,
    OUT LPBYTE pbIns,
    OUT LPBYTE pbP1,
    OUT LPBYTE pbP2,
    OUT LPCBYTE *ppbData,
    OUT LPWORD pwLc,
    OUT LPWORD pwLe,
    OUT LPDWORD pdwFlags)
{
    DWORD dwLen = cbApdu;
    DWORD dwFlags = 0;
    WORD wLen, wLe, wLc;


    //
    // Easy stuff.
    //

    if (4 > dwLen)
        throw (HRESULT)E_INVALIDARG;
    if (NULL != pbCla)
        *pbCla = pbApdu[0];
    if (NULL != pbIns)
        *pbIns = pbApdu[1];
    if (NULL != pbP1)
        *pbP1  = pbApdu[2];
    if (NULL != pbP2)
        *pbP2  = pbApdu[3];


    //
    // Harder stuff.
    //

    if (NULL != ppbData)
        *ppbData = NULL;
    if (4 == dwLen)
    {
        // Type 1

        wLc = 0;
        wLe = 0;
    }
    else if ((0 != pbApdu[4]) || (5 == dwLen))
    {
        // Short length

        wLen = pbApdu[4];
        if (5 == dwLen)
        {
            // Type 2S
            wLc = 0;
            wLe = wLen;
            if (0 == wLen)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else if (5 == dwLen - wLen)
        {
            // Type 3S
            if (NULL != ppbData)
                *ppbData = &pbApdu[5];
            wLc = wLen;
            wLe = 0;
        }
        else if (6 == dwLen - wLen)
        {
            // Type 4S
            if (NULL != ppbData)
                *ppbData = &pbApdu[5];
            wLc = wLen;
            wLe = pbApdu[dwLen - 1];
            if (0 == wLe)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else
            throw (HRESULT)E_INVALIDARG;
    }
    else if (7 <= dwLen)
    {
        // Extended length
        dwFlags |= APDU_EXTENDED_LENGTH;
        wLen = NetToLocal(&pbApdu[5]);
        if (7 == dwLen)
        {
            // Type 2E
            wLe = wLen;
            if (0 == wLen)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else if (7 == dwLen - wLen)
        {
            // Type 3E
            if (NULL != ppbData)
                *ppbData = &pbApdu[6];
            wLc = wLen;
            wLe = 0;
        }
        else if (9 == dwLen - wLen)
        {
            // Type 4E
            if (NULL != ppbData)
                *ppbData = &pbApdu[6];
            wLc = wLen;
            wLe = NetToLocal(&pbApdu[dwLen - 2]);
            if (0 == wLe)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else
            throw (HRESULT)E_INVALIDARG;
    }
    else
        throw (HRESULT)E_INVALIDARG;

    if (NULL != pwLc)
        *pwLc = wLc;
    if (NULL != pwLe)
        *pwLe = wLe;
    if (NULL != pdwFlags)
        *pdwFlags = dwFlags;
}


/*++

ParseReply:

    This routine parses an APDU reply.

Arguments:

    bfApdu supplies the APDU reply to be parsed.

    pbSW1 receives SW1

    pbSW2 receives SW2

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/26/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ParseReply")

void
ParseReply(
    IN  CBuffer &bfApdu,
    OUT LPBYTE pbSW1,
    OUT LPBYTE pbSW2)
{
    DWORD dwLen = bfApdu.Length();

    if (2 > dwLen)
        throw (HRESULT)E_INVALIDARG;
    if (NULL != pbSW1)
        *pbSW1 = bfApdu[dwLen - 2];
    if (NULL != pbSW2)
        *pbSW2 = bfApdu[dwLen - 1];
}


/*++

MultiStringToSafeArray:

    This function converts a Calais Multistring to a SafeArray Structure.

Arguments:

    msz supplies the multistring to be converted.

    pprgsz supplies and/or receives the SafeArray.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT error codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/20/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("MultiStringToSafeArray")

void
MultiStringToSafeArray(
    IN LPCTSTR msz,
    IN OUT LPSAFEARRAY *pprgsz)
{
    LONG ni = 0;
    DWORD csz = MStringCount(msz);
    VARTYPE vt;
    HRESULT hr;
    LPCTSTR sz;
    CTextString tz;
    LPSAFEARRAY pDelArray = NULL;

    try
    {
        if (NULL == *pprgsz)
        {
            vt = VT_BSTR;
            pDelArray = SafeArrayCreateVector(vt, 0, csz);
            if (NULL == pDelArray)
                throw (HRESULT)E_OUTOFMEMORY;
             *pprgsz= pDelArray;
        }
        else
        {
            SAFEARRAYBOUND bound;

            if (1 != SafeArrayGetDim(*pprgsz))
                throw (HRESULT)E_INVALIDARG;
            bound.cElements = csz;
            bound.lLbound = 0;
            hr = SafeArrayRedim(*pprgsz, &bound);
            if (FAILED(hr))
                throw hr;
            hr = SafeArrayGetVartype(*pprgsz, &vt);
            if (FAILED(hr))
                throw hr;
        }

        for (sz = FirstString(msz); NULL != sz; sz = NextString(sz))
        {
            tz = sz;
            switch (vt)
            {
            case VT_LPSTR:
                hr = SafeArrayPutElement(*pprgsz, &ni, (LPVOID)((LPCSTR)tz));
                break;
            case VT_LPWSTR:
                hr = SafeArrayPutElement(*pprgsz, &ni, (LPVOID)((LPCWSTR)tz));
                break;
            case VT_BSTR:
                hr = SafeArrayPutElement(*pprgsz, &ni, (LPVOID)((LPCWSTR)tz));
                break;
            default:
                hr = E_INVALIDARG;
            }

            if (FAILED(hr))
                throw hr;
            ni += 1;
        }
    }

    catch (...)
    {
        if (NULL != pDelArray)
        {
            try { *pprgsz = NULL; } catch (...) {}
            SafeArrayDestroy(pDelArray);
            throw;
        }
    }
}


/*++

GuidArrayToSafeArray:

    This function converts a vector of GUIDs into its SafeArray form.

Arguments:

    pGuids supplies the list of GUIDs

    cguids supplies the number of GUIDs in the list

    pprgguids supplies a safe array to receive the GUIDs, or if NULL, receives
        a new safe array of GUIDs.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT error codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("GuidArrayToSafeArray")

void
GuidArrayToSafeArray(
    IN LPCGUID pGuids,
    IN DWORD cguids,
    IN OUT LPSAFEARRAY *pprgguids)
{
    LONG ni = 0;
    VARTYPE vt;
    HRESULT hr;
    LPSAFEARRAY pDelArray = NULL;
    CTextString tz;

    try
    {
        if (NULL == *pprgguids)
        {
            vt = VT_CLSID;
            pDelArray = SafeArrayCreateVector(vt, 0, cguids);
            if (NULL == pDelArray)
                throw (HRESULT)E_OUTOFMEMORY;
            *pprgguids = pDelArray;
        }
        else
        {
            SAFEARRAYBOUND bound;

            if (1 != SafeArrayGetDim(*pprgguids))
                throw (HRESULT)E_INVALIDARG;
            bound.cElements = cguids;
            bound.lLbound = 0;
            hr = SafeArrayRedim(*pprgguids, &bound);
            if (FAILED(hr))
                throw hr;
            hr = SafeArrayGetVartype(*pprgguids, &vt);
            if (FAILED(hr))
                throw hr;
        }

        for (ni = 0; (DWORD)ni < cguids; ni += 1)
        {
            TCHAR szGuid[40];

            StringFromGuid(&pGuids[ni], szGuid);
            tz = szGuid;

            switch (vt)
            {
            case VT_LPSTR:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)((LPCSTR)tz));
                break;
            case VT_LPWSTR:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)((LPCWSTR)tz));
                break;
            case VT_BSTR:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)((LPCWSTR)tz));
                break;
            case VT_CLSID:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)(&pGuids[ni]));
                break;
            default:
                hr = E_INVALIDARG;
            }
            if (FAILED(hr))
                throw hr;
        }
    }

    catch (...)
    {
        if (NULL != pDelArray)
        {
            try { *pprgguids = NULL; } catch (...) {}
            SafeArrayDestroy(pDelArray);
        }
        throw;
    }
}


/*++

SafeArrayToGuidArray:

    This routine converts a given SafeArray object into a list of GUIDs.

Arguments:

    prgGuids supplies the SafeArray containing the GUIDs.

    bfGuids receives a block of memory containing binary GUIDs.

    pcGuids receives the number of GUIDs in the array.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("SafeArrayToGuidArray")

void
SafeArrayToGuidArray(
    IN LPSAFEARRAY prgGuids,
    OUT CBuffer &bfGuids,
    OUT LPDWORD pcGuids)
{
    VARTYPE vt;
    HRESULT hr;
    LONG lLBound, lUBound, lIndex;
    LPVOID pVoid;
    CTextString tz;
    LPGUID pguid;
    LONG lOne = 1;

    if (1 != SafeArrayGetDim(prgGuids))
        throw (HRESULT)E_INVALIDARG;
    hr = SafeArrayGetLBound(prgGuids, 1, &lLBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetUBound(prgGuids, 1, &lUBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetVartype(prgGuids, &vt);
    if (FAILED(hr))
        throw hr;
    lIndex = lUBound - lLBound;
    pguid = (LPGUID)bfGuids.Resize(lIndex * sizeof(GUID));
    if (NULL != pcGuids)
        *pcGuids = (DWORD)lIndex;

    for (lIndex = lLBound; lIndex <= lUBound; lIndex += 1)
    {
        hr = SafeArrayGetElement(prgGuids, &lOne, &pVoid);
        if (FAILED(hr))
            throw hr;

        switch (vt)
        {
        case VT_LPSTR:
            tz = (LPCSTR)pVoid;
            if (!GuidFromString(tz, &pguid[lIndex - lLBound]))
                hr = E_INVALIDARG;
            break;
        case VT_LPWSTR:
            tz = (LPCWSTR)pVoid;
            if (!GuidFromString(tz, &pguid[lIndex - lLBound]))
                hr = E_INVALIDARG;
            break;
        case VT_BSTR:
            tz = (BSTR)pVoid;
            if (!GuidFromString(tz, &pguid[lIndex - lLBound]))
                hr = E_INVALIDARG;
            break;
        case VT_CLSID:
            CopyMemory(&pguid[lIndex - lLBound], pVoid, sizeof(GUID));
            break;
        default:
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
            throw hr;
    }
}


/*++

SafeArrayToMultiString:

    This routine converts a SafeArray into a multiString.

Arguments:

    prgsz supplies the SafeArray

    msz receives the MultiString

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("SafeArrayToMultiString")

void
SafeArrayToMultiString(
    IN LPSAFEARRAY prgsz,
    IN OUT CTextMultistring &msz)
{
    VARTYPE vt;
    HRESULT hr;
    LONG lLBound, lUBound, lIndex;
    LPVOID pVoid;
    CBuffer bf;

    if (1 != SafeArrayGetDim(prgsz))
        throw (HRESULT)E_INVALIDARG;
    hr = SafeArrayGetLBound(prgsz, 1, &lLBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetUBound(prgsz, 1, &lUBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetVartype(prgsz, &vt);
    if (FAILED(hr))
        throw hr;

    for (lIndex = lLBound; lIndex <= lUBound; lIndex += 1)
    {
        hr = SafeArrayGetElement(prgsz, &lIndex, &pVoid);
        if (FAILED(hr))
            throw hr;

        switch (vt)
        {
        case VT_LPSTR:
            MStrAdd(bf, (LPCSTR)pVoid);
            break;
        case VT_LPWSTR:
        case VT_BSTR:
            MStrAdd(bf, (LPCWSTR)pVoid);
            break;
        default:
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
            throw hr;
    }

    msz = (LPCTSTR)bf.Access();
}


/*++

GuidFromString:

    This routine converts a string GUID into a binary GUID.

Arguments:

    szGuid supplies the GUID in the string format.

    pGuid receives the converted GUID.

Return Value:

    TRUE - Successful conversion
    FALSE - Parsing Error

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("GuidFromString")

static BOOL
GuidFromString(
    LPCTSTR szGuid,
    LPGUID pGuid)
{

    //
    // The following placement assumes Little Endianness.
    // 1D92589A-91E4-11d1-93AA-00C04FD91402
    // 012345678901234567890123456789012345
    //           1         2         3
    //

    static const BYTE rgbPlace[sizeof(GUID)]
        = {  3,  2,  1,  0,  5,  4,  7,  6,  8,  9, 10, 11, 12, 13, 14, 15 };
    static const DWORD rgdwPunct[]
        = { 8,         13,        18,        23 };
    LPCTSTR pch = szGuid;
    BYTE bVal;
    DWORD dwI, dwJ, dwPunct = 0;

    szGuid += _tcsspn(szGuid, TEXT("{[("));
    pch = szGuid;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        if ((BYTE)(pch - szGuid) == rgdwPunct[dwPunct])
        {
            if (TEXT('-') != *pch)
                goto ErrorExit;
            dwPunct += 1;
            pch += 1;
        }

        bVal = 0;
        for (dwJ = 0; dwJ < 2; dwJ += 1)
        {
            bVal <<= 4;
            if ((TEXT('0') <= *pch) && (TEXT('9') >= *pch))
                bVal += *pch - TEXT('0');
            else if ((TEXT('A') <= *pch) && (TEXT('F') >= *pch))
                bVal += 10 + *pch - TEXT('A');
            else if ((TEXT('f') <= *pch) && (TEXT('f') >= *pch))
                bVal += 10 + *pch - TEXT('a');
            else
                goto ErrorExit;
            pch += 1;
        }

        ((LPBYTE)pGuid)[rgbPlace[dwI]] = bVal;
    }
    return TRUE;

ErrorExit:
    return FALSE;
}


/*++

ByteBufferToBuffer:

    This routine extracts the contents of a ByteBuffer object into a CBuffer
    for easy access.

Arguments:

    pby supplies the ByteBuffer to be read.

    bf receives the contents of pby.

Return Value:

    Number of bytes read from the stream.

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/29/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ByteBufferToBuffer")

LONG
ByteBufferToBuffer(
    IN LPBYTEBUFFER pby,
    OUT CBuffer &bf)
{
    HRESULT hr;
    LONG nLen = 0;

    if (NULL != pby)
    {
        hr = pby->Seek(0, STREAM_SEEK_END, &nLen);
        if (FAILED(hr))
            throw hr;
        hr = pby->Seek(0, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;

        hr = pby->Read(
                    bf.Presize((DWORD)nLen),
                    nLen,
                    &nLen);
        if (FAILED(hr))
            throw hr;
        bf.Resize((DWORD)nLen, TRUE);
    }
    else
        bf.Reset();
    return nLen;
}


/*++

BufferToByteBuffer:

    This routine writes the contents of the supplied CBuffer object into the
    supplied IByteBuffer object, replacing any existing contents.

Arguments:

    bf supplies the data to be written into pby.

    ppby receives the contents of bf.

Return Value:

    Number of bytes written to the stream.

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/29/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("BufferToByteBuffer")

LONG
BufferToByteBuffer(
    IN  CBuffer &bf,
    OUT LPBYTEBUFFER *ppby)
{
    HRESULT hr;
    LONG lLen = 0;

    if (NULL == *ppby)
    {
        *ppby = NewByteBuffer();
        if (NULL == *ppby)
            throw (HRESULT)E_OUTOFMEMORY;
    }

    hr = (*ppby)->Initialize();
    if (FAILED(hr))
        throw hr;
    hr = (*ppby)->Write(bf.Access(), bf.Length(), &lLen);
    if (FAILED(hr))
        throw hr;
    hr = (*ppby)->Seek(0, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        throw hr;
    return lLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\dlldatax.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dlldatax.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_DLLDATAX_H__9AEC1AFF_19F1_11D3_A11F_00C04F79F800__INCLUDED_)
#define AFX_DLLDATAX_H__9AEC1AFF_19F1_11D3_A11F_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__9AEC1AFF_19F1_11D3_A11F_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\iso7816.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ISO7816.h
//
//--------------------------------------------------------------------------

// ISO7816.h : Declaration of the CSCardISO7816

#ifndef __SCARDISO7816_H_
#define __SCARDISO7816_H_

#include "resource.h"       // main symbols
#include "scardcmd.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardISO7816
class ATL_NO_VTABLE CSCardISO7816 :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardISO7816, &CLSID_CSCardISO7816>,
    public IDispatchImpl<ISCardISO7816, &IID_ISCardISO7816, &LIBID_SCARDSSPLib>
{
public:
    CSCardISO7816()
    {
        m_pUnkMarshaler = NULL;
        m_bCla = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDISO7816)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardISO7816)
    COM_INTERFACE_ENTRY(ISCardISO7816)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    BYTE m_bCla;

// ISCardISO7816
public:
    STDMETHOD(AppendRecord)(
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(EraseBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ExternalAuthenticate)(
        /* [in] */ BYTE byAlgorithmRef,
        /* [in] */ BYTE bySecretRef,
        /* [in] */ LPBYTEBUFFER pChallenge,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(GetChallenge)(
        /* [in] */ LONG lBytesExpected,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(GetData)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LONG lBytesToGet,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(GetResponse)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LONG lDataLength,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(InternalAuthenticate)(
        /* [in] */ BYTE byAlgorithmRef,
        /* [in] */ BYTE bySecretRef,
        /* [in] */ LPBYTEBUFFER pChallenge,
        /* [in] */ LONG lReplyBytes,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ManageChannel)(
        /* [in] */ BYTE byChannelState,
        /* [in] */ BYTE byChannel,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(PutData)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ReadBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LONG lBytesToRead,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ReadRecord)(
        /* [in] */ BYTE byRecordId,
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LONG lBytesToRead,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(SelectFile)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [in] */ LONG lBytesToRead,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(SetDefaultClassId)(
        /* [in] */ BYTE byClass);

    STDMETHOD(UpdateBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(UpdateRecord)(
        /* [in] */ BYTE byRecordId,
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(Verify)(
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(WriteBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(WriteRecord)(
        /* [in] */ BYTE byRecordId,
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
};

inline CSCardISO7816 *
NewSCardISO7816(
    void)
{
    return (CSCardISO7816 *)NewObject(CLSID_CSCardISO7816, IID_ISCardISO7816);
}

#endif //__SCARDISO7816_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\proto_t0.cpp ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    Proto_T0

Abstract:

    This module provides the mapping from an APDU to a T=0 TPDU.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "Conversion.h"


/*++

ApduToTpdu_T0:

    This routine takes an APDU, converts it to a T=0 TPDU, and performs the
    exchange to the specified card.

Arguments:

    hCard supplies a handle to the card to be used in the exchange.

    pbPciRqst supplies the PCI Request structure

    cbPciRqst supplies the length of pbPciRqst, in bytes

    pbApdu supplies the APDU to be sent to the card.

    cbApdu supplies the length of the APDU in pbApdu.

    dwFlags supplies any special flags used to modify the operation.

    bfPciRsp receives the response PCI.

    bfReply receives the response from the card.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/28/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ApduToTpdu_T0")

void
ApduToTpdu_T0(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply,
    IN LPCBYTE pbAltCla)
{
    LONG lSts;
    DWORD dwLen, dwXmitFlags;
    WORD wLen, wLc, wLe, wSts;
    CBuffer bfXmit(264), bfRecv(264);
    BYTE rgb[4];
    BYTE b;
    LPCBYTE pbData;


    //
    // Prepare for conversion.
    //

    bfReply.Reset();
    bfPciRsp.Set((LPCBYTE)pPciRqst, pPciRqst->cbPciLength);
    ParseRequest(
        pbApdu,
        cbApdu,
        NULL,
        NULL,
        NULL,
        NULL,
        &pbData,
        &wLc,
        &wLe,
        &dwXmitFlags);


    //
    // Send the data.
    //

    if (0 == wLc)
    {

        //
        // Le goes into P3
        //

        bfXmit.Set(pbApdu, 4); // CLA, INS, P1, P2
        if (0 == (dwXmitFlags & APDU_MAXIMUM_LE))
            wLen = __min(255, wLe);
        else
            wLen = 0;
        b = LeastSignificantByte(wLen);
        bfXmit.Append(&b, 1);

        dwLen = bfRecv.Space();
        lSts = SCardTransmit(
                    hCard,
                    pPciRqst,
                    bfXmit.Access(),
                    bfXmit.Length(),
                    (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                    bfRecv.Access(),
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        bfRecv.Resize(dwLen, TRUE);
        if (2 > dwLen)
        {
            bfReply.Set(bfRecv.Access(), bfRecv.Length());
            goto EndProtocol;
        }
        ASSERT(0x10000 > dwLen);
        wLe -= (WORD)(dwLen - 2);
        wSts = NetToLocal(bfRecv.Access(dwLen - 2));
    }
    else if (256 > wLc)
    {

        //
        // Send the data in the short form.
        //

        bfXmit.Set(pbApdu, 4); // CLA, INS, P1, P2
        b = LeastSignificantByte(wLc);
        bfXmit.Append(&b, 1);
        bfXmit.Append(pbData, wLc);

        dwLen = bfRecv.Space();
        lSts = SCardTransmit(
                    hCard,
                    pPciRqst,
                    bfXmit.Access(),
                    bfXmit.Length(),
                    (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                    bfRecv.Access(),
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        bfRecv.Resize(dwLen, TRUE);
        if (2 > dwLen)
        {
            bfReply.Set(bfRecv.Access(), bfRecv.Length());
            goto EndProtocol;
        }
        wSts = NetToLocal(bfRecv.Access(dwLen - 2));
    }
    else
    {
        WORD wSent;


        //
        // Send the data in the enveloped form.
        //

        rgb[0] = (NULL != pbAltCla) ? *pbAltCla : *pbApdu;  // CLA
        rgb[1] = 0xc2;      // envelope INS
        rgb[2] = 0;         // P1
        rgb[3] = 0;         // P2
        wSent = 0;
        while (wLc > wSent)
        {
            wLen = __min(255, wLc - wSent);
            bfXmit.Set(rgb, 4);
            bfXmit.Append(&pbData[wSent], wLen);
            b = LeastSignificantByte(wLen);
            bfXmit.Append(&b, 1);
            wSent -= wLen;

            dwLen = bfRecv.Space();
            lSts = SCardTransmit(
                        hCard,
                        pPciRqst,
                        bfXmit.Access(),
                        bfXmit.Length(),
                        (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                        bfRecv.Access(),
                        &dwLen);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            bfRecv.Resize(dwLen, TRUE);
            if (2 != dwLen)
            {
                bfReply.Set(bfRecv.Access(), bfRecv.Length());
                goto EndProtocol;
            }
            wSts = NetToLocal(bfRecv.Access());
            if ((wSent < wLc) && (0x9000 != wSts))
            {
                bfReply.Set(bfRecv.Access(), bfRecv.Length());
                goto EndProtocol;
            }
        }
    }


    //
    // At this point, the first received buffer is in bfRecv.  What do we
    // have to do to bring in any more data?
    //

    rgb[0] = (NULL != pbAltCla) ? *pbAltCla : *pbApdu;  // CLA
    rgb[1] = 0xc0;      // Get Response INS
    rgb[2] = 0;         // P1
    rgb[3] = 0;         // P2

    for (;;)
    {
        ASSERT(2 <= bfRecv.Length());
        BYTE bSw1 = *bfRecv.Access(bfRecv.Length() - 2);
        BYTE bSw2 = *bfRecv.Access(bfRecv.Length() - 1);

        switch (bSw1)
        {
        case 0x6c:  // Wrong length
            wLe = bSw2;
            break;
        case 0x61:  // More data
            bfReply.Append(bfRecv.Access(), bfRecv.Length() - 2);
            if (0 == wLe)
                wLe = bSw2;
            else
                wLe = __min(wLe, bSw2);
            break;
        case 0x90:  // Success?
            if (((0 == wLe) && (0 == (APDU_MAXIMUM_LE & dwFlags)))
                || (0x00 != bSw2))
            {
                bfReply.Append(bfRecv.Access(), bfRecv.Length());
                goto EndProtocol;
            }
            if (2 < bfRecv.Length())    // Shouldn't be
                bfReply.Append(bfRecv.Access(), bfRecv.Length() - 2);
            break;
        default:    // We're done.
            bfReply.Append(bfRecv.Access(), bfRecv.Length());
            goto EndProtocol;
        }


        //
        // We need to request additional data.
        //

        bfXmit.Set(rgb, 4);
        b = LeastSignificantByte(wLe);
        bfXmit.Append(&b, 1);
        dwLen = bfRecv.Space();
        lSts = SCardTransmit(
                    hCard,
                    pPciRqst,
                    bfXmit.Access(),
                    bfXmit.Length(),
                    (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                    bfRecv.Access(),
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        bfRecv.Resize(dwLen, TRUE);
        wLe -= b;
    }


EndProtocol:

    //
    // We've completed the protocol exchange.  The data is ready to be
    // returned to the caller.
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\proto_t1.cpp ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    Proto_T1

Abstract:

    This module provides the mapping from an APDU to a T=1 TPDU.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "Conversion.h"

static DWORD l_dwDefaultIOMax = 0;


/*++

ApduToTpdu_T1:

    This routine takes an APDU, converts it to a T=1 TPDU, and performs the
    exchange to the specified card.

Arguments:

    hCard supplies a handle to the card to be used in the exchange.

    pbPciRqst supplies the PCI Request structure
    
    cbPciRqst supplies the length of pbPciRqst, in bytes
    
    pbApdu supplies the APDU to be sent to the card.
    
    cbApdu supplies the length of the APDU in pbApdu.

    dwFlags supplies any special flags used to modify the operation.

    bfPciRsp receives the response PCI.

    bfReply receives the response from the card.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/28/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ApduToTpdu_T1")

void
ApduToTpdu_T1(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply)
{
    LONG lSts;
    DWORD dwLen, dwXmitFlags;
    WORD wLe;


    //
    // Figure out how big the receive buffers should be.
    //

    bfPciRsp.Set((LPCBYTE)pPciRqst, pPciRqst->cbPciLength);
    ParseRequest(
        pbApdu, 
        cbApdu, 
        NULL, 
        NULL, 
        NULL, 
        NULL, 
        NULL, 
        NULL, 
        &wLe, 
        &dwXmitFlags);
    if ((0 == wLe) && (0 != (dwXmitFlags & APDU_MAXIMUM_LE)))
    {
        if (0 == l_dwDefaultIOMax)
        {
            try
            {
                CRegistry regCalais(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais"),
                    KEY_READ);
            
                l_dwDefaultIOMax = regCalais.GetNumericValue(
                    TEXT("MaxDefaultBuffer"));
            }
            catch (...) 
            {
                l_dwDefaultIOMax = 264;
            }
        }
        wLe = (WORD)l_dwDefaultIOMax;
    }
    bfReply.Presize(wLe + 2);


    //
    // Perform the I/O
    
    dwLen = bfReply.Space();
    lSts = SCardTransmit(
                hCard,
                pPciRqst,
                pbApdu,
                cbApdu,
                (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                bfReply.Access(),
                &dwLen);
    if (SCARD_S_SUCCESS != lSts)
        throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    bfReply.Resize(dwLen, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scardssp.rc
//
#define IDS_PROJNAME                    100
#define IDR_BYTEBUFFER                  101
#define IDR_SCARDTYPECONV               102
#define IDR_SCARDCMD                    103
#define IDR_SCARDISO7816                104
#define IDR_SCARD                       105
#define IDR_SCARDDATABASE               106
#define IDR_SCARDLOCATE                 107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\iso7816.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    ISO7816

Abstract:

    The ISCardISO7816 interface provides methods for implementing ISO 7816-4
    functionality.  With the exception of ISCardISO7816::SetDefaultClassId,
    these methods create an APDU command that is encapsulated in a ISCardCmd
    object.

    The ISO 7816-4 specification defines standard commands available on smart
    cards.  The specification also defines how a smart card Application
    Protocol Data Unit (APDU) command should be constructed and sent to the
    smart card for execution.  This interface automates the building process.

    The following example shows a typical use of the ISCardISO7816 interface.
    In this case, the ISCardISO7816 interface is used to build an APDU command.

    To submit a transaction to a specific card

    1)  Create an ISCardISO7816 and ISCardCmd interface.  The ISCardCmd
        interface is used to encapsulate the APDU.
    2)  Call the appropriate method of the ISCardISO7816 interface, passing the
        required parameters and the ISCardCmd interface pointer.
    3)  The ISO 7816-4 APDU command will be built and encapsulated in the
        ISCardCmd interface.
    4)  Release the ISCardISO7816 and ISCardCmd interfaces.

    Note

    In the method reference pages, if a bit sequence in a table is not defined,
    assume that bit sequence is reserved for future use or proprietary to a
    specific vendor).

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "ISO7816.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardISO7816


/*++

CSCardISO7816::AppendRecord:

    The AppendRecord method constructs an APDU command that either appends a
    record to the end of a linear-structured elementary file (EF) or writes
    record number 1 in an cyclic-structured elementary file.

Arguments:

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Identifies the elementary file to
        be appended:

        Meaning     8 7 6 5 4 3 2 1
        Current EF  0 0 0 0 0 0 0 0
        Short EF ID x x x x x 0 0 0
        Reserved    x x x x x x x x

    pData [in] Pointer to the data to be appended to the file:

        Tn (1 byte)
        Ln (1 or 3 bytes)
        data (Ln bytes)

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    read.

    If another elementary file is selected at the time of issuing this command,
    it may be processed without identification of the currently selected file.

    Elementary files without a record structure cannot be read.  The
    encapsulated command aborts if applied to an elementary file without a
    record structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::AppendRecord")

STDMETHODIMP
CSCardISO7816::AppendRecord(
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xe2,       // INS
                            0,          // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::EraseBinary:

    The EraseBinary method constructs an APDU command that sequentially sets
    part of the content of an elementary file to its logical erased state,
    starting from a given offset.

Arguments:

    byP1, byP2 [in] RFU position.

        If         Then
        b8=1 in P1  b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1 of P1 are
                    a short EF identifier and P2 is the offset of the first
                    byte to be erased (in data units) from the beginning of the
                    file.
        b8=0 in P1  then P1 || P2 is the offset of the first byte to be erased
        (in data units) from the beginning of the file.

        If the data field is present, it codes the offset of the first data
        unit not to be erased.  This offset shall be higher than the one coded
        in P1-P2.  When the data field is empty, the command erases up to the
        end of the file.

    pData [in, defaultvalue(NULL)] Pointer to the data that specifies the erase
        range; may be NULL.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a transparent structure cannot be erased.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::EraseBinary")

STDMETHODIMP
CSCardISO7816::EraseBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0x0e,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ExternalAuthenticate:

    The ExternalAuthenticate method constructs an APDU command that
    conditionally updates security status, verifying the identity of the
    computer when the smart card does not trust it.

    The command uses the result (yes or no) of the computation by the card
    (based on a challenge previously issued by the card  for example, by the
    INS_GET_CHALLENGE command), a key (possibly secret) stored in the card, and
    authentication data transmitted by the interface device.

Arguments:

    byAlgorithmRef [in, defaultvalue(NULL_BYTE)] Reference of the algorithm in
        the card.  If this value is zero, this indicates that no information is
        given.  The reference of the algorithm is known either before issuing
        the command or is provided in the data field.

    bySecretRef [in, defaultvalue(NULL_BYTE)] Reference of the secret:

        Meaning         8 7 6 5 4 3 2 1
        No Info         0 0 0 0 0 0 0 0
        Global ref      0 - - - - - - -
        Specific ref    1 - - - - - - -
        RFU             - x x - - - - -
        Secret          - - - x x x x x

        No Info = No information is given. The reference of the secret is known
            either before issuing the command or is provided in the data field.

        Global ref = Global reference data (an MF specific key).

        Specific ref = Specific reference data (a DF specific key).

        RFU = 00 (other values are RFU).

        Secret = Number of the secret.

    pChallenge [in, defaultvalue(NULL)] Pointer to the authentication-related
        data; may be NULL.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    For the encapsulated command to be successful, the last challenge obtained
    from the card must be valid.

    Unsuccessful comparisons may be recorded in the card (for example, to limit
    the number of further attempts of the use of the reference data).

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ExternalAuthenticate")

STDMETHODIMP
CSCardISO7816::ExternalAuthenticate(
    /* [in] */ BYTE byAlgorithmRef,
    /* [in] */ BYTE bySecretRef,
    /* [in] */ LPBYTEBUFFER pChallenge,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,         // CLA
                            0x82,           // INS
                            byAlgorithmRef, // P1
                            bySecretRef,    // P2
                            pChallenge,     // data
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::GetChallenge:

    The GetChallenge method constructs an APDU command that issue a challenge
    (for example, a random number) for use in a security-related procedure.

Arguments:

    lBytesExpected [in, defaultvalue(0)] Maximum length of the expected response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation. If ppCmd was set to NULL, a smart card ISCardCmd object
        is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The challenge is valid at least for the next command.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::GetChallenge")

STDMETHODIMP
CSCardISO7816::GetChallenge(
    /* [in] */ LONG lBytesExpected,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0x84,   // INS
                            0x00,   // P1
                            0x00,   // P2
                            NULL,
                            &lBytesExpected);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::GetData:

    The GetData method constructs an APDU command that retrieves either a
    single primitive data object or a set of data objects (contained in a
    constructed data object), depending on the type of file selected.

Arguments:

    byP1, byP2 [in] Parameters:

        Value           Meaning
        0000 - 003F     RFU
        0040 - 00FF     BER-TLV tag (1 byte) in P2
        0100 - 01FF     Application data (proprietary coding)
        0200 - 02FF     SIMPLE-TLV tag in P2
        0300 - 03FF     RFU
        0400 - 04FF     BER-TLV tag (2 bytes) in P1-P2

    lBytesToGet [in, defaultvalue(0)] Number of bytes expected in the response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being read.  Security conditions are dependent on the policy of the card,
    and may be manipulated through ExternalAuthenticate, InternalAuthenticate,
    ISCardAuth, etc.

    To select a file, call SelectFile.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::GetData")

STDMETHODIMP
CSCardISO7816::GetData(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lBytesToGet,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xca,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            NULL,
                            &lBytesToGet);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::GetResponse:

    The GetResponse method constructs an APDU command that transmits APDU
    commands (or part of an APDU command) which otherwise could not be
    transmitted by the available protocols.

Arguments:

    byP1, byP2 [in, defaultvalue(0)] Per the ISO 7816-4, P1 and P2 should be 0
        (RFU).

    lDataLength [in, defaultvalue(0)] Length of data transmitted.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::GetResponse")

STDMETHODIMP
CSCardISO7816::GetResponse(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lDataLength,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xc0,   // INS
                            0x00,   // P1
                            0x00,   // P2
                            NULL,
                            &lDataLength);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::InternalAuthenticate:

    The InternalAuthenticate method constructs an APDU command that initiates
    the computation of the authentication data by the card using the challenge
    data sent from the interface device and a relevant secret (for example, a
    key) stored in the card.

    When the relevant secret is attached to the MF, the command may be used to
    authenticate the card as a whole.

    When the relevant secret is attached to another DF, the command may be used
    to authenticate that DF.

Arguments:

    byAlgorithmRef [in, defaultvalue(NULL_BYTE)] Reference of the algorithm in
        the card.  If this value is zero, this indicates that no information is
        given.  The reference of the algorithm is known either before issuing
        the command or is provided in the data field.

    bySecretRef [in, defaultvalue(NULL_BYTE)] Reference of the secret:

        Meaning         8 7 6 5 4 3 2 1
        No Info         0 0 0 0 0 0 0 0
        Global ref      0 - - - - - - -
        Specific ref    1 - - - - - - -
        RFU             - x x - - - - -
        Secret          - - - x x x x x

        No Info = No information is given.

        Global ref = Global reference data (an MF specific key).

        Specific ref = Specific reference data (a DF specific key).

        RFU = 00 (other values are RFU).

        Secret = Number of the secret.

    pChallenge [in] Pointer to the authentication-related data (for example,
        challenge).

    lReplyBytes [in, defaultvalue(0)] Maximum number of bytes expected in
        response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The successful execution of the command may be subject to successful
    completion of prior commands (for example, VERIFY or SELECT FILE) or
    selections (for example, the relevant secret).

    If a key and an algorithm are currently selected when issuing the command,
    then the command may implicitly use the key and the algorithm.

    The number of times the command is issued may be recorded in the card to
    limit the number of further attempts of using the relevant secret or the
    algorithm.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::InternalAuthenticate")

STDMETHODIMP
CSCardISO7816::InternalAuthenticate(
    /* [in] */ BYTE byAlgorithmRef,
    /* [in] */ BYTE bySecretRef,
    /* [in] */ LPBYTEBUFFER pChallenge,
    /* [in] */ LONG lReplyBytes,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,         // CLA
                            0x88,           // INS
                            byAlgorithmRef, // P1
                            bySecretRef,    // P2
                            pChallenge,
                            &lReplyBytes);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ManageChannel:

    The ManageChannel method constructs an APDU command that opens and closes
    logical channels.

    The open function opens a new logical channel other than the basic one.
    Options are provided for the card to assign a logical channel number, or
    for the logical channel number to be supplied to the card.

    The close function explicitly closes a logical channel other than the basic
    one.  After the successful closing, the logical channel shall be available
    for re-use.

Arguments:

    byChannelState [in, defaultvalue(ISO_CLOSE_LOGICAL_CHANNEL)] Bit b8 of P1
        is used to indicate the open function or the close function; if b8 is 0
        then MANAGE CHANNEL shall open a logical channel and if b8 is 1 then
        MANAGE CHANNEL shall close a logical channel:

        P1 = '00' to open

        P1 = '80' to close

        Other values are RFU

    byChannel [in, defaultvalue(ISO_LOGICAL_CHANNEL_0)] For the open function
        (P1 = '00'), the bits b1 and b2 of P2 are used to code the logical
        channel number in the same manner as in the class byte, the other bits
        of P2 are RFU.  When b1 and b2 of P2 are NULL, then the card will
        assign a logical channel number that will be returned in bits b1 and
        b2 of the data field.

        When b1 and/or b2 of P2 are not NULL, they code a logical channel
        number other than the basic one; then the card will open the externally
        assigned logical channel number.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    When the open function is successfully performed from the basic logical
    channel, the MF shall be implicitly selected as the current DF and the
    security status of the new logical channel should be the same as the basic
    logical channel after ATR.  The security status of the new logical channel
    should be separate from that of any other logical channel.

    When the open function is successfully performed from a logical channel,
    which is not the basic one, the current DF of the logical channel that
    issued the command will be selected as the current DF.  In addition, the
    security status for the new logical channel should be the same as the
    security status of the logical channel from which the open function was
    performed.

    After a successful close function, the security status related to this
    logical channel is lost.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ManageChannel")

STDMETHODIMP
CSCardISO7816::ManageChannel(
    /* [in] */ BYTE byChannelState,
    /* [in] */ BYTE byChannel,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;
        LONG lLe = 1;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,         // CLA
                            0x70,           // INS
                            byChannelState, // P1
                            byChannel,      // P2
                            NULL,
                            0 == (byChannelState | byChannel)
                            ? &lLe
                            : NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::PutData:

    The PutData method constructs an APDU command that stores a single
    primitive data object or the set of data objects contained in a constructed
    data object, depending on the file selected.

    How the objects are stored (writing once and/or updating and/or appending)
    depends on the definition or the nature of the data objects.

Arguments:

    byP1, byP2 [in] Coding of P1-P2:

        Value           Meaning
        0000 - 003F     RFU
        0040 - 00FF     BER-TLV tag (1 byte) in P2
        0100 - 01FF     Application data (proprietary coding)
        0200 - 02FF     SIMPLE-TLV tag in P2
        0300 - 03FF     RFU
        0400 - 04FF     BER-TLV tag (2 bytes) in P1-P2

    pData [in] Pointer to a byte buffer that contains the parameters and data to be
        written.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The command can be performed only if the security status satisfies the
    security conditions defined by the application within the context for the
    function.

    Store Application Data
        When the value of P1-P2 lies in the range from 0100 to 01FF, the value
        of P1-P2 shall be an identifier reserved for card internal tests and
        for proprietary services meaningful within a given application context.

    Store Data Objects
        When the value P1-P2 lies in the range from 0040 to 00FF, the value of
        P2 shall be a BER-TLV tag on a single byte.  The value of 00FF is
        reserved for indicating that the data field carries BER-TLV data
        objects.

        When the value of P1-P2 lies in the range 0200 to 02FF, the value of P2
        shall be a SIMPLE-TLV tag.  The value 0200 is RFU.  The value 02FF is
        reserved for indicating that the data field carries SIMPLE-TLV data
        objects.

        When the value of P1-P2 lies in the range from 4000 to FFFF, the value
        of P1-P2 shall be a BER-TLV tag on two bytes.  The values 4000 to FFFF
        are RFU.

        When a primitive data object is provided, the data field of the command
        message shall contain the value of the corresponding primitive data
        object.

        When a constructed data object is provided, the data field of the
        command message shall contain the value of the constructed data object
        (that is, data objects including their tag, length, and value).

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::PutData")

STDMETHODIMP
CSCardISO7816::PutData(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xda,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ReadBinary:

    The ReadBinary method constructs an APDU command that acquires a response
    message that gives that part of the contents of a transparent-structured
    elementary file.

Arguments:

    byP1, byP2 [in] The P1-P2 field, offset to the first byte to be read from
        the beginning of the file.

        If b8=1 in P1, then b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1
        of P1 are a short EF identifier and P2 is the offset of the first byte
        to be read in data units from the beginning of the file.

        If b8=0 in P1, then P1||P2 is the offset of the first byte to be read
        in data units from the beginning of the file.

    lBytesToRead [in, defaultvalue(0)] Number of bytes to read from the
    transparent EF.  If the Le field contains only zeroes, then within the
    limit of 256 for short length or 65536 for extended length, all the bytes
    until the end of the file should be read.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a transparent structure cannot be erased.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ReadBinary")

STDMETHODIMP
CSCardISO7816::ReadBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xb0,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            NULL,
                            &lBytesToRead);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ReadRecord:

    The ReadRecord method constructs an APDU command that reads either the
    contents of the specified record(s) or the beginning part of one record of
    an elementary file.

Arguments:

    byRecordId [in, defaultvalue(NULL_BYTE)] Record number or ID of the first
        record to be read (00 indicates the current record).

    byRefCtrl [in] Coding of the reference control:

        Meaning     8 7 6 5 4 3 2 1
        Current EF  0 0 0 0 0 - - -
        Short EF ID x x x x x - - -
        RFU         1 1 1 1 1 - - -
        Record      - - - - - 1 x x
        Read Record - - - - - 1 0 0
        Up to Last  - - - - - 1 0 1
        Up to P1    - - - - - 1 1 0
        RFU         - - - - - 1 1 1
        Record ID   - - - - - 0 x x
        First Occur - - - - - 0 0 0
        Last Occur  - - - - - 0 0 1
        Next Occur  - - - - - 0 1 0
        Previous    - - - - - 0 1 1
        Secret      - - - x x x x x

        Current EF = Currently selected EF.

        Short EF ID = Short EF identifier.

        Record # = Usage of record number in P1.

        Read Record = Read record P1.

        Up to Last = Read all records from P1 up to the last.

        Up to P1 = Read all records from the last up to P1.

        Record ID = Usage of record ID in P1.

        First Occur = Read first occurrence.

        Last Occur = Read last occurrence.

        Next Occur = Read next occurrence.

        Previous = Read previous occurrence.

    lBytesToRead [in, defaultvalue(0)] Number of bytes to read from the
        transparent EF.  If the Le field contains only zeroes, then depending
        on b3b2b1 of P2 and within the limit of 256 for short length or 65536
        for extended length, the command should read completely either the
        single requested record or the requested sequence of records.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being read.

    If another elementary file is currently selected at the time of issuing
    this command, it may be processed without identification of the currently
    selected file.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a record structure cannot be read.  The
    encapsulated command aborts if applied to an elementary file without a
    record structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ReadRecord")

STDMETHODIMP
CSCardISO7816::ReadRecord(
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xb2,       // INS
                            byRecordId, // P1
                            byRefCtrl,  // P2
                            NULL,
                            &lBytesToRead);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::SelectFile:

    The SelectFile method constructs an APDU command that sets a current
    elementary file within a logical channel.  Subsequent commands may
    implicitly refer to the current file through the logical channel.

    Selecting a directory (DF) within the card filestore  which may be the
    root (MF) of the filestore  makes it the current DF.  After such a
    selection, an implicit current elementary file may be referred to through
    that logical channel.

    Selecting an elementary file sets the selected file and its parent as
    current files.

    After the answer to reset, the MF is implicitly selected through the basic
    logical channel, unless specified differently in the historical bytes or in
    the initial data string.

Arguments:

    byP1, byP2 [in] Selection control.

        P1 (upper byte in word):
            Meaning                 8 7 6 5 4 3 2 1
            Select File ID          0 0 0 0 0 0 x x
            EF, DF, or MF           0 0 0 0 0 0 0 0
            child DF                0 0 0 0 0 0 0 1
            EF under DF             0 0 0 0 0 0 1 0
            parent DF of current DF 0 0 0 0 0 0 1 1

            Select by DF Name       0 0 0 0 0 1 x x
            DFname                  0 0 0 0 0 1 0 0
            RFU                     0 0 0 0 0 1 0 1
            RFU                     0 0 0 0 0 1 1 0
            RFU                     0 0 0 0 0 1 1 1

            Select by path          0 0 0 0 1 0 x x
            from MF                 0 0 0 0 1 0 0 0
            current DF              0 0 0 0 1 0 0 1
            RFU                     0 0 0 0 1 0 1 0
            RFU                     0 0 0 0 1 0 1 1

            When P1=00, the card knows either because of a specific coding of
            the file ID or because of the context of execution of the command
            if the file to select is the MF, a DF, or an EF.

            When P1-P2=0000, if a file ID is provided, then it shall be unique
            in the following environments:

                the immediate children of the current DF
                the parent DF
                the immediate children of the parent DF

            If P1-P2=0000 and if the data field is empty or equal to 3F00, then
            select the MF.

            When P1=04, the data field is a DF name, possibly right truncated.

            When supported, successive such commands with the same data field
            shall select DFs whose names match with the data field (that is,
            start with the command data field).  If the card accepts the
            command with an empty data field, then all or a subset of the DFs
            can be successively selected.

        P2 (lower byte of word):
            Meaning         8 7 6 5 4 3 2 1
            First occur     0 0 0 0 - - 0 0
            Last occur      0 0 0 0 - - 0 1
            Next occur      0 0 0 0 - - 1 0
            Previous occur  0 0 0 0 - - 1 1

            File Control    0 0 0 0 x x - -
            Return FCI      0 0 0 0 0 0 - -
            Return FCP      0 0 0 0 0 1 - -
            Return FMD      0 0 0 0 1 0 - -

    pData [in, defaultvalue(NULL)] Data for operation if needed; else, NULL.
        Types of data that are passed in this parameter include:

        file ID
        path from the MF
        path from the current DF
        DF name

    lBytesToRead [in, defaultvalue(0)] Empty (that is, 0) or maximum length of
        data expected in response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    Unless otherwise specified, the correct execution of the encapsulated
    command modifies the security status according to the following rules:

    *   When the current elementary file is changed, or when there is no
        current elementary file, the security status specific to a former
        current elementary file is lost.

    *   When the current filestore directory (DF) is descendant of, or
        identical to the former current DF, the security status specific to the
        former current DF is lost.  The security status common to all common
        ancestors of the previous and new current DF is maintained.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::SelectFile")

STDMETHODIMP
CSCardISO7816::SelectFile(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xa4,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            0 == lBytesToRead ? NULL : &lBytesToRead);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::SetDefaultClassId:

    The SetDefaultClassId method assigns a standard class identifier byte that
    will be used in all operations when constructing an ISO 7816-4 command
    APDU.  By default, the standard class identifier byte is 0x00.

Arguments:

    byClass [in] Class ID byte.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::SetDefaultClassId")

STDMETHODIMP
CSCardISO7816::SetDefaultClassId(
    /* [in] */ BYTE byClass)
{
    m_bCla = byClass;
    return S_OK;
}


/*++

CSCardISO7816::UpdateBinary:

    The UpdateBinary method constructs an APDU command that updates the bits
    present in an elementary file with the bits given in the APDU command.

Arguments:

    byP1, byP2 [in] Offset to the write (update) location into the binary from
        the start of the binary.

        If b8=1 in P1, then b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1
        of P1 are a short EF identifier and P2 is the offset of the first byte
        to be updated in data units from the beginning of the file.

        If b8=0 in P1, then P1 || P2 is the offset of the first byte to be
        updated in data units from the beginning of the file.

    pData [in] Pointer to the string of data units to be updated.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a transparent structure cannot be erased.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::UpdateBinary")

STDMETHODIMP
CSCardISO7816::UpdateBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xd6,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::UpdateRecord:

    The UpdateRecord method constructs an APDU command that updates a specific
    record with the bits given in the APDU command.

    Note    When using current record addressing, the command sets the record
            pointer on the successfully updated record.

Arguments:

    byRecordId [in, defaultvalue(NULL_BYTE)] P1 value:

        P1 = 00 designates the current record
        P1 != '00' is the number of the specified record

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Coding of the reference control P2:

        Meaning         8 7 6 5 4 3 2 1
        Current EF      0 0 0 0 0 - - -
        Short EF ID     x x x x x - - -
        First Record    - - - - - 0 0 0
        Last Record     - - - - - 0 0 1
        Next Record     - - - - - 0 1 0
        Previous Record - - - - - 0 1 1
        Record # in P1  - - - - - 1 0 0

    pData [in] Pointer to the record to be updated.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.  If another elementary file is currently
    selected at the time of issuing this command, this command may be processed
    without identification of the currently selected file.

    If the constructed command applies to a linear-fixed or cyclic-structured
    elementary file, it will abort if the record length is different from the
    length of the existing record.

    If the command applies to a linear-variable structured elementary file, it
    may be carried out when the record length is different from the length of
    the existing record.

    The "previous" option of the command (P2=xxxxx011), applied to a cyclic
    file, has the same behavior as a command constructed by AppendRecord.

    Elementary files without a record structure cannot be read.  The
    constructed command aborts if applied to an elementary file without record
    structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::UpdateRecord")

STDMETHODIMP
CSCardISO7816::UpdateRecord(
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xdc,       // INS
                            byRecordId, // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::Verify:

    The Verify method constructs an APDU command that initiates the comparison
    (in the card) of the verification data sent from the interface device with
    the reference data stored in the card (for example, password).

Arguments:

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Quantifier of the reference data;
        coding of the reference control P2:

        Meaning         8 7 6 5 4 3 2 1
        No Info         0 0 0 0 0 0 0 0
        Global Ref      0 - - - - - - -
        Specific Ref    1 - - - - - - -
        RFU             - x x - - - - -
        Ref Data #      - - - x x x x x

        An example of Global Ref would be a password.

        An example of Specific Ref is DF specific password.

        P2=00 is reserved to indicate that no particular qualifier is used in
        those cards where the verify command references the secret data
        unambiguously.

        The reference data number may be for example a password number or a
        short EF identifier.

        When the body is empty, the command may be used either to retrieve the
        number 'X' of further allowed retries (SW1-SW2=63CX) or to check
        whether the verification is not required (SW1-SW2=9000).

    pData [in, defaultvalue(NULL)] Pointer to the verification data, or can be
        NULL.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation. If ppCmd was set to NULL, a smart card ISCardCmd object
        is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The security status may be modified as a result of a comparison.
    Unsuccessful comparisons may be recorded in the card (for example, to limit
    the number of further attempts of the use of the reference data).

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::Verify")

STDMETHODIMP
CSCardISO7816::Verify(
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0x20,       // INS
                            0x00,       // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::WriteBinary:

    The WriteBinary method constructs an APDU command that writes binary values
    into an elementary file.

    Depending upon the file attributes, the command performs one of the
    following operations:

    *   The logical OR of the bits already present in the card with the bits
        given in the command APDU (logical erased state of the bits of the file
        is 0).

    *   The logical AND of the bits already present in the card with the bits
        given in the command APDU (logical erased state of the bits of the file
        is 1).

    *   The one-time write in the card of the bits given in the command APDU.

    When no indication is given in the data coding byte, the logical OR
    behavior applies.

Arguments:

    byP1, byP2 [in] Offset to the write location from the beginning of the
        binary file (EF).

        If b8=1 in P1, then b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1
        of P1 are a short EF identifier and P2 is the offset of the first byte
        to be written in data units from the beginning of the file.

        If b8=0 in P1, then P1||P2 is the offset of the first byte to be
        written in data units from the beginning of the file.

    pData [in] Pointer to the string of data units to be written.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Once a write binary operation has been applied to a data unit of a one-time
    write EF, any further write operation referring to this data unit will be
    aborted if the content of the data unit or the logical erased state
    indicator (if any) attached to this data unit is different from the logical
    erased state.

    Elementary files without a transparent structure cannot be written to.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::WriteBinary")

STDMETHODIMP
CSCardISO7816::WriteBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xd0,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::WriteRecord:

    The WriteRecord method constructs an APDU command that initiates one of the
    following operations:

    *   The write once of a record.

    *   The logical OR of the data bytes of a record already present in the
        card with the data bytes of the record given in the command APDU.

    *   The logical AND of the data bytes of a record already present in the
        card with the data bytes of the record given in the command APDU.

    When no indication is given in the data coding byte, the logical OR behavior applies.

    Note:  When using current record addressing, the command sets the record
    pointer on the successfully updated record.

Arguments:

    byRecordId [in, defaultvalue(NULL_BYTE)] Record identification. This is the
        P1 value:

        P1 = '00' designates the current record.

        P1 != '00' is the number of the specified record.

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Coding of the reference control P2:

        Meaning         8 7 6 5 4 3 2 1
        Current EF      0 0 0 0 0 - - -
        Short EF ID     x x x x x - - -
        First Record    - - - - - 0 0 0
        Last Record     - - - - - 0 0 1
        Next Record     - - - - - 0 1 0
        Previous Record - - - - - 0 1 1
        Record # in P1  - - - - - 1 0 0

    pData [in] Pointer to the record to be written.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.  If another elementary file is currently
    selected at the time of issuing this command, this command may be processed
    without identification of the currently selected file.

    If the encapsulated command applies to a linear-fixed or cyclic-structured
    elementary file, it will abort if the record length is different from the
    length of the existing record.  If it applies to a linear-variable
    structured elementary file, it may be carried out when the record length is
    different from the length of the existing record.

    If P2=xxxxx011 and the elementary file is cyclic file, this command has the
    same behavior a command constructed using AppendRecord.

    Elementary files without a record structure cannot be written to.  The
    constructed command aborts if applied to an elementary file without a
    record structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::WriteRecord")

STDMETHODIMP
CSCardISO7816::WriteRecord(
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xd2,       // INS
                            byRecordId, // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\locate.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Locate

Abstract:

    The ISCardeLocate interface provides services for locating a smart card by
    its name.

    This interface can display the smart card user interface if it is required.

    The following example shows a typical use of the ISCardLocate interface.
    The ISCardLocate interface is used to build the an ADPU.

    To locate a specific card using its name

    1)  Create an ISCardLocate interface.
    2)  Call ConfigureCardNameSearch to search for a smart card name.
    3)  Call FindCard to search for the smart card.
    4)  Interpret the results.
    5)  Release the ISCardLocate interface.

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "Conversion.h"
#include "Locate.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardLocate

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardLocate::ConfigureCardGuidSearch")

STDMETHODIMP
CSCardLocate::ConfigureCardGuidSearch(
    /* [in] */ LPSAFEARRAY pCardGuids,
    /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ LONG lFlags)
{
    HRESULT hReturn = S_OK;

    try
    {
        // TODO: Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardLocate::ConfigureCardNameSearch:

    The ConfigureCardNameSearch method specifies the card names to be used in
    the search for the smart card.

Arguments:

    pCardNames [in] Pointer to an OLE Automation safe array of card names in
        BSTR form.

    pGroupNames [in, defaultvalue(NULL )] Pointer to an OLE Automation safe
        array of names of card/reader groups in BSTR form to add to the search.

    bstrTitle [in, defaultvalue("")] Search common control dialog title.

    lFlags [in, defaultvalue(1)] Specifies when user interface is displayed:

    Flag                Meaning
    SC_DLG_MINIMAL_UI   Displays the dialog only if the card being searched for
                        by the calling application is not located and available
                        for use in a reader.  This allows the card to be found,
                        connected (either through internal dialog mechanism or
                        the user callback functions), and returned to the
                        calling application.
    SC_DLG_NO_UI        Causes no UI display, regardless of the search outcome.
    SC_DLG_FORCE_UI     Causes UI display regardless of the search outcome.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardLocate::ConfigureCardNameSearch")

STDMETHODIMP
CSCardLocate::ConfigureCardNameSearch(
    /* [in] */ LPSAFEARRAY pCardNames,
    /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ LONG lFlags)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (NULL != pCardNames)
            SafeArrayToMultiString(pCardNames, m_mtzCardNames);
        if (NULL != pGroupNames)
            SafeArrayToMultiString(pGroupNames, m_mtzGroupNames);
        if (NULL != bstrTitle)
            m_tzTitle = bstrTitle;
        m_lFlags = lFlags;
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardLocate::FindCard:

    The FindCard method searches for the smart card and opens a valid
    connection to it.

Arguments:

    ShareMode [in, defaultvalue(EXCLUSIVE)] Mode in which to share or not share
        the smart card when a connection is opened to it.

        Values      Description
        EXCLUSIVE   No one else use this connection to the smart card.
        SHARED      Other applications can use this connection.

    Protocols [in, defaultvalue(T0)] Protocol to use when connecting to the
        card.

        T0
        T1
        Raw
        T0|T1

    lFlags [in, defaultvalue(SC_DLG_NO_UI)] Specifies when user interface is
        displayed:

        Flag                Meaning
        SC_DLG_MINIMAL_UI   Displays the dialog only if the card being searched
                            for by the calling application is not located and
                            available for use in a reader.  This allows the
                            card to be found, connected (either through
                            internal dialog mechanism or the user callback
                            functions), and returned to the calling
                            application.
        SC_DLG_NO_UI        Causes no UI display, regardless of the search
                            outcome.
        SC_DLG_FORCE_UI     Causes UI display regardless of the search outcome.

    ppCardInfo [out, retval] Pointer to a data structure that contains/returns
        information about the opened smart card, if successful.  Will be NULL
        if operation has failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To set the search criteria of the search, call ConfigureCardNameSearch to
    specify a smart card's card names or call ConfigureCardGuidSearch to
    specify a smart card's interfaces.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardLocate::FindCard")

STDMETHODIMP
CSCardLocate::FindCard(
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_PROTOCOLS Protocols,
    /* [defaultvalue][in] */ LONG lFlags,
    /* [retval][out] */ LPSCARDINFO __RPC_FAR *ppCardInfo)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;
        OPENCARDNAME cardInfo;

        ZeroMemory(&cardInfo, sizeof(cardInfo));
        cardInfo.dwShareMode = ShareMode;
        cardInfo.dwPreferredProtocols = Protocols;
        cardInfo.dwFlags = lFlags | m_lFlags;

        if ((NULL != ppCardInfo) && (NULL != *ppCardInfo))
        {
            if (NULL != (*ppCardInfo)->hContext)
                cardInfo.hSCardContext = (*ppCardInfo)->hContext;
            cardInfo.dwPreferredProtocols = (*ppCardInfo)->ActiveProtocol;
            cardInfo.dwShareMode = (*ppCardInfo)->ShareMode;
            cardInfo.hwndOwner = (HWND)(*ppCardInfo)->hwndOwner;
            cardInfo.lpfnConnect = (LPOCNCONNPROC)(*ppCardInfo)->lpfnConnectProc;
            cardInfo.lpfnCheck = (LPOCNCHKPROC)(*ppCardInfo)->lpfnCheckProc;
            cardInfo.lpfnDisconnect = (LPOCNDSCPROC)(*ppCardInfo)->lpfnDisconnectProc;
        }

        if (0 == cardInfo.dwPreferredProtocols)
            cardInfo.dwPreferredProtocols = SCARD_PROTOCOL_Tx;
        if (0 == cardInfo.dwShareMode)
            cardInfo.dwShareMode = SCARD_SHARE_EXCLUSIVE;

        cardInfo.dwStructSize = sizeof(OPENCARDNAME);
        cardInfo.lpstrGroupNames = (LPTSTR)((LPCTSTR)m_mtzGroupNames);
        cardInfo.nMaxGroupNames = m_mtzGroupNames.Length();
        cardInfo.lpstrCardNames = (LPTSTR)((LPCTSTR)m_mtzCardNames);
        cardInfo.nMaxCardNames = m_mtzCardNames.Length();
        cardInfo.rgguidInterfaces = (LPCGUID)m_bfInterfaces.Access();
        cardInfo.cguidInterfaces = m_bfInterfaces.Length();
        cardInfo.lpstrRdr = (LPTSTR)m_bfRdr.Access();
        cardInfo.nMaxRdr = m_bfRdr.Space() / sizeof(TCHAR);
        cardInfo.lpstrCard = (LPTSTR)m_bfCard.Access();
        cardInfo.nMaxCard = m_bfCard.Space() / sizeof(TCHAR);
        cardInfo.lpstrTitle = (LPCTSTR)m_tzTitle;

        lSts = GetOpenCardName(&cardInfo);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);

        m_bfRdr.Resize(cardInfo.nMaxRdr * sizeof(TCHAR), TRUE);
        m_bfCard.Resize(cardInfo.nMaxCard * sizeof(TCHAR), TRUE);

        if (NULL != ppCardInfo)
        {
            if (NULL == *ppCardInfo)
            {
                *ppCardInfo = &m_subCardInfo;
                (*ppCardInfo)->ShareMode = (SCARD_SHARE_MODES)cardInfo.dwShareMode;
            }

            if (NULL == cardInfo.hCardHandle)
            {
                lSts = SCardConnect(
                            cardInfo.hSCardContext,
                            cardInfo.lpstrRdr,
                            cardInfo.dwShareMode,
                            cardInfo.dwPreferredProtocols,
                            &cardInfo.hCardHandle,
                            &cardInfo.dwActiveProtocol);
                if (SCARD_S_SUCCESS != lSts)
                    throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            }
            (*ppCardInfo)->hCard = cardInfo.hCardHandle;
            (*ppCardInfo)->hContext = cardInfo.hSCardContext;
            (*ppCardInfo)->ActiveProtocol = (SCARD_PROTOCOLS)cardInfo.dwActiveProtocol;
        }
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\locate.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       Locate.h
//
//--------------------------------------------------------------------------

// Locate.h : Declaration of the CSCardLocate

#ifndef __SCARDLOCATE_H_
#define __SCARDLOCATE_H_

#include <winscard.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardLocate
class ATL_NO_VTABLE CSCardLocate :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardLocate, &CLSID_CSCardLocate>,
    public IDispatchImpl<ISCardLocate, &IID_ISCardLocate, &LIBID_SCARDSSPLib>
{
public:
    CSCardLocate()
    :   m_mtzGroupNames(),
        m_mtzCardNames(),
        m_bfInterfaces(),
        m_bfRdr(MAX_PATH),
        m_bfCard(MAX_PATH),
        m_tzTitle()
    {
        m_pUnkMarshaler = NULL;
        m_lFlags = 0;
        ZeroMemory(&m_subCardInfo, sizeof(SCARDINFO));
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDLOCATE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardLocate)
    COM_INTERFACE_ENTRY(ISCardLocate)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    SCARDINFO m_subCardInfo;
    CTextMultistring m_mtzGroupNames;
    CTextMultistring m_mtzCardNames;
    CBuffer m_bfInterfaces;
    CBuffer m_bfRdr;
    CBuffer m_bfCard;
    CTextString m_tzTitle;
    LONG m_lFlags;

// ISCardLocate
public:
    STDMETHOD(ConfigureCardGuidSearch)(
        /* [in] */ LPSAFEARRAY pCardGuids,
        /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames = 0,
        /* [defaultvalue][in] */ BSTR bstrTitle = L"",
        /* [defaultvalue][in] */ LONG lFlags = 1);

    STDMETHOD(ConfigureCardNameSearch)(
        /* [in] */ LPSAFEARRAY pCardNames,
        /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames = 0,
        /* [defaultvalue][in] */ BSTR bstrTitle = L"",
        /* [defaultvalue][in] */ LONG lFlags = 1);

    STDMETHOD(FindCard)(
        /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
        /* [defaultvalue][in] */ SCARD_PROTOCOLS Protocols,
        /* [defaultvalue][in] */ LONG lFlags,
        /* [retval][out] */ LPSCARDINFO __RPC_FAR *ppCardInfo);
};

inline LPSCARDLOCATE
NewSCardLocate(
    void)
{
    return (LPSCARDLOCATE)NewObject(CLSID_CSCardLocate, IID_ISCardLocate);
}


#endif //__SCARDLOCATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\scard.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    SCard

Abstract:

    The ISCard interface lets you open and manage a connection to a smart card.
    Each connection to a card requires a single, corresponding instance of the
    ISCard interface.

    The smart card resource manager must be available whenever an instance of
    ISCard is created.  If this service is unavailable, creation of the
    interface will fail.

    The following example shows a typical use of the ISCard interface.  The
    ISCard interface is used to connect to the smart card, submit a
    transaction, and release the smart card.

    To submit a transaction to a specific card

    1)  Create an ISCard interface.
    2)  Attach to a smart card by specifying a smart card reader or by using a
        previously established, valid handle.
    3)  Create transaction commands with ISCardCmd, and ISCardISO7816 smart
        card interfaces.
    4)  Use ISCard to submit the transaction commands for processing by the
        smart card.
    5)  Use ISCard to release the smart card.
    6)  Release the ISCard interface.

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "ByteBuffer.h"
#include "SCard.h"
#include "Conversion.h"

/////////////////////////////////////////////////////////////////////////////
// CSCard

/*++

CSCard::get_Atr:

    The get_Atr method retrieves an ATR string of the smart card.

Arguments:

    ppAtr [out, retval] Pointer to a byte buffer in the form of an IStream that
        will contain the ATR string on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Atr")

STDMETHODIMP
CSCard::get_Atr(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppAtr)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;

    try
    {
        CBuffer bfAtr(36);
        LONG lSts;
        DWORD dwLen = 0;

        if (NULL == *ppAtr)
        {
            *ppAtr = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        if (NULL != m_hCard)
        {
            dwLen = bfAtr.Space();
            lSts = SCardStatus(
                m_hCard,
                NULL, 0, // Reader name
                NULL,    // State
                NULL,    // Protocol
                bfAtr.Access(),
                &dwLen);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            bfAtr.Resize(dwLen);
        }
        BufferToByteBuffer(bfAtr, ppAtr);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppAtr = NULL;
    }
    return hReturn;
}


/*++

CSCard::get_CardHandle:

    The get_CardHandle method retrieves the handle for a connected smart card.
    Returns (*pHandle) == NULL if not connected.

Arguments:

    pHandle [out, retval] Pointer to the card handle on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_CardHandle")

STDMETHODIMP
CSCard::get_CardHandle(
    /* [retval][out] */ HSCARD __RPC_FAR *pHandle)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pHandle = m_hCard;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::get_Context:

    The get_Context method retrieves the current resource manager context
    handle. Returns (*pContext) == NULL if no context has been established.

Arguments:

    pContext [out, retval] Pointer to the context handle on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The resource manager context is set by calling the smart card function
    SCardEstablishContext.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Context")

STDMETHODIMP
CSCard::get_Context(
    /* [retval][out] */ HSCARDCONTEXT __RPC_FAR *pContext)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pContext = Context();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::get_Protocol:

    The get_Protocol retrieves the identifier of the protocol currently in use
    on the smart card.

Arguments:

    pProtocol [out, retval] Pointer to the protocol identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Protocol")

STDMETHODIMP
CSCard::get_Protocol(
    /* [retval][out] */ SCARD_PROTOCOLS __RPC_FAR *pProtocol)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        if (NULL != m_hCard)
        {
            lSts = SCardStatus(
                        m_hCard,
                        NULL, 0,            // Reader name
                        NULL,               // State
                        (LPDWORD)pProtocol, // Protocol
                        NULL, 0);           // ATR
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        }
        else
            *pProtocol = (SCARD_PROTOCOLS)SCARD_PROTOCOL_UNDEFINED;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::get_Status:

    The get_Status method retrieves the current state of the smart card.

Arguments:

    pStatus [out, retval] Pointer to the state variable.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Status")

STDMETHODIMP
CSCard::get_Status(
    /* [retval][out] */ SCARD_STATES __RPC_FAR *pStatus)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        if (NULL != m_hCard)
        {
            lSts = SCardStatus(
                m_hCard,
                NULL, 0,            // Reader name
                (LPDWORD)pStatus,   // State
                NULL,               // Protocol
                NULL, 0);           // ATR
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        }
        else
            *pStatus = (SCARD_STATES)SCARD_UNKNOWN;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::AttachByHandle:

    The AttachByHandle method attaches this object to an open and configured
    smart card handle.

Arguments:

    hCard [in] Handle to an open connection to a smart card.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::AttachByHandle")

STDMETHODIMP
CSCard::AttachByHandle(
    /* [in] */ HSCARD hCard)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        if (NULL != m_hMyCard)
        {
            lSts = SCardDisconnect(m_hMyCard, SCARD_RESET_CARD);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            m_hMyCard = NULL;
        }
        m_dwProtocol = 0;
        m_hCard = hCard;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::AttachByReader:

    The AttachByReader method opens the smart card in the named reader.

Arguments:

    bstrReaderName [in] Pointer to the name of the smart card reader.

    ShareMode [in, defaultvalue(EXCLUSIVE)] Mode in which to claim access to
        the smart card.

        Values      Description
        EXCLUSIVE   No one else use this connection to the smart card.
        SHARED      Other applications can use this connection.

    PrefProtocol [in, defaultvalue(T0)] Preferred protocol values:

        T0
        T1
        Raw
        T0|T1

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::AttachByReader")

STDMETHODIMP
CSCard::AttachByReader(
    /* [in] */ BSTR bstrReaderName,
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_PROTOCOLS PrefProtocol)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;
        DWORD dwProto;
        CTextString tzReader;

        tzReader = bstrReaderName;
        if (NULL != m_hMyCard)
        {
            lSts = SCardDisconnect(m_hMyCard, SCARD_RESET_CARD);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            m_hMyCard = NULL;
        }
        m_dwProtocol = 0;

        lSts = SCardConnect(
                    Context(),
                    tzReader,
                    (DWORD)ShareMode,
                    (DWORD)PrefProtocol,
                    &m_hMyCard,
                    &dwProto);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        m_hCard = m_hMyCard;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::Detach:

    The Detach method closes the open connection to the smart card.

Arguments:

    Disposition [in, defaultvalue(LEAVE)] Indicates what should be done with
        the card in the connected reader.

        Values  Description
        LEAVE   Leaves the smart card in the current state.
        RESET   Resets the smart card to some known state.
        UNPOWER Removes power from the smart card.
        EJECT   Ejects the smart card if the reader has eject capabilities.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::Detach")

STDMETHODIMP
CSCard::Detach(
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        m_dwProtocol = 0;
        lSts = SCardDisconnect(m_hCard, (DWORD)Disposition);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        m_hCard = m_hMyCard = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::LockSCard:

    The LockSCard method claims exclusive access to the smart card.

Arguments:

    None

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::LockSCard")

STDMETHODIMP
CSCard::LockSCard(
    void)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        lSts = SCardBeginTransaction(m_hCard);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::ReAttach:

    The ReAttach method resets, or reinitializes, the smart card.

Arguments:

    ShareMode [in, defaultvalue(EXCLUSIVE)] Mode in which to share or
        exclusively own the connection to the smart card.

        Values      Description
        EXCLUSIVE   No one else use this connection to the smart card.
        SHARED      Other applications can use this connection.

    InitState [in, defaultvalue(LEAVE)] Indicates what to do with the card.

        Values  Description
        LEAVE   Leaves the smart card in the current state.
        RESET   Resets the smart card to some known state.
        UNPOWER Removes power from the smart card.
        EJECT   Ejects the smart card if the reader has eject capabilities.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::ReAttach")

STDMETHODIMP
CSCard::ReAttach(
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS InitState)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwProto;
        LONG lSts;

        m_dwProtocol = 0;
        lSts = SCardReconnect(
                    m_hCard,
                    (DWORD)ShareMode,
                    SCARD_PROTOCOL_Tx,
                    (DWORD)InitState,
                    &dwProto);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::Transaction:

    The Transaction method executes a write and read operation on the smart
    card command (APDU) object.  The reply string from the smart card for the
    command string defined in the card that was sent to the smart card will be
    accessible after this function returns.

Arguments:

    ppCmd [in, out] Pointer to the smart card command object.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::Transaction")

STDMETHODIMP
CSCard::Transaction(
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pbyApdu = NewByteBuffer();

    try
    {
        HRESULT hr;
        LONG lSts;
        DWORD dwFlags = 0;
        CBuffer bfResponse, bfPciRqst, bfPciRsp, bfApdu;


        //
        // Get the protocol.
        //

        if (0 == m_dwProtocol)
        {
            lSts = SCardStatus(
                m_hCard,
                NULL, 0,            // Reader name
                NULL,               // State
                &m_dwProtocol,      // Protocol
                NULL, 0);           // ATR
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        }
        ASSERT(0 != m_dwProtocol);


        //
        // Get The APDU
        //

        if (NULL == pbyApdu)
            throw (HRESULT)E_OUTOFMEMORY;
        hr = (*ppCmd)->get_Apdu((LPBYTEBUFFER *)&pbyApdu);
        if (FAILED(hr))
            throw hr;
        ByteBufferToBuffer(pbyApdu, bfApdu);


        //
        // Convert it to a TPDU.
        //

        switch (m_dwProtocol)
        {
        case SCARD_PROTOCOL_T0:
        {
            BYTE bAltCla;
            LPBYTE pbAltCla = NULL;

            if (SUCCEEDED((*ppCmd)->get_AlternateClassId(&bAltCla)))
                pbAltCla = &bAltCla;

            ApduToTpdu_T0(
                m_hCard,
                SCARD_PCI_T0,
                bfApdu.Access(),
                bfApdu.Length(),
                dwFlags,
                bfPciRsp,
                bfResponse,
                pbAltCla);
            break;
        }

        case SCARD_PROTOCOL_T1:
        {
            BYTE bNad;
            LPBYTE pbCur, pbEnd;
            DWORD dwI;

            bfPciRqst.Set((LPBYTE)SCARD_PCI_T1, sizeof(SCARD_IO_REQUEST));
            if (SUCCEEDED((*ppCmd)->get_Nad(&bNad)))
            {
                bfPciRqst.Presize(bfPciRqst.Length() + sizeof(DWORD), TRUE);
                bfPciRqst.Append((LPBYTE)"\0x81\0x01", 2);
                bfPciRqst.Append(&bNad, 1);
            }
            dwI = 0;
            bfPciRqst.Append(
                (LPBYTE)&dwI,
                bfPciRqst.Length() % sizeof(DWORD));
            ((LPSCARD_IO_REQUEST)bfPciRqst.Access())->cbPciLength = bfPciRqst.Length();

            ApduToTpdu_T1(
                m_hCard,
                (LPSCARD_IO_REQUEST)bfPciRqst.Access(),
                bfApdu.Access(),
                bfApdu.Length(),
                dwFlags,
                bfPciRsp,
                bfResponse);

            pbEnd = bfPciRsp.Access();
            pbCur = pbEnd + sizeof(SCARD_PCI_T1);
            pbEnd += bfPciRsp.Length();
            while (pbCur < pbEnd)
            {
                switch (*pbCur++)
                {
                case 0x00:
                    break;
                case 0x81:
                    bNad = *(++pbCur);
                    hr = (*ppCmd)->put_ReplyNad(bNad);
                    break;
                default:
                    pbCur += *pbCur + 1;
                }
            }
            break;
        }
        default:
            throw (HRESULT)SCARD_E_CARD_UNSUPPORTED;
        }


        //
        // Write the response back to the ISCardCommand object.
        //

        BufferToByteBuffer(bfResponse, (LPBYTEBUFFER *)&pbyApdu);
        hr = (*ppCmd)->put_ApduReply(pbyApdu);
        if (FAILED(hr))
            throw hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pbyApdu)
        pbyApdu->Release();
    return hReturn;
}


/*++

CSCard::UnlockSCard:

    The UnlockSCard method releases exclusive access to the smart card.

Arguments:

    Disposition [in, defaultvalue(LEAVE)] Indicates what should be done with
        the card in the connected reader.

        Values  Description
        LEAVE   Leaves the smart card in the current state.
        RESET   Resets the smart card to some known state.
        UNPOWER Removes power from the smart card.
        EJECT   Ejects the smart card if the reader has eject capabilities.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::UnlockSCard")

STDMETHODIMP
CSCard::UnlockSCard(
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        lSts = SCardEndTransaction(m_hCard, (DWORD)Disposition);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\scard.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       SCard.h
//
//--------------------------------------------------------------------------

// SCard.h : Declaration of the CSCard

#ifndef __SCARD_H_
#define __SCARD_H_

#include "resource.h"       // main symbols
#include <winscard.h>

/////////////////////////////////////////////////////////////////////////////
// CSCard
class ATL_NO_VTABLE CSCard :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCard, &CLSID_CSCard>,
    public IDispatchImpl<ISCard, &IID_ISCard, &LIBID_SCARDSSPLib>
{
public:
    CSCard()
    {
        m_pUnkMarshaler = NULL;
        m_hContext = NULL;
        m_hMyContext = NULL;
        m_hCard = NULL;
        m_hMyCard = NULL;
        m_dwProtocol = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARD)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCard)
    COM_INTERFACE_ENTRY(ISCard)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        if (NULL != m_hMyCard)
            SCardDisconnect(m_hMyCard, SCARD_RESET_CARD);
        if (NULL != m_hMyContext)
            SCardReleaseContext(m_hMyContext);
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    SCARDCONTEXT m_hContext;
    SCARDCONTEXT m_hMyContext;
    SCARDHANDLE m_hCard;
    SCARDHANDLE m_hMyCard;
    DWORD m_dwProtocol;

    SCARDCONTEXT Context(void)
    {
        LONG lSts;

        if (NULL == m_hContext)
        {
            ASSERT(NULL == m_hMyContext);
            lSts = SCardEstablishContext(
                        SCARD_SCOPE_USER,
                        NULL,
                        NULL,
                        &m_hMyContext);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            m_hContext = m_hMyContext;
        }
        return m_hContext;
    }


// ISCard
public:
    STDMETHOD(get_Atr)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppAtr);

    STDMETHOD(get_CardHandle)(
        /* [retval][out] */ HSCARD __RPC_FAR *pHandle);

    STDMETHOD(get_Context)(
        /* [retval][out] */ HSCARDCONTEXT __RPC_FAR *pContext);

    STDMETHOD(get_Protocol)(
        /* [retval][out] */ SCARD_PROTOCOLS __RPC_FAR *pProtocol);

    STDMETHOD(get_Status)(
        /* [retval][out] */ SCARD_STATES __RPC_FAR *pStatus);

    STDMETHOD(AttachByHandle)(
        /* [in] */ HSCARD hCard);

    STDMETHOD(AttachByReader)(
        /* [in] */ BSTR bstrReaderName,
        /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode = EXCLUSIVE,
        /* [defaultvalue][in] */ SCARD_PROTOCOLS PrefProtocol = T0);

    STDMETHOD(Detach)(
        /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition = LEAVE);

    STDMETHOD(LockSCard)(
            void);

    STDMETHOD(ReAttach)(
        /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode = EXCLUSIVE,
        /* [defaultvalue][in] */ SCARD_DISPOSITIONS InitState = LEAVE);

    STDMETHOD(Transaction)(
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(UnlockSCard)(
        /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition = LEAVE);
};

inline CSCard *
NewSCard(
    void)
{
    return (CSCard *)NewObject(CLSID_CSCard, IID_ISCard);
}

#endif //__SCARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\scardcmd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       SCardCmd.h
//
//--------------------------------------------------------------------------

// SCardCmd.h : Declaration of the CSCardCmd

#ifndef __SCARDCMD_H_
#define __SCARDCMD_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardCmd
class ATL_NO_VTABLE CSCardCmd :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardCmd, &CLSID_CSCardCmd>,
    public IDispatchImpl<ISCardCmd, &IID_ISCardCmd, &LIBID_SCARDSSPLib>
{
public:
    CSCardCmd()
    :   m_bfRequestData(),
        m_bfResponseApdu()
    {
        m_pUnkMarshaler = NULL;
        m_bCla = 0;
        m_bIns = 0;
        m_bP1 = 0;
        m_bP2 = 0;
        m_wLe = 0;
        m_dwFlags = 0;
        m_bRequestNad = 0;
        m_bResponseNad = 0;
        m_bAltCla = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDCMD)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardCmd)
    COM_INTERFACE_ENTRY(ISCardCmd)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    BYTE m_bCla;
    BYTE m_bIns;
    BYTE m_bP1;
    BYTE m_bP2;
    CBuffer m_bfRequestData;
    CBuffer m_bfResponseApdu;
    WORD m_wLe;
    DWORD m_dwFlags;
    BYTE m_bRequestNad;
    BYTE m_bResponseNad;
    BYTE m_bAltCla;

// ISCardCmd
public:
    STDMETHOD(get_Apdu)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppApdu);

    STDMETHOD(put_Apdu)(
        /* [in] */ LPBYTEBUFFER pApdu);

    STDMETHOD(get_ApduLength)(
        /* [retval][out] */ LONG __RPC_FAR *plSize);

    STDMETHOD(get_ApduReply)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppReplyApdu);

    STDMETHOD(put_ApduReply)(
        /* [in] */ LPBYTEBUFFER pReplyApdu);

    STDMETHOD(get_ApduReplyLength)(
        /* [retval][out] */ LONG __RPC_FAR *plSize);

    STDMETHOD(put_ApduReplyLength)(
        /* [in] */ LONG lSize);

    STDMETHOD(get_ClassId)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyClass);

    STDMETHOD(put_ClassId)(
        /* [defaultvalue][in] */ BYTE byClass = 0);

    STDMETHOD(get_Data)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppData);

    STDMETHOD(put_Data)(
        /* [in] */ LPBYTEBUFFER pData);

    STDMETHOD(get_InstructionId)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyIns);

    STDMETHOD(put_InstructionId)(
        /* [in] */ BYTE byIns);

    STDMETHOD(get_LeField)(
        /* [retval][out] */ LONG __RPC_FAR *plSize);

    STDMETHOD(get_P1)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyP1);

    STDMETHOD(put_P1)(
        /* [in] */ BYTE byP1);

    STDMETHOD(get_P2)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyP2);

    STDMETHOD(put_P2)(
        /* [in] */ BYTE byP2);

    STDMETHOD(get_P3)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyP3);

    STDMETHOD(get_ReplyStatus)(
        /* [retval][out] */ LPWORD pwStatus);

    STDMETHOD(put_ReplyStatus)(
        /* [in] */ WORD wStatus);

    STDMETHOD(get_ReplyStatusSW1)(
        /* [retval][out] */ BYTE __RPC_FAR *pbySW1);

    STDMETHOD(get_ReplyStatusSW2)(
        /* [retval][out] */ BYTE __RPC_FAR *pbySW2);

    STDMETHOD(get_Type)(
        /* [retval][out] */ ISO_APDU_TYPE __RPC_FAR *pType);

    STDMETHOD(get_Nad)(
        /* [retval][out] */ BYTE __RPC_FAR *pbNad);

    STDMETHOD(put_Nad)(
        /* [in] */ BYTE bNad);

    STDMETHOD(get_ReplyNad)(
        /* [retval][out] */ BYTE __RPC_FAR *pbNad);

    STDMETHOD(put_ReplyNad)(
        /* [in] */ BYTE bNad);

    STDMETHOD(BuildCmd)(
        /* [in] */ BYTE byClassId,
        /* [in] */ BYTE byInsId,
        /* [defaultvalue][in] */ BYTE byP1 = 0,
        /* [defaultvalue][in] */ BYTE byP2 = 0,
        /* [defaultvalue][in] */ LPBYTEBUFFER pbyData = 0,
        /* [defaultvalue][in] */ LONG __RPC_FAR *plLe = 0);

    STDMETHOD(Clear)(
        void);

    STDMETHOD(Encapsulate)(
        /* [in] */ LPBYTEBUFFER pApdu,
        /* [in] */ ISO_APDU_TYPE ApduType);

    STDMETHOD(get_AlternateClassId)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyClass);

    STDMETHOD(put_AlternateClassId)(
        /* [in] */ BYTE byClass = 0);
};

inline CSCardCmd *
NewSCardCmd(
    void)
{
    return (CSCardCmd *)NewObject(CLSID_CSCardCmd, IID_ISCardCmd);
}

#endif //__SCARDCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\scardcmd.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    SCardCmd

Abstract:

    The ISCardCmd interface provides the methods needed to construct and manage
    a smart card Application Protocol Data Unit (APDU ).  This interface
    encapsulates two buffers:

    The APDU buffer contains the command sequence that will be sent to the
    card.

    The APDUReply buffer contains data returned from the card after execution
    of the APDU command (this data is also referred to as the return ADPU).

    The following example shows a typical use of the ISCardCmd interface.  The
    ISCardCmd interface is used to build the an ADPU.

    To submit a transaction to a specific card

    1)  Create an ISCard interface and connect to a smart card.
    2)  Create an ISCardCmd interface.
    3)  Build a smart card APDU command using the ISCardISO7816 interface or
        one of ISCardCmd's build methods).
    4)  Execute the command on the smart card by calling the appropriate ISCard
        interface method.
    5)  Evaluate the returned response.
    6)  Repeat the procedure as needed.
    7)  Release the ISCardCmd interface and others as needed.

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "scardssp.h"
#include "ByteBuffer.h"
#include "SCardCmd.h"
#include "Conversion.h"


/////////////////////////////////////////////////////////////////////////////
// CSCardCmd

/*++

CSCardCmd::get_Apdu:

    The get_Apdu method retrieves the raw APDU.

Arguments:

    ppApdu [out, retval] Pointer to the byte buffer mapped through an IStream
        that contains the APDU message on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To copy the APDU from an IByteBuffer (IStream) object into the APDU
    wrapped in this interface object, call put_Apdu.

    To determine the length of the APDU, call get_ApduLength.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_Apdu")

STDMETHODIMP
CSCardCmd::get_Apdu(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppApdu)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;

    try
    {
        CBuffer bfApdu(m_bfRequestData.Length() + 4 + 3 + 3);

        if (NULL == *ppApdu)
        {
            *ppApdu = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        ConstructRequest(
            m_bCla,
            m_bIns,
            m_bP1,
            m_bP2,
            m_bfRequestData,
            m_wLe,
            m_dwFlags,
            bfApdu);
        BufferToByteBuffer(bfApdu, ppApdu);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppApdu = NULL;
    }
    return hReturn;
}


/*++

CSCardCmd::put_Apdu:

    The put_Apdu method copies the APDU from the IByteBuffer (IStream) object
    into the APDU wrapped in this interface object.

Arguments:

    pApdu [in] Pointer to the ISO 7816-4 APDU to be copied in.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve the raw APDU from the byte buffer mapped through an IStream
    that contains the APDU message, call get_Apdu.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_Apdu")

STDMETHODIMP
CSCardCmd::put_Apdu(
    /* [in] */ LPBYTEBUFFER pApdu)
{
    HRESULT hReturn = S_OK;

    try
    {
        CBuffer bfApdu;
        LPCBYTE pbData;
        WORD wLc;

        ByteBufferToBuffer(pApdu, bfApdu);
        ParseRequest(
            bfApdu.Access(),
            bfApdu.Length(),
            &m_bCla,
            &m_bIns,
            &m_bP1,
            &m_bP2,
            &pbData,
            &wLc,
            &m_wLe,
            &m_dwFlags);
        m_bfRequestData.Set(pbData, wLc);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ApduLength:

    The get_ApduLength method determines the length (in bytes) of the APDU.

Arguments:

    plSize [out, retval] Pointer to the length of the APDU.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve the raw APDU from the byte buffer mapped through an IStream
    that contains the APDU message, call get_Apdu.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ApduLength")

STDMETHODIMP
CSCardCmd::get_ApduLength(
    /* [retval][out] */ LONG __RPC_FAR *plSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        CBuffer bfApdu;

        ConstructRequest(
            m_bCla,
            m_bIns,
            m_bP1,
            m_bP2,
            m_bfRequestData,
            m_wLe,
            m_dwFlags,
            bfApdu);
        *plSize = (LONG)bfApdu.Length();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ApduReply:

    The get_ApduReply retrieves the reply APDU, placing it in a specific byte
    buffer.  The reply may be NULL if no transaction has been performed on the
    command APDU.

Arguments:

    ppReplyApdu [out, retval] Pointer to the byte buffer (mapped through an
        IStream) that contains the APDU reply message on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ApduReply")

STDMETHODIMP
CSCardCmd::get_ApduReply(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppReplyApdu)
{
    HRESULT hReturn = S_OK;
    LPBYTEBUFFER pMyBuffer = NULL;

    try
    {
        if (NULL == *ppReplyApdu)
        {
            *ppReplyApdu = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        BufferToByteBuffer(m_bfResponseApdu, ppReplyApdu);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppReplyApdu = NULL;
    }
    return hReturn;
}


/*++

CSCardCmd::put_ApduReply:

    The put_ApduReply method sets a new reply APDU.

Arguments:

    pReplyApdu [in] Pointer to the byte buffer (mapped through an IStream) that
        contains the replay APDU message on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_ApduReply")

STDMETHODIMP
CSCardCmd::put_ApduReply(
    /* [in] */ LPBYTEBUFFER pReplyApdu)
{
    HRESULT hReturn = S_OK;

    try
    {
        ByteBufferToBuffer(pReplyApdu, m_bfResponseApdu);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ApduReplyLength:

    The get_ApduReplyLength method determines the length (in bytes) of the
    reply APDU.

Arguments:

    plSize [out, retval] Pointer to the size of the reply APDU message.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ApduReplyLength")

STDMETHODIMP
CSCardCmd::get_ApduReplyLength(
    /* [retval][out] */ LONG __RPC_FAR *plSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        *plSize = (LONG)m_bfResponseApdu.Length();
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


STDMETHODIMP
CSCardCmd::put_ApduReplyLength(
    /* [in] */ LONG lSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bfResponseApdu.Resize((DWORD)lSize, TRUE);
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ClassId:

    The get_ClassId method retrieves the class identifier from the APDU.

Arguments:

    pbyClass [out, retval] Pointer to the byte that represents the class
        identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ClassId")

STDMETHODIMP
CSCardCmd::get_ClassId(
    /* [retval][out] */ BYTE __RPC_FAR *pbyClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyClass = m_bCla;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_ClassId:

    The put_ClassId method sets a new class identifier in the APDU.

Arguments:

byClass [in, defaultvalue(0)] The byte that represents the class identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_ClassId")

STDMETHODIMP
CSCardCmd::put_ClassId(
    /* [defaultvalue][in] */ BYTE byClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bCla = byClass;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_Data:

    The get_Data method retrieves the data field from the APDU, placing it in a
    byte buffer object.

Arguments:

    ppData [out, retval] Pointer to the byte buffer object (IStream) that holds
        the APDU's data field on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_Data")

STDMETHODIMP
CSCardCmd::get_Data(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppData)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;

    try
    {
        if (NULL == *ppData)
        {
            *ppData = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        BufferToByteBuffer(m_bfRequestData, ppData);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppData = NULL;
    }
    return hReturn;
}


/*++

CSCardCmd::put_Data:

    The put_Data method sets the data field in the APDU.

Arguments:

    pData [in] Pointer to the byte buffer object (IStream) to be copied into
        the APDU's data field.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_Data")

STDMETHODIMP
CSCardCmd::put_Data(
    /* [in] */ LPBYTEBUFFER pData)
{
    HRESULT hReturn = S_OK;

    try
    {
        ByteBufferToBuffer(pData, m_bfRequestData);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_InstructionId:

    The get_InstructionId method retrieves the instruction identifier byte from
    the APDU.

Arguments:

    pbyIns [out, retval] Pointer to the byte that is the instruction ID from
        the APDU on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_InstructionId")

STDMETHODIMP
CSCardCmd::get_InstructionId(
    /* [retval][out] */ BYTE __RPC_FAR *pbyIns)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyIns = m_bIns;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_InstructionId:

    The put_InstructionId sets the given instruction identifier in the APDU.

Arguments:

    byIns [in] The byte that is the instruction identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_InstructionId")

STDMETHODIMP
CSCardCmd::put_InstructionId(
    /* [in] */ BYTE byIns)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bIns = byIns;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


STDMETHODIMP
CSCardCmd::get_LeField(
    /* [retval][out] */ LONG __RPC_FAR *plSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        *plSize = m_wLe;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_P1:

    The get_P1 method retrieves the first parameter (P1) byte from the APDU.

Arguments:

    pbyP1 [out, retval] Pointer to the P1 byte in the APDU on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_P1")

STDMETHODIMP
CSCardCmd::get_P1(
    /* [retval][out] */ BYTE __RPC_FAR *pbyP1)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyP1 = m_bP1;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_P1:

    The put_P1 method sets the first parameter (P1) byte of the APDU.

Arguments:

    byP1 [in] The byte that is the P1 field.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_P1")

STDMETHODIMP
CSCardCmd::put_P1(
    /* [in] */ BYTE byP1)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bP1 = byP1;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_P2:

    The get_P2 method retrieves the second parameter (P2) byte from the APDU

Arguments:

    pbyP2 [out, retval] Pointer to the byte that is the P2 from the APDU on
        return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_P2")

STDMETHODIMP
CSCardCmd::get_P2(
    /* [retval][out] */ BYTE __RPC_FAR *pbyP2)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyP2 = m_bP2;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_P2:

    The put_P2 method sets the second parameter (P2) byte in the APDU.

Arguments:

    byP2 [in] The byte that is the P2 field.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_P2")

STDMETHODIMP
CSCardCmd::put_P2(
    /* [in] */ BYTE byP2)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bP2 = byP2;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_P3:

    The get_P3 method retrieves the third parameter (P3) byte from the APDU.
    This read-only byte value represents the size of the data portion of the
    APDU.

Arguments:

    pbyP3 [out, retval] Pointer to the byte that is the P3 from the APDU on
        return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_P3")

STDMETHODIMP
CSCardCmd::get_P3(
    /* [retval][out] */ BYTE __RPC_FAR *pbyP3)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyP3 = (BYTE)m_bfRequestData.Length();
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ReplyStatus:

    The get_ReplyStatus method retrieves the reply APDU's message status word.

Arguments:

    pwStatus [out, retval] Pointer to the word that is the status on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ReplyStatus")

STDMETHODIMP
CSCardCmd::get_ReplyStatus(
    /* [retval][out] */ LPWORD pwStatus)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            *pwStatus = NetToLocal(m_bfResponseApdu.Access(dwLen - 2));
        else
            *pwStatus = 0;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_ReplyStatus:

    The put_ReplyStatus sets a new reply APDU's message status word.

Arguments:

    wStatus [in] The word that is the status.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_ReplyStatus")

STDMETHODIMP
CSCardCmd::put_ReplyStatus(
    /* [in] */ WORD wStatus)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            CopyMemory(m_bfResponseApdu.Access(dwLen - 2), &wStatus, 2);
        else
            m_bfResponseApdu.Set((LPCBYTE)&wStatus, 2);
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ReplyStatusSW1:

    The get_ReplyStatusSW1 method retrieves the reply APDU's SW1 status byte.

Arguments:

    pbySW1 [out, retval] Pointer to the byte that contains the value of the SW1
        byte on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ReplyStatusSW1")

STDMETHODIMP
CSCardCmd::get_ReplyStatusSW1(
    /* [retval][out] */ BYTE __RPC_FAR *pbySW1)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            *pbySW1 = *m_bfResponseApdu.Access(dwLen - 2);
        else
            *pbySW1 = 0;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ReplyStatusSW2:

    The get_ReplyStatusSW2 method retrieves the reply APDU's SW2 status byte.

Arguments:

    pbySW2 [out, retval] Pointer to the byte that contains the value of the SW2
        byte on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ReplyStatusSW2")

STDMETHODIMP
CSCardCmd::get_ReplyStatusSW2(
    /* [retval][out] */ BYTE __RPC_FAR *pbySW2)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            *pbySW2 = *m_bfResponseApdu.Access(dwLen - 1);
        else
            *pbySW2 = 0;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_Type")

STDMETHODIMP
CSCardCmd::get_Type(
    /* [retval][out] */ ISO_APDU_TYPE __RPC_FAR *pType)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?todo?
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::get_Nad(
    /* [retval][out] */ BYTE __RPC_FAR *pbNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (0 != (m_dwFlags & APDU_REQNAD_VALID))
            *pbNad = m_bRequestNad;
        else
            hReturn = E_ACCESSDENIED;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::put_Nad(
    /* [in] */ BYTE bNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bRequestNad = bNad;
        m_dwFlags |= APDU_REQNAD_VALID;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::get_ReplyNad(
    /* [retval][out] */ BYTE __RPC_FAR *pbNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (0 != (APDU_RSPNAD_VALID & m_dwFlags))
            *pbNad = m_bResponseNad;
        else
            hReturn = E_ACCESSDENIED;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::put_ReplyNad(
    /* [in] */ BYTE bNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bResponseNad = bNad;
        m_dwFlags |= APDU_RSPNAD_VALID;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_AlternateClassId:

    The get_AlternateClassId method retrieves the alternate class identifier
    from the APDU.  The Alternate Class Id is used for automatically generated
    GetResponse and Envelope commands when T=0 is used.

Arguments:

    pbyClass [out, retval] Pointer to the byte that represents the alternate
        class identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_AlternateClassId")

STDMETHODIMP
CSCardCmd::get_AlternateClassId(
    /* [retval][out] */ BYTE __RPC_FAR *pbyClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (0 != (m_dwFlags & APDU_ALTCLA_VALID))
            *pbyClass = m_bAltCla;
        else
            hReturn = E_ACCESSDENIED;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_AlternateClassId:

    The put_AlternateClassId method sets a new alternate class identifier in
    the APDU.  The Alternate Class Id is used for automatically generated
    GetResponse and Envelope commands when T=0 is used.  If no alternate class
    identifier is set, then the CLA of the original command is used.

Arguments:

    byClass [in, defaultvalue(0)] The byte that represents the alternate class
        identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_AlternateClassId")

STDMETHODIMP
CSCardCmd::put_AlternateClassId(
    /* [defaultvalue][in] */ BYTE byClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bAltCla = byClass;
        m_dwFlags |= APDU_ALTCLA_VALID;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::BuildCmd:

    The BuildCmd method constructs a valid command APDU for transmission to a
    smart card.

Arguments:

    byClassId [in] Command class identifier.

    byInsId [in] Command instruction identifier.

    byP1 [in, defaultvalue(0)] Command's first parameter.

    byP2 [in, defaultvalue(0)] Command's second parameter.

    pbyData [in, defaultvalue(NULL)] Pointer to the data portion of the
        command.

    p1Le [in, defaultvalue(NULL)] Pointer to a LONG integer containing the
        expected length of the returned data.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::BuildCmd")

STDMETHODIMP
CSCardCmd::BuildCmd(
    /* [in] */ BYTE byClassId,
    /* [in] */ BYTE byInsId,
    /* [defaultvalue][in] */ BYTE byP1,
    /* [defaultvalue][in] */ BYTE byP2,
    /* [defaultvalue][in] */ LPBYTEBUFFER pbyData,
    /* [defaultvalue][in] */ LONG __RPC_FAR *plLe)
{
    HRESULT hReturn = S_OK;

    try
    {
        ByteBufferToBuffer(pbyData, m_bfRequestData);
        m_bCla = byClassId;
        m_bIns = byInsId;
        m_bP1  = byP1;
        m_bP2  = byP2;
        m_dwFlags = 0;

        if (NULL != plLe)
        {
            switch (*plLe)
            {
            case 0x10000:
                m_dwFlags |= APDU_EXTENDED_LENGTH;
                // Fall through intentionally
            case 0x100:
            case 0:
                m_dwFlags |= APDU_MAXIMUM_LE;
                m_wLe = 0;
                break;
            default:
                if (0x10000 < *plLe)
                    throw (HRESULT)E_INVALIDARG;
                if (0x100 < *plLe)
                    m_dwFlags |= APDU_EXTENDED_LENGTH;
                m_wLe = (WORD)(*plLe);
            }
        }
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::Clear:

    The Clear method clears the APDU and reply APDU message buffers.

Arguments:

    None

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::Clear")

STDMETHODIMP
CSCardCmd::Clear(
    void)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bfRequestData.Reset();
        m_bfResponseApdu.Reset();
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::Encapsulate:

    The Encapsulate method encapsulates the given command APDU into another
    command APDU for transmission to a smart card.

Arguments:

    pApdu [in] Pointer to the APDU to be encapsulated.

    ApduType [in] Specifies the ISO 7816-4 case for T0 transmissions.  Possible
        values are:

        ISO_CASE_1
        ISO_CASE_2
        ISO_CASE_3
        ISO_CASE_4

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::Encapsulate")

STDMETHODIMP
CSCardCmd::Encapsulate(
    /* [in] */ LPBYTEBUFFER pApdu,
    /* [in] */ ISO_APDU_TYPE ApduType)
{
    HRESULT hReturn = S_OK;

    try
    {
        WORD wLe;
        DWORD dwFlags;


        //
        // Get the APDU to be encapsulated.
        //

        ByteBufferToBuffer(pApdu, m_bfRequestData);


        //
        // Parse it.
        //

        ParseRequest(
            m_bfRequestData.Access(),
            m_bfRequestData.Length(),
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &wLe,
            &dwFlags);


        m_bIns = 0xc2;
        m_bP1  = 0x00;
        m_bP2  = 0x00;
        m_wLe  = wLe;
        m_dwFlags = dwFlags;

        // ?todo? -- support ApduType
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9AEC1AF7_19F1_11D3_A11F_00C04F79F800__INCLUDED_)
#define AFX_STDAFX_H__9AEC1AF7_19F1_11D3_A11F_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ole2.h>
#include <oleauto.h>
#include <unknwn.h>

#ifdef _DEBUG

#include <crtdbg.h>
#define ASSERT(x) _ASSERTE(x)
#define breakpoint _CrtDbgBreak()
// #define breakpoint

#elif defined(DBG)

#include <stdio.h>
inline void
LocalAssert(
    LPCTSTR szExpr,
    LPCTSTR szFile,
    DWORD dwLine)
{
    TCHAR szBuffer[MAX_PATH * 2];
    _stprintf(szBuffer, TEXT("ASSERT FAIL: '%s' in %s at %d.\n"), szExpr, szFile, dwLine);
    OutputDebugString(szBuffer);
}
#define ASSERT(x) if (!(x)) do { \
        LocalAssert(TEXT(#x), TEXT(__FILE__), __LINE__); \
        _CrtDbgBreak(); } while (0)
#define breakpoint _CrtDbgBreak()

#else

#define ASSERT(x)
#define breakpoint

#endif

#include <winscard.h>
#include <scardlib.h>
#include <scardssp.h>

extern LPUNKNOWN NewObject(REFCLSID rclsid, REFIID riid);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9AEC1AF7_19F1_11D3_A11F_00C04F79F800__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\typeconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       TypeConv.cpp
//
//--------------------------------------------------------------------------

// TypeConv.cpp : Implementation of CSCardTypeConv
#include "stdafx.h"
#include "ByteBuffer.h"
#include "TypeConv.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardTypeConv

STDMETHODIMP
CSCardTypeConv::ConvertByteArrayToByteBuffer(
    /* [in] */ LPBYTE pbyArray,
    /* [in] */ DWORD dwArraySize,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuffer)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;

        if (NULL == *ppbyBuffer)
        {
            *ppbyBuffer = NewByteBuffer();
            if (NULL == *ppbyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        hr = (*ppbyBuffer)->Initialize();
        if (FAILED(hr))
            throw hr;
        hr = (*ppbyBuffer)->Write(pbyArray, dwArraySize, NULL);
        if (FAILED(hr))
            throw hr;
        hr = (*ppbyBuffer)->Seek(0, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::ConvertByteBufferToByteArray(
    /* [in] */ LPBYTEBUFFER pbyBuffer,
    /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;
        LONG nLen;
        BOOL fSts;
        DWORD dwSts;
        HGLOBAL hMem = NULL;

        hr = pbyBuffer->Seek(0, STREAM_SEEK_END, &nLen);
        if (FAILED(hr))
            throw hr;
        hr = pbyBuffer->Seek(0, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;

        if (NULL == (*ppArray)->hMem)
            (*ppArray)->hMem = GlobalAlloc(GMEM_MOVEABLE, nLen);
        else
        {
            fSts = GlobalUnlock((*ppArray)->hMem);
            if (!fSts)
            {
                dwSts = GetLastError();
                if (NO_ERROR != dwSts)
                    throw (HRESULT)HRESULT_FROM_WIN32(dwSts);
            }
            else
                throw (HRESULT)E_HANDLE;

            hMem = GlobalReAlloc((*ppArray)->hMem, nLen, 0);

            if (NULL == hMem)
            {
                // Realloc failed.  Free the initial buffer and bail out.
                GlobalFree((*ppArray)->hMem);
                (*ppArray)->hMem = NULL;
            }
            else
            {
                (*ppArray)->hMem = hMem;
            }
        }
        if (NULL == (*ppArray)->hMem)
            throw (HRESULT)HRESULT_FROM_WIN32(GetLastError());
        (*ppArray)->pbyData = (LPBYTE)GlobalLock((*ppArray)->hMem);
        (*ppArray)->dwSize = nLen;
        if (NULL == (*ppArray)->pbyData)
            throw (HRESULT)HRESULT_FROM_WIN32(GetLastError());

        hr = pbyBuffer->Read(
                    (*ppArray)->pbyData,
                    nLen,
                    &nLen);
        if (FAILED(hr))
            throw hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::ConvertByteBufferToSafeArray(
    /* [in] */ LPBYTEBUFFER pbyBuffer,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppbyArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::ConvertSafeArrayToByteBuffer(
    /* [in] */ LPSAFEARRAY pbyArray,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::CreateByteArray(
    /* [in] */ DWORD dwAllocSize,
    /* [retval][out] */ LPBYTE __RPC_FAR *ppbyArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::CreateByteBuffer(
    /* [in] */ DWORD dwAllocSize,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff)
{
    HRESULT hReturn = S_OK;

    try
    {
        *ppbyBuff = NewByteBuffer();
        if (NULL == *ppbyBuff)
            throw (HRESULT)E_OUTOFMEMORY;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::CreateSafeArray(
    /* [in] */ UINT nAllocSize,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::FreeIStreamMemoryPtr(
    /* [in] */ LPSTREAM pStrm,
    /* [in] */ LPBYTE pMem)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::GetAtIStreamMemory(
    /* [in] */ LPSTREAM pStrm,
    /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppMem)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::SizeOfIStream(
    /* [in] */ LPSTREAM pStrm,
    /* [retval][out] */ ULARGE_INTEGER __RPC_FAR *puliSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\scardssp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scardssp.cpp
//
//--------------------------------------------------------------------------

// scardssp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for scardssp.idl by adding the following
//      files to the Outputs.
//          scardssp_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f scardsspps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <sspguid.h>
#include "dlldatax.h"

#include "ByteBuffer.h"
#include "TypeConv.h"
#include "SCardCmd.h"
#include "ISO7816.h"
#include "SCard.h"
#include "Database.h"
#include "Locate.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CByteBuffer, CByteBuffer)
OBJECT_ENTRY(CLSID_CSCardTypeConv, CSCardTypeConv)
OBJECT_ENTRY(CLSID_CSCardCmd, CSCardCmd)
OBJECT_ENTRY(CLSID_CSCardISO7816, CSCardISO7816)
OBJECT_ENTRY(CLSID_CSCard, CSCard)
OBJECT_ENTRY(CLSID_CSCardDatabase, CSCardDatabase)
OBJECT_ENTRY(CLSID_CSCardLocate, CSCardLocate)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance/* , &LIBID_SCARDSSPLib */);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(/* TRUE */);
}


/////////////////////////////////////////////////////////////////////////////
// Quick Generation of our own objects.

LPUNKNOWN
NewObject(
    REFCLSID rclsid,
    REFIID riid)
{
    HRESULT hr;
    IClassFactory *pCF = NULL;
    LPUNKNOWN pUnk = NULL;

    try
    {
        hr = DllGetClassObject(rclsid, IID_IClassFactory, (LPVOID *)&pCF);
        if (FAILED(hr))
            throw hr;
        hr = pCF->CreateInstance(NULL, riid, (LPVOID *)&pUnk);
        if (FAILED(hr))
            throw hr;
        pCF->Release();
    }
    catch (...)
    {
        if (NULL != pCF)
            pCF->Release();
        throw;
    }
    return pUnk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\newssp\scardssp\typeconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       TypeConv.h
//
//--------------------------------------------------------------------------

// TypeConv.h : Declaration of the CSCardTypeConv

#ifndef __SCARDTYPECONV_H_
#define __SCARDTYPECONV_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardTypeConv
class ATL_NO_VTABLE CSCardTypeConv :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardTypeConv, &CLSID_CSCardTypeConv>,
    public IDispatchImpl<ISCardTypeConv, &IID_ISCardTypeConv, &LIBID_SCARDSSPLib>
{
public:
    CSCardTypeConv()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDTYPECONV)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardTypeConv)
    COM_INTERFACE_ENTRY(ISCardTypeConv)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISCardTypeConv
public:
    STDMETHOD(ConvertByteArrayToByteBuffer)(
        /* [in] */ LPBYTE pbyArray,
        /* [in] */ DWORD dwArraySize,
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuffer);

    STDMETHOD(ConvertByteBufferToByteArray)(
        /* [in] */ LPBYTEBUFFER pbyBuffer,
        /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppArray);

    STDMETHOD(ConvertByteBufferToSafeArray)(
        /* [in] */ LPBYTEBUFFER pbyBuffer,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppbyArray);

    STDMETHOD(ConvertSafeArrayToByteBuffer)(
        /* [in] */ LPSAFEARRAY pbyArray,
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);

    STDMETHOD(CreateByteArray)(
        /* [in] */ DWORD dwAllocSize,
        /* [retval][out] */ LPBYTE __RPC_FAR *ppbyArray);

    STDMETHOD(CreateByteBuffer)(
        /* [in] */ DWORD dwAllocSize,
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);

    STDMETHOD(CreateSafeArray)(
        /* [in] */ UINT nAllocSize,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppArray);

    STDMETHOD(FreeIStreamMemoryPtr)(
        /* [in] */ LPSTREAM pStrm,
        /* [in] */ LPBYTE pMem);

    STDMETHOD(GetAtIStreamMemory)(
        /* [in] */ LPSTREAM pStrm,
        /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppMem);

    STDMETHOD(SizeOfIStream)(
        /* [in] */ LPSTREAM pStrm,
        /* [retval][out] */ ULARGE_INTEGER __RPC_FAR *puliSize);
};

inline CSCardTypeConv *
NewSCardTypeConv(
    void)
{
    return (CSCardTypeConv *)NewObject(CLSID_CSCardTypeConv, IID_ISCardTypeConv);
}

#endif //__SCARDTYPECONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\sclogon\unicodes.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    unicodes

Abstract:

    This header file describes the CUnicodeString class, useful for converting
    string types.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _UNICODES_H_
#define _UNICODES_H_

//
//==============================================================================
//
//  CUnicodeString
//

class CUnicodeString
{
public:

    //  Constructors & Destructor
    CUnicodeString(void);
    CUnicodeString(LPCSTR sz);
    CUnicodeString(LPCWSTR wsz);
    CUnicodeString(PUNICODE_STRING pus);
    ~CUnicodeString();

    //  Properties
    //  Methods
    LPCSTR  Set(LPCSTR sz);
    LPCWSTR Set(LPCWSTR wsz);
    PUNICODE_STRING Set(PUNICODE_STRING pus);
    BOOL Valid(void)
    {
        if (m_fFlags == fNoneGood)
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }

    //  Operators
    LPCSTR operator=(LPCSTR sz)
    { return Set(sz); };
    LPCWSTR operator=(LPCWSTR wsz)
    { return Set(wsz); };
    PUNICODE_STRING operator=(PUNICODE_STRING pus)
    { return Set(pus);};
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };
    operator PUNICODE_STRING(void);

protected:
    //  Properties
    UNICODE_STRING m_us;
    LPSTR m_szAnsi;
    LPWSTR m_wszUnicode;
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
};

#endif // _UNICODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\sclogon\unicodes.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    unicodes

Abstract:

    This module implements the CUnicodeString class.  This class allows a string
    to automatically convert between PUNICODE_STRING, LPCSTR, and LPCWSTR.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#include <windows.h>
#include <wincrypt.h>
#include <crtdbg.h>
#include "scLogon.h"
#include "unicodes.h"


//
// Piddly routines.
//

CUnicodeString::CUnicodeString(
    void)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
}

CUnicodeString::CUnicodeString(
    LPCSTR sz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(sz);
}

CUnicodeString::CUnicodeString(
    LPCWSTR wsz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(wsz);
}

CUnicodeString::CUnicodeString(
    PUNICODE_STRING pus)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(pus);
}

CUnicodeString::~CUnicodeString()
{
    if (NULL != m_szAnsi)
    {
        memset(m_szAnsi, 0, lstrlenA(m_szAnsi));
        LocalFree(m_szAnsi);
    }
    if (NULL != m_wszUnicode)
    {
        memset(m_wszUnicode, 0, lstrlenW(m_wszUnicode)*sizeof(WCHAR));
        LocalFree(m_wszUnicode);
    }
}

PUNICODE_STRING
CUnicodeString::Set(
    PUNICODE_STRING pus)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    m_fFlags = fNoneGood;
    if (pus != NULL)
    {
        m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, pus->Length + sizeof(WCHAR));
        if (m_wszUnicode != NULL)
        {
            CopyMemory(
                m_wszUnicode,
                pus->Buffer,
                pus->Length
                );
            m_wszUnicode[pus->Length/sizeof(WCHAR)] = L'\0';
            m_fFlags = fUnicodeGood;
        }
    }
    return pus;
}


/*++

Set:

    These methods initialize the object to a given string.

Arguments:

    sz - Supplies an ANSI string with which to initialize the object.

    wsz - Supplies a UNICODE string with which to initialize the object.

    pus - Supplies a pointer to a UNICODE_STRING structure from which to
        initialize the object.

Return Value:

    The same value as was provided.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Set(
    LPCSTR sz)
{
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    if (NULL != m_szAnsi)
        LocalFree(m_szAnsi);
    m_fFlags = fNoneGood;

    m_szAnsi = (LPSTR)LocalAlloc(LPTR, (lstrlenA(sz) + 1) * sizeof(CHAR));
    if (NULL != m_szAnsi)
    {
        lstrcpyA(m_szAnsi, sz);
        m_fFlags = fAnsiGood;
    }
    return m_szAnsi;
}

LPCWSTR
CUnicodeString::Set(
    LPCWSTR wsz)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
        LocalFree(m_wszUnicode);
    m_fFlags = fNoneGood;
    m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(wsz) + 1) * sizeof(WCHAR));
    if (m_wszUnicode != NULL)
    {
        lstrcpyW(m_wszUnicode, wsz);
        m_fFlags = fUnicodeGood;
    }
    return m_wszUnicode;
}

CUnicodeString::operator PUNICODE_STRING(
    void)
{
    m_us.Buffer = (LPWSTR)Unicode();
    m_us.Length = m_us.MaximumLength = (USHORT)(lstrlenW(m_us.Buffer) * sizeof(WCHAR));
    return &m_us;
}


/*++

Unicode:

    This method ensures that the object has a valaid internal UNICODE
    representation.

Arguments:

    None

Return Value:

    The represented string, in UNICODE format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCWSTR
CUnicodeString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        _ASSERTE(NULL != m_szAnsi);
        length =
            MultiByteToWideChar(
                GetACP(),
                MB_PRECOMPOSED,
                m_szAnsi,
                -1,
                NULL,
                0);
        if (NULL != m_wszUnicode)
        {
            LocalFree(m_wszUnicode);
        }
        if (0 != length)
        {
            m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
            if (m_wszUnicode == NULL)
            {
                break;
            }
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    m_szAnsi,
                    -1,
                    m_wszUnicode,
                    length);
            m_wszUnicode[length] = 0;
        }
        else
        {
            m_wszUnicode = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    case fNoneGood:
    default:
        // Internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_wszUnicode;
}


/*++

Ansi:

    This method ensures that the object has a valaid internal ANSI
    representation.

Arguments:

    None

Return Value:

    The represented string, in ANSI format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        length =
            WideCharToMultiByte(
                GetACP(),
                0,
                m_wszUnicode,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        if (NULL != m_szAnsi)
        {
            LocalFree(m_szAnsi);
        }

        if (0 != length)
        {
            m_szAnsi = (LPSTR)LocalAlloc(LPTR, (length + 1) * sizeof(CHAR));
            if (m_szAnsi == NULL)
            {
                break;
            }
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    m_wszUnicode,
                    -1,
                    m_szAnsi,
                    length,
                    NULL,
                    NULL);
            m_szAnsi[length] = 0;
        }
        else
        {
            m_szAnsi = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    case fNoneGood:
    default:
        // An internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_szAnsi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\sclogon\sclogon.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScLogon

Abstract:

    This module provides helper functions for use by winlogon (GINA, Kerberos)

Author:

    Amanda Matlosz (amatlosz) 10/22/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

        03-11-98 Wrap calls to GetLastError() to workaround bug where LastErr gets
                        clobbered.  Added event logging to make logon smoother.

                04-02-98 Removed all references to WinVerifyTrust; this is something
                                                Kerberos itself is responsible for.
--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes

#if !defined(_AMD64_) && !defined(_X86_) && !defined(_IA64_)
#define _X86_ 1
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#ifndef UNICODE
#define UNICODE
#endif
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <windows.h>
#include <winscard.h>
#include <wincrypt.h>
#include <softpub.h>
#include <stddef.h>
#include <crtdbg.h>
#include "sclogon.h"
#include "unicodes.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <tchar.h>

#ifndef KP_KEYEXCHANGE_PIN
#define KP_KEYEXCHANGE_PIN 32
#else
#if 32 != KP_KEYEXCHANGE_PIN
#error Invalid KP_KEYEXCHANGE_PIN assumption
#endif
#endif
#ifndef CRYPT_SILENT
#define CRYPT_SILENT 0x40
#else
#if 0x40 != CRYPT_SILENT
#error Duplicate CRYPT_SILENT definition
#endif
#endif
#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#else
#if 2 != SCARD_PROVIDER_CSP
#error Invalid SCARD_PROVIDER_CSP definition
#endif
#endif

#if defined(DBG) || defined(DEBUG)
BOOL SCDebug = TRUE;
#define DebugPrint(a) _DebugPrint a
void
__cdecl
_DebugPrint(
    LPCSTR szFormat,
    ...
    )
{
    if (SCDebug) {
        CHAR szBuffer[512];
        va_list ap;

        va_start(ap, szFormat);
        vsprintf(szBuffer, szFormat, ap);
        OutputDebugStringA(szBuffer);
    }
}
#else
#define DebugPrint(a)
#endif

// TODO: The following logging is still proving useful.
// TODO: leave in for B3: integrate more tightly w/ winlogon/kerberos ??
#include <sclmsg.h>

// A Global class used to maintain internal state.
class CSCLogonInit
{
public:
    // Runs at image creation
    CSCLogonInit(
        BOOL *pfResult)
    {
        m_hCrypt = NULL;
        *pfResult = TRUE;
    };

    // Runs at image termination
    ~CSCLogonInit()
    {
        Release();
    };

    // Cleans up current state.
    void
    Release(
        void)
    {
        if (NULL != m_hCrypt)
        {
            CryptReleaseContext(m_hCrypt, 0);
            m_hCrypt = NULL;
        }
    }

    // Relinquish control of the crypto context.
    HCRYPTPROV
    RelinquishCryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;

        hProv = CryptCtx(pLogon);
        m_hCrypt = NULL;
        return hProv;
    };

    // Get the crypto context, creating it if it's not there.
    HCRYPTPROV
    CryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;
        LPCTSTR szRdr = NULL;
        LPCTSTR szCntr = NULL;
        LPTSTR szFQCN = NULL;
        LONG lLen = 0;

        if (NULL == m_hCrypt)
        {
            BOOL fSts;

            // Prepare FullyQualifiedContainerName for CryptAcCntx call

            szRdr = GetReaderName((LPBYTE)pLogon);
            szCntr = GetContainerName((LPBYTE)pLogon);

            lLen = (lstrlen(szRdr) + lstrlen(szCntr) + 10)*sizeof(TCHAR);
            szFQCN = (LPTSTR)LocalAlloc(LPTR, lLen);
            if (NULL != szFQCN)
            {
                wsprintf(szFQCN, TEXT("\\\\.\\%s\\%s"), szRdr, szCntr);

                fSts = CryptAcquireContext(
                    &m_hCrypt,
                    szFQCN,
                    GetCSPName((LPBYTE)pLogon),
                    PROV_RSA_FULL,  // ?TODO? from pbLogonInfo
                    CRYPT_SILENT | CRYPT_MACHINE_KEYSET
                    );

                LocalFree(szFQCN);
            }
            else
            {
                fSts = FALSE;
            }
        }
        hProv = m_hCrypt;
        return hProv;
    }

protected:
    HCRYPTPROV m_hCrypt;
};

NTSTATUS ScNtStatusTranslation(NTSTATUS NtErr, DWORD *pdwErr)
{
    //
    // Convert the error back to a Win32 error
    //
    switch (NtErr)
    {
    case STATUS_INVALID_PARAMETER:
        *pdwErr = ERROR_INVALID_DATA;
        break;

    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
            // A Cryptxxx API just failed
        *pdwErr = GetLastError();
        switch (*pdwErr)
        {
        case SCARD_W_WRONG_CHV:
        case SCARD_E_INVALID_CHV:
            NtErr = STATUS_SMARTCARD_WRONG_PIN;
            break;

        case SCARD_W_CHV_BLOCKED:
            NtErr = STATUS_SMARTCARD_CARD_BLOCKED;
            break;

        case SCARD_W_REMOVED_CARD:
        case SCARD_E_NO_SMARTCARD:
            NtErr = STATUS_SMARTCARD_NO_CARD;
            break;

        case NTE_BAD_KEYSET:
        case NTE_KEYSET_NOT_DEF:
            NtErr = STATUS_SMARTCARD_NO_KEY_CONTAINER;
            break;

        case SCARD_E_NO_SUCH_CERTIFICATE:
        case SCARD_E_CERTIFICATE_UNAVAILABLE:
            NtErr = STATUS_SMARTCARD_NO_CERTIFICATE;
            break;

        case NTE_NO_KEY:
            NtErr = STATUS_SMARTCARD_NO_KEYSET;
            break;

        case SCARD_E_TIMEOUT:
        case SCARD_F_COMM_ERROR:
        case SCARD_E_COMM_DATA_LOST:
            NtErr = STATUS_SMARTCARD_IO_ERROR;
            break;

        case NTE_SILENT_CONTEXT:
            NtErr = STATUS_SMARTCARD_SILENT_CONTEXT;
            break;

        //default:
            // Nothing, leave NtErr unchanged
        }
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_NO_MEMORY:
        *pdwErr = ERROR_OUTOFMEMORY;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        *pdwErr = SEC_E_BUFFER_TOO_SMALL;
        break;

    default:
        *pdwErr = SCARD_E_UNEXPECTED;
    }

    return NtErr;
}

// For tracing errors in ScHelper*

NTSTATUS LogEvent(NTSTATUS NtErr, DWORD dwEventID)
{
    DWORD dwErr;
    //
    // Convert the error back to a Win32 error
    //
    NtErr = ScNtStatusTranslation(NtErr, &dwErr);

    if (0 == dwErr)
    {
        return NtErr;
    }

    //
    // Initialize log as necessary
    //
    HKEY    hKey;
    DWORD   disp;

    long err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\Smart Card Logon"),
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_WRITE,
        NULL,
        &hKey,
        &disp
        );

    if (ERROR_SUCCESS != err)
    {
        return NtErr;
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        PBYTE l_szModulePath = (PBYTE)TEXT("%SystemRoot%\\System32\\scarddlg.dll");
        ULONG l_uLen = (_tcslen((LPCTSTR)l_szModulePath) + 1)*sizeof(TCHAR);

        RegSetValueEx(
            hKey,
            TEXT("EventMessageFile"),
            0,
            REG_EXPAND_SZ,
            l_szModulePath,
            l_uLen
            );

        disp = (DWORD)(
            EVENTLOG_ERROR_TYPE |
            EVENTLOG_WARNING_TYPE |
            EVENTLOG_INFORMATION_TYPE
            );

        RegSetValueEx(
            hKey,
            TEXT("TypesSupported"),
            0,
            REG_DWORD,
            (PBYTE) &disp,
            sizeof(DWORD)
            );
    }

    RegCloseKey(hKey);

    HANDLE hEventSource = RegisterEventSource(
        NULL,
        TEXT("Smart Card Logon")
        );

    if (NULL != hEventSource)
    {
        DWORD dwLen = 0;
        LPTSTR szErrorString = NULL;
        TCHAR szBuffer[2+8+1];  // Enough for "0x????????"

        dwLen = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwErr,
                LANG_NEUTRAL,
                (LPTSTR)&szErrorString,
                0,
                NULL);

        if (dwLen == 0)
        {
            _stprintf(szBuffer, _T("0x%08lX"), dwErr);
            szErrorString = szBuffer;
        }

        ReportEvent(
            hEventSource,
            EVENTLOG_ERROR_TYPE,
            0,              // event category
            dwEventID,      // event identifier // resourceID for the messagetable entry...
            NULL,           // user security identifier (optional)
            1,              // number of strings to merge with message
            sizeof(long),   // size of binary data, in bytes
            (LPCTSTR*)&szErrorString,   // array of strings to merge with message
            (LPVOID)&dwErr   // address of binary data
            );

        DeregisterEventSource(hEventSource);

        if ((NULL != szErrorString) && (szErrorString != szBuffer))
        {
            LocalFree((LPVOID)szErrorString);
        }

    }

    return NtErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Structs



//////////////////////////////////////////////////////////////////////////////
//
// Functions
//

// Internal helpers: called by the ScLogon APIs to perform certain tedious work

/*++

GetReaderName:
GetCardName:
GetContainerName:
GetCSPName:

  : Intended for accessing the LogonInformation glob

Author:

        Amanda Matlosz

Note:

  Some of these are made available to outside callers; see sclogon.h

--*/

extern "C"
PBYTE
WINAPI
ScBuildLogonInfo(
    LPCTSTR szCard,
    LPCTSTR szReader,
    LPCTSTR szContainer,
    LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.

    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");

    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }


    //
    // Build the LogonInfo glob using strings (or empty strings)
    //

    DWORD cbLi = offsetof(LogonInfo, bBuffer)
                 + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);

    if (NULL == pLI)
    {
        return NULL;
    }

    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;

    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);

    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);

    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);

    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);

    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}


LPCTSTR WINAPI GetReaderName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nReaderNameOffset];
};

LPCTSTR WINAPI GetCardName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCardNameOffset];
};

LPCTSTR WINAPI GetContainerName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nContainerNameOffset];
};

LPCTSTR WINAPI GetCSPName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCSPNameOffset];
};

/*++
BuildCertContext:

  Generates a certificate context with (static) keyprov info suitable for
  CertStore-based operations.

        If the PIN is provided, it is assumed the hProv (if provided) has not had the
        PIN parameter set...



Arguments:

    hProv -- must be a valid HCRYPTPROV

    pucPIN -- may be empty; used to set the PIN for hProv

    pbCert -- assumed to be a valid certificate; must not be NULL
    dwCertLen

    CertificateContext -- pointer to a pointer to the resultant CertContext

Return Value:

        NTSTATUS indicating STATUS_SUCCESS or error (see winerror.h or scarderr.h)

Author:

        Amanda Matlosz

Note:

--*/
NTSTATUS
BuildCertContext(
    IN HCRYPTPROV hProv,
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbCert,
    IN DWORD dwCertLen,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    BOOL fSts = FALSE;

    CRYPT_KEY_PROV_INFO KeyProvInfo;
    LPSTR szContainerName = NULL;
    LPSTR szProvName = NULL;
    CUnicodeString wszContainerName, wszProvName;
    DWORD cbContainerName, cbProvName;

    //
    // Check params
    //
    if ((NULL == hProv) || (NULL == pbCert || 0 == dwCertLen))
    {
        ASSERT(FALSE);
        lResult = STATUS_INVALID_PARAMETER;
        goto ErrorExit;
    }

    //
    // Convert the certificate into a Cert Context.
    //
    *CertificateContext = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    pbCert,
                    dwCertLen);
    if (NULL == *CertificateContext)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    //  Associate cryptprovider w/ the private key property of this cert
    //

    //  ... need the container name

    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            NULL,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szContainerName = (LPSTR)LocalAlloc(LPTR, cbContainerName);
    if (NULL == szContainerName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            (PBYTE)szContainerName,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszContainerName = szContainerName;

    //  ... need the provider name

    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            NULL,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szProvName = (LPSTR)LocalAlloc(LPTR, cbProvName);
    if (NULL == szProvName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            (PBYTE)szProvName,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszProvName = szProvName;

    //
    // Set the cert context properties to reflect the prov info
    //

    KeyProvInfo.pwszContainerName = (LPWSTR)(LPCWSTR)wszContainerName;
    KeyProvInfo.pwszProvName = (LPWSTR)(LPCWSTR)wszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = AT_KEYEXCHANGE;
    KeyProvInfo.dwFlags |= CERT_SET_KEY_CONTEXT_PROP_ID;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                (void *)&KeyProvInfo);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

    CERT_KEY_CONTEXT certKeyContext;
    certKeyContext.cbSize = sizeof(CERT_KEY_CONTEXT);
    certKeyContext.hCryptProv = hProv;
    certKeyContext.dwKeySpec = KeyProvInfo.dwKeySpec;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                0,
                (void *)&certKeyContext);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

ErrorExit:

    if(NULL != szContainerName)
    {
        LocalFree(szContainerName);
        szContainerName = NULL;
    }
    if(NULL != szProvName)
    {
        LocalFree(szProvName);
        szProvName = NULL;
    }

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_BUILDCC);
    }

    return lResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// ScLogon APIs
//


/*++

ScHelperInitializeContext:

        Prepares contextual information to be used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    )
{
    ULONG AllowedSize;

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    if ((cbLogonInfo < sizeof(ULONG)) ||
        (cbLogonInfo != pLI->dwLogonInfoLen))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    AllowedSize = (cbLogonInfo - sizeof(LogonInfo) ) / sizeof(TCHAR) + sizeof(DWORD) ;
    //
    // Verify the other fields of the logon info
    //
    if ((pLI->nCardNameOffset > pLI->nReaderNameOffset) ||
        (pLI->bBuffer[pLI->nReaderNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nReaderNameOffset > pLI->nContainerNameOffset) ||
        (pLI->bBuffer[pLI->nContainerNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nContainerNameOffset > pLI->nCSPNameOffset) ||
        (pLI->bBuffer[pLI->nCSPNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nCSPNameOffset > AllowedSize) ||
        (pLI->bBuffer[AllowedSize-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }


    _ASSERTE(pLI->ContextInformation == NULL);

    BOOL fResult = 0;
    pLI->ContextInformation = new CSCLogonInit(&fResult);
    if (pLI->ContextInformation == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    else
    {
        if (!fResult)
        {
            delete pLI->ContextInformation;
            pLI->ContextInformation = NULL;
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return(STATUS_SUCCESS);
}

/*++

ScHelperRelease:

        Releases contextual information used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
VOID WINAPI
ScHelperRelease(
    IN OUT PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;

    if (LogonInit != NULL)
    {
        LogonInit->Release();
        delete LogonInit;
        pLI->ContextInformation = NULL;
    }
}


/*++

ScHelperGetCertFromLogonInfo:

        Returns a CertificateContext for the cert on the card specified by the
        LogonInfo.  Creates the cert context by calling BuildCertContext,
        which generates a certificate context with (static) keyprov info
        suitable for CertStore-based operations.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        None

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    PCCERT_CONTEXT pCertCtx = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    LPBYTE pbCert = NULL;
    DWORD cbCertLen;

    //
    // Make sure we've got a Crypto Provider up and running.
    //
    hProv = LogonInit->RelinquishCryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Get the key handle.
    //
    fSts = CryptGetUserKey(
                hProv,
                AT_KEYEXCHANGE,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Upload the certificate.
    //

    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                NULL,
                &cbCertLen,
                0);
    if (!fSts)
    {
        DWORD dwGLE = GetLastError();

        if (ERROR_MORE_DATA != dwGLE)
        {
            if (NTE_NOT_FOUND == dwGLE)
            {
                SetLastError(SCARD_E_NO_SUCH_CERTIFICATE);
            }
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    pbCert = (LPBYTE)LocalAlloc(LPTR, cbCertLen);
    if (NULL == pbCert)
    {
        lResult = STATUS_NO_MEMORY;
        goto ErrorExit;
    }
    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                pbCert,
                &cbCertLen,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    lResult = BuildCertContext(
        hProv,
        pucPIN,
        pbCert,
        cbCertLen,
        &pCertCtx);
    if (NT_SUCCESS(lResult))
    {
        // The cert context will take care of the crypt context now.
        hProv = NULL;
    }

    //
    // Clean up and return.
    //

ErrorExit:
    *CertificateContext = pCertCtx;

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GETCERT);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbCert)
    {
        LocalFree(pbCert);
    }

    return lResult;
}

/*++

ScHelperGetProvParam:

        This API wraps the CryptGetProvParam routine for use with a smart card.
Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.


        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        The other parameters are identical to CryptGetProvParam


Return Value:

    A STATUS_SUCECSS for success, or an error
--*/

NTSTATUS WINAPI
ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    LogonInfo *pLI;
    CSCLogonInit *LogonInit;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV h = NULL;
    BOOL fSts;

    if (hProv != NULL)
    {
        h = hProv;
    }
    else
    {
        pLI = (LogonInfo *) pbLogonInfo;
        LogonInit = (CSCLogonInit *) pLI->ContextInformation;

        h = LogonInit->CryptCtx(pLI);
        if (NULL == h)
        {
            return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
        }
    }

    fSts = CryptGetProvParam(
            h,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags
            );

    if (!fSts)
    {
        if (GetLastError() == ERROR_NO_MORE_ITEMS)
        {
            return (STATUS_NO_MORE_ENTRIES);
        }
        else
        {
            return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
        }
    }

    return(STATUS_SUCCESS);
}


/*++

ScHelperVerifyCard:

        This API provides an easy way to verify the integrity of the card
        identified by pbLogonInfo (ie, that it has the private key associated
        w/ the public key contained in the certificate it returned via
        ScHelperGetCertFromLogonInfo) and, in so doing, authenticates the user
                to the card.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system default
                store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.


Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.
--*/

NTSTATUS WINAPI
ScHelperVerifyCard(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    PBYTE pbBlob = NULL;
    ULONG ulBlobLen = 32;
    PBYTE pbSignature = NULL;
    ULONG ulSigLen = 0;
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Generate a random key blob as the message to sign
    //

    pbBlob = (LPBYTE)LocalAlloc(LPTR, ulBlobLen);
    if (NULL == pbBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGenRandom(hProv, ulBlobLen, pbBlob);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // The card signs a hash of the message...
    //

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (STATUS_BUFFER_TOO_SMALL != lResult)
    {
        goto ErrorExit;
    }

    pbSignature = (LPBYTE)LocalAlloc(LPTR, ulSigLen);

    if (NULL == pbSignature)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    //
    // Verify the signature is correct
    //

    lResult = ScHelperVerifyMessage(
                pbLogonInfo,
                NULL,
                CertificateContext,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                ulSigLen);

    //
    // Clean up and return.
    //

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYCARD);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != pbSignature)
    {
        LocalFree(pbSignature);
    }
    if (NULL != pbBlob)
    {
            LocalFree(pbBlob);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperGenRandBits(
    IN PBYTE pbLogonInfo,
    IN OUT ScHelper_RandomCredBits* psc_rcb
)
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts = FALSE;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(psc_rcb, 0, sizeof(*psc_rcb));
    fSts = CryptGenRandom(hProv, 32, psc_rcb->bR1);

    if (fSts)
    {
        fSts = CryptGenRandom(hProv, 32, psc_rcb->bR2);
    }

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GENRANDBITS);
    }

    return lResult;
}


/*++

ScHelperCreateCredKeys:

    This routine (called by ScHelperVerifyCardAndCreds and
    ScHelperEncryptCredentials) munges a R1 and R2 to derive symmetric keys
    for encrypting and decrypting KDC creds, and or genearting an HMAC.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        psc_rcb supplies the R1 and R2, previously generated by a call to
                ScHelperGenRandBits.

        phHmacKey recieves the generated HMAC key.

        phRc4Key receives the generated RC4 key.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Amanda Matlosz (amatlosz) 6/23/1999

--*/

NTSTATUS WINAPI
ScHelperCreateCredKeys(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN ScHelper_RandomCredBits* psc_rcb,
    IN OUT HCRYPTKEY* phHmacKey,
    IN OUT HCRYPTKEY* phRc4Key,
    IN OUT HCRYPTPROV* phProv
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    PBYTE pbR1Sig = NULL;
    DWORD dwR1SigLen = 0;
    HCRYPTHASH hKHash = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts = FALSE;
    *phProv = NULL;

    // check params

    if (NULL == psc_rcb || NULL == phHmacKey || NULL == phRc4Key)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Get hProv for smart card

    if (NULL != pucPIN)
    {
        if (!szPin.Valid())
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // Sign R1 w/ smart card

    fSts = CryptCreateHash(
        hProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hHash);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
                hHash,
                psc_rcb->bR1,
                32, // TODO: const
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Declare the PIN.
    //

    if (NULL != pucPIN)
    {
        fSts = CryptSetProvParam(
                hProv,
                PP_KEYEXCHANGE_PIN,
                (LPBYTE)((LPCSTR)szPin),
                0);
        if (!fSts)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        NULL,
        &dwR1SigLen);
//  if (fSts || ERROR_MORE_DATA != GetLastError())
    if (0 >= dwR1SigLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    pbR1Sig = (LPBYTE)LocalAlloc(LPTR, dwR1SigLen);

    if (NULL == pbR1Sig)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        pbR1Sig,
        &dwR1SigLen);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // TODO: sigR1 is the key to hash R2 with;
    // for now, just hash 'em together; use generic CSP
    fSts = CryptAcquireContext(
        phProv,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptCreateHash(
        *phProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hKHash
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        pbR1Sig,
        dwR1SigLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        psc_rcb->bR2,
        32, // TODO: use a const
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the rc4 key for the cred&hmac encryption

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC4, // stream cipher,
        hKHash,
        NULL,
        phRc4Key
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the key for the HMAC from the hash of R1&2

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC2,
        hKHash,
        NULL,
        phHmacKey
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    //
    // cleanup
    //

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    if (NULL != hKHash)
    {
        CryptDestroyHash(hKHash);
    }

    if (NULL != pbR1Sig)
    {
        LocalFree(pbR1Sig);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperCreateCredHMAC(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hHmacKey,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    IN OUT PBYTE* ppbHmac,
    IN OUT DWORD* pdwHmacLen
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHMAC = NULL;
    HMAC_INFO hmac_info;
    BOOL fSts = FALSE;

    fSts = CryptCreateHash(
        hProv,
        CALG_HMAC,
        hHmacKey,
        NULL,
        &hHMAC
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(&hmac_info, 0, sizeof(HMAC_INFO));
    hmac_info.HashAlgid = CALG_SHA1;

    fSts = CryptSetHashParam(
        hHMAC,
        HP_HMAC_INFO,
        (PBYTE)&hmac_info,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hHMAC,
        CleartextData,
        CleartextDataSize,
        NULL);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (0 >= *pdwHmacLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    *ppbHmac = (PBYTE)LocalAlloc(LPTR, *pdwHmacLen);

    if (NULL == *ppbHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (NULL != hHMAC)
    {
        CryptDestroyHash(hHMAC);
    }

    return lResult;
}

/*++

ScHelperVerifyCardAndCreds:

    This routine combines Card Verification and Credential Decryption.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the size of the EncryptedData buffer in
            bytes, and receives the actual size of the encrypted blob.

        CleartextData supplies a credential blob to be encrypted.

        CleartextDataSize supplies the size of the blob, in bytes.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;

    // Verify the Card

    lResult = ScHelperVerifyCard(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo);

    // Decrypt the Creds

    if (NT_SUCCESS(lResult))
    {
        lResult = ScHelperDecryptCredentials(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo,
                EncryptedData,
                EncryptedDataSize,
                CleartextData,
                CleartextDataSize);
    }

    return lResult;
}




/*++

ScHelperDecryptCredentials:

    This routine decrypts an encrypted credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        EncryptedData supplies the encrypted credential blob.

        EncryptedDataSize supplies the length of the encrypted credential blob,
            in bytes.

        CleartextData receives the decrypted credential blob.

        CleartextDataSize supplies the length of the CleartextData buffer, and
            receives the actual length of returned decrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to CleartextData to receive only the
    required size of the buffer in CleartextDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperDecryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    PBYTE pbCredBlob = NULL;
    DWORD dwCredBlobSize = 0;
    PBYTE pbHmac = NULL;        // the HMAC stored with the cred blob
    DWORD dwHmacSize = NULL;    // size of HMAC stored with cred blob
    PBYTE pbNewHmac = NULL;     // HMAC generated from cred blob for verify
    DWORD dwNewHmacSize = 0;    // size of gen'd HMAC
    PBYTE pb = NULL;
    DWORD dw = 0;
    PBYTE pbPlainCred = NULL;
    DWORD dwPlainCredSize = 0;
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    HCRYPTPROV hGenProv = NULL;
    BOOL fSts = FALSE;


    // pull the SCH_RCB out of the EncryptedData blob
    ScHelper_RandomCredBits* psch_rcb = (ScHelper_RandomCredBits*)EncryptedData;
    // and build a private copy of the blob itself
    dwCredBlobSize = EncryptedDataSize - sizeof(ScHelper_RandomCredBits);
    pbCredBlob = (PBYTE)LocalAlloc(LPTR, dwCredBlobSize);
    if (NULL == pbCredBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = EncryptedData + sizeof(ScHelper_RandomCredBits);
    CopyMemory(pbCredBlob, pb, dwCredBlobSize);


    //
    // Fetch the keys we need to decrypt & verify the cred blob
    //

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hGenProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // Decrypt the cred blob
    //

    fSts = CryptDecrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredBlob,
        &dwCredBlobSize);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // pull the HMAC out & verify it
    //

    dwHmacSize = (DWORD)*pbCredBlob;
    pbHmac = pbCredBlob + sizeof(DWORD);
    pbPlainCred = pbCredBlob + dwHmacSize + sizeof(DWORD);
    dwPlainCredSize = dwCredBlobSize - dwHmacSize - sizeof(DWORD);


    lResult = ScHelperCreateCredHMAC(
        hGenProv,
        hHmacKey,
        pbPlainCred,
        dwPlainCredSize,
        &pbNewHmac,
        &dwNewHmacSize);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    if (dwNewHmacSize == dwHmacSize)
    {
        for (dw = 0;
            (dw < dwNewHmacSize) && ((BYTE)*(pbHmac+dw)==(BYTE)*(pbNewHmac+dw));
            dw++);
        if (dwNewHmacSize == dw)
        {
            // verification succeeded!
            lResult = STATUS_SUCCESS;
        }
    }
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // return the decrypted blob or just its length, as necessary
    //

    if ((NULL != CleartextData) && (0 < *CleartextDataSize))
    {
        if (*CleartextDataSize >= dwPlainCredSize)
        {
            CopyMemory(CleartextData, pbPlainCred, dwPlainCredSize);
        }
        else
            lResult = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *CleartextDataSize = dwPlainCredSize;

    //
    // Cleanup and return
    //
ErrorExit:

    if (NULL != pbNewHmac)
    {
        LocalFree(pbNewHmac);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hGenProv)
    {
        CryptReleaseContext(hGenProv, NULL);
    }

    return lResult;
}


/*++

ScHelperEncryptCredentials:

    This routine encrypts a credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        CleartextData supplies the cleartext credential blob.

        CleartextDataSize supplies the length of the cleartext credential blob,
            in bytes.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the length of the EncryptedData buffer, and
            receives the actual length of returned encrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the buffer in EncryptedDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/


NTSTATUS WINAPI
ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;

    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    ULONG SignedEncryptedCredSize = 0;
    PBYTE SignedEncryptedCred = NULL; // encrypted cred&sig, !including R1+R2
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    PBYTE pbHmac = NULL;
    DWORD dwHmacLen = 0;
    PBYTE pbCredsAndHmac  = NULL;
    DWORD dwCredsAndHmacLen = 0;
    DWORD dwEncryptedCredSize = 0;
    PBYTE pb = NULL;

    // parameter checking?


    //
    // do stuff to determine size required for SignedEncryptedCred
    //

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    // HMAC creds
    lResult = ScHelperCreateCredHMAC(
        hProv,
        hHmacKey,
        CleartextData,
        CleartextDataSize,
        &pbHmac,
        &dwHmacLen);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    // make a buffer with creds and HMAC

    pbCredsAndHmac = NULL;
    dwCredsAndHmacLen = dwHmacLen + CleartextDataSize + sizeof(DWORD);
    pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
    if (NULL == pbCredsAndHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = pbCredsAndHmac;
    CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
    pb += sizeof(DWORD);
    CopyMemory(pb, pbHmac, dwHmacLen);
    pb += dwHmacLen;
    CopyMemory(pb, CleartextData, CleartextDataSize);

    // Encrypt creds+HMAC
    dwEncryptedCredSize = dwCredsAndHmacLen;

    // After CryptEncrypt, dwCredsAndHmacLen describes the length of the data
    // to encrypt and dwEncryptedCredSize describes the req'd buffer length

    // TODO: VERIFY THE HANDLING OF dwEncryptedCredSize and dwCresAndHmacLen

    fSts = CryptEncrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredsAndHmac,
        &dwEncryptedCredSize,
        dwCredsAndHmacLen
        );
    if (!fSts)
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // Create the final blob for return, or inform user of size, as necessary
    //

    if ((NULL != EncryptedData) && (0 < *EncryptedDataSize))
    {

        if (*EncryptedDataSize >= dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits))
        {
            // the user gave us enough space for the whole thing.

            // if the previous CryptEncrypt failed with ERROR_MORE_DATA
            // we can now do something about it...
            if (!fSts)
            {
                // resize pbCredsAndHmac
                LocalFree(pbCredsAndHmac);
                pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
                if (NULL == pbCredsAndHmac)
                {
                    lResult = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
                // reset pbCredsAndHmac
                pb = pbCredsAndHmac;
                CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
                pb += sizeof(DWORD);
                CopyMemory(pb, pbHmac, dwHmacLen);
                pb += dwHmacLen;
                CopyMemory(pb, CleartextData, CleartextDataSize);
                // re-encrypt CredsAndHmac
                fSts = CryptEncrypt(
                    hRc4Key,
                    NULL,
                    TRUE,
                    NULL,
                    pbCredsAndHmac,
                    &dwCredsAndHmacLen, // length of data
                    dwEncryptedCredSize // length of buffer
                    );
                if (!fSts)
                {
                    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                    goto ErrorExit;
                }
            }

            pb = EncryptedData;

            CopyMemory(pb, (PBYTE)psch_rcb, sizeof(ScHelper_RandomCredBits));
            pb += sizeof(ScHelper_RandomCredBits);
            CopyMemory(pb, pbCredsAndHmac, dwCredsAndHmacLen);

        }
        else
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *EncryptedDataSize = dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits);

ErrorExit:

    // clean up!

    if (NULL != pbCredsAndHmac)
    {
        LocalFree(pbCredsAndHmac);
    }

    if (NULL != pbHmac)
    {
        LocalFree(pbHmac);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, NULL);
    }

    return lResult;
}


/*++

ScHelperSignMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        if (NULL != pucPIN)
        {
            if (!szPin.Valid())
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
            hProv,
            Algorithm,
            NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
            0,  // reserved for future use
            &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    if (!ARGUMENT_PRESENT(Provider))
    {
        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }

    //
    // OK, sign it with the exchange key from the smart card or the supplied signature key. ????
    //

    fSts = CryptSignHash(
                hHash,
                AT_KEYEXCHANGE,
                NULL,
                0,
                Signature,
                SignatureLength);
    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_SIGNMSG_NOSC:EVENT_ID_SIGNMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    return lResult;
}


/*++

ScHelperVerifyMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    )
{
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;


    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // Convert the certificate handle into a Public Key handle.
    //

    fSts = CryptImportPublicKeyInfo(
                hProv,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CertificateContext->pCertInfo->SubjectPublicKeyInfo,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
                hProv,
                Algorithm,
                NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
                0,  // reserved for future use
                &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // So is this signature any good?
    //

    fSts = CryptVerifySignature(
                hHash,
                Signature,
                SignatureLength,
                hKey,
                NULL,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_VERIFYMSG_NOSC:EVENT_ID_VERIFYMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }

    return lResult;
}

/*++

ScHelperSignPkcsMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_SIGN_MESSAGE_PARA Parameter = {0};
    CUnicodeString szPin(pucPIN);
    const BYTE * BufferArray = Buffer;

    if (NULL != pucPIN)
    {
        if (!szPin.Valid())
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }


    //
    // Sign the message
    //

    Parameter.cbSize = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    Parameter.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.pSigningCert = Certificate;
    Parameter.HashAlgorithm = *Algorithm;
    Parameter.cMsgCert = 1;
    Parameter.rgpMsgCert = &Certificate;
    Parameter.dwFlags = dwSignMessageFlags;


    fSts = CryptSignMessage(
            &Parameter,
            FALSE,              // no detached signature
            1,                  // one buffer to sign
            &BufferArray,
            &BufferLength,
            SignedBuffer,
            SignedBufferLength);

    if (!fSts)
    {
        switch (GetLastError())
        {
        case ERROR_MORE_DATA:
            lResult = STATUS_BUFFER_TOO_SMALL;
            break;
        case NTE_SILENT_CONTEXT:
            lResult = STATUS_SMARTCARD_SILENT_CONTEXT;
            break;
        default:
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }

        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_SIGNMSG);
    }

    return lResult;
}


/*++

ScHelperVerifyPkcsMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    )
{
    CRYPT_VERIFY_MESSAGE_PARA Parameter = {0};
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;

    Parameter.cbSize = sizeof(CRYPT_VERIFY_MESSAGE_PARA);
    Parameter.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.hCryptProv = NULL;

    //
    // Indicate that we want to get the certificate from the message
    // cert store.
    //

    Parameter.pfnGetSignerCertificate = NULL;
    fSts = CryptVerifyMessageSignature(
                &Parameter,
                0,              // only check first signer
                Buffer,
                BufferLength,
                DecodedBuffer,
                DecodedBufferLength,
                CertificateContext
                );

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYMSG);

    }

    return lResult;
}

/*++

ScHelperEncryptMessage:

    Encrypts a message with the public key associated w/ the provided
        certificate.  The resultant encoding is PKCS-7 compliant.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        Either pbLogonInfo or Provided must be set; if both are set,
        Provider is used.

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperEncryptMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN PBYTE Buffer,                        // The data to encrypt
    IN ULONG BufferLength,                  // The length of that data
    OUT PBYTE CipherText,                   // Receives the formatted CipherText
    IN PULONG pCipherLength                 // Supplies size of CipherText buffer
    )                                       // Receives length of actual CipherText
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cbEncryptParaSize = 0;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }


    //
    // Encrypt the message
    //

    cbEncryptParaSize = sizeof(EncryptPara);
    memset(&EncryptPara, 0, cbEncryptParaSize);
    EncryptPara.cbSize = cbEncryptParaSize;
    EncryptPara.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    EncryptPara.hCryptProv = hProv;
    EncryptPara.ContentEncryptionAlgorithm = *Algorithm;

    fSts = CryptEncryptMessage(
            &EncryptPara,
            1,
            &CertificateContext,
            Buffer,
            BufferLength,
            CipherText,
            pCipherLength);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_ENCMSG_NOSC:EVENT_ID_ENCMSG)
            );
    }

    return lResult;
}


/*++

ScHelperDecryptMessage :

    Deciphers a PKCS-7 encoded message with the private key associated
        w/ the provided certificate.

Arguments:

        Either pbLogonInfo or Provider must be set; if both are set,
        Provider is used.


Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        ** CertificateContext subtleties: **

        CryptDecryptMessage takes as a parameter a pointer to a certificate store;
        it will use the first appropriate certificate context it finds in that
        store to perform the decryption.  In order to make this call, we create a
        CertificateStore in memory, and add the provided CertificateContext to it.

        CertAddCertificateContextToStore actually places a copy of the certificate
        context in the store.  In so doing, it strips off any properties that are
        not permanent -- if a HCRYPTPROV is associated with the KeyContext of the
        source CertificateContext, it will NOT be associated with the KeyContext
        of the cert context in the store.

        Although this is appropriate behavior in most cases, we need that property
        to be kept intact when dealing with Smart Card CSPs (to avoid surprise
        "Insert PIN" dialogs), so after adding the CertificateContext to the store,
        we turn around and get the CERT_KEY_CONTEXT_PROP_ID from the source
        certcontext and (re)set it on the certcontext in the memory store.

        ** Algorithm notes: **

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        for example: CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    PCCERT_CONTEXT pStoreCertContext = NULL;
    HCERTSTORE hCertStore = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    CERT_KEY_CONTEXT CertKeyContext;
    DWORD cbData = sizeof(CERT_KEY_CONTEXT); // PhilH swears this will not grow!
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        if (NULL != pucPIN)
        {
            if (!szPin.Valid())
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN )
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }

    //
    // Open a temporary certstore to hold this certcontext
    //

    hCertStore = CertOpenStore(
                            CERT_STORE_PROV_MEMORY,
                            0, // not applicable
                            hProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG, // auto-release hProv NOT OK
                            NULL);

    if (NULL == hCertStore)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CertAddCertificateContextToStore(
            hCertStore,
            CertificateContext,
            CERT_STORE_ADD_ALWAYS,
            &pStoreCertContext);

    //
    // NOW WE NEED TO RESET THE KEY CONTEXT PROPERTY ON THIS CERTCONTEXT
        // IN THE MEMORY STORE (see function header/notes) AS APPROPRIATE
        //
        // ie, IFF the certcontext we were give has the key_context property,
        // reset it (and fail if the resetting doesn't work)
        //
    fSts = CertGetCertificateContextProperty(
                CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                (void *)&CertKeyContext,
                &cbData);

        if (TRUE == fSts)
        {
                fSts = CertSetCertificateContextProperty(
                                        pStoreCertContext,
                                        CERT_KEY_CONTEXT_PROP_ID,
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG, // no auto-release hProv!
                                        (void *)&CertKeyContext);

                if (!fSts)
                {
                        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                        goto ErrorExit;
                }
        }

    //
    // Decrypt the message
    //

    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;
    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    DecryptPara.cCertStore = 1;
    DecryptPara.rghCertStore = &hCertStore;

    fSts = CryptDecryptMessage(
            &DecryptPara,
            CipherText,
            CipherLength,
            ClearText,
            pClearLength,
            NULL);

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_DECMSG_NOSC:EVENT_ID_DECMSG)
            );
    }

    if (hCertStore != NULL)
    {
        fSts = CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        if (!fSts)
        {
            if (!NT_SUCCESS(lResult))
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\sclogon2\unicodes.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    unicodes

Abstract:

    This module implements the CUnicodeString class.  This class allows a string
    to automatically convert between PUNICODE_STRING, LPCSTR, and LPCWSTR.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#include <windows.h>
#include <wincrypt.h>
#include <crtdbg.h>
#include "scLogon.h"
#include "unicodes.h"


//
// Piddly routines.
//

CUnicodeString::CUnicodeString(
    void)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
}

CUnicodeString::CUnicodeString(
    LPCSTR sz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(sz);
}

CUnicodeString::CUnicodeString(
    LPCWSTR wsz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(wsz);
}

CUnicodeString::CUnicodeString(
    PUNICODE_STRING pus)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(pus);
}

CUnicodeString::~CUnicodeString()
{
    if (NULL != m_szAnsi)
    {
        memset(m_szAnsi, 0, lstrlenA(m_szAnsi));
        LocalFree(m_szAnsi);
    }
    if (NULL != m_wszUnicode)
    {
        memset(m_wszUnicode, 0, lstrlenW(m_wszUnicode)*sizeof(WCHAR));
        LocalFree(m_wszUnicode);
    }
}

PUNICODE_STRING
CUnicodeString::Set(
    PUNICODE_STRING pus)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    m_fFlags = fNoneGood;
    if (pus != NULL)
    {
        m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, pus->Length + sizeof(WCHAR));
        if (m_wszUnicode != NULL)
        {
            CopyMemory(
                m_wszUnicode,
                pus->Buffer,
                pus->Length
                );
            m_wszUnicode[pus->Length/sizeof(WCHAR)] = L'\0';
            m_fFlags = fUnicodeGood;
        }
    }
    return pus;
}


/*++

Set:

    These methods initialize the object to a given string.

Arguments:

    sz - Supplies an ANSI string with which to initialize the object.

    wsz - Supplies a UNICODE string with which to initialize the object.

    pus - Supplies a pointer to a UNICODE_STRING structure from which to
        initialize the object.

Return Value:

    The same value as was provided.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Set(
    LPCSTR sz)
{
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    if (NULL != m_szAnsi)
        LocalFree(m_szAnsi);
    m_fFlags = fNoneGood;

    m_szAnsi = (LPSTR)LocalAlloc(LPTR, (lstrlenA(sz) + 1) * sizeof(CHAR));
    if (NULL != m_szAnsi)
    {
        lstrcpyA(m_szAnsi, sz);
        m_fFlags = fAnsiGood;
    }
    return m_szAnsi;
}

LPCWSTR
CUnicodeString::Set(
    LPCWSTR wsz)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
        LocalFree(m_wszUnicode);
    m_fFlags = fNoneGood;
    m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(wsz) + 1) * sizeof(WCHAR));
    if (m_wszUnicode != NULL)
    {
        lstrcpyW(m_wszUnicode, wsz);
        m_fFlags = fUnicodeGood;
    }
    return m_wszUnicode;
}

CUnicodeString::operator PUNICODE_STRING(
    void)
{
    m_us.Buffer = (LPWSTR)Unicode();
    m_us.Length = m_us.MaximumLength = (USHORT)(lstrlenW(m_us.Buffer) * sizeof(WCHAR));
    return &m_us;
}


/*++

Unicode:

    This method ensures that the object has a valaid internal UNICODE
    representation.

Arguments:

    None

Return Value:

    The represented string, in UNICODE format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCWSTR
CUnicodeString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        _ASSERTE(NULL != m_szAnsi);
        length =
            MultiByteToWideChar(
                GetACP(),
                MB_PRECOMPOSED,
                m_szAnsi,
                -1,
                NULL,
                0);
        if (NULL != m_wszUnicode)
        {
            LocalFree(m_wszUnicode);
        }
        if (0 != length)
        {
            m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
            if (m_wszUnicode == NULL)
            {
                break;
            }
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    m_szAnsi,
                    -1,
                    m_wszUnicode,
                    length);
            m_wszUnicode[length] = 0;
        }
        else
        {
            m_wszUnicode = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    case fNoneGood:
    default:
        // Internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_wszUnicode;
}


/*++

Ansi:

    This method ensures that the object has a valaid internal ANSI
    representation.

Arguments:

    None

Return Value:

    The represented string, in ANSI format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        length =
            WideCharToMultiByte(
                GetACP(),
                0,
                m_wszUnicode,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        if (NULL != m_szAnsi)
        {
            LocalFree(m_szAnsi);
        }

        if (0 != length)
        {
            m_szAnsi = (LPSTR)LocalAlloc(LPTR, (length + 1) * sizeof(CHAR));
            if (m_szAnsi == NULL)
            {
                break;
            }
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    m_wszUnicode,
                    -1,
                    m_szAnsi,
                    length,
                    NULL,
                    NULL);
            m_szAnsi[length] = 0;
        }
        else
        {
            m_szAnsi = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    case fNoneGood:
    default:
        // An internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_szAnsi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\sclogon2\sclogon2.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScLogon2

Abstract:



Author:

    reidk

Environment:

    Win32, C++ w/ Exceptions

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes

#if !defined(_X86_) && !defined(_AMD64_) && !defined(_IA64_)
#define _X86_ 1
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#ifndef UNICODE
#define UNICODE
#endif
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <windows.h>
#include <winscard.h>
#include <wincrypt.h>
#include <softpub.h>
#include <stddef.h>
#include <crtdbg.h>
#include "sclogon.h"
#include "sclogon2.h"
#include "unicodes.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <tchar.h>

#include "sclgnrpc.h"


typedef struct _KERB_PUBLIC_KEY_HPROV {
    RPC_BINDING_HANDLE hRPCBinding;
    BINDING_CONTEXT  hCertAndKey;
} KERB_PUBLIC_KEY_HPROV, *PKERB_PUBLIC_KEY_HPROV;


//
// from secpkg.h
//
typedef NTSTATUS (NTAPI LSA_IMPERSONATE_CLIENT) (VOID);
typedef LSA_IMPERSONATE_CLIENT * PLSA_IMPERSONATE_CLIENT;


bool
GetImpersonationToken(HANDLE *phThreadToken)
{
    bool ret = false;

    //
    // This will fail if not impersonating.
    //
    if (OpenThreadToken(
            GetCurrentThread(),
            TOKEN_IMPERSONATE | TOKEN_QUERY,
            TRUE,
            phThreadToken))
    {
        ret = true;
    }
    else if (GetLastError() == ERROR_NO_TOKEN)
    {
        ret = true;
    }
    else
    {
        DbgPrint("OpenThreadToken failed - %lx\n", GetLastError());
    }

    return (ret);
}

DWORD
GetTSSessionID(HANDLE hThreadToken)
{
    bool                    fRet                    = false;
    PLIST_ENTRY             Module;
    PLDR_DATA_TABLE_ENTRY   Entry;
    BOOL                    fRunningInLsa           = false;
    HMODULE                 hLsa                    = NULL;
    PLSA_IMPERSONATE_CLIENT pLsaImpersonateClient   = NULL;
    bool                    bImpersonating          = false;
    HANDLE                  hLocalThreadToken       = INVALID_HANDLE_VALUE;
    DWORD                   dwTSSessionID           = 0;
    DWORD                   dwSize;
    bool                    fAlreadyImpersonating;

    //
    // Make sure we are running in LSA
    //
    Module = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink;
    Entry = CONTAINING_RECORD(Module,
                                LDR_DATA_TABLE_ENTRY,
                                InLoadOrderLinks);

    fRunningInLsa = (0 == _wcsicmp(Entry->BaseDllName.Buffer, L"lsass.exe"));

    if (!fRunningInLsa)
    {
        return (0);
    }

    //
    // Check to see if we are already impersonating by checking the thread token passed in
    //
    if(hThreadToken == INVALID_HANDLE_VALUE)
    {
        //
        // If we aren't already impernonating, then we need to call the special LssImpersonateClient
        //
        hLsa = GetModuleHandleW(L"lsasrv.dll");
        if (hLsa == NULL)
        {
            DbgPrint("failed to get lsa module handle\n");
            goto Return;
        }

        pLsaImpersonateClient = (PLSA_IMPERSONATE_CLIENT) GetProcAddress(hLsa, "LsaIImpersonateClient");
        if (pLsaImpersonateClient == NULL)
        {
            DbgPrint("failed to get proc address\n");
            goto Return;
        }

        if (pLsaImpersonateClient() != STATUS_SUCCESS)
        {
            DbgPrint("failed to impersonate\n");
            goto Return;
        }
        bImpersonating = true;

        if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                FALSE,
                &hLocalThreadToken))
        {
            DbgPrint("OpenThreadToken failed\n");
            goto Return;
        }
    }

    //
    // see if the calling thread token has a TS session ID...
    // if so, then we are being called on behalf of a process in a TS session
    //
    if (!GetTokenInformation(
                (hThreadToken == INVALID_HANDLE_VALUE) ? hLocalThreadToken : hThreadToken,
                TokenSessionId,
                &dwTSSessionID,
                sizeof(dwTSSessionID),
                &dwSize))
    {
        DbgPrint("GetTokenInformation failed\n");
    }

Return:

    if (hLocalThreadToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hLocalThreadToken);
    }

    if (bImpersonating)
    {
        RevertToSelf();
    }

    return (dwTSSessionID);
}

void
_TeardownRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding)
{
    __try
    {
        RpcBindingFree(phRPCBinding);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DbgPrint("Exception occurred during RpcBindingFree - %lx\n", _exception_code());
    }
}


NTSTATUS
_SetupRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding,
    HANDLE                hThreadToken)
{
    LPWSTR                      pStringBinding          = NULL;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    DWORD                       dwTSSessionID           = 0;
    WCHAR                       wszLocalEndpoint[256];
    LPWSTR                      pwszLocalEndpoint       = NULL;
    RPC_SECURITY_QOS            RpcSecurityQOS;
    SID_IDENTIFIER_AUTHORITY    SIDAuth                 = SECURITY_NT_AUTHORITY;
    PSID                        pSID                    = NULL;
    WCHAR                       szName[64]; // SYSTEM
    DWORD                       cbName                  = 64;
    WCHAR                       szDomainName[256]; // max domain is 255
    DWORD                       cbDomainName            = 256;
    SID_NAME_USE                Use;

    //
    // Get the ID of the winlogon RPC server to connect to
    //
    dwTSSessionID = GetTSSessionID(hThreadToken);

    if (dwTSSessionID != 0)
    {
        wsprintfW(
            wszLocalEndpoint,
            SZ_ENDPOINT_NAME_FORMAT,
            SCLOGONRPC_LOCAL_ENDPOINT,
            dwTSSessionID);

        pwszLocalEndpoint = wszLocalEndpoint;
    }
    else
    {
        pwszLocalEndpoint = SCLOGONRPC_LOCAL_ENDPOINT;
    }

    //
    // get a binding handle
    //
    if (RPC_S_OK != (rpcStatus = RpcStringBindingComposeW(
                            NULL,
                            SCLOGONRPC_LOCAL_PROT_SEQ,
                            NULL, //LPC - no machine name
                            pwszLocalEndpoint,
                            0,
                            &pStringBinding)))
    {
        DbgPrint("RpcStringBindingComposeW failed\n");

        status = I_RpcMapWin32Status(rpcStatus);
        //
        // if I_RpcMapWin32Status() can't map the error code it returns
        // the same error back, so check for that
        //
        if (status == rpcStatus)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto Return;
    }

    if (RPC_S_OK != (rpcStatus = RpcBindingFromStringBindingW(
                            pStringBinding,
                            phRPCBinding)))
    {
        DbgPrint("RpcBindingFromStringBindingW failed\n");
        status = I_RpcMapWin32Status(rpcStatus);
        //
        // if I_RpcMapWin32Status() can't map the error code it returns
        // the same error back, so check for that
        //
        if (status == rpcStatus)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto Return;
    }

    if (RPC_S_OK != (rpcStatus = RpcEpResolveBinding(
                            *phRPCBinding,
                            IRPCSCLogon_v1_0_c_ifspec)))
    {
        DbgPrint("RpcEpResolveBinding failed\n");
        status = I_RpcMapWin32Status(rpcStatus);
        //
        // if I_RpcMapWin32Status() can't map the error code it returns
        // the same error back, so check for that
        //
        if (status == rpcStatus)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        _TeardownRPCConnection(phRPCBinding);
        goto Return;
    }

    //
    // Set the autorization so that we will only call a Local System process
    //
    memset(&RpcSecurityQOS, 0, sizeof(RpcSecurityQOS));
    RpcSecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    RpcSecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    RpcSecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
    RpcSecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;

   if (AllocateAndInitializeSid(&SIDAuth, 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSID) == 0)
    {
        DbgPrint("AllocateAndInitializeSid failed\n");
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Return;
    }

    if (LookupAccountSid(NULL,
                         pSID,
                         szName,
                         &cbName,
                         szDomainName,
                         &cbDomainName,
                         &Use) == 0)
    {
        DbgPrint("LookupAccountSid failed\n");
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Return;
    }

    if (RPC_S_OK != (rpcStatus = RpcBindingSetAuthInfoEx(
                            *phRPCBinding,
                            szName,
                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                            RPC_C_AUTHN_WINNT,
                            NULL,
                            0,
                            &RpcSecurityQOS)))
    {
        DbgPrint("RpcBindingSetAuthInfoEx failed\n");
        status = I_RpcMapWin32Status(rpcStatus);
        goto Return;
    }

Return:
    if (pStringBinding != NULL)
    {
        RpcStringFreeW(&pStringBinding);
    }

    if (pSID != NULL)
    {
        FreeSid( pSID );
    }

    return (status);
}


typedef struct _SCLOGON_PIPE
{
    RPC_BINDING_HANDLE  hRPCBinding;
    BINDING_CONTEXT     BindingContext;
} SCLOGON_PIPE;


///////////////////////////////////////////////////////////////////////////////
//
// ScLogon APIs
//


//***************************************************************************************
//
// __ScHelperInitializeContext:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    )
{
    SCLOGON_PIPE    *pSCLogonPipe;
    NTSTATUS        status                  = STATUS_SUCCESS;
    BOOL            fRPCBindingInitialized  = FALSE;
    LogonInfo       *pLI                    = (LogonInfo *)pbLogonInfo;

    if ((cbLogonInfo < sizeof(ULONG)) ||
        (cbLogonInfo != pLI->dwLogonInfoLen))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    pLI->ContextInformation = malloc(sizeof(SCLOGON_PIPE));
    if (pLI->ContextInformation == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pSCLogonPipe = (SCLOGON_PIPE *) pLI->ContextInformation;

    status = _SetupRPCConnection(&(pSCLogonPipe->hRPCBinding), INVALID_HANDLE_VALUE);
    if (!NT_SUCCESS(status))
    {
        goto ErrorReturn;
    }
    fRPCBindingInitialized = TRUE;

    pSCLogonPipe->BindingContext = NULL;

    __try
    {
        status = RPC_ScHelperInitializeContext(
                    pSCLogonPipe->hRPCBinding,
                    cbLogonInfo,
                    pbLogonInfo,
                    &(pSCLogonPipe->BindingContext));
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperInitializeContext - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        DbgPrint("RPC_ScHelperInitializeContext failed - %lx\n", status);
        goto ErrorReturn;
    }

Return:

    return (status);

ErrorReturn:

    if (pSCLogonPipe != NULL)
    {
        if (fRPCBindingInitialized)
        {
            _TeardownRPCConnection(&(pSCLogonPipe->hRPCBinding));
        }

        free(pSCLogonPipe);
    }

    goto Return;
}


//***************************************************************************************
//
// __ScHelperRelease:
//
//***************************************************************************************
VOID WINAPI
__ScHelperRelease(
    IN OUT PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE * pSCLogonPipe = (SCLOGON_PIPE *) pLI->ContextInformation;
    BOOL fReleaseFailed = TRUE;

    if (pSCLogonPipe != NULL)
    {
        __try
        {
            RPC_ScHelperRelease(
                pSCLogonPipe->hRPCBinding,
                &(pSCLogonPipe->BindingContext));

            fReleaseFailed = FALSE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DbgPrint("Exception occurred during RPC_ScHelperRelease - %lx\n", _exception_code());
        }

        //
        // RPC_ScHelperRelease will throw an exception if the winlogon process it is trying
        // to talk to has gone away.  If that is the case, then we need to manually free
        // the BINDING_CONTEXT since it won't get free'd by RPC.
        //
        // NOTE: RPC will free the BINDING_CONTEXT when the server sets it to NULL, which
        // does happen if the RPC_ScHelperRelease function executes
        //
        if (fReleaseFailed)
        {
            __try
            {
                RpcSsDestroyClientContext(&(pSCLogonPipe->BindingContext));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                DbgPrint("Exception occurred during RpcSsDestroyClientContext - %lx\n", _exception_code());
            }
        }

        _TeardownRPCConnection(&(pSCLogonPipe->hRPCBinding));

        free(pSCLogonPipe);
        pLI->ContextInformation = NULL;
    }
}


//***************************************************************************************
//
// __ScHelperGetCertFromLogonInfo:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    PCCERT_CONTEXT  pCertCtx        = NULL;
    OUT_BUFFER1     CertBytes;
    CUnicodeString  szPIN(pucPIN);

    memset(&CertBytes, 0, sizeof(CertBytes));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
        if (!szPIN.Valid())
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Return;
        }
    }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperGetCertFromLogonInfo(
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    &CertBytes);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperGetCertFromLogonInfo - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        DbgPrint("RPC_ScHelperGetCertFromLogonInfo failed - %lx\n", status);
        goto Return;
    }

    //
    // Create the return CertContext based on the bytes returned
    //
    pCertCtx = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CertBytes.pb,
                    CertBytes.cb);
    if (pCertCtx == NULL)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    }

Return:

    if (CertBytes.pb != NULL)
    {
        MIDL_user_free(CertBytes.pb);
    }

    *CertificateContext = pCertCtx;

    return (status);
}


//***************************************************************************************
//
// __ScHelperGetProvParam:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN ULONG_PTR KerbHProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo               *pLI;
    SCLOGON_PIPE            *pSCLogonPipe;
    NTSTATUS                status              = STATUS_SUCCESS;
    CUnicodeString          szPIN(pucPIN);
    OUT_BUFFER1             Data;
    PKERB_PUBLIC_KEY_HPROV  pKerbHProv;
    handle_t                hRPCBinding;
    BINDING_CONTEXT         BindingContext;
    BOOL                    fBindingIsCertAndKey = FALSE;

    //
    // Decide which rpc binding to use
    //
    if (KerbHProv != NULL)
    {
        pKerbHProv              = (PKERB_PUBLIC_KEY_HPROV) KerbHProv;
        hRPCBinding             = pKerbHProv->hRPCBinding;
        BindingContext          = pKerbHProv->hCertAndKey;
        fBindingIsCertAndKey    = TRUE;
    }
    else
    {
        pLI                     = (LogonInfo *)pbLogonInfo;
        pSCLogonPipe            = (SCLOGON_PIPE *) pLI->ContextInformation;
        hRPCBinding             = pSCLogonPipe->hRPCBinding;
        BindingContext          = pSCLogonPipe->BindingContext;
    }

    memset(&Data, 0, sizeof(Data));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
        if (!szPIN.Valid())
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Return;
        }
    }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperGetProvParam(
                    hRPCBinding,
                    BindingContext,
                    (LPCWSTR)szPIN,
                    fBindingIsCertAndKey,
                    dwParam,
                    pdwDataLen,
                    &Data,
                    dwFlags);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        if ((_exception_code() == RPC_S_CALL_FAILED_DNE) ||
            (_exception_code() == RPC_S_SERVER_UNAVAILABLE))
        {
                // Special case to trigger the balloon when the session
                // went away (transfer of credentials case)
            status = STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED;
        }
        else
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        DbgPrint("Exception occurred during RPC_ScHelperGetProvParam - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        DbgPrint("RPC_ScHelperGetProvParam failed - %lx\n", status);
        goto Return;
    }

    //
    // if Data.cb is not 0, then the called is getting back data
    //
    if (Data.cb != 0)
    {
        memcpy(pbData, Data.pb, Data.cb);
    }

Return:

    if (Data.pb != NULL)
    {
        MIDL_user_free(Data.pb);
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperGenRandBits:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperGenRandBits(
    IN PBYTE pbLogonInfo,
    IN OUT ScHelper_RandomCredBits* psc_rcb
)
{
    _ASSERTE(NULL != pbLogonInfo);

    NTSTATUS        status          = STATUS_SUCCESS;
    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;

    __try
    {
        status = RPC_ScHelperGenRandBits(
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    psc_rcb->bR1,
                    psc_rcb->bR2);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperGenRandBits - %lx\n", _exception_code());
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperVerifyCardAndCreds:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER2     CleartextDataBuffer;

    memset(&CleartextDataBuffer, 0, sizeof(CleartextDataBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
        if (!szPIN.Valid())
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Return;
        }
    }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperVerifyCardAndCreds(
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    EncryptedDataSize,
                    EncryptedData,
                    CleartextDataSize,
                    &CleartextDataBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperVerifyCardAndCreds - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        DbgPrint("RPC_ScHelperVerifyCardAndCreds failed - %lx\n", status);
        goto Return;
    }

    //
    // if CleartextData.cb is not 0, then the called is getting back data
    //
    if (CleartextDataBuffer.cb != 0)
    {
        memcpy(CleartextData, CleartextDataBuffer.pb, CleartextDataBuffer.cb);
    }

Return:

    if (CleartextDataBuffer.pb != NULL)
    {
        MIDL_user_free(CleartextDataBuffer.pb);
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperEncryptCredentials:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize)
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER2     EncryptedDataBuffer;

    memset(&EncryptedDataBuffer, 0, sizeof(EncryptedDataBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
        if (!szPIN.Valid())
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Return;
        }
    }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperEncryptCredentials(
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    psch_rcb->bR1,
                    psch_rcb->bR2,
                    CleartextDataSize,
                    CleartextData,
                    EncryptedDataSize,
                    &EncryptedDataBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperEncryptCredentials - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        if (status != STATUS_BUFFER_TOO_SMALL)
        {
            DbgPrint("RPC_ScHelperEncryptCredentials failed - %lx\n", status);
        }
        goto Return;
    }

    //
    // if EncryptedDataBuffer.cb is not 0, then the called is getting back data
    //
    if (EncryptedDataBuffer.cb != 0)
    {
        memcpy(EncryptedData, EncryptedDataBuffer.pb, EncryptedDataBuffer.cb);
    }

Return:

    if (EncryptedDataBuffer.pb != NULL)
    {
        MIDL_user_free(EncryptedDataBuffer.pb);
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperSignMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL ULONG_PTR KerbHProv,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    )
{
    LogonInfo               *pLI;
    SCLOGON_PIPE            *pSCLogonPipe;
    NTSTATUS                status          = STATUS_SUCCESS;
    CUnicodeString          szPIN(pucPIN);
    OUT_BUFFER2             SignatureBuffer;
    PKERB_PUBLIC_KEY_HPROV  pKerbHProv;
    handle_t                hRPCBinding;
    BINDING_CONTEXT         BindingContext;
    BOOL                    fBindingIsCertAndKey = FALSE;

    //
    // Decide which rpc binding to use
    //
    if (KerbHProv != NULL)
    {
        pKerbHProv              = (PKERB_PUBLIC_KEY_HPROV) KerbHProv;
        hRPCBinding             = pKerbHProv->hRPCBinding;
        BindingContext          = pKerbHProv->hCertAndKey;
        fBindingIsCertAndKey    = TRUE;
    }
    else
    {
        pLI                     = (LogonInfo *)pbLogonInfo;
        pSCLogonPipe            = (SCLOGON_PIPE *) pLI->ContextInformation;
        hRPCBinding             = pSCLogonPipe->hRPCBinding;
        BindingContext          = pSCLogonPipe->BindingContext;
    }

    memset(&SignatureBuffer, 0, sizeof(SignatureBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
        if (!szPIN.Valid())
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Return;
        }
    }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperSignMessage(
                    hRPCBinding,
                    BindingContext,
                    (LPCWSTR)szPIN,
                    fBindingIsCertAndKey,
                    Algorithm,
                    BufferLength,
                    Buffer,
                    SignatureLength,
                    &SignatureBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperSignMessage - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        DbgPrint("RPC_ScHelperSignMessage failed - %lx\n", status);
        goto Return;
    }

    //
    // if SignatureBuffer.cb is not 0, then the called is getting back data
    //
    if (SignatureBuffer.cb != 0)
    {
        memcpy(Signature, SignatureBuffer.pb, SignatureBuffer.cb);
    }

Return:

    if (SignatureBuffer.pb != NULL)
    {
        MIDL_user_free(SignatureBuffer.pb);
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperVerifyMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;

    __try
    {
        status = RPC_ScHelperVerifyMessage(
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    Algorithm,
                    BufferLength,
                    Buffer,
                    SignatureLength,
                    Signature);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperVerifyMessage - %lx\n", _exception_code());
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperSignPkcsMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL ULONG_PTR KerbHProv,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    )
{
    LogonInfo               *pLI;
    SCLOGON_PIPE            *pSCLogonPipe;
    NTSTATUS                status          = STATUS_SUCCESS;
    CUnicodeString          szPIN(pucPIN);
    OUT_BUFFER2             SignedBufferBuffer;
    PKERB_PUBLIC_KEY_HPROV  pKerbHProv;
    handle_t                hRPCBinding;
    BINDING_CONTEXT         BindingContext;
    BOOL                    fBindingIsCertAndKey = FALSE;

    //
    // Decide which rpc binding to use
    //
    if (KerbHProv != NULL)
    {
        pKerbHProv              = (PKERB_PUBLIC_KEY_HPROV) KerbHProv;
        hRPCBinding             = pKerbHProv->hRPCBinding;
        BindingContext          = pKerbHProv->hCertAndKey;
        fBindingIsCertAndKey    = TRUE;
    }
    else
    {
        pLI                     = (LogonInfo *)pbLogonInfo;
        pSCLogonPipe            = (SCLOGON_PIPE *) pLI->ContextInformation;
        hRPCBinding             = pSCLogonPipe->hRPCBinding;
        BindingContext          = pSCLogonPipe->BindingContext;
    }

    memset(&SignedBufferBuffer, 0, sizeof(SignedBufferBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
        if (!szPIN.Valid())
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Return;
        }
    }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperSignPkcsMessage(
                    hRPCBinding,
                    BindingContext,
                    (LPCWSTR)szPIN,
                    fBindingIsCertAndKey,
                    Algorithm->pszObjId,
                    Algorithm->Parameters.cbData,
                    Algorithm->Parameters.pbData,
                    dwSignMessageFlags,
                    BufferLength,
                    Buffer,
                    SignedBufferLength,
                    &SignedBufferBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperSignPkcsMessage - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        if (status != STATUS_BUFFER_TOO_SMALL)
        {
            DbgPrint("RPC_ScHelperSignPkcsMessage failed - %lx\n", status);
        }
        goto Return;
    }

    //
    // if SignedBufferBuffer.cb is not 0, then the called is getting back data
    //
    if (SignedBufferBuffer.cb != 0)
    {
        memcpy(SignedBuffer, SignedBufferBuffer.pb, SignedBufferBuffer.cb);
    }

Return:

    if (SignedBufferBuffer.pb != NULL)
    {
        MIDL_user_free(SignedBufferBuffer.pb);
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperVerifyPkcsMessage:
//
//***************************************************************************************
/*NTSTATUS WINAPI
__ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    )
{
    if (Provider != NULL)
    {
        return (ScHelperVerifyPkcsMessage(
                    pbLogonInfo,
                    Provider,
                    Buffer,
                    BufferLength,
                    DecodedBuffer,
                    DecodedBufferLength,
                    CertificateContext));
    }

    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI                        = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe               = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status                      = STATUS_SUCCESS;
    PCCERT_CONTEXT  pCertCtx                    = NULL;
    OUT_BUFFER2     DecodedBufferBuffer;
    OUT_BUFFER1     CertBytes;
    BOOL            fCertificateContextRequested = (CertificateContext != NULL);

    memset(&DecodedBufferBuffer, 0, sizeof(DecodedBufferBuffer));
    memset(&CertBytes, 0, sizeof(CertBytes));

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperVerifyPkcsMessage(
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    BufferLength,
                    Buffer,
                    DecodedBufferLength,
                    &DecodedBufferBuffer,
                    fCertificateContextRequested,
                    &CertBytes);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperVerifyPkcsMessage - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // Create the return CertContext based on the bytes returned
    //
    if (fCertificateContextRequested)
    {
        pCertCtx = CertCreateCertificateContext(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        CertBytes.pb,
                        CertBytes.cb);
        if (pCertCtx == NULL)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto Return;
        }
    }

    //
    // if DecodedBufferBuffer.cb is not 0, then the called is getting back data
    //
    if (DecodedBufferBuffer.cb != 0)
    {
        memcpy(DecodedBuffer, DecodedBufferBuffer.pb, DecodedBufferBuffer.cb);
    }

Return:

    if (fCertificateContextRequested)
    {
        *CertificateContext = pCertCtx;
    }

    if (DecodedBufferBuffer.pb != NULL)
    {
        MIDL_user_free(DecodedBufferBuffer.pb);
    }

    if (CertBytes.pb != NULL)
    {
        MIDL_user_free(CertBytes.pb);
    }

    return (status);
}*/



//***************************************************************************************
//
// __ScHelperDecryptMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL ULONG_PTR KerbHProv,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    )
{
    LogonInfo               *pLI;
    SCLOGON_PIPE            *pSCLogonPipe;
    NTSTATUS                status          = STATUS_SUCCESS;
    CUnicodeString          szPIN(pucPIN);
    OUT_BUFFER2             ClearTextBuffer;
    PKERB_PUBLIC_KEY_HPROV  pKerbHProv;
    handle_t                hRPCBinding;
    BINDING_CONTEXT         BindingContext;
    BOOL                    fBindingIsCertAndKey = FALSE;

    //
    // Decide which rpc binding to use
    //
    if (KerbHProv != NULL)
    {
        pKerbHProv              = (PKERB_PUBLIC_KEY_HPROV) KerbHProv;
        hRPCBinding             = pKerbHProv->hRPCBinding;
        BindingContext          = pKerbHProv->hCertAndKey;
        fBindingIsCertAndKey    = TRUE;
    }
    else
    {
        pLI                     = (LogonInfo *)pbLogonInfo;
        pSCLogonPipe            = (SCLOGON_PIPE *) pLI->ContextInformation;
        hRPCBinding             = pSCLogonPipe->hRPCBinding;
        BindingContext          = pSCLogonPipe->BindingContext;
    }

    memset(&ClearTextBuffer, 0, sizeof(ClearTextBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
        if (!szPIN.Valid())
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Return;
        }
    }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperDecryptMessage(
                    hRPCBinding,
                    BindingContext,
                    (LPCWSTR)szPIN,
                    fBindingIsCertAndKey,
                    CipherLength,
                    CipherText,
                    pClearLength,
                    &ClearTextBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperDecryptMessage - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        if (status != STATUS_BUFFER_TOO_SMALL)
        {
            DbgPrint("RPC_ScHelperDecryptMessage failed - %lx\n", status);
        }
        goto Return;
    }

    //
    // if ClearTextBuffer.cb is not 0, then the call is getting back data
    //
    if (ClearTextBuffer.cb != 0)
    {
        memcpy(ClearText, ClearTextBuffer.pb, ClearTextBuffer.cb);
    }

Return:

    if (ClearTextBuffer.pb != NULL)
    {
        MIDL_user_free(ClearTextBuffer.pb);
    }

    return (status);
}



//***************************************************************************************
//
// __ScHelper_CryptAcquireCertificatePrivateKey:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelper_CryptAcquireCertificatePrivateKey(
    IN PCCERT_CONTEXT               CertificateContext,
    OUT ULONG_PTR                   *pKerbHProv,
    OUT DWORD                       *pLastError
    )
{
    NTSTATUS                status                  = STATUS_SUCCESS;
    PKERB_PUBLIC_KEY_HPROV  pProv                   = NULL;
    BOOL                    fRPCBindingInitialized  = FALSE;
    CRYPT_KEY_PROV_INFO     *pKeyProvInfo           = NULL;
    DWORD                   cbKeyProvInfo           = 0;
    HANDLE                  hThreadToken            = INVALID_HANDLE_VALUE;
    BOOL                    fImpersonatingAnonymous = FALSE;
    HANDLE                  hNULL                   = NULL;

    *pLastError = 0;

    //
    // If we are already impersonating, then we need to do things slightly
    // differently... starting with getting the current thread token
    //
    if (!GetImpersonationToken(&hThreadToken))
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Return;
    }

    //
    // If we are impersonating, then revert to anonymous
    //
    if (hThreadToken != INVALID_HANDLE_VALUE)
    {
        if (!SetThreadToken(NULL, NULL))
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto Return;
        }

        fImpersonatingAnonymous = TRUE;
    }

    //
    // Allocate the new KERB_PUBLIC_KEY_HPROV struct
    //
    pProv = (PKERB_PUBLIC_KEY_HPROV) MIDL_user_allocate(sizeof(KERB_PUBLIC_KEY_HPROV));
    if (pProv == NULL)
    {
        *pLastError = ERROR_NOT_ENOUGH_MEMORY;
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Return;
    }
    pProv->hCertAndKey = NULL;

    //
    // Setup the RPC binding
    //
    status = _SetupRPCConnection(&(pProv->hRPCBinding), hThreadToken);
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }
    fRPCBindingInitialized = TRUE;

    //
    // Get the key prov info from the cert context
    //
    if (!CertGetCertificateContextProperty(
            CertificateContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbKeyProvInfo))
    {
        *pLastError = GetLastError();
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Return;
    }

    pKeyProvInfo = (CRYPT_KEY_PROV_INFO *) MIDL_user_allocate(cbKeyProvInfo);
    if (pKeyProvInfo == NULL)
    {
        *pLastError = ERROR_NOT_ENOUGH_MEMORY;
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Return;
    }

    if (!CertGetCertificateContextProperty(
            CertificateContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbKeyProvInfo))
    {
        *pLastError = GetLastError();
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Return;
    }

    //
    // Create the hProv in the winlogon process
    //
    __try
    {
        status = RPC_ScHelper_CryptAcquireCertificatePrivateKey(
                    pProv->hRPCBinding,
                    CertificateContext->cbCertEncoded,
                    CertificateContext->pbCertEncoded,
                    pKeyProvInfo->pwszContainerName,
                    pKeyProvInfo->pwszProvName,
                    pKeyProvInfo->dwProvType,
                    pKeyProvInfo->dwFlags,
                    pKeyProvInfo->dwKeySpec,
                    &(pProv->hCertAndKey),
                    pLastError);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelper_CryptAcquireCertificatePrivateKey - %lx\n", _exception_code());
    }

Return:

    if (NT_SUCCESS(status))
    {
        *pKerbHProv = (ULONG_PTR) pProv;
    }
    else
    {
         DbgPrint("RPC_ScHelper_CryptAcquireCertificatePrivateKey failed - %lx\n", status);

        if (fRPCBindingInitialized)
        {
            _TeardownRPCConnection(&(pProv->hRPCBinding));
        }

        if (pProv != NULL)
        {
            MIDL_user_free(pProv);
        }
    }

    if (pKeyProvInfo != NULL)
    {
        MIDL_user_free(pKeyProvInfo);
    }

    //
    // Reset impersonation if needed
    //
    if (fImpersonatingAnonymous)
    {
         if (!SetThreadToken(NULL, hThreadToken))
         {
             status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
             DbgPrint("SetThreadToken failed, we are now in a BOGUS STATE!! - %lx\n", status);
         }
    }

    if (hThreadToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hThreadToken);
    }

    return (status);
}



//***************************************************************************************
//
// __ScHelper_CryptSetProvParam:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelper_CryptSetProvParam(
    IN ULONG_PTR                    KerbHProv,
    IN LPSTR                        pszPIN,
    OUT DWORD                       *pLastError
    )
{
    NTSTATUS                status                  = STATUS_SUCCESS;
    PKERB_PUBLIC_KEY_HPROV  pKerbHProv              = (PKERB_PUBLIC_KEY_HPROV) KerbHProv;
    HANDLE                  hThreadToken            = INVALID_HANDLE_VALUE;
    BOOL                    fImpersonatingAnonymous = FALSE;
    HANDLE                  hNULL                   = NULL;

    *pLastError = 0;

    //
    // If we are already impersonating, then we need to do things slightly
    // differently... starting with getting the current thread token
    //
    if (!GetImpersonationToken(&hThreadToken))
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Return;
    }

    //
    // If we are impersonating, then revert to anonymous
    //
    if (hThreadToken != INVALID_HANDLE_VALUE)
    {
        if (!SetThreadToken(NULL, NULL))
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto Return;
        }

        fImpersonatingAnonymous = TRUE;
    }

    //
    // Set the prov param on the hProv in the winlogon process
    //
    __try
    {
        status = RPC_ScHelper_CryptSetProvParam(
                    pKerbHProv->hRPCBinding,
                    pKerbHProv->hCertAndKey,
                    pszPIN,
                    pLastError);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelper_CryptSetProvParam - %lx\n", _exception_code());
        goto Return;
    }

Return:

    //
    // Reset impersonation if needed
    //
    if (fImpersonatingAnonymous)
    {
         if (!SetThreadToken(NULL, hThreadToken))
         {
             status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
             DbgPrint("SetThreadToken failed, we are now in a BOGUS STATE!! - %lx\n", status);
         }
    }

    if (hThreadToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hThreadToken);
    }

    return (status);
}



//***************************************************************************************
//
// __ScHelper_CryptReleaseContext:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelper_CryptReleaseContext(
    IN ULONG_PTR                    KerbHProv
    )
{
    NTSTATUS                status                  = STATUS_SUCCESS;
    PKERB_PUBLIC_KEY_HPROV  pKerbHProv              = (PKERB_PUBLIC_KEY_HPROV) KerbHProv;
    HANDLE                  hThreadToken            = INVALID_HANDLE_VALUE;
    BOOL                    fImpersonatingAnonymous = FALSE;
    HANDLE                  hNULL                   = NULL;

    //
    // If we are already impersonating, then we need to do things slightly
    // differently... starting with getting the current thread token
    //
    if (!GetImpersonationToken(&hThreadToken))
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Return;
    }

    //
    // If we are impersonating, then revert to anonymous
    //
    if (hThreadToken != INVALID_HANDLE_VALUE)
    {
        if (!SetThreadToken(NULL, NULL))
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto Return;
        }

        fImpersonatingAnonymous = TRUE;
    }

    //
    // release hProv in the winlogon process
    //
    __try
    {
        status = RPC_ScHelper_CryptReleaseContext(
                    pKerbHProv->hRPCBinding,
                    &(pKerbHProv->hCertAndKey));
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelper_CryptReleaseContext - %lx\n", _exception_code());
        goto Return;
    }

Return:

    _TeardownRPCConnection(&(pKerbHProv->hRPCBinding));
    MIDL_user_free(pKerbHProv);

    //
    // Reset impersonation if needed
    //
    if (fImpersonatingAnonymous)
    {
         if (!SetThreadToken(NULL, hThreadToken))
         {
             status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
             DbgPrint("SetThreadToken failed, we are now in a BOGUS STATE!! - %lx\n", status);
         }
    }

    if (hThreadToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hThreadToken);
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\sclogon2\unicodes.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    unicodes

Abstract:

    This header file describes the CUnicodeString class, useful for converting
    string types.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _UNICODES_H_
#define _UNICODES_H_

//
//==============================================================================
//
//  CUnicodeString
//

class CUnicodeString
{
public:

    //  Constructors & Destructor
    CUnicodeString(void);
    CUnicodeString(LPCSTR sz);
    CUnicodeString(LPCWSTR wsz);
    CUnicodeString(PUNICODE_STRING pus);
    ~CUnicodeString();

    //  Properties
    //  Methods
    LPCSTR  Set(LPCSTR sz);
    LPCWSTR Set(LPCWSTR wsz);
    PUNICODE_STRING Set(PUNICODE_STRING pus);
    BOOL Valid(void)
    {
        if (m_fFlags == fNoneGood)
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }

    //  Operators
    LPCSTR operator=(LPCSTR sz)
    { return Set(sz); };
    LPCWSTR operator=(LPCWSTR wsz)
    { return Set(wsz); };
    PUNICODE_STRING operator=(PUNICODE_STRING pus)
    { return Set(pus);};
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };
    operator PUNICODE_STRING(void);

protected:
    //  Properties
    UNICODE_STRING m_us;
    LPSTR m_szAnsi;
    LPWSTR m_wszUnicode;
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
};

#endif // _UNICODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\context.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Context

Abstract:

    This module implements the CSCardUserContext and CSCardSubcontext classes.
    These classes are responsible for establishing and maintaining the
    connection to the Calais Server application, and for tracking the context
    under which related operations are performed.

Author:

    Doug Barlow (dbarlow) 11/21/1996

Environment:

    Win32, C++ w/ Excpetions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "client.h"
#ifdef DBG
#include <stdio.h>
#endif


//
//==============================================================================
//
//  CSCardUserContext
//

/*++

CSCardUserContext:

    This is the default constructor for the user context.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::CSCardUserContext")

CSCardUserContext::CSCardUserContext(
    IN DWORD dwScope)
:   m_csUsrCtxLock(CSID_USER_CONTEXT),
    m_hContextHeap(DBGT("User Context Heap Handle")),
    m_rgpSubContexts()
{
    m_dwScope = dwScope;
    m_hRedirContext = NULL;
}


/*++

CSCardUserContext::~CSCardUserContext:

    This is the destructor for a User Context.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::~CSCardUserContext")

CSCardUserContext::~CSCardUserContext()
{
    DWORD dwIndex;
    CSCardSubcontext *pSubCtx;

    LockSection(&m_csUsrCtxLock, DBGT("Destructing User Level Context"));
    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        {
            pSubCtx = m_rgpSubContexts[--dwIndex];
            if (NULL != pSubCtx)
                m_rgpSubContexts.Set(dwIndex, NULL);
        }
        if (NULL != pSubCtx)
            delete pSubCtx;
    }
    m_rgpSubContexts.Empty();

    if (m_hContextHeap.IsValid())
        HeapDestroy(m_hContextHeap.Relinquish());
}


/*++

EstablishContext:

    This method establishes the context by connecting to the Calais Server
    application.

Arguments:

    dwScope supplies an indication of the scope of the context.  Possible values
        are:

        SCARD_SCOPE_USER - The context is a user context, and any database
            operations are performed within the domain of the user.

        SCARD_SCOPE_TERMINAL - The context is that of the current terminal, and
            any database operations are performed within the domain of that
            terminal.  (The calling application must have appropriate access
            permissions for any database actions.)

        SCARD_SCOPE_SYSTEM - The context is the system context, and any database
            operations are performed within the domain of the system.  (The
            calling application must have appropriate access permissions for any
            database actions.)

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/21/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::EstablishContext")

void
CSCardUserContext::EstablishContext(
    void)
{

    //
    // Make sure we can access the server.
    //

    CSCardSubcontext *pSubCtx = AcquireSubcontext();
    ASSERT(NULL != pSubCtx);
    if (NULL == pSubCtx)
        throw (DWORD)SCARD_E_NO_MEMORY;
    pSubCtx->ReleaseSubcontext();
}


/*++

ReleaseContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::ReleaseContext")

void
CSCardUserContext::ReleaseContext(
    void)
{
    DWORD dwIndex;
    CSCardSubcontext *pSubCtx;
    LockSection(&m_csUsrCtxLock, DBGT("Releasing subcontexts"));

    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        pSubCtx = m_rgpSubContexts[--dwIndex];
        if (NULL != pSubCtx)
        {
            m_rgpSubContexts.Set(dwIndex, NULL);
            if (NULL != pSubCtx->m_hReaderHandle)
            {
                try
                {
                    g_phlReaders->Close(pSubCtx->m_hReaderHandle);
                }
                catch (...) {}
            }
            try
            {
                pSubCtx->ReleaseContext();
            }
            catch (...) {}
            delete pSubCtx;
        }
    }
}

/*++

ClosePipes:

    This method closes the pipes to SCardSvr.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Sermet Iskin (SermetI) 1/3/2001

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::ClosePipes")

void
CSCardUserContext::ClosePipes(
    void)
{
    DWORD dwIndex;
    CSCardSubcontext *pSubCtx;
    LockSection(&m_csUsrCtxLock, DBGT("Closing pipes"));

    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        pSubCtx = m_rgpSubContexts[--dwIndex];
        if (NULL != pSubCtx)
        {
            try
            {
                pSubCtx->ClosePipe();
            }
            catch (...) {}
        }
    }
}


/*++

AllocateMemory:

    Allocate memory for the user through this user context.

Arguments:

    cbLength supplies the length of the buffer to be allocated, in bytes.

Return Value:

    The address of the allocated buffer, or NULL if an error occurred.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::AllocateMemory")

LPVOID
CSCardUserContext::AllocateMemory(
    DWORD cbLength)
{
    LockSection(&m_csUsrCtxLock, DBGT("Locking memory heap"));

    if (!m_hContextHeap.IsValid())
    {
        m_hContextHeap = HeapCreate(0, 0, 0);
        if (!m_hContextHeap.IsValid())
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to create context heap: "),
                m_hContextHeap.GetLastError());
            goto ErrorExit;
        }
    }

    if (cbLength)
    {
        return HeapAlloc(
                m_hContextHeap,
                HEAP_ZERO_MEMORY,
                cbLength);
    }

ErrorExit:
    return NULL;
}


/*++

FreeMemory:

    Free memory for the user through this user context.

Arguments:

    pvBuffer supplies the address of the previously allocated buffer.

Return Value:

    None.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::FreeMemory")

DWORD
CSCardUserContext::FreeMemory(
    LPCVOID pvBuffer)
{
    BOOL fSts;
    LockSection(&m_csUsrCtxLock, DBGT("Freeing heap memory"));

    ASSERT(m_hContextHeap.IsValid());
    fSts = HeapFree(m_hContextHeap, 0, (LPVOID)pvBuffer);
    return fSts ? ERROR_SUCCESS : GetLastError();
}


/*++

AcquireSubcontext:

    A User Context manages one or more underlying subcontexts.  Subcontexts
    exist to facilitate multiple operations simoultaneously.  This method
    obtains a subcontext for temporary use.

Arguments:

    None

Return Value:

    The address of the newly created subcontext object.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    Subcontexts are managed by the main context, so when the main context is
    closed, all the subcontexts are closed too.

Author:

    Doug Barlow (dbarlow) 9/4/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::AcquireSubcontext")

CSCardSubcontext *
CSCardUserContext::AcquireSubcontext(
    BOOL fAndAllocate)
{
    CSCardSubcontext *pSubCtx = NULL;
    LockSection(&m_csUsrCtxLock, DBGT("Acquiring a subcontext"));

    try
    {
        DWORD dwIndex;

        //
        // See if we've got an unused subcontext laying around.
        //

        for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
        {
            pSubCtx = m_rgpSubContexts[--dwIndex];
            if (NULL != pSubCtx)
            {
                LockSection2(&pSubCtx->m_csSubCtxLock, DBGT("Reusing subcontext"));
                if (fAndAllocate)
                {
                    if (CSCardSubcontext::Idle == pSubCtx->m_nInUse)
                    {
                        ASSERT(pSubCtx->m_hCancelEvent.IsValid());
                        pSubCtx->Allocate();
                        pSubCtx->SetBusy();
                        break;
                    }
                }
                else
                {
                    if (CSCardSubcontext::Busy > pSubCtx->m_nInUse)
                    {
                        ASSERT(pSubCtx->m_hCancelEvent.IsValid());
                        pSubCtx->SetBusy();
                        break;
                    }
                }
                pSubCtx = NULL;
            }
        }


        //
        // If not, make a new one.
        //

        if (NULL == pSubCtx)
        {
            pSubCtx = new CSCardSubcontext;
            if (NULL == pSubCtx)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Client can't allocate a new subcontext"));
                return NULL; // SCARD_E_NO_MEMORY;
            }
            if (pSubCtx->InitFailed())
            {
                delete pSubCtx;
                pSubCtx = NULL;
                return NULL; // SCARD_E_NO_MEMORY;
            }
            if (fAndAllocate)
                pSubCtx->Allocate();
            pSubCtx->SetBusy();
            pSubCtx->EstablishContext(m_dwScope);
            m_rgpSubContexts.Add(pSubCtx);
            pSubCtx->m_pParentCtx = this;
        }


        //
        // Make sure the cancel event is clear.
        //

        ASSERT(pSubCtx->m_hCancelEvent.IsValid());
        if (!ResetEvent(pSubCtx->m_hCancelEvent))
        {
            DWORD dwErr = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Subcontext Allocate Failed to clear cancel event:  %1"),
                dwErr);
        }


        //
        // All done.  Return to caller.
        //

        ASSERT(pSubCtx->m_pParentCtx == this);
    }

    catch (...)
    {
        if (NULL != pSubCtx)
        {
            if (NULL == pSubCtx->m_pParentCtx)
                delete pSubCtx;
            else
            {
                if (fAndAllocate)
                    pSubCtx->Deallocate();
                pSubCtx->ReleaseSubcontext();
            }
        }
        throw;
    }

    return pSubCtx;
}


/*++

IsValidContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    If the call cannot be completed, a DWORD status code is thrown.

Remarks:

    If the context is determined to not be valid, it is automatically released.

Author:

    Doug Barlow (dbarlow) 11/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::IsValidContext")

BOOL
CSCardUserContext::IsValidContext(
    void)
{
    DWORD dwIndex;
    BOOL fIsValid = TRUE;
    CSCardSubcontext *pSubCtx;
    LockSection(&m_csUsrCtxLock, DBGT("Valid context check"));

    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        pSubCtx = m_rgpSubContexts[--dwIndex];
        if (NULL != pSubCtx)
        {
            CSCardSubcontext::State nState;

            {
                LockSection2(
                    &pSubCtx->m_csSubCtxLock,
                    DBGT("IsValidContext Checking validity state"));
                nState = pSubCtx->m_nInUse;
            }

            switch (nState)
            {
            case CSCardSubcontext::Idle:
            case CSCardSubcontext::Allocated:
                try
                {
                    CSubctxLock ctxLock(pSubCtx);
                    pSubCtx->IsValidContext();
                    fIsValid = TRUE;
                }
                catch (...)
                {
                    m_rgpSubContexts.Set(dwIndex, NULL);
                    delete pSubCtx;
                    fIsValid = FALSE;
                }
                break;
            case CSCardSubcontext::Busy:
                // Don't bother it.
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Subcontext state is invalid"));
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
        }
    }

    return fIsValid;
}


/*++

LocateCards:

    This method requests the LocateCards service on behalf of the client.

Arguments:

    mszReaders supplies the names of readers to look in, as a multistring.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.  Reader names are taken from the
        mszReaders parameter, not from here.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::LocateCards")

void
CSCardUserContext::LocateCards(
    IN LPCTSTR mszReaders,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders)
{
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        pSubCtx = AcquireSubcontext();
        if (NULL == pSubCtx)
            throw (DWORD)SCARD_E_NO_MEMORY;
        pSubCtx->LocateCards(
            mszReaders,
            rgAtrMasks,
            cAtrs,
            rgReaderStates,
            cReaders);
        pSubCtx->ReleaseSubcontext();
    }
    catch (...)
    {
        if (NULL != pSubCtx)
            pSubCtx->ReleaseSubcontext();
        throw;
    }
}


/*++

GetStatusChange:

    This method requests the GetStatusChange service on behalf of the client.

Arguments:

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Remarks:

    We don't have to clean up the cancel event, since this is a one-time usage
    of this sub-context.  Typically, if the subcontext were to be continued
    to be used, we'd have to make sure the cancel event got cleared eventually.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::GetStatusChange")

void
CSCardUserContext::GetStatusChange(
    IN LPCTSTR mszReaders,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN DWORD dwTimeout)
{
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        pSubCtx = AcquireSubcontext(TRUE);
        if (NULL == pSubCtx)
            throw (DWORD) SCARD_E_NO_MEMORY;
        pSubCtx->GetStatusChange(
                    mszReaders,
                    rgReaderStates,
                    cReaders,
                    dwTimeout);
        pSubCtx->Deallocate();
        pSubCtx->ReleaseSubcontext();
    }
    catch (DWORD dwStatus)
    {
        DWORD dwError;

        dwError = dwStatus;

        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }

            // Catch & convert the Cancel I threw myself
        if ((SCARD_E_CANCELLED == dwError) && (IsBad()))
        {
            dwError = SCARD_E_SYSTEM_CANCELLED;
        }

        throw dwError;
    }
    catch (...)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        throw;
    }
}


/*++

Cancel:

    This method requests the Cancel service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::Cancel")

void
CSCardUserContext::Cancel(
    void)
{
    DWORD dwIndex;
    CSCardSubcontext *pSubCtx;
    LockSection(&m_csUsrCtxLock, DBGT("Cancelling outstanding operations"));

    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        pSubCtx = m_rgpSubContexts[--dwIndex];
        if (NULL != pSubCtx)
            pSubCtx->Cancel();
    }
}


/*++

StripInactiveReaders:

    This routine scans the supplied list of readers, and shortens it to exclude
    any readers that aren't currently active.

Arguments:

    bfReaders supplies a list of readers by friendly name.  This list is pruned
        to remove all names that refer to inactive readers.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    All the listed readers must be introduced.  This routine does not filter
    undefined readers.

Author:

    Doug Barlow (dbarlow) 5/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::StripInactiveReaders")

void
CSCardUserContext::StripInactiveReaders(
    IN OUT CBuffer &bfReaders)
{
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        pSubCtx = AcquireSubcontext();
        if (NULL == pSubCtx)
            throw (DWORD) SCARD_E_NO_MEMORY;
        pSubCtx->StripInactiveReaders(bfReaders);
        pSubCtx->ReleaseSubcontext();
    }
    catch (...)
    {
        if (NULL != pSubCtx)
            pSubCtx->ReleaseSubcontext();
        throw;
    }
}


//
//==============================================================================
//
//  CSCardSubcontext
//

/*++

CONSTRUCTOR and DESTRUCTOR:

    These are the simple constructor and destructor for the CSCardSubcontext
    class.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/8/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::CSCardSubcontext")

CSCardSubcontext::CSCardSubcontext(void)
:   m_csSubCtxLock(CSID_SUBCONTEXT),
    m_hBusy(DBGT("Subcontext busy mutex")),
    m_hCancelEvent(DBGT("Subcontext cancel event"))
{
    DWORD dwSts;

    m_hReaderHandle = NULL;
    m_pParentCtx = NULL;
    m_pChannel = NULL;
    m_nInUse = Idle;
    m_nLastState = Invalid;
    m_hBusy = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hBusy.IsValid())
    {
        dwSts = m_hBusy.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to create busy event flag: %1"),
            dwSts);
        throw dwSts;
    }

    CSecurityDescriptor acl;

    acl.InitializeFromProcessToken();
    acl.AllowOwner(
        EVENT_ALL_ACCESS);
    acl.Allow(
        &acl.SID_LocalService,
        EVENT_ALL_ACCESS);

    m_hCancelEvent = CreateEvent(acl, TRUE, FALSE, NULL);
    if (!m_hCancelEvent.IsValid())
    {
        dwSts = m_hCancelEvent.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Card context cannot create cancel event:  %1"),
            dwSts);
        throw dwSts;
    }
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::~CSCardSubcontext")
CSCardSubcontext::~CSCardSubcontext()
{
    if (NULL != m_pChannel)
        delete m_pChannel;
    if (m_hBusy.IsValid())
        m_hBusy.Close();
    if (m_hCancelEvent.IsValid())
        m_hCancelEvent.Close();
}


/*++

Allocate:

    This method raises the state of the subcontext to 'Allocated'.  This means
    it is in use as an SCARDHANDLE.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/23/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::Allocate")

void
CSCardSubcontext::Allocate(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Mark subcontext as allocated"));
    ASSERT(Idle == m_nInUse);
    ASSERT(Invalid == m_nLastState);
    m_nInUse = Allocated;
}


/*++

Deallocate:

    This method releases the subcontext from the allocated state.
    If the device is still busy, it sets things up to be deallocated
    when it is released.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/23/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::Deallocate")

void
CSCardSubcontext::Deallocate(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Deallocate subcontext"));

    switch (m_nInUse)
    {
    case Idle:
        ASSERT(FALSE);  // Why are we here?
        break;
    case Allocated:
        m_nInUse = Idle;
        m_nLastState = Invalid;
        break;
    case Busy:
        ASSERT(Allocated == m_nLastState);
        m_nLastState = Idle;
        break;
    default:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Subcontext deallocation state corruption detected."));
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
}


/*++

SetBusy:

    This method marks the subcontext as busy.

Arguments:

    None

Return Value:

    None

Throws:

    None (It tries to limp along)

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 11/10/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::SetBusy")

void
CSCardSubcontext::SetBusy(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Mark subcontext busy"));

    ASSERT(Busy != m_nInUse);
    ASSERT(Invalid == m_nLastState);
    ASSERT(m_hBusy.IsValid());
    m_nLastState = m_nInUse;
    m_nInUse = Busy;
    ASSERT(m_nLastState < m_nInUse);
    ASSERT(Invalid != m_nLastState);
    if (!ResetEvent(m_hBusy))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to mark context busy: %1"),
            GetLastError());
}


/*++

SendRequest:

    This method sends the given Communications Object to the server application.

Arguments:

    pCom supplies the Communications Object to be sent.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/16/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::SendRequest")

void
CSCardSubcontext::SendRequest(
    CComObject *pCom)
{
    ASSERT(Busy == m_nInUse);
    try
    {
        DWORD dwSts = pCom->Send(m_pChannel);
        if (ERROR_SUCCESS != dwSts)
            throw dwSts;
    }
    catch (DWORD dwErr)
    {
        switch (dwErr)
        {
        case ERROR_NO_DATA:
        case ERROR_PIPE_NOT_CONNECTED:
        case ERROR_BAD_PIPE:
        case ERROR_BROKEN_PIPE:
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
            break;
        default:
            throw;
        }
    }
}

//
// Attempts to restore the impersonation token of the current thread.  
// Assumes that failure to restore the impersonation token is catastrophic.
//
// If this function is called, we assume we're currently running as Local 
// System and attempting to restore our impersonation token.  That shouldn't
// fail, but if it does, something is really wrong and we must not continue
// to execute code in this state.
//
void MySetThreadToken(HANDLE hThreadToken)
{
    if (FALSE == SetThreadToken(NULL, hThreadToken))
    {
        ASSERT(FALSE);
        TerminateThread(GetCurrentThread(), 0);
    }
}

/*++

EstablishContext:

    This method establishes the context by connecting to the Calais Server
    application.

Arguments:

    dwScope supplies an indication of the scope of the context.  Possible values
        are:

        SCARD_SCOPE_USER - The context is a user context, and any database
            operations are performed within the domain of the user.

        SCARD_SCOPE_TERMINAL - The context is that of the current terminal, and
            any database operations are performed within the domain of that
            terminal.  (The calling application must have appropriate access
            permissions for any database actions.)

        SCARD_SCOPE_SYSTEM - The context is the system context, and any database
            operations are performed within the domain of the system.  (The
            calling application must have appropriate access permissions for any
            database actions.)

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/21/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::EstablishContext")

void
CSCardSubcontext::EstablishContext(
    IN DWORD dwScope)
{
    CComChannel *pCom = NULL;
    DWORD dwVersion = CALAIS_COMM_CURRENT;
    HANDLE hThreadToken = NULL;

    try
    {
        CComInitiator comInit;
        ComEstablishContext comEstablishContext;
        ComEstablishContext::CObjEstablishContext_request *pReq;
        ComEstablishContext::CObjEstablishContext_response *pRsp;
        DWORD dwSts;
        HANDLE hServerCancelEvent = NULL;

        ASSERT(Busy == m_nInUse);
        pCom = comInit.Initiate(
                    CalaisString(CALSTR_COMMPIPENAME),
                    &dwVersion);
        ASSERT(dwVersion == CALAIS_COMM_CURRENT);

        pReq = comEstablishContext.InitRequest(0);
        pReq->dwProcId = GetCurrentProcessId();
        pReq->hptrCancelEvent = (HANDLE_PTR) m_hCancelEvent.Value();

        comEstablishContext.Send(pCom);
        comEstablishContext.InitResponse(0);
        pRsp = comEstablishContext.Receive(pCom);
        if (SCARD_S_SUCCESS != pRsp->dwStatus)
            throw pRsp->dwStatus;

        hServerCancelEvent = (HANDLE) pRsp->hptrCancelEvent;

        if (NULL != hServerCancelEvent)
        {
            CHandleObject hTargetProc(DBGT("Target Process in EstablishContext"));
            HANDLE h = NULL;
            BOOL fSts = FALSE;

            //
            // The Resource Manager doesn't have access to our Cancel event.
            // It's proposed an event to use instead.  Switch over.
            //
            // Get the process handle for scardsvr.  We require Duplicate 
            // Handle rights.
            //
            // Assume that the only reason scardsvr would have sent back a new
            // event handle is that we're impersonating a lesser account that 
            // doesn't own the current process.  That account will likely not
            // have the appropriate rights to scardsvr either, so we need to 
            // revert to self before doing the following work.
            //

            if (FALSE == OpenThreadToken(
                    GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &hThreadToken))
                throw GetLastError();

            if (FALSE == RevertToSelf())
                throw GetLastError();

            hTargetProc = OpenProcess(
                            PROCESS_DUP_HANDLE | EVENT_ALL_ACCESS,
                            FALSE,              // handle inheritance flag
                            pRsp->dwProcId);    // process identifier

            if (!hTargetProc.IsValid())
                throw GetLastError();

            fSts = DuplicateHandle(
                        hTargetProc,        // handle to process
                        hServerCancelEvent,
                        GetCurrentProcess(),// handle to process to duplicate to
                        &h,                 // pointer to duplicate handle
                        EVENT_ALL_ACCESS,   // access for duplicate handle
                        FALSE,              // handle inheritance flag
                        0);                 // optional actions
            if (!fSts)
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("EstablishContext could not dup offered cancel event:  %1"),
                    dwSts);
                ASSERT(NULL == h);
                throw dwSts;
            }

            // Restore the impersonation token
            MySetThreadToken(hThreadToken);

            CloseHandle(hThreadToken);
            hThreadToken = NULL;
            
            ASSERT(m_hCancelEvent.IsValid());
            m_hCancelEvent.Close();
            m_hCancelEvent = h;
        }

        m_pChannel = pCom;
    }

    catch (...)
    {
        if (NULL != hThreadToken)
        {
            MySetThreadToken(hThreadToken);
            CloseHandle(hThreadToken);
        }
        if (NULL != pCom)
            delete pCom;
        throw;
    }
}


/*++

ReleaseSubcontext:

    This method releases the subcontext for use by other requests.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::ReleaseSubcontext")

void
CSCardSubcontext::ReleaseSubcontext(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Mark subcontext available"));

    // Check to see if winscard.dll is currently being unloaded.  If
    // so, skip the asserts.
    if (FALSE == g_fInClientRundown)
    {
        ASSERT(Idle != m_nInUse);
        ASSERT(Busy != m_nLastState);
        ASSERT(Invalid != m_nLastState);
        ASSERT(m_nInUse > m_nLastState);
        ASSERT(m_hBusy.IsValid());
    }

    m_nInUse = m_nLastState;

    if (FALSE == g_fInClientRundown)
    {
        ASSERT(Busy != m_nInUse);
    }

    m_nLastState = Invalid;
    if (!SetEvent(m_hBusy))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to mark context Available: %1"),
            GetLastError());
}


/*++

ReleaseContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::ReleaseContext")

void
CSCardSubcontext::ReleaseContext(
    void)
{
    ComReleaseContext comRel;
    ComReleaseContext::CObjReleaseContext_request *pReq;
    ComReleaseContext::CObjReleaseContext_response *pRsp;

    if (WaitForSingleObject(m_hBusy, 0) != WAIT_TIMEOUT)    // Subcontext not busy
    {
        CSubctxLock csCtxLock(this);

        pReq = comRel.InitRequest(0);
        SendRequest(&comRel);

        comRel.InitResponse(0);
        pRsp = comRel.Receive(m_pChannel);
        if (SCARD_S_SUCCESS != pRsp->dwStatus)
            throw pRsp->dwStatus;
    }
}

/*++

ClosePipe:

    This method closes the pipe to SCardSvr.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Sermet Iskin (SermetI) 1/4/2001

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::ClosePipe")

void
CSCardSubcontext::ClosePipe(
    void)
{
    if (WaitForSingleObject(m_hBusy, 0) != WAIT_TIMEOUT)    // Subcontext not busy
    {
        CSubctxLock csCtxLock(this);
        m_pChannel->ClosePipe() ;
    }
}


/*++

WaitForAvailable:

    This method waits for a given connection to go not busy, then locks it.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::WaitForAvailable")

void
CSCardSubcontext::WaitForAvailable(
    void)
{
    DWORD dwSts;
    BOOL fNotDone = TRUE;

    ASSERT(m_hBusy.IsValid());

    while (fNotDone)
    {
        {
            LockSection(&m_csSubCtxLock, DBGT("Checking availability"));

            switch (m_nInUse)
            {
            case Idle:
                ASSERT(Invalid == m_nLastState);
                // Fall through intentionally
            case Allocated:
                ASSERT(Allocated != m_nLastState);
                SetBusy();
                fNotDone = FALSE;
                continue;
                break;
            case Busy:
                ASSERT(Busy > m_nLastState);
                ASSERT(Invalid != m_nLastState);
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Subcontext availability state is corrupted."));
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
        }

        dwSts = WaitForSingleObject(m_hBusy, CALAIS_LOCK_TIMEOUT);
        switch (dwSts)
        {
        case WAIT_ABANDONED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy received wait abandoned."));
            break;
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy timed out."),
                GetLastError());
            break;
        case WAIT_FAILED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy failed: %1"),
                GetLastError());
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy received invalid return: %1"),
                GetLastError());
        }
    }
}


/*++

IsValidContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    If the call cannot be completed, a DWORD status code is thrown.

Remarks:

    If the context is determined to not be valid, it is automatically released.

Author:

    Doug Barlow (dbarlow) 11/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::IsValidContext")

void
CSCardSubcontext::IsValidContext(
    void)
{
    ComIsValidContext comObj;
    ComIsValidContext::CObjIsValidContext_request *pReq;
    ComIsValidContext::CObjIsValidContext_response *pRsp;

    pReq = comObj.InitRequest(0);
    SendRequest(&comObj);
    comObj.InitResponse(0);
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}


/*++

LocateCards:

    This method requests the LocateCards service on behalf of the client.

Arguments:

    mszReaders supplies the names of readers to look in, as a multistring.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.  Reader names are taken from the
        mszReaders parameter, not from here.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::LocateCards")

void
CSCardSubcontext::LocateCards(
    IN LPCTSTR mszReaders,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders)
{
    ComLocateCards comObj;
    ComLocateCards::CObjLocateCards_request *pReq;
    ComLocateCards::CObjLocateCards_response *pRsp;
    CBuffer bfReaders;
    CBuffer bfStatus;
    CBuffer bfAtrs;
    CBuffer bfMasks;
    CBuffer bfXlate1(36); // Rough guess of name & ATR lengths
    LPDWORD rgdwStatus;
    DWORD dwIndex, dwChkLen;
    BYTE cbAtrLen;
    DWORD dwAtrLen;
    LPCBYTE pbAtr;
    LPCTSTR szReader;

    if (0 == cReaders)
        return;
    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    bfStatus.Resize(sizeof(DWORD) * cReaders);
    rgdwStatus = (LPDWORD)bfStatus.Access();


    //
    // List the smartcard ATRs and masks we're interested in.
    //

    for (dwIndex = 0;
         dwIndex < cAtrs;
         dwIndex++)
    {
        bfAtrs.Presize(bfAtrs.Length() + rgAtrMasks[dwIndex].cbAtr + 1, TRUE);
        bfMasks.Presize(bfMasks.Length() + rgAtrMasks[dwIndex].cbAtr + 1, TRUE);

        ASSERT(33 >= rgAtrMasks[dwIndex].cbAtr);    // Biggest an ATR can be.
        cbAtrLen = (BYTE)rgAtrMasks[dwIndex].cbAtr;
        bfAtrs.Append(&cbAtrLen, 1);
        bfAtrs.Append(rgAtrMasks[dwIndex].rgbAtr, cbAtrLen);

        bfMasks.Append(&cbAtrLen, 1);
        bfMasks.Append(rgAtrMasks[dwIndex].rgbMask, cbAtrLen);
    }


    //
    // List the reader devices we're interested in.
    //

    for (szReader = FirstString(mszReaders), dwIndex = 0;
         NULL != szReader;
         szReader = NextString(szReader), dwIndex += 1)
    {
        ASSERT(cReaders > dwIndex);
        BOOL fSts = GetReaderInfo(
                    Scope(),
                    szReader,
                    NULL,
                    &bfXlate1);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        bfReaders.Append(
            bfXlate1.Access(),
            bfXlate1.Length());
        rgdwStatus[dwIndex] = rgReaderStates[dwIndex].dwCurrentState;
    }
    ASSERT(cReaders == dwIndex);
    bfReaders.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));


    //
    // Put it all into the request.
    //

    pReq = comObj.InitRequest(
                bfAtrs.Length() + bfMasks.Length() + bfReaders.Length()
                + bfStatus.Length() + 4 * sizeof(DWORD));
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscAtrs, bfAtrs.Access(), bfAtrs.Length());
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscAtrMasks, bfMasks.Access(), bfMasks.Length());
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscReaders, bfReaders.Access(), bfReaders.Length());
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscReaderStates, bfStatus.Access(), bfStatus.Length());


    //
    // Send in the request.
    //

    SendRequest(&comObj);
    comObj.InitResponse(cReaders * sizeof(DWORD));
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;


    //
    // Parse the response.
    //

    rgdwStatus = (LPDWORD)comObj.Parse(pRsp->dscReaderStates, &dwChkLen);
    if (dwChkLen != cReaders * sizeof(DWORD))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Client locate cards array size mismatch"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    pbAtr = (LPCBYTE)comObj.Parse(pRsp->dscAtrs, &dwChkLen);

    for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
    {
        rgReaderStates[dwIndex].dwEventState = rgdwStatus[dwIndex];
        dwAtrLen = *pbAtr++;
        ASSERT(33 >= dwAtrLen);
        if (dwAtrLen >= dwChkLen)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Client locate cards ATR size mismatch"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }
        ZeroMemory(
            rgReaderStates[dwIndex].rgbAtr,
            sizeof(SCARD_READERSTATE) - FIELD_OFFSET(SCARD_READERSTATE, rgbAtr));
        CopyMemory(rgReaderStates[dwIndex].rgbAtr, pbAtr, dwAtrLen);
        rgReaderStates[dwIndex].cbAtr = dwAtrLen;
        dwChkLen -= dwAtrLen + 1;
        pbAtr += dwAtrLen;
    }
}


/*++

GetStatusChange:

    This method requests the GetStatusChange service on behalf of the client.

Arguments:

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Remarks:

    We don't have to clean up the cancel event, since this is a one-time usage
    of this sub-context.  Typically, if the subcontext were to be continued
    to be used, we'd have to make sure the cancel event got cleared eventually.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::GetStatusChange")

void
CSCardSubcontext::GetStatusChange(
    IN LPCTSTR mszReaders,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN DWORD dwTimeout)
{
    ComGetStatusChange comObj;
    ComGetStatusChange::CObjGetStatusChange_request *pReq;
    ComGetStatusChange::CObjGetStatusChange_response *pRsp;
    CBuffer bfReaders;
    CBuffer bfStatus;
    LPDWORD rgdwStatus;
    CBuffer bfXlate(16);    // Rough guess of device name length
    DWORD dwIndex, dwChkLen;
    BOOL fSts;
    LPCBYTE pbAtr;
    DWORD dwAtrLen;
    LPCTSTR szReader;

    if (0 == cReaders)
        return;
    bfStatus.Resize(sizeof(DWORD) * cReaders);
    rgdwStatus = (LPDWORD)bfStatus.Access();
    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;


    //
    // List the reader devices we're interested in.
    //

    for (szReader = FirstString(mszReaders), dwIndex = 0;
         NULL != szReader;
         szReader = NextString(szReader), dwIndex += 1)
    {
        ASSERT(cReaders > dwIndex);
        fSts = GetReaderInfo(
                    Scope(),
                    szReader,
                    NULL,
                    &bfXlate);
        if (fSts)
        {
            bfReaders.Append(
                bfXlate.Access(),
                bfXlate.Length());
        }
        else if (0 == _tcsncicmp(
                            CalaisString(CALSTR_SPECIALREADERHEADER),
                            szReader,
                            _tcslen(CalaisString(CALSTR_SPECIALREADERHEADER))))
        {
            bfReaders.Append(
                (LPCBYTE)szReader,
                (_tcslen(szReader) + 1) * sizeof(TCHAR));
        }
        else
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        rgdwStatus[dwIndex] = rgReaderStates[dwIndex].dwCurrentState;
    }
    ASSERT(cReaders == dwIndex);
    bfReaders.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));


    //
    // Put it all into the request.
    //

    pReq = comObj.InitRequest(
        bfReaders.Length() + bfStatus.Length()
        + 2 * sizeof(DWORD));
    pReq->dwTimeout = dwTimeout;
    pReq = (ComGetStatusChange::CObjGetStatusChange_request *)
            comObj.Append(
                pReq->dscReaders,
                bfReaders.Access(),
                bfReaders.Length());
    pReq = (ComGetStatusChange::CObjGetStatusChange_request *)
            comObj.Append(
                pReq->dscReaderStates,
                bfStatus.Access(),
                bfStatus.Length());

    SendRequest(&comObj);
    comObj.InitResponse(cReaders * sizeof(DWORD));
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;

    rgdwStatus = (LPDWORD)comObj.Parse(pRsp->dscReaderStates, &dwChkLen);
    if (dwChkLen != cReaders * sizeof(DWORD))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Client locate cards array size mismatch"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    pbAtr = (LPCBYTE)comObj.Parse(pRsp->dscAtrs, &dwChkLen);
    for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
    {
        rgReaderStates[dwIndex].dwEventState = rgdwStatus[dwIndex];
        dwAtrLen = *pbAtr++;
        ASSERT(33 >= dwAtrLen);
        if (dwAtrLen >= dwChkLen)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Client locate cards ATR size mismatch"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }
        ZeroMemory(
            rgReaderStates[dwIndex].rgbAtr,
            sizeof(SCARD_READERSTATE) - FIELD_OFFSET(SCARD_READERSTATE, rgbAtr));
        CopyMemory(rgReaderStates[dwIndex].rgbAtr, pbAtr, dwAtrLen);
        rgReaderStates[dwIndex].cbAtr = dwAtrLen;
        dwChkLen -= dwAtrLen + 1;
        pbAtr += dwAtrLen;
    }
}


/*++

Cancel:

    This method requests the Cancel service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::Cancel")

void
CSCardSubcontext::Cancel(
    void)
{
    ASSERT(m_hCancelEvent.IsValid());
    if (!SetEvent(m_hCancelEvent))
        CalaisWarning(
        __SUBROUTINE__,
        DBGT("Cancel request Failed to set context cancel event: %1"),
        GetLastError());
}


/*++

StripInactiveReaders:

    This routine scans the supplied list of readers, and shortens it to exclude
    any readers that aren't currently active.

Arguments:

    bfReaders supplies a list of readers by friendly name.  This list is pruned
        to remove all names that refer to inactive readers.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    All the listed readers must be introduced.  This routine does not filter
    undefined readers.

Author:

    Doug Barlow (dbarlow) 5/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::StripInactiveReaders")

void
CSCardSubcontext::StripInactiveReaders(
    IN OUT CBuffer &bfReaders)
{
    ComListReaders comObj;
    ComListReaders::CObjListReaders_request *pReq;
    ComListReaders::CObjListReaders_response *pRsp;
    CBuffer bfDeviceName, bfDevices;
    LPCTSTR szReader;
    BOOL fSts;
    LPBOOL pfDeviceActive;
    DWORD dwReaderCount;


    //
    // Build the corresponding list of device names.
    //

    if (0 == *(LPCTSTR)bfReaders.Access())
        throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
    for (szReader = FirstString((LPCTSTR)bfReaders.Access());
         NULL != szReader;
         szReader = NextString(szReader))
    {
        fSts = GetReaderInfo(Scope(), szReader, NULL, &bfDeviceName);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        MStrAdd(bfDevices, (LPCTSTR)bfDeviceName.Access());
    }


    //
    // Ask the resource manager which ones are active.
    //

    pReq = comObj.InitRequest(bfDevices.Length());
    pReq = (ComListReaders::CObjListReaders_request *)comObj.Append(
                pReq->dscReaders, bfDevices.Access(), bfDevices.Length());

    SendRequest(&comObj);
    comObj.InitResponse(0);
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;

    pfDeviceActive = (LPBOOL)comObj.Parse(pRsp->dscReaders, &dwReaderCount);
    dwReaderCount /= sizeof(BOOL);
    ASSERT(dwReaderCount == MStringCount((LPCTSTR)bfReaders.Access()));


    //
    // Filter the inactive ones out of the original set.
    //

    bfDevices.Reset();
    for (szReader = FirstString((LPCTSTR)bfReaders.Access());
         NULL != szReader;
         szReader = NextString(szReader))
    {
        if (*pfDeviceActive++)
            MStrAdd(bfDevices, szReader);
    }


    //
    // Replace the original buffer.
    //

    bfReaders = bfDevices;
}


//
//==============================================================================
//
//  CReaderContext
//

#define INVALID_SCARDHANDLE_VALUE (INTERCHANGEHANDLE)(-1)


/*++

CReaderContext:
~CReaderContext:

    These are the constructor and destructor for a client reader context object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::CReaderContext")

CReaderContext::CReaderContext(
    void)
{
    m_dwActiveProtocol = SCARD_PROTOCOL_UNDEFINED;
    m_pCtx = NULL;
    m_hCard = (INTERCHANGEHANDLE)INVALID_SCARDHANDLE_VALUE;
    m_hRedirCard = NULL;
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::~CReaderContext")
CReaderContext::~CReaderContext()
{
    try
    {
        if (NULL != m_pCtx)
        {
            Context()->Deallocate();
            Context()->ReleaseSubcontext();
            m_pCtx = NULL;
        }
    }
    catch (...) {}
}


/*++

Connect:

    This method requests the Connect service on behalf of the client.

Arguments:

    pCtx supplies the Context under which the reader is opened.

    szReaderName supplies the name of the reader to connect to.

    dwShareMode supplies the form of sharing to be invoked.

    dwPreferredProtocols supplies the acceptable protocols.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Connect")

void
CReaderContext::Connect(
    CSCardSubcontext *pCtx,
    LPCTSTR szReaderName,
    DWORD dwShareMode,
    DWORD dwPreferredProtocols)
{
    ComConnect comObj;
    ComConnect::CObjConnect_request *pReq;
    ComConnect::CObjConnect_response *pRsp;
    BOOL fSts;
    CBuffer bfDevice;

    ASSERT(SCARD_PROTOCOL_UNDEFINED == m_dwActiveProtocol);
    ASSERT(NULL == m_pCtx);
    if (0 == *szReaderName)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    fSts = GetReaderInfo(
                pCtx->Scope(),
                szReaderName,
                NULL,
                &bfDevice);
    if (!fSts)
        throw (DWORD)SCARD_E_UNKNOWN_READER;

    pReq = comObj.InitRequest(bfDevice.Length() + sizeof(DWORD));
    pReq->dwShareMode = dwShareMode;
    pReq->dwPreferredProtocols = dwPreferredProtocols;
    pReq = (ComConnect::CObjConnect_request *)comObj.Append(
                pReq->dscReader, bfDevice.Access(), bfDevice.Length());
    pCtx->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(pCtx->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    m_hCard = pRsp->hCard;
    m_dwActiveProtocol = pRsp->dwActiveProtocol;
    m_pCtx = pCtx;
}


/*++

Reconnect:

    This method requests the Reconnect service on behalf of the client.

Arguments:

    dwShareMode supplies the form of sharing to be invoked.

    dwPreferredProtocols supplies the acceptable protocols.

    dwInitialization supplies the card initialization required.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Reconnect")

void
CReaderContext::Reconnect(
    DWORD dwShareMode,
    DWORD dwPreferredProtocols,
    DWORD dwInitialization)
{
    ComReconnect comObj;
    ComReconnect::CObjReconnect_request *pReq;
    ComReconnect::CObjReconnect_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwShareMode = dwShareMode;
    pReq->dwPreferredProtocols = dwPreferredProtocols;
    pReq->dwInitialization = dwInitialization;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    m_dwActiveProtocol = pRsp->dwActiveProtocol;
}


/*++

Disconnect:

    This method requests the Disconnect service on behalf of the client.

Arguments:

    dwDisposition - Supplies an indication of what should be done with the card
        in the connected reader.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Disconnect")

LONG
CReaderContext::Disconnect(
    DWORD dwDisposition)
{
    ComDisconnect comObj;
    ComDisconnect::CObjDisconnect_request *pReq;
    ComDisconnect::CObjDisconnect_response *pRsp = NULL;
    CSubctxLock ctxLock(Context());

    try
    {
        pReq = comObj.InitRequest(0);
        pReq->hCard = m_hCard;
        pReq->dwDisposition = dwDisposition;
        Context()->SendRequest(&comObj);

        comObj.InitResponse(0);
        pRsp = comObj.Receive(Context()->m_pChannel);
    }
    catch (...) {}
    if (NULL != m_pCtx)
    {
        Context()->Deallocate();
        m_pCtx = NULL;
    }
    m_dwActiveProtocol = SCARD_PROTOCOL_UNDEFINED;
    m_hCard = INVALID_SCARDHANDLE_VALUE;
    return (NULL != pRsp) ? pRsp->dwStatus : SCARD_E_SERVICE_STOPPED;
}


/*++

BeginTransaction:

    This method requests the BeginTransaction service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::BeginTransaction")

void
CReaderContext::BeginTransaction(
    void)
{
    ComBeginTransaction comObj;
    ComBeginTransaction::CObjBeginTransaction_request *pReq;
    ComBeginTransaction::CObjBeginTransaction_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}


/*++

EndTransaction:

    This method requests the EndTransaction service on behalf of the client.

Arguments:

    dwDisposition supplies the disposition of the card.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::EndTransaction")

void
CReaderContext::EndTransaction(
    DWORD dwDisposition)
{
    DWORD dw;

    if (dwDisposition == SCARD_LEAVE_CARD_FORCE)
    {
        if (INVALID_SCARDHANDLE_VALUE == m_hCard)
        {
            return;
        }

        dw = SCARD_LEAVE_CARD;
    }
    else
    {
        dw = dwDisposition;
    }
    
    ComEndTransaction comObj;
    ComEndTransaction::CObjEndTransaction_request *pReq;
    ComEndTransaction::CObjEndTransaction_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwDisposition = dw;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}


/*++

Status:

    This method requests the Status service on behalf of the client.

Arguments:

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    bfAtr - This receives the current ATR, if any.

    bfReaderNames - This receives the list of friendly names assigned to the
        connected reader, as a MultiString.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/14/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Status")

void
CReaderContext::Status(
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT CBuffer &bfAtr,
    OUT CBuffer &bfReaderNames)
{
    ComStatus comObj;
    ComStatus::CObjStatus_request *pReq;
    ComStatus::CObjStatus_response *pRsp;
    CBuffer bfSysName;
    LPCBYTE pbAtr;
    DWORD cbAtr;
    LPCTSTR szSysName;

    CSubctxLock ctxLock(Context());
    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    *pdwState = pRsp->dwState;
    *pdwProtocol = pRsp->dwProtocol;
    pbAtr = (LPCBYTE)comObj.Parse(pRsp->dscAtr, &cbAtr);
    szSysName = (LPCTSTR)comObj.Parse(pRsp->dscSysName);
    bfAtr.Set(pbAtr, cbAtr);
    ListReaderNames(
        Context()->Scope(),
        szSysName,
        bfReaderNames);
}


/*++

Transmit:

    This method requests the Transmit service on behalf of the client.

Arguments:

    pioSendPci - This supplies the protocol header structure for the
        instruction.

    pbSendBuffer - This supplies the actual data to be written to the card in
        conjunction with the command.

    cbSendLength - This supplies the length of the pbDataBuffer parameter, in
        bytes.

    pioRecvPci - This receives the return protocol header structure from the
        instruction.

    bfRecvData - This receives any data returned from the card in conjunction
        with the command.

    cbProposedLength - This supplies a maximum length for the received data.
        If this value is zero, then the server uses the default max length.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Transmit")

void
CReaderContext::Transmit(
    IN  LPCSCARD_IO_REQUEST pioSendPci,
    IN  LPCBYTE pbSendBuffer,
    IN  DWORD cbSendLength,
    OUT LPSCARD_IO_REQUEST pioRecvPci,
    OUT CBuffer &bfRecvData,
    IN  DWORD cbProposedLength)
{
    static const SCARD_IO_REQUEST ioNullPci = { 0, sizeof(SCARD_IO_REQUEST) };
    ComTransmit comObj;
    ComTransmit::CObjTransmit_request *pReq;
    ComTransmit::CObjTransmit_response *pRsp;
    LPSCARD_IO_REQUEST pioIoreq;
    DWORD cbIoreq, cbData;
    LPCBYTE pbData;
    CSubctxLock ctxLock(Context());

    if (NULL == pioSendPci)
        pioSendPci = &ioNullPci;
    pReq = comObj.InitRequest(pioSendPci->cbPciLength + cbSendLength
                                + 2 * sizeof(DWORD)
                                + 2 * sizeof(DWORD));
    pReq->hCard = m_hCard;
    pReq->dwPciLength = (NULL == pioRecvPci)
                        ? sizeof(SCARD_IO_REQUEST)
                        : pioRecvPci->cbPciLength;
    pReq->dwRecvLength = cbProposedLength;
    pReq = (ComTransmit::CObjTransmit_request *)comObj.Append(
                                            pReq->dscSendPci,
                                            (LPCBYTE)pioSendPci,
                                            pioSendPci->cbPciLength);
    pReq = (ComTransmit::CObjTransmit_request *)comObj.Append(
                                            pReq->dscSendBuffer,
                                            pbSendBuffer,
                                            cbSendLength);
    Context()->SendRequest(&comObj);

    comObj.InitResponse(pReq->dwPciLength + pReq->dwRecvLength
                        + 2 * sizeof(DWORD));
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    pioIoreq = (LPSCARD_IO_REQUEST)comObj.Parse(pRsp->dscRecvPci, &cbIoreq);
    ASSERT(cbIoreq == pioIoreq->cbPciLength);
    if (NULL != pioRecvPci)
    {
        if (cbIoreq > pioRecvPci->cbPciLength)
            throw (DWORD)SCARD_E_PCI_TOO_SMALL;
        CopyMemory(pioRecvPci, pioIoreq, cbIoreq);
    }
    pbData = (LPCBYTE)comObj.Parse(pRsp->dscRecvBuffer, &cbData);
    bfRecvData.Set(pbData, cbData);
}


/*++

Control:

    This method requests the Control service on behalf of the client.

Arguments:

    dwControlCode - This supplies the control code for the operation. This value
        identifies the specific operation to be performed.

    pvInBuffer - This supplies a pointer to a buffer that contains the data
        required to perform the operation.  This parameter can be NULL if the
        dwControlCode parameter specifies an operation that does not require
        input data.

    cbInBufferSize - This supplies the size, in bytes, of the buffer pointed to
        by pvInBuffer.

    bfOutBuffer - This buffer receives the operation's output data.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Control")

void
CReaderContext::Control(
    IN DWORD dwControlCode,
    IN LPCVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT CBuffer &bfOutBuffer)
{
    ComControl comObj;
    ComControl::CObjControl_request *pReq;
    ComControl::CObjControl_response *pRsp;
    LPCBYTE pbData;
    DWORD cbData;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(cbInBufferSize + sizeof(DWORD));
    pReq->hCard = m_hCard;
    pReq->dwControlCode = dwControlCode;
    pReq->dwOutLength = bfOutBuffer.Space();
    pReq = (ComControl::CObjControl_request *)
        comObj.Append(pReq->dscInBuffer, (LPCBYTE)pvInBuffer, cbInBufferSize);
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    pbData = (LPCBYTE)comObj.Parse(pRsp->dscOutBuffer, &cbData);
    bfOutBuffer.Set(pbData, cbData);
}


/*++

GetAttrib:

    This method requests the GetAttrib service on behalf of the client.

Arguments:

    dwAttrId - This supplies the identifier for the attribute to get.

    bfAttr - This buffer receives the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.

    cbProposedLength - This supplies a maximum length for the received data.
        If this value is zero, then the server uses the default max length.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::GetAttrib")

void
CReaderContext::GetAttrib(
    IN DWORD dwAttrId,
    OUT CBuffer &bfAttr,
    DWORD cbProposedLen)
{
    ComGetAttrib comObj;
    ComGetAttrib::CObjGetAttrib_request *pReq;
    ComGetAttrib::CObjGetAttrib_response *pRsp;
    LPCBYTE pbData;
    DWORD cbData;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwAttrId = dwAttrId;
    pReq->dwOutLength = cbProposedLen;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    pbData = (LPCBYTE)comObj.Parse(pRsp->dscAttr, &cbData);
    bfAttr.Set(pbData, cbData);
}


/*++

SetAttrib:

    This method requests the SetAttrib service on behalf of the client.

Arguments:

    dwAttrId - This supplies the identifier for the attribute to get.

    pbAttr - This buffer supplies the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.

    cbAttrLength - This supplies the length of the attribute value in pbAttr
        buffer in bytes.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::SetAttrib")

void
CReaderContext::SetAttrib(
    IN DWORD dwAttrId,
    IN LPCBYTE pbAttr,
    IN DWORD cbAttrLen)
{
    ComSetAttrib comObj;
    ComSetAttrib::CObjSetAttrib_request *pReq;
    ComSetAttrib::CObjSetAttrib_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwAttrId = dwAttrId;
    pReq = (ComSetAttrib::CObjSetAttrib_request *)
            comObj.Append(pReq->dscAttr, pbAttr, cbAttrLen);
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\client.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    client

Abstract:

    This header file collects the definitions for the Calais Client DLL.

Author:

    Doug Barlow (dbarlow) 11/21/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CLIENT_H_
#define _CLIENT_H_

#define WINSCARDDATA
#include <WinSCard.h>
#include <calmsgs.h>
#include <CalCom.h>

#ifndef FACILITY_SCARD
#define FACILITY_SCARD 16
#endif
// #define ErrorCode(x) (0x80000000 | (FACILITY_SCARD << 16) + (x))
// #define WarnCode(x)  (0x80000000 | (FACILITY_SCARD << 16) + (x))
// #define InfoCode(x)  (0x40000000 | (FACILITY_SCARD << 16) + (x))
// #define SuccessCode(x)            ((FACILITY_SCARD << 16) + (x))
#define CONTEXT_HANDLE_ID 0xcd
#define READER_HANDLE_ID  0xea

#define SCARD_LEAVE_CARD_FORCE 0xff

extern CHandleList
    * g_phlContexts,
    * g_phlReaders;
extern const WCHAR
    g_wszBlank[];

extern BOOL g_fInClientRundown;

class CSCardUserContext;
class CSCardSubcontext;
class CReaderContext;

extern void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPBYTE pbOutput,
    LPDWORD pcbLength);
extern void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR szOutput,
    LPDWORD pcchLength);
extern void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR szOutput,
    LPDWORD pcchLength);
extern void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR mszOutput,
    LPDWORD pcchLength);
extern void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR mszOutput,
    LPDWORD pcchLength);


//
//==============================================================================
//
//  CReaderContext
//

class CReaderContext
:   public CHandle
{
public:
    //  Constructors & Destructor
    CReaderContext();
    ~CReaderContext();

    //  Properties
    //  Methods
    DWORD Protocol(void) const
    { return m_dwActiveProtocol; };
    CSCardSubcontext *Context(void) const
    { ASSERT(NULL != m_pCtx);
      return m_pCtx; };

    void Connect(
            CSCardSubcontext *pCtx,
            LPCTSTR szReaderName,
            DWORD dwShareMode,
            DWORD dwPreferredProtocols);
    void Reconnect(
            DWORD dwShareMode,
            DWORD dwPreferredProtocols,
            DWORD dwInitialization);
    LONG Disconnect(
            DWORD dwDisposition);
    void BeginTransaction(
            void);
    void EndTransaction(
            DWORD dwDisposition);
    void Status(
            OUT LPDWORD pdwState,
            OUT LPDWORD pdwProtocol,
            OUT CBuffer &bfAtr,
            OUT CBuffer &bfReaderNames);
    void Transmit(
            IN  LPCSCARD_IO_REQUEST pioSendPci,
            IN LPCBYTE pbSendBuffer,
            IN DWORD cbSendLength,
            OUT LPSCARD_IO_REQUEST pioRecvPci,
            OUT CBuffer &bfRecvData,
            IN  DWORD cbProposedLength = 0);
    void Read(
            IN OUT LPSCARD_IO_REQUEST pioRequest,
            IN DWORD dwMaxLength,
            OUT CBuffer &bfData);
    void Write(
            IN OUT LPSCARD_IO_REQUEST pioRequest,
            IN LPCBYTE pbDataBuffer,
            IN DWORD cbDataLength);
    void Control(
            IN DWORD dwControlCode,
            IN LPCVOID pvInBuffer,
            IN DWORD cbInBufferSize,
            OUT CBuffer &bfOutBuffer);
    void GetAttrib(
            IN DWORD dwAttrId,
            OUT CBuffer &bfAttr,
            IN DWORD dwProposedLen = 0);
    void SetAttrib(
            IN DWORD dwAttrId,
            IN LPCBYTE pbAttr,
            IN DWORD cbAttrLen);

    void SetRedirCard(SCARDHANDLE hCard)
    { m_hRedirCard = hCard;};
    SCARDHANDLE GetRedirCard() const
    {return m_hRedirCard;};

    //  Operators

protected:
    //  Properties
    CSCardSubcontext *m_pCtx;
    INTERCHANGEHANDLE m_hCard;
    DWORD m_dwActiveProtocol;
    SCARDHANDLE m_hRedirCard;

    //  Methods
};


//
//==============================================================================
//
//  CSCardUserContext
//

class CSCardUserContext
:   public CHandle
{
public:
    //  Constructors & Destructor

    CSCardUserContext(DWORD dwScope);
    virtual ~CSCardUserContext();

    //  Properties

    //  Methods
    void EstablishContext(void);
    void ReleaseContext(void);
    void ClosePipes(void);
    LPVOID AllocateMemory(DWORD cbLength);
    DWORD FreeMemory(LPCVOID pvBuffer);
    DWORD Scope(void) const
    { return m_dwScope; };
    HANDLE HeapHandle(void) const
    { return m_hContextHeap; };
    CSCardSubcontext *AcquireSubcontext(BOOL fAndAllocate = FALSE);
    void LocateCards(
            IN LPCTSTR mszReaders,
            IN LPSCARD_ATRMASK rgAtrMasks,
            IN DWORD cAtrs,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders);
    void GetStatusChange(
            IN LPCTSTR mszReaders,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders,
            DWORD dwTimeout);
    void Cancel(void);
    void StripInactiveReaders(IN OUT CBuffer &bfReaders);
    BOOL IsValidContext(void);
    BOOL InitFailed(void) 
    { return m_csUsrCtxLock.InitFailed(); }

    void SetRedirContext(SCARDCONTEXT hRedirContext)
    { m_hRedirContext = hRedirContext;};
    SCARDCONTEXT GetRedirContext() const
    {return m_hRedirContext;};

    //  Operators
    BOOL fCallUnregister;

protected:
    //  Properties
    DWORD m_dwScope;
    CHandleObject m_hContextHeap;
    CDynamicArray<CSCardSubcontext> m_rgpSubContexts;
    CCriticalSectionObject m_csUsrCtxLock;
    SCARDCONTEXT m_hRedirContext;
    
    //  Methods

private:
    //  Properties
    //  Methods

    // Friends
    // friend class CReaderContext;
    // friend class CSCardSubcontext;
};


//
//==============================================================================
//
//  CSCardSubcontext
//

class CSCardSubcontext
{
public:
    typedef enum { Invalid, Idle, Allocated, Busy } State;

    //  Constructors & Destructor

    CSCardSubcontext();
    virtual ~CSCardSubcontext();

    //  Properties
    SCARDHANDLE m_hReaderHandle;

    //  Methods
    DWORD Scope(void) const
        { return m_pParentCtx->Scope(); };
    CSCardUserContext *Parent(void) const
        { return m_pParentCtx; };
    void SendRequest(CComObject *pCom);
    void EstablishContext(IN DWORD dwScope);
    void ReleaseContext(void);
    void ClosePipe(void);
    void ReleaseSubcontext(void);
    void LocateCards(
            IN LPCTSTR mszReaders,
            IN LPSCARD_ATRMASK rgAtrMasks,
            IN DWORD cAtrs,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders);
    void GetStatusChange(
            IN LPCTSTR mszReaders,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders,
            DWORD dwTimeout);
    void Cancel(void);
    void StripInactiveReaders(IN OUT CBuffer &bfReaders);
    void IsValidContext(void);
    void SetBusy(void);
    void WaitForAvailable(void);
    void Allocate(void);
    void Deallocate(void);
    BOOL InitFailed(void) 
    { return m_csSubCtxLock.InitFailed(); }

    //  Operators

protected:
    //  Properties
    State m_nInUse;
    State m_nLastState;
    CHandleObject m_hBusy; // Set => available, reset => busy.
    CHandleObject m_hCancelEvent;
    CSCardUserContext *m_pParentCtx;
    CComChannel *m_pChannel;
    CCriticalSectionObject m_csSubCtxLock;

    //  Methods

private:
    //  Properties
    //  Methods
    // Friends
    friend class CReaderContext;
    friend class CSCardUserContext;
};



//
//==============================================================================
//
//  CSubctxLock
//

class CSubctxLock
{
public:

    //  Constructors & Destructor
    CSubctxLock(CSCardSubcontext *pSubCtx)
    {
        m_pSubCtx = NULL;
        pSubCtx->WaitForAvailable();
        m_pSubCtx = pSubCtx;
    };

    ~CSubctxLock()
    {
        if (NULL != m_pSubCtx)
            m_pSubCtx->ReleaseSubcontext();
    };

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CSCardSubcontext *m_pSubCtx;
    //  Methods
};

#endif // _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winscard.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\redirect.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    redirect

Abstract:

    This header file collects the definitions for TS redirection.

Author:

    Louis Thomas (louisth) 4/4/2000

Environment:

    Win32, C++ w/ Exceptions

--*/

#ifndef _REDIRECT_H_
#define _REDIRECT_H_


//--------------------------------------------------------------------
// function prototypes
bool LoadRedirectionDll(void);
bool RedirectDisabled(void);
void SetRedirectDisabledValue(void);
BOOL InAService();
BOOL InTSRedirectMode();

BOOL WINAPI RedirDllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved);

#define TS_REDIRECT_DISABLED    (RedirectDisabled())
#define TS_REDIRECT_READY       ((g_bRedirectReady || LoadRedirectionDll()) && !TS_REDIRECT_DISABLED)

//--------------------------------------------------------------------
// variables
extern bool  g_bRedirectReady;

extern WINSCARDAPI LONG (WINAPI * pfnSCardEstablishContext)(IN DWORD dwScope, IN LPCVOID pvReserved1, IN LPCVOID pvReserved2, OUT LPSCARDCONTEXT phContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardReleaseContext)(IN SCARDCONTEXT hContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIsValidContext)(IN SCARDCONTEXT hContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsA)(IN SCARDCONTEXT hContext, OUT LPSTR mszGroups, IN OUT LPDWORD pcchGroups);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsW)(IN SCARDCONTEXT hContext, OUT LPWSTR mszGroups, IN OUT LPDWORD pcchGroups);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReadersA)(IN SCARDCONTEXT hContext, IN LPCSTR mszGroups, OUT LPSTR mszReaders, IN OUT LPDWORD pcchReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReadersW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszGroups, OUT LPWSTR mszReaders, IN OUT LPDWORD pcchReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szDeviceName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szDeviceName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsA)(IN SCARDCONTEXT hContext, IN LPCSTR mszCards, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszCards, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeA)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeW)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardCancel)(IN SCARDCONTEXT hContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardConnectA)(IN SCARDCONTEXT hContext, IN LPCSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG (WINAPI * pfnSCardConnectW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG (WINAPI * pfnSCardReconnect)(IN SCARDHANDLE hCard, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, IN DWORD dwInitialization, OUT LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG (WINAPI * pfnSCardDisconnect)(IN SCARDHANDLE hCard, IN DWORD dwDisposition);
extern WINSCARDAPI LONG (WINAPI * pfnSCardBeginTransaction)(IN SCARDHANDLE hCard);
extern WINSCARDAPI LONG (WINAPI * pfnSCardEndTransaction)(IN SCARDHANDLE hCard, IN DWORD dwDisposition);
extern WINSCARDAPI LONG (WINAPI * pfnSCardState)(IN SCARDHANDLE hCard, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardStatusA)(IN SCARDHANDLE hCard, OUT LPSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardStatusW)(IN SCARDHANDLE hCard, OUT LPWSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardTransmit)(IN SCARDHANDLE hCard, IN LPCSCARD_IO_REQUEST pioSendPci, IN LPCBYTE pbSendBuffer, IN DWORD cbSendLength, IN OUT LPSCARD_IO_REQUEST pioRecvPci, OUT LPBYTE pbRecvBuffer, IN OUT LPDWORD pcbRecvLength);
extern WINSCARDAPI LONG (WINAPI * pfnSCardControl)(IN SCARDHANDLE hCard, IN DWORD dwControlCode,IN LPCVOID pvInBuffer, IN DWORD cbInBufferSize, OUT LPVOID pvOutBuffer, IN DWORD cbOutBufferSize, OUT LPDWORD pcbBytesReturned);
extern WINSCARDAPI LONG (WINAPI * pfnSCardGetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, OUT LPBYTE pbAttr, IN OUT LPDWORD pcbAttrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardSetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, IN LPCBYTE pbAttr, IN DWORD cbAttrLen);
extern WINSCARDAPI HANDLE (WINAPI * pfnSCardAccessStartedEvent)(void);
extern WINSCARDAPI void   (WINAPI * pfnSCardReleaseStartedEvent)(void);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRA)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEA rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRW)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEW rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardReleaseBadContext)(IN SCARDCONTEXT hContext);


#endif //_REDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

$(O)\scardmsg.mc: $(PROJECT_ROOT)\published\scard\scarderr.mc scardmsg.mch
    copy $(PROJECT_ROOT)\published\scard\scarderr.mc + scardmsg.mch $@

$(O)\scardmsg.h $(O)\scardmsg.rc $(O)\msg00001.bin: $(O)\scardmsg.mc
    mc -r .\$(O) -h .\$(O) $(O)\scardmsg.mc

winscard.rc: $(O)\scardmsg.h $(O)\scardmsg.rc $(O)\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\redirect.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Redirect

Abstract:

    This module supplies implementation to redirect the SCard* API calls
    so that they can be removed over a terminal services virtual channel.

Author:

    Louis Thomas (louisth) 4/4/2000

Environment:

    Win32, C++ w/ Exceptions

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>
#include <winsvc.h>

#include "client.h"
#include "redirect.h"
#include "scardmsg.h"


#define REG_TERMINALSERVER_KEY  L"Software\\Policies\\Microsoft\\Windows NT\\Terminal Services"
#define REG_DISABLE_VALUE       L"fEnableSmartCard"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//====================================================================
// TS Redirection pointers
//====================================================================
bool g_bRedirectReady=false;
CRITICAL_SECTION g_csLoadingRedirect;

bool g_bRedirectDisabled=false;
CRITICAL_SECTION g_csCheckingDisabled;
bool g_bDisableChecked=false;
HANDLE g_hRegNotifyChange=NULL;

WINSCARDAPI LONG (WINAPI * pfnSCardEstablishContext)(IN DWORD dwScope, IN LPCVOID pvReserved1, IN LPCVOID pvReserved2, OUT LPSCARDCONTEXT phContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardReleaseContext)(IN SCARDCONTEXT hContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIsValidContext)(IN SCARDCONTEXT hContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsA)(IN SCARDCONTEXT hContext, OUT LPSTR mszGroups, IN OUT LPDWORD pcchGroups)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsW)(IN SCARDCONTEXT hContext, OUT LPWSTR mszGroups, IN OUT LPDWORD pcchGroups)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReadersA)(IN SCARDCONTEXT hContext, IN LPCSTR mszGroups, OUT LPSTR mszReaders, IN OUT LPDWORD pcchReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReadersW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszGroups, OUT LPWSTR mszReaders, IN OUT LPDWORD pcchReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szDeviceName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szDeviceName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsA)(IN SCARDCONTEXT hContext, IN LPCSTR mszCards, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszCards, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeA)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeW)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardCancel)(IN SCARDCONTEXT hContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardConnectA)(IN SCARDCONTEXT hContext, IN LPCSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardConnectW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardReconnect)(IN SCARDHANDLE hCard, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, IN DWORD dwInitialization, OUT LPDWORD pdwActiveProtocol)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardDisconnect)(IN SCARDHANDLE hCard, IN DWORD dwDisposition)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardBeginTransaction)(IN SCARDHANDLE hCard)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardEndTransaction)(IN SCARDHANDLE hCard, IN DWORD dwDisposition)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardState)(IN SCARDHANDLE hCard, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardStatusA)(IN SCARDHANDLE hCard, OUT LPSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardStatusW)(IN SCARDHANDLE hCard, OUT LPWSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardTransmit)(IN SCARDHANDLE hCard, IN LPCSCARD_IO_REQUEST pioSendPci, IN LPCBYTE pbSendBuffer, IN DWORD cbSendLength, IN OUT LPSCARD_IO_REQUEST pioRecvPci, OUT LPBYTE pbRecvBuffer, IN OUT LPDWORD pcbRecvLength)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardControl)(IN SCARDHANDLE hCard, IN DWORD dwControlCode,IN LPCVOID pvInBuffer, IN DWORD cbInBufferSize, OUT LPVOID pvOutBuffer, IN DWORD cbOutBufferSize, OUT LPDWORD pcbBytesReturned)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardGetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, OUT LPBYTE pbAttr, IN OUT LPDWORD pcbAttrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardSetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, IN LPCBYTE pbAttr, IN DWORD cbAttrLen)=NULL;
WINSCARDAPI HANDLE (WINAPI * pfnSCardAccessStartedEvent)(void)=NULL;
WINSCARDAPI void   (WINAPI * pfnSCardReleaseStartedEvent)(void)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRA)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEA rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRW)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEW rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardReleaseBadContext)(IN SCARDCONTEXT hContext)=NULL;


//====================================================================

struct NeededEntrypoint {
    void ** ppfn;
    CHAR * szFnName;
};

static NeededEntrypoint neProcList[]={
    { (void **)&pfnSCardEstablishContext, "SCardEstablishContext" },
    { (void **)&pfnSCardReleaseContext, "SCardReleaseContext" },
    { (void **)&pfnSCardIsValidContext, "SCardIsValidContext" },
    { (void **)&pfnSCardListReaderGroupsA, "SCardListReaderGroupsA" },
    { (void **)&pfnSCardListReaderGroupsW, "SCardListReaderGroupsW" },
    { (void **)&pfnSCardListReadersA, "SCardListReadersA" },
    { (void **)&pfnSCardListReadersW, "SCardListReadersW" },
    { (void **)&pfnSCardIntroduceReaderGroupA, "SCardIntroduceReaderGroupA" },
    { (void **)&pfnSCardIntroduceReaderGroupW, "SCardIntroduceReaderGroupW" },
    { (void **)&pfnSCardForgetReaderGroupA, "SCardForgetReaderGroupA" },
    { (void **)&pfnSCardForgetReaderGroupW, "SCardForgetReaderGroupW" },
    { (void **)&pfnSCardIntroduceReaderA, "SCardIntroduceReaderA" },
    { (void **)&pfnSCardIntroduceReaderW, "SCardIntroduceReaderW" },
    { (void **)&pfnSCardForgetReaderA, "SCardForgetReaderA" },
    { (void **)&pfnSCardForgetReaderW, "SCardForgetReaderW" },
    { (void **)&pfnSCardAddReaderToGroupA, "SCardAddReaderToGroupA" },
    { (void **)&pfnSCardAddReaderToGroupW, "SCardAddReaderToGroupW" },
    { (void **)&pfnSCardRemoveReaderFromGroupA, "SCardRemoveReaderFromGroupA" },
    { (void **)&pfnSCardRemoveReaderFromGroupW, "SCardRemoveReaderFromGroupW" },
    { (void **)&pfnSCardLocateCardsA, "SCardLocateCardsA" },
    { (void **)&pfnSCardLocateCardsW, "SCardLocateCardsW" },
    { (void **)&pfnSCardGetStatusChangeA, "SCardGetStatusChangeA" },
    { (void **)&pfnSCardGetStatusChangeW, "SCardGetStatusChangeW" },
    { (void **)&pfnSCardCancel, "SCardCancel" },
    { (void **)&pfnSCardConnectA, "SCardConnectA" },
    { (void **)&pfnSCardConnectW, "SCardConnectW" },
    { (void **)&pfnSCardReconnect, "SCardReconnect" },
    { (void **)&pfnSCardDisconnect, "SCardDisconnect" },
    { (void **)&pfnSCardBeginTransaction, "SCardBeginTransaction" },
    { (void **)&pfnSCardEndTransaction, "SCardEndTransaction" },
    { (void **)&pfnSCardState, "SCardState" },
    { (void **)&pfnSCardStatusA, "SCardStatusA" },
    { (void **)&pfnSCardStatusW, "SCardStatusW" },
    { (void **)&pfnSCardTransmit, "SCardTransmit" },
    { (void **)&pfnSCardControl, "SCardControl" },
    { (void **)&pfnSCardGetAttrib, "SCardGetAttrib" },
    { (void **)&pfnSCardSetAttrib, "SCardSetAttrib" },
    { (void **)&pfnSCardAccessStartedEvent, "SCardAccessStartedEvent" },
    { (void **)&pfnSCardReleaseStartedEvent, "SCardReleaseStartedEvent" },
    { (void **)&pfnSCardLocateCardsByATRA, "SCardLocateCardsByATRA" },
    { (void **)&pfnSCardLocateCardsByATRW, "SCardLocateCardsByATRW" },
    { (void **)&pfnSCardReleaseBadContext, "SCardReleaseBadContext" }
};


////////////////////////////////////////////////////////////////////////////////
//
//  TS redirection support routines
//
//      The following services are used to redirect smart card API calls to
//      a different DLL, that will then marshal the calls over a terminal
//      services virtual channel
//

//--------------------------------------------------------------------
void TsRdrLogEvent(WORD wType, DWORD dwEventID, unsigned int nStrings, const TCHAR ** rgtszStrings) {
    HANDLE hEventLog=RegisterEventSource(NULL, CalaisString(CALSTR_PRIMARYSERVICE));
    if (NULL!=hEventLog) {
        ReportEvent(hEventLog, wType, 0/*category*/, dwEventID, NULL, (WORD)nStrings, 0, rgtszStrings, NULL);
        DeregisterEventSource(hEventLog);
    }
}
//--------------------------------------------------------------------
HRESULT GetSystemErrorString(HRESULT hrIn, TCHAR ** ptszError) {
    HRESULT hr=S_OK;
    DWORD dwResult;
    TCHAR * rgParams[2]={
        NULL,
        (TCHAR *)(UINT_PTR)hrIn
    };

    // must be cleaned up
    TCHAR * tszErrorMessage=NULL;
    TCHAR * tszFullErrorMessage=NULL;

    // initialize input params
    *ptszError=NULL;

    // get the message from the system
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL/*ignored*/, hrIn, 0/*language*/, (TCHAR *)&tszErrorMessage, 0/*min-size*/, NULL/*valist*/);
    if (0==dwResult) {
        if (ERROR_MR_MID_NOT_FOUND==GetLastError()) {
            rgParams[0]=_T("");
        } else {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    } else {
        rgParams[0]=tszErrorMessage;

        // trim off \r\n if it exists
        if (L'\r'==tszErrorMessage[_tcslen(tszErrorMessage)-2]) {
            tszErrorMessage[_tcslen(tszErrorMessage)-2]=_T('\0');
        }
    }

    // add the error number
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
        _T("%1 (0x%2!08X!)"), 0, 0/*language*/, (TCHAR *)&tszFullErrorMessage, 0/*min-size*/, (va_list *)rgParams);
    if (0==dwResult) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto error;
    }

    // success
    *ptszError=tszFullErrorMessage;
    tszFullErrorMessage=NULL;
    hr=S_OK;
error:
    if (NULL!=tszErrorMessage) {
        LocalFree(tszErrorMessage);
    }
    if (NULL!=tszFullErrorMessage) {
        LocalFree(tszFullErrorMessage);
    }
    return hr;
}


//--------------------------------------------------------------------
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DllMain")
BOOL WINAPI RedirDllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {

    bool fInitialized=false;

    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:

        // If we need to load the redirector DLL we will do this on the
        // first smartcard call to be redirected.  So, create a critical
        // section to be used when loading the redirector.
        __try {
            InitializeCriticalSection(&g_csLoadingRedirect);
            fInitialized = true;
            InitializeCriticalSection(&g_csCheckingDisabled);
        } __except(EXCEPTION_EXECUTE_HANDLER) {

            if (fInitialized)
            {
                DeleteCriticalSection(&g_csLoadingRedirect);
            }
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        DeleteCriticalSection(&g_csLoadingRedirect);
        DeleteCriticalSection(&g_csCheckingDisabled);

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

//--------------------------------------------------------------------
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("LoadRedirectionDll")
bool LoadRedirectionDll(void) {
    DWORD dwErr=ERROR_SUCCESS;
    unsigned int nIndex;

    // must be cleaned up
    bool bLogError=false;
    bool bRet=true;
    HMODULE hmRedirector=NULL;

    // make sure we are the only one trying to load the dll
    EnterCriticalSection(&g_csLoadingRedirect);

    // now, our state may have changed. Check one more time
    if (true==g_bRedirectReady) {
        CalaisInfo(__SUBROUTINE__, DBGT("Redirection dll already loaded."));
        goto done;
    }

    // load the dll
    hmRedirector=LoadLibrary(TEXT("scredir.dll"));
    if (NULL==hmRedirector) {
        dwErr=GetLastError();
        TCHAR * tszError;
        if (S_OK==GetSystemErrorString(HRESULT_FROM_WIN32(dwErr), &tszError)) {
            const TCHAR * rgtszStrings[]={TEXT("scredir.dll"), tszError};
            CalaisDebug((DBGT("Logging error: The redirection DLL '%s' could not be loaded. The error was: %s\n"), TEXT("scredir.dll"), tszError));
            TsRdrLogEvent(EVENTLOG_ERROR_TYPE, MSG_TSREDIR_DLL_LOAD_FAIL, 2, rgtszStrings);
            LocalFree(tszError);
        }
        bLogError=false;
        goto error;
    }

    // get the pointers
    for (nIndex=0; nIndex<ARRAYSIZE(neProcList); nIndex++) {
        *neProcList[nIndex].ppfn=GetProcAddress(hmRedirector, neProcList[nIndex].szFnName);
        if (NULL==*neProcList[nIndex].ppfn) {
            dwErr=GetLastError();
            TCHAR * tszError;
            if (S_OK==GetSystemErrorString(HRESULT_FROM_WIN32(dwErr), &tszError)) {
                const TCHAR * rgtszStrings[]={neProcList[nIndex].szFnName, TEXT("scredir.dll"), tszError};
                CalaisDebug((DBGT("Logging error: The entry point '%s' could not be found in the redirection DLL '%s'. The error was: %s\n"), neProcList[nIndex].szFnName, TEXT("scredir.dll"), tszError));
                TsRdrLogEvent(EVENTLOG_ERROR_TYPE, MSG_TSREDIR_MISSING_ENTRY_POINT, 3, rgtszStrings);
                LocalFree(tszError);
            }
            bLogError=false;
            goto error;
        }
    }

    g_bRedirectReady=true;

done:
    hmRedirector=NULL; // don't unload library
error:
    if (NULL!=hmRedirector) {
        FreeLibrary(hmRedirector);
    }

    LeaveCriticalSection(&g_csLoadingRedirect);

    if (ERROR_SUCCESS!=dwErr) {

        bRet=false;

        if (bLogError) {
            TCHAR * tszError;
            if (S_OK==GetSystemErrorString(HRESULT_FROM_WIN32(dwErr), &tszError)) {
                const TCHAR * rgtszStrings[]={tszError};
                CalaisDebug((DBGT("Logging error: An unexpected error occurred trying to determine the redirection dll. The error was: %s\n"), tszError));
                TsRdrLogEvent(EVENTLOG_ERROR_TYPE, MSG_TSREDIR_UNEXPECTED, 1, rgtszStrings);
                LocalFree(tszError);
            }
        }

        SetLastError(dwErr);
    }
    return bRet;
}

#define NAME_VALUE_SIZE 20

void
SetRedirectDisabledValue(void)
{
    HKEY    hKey;
    DWORD   dwDisposition;
    WCHAR   wszValueName[NAME_VALUE_SIZE];
    DWORD   dwValueNameSize = NAME_VALUE_SIZE;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwValueSize = sizeof(DWORD);
    DWORD   dwIndex;
    LONG    lRet;

    //
    // See if the reg key exists, if so, then see if the fEnableSmartCard value exists
    //
    if (RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            REG_TERMINALSERVER_KEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ,
            NULL,
            &hKey,
            &dwDisposition) == ERROR_SUCCESS)
    {
        dwIndex = 0;

        lRet = RegEnumValueW(
                    hKey,
                    dwIndex,
                    wszValueName,
                    &dwValueNameSize,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &dwValueSize);

        while ((lRet == ERROR_SUCCESS) || (lRet == ERROR_MORE_DATA))
        {
            if ((lRet == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)   &&
                (_wcsicmp(wszValueName, REG_DISABLE_VALUE) == 0))
            {
                g_bRedirectDisabled = (dwValue == 0);
                break;
            }
            else
            {
                dwValueNameSize = NAME_VALUE_SIZE;
                dwValueSize = sizeof(DWORD);
                dwIndex++;
                lRet = RegEnumValueW(
                            hKey,
                            dwIndex,
                            wszValueName,
                            &dwValueNameSize,
                            NULL,
                            &dwType,
                            (BYTE *) &dwValue,
                            &dwValueSize);
            }
        }

        RegCloseKey(hKey);
    }
}


bool
RedirectDisabled(void)
{
    if (g_bDisableChecked)
    {
        return (g_bRedirectDisabled);
    }

    // the disabled reg setting hashn't been checked yet, so check it.
    // make sure only one thread does it
    __try {
        EnterCriticalSection(&g_csCheckingDisabled);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // give up
        CalaisWarning(__SUBROUTINE__, DBGT("EnterCriticalSection failed."));
        return (false);
    }

    //
    // Now that we are in the CritSec, check again
    //
    if (g_bDisableChecked)
    {
        LeaveCriticalSection(&g_csCheckingDisabled);
        return (g_bRedirectDisabled);
    }

    SetRedirectDisabledValue();

    //
    // register for registry change notifications
    //

    g_bDisableChecked = true;

    LeaveCriticalSection(&g_csCheckingDisabled);

    return (g_bRedirectDisabled);
}


bool
CheckServicesListForPID()
{
    bool                            fRet            = false;
    SC_HANDLE                       hScm            = NULL;
    LPENUM_SERVICE_STATUS_PROCESS   pInfo           = NULL;
    DWORD                           cbInfo          = 0;
    DWORD                           cbExtraNeeded   = 0;
    DWORD                           dwResume        = 0;
    DWORD                           dwNumServices   = 0;
    DWORD                           dwPID           = GetCurrentProcessId();
    DWORD                           i               = 0;

    //
    // Connect to the service controller.
    //
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

    if (hScm == NULL)
    {
        CalaisDebug((DBGT("OpenSCManager failed: %lx\n"), GetLastError()));
        goto ErrorReturn;
    }

    if (!EnumServicesStatusEx(
            hScm,
            SC_ENUM_PROCESS_INFO,
            SERVICE_WIN32,
            SERVICE_STATE_ALL,
            (LPBYTE)pInfo,
            cbInfo,
            &cbExtraNeeded,
            &dwNumServices,
            &dwResume,
            NULL))
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            CalaisDebug((DBGT("EnumServicesStatusEx failed: %lx\n"), GetLastError()));
            goto ErrorReturn;
        }

        //
        // Need a bigger buffer
        //
        cbInfo = cbExtraNeeded;
        pInfo = (LPENUM_SERVICE_STATUS_PROCESS) malloc(cbInfo);
        if (pInfo == NULL)
        {
            CalaisDebug((DBGT("LocalAlloc failed\n")));
            goto ErrorReturn;
        }

        memset(pInfo, 0, cbInfo);
        cbExtraNeeded = 0;
        dwNumServices = 0;
        dwResume = 0;

        if (!EnumServicesStatusEx(
                hScm,
                SC_ENUM_PROCESS_INFO,
                SERVICE_WIN32,
                SERVICE_STATE_ALL,
                (LPBYTE)pInfo,
                cbInfo,
                &cbExtraNeeded,
                &dwNumServices,
                &dwResume,
                NULL))
        {
            CalaisDebug((DBGT("EnumServicesStatusEx failed: %lx\n"), GetLastError()));
            goto ErrorReturn;
        }
    }

    //
    // Loop trough each service PID and check for current process PID
    //
    while (i < dwNumServices)
    {
        if (pInfo[i].ServiceStatusProcess.dwProcessId == dwPID)
        {
            fRet = true;
            break;
        }

        i++;
    }

Return:

    if (hScm != NULL)
    {
        CloseServiceHandle(hScm);
    }

    if (pInfo != NULL)
    {
        free(pInfo);
    }

    return (fRet);

ErrorReturn:

    fRet = false;
    goto Return;
}

BOOL
InAService()
{
    static bool fServiceChecked = false;
    static bool fInService      = false;

    //
    // Only make the "in a service?" check once
    //
    if (!fServiceChecked)
    {
        fInService = CheckServicesListForPID();
        fServiceChecked = true;
    }

    return fInService;
}

BOOL
InTSRedirectMode()
{
    //
    // If we are in a service, or the session isn't currently
    // remoted, then stay local.  The key here is that being in
    // a service overrides the session remoted check
    //
    if (InAService() || (0 == GetSystemMetrics(SM_REMOTESESSION)))
    {
        return (FALSE);
    }
    else
    {
        return (TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\winscard.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WinSCard

Abstract:

    This module supplies the API for the Calais Smartcard Service Manager.

    The Calais Service Manager does the work of coordinating the protocols,
    readers, drivers, and smartcards on behalf of the application.  The
    following services are provided as part of a library to simplify access to
    the Service Manager.  These routines are the documented, exposed APIs.
    These routines merely package the requests and forward them to the Calais
    Service Manager, allowing the actual implementation of Calais to vary over
    time.

    At no time does the API library make security decisions.  All
    security-related functions must be performed by the Service Manager, running
    in its own address space, or in the operating system kernel.  However, some
    utility routines may be implemented in the API library for speed, as long as
    they do not involve security decisions.


Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <wtsapi32.h>
#include "client.h"
#include "redirect.h"
#include "winsta.h"

const SCARD_IO_REQUEST
    g_rgSCardT0Pci  = { SCARD_PROTOCOL_T0,  sizeof(SCARD_IO_REQUEST) },
    g_rgSCardT1Pci  = { SCARD_PROTOCOL_T1,  sizeof(SCARD_IO_REQUEST) },
    g_rgSCardRawPci = { SCARD_PROTOCOL_RAW, sizeof(SCARD_IO_REQUEST) };
CHandleList
    * g_phlContexts = NULL,
    * g_phlReaders = NULL;
const WCHAR g_wszBlank[] = L"\000";

HINSTANCE           g_hInst;
HANDLE              g_hSessionChangeEvent                       = NULL;
HANDLE              g_hSessionChangeCallbackHandle              = NULL;
ULONG_PTR           g_SessionChangeID                           = 0;
CRITICAL_SECTION    g_RegisterForSessionChangeNoticationsCS;
BOOL                g_fRegisteredForSessionChangeNotications    = FALSE;
DWORD               g_dwTimerCallbacksMade                      = 0;
DWORD               g_dwClientCount                             = 0;
HANDLE              g_hTimerEvent                               = NULL;
HANDLE              g_hWaitTimerEventCallbackHandle             = NULL;

CRITICAL_SECTION    g_SafeCreateHandleCS;
CRITICAL_SECTION    g_SetStartedEventCS;
CRITICAL_SECTION    g_RegisterForStoppedEventCS;
CRITICAL_SECTION    g_DllMainCS;
HANDLE              g_hWaitForStartedCallbackHandle             = NULL;
HANDLE              g_hUnifiedStartedEvent                      = NULL;
HANDLE              g_hWaitForStoppedCallbackHandle             = NULL;

CRITICAL_SECTION    g_TermSrvEnabledCS;
BOOL                g_fTermSrvEnableChecked                     = FALSE;
BOOL                g_bTermSrvEnabled                           = FALSE;
BOOL                g_fInClientRundown                          = FALSE;
BOOL                g_fInDllMain                                = FALSE;


BOOL SetStartedEventWhenSCardSubsytemIsStarted(BOOL fUseLocal);


void
PrintDebugString(LPSTR szString, DWORD dwValue)
{
    char szOutString[256];

    sprintf(szOutString,
            "%d.%d> WINSCARD: %s - %lx\n",
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            szString,
            dwValue);

    //OutputDebugStringA(szOutString);
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Mark all current held contexts bad
//
WINSCARDAPI void WINAPI
MarkContextsAsBad(BOOL fCancel)
{
    try {
        g_phlContexts->MarkContentAsBad(fCancel);
        g_phlReaders->MarkContentAsBad(FALSE);
    }
    catch (...)
    {
    }
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  DllMain
//
BOOL WINAPI
DllMain(
    HMODULE hInstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved)
{
    DWORD dw;
    BOOL f;

    g_fInDllMain = TRUE;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:

        g_hInst = hInstDLL;

        try
        {
            dw = 0;;
            InitializeCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            dw++;
            InitializeCriticalSection(&g_SafeCreateHandleCS);
            dw++;
            InitializeCriticalSection(&g_SetStartedEventCS);
            dw++;
            InitializeCriticalSection(&g_TermSrvEnabledCS);
            dw++;
            InitializeCriticalSection(&g_RegisterForStoppedEventCS);
            dw++;
            InitializeCriticalSection(&g_DllMainCS);
        }
        catch(...)
        {
            if (dw >= 1)
            {
                DeleteCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            }
            if (dw >= 2)
            {
                DeleteCriticalSection(&g_SafeCreateHandleCS);
            }
            if (dw >= 3)
            {
                DeleteCriticalSection(&g_SetStartedEventCS);
            }
            if (dw >= 4)
            {
                DeleteCriticalSection(&g_TermSrvEnabledCS);
            }
            if (dw >= 5)
            {
                DeleteCriticalSection(&g_RegisterForStoppedEventCS);
            }

            g_fInDllMain = FALSE;
            return FALSE;
        }

        g_phlContexts = new CHandleList(CONTEXT_HANDLE_ID);
        g_phlReaders = new CHandleList(READER_HANDLE_ID);

        if ((NULL == g_phlContexts)     ||
            (NULL == g_phlReaders)      ||
            g_phlContexts->InitFailed() ||
            g_phlReaders->InitFailed())
        {
            if (g_phlContexts)
            {
                delete g_phlContexts;
                g_phlContexts = NULL;
            }

            if (g_phlReaders)
            {
                delete g_phlReaders;
                g_phlReaders = NULL;
            }

            DeleteCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            DeleteCriticalSection(&g_SafeCreateHandleCS);
            DeleteCriticalSection(&g_SetStartedEventCS);
            DeleteCriticalSection(&g_TermSrvEnabledCS);
            DeleteCriticalSection(&g_RegisterForStoppedEventCS);
            DeleteCriticalSection(&g_DllMainCS);

            g_fInDllMain = FALSE;
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // Clean up the registered waits if they are still outstanding
        //
        HANDLE hCallbackToUnregister;

        EnterCriticalSection(&g_DllMainCS);
        g_fInDllMain = TRUE;
        LeaveCriticalSection(&g_DllMainCS);

        hCallbackToUnregister = InterlockedExchangePointer(
                                    &g_hWaitTimerEventCallbackHandle,
                                    NULL);

        if (hCallbackToUnregister != NULL)
        {
            UnregisterWaitEx(hCallbackToUnregister, INVALID_HANDLE_VALUE);
        }

        hCallbackToUnregister = InterlockedExchangePointer(
                                    &g_hSessionChangeCallbackHandle,
                                    NULL);

        if (hCallbackToUnregister != NULL)
        {
            UnregisterWaitEx(hCallbackToUnregister, INVALID_HANDLE_VALUE);
        }

        hCallbackToUnregister = InterlockedExchangePointer(
                                    &g_hWaitForStoppedCallbackHandle,
                                    NULL);

        if (hCallbackToUnregister != NULL)
        {
            UnregisterWaitEx(hCallbackToUnregister, INVALID_HANDLE_VALUE);
        }

        hCallbackToUnregister = InterlockedExchangePointer(
                                    &g_hWaitForStartedCallbackHandle,
                                    NULL);

        if (hCallbackToUnregister != NULL)
        {
            UnregisterWaitEx(hCallbackToUnregister, INVALID_HANDLE_VALUE);
        }

        //
        // The third parameter, lpvReserved, passed to DllMain
        // is NULL for FreeLibrary and non-NULL for ProcessExit.
        // Only clean up for FreeLibrary
        //
        if (lpvReserved == NULL)
        {
            if (g_hSessionChangeEvent != NULL)
            {
                CloseHandle(g_hSessionChangeEvent);
            }

            if (g_hTimerEvent != NULL)
            {
                CloseHandle(g_hTimerEvent);
            }

            //
            // Cleanup CritSecs.
            //
            DeleteCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            DeleteCriticalSection(&g_SafeCreateHandleCS);
            DeleteCriticalSection(&g_SetStartedEventCS);
            DeleteCriticalSection(&g_TermSrvEnabledCS);
            DeleteCriticalSection(&g_RegisterForStoppedEventCS);
            DeleteCriticalSection(&g_DllMainCS);

            try {
                if (g_phlReaders)
                {
                    g_fInClientRundown = TRUE;

                    CHandle * pReader = g_phlReaders->GetFirst();

                    while (pReader != NULL)
                    {
                        try
                        {
                            ((CReaderContext *) pReader)->EndTransaction(SCARD_LEAVE_CARD_FORCE);
                        }
                        catch (...){}

                        pReader = g_phlReaders->GetNext(pReader);
                    }

                    delete g_phlReaders;
                    g_phlReaders = NULL;
                }

                if (g_phlContexts)
                {
                    delete g_phlContexts;
                    g_phlContexts = NULL;
                }
            }
            catch (...)
            {
            }

            ReleaseStartedEvent();
            ReleaseStoppedEvent();

            if (g_hUnifiedStartedEvent != NULL)
            {
                CloseHandle(g_hUnifiedStartedEvent);
            }
        }
        break;
    }

    f = RedirDllMain(hInstDLL, fdwReason, lpvReserved);

    g_fInDllMain = FALSE;

    return(f);
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SessionChangeCallback
//
VOID CALLBACK
SessionChangeCallback(
  PVOID     lpParameter,
  BOOLEAN   TimerOrWaitFired)
{
    WTS_CONNECTSTATE_CLASS  *pConnectState  = NULL;
    BOOL                    fConnected      = FALSE;
    DWORD                   dw;
    HANDLE                  hCallbackToUnregister;

    EnterCriticalSection(&g_DllMainCS);
        
    if (g_fInDllMain) 
    {
        LeaveCriticalSection(&g_DllMainCS);
        return;
    }

    //
    // If we are registered for local smart card stopped callbacks then
    // unregister
    //
    hCallbackToUnregister = InterlockedExchangePointer(
                                &g_hWaitForStoppedCallbackHandle,
                                NULL);

    if (hCallbackToUnregister != NULL)
    {
        UnregisterWait(hCallbackToUnregister);
    }

    //
    // Detect whether we are in a connected state or not
    //
    if (!WTSQuerySessionInformation(
            WTS_CURRENT_SERVER_HANDLE,
            WTS_CURRENT_SESSION,
            WTSConnectState,
            (LPTSTR *) &pConnectState,
            &dw))
    {
        //OutputDebugString("WINSCARD: SessionChangeCallback: WTSQuerySessionInformation failed!\n");
        LeaveCriticalSection(&g_DllMainCS);
        return;
    }

    fConnected = (  (*pConnectState == WTSActive) ||
                    (*pConnectState == WTSConnected));

    WTSFreeMemory(pConnectState);

    //
    // If there is an outstanding wait, it may be waiting on the wrong event,
    // so cancel the wait here.  When there is a connect event the
    // SetStartedEventWhenSCardSubsytemIsStarted() API will be called again
    // to wait on the correct event
    //
    hCallbackToUnregister = InterlockedExchangePointer(
                                &g_hWaitForStartedCallbackHandle,
                                NULL);

    if (hCallbackToUnregister != NULL)
    {
        UnregisterWait(hCallbackToUnregister);
    }

    if (!fConnected)
    {
        //
        // Make sure the unified started event isn't set since we
        // are now in a disconnected state
        //
        //OutputDebugString("WINSCARD: SessionChangeCallback: Disconnect\n");
        ResetEvent(g_hUnifiedStartedEvent);

        //
        // Only mark the contexts bad if we're not in a service, because we
        // know we're not redirecting if we're in a service.
        //
        if (FALSE == InAService())
            MarkContextsAsBad(TRUE);
    }
    else
    {
        //OutputDebugString("WINSCARD: SessionChangeCallback: Reconnect\n");
        SetRedirectDisabledValue();
        SetStartedEventWhenSCardSubsytemIsStarted(FALSE);
    }

    LeaveCriticalSection(&g_DllMainCS);
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  TimerCallback
//
VOID CALLBACK
TimerCallback(
  PVOID     lpParameter,
  BOOLEAN   TimerOrWaitFired
)
{
    HANDLE h = NULL;
    BOOL fUnregister = TRUE;

    __try
    {
        EnterCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }

    if (g_dwClientCount == 0)
    {
        LeaveCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
        return;
    }

    //
    // The check for !g_fInDllMain is only to reduce the window in which a deadlock
    // can occur.  The deadlock condition is as follows:
    //
    // 1) A thread enters winscard's DllMain (the thread in DllMain is of course holding the loader lock)
    // 2) TimerCallback gets called
    // 3) winscard's DllMain calls UnregisterWaitEx(INVALID_HANDLE_VALUE) for TimerCallback, which will
    //      block until the TimerCallback callback completes.
    // 4) TimerCallback makes the WinStationRegisterNotificationEvent call which may try to load or unload
    //      a DLL, which of course requires the loader lock.
    // 5) WHAMO!!!
    //
    if (!g_fInDllMain)
    {
        if (!g_fRegisteredForSessionChangeNotications)
        {
            if (WinStationRegisterNotificationEvent(
                    g_hSessionChangeEvent,
                    &g_SessionChangeID,
                    NOTIFY_FOR_THIS_SESSION,
                    WTS_CONSOLE_CONNECT_MASK |
                        WTS_CONSOLE_DISCONNECT_MASK |
                        WTS_REMOTE_CONNECT_MASK |
                        WTS_REMOTE_DISCONNECT_MASK))
            {
                g_fRegisteredForSessionChangeNotications = TRUE;
            }
            else if (++g_dwTimerCallbacksMade < 60) // 60 attemps at 10 seconds each will be ten minutes
            {
                //
                // We still haven't succusfully registered for session change notifications and we haven't
                // exausted our max retries, so don't unregister the callback yet.
                //
                fUnregister = FALSE;
            }
        }
    }
    else
    {
        fUnregister = FALSE;
    }

    if (fUnregister)
    {
        h = InterlockedExchangePointer(&g_hWaitTimerEventCallbackHandle, NULL);
        if (h != NULL)
        {
            UnregisterWait(h);
        }
    }

    LeaveCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  RegisterForSessionChangeNotifications
//
BOOL
RegisterForSessionChangeNotifications()
{
    BOOL fRet = TRUE;

    //
    // Make sure we only register for session change notifications once
    //
    __try
    {
        EnterCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    g_dwClientCount++;

    //
    // If the global session change event and callback aren't setup then do that
    //
    if (g_hSessionChangeEvent == NULL)
    {
        g_hSessionChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (g_hSessionChangeEvent == NULL)
        {
            goto ErrorReturn;
        }

        if (!RegisterWaitForSingleObject(
                &g_hSessionChangeCallbackHandle,
                g_hSessionChangeEvent,
                SessionChangeCallback,
                0,
                INFINITE,
                WT_EXECUTEDEFAULT))
        {
            CloseHandle(g_hSessionChangeEvent);
            g_hSessionChangeEvent = NULL;
            goto ErrorReturn;
        }
    }

    //
    // Register with the WTS subsystem for change notifications
    //
    if (!g_fRegisteredForSessionChangeNotications)
    {
        if (WinStationRegisterNotificationEvent(
                g_hSessionChangeEvent,
                &g_SessionChangeID,
                NOTIFY_FOR_THIS_SESSION,
                WTS_CONSOLE_CONNECT_MASK |
                    WTS_CONSOLE_DISCONNECT_MASK |
                    WTS_REMOTE_CONNECT_MASK |
                    WTS_REMOTE_DISCONNECT_MASK))
        {
            g_fRegisteredForSessionChangeNotications = TRUE;
        }
        else if (g_hWaitTimerEventCallbackHandle == NULL)
        {
            //OutputDebugString("WINSCARD: RegisterForSessionChangeNotifications - WinStationRegisterNotificationEvent failed!!\n");

            //
            // Since the WinStationRegisterNotificationEvent call failed, TermSrv probably
            // isn't ready, so just register for a callback and try to register again later
            //

            g_dwTimerCallbacksMade = 0;

            if (g_hTimerEvent == NULL)
            {
                g_hTimerEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            }

            if (!RegisterWaitForSingleObject(
                    &g_hWaitTimerEventCallbackHandle,
                    g_hTimerEvent,
                    TimerCallback,
                    0,
                    10000,
                    WT_EXECUTEDEFAULT))
            {
                goto ErrorReturn;
            }
        }
    }

Return:

    LeaveCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
    return fRet;

ErrorReturn:

    g_dwClientCount--;
    fRet = FALSE;
    goto Return;
}

//
////////////////////////////////////////////////////////////////////////////////
//
//  UnRegisterForSessionChangeNotifications
//
BOOL
UnRegisterForSessionChangeNotifications()
{
    BOOL fRet = TRUE;
    HANDLE h;

    //
    // Make sure we only unregister if there are no more clients
    //
    __try
    {
        EnterCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    if (g_dwClientCount == 0)
    {
        fRet = FALSE;
        goto Return;
    }
    else if (g_dwClientCount == 1)
    {
        g_dwClientCount = 0;

        //
        // If the timer callback is going then kill it
        //
        h = InterlockedExchangePointer(&g_hWaitTimerEventCallbackHandle, NULL);
        if (h != NULL)
        {
            UnregisterWait(h);
        }

        //
        // If we are registered then unregister
        //
        if (g_fRegisteredForSessionChangeNotications)
        {
            WinStationUnRegisterNotificationEvent(g_SessionChangeID);
            g_SessionChangeID = 0;
        }

        g_fRegisteredForSessionChangeNotications = FALSE;
    }
    else
    {
        g_dwClientCount--;
    }

Return:

    LeaveCriticalSection(&g_RegisterForSessionChangeNoticationsCS);

    return fRet;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SetStartedEventAfterTestingConnectedState
//
BOOL
SetStartedEventAfterTestingConnectedState()
{
    BOOL                    fRet            = TRUE;
    WTS_CONNECTSTATE_CLASS  *pConnectState  = NULL;
    BOOL                    fConnected      = FALSE;
    DWORD                   dw;
    BOOL                    fUnregister     = FALSE;

    //
    // Register for connect/disconnect notifications from the WTS subsystem
    //
    if (!RegisterForSessionChangeNotifications())
    {
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - RegisterForSessionChangeNotifications failed!!\n");
        goto ErrorReturn;
    }

    fUnregister = TRUE;

    //
    // Detect whether we are in a connected state or not
    //
    if (!WTSQuerySessionInformation(
            WTS_CURRENT_SERVER_HANDLE,
            WTS_CURRENT_SESSION,
            WTSConnectState,
            (LPTSTR *) &pConnectState,
            &dw))
    {
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - WTSQuerySessionInformation failed!!\n");

        //
        // Since that failed, TermSrv is probably not started, so just go local
        //
        if (!SetStartedEventWhenSCardSubsytemIsStarted(TRUE))
        {
            goto ErrorReturn;
        }

        goto Return;
    }

    fConnected = (  (*pConnectState == WTSActive) ||
                    (*pConnectState == WTSConnected));

    WTSFreeMemory(pConnectState);

    //
    // If we are connected, then call SetStartedEventWhenSCardSubsytemIsStarted
    // which will detect whether we are in local or redirect mode and subsequently
    // wait on the appropriate smart card subsystem (the local or the remote).
    // Otherwise, we are not connected, so do nothing since
    // SetStartedEventWhenSCardSubsytemIsStarted will be called once when we get
    // a connnected notification from the WTS subsystem
    //
    if (fConnected)
    {
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - Connected!!\n");
        if (!SetStartedEventWhenSCardSubsytemIsStarted(FALSE))
        {
            goto ErrorReturn;
        }
    }
    else
    {
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - NOT Connected!!\n");
    }

Return:
    return fRet;

ErrorReturn:

    if (fUnregister)
    {
        UnRegisterForSessionChangeNotifications();
    }

    fRet = FALSE;
    goto Return;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  TermSrvEnabled
//
BOOL
TermSrvEnabled()
{
    BOOL                    fRet             = TRUE;
    SC_HANDLE               schSCM           = NULL;
    SC_HANDLE               schService       = NULL;
    LPQUERY_SERVICE_CONFIG  pServiceConfig   = NULL;
    DWORD                   cbServiceConfig  = 0;

    //
    // Make sure we only do this once
    //
    __try
    {
        EnterCriticalSection(&g_TermSrvEnabledCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    if (g_fTermSrvEnableChecked)
    {
        goto Return;
    }

    //
    // Open the service control manager
    //
    schSCM = OpenSCManagerW( NULL, NULL, SC_MANAGER_CONNECT );
    if(schSCM == NULL)
    {
        //OutputDebugString("WINSCARD: TermSrvEnabled - OpenSCManagerW failed!!\n");
        goto Return;
    }

    //
    // open the "Terminal Services" service so we can query it's configuration
    //
    schService = OpenServiceW(schSCM, L"TermService", SERVICE_QUERY_CONFIG);

    if (schService == NULL)
    {
        //OutputDebugString("WINSCARD: TermSrvEnabled - OpenServiceW failed!!\n");
        goto Return;
    }

    //
    // Get and check the services configuration
    //
    QueryServiceConfig(schService, NULL, 0, &cbServiceConfig);
    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pServiceConfig = (LPQUERY_SERVICE_CONFIG) HeapAlloc(
                                                    GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    cbServiceConfig);
        if (pServiceConfig == NULL)
        {
            goto Return;
        }

        if (QueryServiceConfig(schService, pServiceConfig, cbServiceConfig, &cbServiceConfig))
        {
            if(pServiceConfig->dwStartType == SERVICE_DISABLED)
            {
                g_fTermSrvEnableChecked = TRUE;
                goto Return;
            }
        }
        else
        {
            //OutputDebugString("WINSCARD: TermSrvEnabled - QueryServiceConfig failed - 2!!\n");
            goto Return;
        }
    }
    else
    {
        //OutputDebugString("WINSCARD: TermSrvEnabled - QueryServiceConfig failed!!\n");
        goto Return;
    }

    g_fTermSrvEnableChecked = TRUE;
    g_bTermSrvEnabled = TRUE;

Return:

    LeaveCriticalSection(&g_TermSrvEnabledCS);

    if (pServiceConfig != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pServiceConfig);
    }

    if (schService != NULL)
    {
        CloseServiceHandle(schService);
    }

    if (schSCM != NULL)
    {
        CloseServiceHandle(schSCM);
    }

    return g_bTermSrvEnabled;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SafeCreateEvent
//
BOOL
SafeCreateEvent(
    HANDLE *phEvent)
{
    BOOL fRet = TRUE;

    __try
    {
        EnterCriticalSection(&g_SafeCreateHandleCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return (FALSE);
    }

    if (*phEvent != NULL)
    {
        goto Return;
    }

    *phEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (*phEvent == NULL)
    {
        fRet = FALSE;
    }

Return:
    LeaveCriticalSection(&g_SafeCreateHandleCS);
    return (fRet);
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SmartCardSubsystemStoppedCallback and RegisterForStoppedCallback
//
VOID CALLBACK SmartCardSubsystemStoppedCallback(
  PVOID     lpParameter,
  BOOLEAN   TimerOrWaitFired
)
{
    HANDLE hCallbackToUnregister;

    EnterCriticalSection(&g_DllMainCS);

    if (g_fInDllMain) 
    {
        LeaveCriticalSection(&g_DllMainCS);
        return;
    }

    //OutputDebugString("WINSCARD: SmartCardSubsystemStoppedCallback - resetting event \n");
    ResetEvent(g_hUnifiedStartedEvent);

    SetStartedEventWhenSCardSubsytemIsStarted(TRUE);

    hCallbackToUnregister = InterlockedExchangePointer(
                                &g_hWaitForStoppedCallbackHandle,
                                NULL);

    if (hCallbackToUnregister != NULL)
    {
        UnregisterWait(hCallbackToUnregister);
    }

    LeaveCriticalSection(&g_DllMainCS);
}

BOOL
RegisterForStoppedCallback()
{
    BOOL    fRet        = TRUE;
    BOOL    fEnteredCS  = FALSE;
    HANDLE  h           = NULL;

    h = AccessStoppedEvent();
    if (h == NULL)
    {
        goto ErrorReturn;
    }

    __try
    {
        EnterCriticalSection(&g_RegisterForStoppedEventCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto ErrorReturn;
    }

    fEnteredCS = TRUE;

    if (g_hWaitForStoppedCallbackHandle != NULL)
    {
        goto Return;
    }

    if (!RegisterWaitForSingleObject(
            &g_hWaitForStoppedCallbackHandle,
            h,
            SmartCardSubsystemStoppedCallback,
            0,
            INFINITE,
            WT_EXECUTEONLYONCE))
    {
        goto ErrorReturn;
    }

Return:

    if (fEnteredCS)
    {
        LeaveCriticalSection(&g_RegisterForStoppedEventCS);
    }

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto Return;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SmartCardSubsystemStartedCallback
//
//  This callback is fired when the smart card subsystem sets its started event.
//  NOTE: Both local and remote scard subsystems being started will fire this
//  same callback
//
VOID CALLBACK SmartCardSubsystemStartedCallback(
  PVOID     lpParameter,
  BOOLEAN   TimerOrWaitFired
)
{
    BOOL fLocal = (lpParameter == (PVOID) 1);
    HANDLE hCallbackToUnregister;

    EnterCriticalSection(&g_DllMainCS);

    if (g_fInDllMain) 
    {
        LeaveCriticalSection(&g_DllMainCS);
        return;
    }

    //OutputDebugString("WINSCARD: SmartCardSubsystemStartedCallback - setting event \n");
    SetEvent(g_hUnifiedStartedEvent);

    if (fLocal)
    {
        RegisterForStoppedCallback();
    }

    hCallbackToUnregister = InterlockedExchangePointer(
                                &g_hWaitForStartedCallbackHandle,
                                NULL);

    if (hCallbackToUnregister != NULL)
    {
        UnregisterWait(hCallbackToUnregister);
    }

    LeaveCriticalSection(&g_DllMainCS);
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SetStartedEventWhenSCardSubsytemIsStarted
//
BOOL
SetStartedEventWhenSCardSubsytemIsStarted(
    BOOL fUseLocal)
{
    HANDLE  h               = NULL;
    BOOL    fRet            = TRUE;
    BOOL    fEnteredCritSec = FALSE;
    BOOL    fLocal          = FALSE;

    //
    // If termsrv is enabled and we are in redirect mode then get the
    // started event that corresponds to the remoted scard subsystem being
    // available, otherwise, get the started event of the local scard
    // resource manager
    //
    if (!fUseLocal && TermSrvEnabled() && InTSRedirectMode())
    {
        //OutputDebugString("WINSCARD: SetStartedEventWhenSCardSubsytemIsStarted REDIRECT\n");
        //
        // if redirect is disabled, then just get out
        //
        if (TS_REDIRECT_DISABLED)
        {
            goto Return;
        }

        if (TS_REDIRECT_READY)
        {
            h = pfnSCardAccessStartedEvent();
        }
        else
        {
            goto ErrorReturn;
        }
    }
    else
    {
        //OutputDebugString("WINSCARD: SetStartedEventWhenSCardSubsytemIsStarted LOCAL\n");
        h = AccessStartedEvent();
        fLocal = TRUE;
    }

    if (h == NULL)
    {
        goto ErrorReturn;
    }

    //
    // If the event is already set, then just set the event returned
    // to the caller and return
    //
    if (WAIT_OBJECT_0 == WaitForSingleObject(h, 0))
    {
        //OutputDebugString("WINSCARD: SetStartedEventWhenSCardSubsytemIsStarted SETTING EVENT\n");
        SetEvent(g_hUnifiedStartedEvent);

        if (fLocal)
        {
            RegisterForStoppedCallback();
        }

        goto Return;
    }

    //
    // The event wasn't set so we need to register a callback which
    // fires when the scard subsystem is started.
    //
    // Make sure only one callback is registered.
    //
    __try
    {
        EnterCriticalSection(&g_SetStartedEventCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto ErrorReturn;
    }

    fEnteredCritSec = TRUE;

    //
    // There is already a callback registered, so just get out
    //
    if (g_hWaitForStartedCallbackHandle != NULL)
    {
        goto Return;
    }

    //
    // Register for the callback.  The callback is fired when the smart
    // card resource manager event is set (either the remote or the local
    // subsystem event, based on whether this is a redirected session or not).
    //
    if (!RegisterWaitForSingleObject(
            &g_hWaitForStartedCallbackHandle,
            h,
            SmartCardSubsystemStartedCallback,
            (fLocal ? ((PVOID) 1) : ((PVOID) 0)), // tell the callback whether this is local or not
            INFINITE,
            WT_EXECUTEONLYONCE))
    {
        goto ErrorReturn;
    }

Return:
    if (fEnteredCritSec)
    {
        LeaveCriticalSection(&g_SetStartedEventCS);
    }

    return (fRet);

ErrorReturn:
    fRet = FALSE;
    goto Return;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Access Services
//
//      The following services are used to manage user and terminal contexts for
//      smartcards.
//

/*++

SCardEstablishContext:

    This service establishes a context within which communication to the Service
    Manager is performed.

Arguments:

    dwScope supplies the scope under which this context acts.  Possible values
        are:

        SCARD_SCOPE_USER - The context is a user context, and any database
            operations are performed within the domain of the user.

        SCARD_SCOPE_TERMINAL - The context is that of the current terminal, and
            any database operations are performed within the domain of that
            terminal.  (The calling application must have appropriate access
            permissions for any database actions.)

        SCARD_SCOPE_SYSTEM - The context is the system context, and any database
            operations are performed within the domain of the system.  (The
            calling application must have appropriate access permissions for any
            database actions.)

    pvReserved1 is reserved for future use, and must be NULL.  [Reserved to
        allow a suitably privileged management application to act on behalf of
        another user.]

    PvReserved2 is reserved for future use, and must be NULL.  [Reserved to
        allow a suitably privileged management application to act on behalf of
        another terminal.]

    phContext receives a handle to the established context, to be supplied to
        other routines attempting to do work within the context.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardEstablishContext")

WINSCARDAPI LONG WINAPI
SCardEstablishContext(
    IN DWORD dwScope,
    IN LPCVOID pvReserved1,
    IN LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CSCardUserContext *pCtx = NULL;

    try
    {
        if (NULL != pvReserved1)
            throw (DWORD)SCARD_E_INVALID_VALUE;
        if (NULL != pvReserved2)
            throw (DWORD)SCARD_E_INVALID_VALUE;
        if ((SCARD_SCOPE_USER != dwScope)
            // && (SCARD_SCOPE_TERMINAL != dwScope) // Maybe NT V5+?
            && (SCARD_SCOPE_SYSTEM != dwScope))
            throw (DWORD)SCARD_E_INVALID_VALUE;
        *phContext = 0;     // Make sure it's valid.

        pCtx = new CSCardUserContext(dwScope);
        if (NULL == pCtx)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Client can't allocate a new context"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }
        if (pCtx->InitFailed())
        {
            delete pCtx;
            pCtx = NULL;
            return SCARD_E_NO_MEMORY;
        }

        if (!SafeCreateEvent(&g_hUnifiedStartedEvent))
        {
            throw GetLastError();
        }

        //
        // If TermSrv is enabled then register for session change notifications.
        // Don't fail if we can't do this, since it may not be fatal
        //
        if (TermSrvEnabled() && RegisterForSessionChangeNotifications())
        {
            pCtx->fCallUnregister = TRUE;
        }
        else
        {
            pCtx->fCallUnregister = FALSE;
        }

        if (InTSRedirectMode())
        {
            HANDLE hHeap;
            SCARDCONTEXT hContext = NULL;
            HANDLE hEvent = NULL;

            //
            // if redirect is disabled, then just get out
            //
            if (TS_REDIRECT_DISABLED)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }

            hEvent = g_hUnifiedStartedEvent;

            pCtx->AllocateMemory(0);
            hHeap = pCtx->HeapHandle();
            if (NULL == hHeap)
                throw GetLastError();

            if (!TS_REDIRECT_READY)
            {
                throw GetLastError();
            }

            nReturn  = pfnSCardEstablishContext(dwScope, (LPCVOID)hHeap, (LPCVOID) hEvent, &hContext);

            //
            // See if there is an indication that the client's scardsvr service was shutdown
            //
            if (SCARD_E_NO_SERVICE == nReturn)
            {
                SetStartedEventAfterTestingConnectedState();
                //OutputDebugString("WINSCARD: SCardEstablishContext: got E_NO_SERVICE!\n");
            }

            if (SCARD_S_SUCCESS != nReturn)
                throw (DWORD)nReturn;

            pCtx->SetRedirContext(hContext);
        }
        else
        {
            pCtx->EstablishContext();
        }

        *phContext = g_phlContexts->Add(pCtx);
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pCtx)
            delete pCtx;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pCtx)
            delete pCtx;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIsValidContext:

    This routine verifies that the context to the Service Manager is intact.
    It is possible that if someone stops the Resource Manager Service, that
    existing handles can be rendered useless, resulting in an
    SCARD_E_SERVICE_STOPPED error.  This routine simply tests to see if the
    context is valid by pinging the server.  It's used internally to validate
    handles, and appears useful for external tools.

Arguments:

    hContext supplies the handle to the context previously established via the
        SCardEstablishContext service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.  Specific interesting error codes are:

    SCARD_E_SERVICE_STOPPED - The Resource Manager Service has been ended.

    SCARD_E_INVALID_HANDLE - The supplied handle isn't valid.

Author:

    Doug Barlow (dbarlow) 11/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIsValidContext")

WINSCARDAPI LONG WINAPI
SCardIsValidContext(
    IN SCARDCONTEXT hContext)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (NULL != hRedirContext) {
            nReturn = pfnSCardIsValidContext(hRedirContext);
        }
        else
        {
            try
            {
                if (!pCtx->IsValidContext())
                    throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            catch (...)
            {
                SCardReleaseContext(hContext);
                throw;
            }
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}

////////////////////////////////////////////////////////////////////////////////
//
//  IsSafeToUnregisterForSessionChangeNotifications
//
BOOL IsSafeToUnregisterForSessionChangeNotifications(
    IN SCARDCONTEXT hContext)
{
    //
    // Check if the loader lock is held by the caller (in which case
    // we may be in the caller's DllMain right now).  If the lock is held,
    // it's not safe to make the Unregister RPC call, since that could cause
    // deadlock.
    //

    // IsSafe is TRUE if the current Thread is Not Equal to the lock's owning
    // thread.
    //
    // Note, we tried using RtlIsThreadWithinLoaderCallout here, but that only
    // tells us if we're in PROCESS_ATTACH.  It doesn't tell us if we're in
    // any other loader callbacks so it's not sufficient.

    return ( NtCurrentTeb()->ClientId.UniqueThread ) !=
            ( ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread );
}

/*++

SCardReleaseContext:

    This routine closes an established context to the Service Manager, and frees
    any resources allocated under that context.

Arguments:

    hContext supplies the handle to the context previously established via the
        SCardEstablishContext service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseContext")

WINSCARDAPI LONG WINAPI
SCardReleaseContext(
    IN SCARDCONTEXT hContext)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CSCardUserContext *pCtx = NULL;

    try
    {
        pCtx = (CSCardUserContext *)g_phlContexts->Close(hContext);
        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();

        if (pCtx->fCallUnregister)
        {
            if (IsSafeToUnregisterForSessionChangeNotifications(hContext))
            {
                UnRegisterForSessionChangeNotifications();
            }
        }

        if (NULL != hRedirContext)
        {
            if (pCtx->IsBad())
            {
                nReturn  = pfnSCardReleaseBadContext(hRedirContext);
            }
            else
            {
                nReturn  = pfnSCardReleaseContext(hRedirContext);
            }
        }
        else
        {
            try
            {
                pCtx->Cancel();
                pCtx->ReleaseContext();
            }
            catch (...) {}
        }
        delete pCtx;
        pCtx = NULL;
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Support Routines
//
//      The following services are supplied to simplify the use of the Service
//      Manager API.
//

/*++

SCardFreeMemory:

    This routine releases memory that has been returned from the Service Manager
    API via the use of the SCARD_AUTOALLOCATE length designator.

Arguments:

    hContext - This is the reference value returned from the
        SCardEstablishContext service.

    pvMem - This supplies the memory block to be released.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardFreeMemory")

WINSCARDAPI LONG WINAPI
SCardFreeMemory(
    IN SCARDCONTEXT hContext,
    IN LPCVOID pvMem)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        if ((NULL != pvMem) && ((LPVOID)g_wszBlank != pvMem))
        {
            if (NULL == hContext)
                HeapFree(GetProcessHeap(), 0, (LPVOID)pvMem);
            else
            {
                CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
                nReturn = (LONG)pCtx->FreeMemory(pvMem);
            }
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

/*++

SCardCancel:

    This service is used to terminate any and all outstanding actions within the
    context.  The caller supplies the context handle under which outstanding
    requests will be canceled.  Not all requests are cancelable; only those
    which require waiting for external action by the smartcard or user.  Any
    such outstanding action requests will terminate with a status indication
    that the action was canceled.  This is especially useful to force
    outstanding SCardGetStatusChange calls to terminate.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardCancel")

WINSCARDAPI LONG WINAPI
SCardCancel(
    IN SCARDCONTEXT hContext)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (NULL != hRedirContext) {
            return pfnSCardCancel(hRedirContext);
        }
        else
            pCtx->Cancel();
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

/*++

SCardReconnect:

    This service re-establishes an existing connection from the calling
    application to the smartcard.  This service is used to move a card handle
    from direct access to general access (see Section 4), or to acknowledge and
    clear an error condition that is preventing further access to the card.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

    DwShareMode supplies a flag indicating whether or not other applications may
        form connections to this card.  Possible values are:

        SCARD_SHARE_SHARED - This application is willing to share this card with
            other applications.

        SCARD_SHARE_EXCLUSIVE - This application is not willing to share this
            card with other applications.

    DwPreferredProtocols supplies a bit mask of acceptable protocols for this
        connection.  Possible values, which may be combined via the OR
        operation, are:

        SCARD_PROTOCOL_T0 - T=0 is an acceptable protocol.

        SCARD_PROTOCOL_T1 - T=1 is an acceptable protocol.

    DwInitialization supplies an indication as to the form of initialization
        that should be performed on the card.  Possible values are:

        SCARD_LEAVE_CARD - Don't do anything special on reconnect

        SCARD_RESET_CARD - Reset the card (Warm Reset)

        SCARD_UNPOWER_CARD - Power down the card and reset it (Cold Reset)

    pdwActiveProtocol receives a flag indicating the established active
        protocol.  Possible values are:

        SCARD_PROTOCOL_T0 - T=0 is the active protocol.

        SCARD_PROTOCOL_T1 - T=1 is the active protocol.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReconnect")

WINSCARDAPI LONG WINAPI
SCardReconnect(
    IN SCARDHANDLE hCard,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    IN DWORD dwInitialization,
    OUT LPDWORD pdwActiveProtocol)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);

        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardReconnect(pRdr->GetRedirCard(), dwShareMode, dwPreferredProtocols, dwInitialization, pdwActiveProtocol);
        }
        else
        {
            pRdr->Reconnect(
                    dwShareMode,
                    dwPreferredProtocols,
                    dwInitialization);
            if (NULL != pdwActiveProtocol)
                *pdwActiveProtocol = pRdr->Protocol();
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardDisconnect:

    This service terminates a previously opened connection between the calling
    application and the smartcard in the target reader.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

    dwDisposition - Supplies an indication of what should be done with the card
        in the connected reader.  Possible values are:

        SCARD_LEAVE_CARD - Don't do anything special on close

        SCARD_RESET_CARD - Reset the card on close

        SCARD_UNPOWER_CARD - Power down the card on close

        SCARD_EJECT_CARD - Eject the card on close

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents a warning condition.  The connection is terminated regardless of
    the return code.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardDisconnect")

WINSCARDAPI LONG WINAPI
SCardDisconnect(
    IN SCARDHANDLE hCard,
    IN DWORD dwDisposition)
{
    CReaderContext *pRdr = NULL;
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        pRdr = (CReaderContext *)g_phlReaders->Close(hCard);

        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardDisconnect(pRdr->GetRedirCard(), dwDisposition);
        }
        else
        {
            ASSERT(pRdr->Context()->m_hReaderHandle == hCard);
            pRdr->Context()->m_hReaderHandle = NULL;
            nReturn = pRdr->Disconnect(dwDisposition);
        }

        delete pRdr;
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pRdr)
            delete pRdr;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pRdr)
            delete pRdr;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardBeginTransaction:

    This service temporarily blocks other applications from accessing the
    smartcard, in order for this application to perform an operation that
    requires multiple interactions.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardBeginTransaction")

WINSCARDAPI LONG WINAPI
SCardBeginTransaction(
    IN SCARDHANDLE hCard)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardBeginTransaction(pRdr->GetRedirCard());
        }
        else
            pRdr->BeginTransaction();
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardEndTransaction:

    This service completes a previously declared transaction, allowing other
    applications to resume interactions with the card.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

    dwDisposition - Supplies an indication of what should be done with the card
        in the connected reader.  Possible values are:

        SCARD_LEAVE_CARD - Don't do anything special on close

        SCARD_RESET_CARD - Reset the card on close

        SCARD_UNPOWER_CARD - Power down the card on close

        SCARD_EJECT_CARD - Eject the card on close

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardEndTransaction")

WINSCARDAPI LONG WINAPI
SCardEndTransaction(
    IN SCARDHANDLE hCard,
    IN DWORD dwDisposition)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardEndTransaction(pRdr->GetRedirCard(), dwDisposition);
        }
        else
            pRdr->EndTransaction(dwDisposition);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardState:

    This routine provides the current state of the reader.  It may be used at
    any time following a successful call to SCardConnect or SCardOpenReader, and
    prior to a successful call to SCardDisconnect.  It does not effect the state
    of the reader or driver.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    pbAtr - This parameter points to a 32-byte buffer which receives the ATR
        string from the currently inserted card, if available.

    pbcAtrLen - This points to a DWORD which supplies the length of the pbAtr
        buffer, and receives the actual number of bytes in the ATR string.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardState")

WINSCARDAPI LONG WINAPI
SCardState(
    IN SCARDHANDLE hCard,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardState(pRdr->GetRedirCard(), pdwState, pdwProtocol, pbAtr, pcbAtrLen);
        }
        else
        {
            CBuffer bfAtr, bfRdr;
            DWORD dwLocalState, dwLocalProtocol;

            pRdr->Status(&dwLocalState, &dwLocalProtocol, bfAtr, bfRdr);
            if (NULL != pdwState)
                *pdwState = dwLocalState;
            if (NULL != pdwProtocol)
                *pdwProtocol = dwLocalProtocol;
            if (NULL != pcbAtrLen)
                PlaceResult(pRdr->Context()->Parent(), bfAtr, pbAtr, pcbAtrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardTransmit:

    This routine sends a service request to the smartcard, and expects to
    receive data back from the card.

Arguments:

    hCard - This is the reference value returned from the SCardConnect service.

    pioSendPci - This supplies the protocol header structure for the
        instruction.  This buffer is in the format of a SCARD_IO_REQUEST
        structure, followed by the specific protocol control information.

    pbSendBuffer - This supplies the actual data to be written to the card in
        conjunction with the command.

    cbSendLength - This supplies the length of the pbSendBuffer parameter, in
        bytes.

    pioRecvPci - This supplies the protocol header structure for the
        instruction, followed by a buffer in which to receive any returned
        protocol control information specific to the protocol in use.  This
        parameter may be NULL if no returned PCI is desired.

    pbRecvBuffer - This receives any data returned from the card in conjunction
        with the command.

    pcbRecvLength - This supplies the length of the pbRecvBuffer parameter, in
        bytes, and receives the actual number of bytes received from the
        smartcard.  If the buffer length is specified as SCARD_AUTOALLOCATE,
        then pbAttrBuffer is converted to a pointer to a byte pointer, and
        receives the address of a block of memory containing the returned data.
        This block of memory must be deallocated via the SCardFreeMemory()
        service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 2/6/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardTransmit")

WINSCARDAPI LONG WINAPI
SCardTransmit(
    IN SCARDHANDLE hCard,
    IN LPCSCARD_IO_REQUEST pioSendPci,
    IN LPCBYTE pbSendBuffer,
    IN DWORD cbSendLength,
    IN OUT LPSCARD_IO_REQUEST pioRecvPci,
    OUT LPBYTE pbRecvBuffer,
    IN OUT LPDWORD pcbRecvLength)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardTransmit(pRdr->GetRedirCard(), pioSendPci, pbSendBuffer, cbSendLength, pioRecvPci, pbRecvBuffer, pcbRecvLength);
        }
        else
        {
            CBuffer bfData(*pcbRecvLength);
            DWORD dwLen = 0;

            if (NULL != pcbRecvLength)
            {
                if (SCARD_AUTOALLOCATE != *pcbRecvLength)
                    dwLen = *pcbRecvLength;
            }

            pRdr->Transmit(
                    pioSendPci,
                    pbSendBuffer,
                    cbSendLength,
                    pioRecvPci,
                    bfData,
                    dwLen);
            PlaceResult(
                pRdr->Context()->Parent(),
                bfData,
                pbRecvBuffer,
                pcbRecvLength);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Control Routines
//
//      The following services provide for direct, low-level manipulation of the
//      reader by the calling application allowing it control over the
//      attributes of the communications with the card.
//

/*++

SCardControl:

    This routine provides for direct application control of the reader, should
    it be necessary.  It may be used at any time following a successful call to
    SCardConnect or SCardOpenReader, and prior to a successful call to
    SCardDisconnect.  The effect on the state of the reader is dependent on the
    control code.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    dwControlCode - This supplies the control code for the operation. This value
        identifies the specific operation to be performed.

    pvInBuffer - This supplies a pointer to a buffer that contains the data
        required to perform the operation.  This parameter can be NULL if the
        dwControlCode parameter specifies an operation that does not require
        input data.

    cbInBufferSize - This supplies the size, in bytes, of the buffer pointed to
        by pvInBuffer.

    pvOutBuffer - This buffer receives the operation's output data.  This
        parameter can be NULL if the dwControlCode parameter specifies an
        operation that does not produce output data.

    cbOutBufferSize - This supplies the size, in bytes, of the buffer pointed to
        by pvOutBuffer.

    pcbBytesReturned - This receives the size, in bytes, of the data stored into
        the buffer pointed to by pvOutBuffer.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardControl")

WINSCARDAPI LONG WINAPI
SCardControl(
    IN SCARDHANDLE hCard,
    IN DWORD dwControlCode,
    IN LPCVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT LPVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardControl(pRdr->GetRedirCard(), dwControlCode, pvInBuffer, cbInBufferSize, pvOutBuffer, cbOutBufferSize, pcbBytesReturned);
        }
        else
        {
            CBuffer bfResponse(cbOutBufferSize);
            *pcbBytesReturned = cbOutBufferSize;
            pRdr->Control(dwControlCode, pvInBuffer, cbInBufferSize, bfResponse);
            PlaceResult(
                pRdr->Context()->Parent(),
                bfResponse,
                (LPBYTE)pvOutBuffer,
                pcbBytesReturned);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetAttrib:

    This routine gets the current communications attributes for the given
    handle.  It does not effect the state of the reader, driver, or card.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    dwAttrId - This supplies the identifier for the attribute to get.

    pbAttr - This buffer receives the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.  If this value is NULL, the
        supplied buffer length in pcbAttrLength is ignored, the length of the
        buffer that would have been returned had this parameter not been null is
        written to pcbAttrLength, and a success code is returned.

    pcbAttrLength - This supplies the length of the pbAttr buffer in bytes, and
        receives the actual length of the received attribute.  If the buffer
        length is specified as SCARD_AUTOALLOCATE, then pbAttrBuffer is
        converted to a pointer to a byte pointer, and receives the address of a
        block of memory containing the attribute.  This block of memory must be
        deallocated via the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

    Note that strings are always returned as ANSI characters, per PC/SC
    standards.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetAttrib")

WINSCARDAPI LONG WINAPI
SCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardGetAttrib(pRdr->GetRedirCard(), dwAttrId, pbAttr, pcbAttrLen);
        }
        else
        {
            CBuffer bfAttrib;
            DWORD dwLen = 0;

            if (NULL != pcbAttrLen)
            {
                if (SCARD_AUTOALLOCATE != *pcbAttrLen)
                    dwLen = *pcbAttrLen;
            }

            switch (dwAttrId)
            {
            case SCARD_ATTR_DEVICE_FRIENDLY_NAME_A:
            {
                CBuffer bfSysName, bfNames;
                CTextMultistring mtzNames;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, MAX_PATH);
                ListReaderNames(
                    pRdr->Context()->Scope(),
                    bfSysName,
                    bfNames);
                mtzNames = (LPCTSTR)bfNames.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCSTR)mtzNames),
                    (mtzNames.Length()) * sizeof(CHAR));
                break;
            }
            case SCARD_ATTR_DEVICE_FRIENDLY_NAME_W:
            {
                CBuffer bfSysName, bfNames;
                CTextMultistring mtzNames;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, MAX_PATH);
                ListReaderNames(
                    pRdr->Context()->Scope(),
                    bfSysName,
                    bfNames);
                mtzNames = (LPCTSTR)bfNames.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCWSTR)mtzNames),
                    (mtzNames.Length()) * sizeof(WCHAR));
                break;
            }
            case SCARD_ATTR_DEVICE_SYSTEM_NAME_A:
            {
                CBuffer bfSysName;
                CTextString szSysName;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, dwLen);
                szSysName = (LPCTSTR)bfSysName.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCSTR)szSysName),
                    (szSysName.Length() + 1) * sizeof(CHAR));
                break;
            }
            case SCARD_ATTR_DEVICE_SYSTEM_NAME_W:
            {
                CBuffer bfSysName;
                CTextString szSysName;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, dwLen);
                szSysName = (LPCTSTR)bfSysName.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCWSTR)szSysName),
                    (szSysName.Length() + 1) * sizeof(WCHAR));
                break;
            }
            default:
                pRdr->GetAttrib(dwAttrId, bfAttrib, dwLen);
            }
            PlaceResult(pRdr->Context()->Parent(), bfAttrib, pbAttr, pcbAttrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardSetAttrib:

    This routine sets the current communications attributes for the given
    handle.  It does not effect the state of the reader, driver, or card.  Not
    all attributes are settable at all times, as many of the attributes are
    directly under control of the transport protocol.  These attributes are
    offered only as a suggestion to the reader -- the reader may ignore any
    attributes it feels are inappropriate.

Arguments:

    hCard - This is the reference value returned from the SCardOpenReader
        service.

    dwAttrId - This supplies the identifier for the attribute to get.

    pbAttr - This buffer supplies the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.

    cbAttrLength - This supplies the length of the attribute value in pbAttr
        buffer in bytes.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardSetAttrib")

WINSCARDAPI LONG WINAPI
SCardSetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    IN LPCBYTE pbAttr,
    IN DWORD cbAttrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardSetAttrib(pRdr->GetRedirCard(), dwAttrId, pbAttr, cbAttrLen);
        }
        else
            pRdr->SetAttrib(dwAttrId, pbAttr, cbAttrLen);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SCard Service Information
//
//      The following services are used to manage the Calais Service itself.
//      These routines are not documented to users, and are not guaranteed
//      to exist in future releases.
//

/*++

SCardAccessStartedEvent:

    This function obtains a local handle to the Calais Resource Manager Start
    event.  The handle must be released via the SCardReleaseStartedEvent
    service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAccessStartedEvent")

WINSCARDAPI HANDLE WINAPI
SCardAccessStartedEvent(
    void)
{
    HANDLE                  hRet                = NULL;

    //
    // Create the event that is passed back to the caller...
    // if it hasn't already been created
    //
    if (SafeCreateEvent(&g_hUnifiedStartedEvent))
    {
        hRet = g_hUnifiedStartedEvent;
    }
    else
    {
        goto ErrorReturn;
    }

    if (TermSrvEnabled())
    {
        //
        //
        //
        if (!SetStartedEventAfterTestingConnectedState())
        {
            goto ErrorReturn;
        }
    }
    else
    {
        //
        // TermSrv is disabled, so go ahead and call the
        // SetStartedEventWhenSCardSubsytemIsStarted function which will make sure
        // the event which is returned to the caller will be set when the LOCAL
        // smart card subsystem becomes available.
        //
        if (!SetStartedEventWhenSCardSubsytemIsStarted(TRUE))
        {
            goto ErrorReturn;
        }
    }

Return:
    return (hRet);

ErrorReturn:
    hRet = NULL;
    goto Return;
}


/*++

SCardAccessNewReaderEvent:

    This function obtains a local handle to the Calais Resource Manager's New
    Reader event.  The handle must be released via the
    SCardReleaseNewReaderEvent service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAccessNewReaderEvent")

WINSCARDAPI HANDLE WINAPI
SCardAccessNewReaderEvent(
    void)
{
    return AccessNewReaderEvent();
}


/*++

SCardReleaseStartedEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager Start event.  The handle must be obtained via the
    SCardAccessStartedEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseStartedEvent")

WINSCARDAPI void WINAPI
SCardReleaseStartedEvent(
    void)
{
    if (TermSrvEnabled())
    {
        UnRegisterForSessionChangeNotifications();
    }
}


/*++

SCardReleaseNewReaderEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager New Reader event.  The handle must be obtained via the
    SCardAccessNewReaderEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseNewReaderEvent")

WINSCARDAPI void WINAPI
SCardReleaseNewReaderEvent(
    void)
{
    ReleaseNewReaderEvent();
}


/*++

SCardReleaseAllEvents:

    This is a catch-all routine that releases all known special event handles.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

Author:

    Doug Barlow (dbarlow) 7/6/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseAllEvents")

WINSCARDAPI void WINAPI
SCardReleaseAllEvents(
    void)
{
    ReleaseAllEvents();
}


//
///////////////////////////////////////////////////////////////////////////////
//
//  Utility Routines
//

/*++

PlaceResult:

    This set of routines places the result of an operation into the user's
    output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes, etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the result to be returned to the user.

    pbOutput receives the result for the user, as a byte stream.

    szOutput receives the result as an ANSI or UNICODE string.

    pcbLength supplies the length of the user's output buffer in bytes, and
        receives how much of it was used.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceResult")

void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPBYTE pbOutput,
    LPDWORD pcbLength)
{
    LPBYTE pbForUser = NULL;
    LPBYTE pbOutBuff = pbOutput;

    try
    {
        if (NULL == pbOutput)
            *pcbLength = 0;
        switch (*pcbLength)
        {
        case 0: // They just want the length.
            *pcbLength = bfResult.Length();
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < bfResult.Length())
            {
                if (NULL == pCtx)
                {
                    pbForUser = (LPBYTE)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            bfResult.Length());
                }
                else
                    pbForUser = (LPBYTE)pCtx->AllocateMemory(bfResult.Length());

                if (NULL == pbForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }

                *(LPBYTE *)pbOutput = pbForUser;
                pbOutBuff = pbForUser;
                // Fall through intentionally
            }
            else
            {
                *pcbLength = 0;
                *(LPBYTE *)pbOutput = (LPBYTE)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcbLength < bfResult.Length())
            {
                *pcbLength = bfResult.Length();
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            CopyMemory(pbOutBuff, bfResult.Access(), bfResult.Length());
            *pcbLength = bfResult.Length();
            break;
        }
    }

    catch (...)
    {
        if (NULL != pbForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, pbForUser);
            else
                pCtx->FreeMemory(pbForUser);
        }
        throw;
    }
}

#include <setupapi.h>

//
// On a system that installs a smart card reader for the very first time
// the smart card subsystem must be started manually, but only this first time.
// After that, it is started automatically whenever the system boots
//
DWORD
APIENTRY
ClassInstall32(
    IN DI_FUNCTION      dif,
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData)       OPTIONAL
{
    if (dif == DIF_INSTALLDEVICE)
    {
        StartCalaisService();
    }
    return ERROR_DI_DO_DEFAULT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\winscarda.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WinSCard

Abstract:

    This module supplies the ANSI versions of the API for the Calais Smartcard
    Service Manager.

    The Calais Service Manager does the work of coordinating the protocols,
    readers, drivers, and smartcards on behalf of the application.  The
    following services are provided as part of a library to simplify access to
    the Service Manager.  These routines are the documented, exposed APIs.
    These routines merely package the requests and forward them to the Calais
    Service Manager, allowing the actual implementation of Calais to vary over
    time.

    At no time does the API library make security decisions.  All
    security-related functions must be performed by the Service Manager, running
    in its own address space, or in the operating system kernel.  However, some
    utility routines may be implemented in the API library for speed, as long as
    they do not involve security decisions.


Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "client.h"
#include "redirect.h"

extern HANDLE g_hUnifiedStartedEvent;

//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Query Services
//
//      These services all are oriented towards reading the Calais database.
//      They provide the option for listing a Smartcard Context (see Section
//      4.1.1), but do not require one.  Note that without a context, some or
//      all information may be inaccessable due to security restrictions.
//

/*++

SCardListReaderGroups:

    This service provides the list of named card reader groups that have
    previously been defined to the system.  The group 'SCard$DefaultReaders' is
    only returned if it contains at least one reader.  The group
    'SCard$AllReaders' is not returned, as it implicitly exists.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups receives a multi-string listing the reader groups defined to this
        system and available to the current user on the current terminal.  If
        this value is NULL, the supplied buffer length in pcchGroups is ignored,
        the length of the buffer that would have been returned had this
        parameter not been null is written to pcchGroups, and a success code is
        returned.

    pcchGroups supplies the length of the mszGroups buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szGroups is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReaderGroupsA")

WINSCARDAPI LONG WINAPI
SCardListReaderGroupsA(
    IN SCARDCONTEXT hContext,
    OUT LPSTR mszGroups,
    IN OUT LPDWORD pcchGroups)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardListReaderGroupsA(hRedirContext, mszGroups, pcchGroups);
        }
        else
        {
            ListReaderGroups(dwScope, bfGroups);
            PlaceMultiResult(pCtx, bfGroups, mszGroups, pcchGroups);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListReaders:

    This service provides the list of readers within a set of named reader
    groups, eliminating duplicates.  The caller supplies a multistring listing
    the name of a set of pre-defined group of readers, and receives the list of
    smartcard readers within the named groups.  Unrecognized group names are
    ignored.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups supplies the names of the reader groups defined to the system, as
        a multi-string.  A NULL value is used to indicate that all readers in
        the system be listed (i.e., the SCard$AllReaders group).

    mszReaders receives a multi-string listing the card readers within the
        supplied reader groups.  If this value is NULL, the supplied buffer
        length in pcchReaders is ignored, the length of the buffer that would
        have been returned had this parameter not been null is written to
        pcchReaders, and a success code is returned.

    pcchReaders supplies the length of the mszReaders buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszReaders is converted to a pointer to a
        string pointer, and receives the address of a block of memory containing
        the multi-string structure.  This block of memory must be deallocated
        via the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReadersA")

WINSCARDAPI LONG WINAPI
SCardListReadersA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR mszGroups,
    OUT LPSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfReaders;
        CTextMultistring mtzGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardListReadersA(hRedirContext, mszGroups, mszReaders, pcchReaders);
        }
        else
        {
            mtzGroups = mszGroups;
            ListReaders(dwScope, mtzGroups, bfReaders);
            if (NULL != pCtx)
                pCtx->StripInactiveReaders(bfReaders);
            PlaceMultiResult(pCtx, bfReaders, mszReaders, pcchReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListCards:

    This service provides a list of named cards previously introduced to the
    system by this user which match an optionally supplied ATR string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    pbAtr supplies the address of an ATR string to compare to known cards, or
        NULL if all card names are to be returned.

    rgguidInterfaces supplies an array of GUIDs, or the value NULL.  When an
        array is supplied, a card name will be returned only if this set of
        GUIDs is a (possibly improper) subset of the set of GUIDs supported by
        the card.

    cguidInterfaceCount supplies the number of entries in the rgguidInterfaces
        array.  If rgguidInterfaces is NULL, then this value is ignored.

  mszCards receives a multi-string listing the smartcards introduced to the
        system by this user which match the supplied ATR string.  If this value
        is NULL, the supplied buffer length in pcchCards is ignored, the length
        of the buffer that would have been returned had this parameter not been
        null is written to pcchCards, and a success code is returned.

    pcchCards supplies the length of the mszCards buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszCards is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListCardsA")

WINSCARDAPI LONG WINAPI
SCardListCardsA(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT LPSTR mszCards,
    IN OUT LPDWORD pcchCards)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfCards;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        ListCards(
            dwScope,
            pbAtr,
            rgquidInterfaces,
            cguidInterfaceCount,
            bfCards);
        PlaceMultiResult(pCtx, bfCards, mszCards, pcchCards);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListInterfaces:

    This service provides a list of interfaces known to be supplied by a given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the list of interfaces supported by the card.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives an array of GUIDs indicating the interfaces
        supported by the named smartcard.  If this value is NULL, the supplied
        array length in pcguidInterfaces is ignored, the size of the array that
        would have been returned had this parameter not been null is written to
        pcguidInterfaces, and a success code is returned.

    pcguidInterfaces supplies the size of the pguidInterfaces array, and
        receives the actual size of the returned array.  If the array size is
        specified as SCARD_AUTOALLOCATE, then pguidInterfaces is converted to a
        pointer to a GUID pointer, and receives the address of a block of memory
        containing the array.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListInterfacesA")

WINSCARDAPI LONG WINAPI
SCardListInterfacesA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCard,
    OUT LPGUID pguidInterfaces,
    IN OUT LPDWORD pcguidInterfaces)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        DWORD cbInterfaces;
        CBuffer bfInterfaces;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    &bfInterfaces,
                    NULL);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (SCARD_AUTOALLOCATE == *pcguidInterfaces)
            cbInterfaces = SCARD_AUTOALLOCATE;
        else
            cbInterfaces = *pcguidInterfaces * sizeof(GUID);
        PlaceResult(
            pCtx,
            bfInterfaces,
            (LPBYTE)pguidInterfaces,
            &cbInterfaces);
        *pcguidInterfaces = cbInterfaces / sizeof(GUID);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetProviderId:

    This service returns the GUID of the Primary Service Provider for the given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the registered Primary Service Provider GUID, if
    any.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives the GUID of the Primary Service Provider of the
        indicated card.  This provider may be activated via COM, and will supply
        access to other services in the card.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetProviderIdA")

WINSCARDAPI LONG WINAPI
SCardGetProviderIdA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCard,
    OUT LPGUID pguidProviderId)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfProvider;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    NULL,
                    &bfProvider);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (sizeof(GUID) != bfProvider.Length())
            throw (DWORD)SCARD_E_INVALID_TARGET;
        CopyMemory(pguidProviderId, bfProvider.Access(), bfProvider.Length());
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetCardTypeProviderName:

    This service returns the value of a given Provider Name, by Id number, for
    the identified card type.  The caller supplies the name of a smartcard
    previously introduced to the system, and receives the registered Service
    Provider of that type, if any, as a string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCardName supplies the name of the card type with which this provider name
        is associated.

    dwProviderId supplies the identifier for the provider associated with this
        card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider receives the string identifying the provider.

    pcchProvider supplies the length of the szProvider buffer in characters,
        and receives the actual length of the returned string, including the
        trailing null character.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szProvider is converted to a pointer to a
        string pointer, and receives the address of a block of memory
        containing the string.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetCardTypeProviderNameA")

WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPSTR szProvider,
    IN OUT LPDWORD pcchProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CTextString tzCardName;
        CBuffer bfProvider;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        GetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            bfProvider);
        PlaceResult(pCtx, bfProvider, szProvider, pcchProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Management Services
//
//      The following services provide for managing the Calais Database.  These
//      services actually update the database, and require a smartcard context.
//

/*++

SCardIntroduceReaderGroup:

    This service provides means for introducing a new smartcard reader group to
    Calais.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name to be assigned to the new reader
        group.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderGroupA")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderGroupA(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            IntroduceReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReaderGroup:

    This service provides means for removing a previously defined smartcard
    reader group from the Calais Subsystem.  This service automatically clears
    all readers from the group before forgetting it.  It does not affect the
    existence of the readers in the database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name of the reader group to be
        forgotten.  The Calais-defined default reader groups may not be
        forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderGroupA")

WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderGroupA(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            ForgetReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceReader:

    This service provides means for introducing an existing smartcard reader
    device to Calais.  Once introduced, Calais will assume responsibility for
    managing access to that reader.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name to be assigned to the reader.

    SzDeviceName supplies the system name of the smartcard reader device.
        (Example: "VendorX ModelY Z".)

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderA")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szDeviceName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzDeviceName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderA(hRedirContext, szReaderName, szDeviceName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzDeviceName = szDeviceName;
            IntroduceReader(
                dwScope,
                tzReaderName,
                tzDeviceName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReader:

    This service provides means for removing previously defined smartcard
    readers from control by the Calais Subsystem.  It is automatically removed
    from any groups it may have been added to.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderA")

WINSCARDAPI LONG WINAPI
SCardForgetReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderA(hRedirContext, szReaderName);
        }
        else
        {
            tzReaderName = szReaderName;
            ForgetReader(
                dwScope,
                tzReaderName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardAddReaderToGroup:

    This service provides means for adding existing an reader into an existing
    reader group.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be added.

    szGroupName supplies the friendly name of the group to which the reader
        should be added.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAddReaderToGroupA")

WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardAddReaderToGroupA(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            AddReaderToGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardRemoveReaderFromGroup:

    This service provides means for removing an existing reader from an existing
    reader group.  It does not affect the existence of either the reader or the
    group in the Calais database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be removed.

    szGroupName supplies the friendly name of the group to which the reader
        should be removed.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardRemoveReaderFromGroupA")

WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardRemoveReaderFromGroupA(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            RemoveReaderFromGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceCardType:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name by which the user can recognize this card.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceCardTypeA")

WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        IntroduceCard(
            dwScope,
            tzCardName,
            pguidPrimaryProvider,
            rgguidInterfaces,
            dwInterfaceCount,
            pbAtr,
            pbAtrMask,
            cbAtrLen);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardSetCardTypeProviderName:

    This service provides means for adding additional service providers to a
    specified card type.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name of the card type with which this provider
        name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardSetCardTypeProviderNameA")

WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCSTR szProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        CTextString tzProvider;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        tzProvider = szProvider;
        SetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            tzProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetCardType:

    This service provides means for removing previously defined smartcards from
    the Calais Subsystem.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the friendly name of the card to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetCardTypeA")

WINSCARDAPI LONG WINAPI
SCardForgetCardTypeA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        ForgetCard(
            dwScope,
            tzCardName);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

/*++

SCardLocateCards:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the card supplied
    names.  This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsA")

WINSCARDAPI LONG WINAPI
SCardLocateCardsA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR mszCards,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;
    LPSCARD_ATRMASK rgAtrMasks = NULL;

    try
    {
        LPCTSTR szCard;
        DWORD dwIndex;
        DWORD dwScope;
        CBuffer bfXlate1(36), bfXlate2(36); // Rough guess of name & ATR lengths
        BOOL fSts;

        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        dwScope = pCtx->Scope();

        if (0 == *mszCards)
            throw (DWORD)SCARD_E_INVALID_VALUE;

        rgAtrMasks = new SCARD_ATRMASK[MStringCount(mszCards)];
        if (rgAtrMasks == NULL)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        dwIndex = 0;
        for (szCard = FirstString(mszCards);
             NULL != szCard;
             szCard = NextString(szCard))
        {
            fSts = GetCardInfo(
                        dwScope,
                        szCard,
                        &bfXlate1,  // ATR
                        &bfXlate2,  // Mask
                        NULL,
                        NULL);
            if (!fSts)
                throw (DWORD)SCARD_E_UNKNOWN_CARD;

            ASSERT(33 >= bfXlate1.Length());    // Biggest an ATR can be.
            rgAtrMasks[dwIndex].cbAtr = bfXlate1.Length();
            memcpy(rgAtrMasks[dwIndex].rgbAtr, bfXlate1.Access(), rgAtrMasks[dwIndex].cbAtr);

            ASSERT(rgAtrMasks[dwIndex].cbAtr == bfXlate2.Length());
            memcpy(rgAtrMasks[dwIndex].rgbMask, bfXlate2.Access(), rgAtrMasks[dwIndex].cbAtr);

            dwIndex ++;
        }

        nReturn = SCardLocateCardsByATRA(
                    hContext,
                    rgAtrMasks,
                    dwIndex,
                    rgReaderStates,
                    cReaders);

            // If the remote client does not implement the new API
            // retry with the old one. it might succeed if its DB is good enough
        if ((nReturn == ERROR_CALL_NOT_IMPLEMENTED) && (pCtx->GetRedirContext()))
        {
            nReturn = pfnSCardLocateCardsA(pCtx->GetRedirContext(), mszCards, rgReaderStates, cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    if (rgAtrMasks != NULL)
    {
        try
        {
            delete[] rgAtrMasks;
        }
        catch (...)
        {
        }
    }

    return nReturn;
}


/*++

SCardLocateCardsByATR:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the supplied ATRs
    This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    rgAtrMasks supplies the ATRs to search for, as an array of structs.

    cAtrs supplies the number of elements in the rgAtrMasks array.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsByATRA")

WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRA(
    IN SCARDCONTEXT hContext,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardLocateCardsByATRA(pCtx->GetRedirContext(), rgAtrMasks, cAtrs, rgReaderStates, cReaders);
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);

            pCtx->LocateCards(
                    bfReaders,
                    rgAtrMasks,
                    cAtrs,
                    (LPSCARD_READERSTATE)rgReaderStates,
                    cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetStatusChange:

    This service is used to block execution until such time as the current
    availability of cards in a given set of readers changes.  The caller
    supplies a list of readers to be monitored via an SCARD_READERSTATE array,
    and the maximum amount of time, in seconds, that it is willing to wait for
    an action to occur on one of the listed readers.  Zero in this parameter
    indicates that no timeout is specified.  The service returns when there is a
    change in availability, having filled in the dwEventState fields of the
    rgReaderStates parameter appropriately.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    dwTimeOut supplies the maximum amount of time to wait for an action, in
        seconds.  A zero value implies that the wait will never timeout.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the wait, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetStatusChangeA")

BOOL
SetStartedEventAfterTestingConnectedState();

WINSCARDAPI LONG WINAPI
SCardGetStatusChangeA(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardGetStatusChangeA(pCtx->GetRedirContext(), dwTimeout, rgReaderStates, cReaders);

            //
            // See if there is an indication that the client's scardsvr service was shutdown
            //
            if (SCARD_E_SYSTEM_CANCELLED == nReturn)
            {
                //OutputDebugString("WINSCARD: SCardEstablishContext: got E_NO_SERVICE!\n");
                SetStartedEventAfterTestingConnectedState();
            }
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);
            pCtx->GetStatusChange(
                        bfReaders,
                        (LPSCARD_READERSTATE)rgReaderStates,
                        cReaders,
                        dwTimeout);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
        
        if (SCARD_E_SYSTEM_CANCELLED == nReturn)
        {
            ResetEvent(g_hUnifiedStartedEvent);
        }
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

/*++

SCardConnect:

    This service establishes a connection from the calling application to the
    smartcard in the designated reader.  If no card exists in the specified
    reader, an error is returned.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    szReader supplies the name of the reader containing the target card.

    DwShareMode supplies a flag indicating whether or not other applications may
        form connections to this card.  Possible values are:

        SCARD_SHARE_SHARED - This application is willing to share this card with
            other applications.

        SCARD_SHARE_EXCLUSIVE - This application is not willing to share this
            card with other applications.

        SCARD_SHARE_DIRECT - This application is taking control of the reader.

    DwPreferredProtocols supplies a bit mask of acceptable protocols for this
        connection.  Possible values, which may be combined via the OR
        operation, are:

        SCARD_PROTOCOL_T0 - T=0 is an acceptable protocol.

        SCARD_PROTOCOL_T1 - T=1 is an acceptable protocol.

    phCard receives a handle identifying the connection to the smartcard in the
        designated reader.

    pdwActiveProtocol receives a flag indicating the established active
        protocol.  Possible values are:

        SCARD_PROTOCOL_T0 - T=0 is the active protocol.

        SCARD_PROTOCOL_T1 - T=1 is the active protocol.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardConnectA")

WINSCARDAPI LONG WINAPI
SCardConnectA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReader,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT LPSCARDHANDLE phCard,
    OUT LPDWORD pdwActiveProtocol)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CReaderContext *pRdr = NULL;
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        *phCard = NULL;     // Touch it to be sure it's real.
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        CTextString tzReader;

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        tzReader = szReader;
        pRdr = new CReaderContext;
        if (NULL == pRdr)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();
        if (hRedirContext)
        {
            SCARDHANDLE hCard = g_phlReaders->Add(pRdr);    // do it first to avoid out of memory condition
            nReturn = pfnSCardConnectA(hRedirContext, szReader, dwShareMode, dwPreferredProtocols, phCard, pdwActiveProtocol);
            if (nReturn == SCARD_S_SUCCESS)
            {
                pRdr->SetRedirCard(*phCard);
                *phCard = hCard;
            }
            else
            {
                g_phlReaders->Close(hCard);
                delete pRdr;
            }
        }
        else
        {
            pSubCtx = pCtx->AcquireSubcontext(TRUE);
            pRdr->Connect(
                    pSubCtx,
                    tzReader,
                    dwShareMode,
                    dwPreferredProtocols);
            pSubCtx = NULL;
            pRdr->Context()->ReleaseSubcontext();
            if (NULL != pdwActiveProtocol)
                *pdwActiveProtocol = pRdr->Protocol();
            pRdr->Context()->m_hReaderHandle = g_phlReaders->Add(pRdr);
            *phCard = pRdr->Context()->m_hReaderHandle;
        }
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardStatus:

    This routine provides the current status of the reader.  It may be used at
    any time following a successful call to SCardConnect or SCardOpenReader, and
    prior to a successful call to SCardDisconnect.  It does not effect the state
    of the reader or driver.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    mszReaderNames - This receives a list of friendly names by which the
        currently connected reader is known.  This list is returned as a
        multistring.

    pcchReaderLen - This supplies the length of the mszReader buffer, in
        characters, and receives the actual returned length of the reader
        friendly name list, in characters, including the trailing NULL
        characters.

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    pbAtr - This parameter points to a 32-byte buffer which receives the ATR
        string from the currently inserted card, if available.

    pbcAtrLen - This points to a DWORD which supplies the length of the pbAtr
        buffer, and receives the actual number of bytes in the ATR string.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardStatusA")

WINSCARDAPI LONG WINAPI
SCardStatusA(
    IN SCARDHANDLE hCard,
    OUT LPSTR mszReaderNames,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pRdr->GetRedirCard())
        {
            nReturn = pfnSCardStatusA(pRdr->GetRedirCard(), mszReaderNames, pcchReaderLen, pdwState, pdwProtocol, pbAtr, pcbAtrLen);
        }
        else
        {
            CBuffer bfAtr, bfReader;
            DWORD dwLocalState, dwLocalProtocol;

            pRdr->Status(&dwLocalState, &dwLocalProtocol, bfAtr, bfReader);
            if (NULL != pdwState)
                *pdwState = dwLocalState;
            if (NULL != pdwProtocol)
                *pdwProtocol = dwLocalProtocol;
            if (NULL != pcchReaderLen)
                PlaceMultiResult(
                    pRdr->Context()->Parent(),
                    bfReader,
                    mszReaderNames,
                    pcchReaderLen);
            if (NULL != pcbAtrLen)
                PlaceResult(pRdr->Context()->Parent(), bfAtr, pbAtr, pcbAtrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
///////////////////////////////////////////////////////////////////////////////
//
//  Utility Routines
//

/*++

PlaceResult:

    This set of routines places the result of an operation into the user's
    output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes, etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the result to be returned to the user.

    pbOutput receives the result for the user, as a byte stream.

    szOutput receives the result as an ANSI or UNICODE string.

    pcbLength supplies the length of the user's output buffer in bytes, and
        receives how much of it was used.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceResult")

void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR szOutput,
    LPDWORD pcchLength)
{
    LPSTR szForUser = NULL;
    LPSTR szOutBuf = szOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == szOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    szForUser = (LPSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(CHAR));
                }
                else
                    szForUser = (LPSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(CHAR));

                if (NULL == szForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }

                *(LPSTR *)szOutput = szForUser;
                szOutBuf = szForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPSTR *)szOutput = (LPSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToAnsiString(
                szOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != szForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, szForUser);
            else
                pCtx->FreeMemory(szForUser);
        }
        throw;
    }
}


/*++

PlaceMultiResult:

    This set of routines places a Multistring result of an operation into the
    user's output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes,
    etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the TCHAR multistring result to be returned to the user.

    mszOutput receives the result as an ANSI or UNICODE multistring.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceMultiResult")

void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR mszOutput,
    LPDWORD pcchLength)
{
    LPSTR mszForUser = NULL;
    LPSTR mszOutBuf = mszOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == mszOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    mszForUser = (LPSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(CHAR));
                }
                else
                    mszForUser = (LPSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(CHAR));

                if (NULL == mszForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }

                *(LPSTR *)mszOutput = mszForUser;
                mszOutBuf = mszForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPSTR *)mszOutput = (LPSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToAnsiMultiString(
                mszOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != mszForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, mszForUser);
            else
                pCtx->FreeMemory(mszForUser);
        }
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\client\winscardw.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WinSCard

Abstract:

    This module supplies the UNICODE version of the API for the Calais Smartcard
    Service Manager.

    The Calais Service Manager does the work of coordinating the protocols,
    readers, drivers, and smartcards on behalf of the application.  The
    following services are provided as part of a library to simplify access to
    the Service Manager.  These routines are the documented, exposed APIs.
    These routines merely package the requests and forward them to the Calais
    Service Manager, allowing the actual implementation of Calais to vary over
    time.

    At no time does the API library make security decisions.  All
    security-related functions must be performed by the Service Manager, running
    in its own address space, or in the operating system kernel.  However, some
    utility routines may be implemented in the API library for speed, as long as
    they do not involve security decisions.


Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "client.h"
#include "redirect.h"

extern HANDLE g_hUnifiedStartedEvent;

//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Query Services
//
//      These services all are oriented towards reading the Calais database.
//      They provide the option for listing a Smartcard Context (see Section
//      4.1.1), but do not require one.  Note that without a context, some or
//      all information may be inaccessable due to security restrictions.
//

/*++

SCardListReaderGroups:

    This service provides the list of named card reader groups that have
    previously been defined to the system.  The group 'SCard$DefaultReaders' is
    only returned if it contains at least one reader.  The group
    'SCard$AllReaders' is not returned, as it implicitly exists.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups receives a multi-string listing the reader groups defined to this
        system and available to the current user on the current terminal.  If
        this value is NULL, the supplied buffer length in pcchGroups is ignored,
        the length of the buffer that would have been returned had this
        parameter not been null is written to pcchGroups, and a success code is
        returned.

    pcchGroups supplies the length of the mszGroups buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szGroups is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReaderGroupsW")

WINSCARDAPI LONG WINAPI
SCardListReaderGroupsW(
    IN SCARDCONTEXT hContext,
    OUT LPWSTR mszGroups,
    IN OUT LPDWORD pcchGroups)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardListReaderGroupsW(hRedirContext, mszGroups, pcchGroups);
        }
        else
        {
            ListReaderGroups(dwScope, bfGroups);
            PlaceMultiResult(pCtx, bfGroups, mszGroups, pcchGroups);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListReaders:

    This service provides the list of readers within a set of named reader
    groups, eliminating duplicates.  The caller supplies a multistring listing
    the name of a set of pre-defined group of readers, and receives the list of
    smartcard readers within the named groups.  Unrecognized group names are
    ignored.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups supplies the names of the reader groups defined to the system, as
        a multi-string.  A NULL value is used to indicate that all readers in
        the system be listed (i.e., the SCard$AllReaders group).

    mszReaders receives a multi-string listing the card readers within the
        supplied reader groups.  If this value is NULL, the supplied buffer
        length in pcchReaders is ignored, the length of the buffer that would
        have been returned had this parameter not been null is written to
        pcchReaders, and a success code is returned.

    pcchReaders supplies the length of the mszReaders buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszReaders is converted to a pointer to a
        string pointer, and receives the address of a block of memory containing
        the multi-string structure.  This block of memory must be deallocated
        via the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReadersW")

WINSCARDAPI LONG WINAPI
SCardListReadersW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszGroups,
    OUT LPWSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfReaders;
        CTextMultistring mtzGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn  = pfnSCardListReadersW(hRedirContext, mszGroups, mszReaders, pcchReaders);
        }
        else
        {
            mtzGroups = mszGroups;
            ListReaders(dwScope, mtzGroups, bfReaders);
            if (NULL != pCtx)
                pCtx->StripInactiveReaders(bfReaders);
            PlaceMultiResult(pCtx, bfReaders, mszReaders, pcchReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListCards:

    This service provides a list of named cards previously introduced to the
    system by this user which match an optionally supplied ATR string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    pbAtr supplies the address of an ATR string to compare to known cards, or
        NULL if all card names are to be returned.

    rgguidInterfaces supplies an array of GUIDs, or the value NULL.  When an
        array is supplied, a card name will be returned only if this set of
        GUIDs is a (possibly improper) subset of the set of GUIDs supported by
        the card.

    cguidInterfaceCount supplies the number of entries in the rgguidInterfaces
        array.  If rgguidInterfaces is NULL, then this value is ignored.

  mszCards receives a multi-string listing the smartcards introduced to the
        system by this user which match the supplied ATR string.  If this value
        is NULL, the supplied buffer length in pcchCards is ignored, the length
        of the buffer that would have been returned had this parameter not been
        null is written to pcchCards, and a success code is returned.

    pcchCards supplies the length of the mszCards buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszCards is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListCardsW")

WINSCARDAPI LONG WINAPI
SCardListCardsW(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT LPWSTR mszCards,
    IN OUT LPDWORD pcchCards)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfCards;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        ListCards(
            dwScope,
            pbAtr,
            rgquidInterfaces,
            cguidInterfaceCount,
            bfCards);
        PlaceMultiResult(pCtx, bfCards, mszCards, pcchCards);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListInterfaces:

    This service provides a list of interfaces known to be supplied by a given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the list of interfaces supported by the card.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives an array of GUIDs indicating the interfaces
        supported by the named smartcard.  If this value is NULL, the supplied
        array length in pcguidInterfaces is ignored, the size of the array that
        would have been returned had this parameter not been null is written to
        pcguidInterfaces, and a success code is returned.

    pcguidInterfaces supplies the size of the pguidInterfaces array, and
        receives the actual size of the returned array.  If the array size is
        specified as SCARD_AUTOALLOCATE, then pguidInterfaces is converted to a
        pointer to a GUID pointer, and receives the address of a block of memory
        containing the array.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListInterfacesW")

WINSCARDAPI LONG WINAPI
SCardListInterfacesW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCard,
    OUT LPGUID pguidInterfaces,
    IN OUT LPDWORD pcguidInterfaces)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        DWORD cbInterfaces;
        CBuffer bfInterfaces;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    &bfInterfaces,
                    NULL);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (SCARD_AUTOALLOCATE == *pcguidInterfaces)
            cbInterfaces = SCARD_AUTOALLOCATE;
        else
            cbInterfaces = *pcguidInterfaces * sizeof(GUID);
        PlaceResult(
            pCtx,
            bfInterfaces,
            (LPBYTE)pguidInterfaces,
            &cbInterfaces);
        *pcguidInterfaces = cbInterfaces / sizeof(GUID);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetProviderId:

    This service returns the GUID of the Primary Service Provider for the given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the registered Primary Service Provider GUID, if
    any.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives the GUID of the Primary Service Provider of the
        indicated card.  This provider may be activated via COM, and will supply
        access to other services in the card.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetProviderIdW")

WINSCARDAPI LONG WINAPI
SCardGetProviderIdW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCard,
    OUT LPGUID pguidProviderId)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfProvider;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    NULL,
                    &bfProvider);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (sizeof(GUID) != bfProvider.Length())
            throw (DWORD)SCARD_E_INVALID_TARGET;
        CopyMemory(pguidProviderId, bfProvider.Access(), bfProvider.Length());
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetCardTypeProviderName:

    This service returns the value of a given Provider Name, by Id number, for
    the identified card type.  The caller supplies the name of a smartcard
    previously introduced to the system, and receives the registered Service
    Provider of that type, if any, as a string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCardName supplies the name of the card type with which this provider name
        is associated.

    dwProviderId supplies the identifier for the provider associated with this
        card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider receives the string identifying the provider.

    pcchProvider supplies the length of the szProvider buffer in characters,
        and receives the actual length of the returned string, including the
        trailing null character.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szProvider is converted to a pointer to a
        string pointer, and receives the address of a block of memory
        containing the string.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetCardTypeProviderNameW")

WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPWSTR szProvider,
    IN OUT LPDWORD pcchProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CTextString tzCardName;
        CBuffer bfProvider;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        GetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            bfProvider);
        PlaceResult(pCtx, bfProvider, szProvider, pcchProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Management Services
//
//      The following services provide for managing the Calais Database.  These
//      services actually update the database, and require a smartcard context.
//

/*++

SCardIntroduceReaderGroup:

    This service provides means for introducing a new smartcard reader group to
    Calais.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name to be assigned to the new reader
        group.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderGroupW")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderGroupW(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            IntroduceReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReaderGroup:

    This service provides means for removing a previously defined smartcard
    reader group from the Calais Subsystem.  This service automatically clears
    all readers from the group before forgetting it.  It does not affect the
    existence of the readers in the database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name of the reader group to be
        forgotten.  The Calais-defined default reader groups may not be
        forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderGroupW")

WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderGroupW(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            ForgetReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceReader:

    This service provides means for introducing an existing smartcard reader
    device to Calais.  Once introduced, Calais will assume responsibility for
    managing access to that reader.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name to be assigned to the reader.

    SzDeviceName supplies the system name of the smartcard reader device.
        (Example: "VendorX ModelY Z".)

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderW")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szDeviceName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzDeviceName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderW(hRedirContext, szReaderName, szDeviceName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzDeviceName = szDeviceName;
            IntroduceReader(
                dwScope,
                tzReaderName,
                tzDeviceName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReader:

    This service provides means for removing previously defined smartcard
    readers from control by the Calais Subsystem.  It is automatically removed
    from any groups it may have been added to.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderW")

WINSCARDAPI LONG WINAPI
SCardForgetReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderW(hRedirContext, szReaderName);
        }
        else
        {
            tzReaderName = szReaderName;
            ForgetReader(
                dwScope,
                tzReaderName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardAddReaderToGroup:

    This service provides means for adding existing an reader into an existing
    reader group.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be added.

    szGroupName supplies the friendly name of the group to which the reader
        should be added.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAddReaderToGroupW")

WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardAddReaderToGroupW(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            AddReaderToGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardRemoveReaderFromGroup:

    This service provides means for removing an existing reader from an existing
    reader group.  It does not affect the existence of either the reader or the
    group in the Calais database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be removed.

    szGroupName supplies the friendly name of the group to which the reader
        should be removed.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardRemoveReaderFromGroupW")

WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || InTSRedirectMode()) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardRemoveReaderFromGroupW(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            RemoveReaderFromGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceCardType:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name by which the user can recognize this card.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceCardTypeW")

WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        IntroduceCard(
            dwScope,
            tzCardName,
            pguidPrimaryProvider,
            rgguidInterfaces,
            dwInterfaceCount,
            pbAtr,
            pbAtrMask,
            cbAtrLen);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardSetCardTypeProviderName:

    This service provides means for adding additional service providers to a
    specified card type.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name of the card type with which this provider
        name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardSetCardTypeProviderNameW")

WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCWSTR szProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        CTextString tzProvider;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
           CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        tzProvider = szProvider;
        SetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            tzProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetCardType:

    This service provides means for removing previously defined smartcards from
    the Calais Subsystem.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the friendly name of the card to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetCardTypeW")

WINSCARDAPI LONG WINAPI
SCardForgetCardTypeW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        ForgetCard(
            dwScope,
            tzCardName);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

/*++

SCardLocateCards:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the card supplied
    names.  This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsW")

WINSCARDAPI LONG WINAPI
SCardLocateCardsW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszCards,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;
    LPSCARD_ATRMASK rgAtrMasks = NULL;

    try
    {
        LPCSTR szCard;
        CTextMultistring mtzCards;
        DWORD dwIndex;
        DWORD dwScope;
        CBuffer bfXlate1(36), bfXlate2(36); // Rough guess of name & ATR lengths
        BOOL fSts;

        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        dwScope = pCtx->Scope();

        if (0 == *mszCards)
            throw (DWORD)SCARD_E_INVALID_VALUE;

        mtzCards = mszCards;

        rgAtrMasks = new SCARD_ATRMASK[MStringCount(mtzCards)];
        if (rgAtrMasks == NULL)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        dwIndex = 0;
        for (szCard = FirstString(mtzCards);
             NULL != szCard;
             szCard = NextString(szCard))
        {
            fSts = GetCardInfo(
                        dwScope,
                        szCard,
                        &bfXlate1,  // ATR
                        &bfXlate2,  // Mask
                        NULL,
                        NULL);
            if (!fSts)
                throw (DWORD)SCARD_E_UNKNOWN_CARD;

            ASSERT(33 >= bfXlate1.Length());    // Biggest an ATR can be.
            rgAtrMasks[dwIndex].cbAtr = bfXlate1.Length();
            memcpy(rgAtrMasks[dwIndex].rgbAtr, bfXlate1.Access(), rgAtrMasks[dwIndex].cbAtr);

            ASSERT(rgAtrMasks[dwIndex].cbAtr == bfXlate2.Length());
            memcpy(rgAtrMasks[dwIndex].rgbMask, bfXlate2.Access(), rgAtrMasks[dwIndex].cbAtr);

            dwIndex ++;
        }

        nReturn = SCardLocateCardsByATRW(
                    hContext,
                    rgAtrMasks,
                    dwIndex,
                    rgReaderStates,
                    cReaders);

            // If the remote client does not implement the new API
            // retry with the old one. it might succeed if its DB is good enough
        if ((nReturn == ERROR_CALL_NOT_IMPLEMENTED) && (pCtx->GetRedirContext()))
        {
            nReturn = pfnSCardLocateCardsW(pCtx->GetRedirContext(), mszCards, rgReaderStates, cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    if (rgAtrMasks != NULL)
    {
        try
        {
            delete[] rgAtrMasks;
        }
        catch (...)
        {
        }
    }

    return nReturn;
}


/*++

SCardLocateCardsByATR:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the supplied ATRs
    This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    rgAtrMasks supplies the ATRs to search for, as an array of structs.

    cAtrs supplies the number of elements in the rgAtrMasks array.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsByATRW")

WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRW(
    IN SCARDCONTEXT hContext,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardLocateCardsByATRW(pCtx->GetRedirContext(), rgAtrMasks, cAtrs, rgReaderStates, cReaders);
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);

            pCtx->LocateCards(
                    bfReaders,
                    rgAtrMasks,
                    cAtrs,
                    (LPSCARD_READERSTATE)rgReaderStates,
                    cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetStatusChange:

    This service is used to block execution until such time as the current
    availability of cards in a given set of readers changes.  The caller
    supplies a list of readers to be monitored via an SCARD_READERSTATE array,
    and the maximum amount of time, in seconds, that it is willing to wait for
    an action to occur on one of the listed readers.  Zero in this parameter
    indicates that no timeout is specified.  The service returns when there is a
    change in availability, having filled in the dwEventState fields of the
    rgReaderStates parameter appropriately.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    dwTimeOut supplies the maximum amount of time to wait for an action, in
        seconds.  A zero value implies that the wait will never timeout.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the wait, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetStatusChangeW")

BOOL
SetStartedEventAfterTestingConnectedState();

WINSCARDAPI LONG WINAPI
SCardGetStatusChangeW(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardGetStatusChangeW(pCtx->GetRedirContext(), dwTimeout, rgReaderStates, cReaders);

            //
            // See if there is an indication that the client's scardsvr service was shutdown
            //
            if (SCARD_E_SYSTEM_CANCELLED == nReturn)
            {
                //OutputDebugString("WINSCARD: SCardEstablishContext: got E_NO_SERVICE!\n");
                SetStartedEventAfterTestingConnectedState();
            }
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);
            pCtx->GetStatusChange(
                        bfReaders,
                        (LPSCARD_READERSTATE)rgReaderStates,
                        cReaders,
                        dwTimeout);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;

        if (SCARD_E_SYSTEM_CANCELLED == nReturn)
        {
            ResetEvent(g_hUnifiedStartedEvent);
        }
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

/*++

SCardConnect:

    This service establishes a connection from the calling application to the
    smartcard in the designated reader.  If no card exists in the specified
    reader, an error is returned.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    szReader supplies the name of the reader containing the target card.

    DwShareMode supplies a flag indicating whether or not other applications may
        form connections to this card.  Possible values are:

        SCARD_SHARE_SHARED - This application is willing to share this card with
            other applications.

        SCARD_SHARE_EXCLUSIVE - This application is not willing to share this
            card with other applications.

        SCARD_SHARE_DIRECT - This application is taking control of the reader.

    DwPreferredProtocols supplies a bit mask of acceptable protocols for this
        connection.  Possible values, which may be combined via the OR
        operation, are:

        SCARD_PROTOCOL_T0 - T=0 is an acceptable protocol.

        SCARD_PROTOCOL_T1 - T=1 is an acceptable protocol.

    phCard receives a handle identifying the connection to the smartcard in the
        designated reader.

    pdwActiveProtocol receives a flag indicating the established active
        protocol.  Possible values are:

        SCARD_PROTOCOL_T0 - T=0 is the active protocol.

        SCARD_PROTOCOL_T1 - T=1 is the active protocol.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardConnectW")

WINSCARDAPI LONG WINAPI
SCardConnectW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReader,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT LPSCARDHANDLE phCard,
    OUT LPDWORD pdwActiveProtocol)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CReaderContext *pRdr = NULL;
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        *phCard = NULL;     // Touch it to be sure it's real.
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        CTextString tzReader;

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        tzReader = szReader;
        pRdr = new CReaderContext;
        if (NULL == pRdr)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();
        if (hRedirContext)
        {
            SCARDHANDLE hCard = g_phlReaders->Add(pRdr);    // do it first to avoid out of memory condition
            nReturn = pfnSCardConnectW(hRedirContext, szReader, dwShareMode, dwPreferredProtocols, phCard, pdwActiveProtocol);
            if (nReturn == SCARD_S_SUCCESS)
            {
                pRdr->SetRedirCard(*phCard);
                *phCard = hCard;
            }
            else
            {
                g_phlReaders->Close(hCard);
                delete pRdr;
            }
        }
        else
        {
            pSubCtx = pCtx->AcquireSubcontext(TRUE);
            pRdr->Connect(
                    pSubCtx,
                    tzReader,
                    dwShareMode,
                    dwPreferredProtocols);
            pSubCtx = NULL;
            pRdr->Context()->ReleaseSubcontext();
            if (NULL != pdwActiveProtocol)
                *pdwActiveProtocol = pRdr->Protocol();
            pRdr->Context()->m_hReaderHandle = g_phlReaders->Add(pRdr);
            *phCard = pRdr->Context()->m_hReaderHandle;
        }
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardStatus:

    This routine provides the current status of the reader.  It may be used at
    any time following a successful call to SCardConnect or SCardOpenReader, and
    prior to a successful call to SCardDisconnect.  It does not effect the state
    of the reader or driver.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    mszReaderNames - This receives a list of friendly names by which the
        currently connected reader is known.  This list is returned as a
        multistring.

    pcchReaderLen - This supplies the length of the mszReader buffer, in
        characters, and receives the actual returned length of the reader
        friendly name list, in characters, including the trailing NULL
        characters.

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    pbAtr - This parameter points to a 32-byte buffer which receives the ATR
        string from the currently inserted card, if available.

    pbcAtrLen - This points to a DWORD which supplies the length of the pbAtr
        buffer, and receives the actual number of bytes in the ATR string.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardStatusW")

WINSCARDAPI LONG WINAPI
SCardStatusW(
    IN SCARDHANDLE hCard,
    OUT LPWSTR mszReaderNames,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pRdr->GetRedirCard())
        {
            nReturn = pfnSCardStatusW(pRdr->GetRedirCard(), mszReaderNames, pcchReaderLen, pdwState, pdwProtocol, pbAtr, pcbAtrLen);
        }
        else
        {
            CBuffer bfAtr, bfReader;
            DWORD dwLocalState, dwLocalProtocol;

            pRdr->Status(&dwLocalState, &dwLocalProtocol, bfAtr, bfReader);
            if (NULL != pdwState)
                *pdwState = dwLocalState;
            if (NULL != pdwProtocol)
                *pdwProtocol = dwLocalProtocol;
            if (NULL != pcchReaderLen)
                PlaceMultiResult(
                    pRdr->Context()->Parent(),
                    bfReader,
                    mszReaderNames,
                    pcchReaderLen);
            if (NULL != pcbAtrLen)
                PlaceResult(pRdr->Context()->Parent(), bfAtr, pbAtr, pcbAtrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
///////////////////////////////////////////////////////////////////////////////
//
//  Utility Routines
//

/*++

PlaceResult:

    This set of routines places the result of an operation into the user's
    output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes, etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the result to be returned to the user.

    pbOutput receives the result for the user, as a byte stream.

    szOutput receives the result as an ANSI or UNICODE string.

    pcbLength supplies the length of the user's output buffer in bytes, and
        receives how much of it was used.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceResult")

void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR szOutput,
    LPDWORD pcchLength)
{
    LPWSTR szForUser = NULL;
    LPWSTR szOutBuf = szOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == szOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    szForUser = (LPWSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(WCHAR));
                }
                else
                    szForUser = (LPWSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(WCHAR));

                if (NULL == szForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }

                *(LPWSTR *)szOutput = szForUser;
                szOutBuf = szForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPWSTR *)szOutput = (LPWSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToUnicodeString(
                szOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != szForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, szForUser);
            else
                pCtx->FreeMemory(szForUser);
        }
        throw;
    }
}


/*++

PlaceMultiResult:

    This set of routines places a Multistring result of an operation into the
    user's output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes,
    etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the TCHAR multistring result to be returned to the user.

    mszOutput receives the result as an ANSI or UNICODE multistring.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceMultiResult")

void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR mszOutput,
    LPDWORD pcchLength)
{
    LPWSTR mszForUser = NULL;
    LPWSTR mszOutBuf = mszOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == mszOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    mszForUser = (LPWSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(WCHAR));
                }
                else
                    mszForUser = (LPWSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(WCHAR));

                if (NULL == mszForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }

                *(LPWSTR *)mszOutput = mszForUser;
                mszOutBuf = mszForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPWSTR *)mszOutput = (LPWSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToUnicodeMultiString(
                mszOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != mszForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, mszForUser);
            else
                pCtx->FreeMemory(mszForUser);
        }
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\calmsgs.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    CalMsgs

Abstract:

    This module provides Message logging services.

Author:

    Doug Barlow (dbarlow) 5/29/1997

Environment:

    Win32, C++

Notes:

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalaisLb.h>
#include <CalCom.h>
#include <scarderr.h>
#ifdef DBG
#include <stdio.h>
#include <stdarg.h>
#endif

#ifndef FACILITY_SCARD
#define FACILITY_SCARD 16
#endif
// #define ErrorCode(x) (0xc0000000 | (FACILITY_SCARD << 16) + (x))
// #define WarnCode(x)  (0x80000000 | (FACILITY_SCARD << 16) + (x))
// #define InfoCode(x)  (0x40000000 | (FACILITY_SCARD << 16) + (x))
// #define SuccessCode(x)            ((FACILITY_SCARD << 16) + (x))

#if defined(_DEBUG)
BOOL g_fDebug        = FALSE;
BOOL g_fGuiWarnings  = TRUE;
WORD g_wGuiSeverity  = EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE;
WORD g_wLogSeverity  = 0x03;
#ifndef DBG
#define DBG
#endif
#elif defined(DBG)
BOOL g_fDebug        = FALSE;
BOOL g_fGuiWarnings  = FALSE;
WORD g_wGuiSeverity  = EVENTLOG_ERROR_TYPE;
WORD g_wLogSeverity  = EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE;
#else
WORD g_wLogSeverity  = EVENTLOG_ERROR_TYPE;
#endif
static LPCTSTR l_szServiceName = TEXT("SCard Client");
static HANDLE l_hEventLogger = NULL;
static BOOL l_fServer = FALSE;
static const TCHAR l_szDefaultMessage[] = TEXT("SCARDSVR!CalaisMessageLog error logging is broken: %1");


//
// Common global strings.
//

const LPCTSTR g_rgszDefaultStrings[]
    = {
    /* CALSTR_CALAISEXECUTABLE          */  TEXT("%windir%\\system32\\SCardSvr.exe"),
    /* CALSTR_PRIMARYSERVICE            */  TEXT("SCardSvr"),
    /* CALSTR_LEGACYSERVICE             */  TEXT("SCardDrv"),
    /* CALSTR_CALAISREGISTRYKEY         */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais"),
    /* CALSTR_READERREGISTRYKEY         */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"),
    /* CALSTR_SMARTCARDREGISTRYKEY      */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
    /* CALSTR_READERREGISTRYSUBKEY      */  TEXT("Readers"),
    /* CALSTR_DEVICEREGISTRYSUBKEY      */  TEXT("Device"),
    /* CALSTR_GROUPSREGISTRYSUBKEY      */  TEXT("Groups"),
    /* CALSTR_ATRREGISTRYSUBKEY         */  TEXT("ATR"),
    /* CALSTR_ATRMASKREGISTRYSUBKEY     */  TEXT("ATRMask"),
    /* CALSTR_INTERFACESREGISTRYSUBKEY  */  TEXT("Supported Interfaces"),
    /* CALSTR_PRIMARYPROVIDERSUBKEY     */  TEXT("Primary Provider"),
    /* CALSTR_CRYPTOPROVIDERSUBKEY      */  TEXT("Crypto Provider"),
    /* CALSTR_SERVICESREGISTRYKEY       */  TEXT("SYSTEM\\CurrentControlSet\\Services"),
    /* CALSTR_EVENTLOGREGISTRYKEY       */  TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog"),
    /* CALSTR_SYSTEMREGISTRYSUBKEY      */  TEXT("System"),
    /* CALSTR_EVENTMESSAGEFILESUBKEY    */  TEXT("EventMessageFile"),
    /* CALSTR_TYPESSUPPORTEDSUBKEY      */  TEXT("TypesSupported"),
    /* CALSTR_PNPDEVICEREGISTRYKEY      */  TEXT("SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{50dd5230-ba8a-11d1-bf5d-0000f805f530}"),
    /* CALSTR_SYMBOLICLINKSUBKEY        */  TEXT("SymbolicLink"),
    /* CALSTR_VXDPATHREGISTRYKEY        */  TEXT("System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices"),
    /* CALSTR_LEGACYDEPENDONGROUP       */  TEXT("+Smart Card Reader"),
    /* CALSTR_NEWREADEREVENTNAME        */  TEXT("Global\\Microsoft Smart Card Resource Manager New Reader"),
    /* CALSTR_STARTEDEVENTNAME          */  TEXT("Global\\Microsoft Smart Card Resource Manager Started"),
    /* CALSTR_CANCELEVENTPREFIX         */  TEXT("Global\\Microsoft Smart Card Cancel Event for %1!d!"),
    /* CALSTR_COMMPIPENAME              */  TEXT("Microsoft Smart Card Resource Manager"),
    /* CALSTR_LEGACYDEVICEHEADER        */  TEXT("\\\\.\\"),
    /* CALSTR_LEGACYDEVICENAME          */  TEXT("SCReader"),
    /* CALSTR_MAXLEGACYDEVICES          */  TEXT("MaxLegacyDevices"),
    /* CALSTR_MAXDEFAULTBUFFER          */  TEXT("MaxDefaultBuffer"),
    /* CALSTR_PIPEDEVICEHEADER          */  TEXT("\\\\.\\pipe\\"),
    /* CALSTR_SERVICEDEPENDENCIES       */  TEXT("PlugPlay\000"),
    /* CALSTR_SPECIALREADERHEADER       */  TEXT("\\\\?PNP?\\"),
    /* CALSTR_ACTIVEREADERCOUNTREADER   */  TEXT("NOTIFICATION"),
    /* CALSTR_CERTPROPREGISTRY          */  TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify"),
    /* CALSTR_CERTPROPKEY               */  TEXT("ScCertProp"),
    /* CALSTR_DLLNAME                   */  TEXT("DLLName"),
    /* CALSTR_LOGON                     */  TEXT("Logon"),
    /* CALSTR_LOGOFF                    */  TEXT("Logoff"),
    /* CALSTR_LOCK                      */  TEXT("Lock"),
    /* CALSTR_UNLOCK                    */  TEXT("Unlock"),
    /* CALSTR_ENABLED                   */  TEXT("Enabled"),
    /* CALSTR_IMPERSONATE               */  TEXT("Impersonate"),
    /* CALSTR_ASYNCHRONOUS              */  TEXT("Asynchronous"),
    /* CALSTR_CERTPROPDLL               */  TEXT("WlNotify.dll"),
    /* CALSTR_CERTPROPSTART             */  TEXT("SCardStartCertProp"),
    /* CALSTR_CERTPROPSTOP              */  TEXT("SCardStopCertProp"),
    /* CALSTR_CERTPROPSUSPEND           */  TEXT("SCardSuspendCertProp"),
    /* CALSTR_CERTPROPRESUME            */  TEXT("SCardResumeCertProp"),
    /* CALSTR_SMARTCARDINSERTION        */  TEXT("SmartcardInsertion"),
    /* CALSTR_SMARTCARDREMOVAL          */  TEXT("SmartcardRemoval"),
    /* CALSTR_APPEVENTS                 */  TEXT("AppEvents"),
    /* CALSTR_EVENTLABELS               */  TEXT("EventLabels"),
    /* CALSTR_DOT_DEFAULT               */  TEXT(".Default"),
    /* CALSTR_DOT_CURRENT               */  TEXT(".Current"),
    /* CALSTR_SOUNDSREGISTRY            */  TEXT("Schemes\\Apps\\.Default"),
    /* CALSTR_LOGONREGISTRY             */  TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
    /* CALSTR_LOGONREMOVEOPTION         */  TEXT("ScRemoveOption"),
    /* CALSTR_STOPPEDEVENTNAME          */  TEXT("Global\\Microsoft Smart Card Resource Manager Stopped"),

// Unused
//  /* CALSTR_TEMPLATEREGISTRYKEY       */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCard Templates"),
//  /* CALSTR_OEMCONFIGREGISTRYSUBKEY   */  TEXT("OEM Configuration"),

// Debug only
    /* CALSTR_DEBUGSERVICE              */  TEXT("SCardDbg"),
    /* CALSTR_DEBUGREGISTRYSUBKEY       */  TEXT("Debug"),
    
#ifdef DBG
    /* CALSTR_DEBUGLOGSUBKEY            */  TEXT("Debug"),
    /* CALSTR_GUIWARNINGSUBKEY          */  TEXT("GuiWarnings"),
    /* CALSTR_LOGSEVERITYSUBKEY         */  TEXT("LogSeverity"),
    /* CALSTR_GUISEVERITYSUBKEY         */  TEXT("GuiSeverity"),
    /* CALSTR_APITRACEFILENAME          */  TEXT("C:\\SCard.log"),
    /* CALSTR_DRIVERTRACEFILENAME       */  TEXT("C:\\Calais.log"),
    /* CALSTR_MESSAGETAG                */  TEXT(" *MESSAGE* "),
    /* CALSTR_INFOMESSAGETAG            */  TEXT(" *INFO* "),
    /* CALSTR_WARNINGMESSAGETAG         */  TEXT(" *WARNING* "),
    /* CALSTR_ERRORMESSAGETAG           */  TEXT(" *ERROR* "),
    /* CALSTR_DEBUGSERVICEDISPLAY       */  TEXT("Smart Card Debug"),
    /* CALSTR_DEBUGSERVICEDESC          */  TEXT("Start this service first to debug Smart card service startup"),
#endif
    NULL };


/*++

CalaisMessageLog:

    This function and it's derivatives provide convienent error logging
    capabilities.  On NT, errors are logged to the Event Log file.  Otherwise,
    the errors are placed in a message box for the user.

Arguments:

    wSeverity - Supplies the severity of the event.  Possible values are:

        EVENTLOG_SUCCESS - A success event is to be logged.
        EVENTLOG_ERROR_TYPE - An Error event is to be logged.
        EVENTLOG_WARNING_TYPE - A Warning event is to be logged.
        EVENTLOG_INFORMATION_TYPE - An Informational event is to be logged.

    dwMessageId - Message Id from the resource file.

    szMessageStr - Message, supplied as a string.

    cbBinaryData - Size, in bytes, of any binary data to include with the log.

    pvBinaryData - Pointer to binary data to include with the log, or NULL.

    rgszParams - An array of pointers to strings to be included as parameters.
        The last pointer must be NULL.

    szParam<n> - A string parameter to include with the message

    dwParam<n> - A DWORD value to include with the message.


Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 5/9/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageLog")

void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    DWORD dwMessageId,
    LPCTSTR *rgszParams,
    LPCVOID pvBinaryData,
    DWORD cbBinaryData)
{
    LPTSTR szMessage = (LPTSTR)l_szDefaultMessage;
    DWORD cchMessage, dwLen;
    LCID SaveLCID;
    BOOL fSts;

    if (0 != (wSeverity & g_wLogSeverity))
    {
        WORD cszParams = 0;

        if (NULL != rgszParams)
        {
            while (NULL != rgszParams[cszParams])
                cszParams += 1;
        }

        if (EVENTLOG_INFORMATION_TYPE > wSeverity)
        {
            if (l_fServer && (NULL == l_hEventLogger))
            {
                l_hEventLogger = RegisterEventSource(
                                        NULL,
                                        CalaisString(CALSTR_PRIMARYSERVICE));

            }
            if (NULL != l_hEventLogger)
            {
                fSts = ReportEvent(
                            l_hEventLogger,
                            wSeverity,
                            0,
                            dwMessageId,
                            NULL,
                            cszParams,
                            cbBinaryData,
                            rgszParams,
                            (LPVOID)pvBinaryData);
            }
        }

#ifdef DBG
        // Don't pass specific lang id to FormatMessage, as it fails if there's
        // no msg in that language.  Instead, set the thread locale, which will
        // get FormatMessage to use a search algorithm to find a message of the
        // appropriate language, or use a reasonable fallback msg if there's
        // none.

        SaveLCID = GetThreadLocale();
        SetThreadLocale(LOCALE_SYSTEM_DEFAULT);

        cchMessage = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        GetModuleHandle(TEXT("winscard.dll")),  // NULL on server
                        dwMessageId,
                        0,
                        (LPTSTR)&szMessage,
                        0,
                        (va_list *)rgszParams);
        SetThreadLocale(SaveLCID);
        dwLen = lstrlen(szMessage);
        if (0 < dwLen)
        {
            dwLen -= 1;
            while (!_istgraph(szMessage[dwLen]))
            {
                szMessage[dwLen] = 0;
                if (0 == dwLen)
                    break;
                dwLen -= 1;
            }
        }

        {
            CTextString tzOutMessage;

            tzOutMessage = l_szServiceName;
            tzOutMessage += TEXT("!");
            tzOutMessage += szSubroutine;
            if (0 != (EVENTLOG_ERROR_TYPE & wSeverity))
                tzOutMessage += CalaisString(CALSTR_ERRORMESSAGETAG);
            else if (0 != (EVENTLOG_WARNING_TYPE & wSeverity))
                tzOutMessage += CalaisString(CALSTR_WARNINGMESSAGETAG);
            else if (0 != (EVENTLOG_INFORMATION_TYPE & wSeverity))
                tzOutMessage += CalaisString(CALSTR_INFOMESSAGETAG);
            else
                tzOutMessage += CalaisString(CALSTR_MESSAGETAG);
            if ((0 == cchMessage) || (NULL == szMessage))
                tzOutMessage += CErrorString(GetLastError());
            else
                tzOutMessage += szMessage;
            tzOutMessage += TEXT("\n");
#ifdef _DEBUG
            _putts(tzOutMessage);
#else
            OutputDebugString(tzOutMessage);
#endif
        }
        if ((g_fGuiWarnings) && (0 != (g_wGuiSeverity & wSeverity)))
        {
            int nAction;
            DWORD dwIcon;

            if (0 != (EVENTLOG_ERROR_TYPE & wSeverity))
                dwIcon = MB_ICONERROR;
            else if (0 != (EVENTLOG_WARNING_TYPE & wSeverity))
                dwIcon = MB_ICONWARNING;
            else if (0 != (EVENTLOG_INFORMATION_TYPE & wSeverity))
                dwIcon = MB_ICONINFORMATION;
            else
                dwIcon = 0;
            if ((0 == cchMessage) || (NULL == szMessage))
            {
                nAction = MessageBox(
                                NULL,
                                CErrorString(GetLastError()),
                                l_szDefaultMessage,
                                MB_SYSTEMMODAL
                                | MB_OKCANCEL
                                | dwIcon);
            }
            else
            {
                nAction = MessageBox(
                                NULL,
                                szMessage,
                                l_szServiceName,
                                MB_SYSTEMMODAL
                                | MB_OKCANCEL
                                | dwIcon);
            }
            if (IDCANCEL == nAction)
            {
                breakpoint;
            }
        }
        if ((NULL != szMessage) && (l_szDefaultMessage != szMessage))
            LocalFree((LPVOID)szMessage);
#endif

    }
}

#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageLog")

void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    LPCTSTR szMessageStr,
    LPCTSTR *rgszParams,
    LPCVOID pvBinaryData,
    DWORD cbBinaryData)
{
    if (0 != (wSeverity & g_wLogSeverity))
    {
        LPCTSTR szMessage = l_szDefaultMessage;
        DWORD cchMessage;
        LPCTSTR szArgs[2];

        cchMessage = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_STRING
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szMessageStr,
                        0,
                        0,
                        (LPTSTR)&szMessage,
                        0,
                        (va_list *)rgszParams);
        szArgs[0] = szMessage;
        szArgs[1] = NULL;
        CalaisMessageLog(
            szSubroutine,
            wSeverity,
            1,  // "%1"
            szArgs,
            pvBinaryData,
            cbBinaryData);
        if ((NULL != szMessage) && (l_szDefaultMessage != szMessage))
            LocalFree((LPVOID)szMessage);
    }
}


/*++
CalaisError:
CalaisWarning:
CalaisInfo:

    The following routines supply convienent access to the error logging
    services, above.

Arguments:

    dwMessageId - Supplies a message Id code to use to obtain the message from
        the current image's message resource.

    szMessage - Supplies the message as a string.

    dwErrorCode - Supples an error code to be converted into a string as the
        parameter %1.

    szParam<n> - Supplies an optional parameter for the message as %<n>.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisInfo")

void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];

    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_INFORMATION_TYPE,
        szMessage,
        rgszParams);
}

void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];
    CErrorString szErrStr(dwErrorCode);

    rgszParams[0] = szErrStr.Value();
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_INFORMATION_TYPE,
        szMessage,
        rgszParams);
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisWarning")

void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];

    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_WARNING_TYPE,
        szMessage,
        rgszParams);
}

void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];
    CErrorString szErrStr(dwErrorCode);

    rgszParams[0] = szErrStr.Value();
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_WARNING_TYPE,
        szMessage,
        rgszParams);
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisError")

void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    DWORD dwLineNo)
{
    LPCTSTR rgszParams[4];
    TCHAR szLineNo[32];

    _stprintf(szLineNo, TEXT("%d"), dwLineNo);
    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szLineNo;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_ERROR_TYPE,
        szMessage,
        rgszParams);
}

#endif
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisError")

void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    DWORD dwErrorCode,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];
    CErrorString szErrStr(dwErrorCode);

    rgszParams[0] = szErrStr.Value();
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_ERROR_TYPE,
        dwMessageId,
        rgszParams);
}

void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];

    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_ERROR_TYPE,
        dwMessageId,
        rgszParams);
}


/*++

CalaisMessageInit:

    This routine prepares the error logging system.

Arguments:

    szTitle supplies the title of the module for logging purposes.

    hEventLogger supplies a handle to an event logging service.  This parameter
        may be NULL.

    fServer supplies an indicator as to whether or not this process is a
        service which should try really hard to log errors.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 5/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageInit")

void
CalaisMessageInit(
    LPCTSTR szTitle,
    HANDLE hEventLogger,
    BOOL fServer)
{
    ASSERT(NULL == l_hEventLogger);
    l_szServiceName = szTitle;
    l_hEventLogger = hEventLogger;
    l_fServer = fServer;
#ifdef DBG
    try
    {
        DWORD dwValue;
        CRegistry regSc(
                    HKEY_LOCAL_MACHINE,
                    CalaisString(CALSTR_CALAISREGISTRYKEY),
                    KEY_READ);
        CRegistry regDebug(
                    regSc,
                    CalaisString(CALSTR_DEBUGREGISTRYSUBKEY),
                    KEY_READ);
        regDebug.GetValue(CalaisString(CALSTR_DEBUGLOGSUBKEY), &dwValue);
        g_fDebug = (0 != dwValue);
        regDebug.GetValue(CalaisString(CALSTR_LOGSEVERITYSUBKEY), &dwValue);
        g_wLogSeverity = (WORD)dwValue;
        regDebug.GetValue(CalaisString(CALSTR_GUIWARNINGSUBKEY), &dwValue);
        g_fGuiWarnings = (0 != dwValue);
        regDebug.GetValue(CalaisString(CALSTR_GUISEVERITYSUBKEY), &dwValue);
        g_wGuiSeverity = (WORD)dwValue;
    }
    catch (...) {}
#endif
}


/*++

CalaisMessageClose:

    This routine closes out any error loging in progress, and cleans up.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 5/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageClose")

void
CalaisMessageClose(
    void)
{
    if (NULL != l_hEventLogger)
        DeregisterEventSource(l_hEventLogger);
    l_hEventLogger = NULL;
    l_szServiceName = NULL;
}


/*++

CalaisString:

    This routine converts a string identifier into a string.

Arguments:

    dwStringId supplies the identifier for the string.

Return Value:

    The target string value.

Remarks:

    String Ids larger than CALSTR_RESOURCELIMIT are assumed to be resources.

Author:

    Doug Barlow (dbarlow) 4/8/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisString")

LPCTSTR
CalaisString(
    DWORD dwStringId)
{
    static LPTSTR rgszResources[]
        = { NULL, NULL, NULL, NULL, NULL, NULL };   // 6 is all we have for now...
    LPCTSTR szReturn;
    int nStrLen;
    DWORD dwResId = (dwStringId % CALSTR_RESOURCELIMIT) - 1;

    if (CALSTR_RESOURCELIMIT > dwStringId)
    {

        //
        // This is a straight internal text string.
        //

        szReturn = g_rgszDefaultStrings[(dwStringId) - 1];
    }
    else if (dwResId > (sizeof(rgszResources) / sizeof(LPCTSTR)))
    {

        //
        // Make sure the request isn't out of our range.
        //

        ASSERT(FALSE);  // Make that 6 bigger.
        szReturn = TEXT("<Resource out of Range>");
    }
    else if (NULL != rgszResources[dwResId])
    {

        //
        // Have we already loaded that resource?  If so, return
        // it from the cache.
        //

        szReturn = rgszResources[dwResId];
    }
    else
    {
        TCHAR szString[MAX_PATH];


        //
        // OK, we've got to load the resource into the cache.
        //

        nStrLen = LoadString(
                        NULL,
                        dwStringId - CALSTR_RESOURCELIMIT,
                        szString,
                        sizeof(szString));
        if (0 < nStrLen)
        {
            rgszResources[dwResId]
                = (LPTSTR)HeapAlloc(
                            GetProcessHeap(),
                            0,
                            (nStrLen + 1) * sizeof(TCHAR));
            if (NULL != rgszResources[dwResId])
            {
                lstrcpy(rgszResources[dwResId], szString);
                szReturn = rgszResources[dwResId];
            }
            else
                szReturn = TEXT("<Resource Load Error>");
        }
        else
            szReturn = TEXT("<Unavailable Resource>");
    }

    return szReturn;
}


//
//==============================================================================
//
//  Hard core debugging routines.
//

#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisSetDebug")
void
CalaisSetDebug(
    BOOLEAN Debug
    )
{
    g_fDebug = Debug;
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("_CalaisDebug")
void
_CalaisDebug(
    LPCTSTR szFormat,
    ...
    )
{
    TCHAR szBuffer[512];
    va_list ap;

    if (g_fDebug == FALSE) {

        return;
    }

    va_start(ap, szFormat);
    _vstprintf(szBuffer, szFormat, ap);
#ifdef _DEBUG
    _putts(szBuffer);
#else
    OutputDebugString(szBuffer);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\cominitr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ComInitr

Abstract:

    This module implements the methods for the Communications Initiation Class.

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:



--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <limits.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>
#include <stdlib.h>
#include <aclapi.h>

HANDLE g_hCalaisShutdown = NULL;    // This is used by the Send and Receive
                                    // methods of the CComChannel.  It stays
                                    // NULL.

//
//==============================================================================
//
//  CComInitiator
//

/*++

Initiate:

    This method creates a communications channel object to the supplied target.

Arguments:

    szName supplies the full file name of the target with which to initiate a
        connection.

Return Value:

    None

Throws:

    DWORDs representing any error conditions encountered.

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComInitiator::Initiate")

CComChannel *
CComInitiator::Initiate(
    LPCTSTR szName,
    LPDWORD pdwVersion)
const
{
    LPCTSTR szPipeHdr = CalaisString(CALSTR_PIPEDEVICEHEADER);
    CComChannel *pChannel = NULL;
    CHandleObject hComPipe(DBGT("Comm Pipe Handle from CComInitiator::Initiate"));

    try
    {
        BOOL fSts;
        DWORD dwSts;
        DWORD cbPipeHeader = lstrlen(szPipeHdr) * sizeof(TCHAR);
        CBuffer bfPipeName;
        DWORD dwLen;
        HANDLE hStarted;
        DWORD nPipeNo;
        HKEY hCurrentKey;
        TCHAR szPipeNo[sizeof(nPipeNo)*2 + 1];    // Twice as many hex digits + zero
        DWORD cbData;
        DWORD ValueType;

        //
        // Build the pipe name.
        //

        dwLen = lstrlen(szName) * sizeof(TCHAR);
        bfPipeName.Presize(cbPipeHeader + dwLen + sizeof(szPipeNo));


        //
        // Build our Connect Request block.
        //

        CComChannel::CONNECT_REQMSG creq;
        CComChannel::CONNECT_RSPMSG crsp;

        hStarted = AccessStartedEvent();
        if ((NULL == hStarted) ||
            (WAIT_OBJECT_0 != WaitForSingleObject(hStarted, 0)))
        {
            throw (DWORD)SCARD_E_NO_SERVICE;
        }

        //
        // Open the Current key.
        //
        dwSts = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                        _T("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Current"),
                       0,                       // options (ignored)
                       KEY_QUERY_VALUE,
                       &hCurrentKey
                       );
        if (ERROR_SUCCESS != dwSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Initiator could not access the Current key:  %1"),
                dwSts);
            throw dwSts;
        }

        cbData = sizeof(nPipeNo);
        dwSts = RegQueryValueEx(
                    hCurrentKey,
                    NULL,                // Use key's unnamed value
                    0,
                    &ValueType,
                    (LPBYTE) &nPipeNo,
                    &cbData);

        RegCloseKey(hCurrentKey);

        if (dwSts != ERROR_SUCCESS || ValueType != REG_DWORD)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Initiator failed to query the Current value:  %1"),
                dwSts);
            throw dwSts;
        }

        _itot(nPipeNo, szPipeNo, 16);

        bfPipeName.Set((LPCBYTE)szPipeHdr, cbPipeHeader);
        bfPipeName.Append((LPCBYTE)szName, dwLen);
        bfPipeName.Append((LPCBYTE)szPipeNo, sizeof(szPipeNo));

        {
            PSID pPipeOwnerSid;
            PSID pLocalServiceSid = NULL;
            PSECURITY_DESCRIPTOR pSD = NULL;
            SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

RetryGetInfo:
            dwSts = GetNamedSecurityInfo(
                (LPTSTR)(LPCTSTR)bfPipeName,
                SE_FILE_OBJECT,
                OWNER_SECURITY_INFORMATION,
                &pPipeOwnerSid,
                NULL,
                NULL,
                NULL,
                &pSD);
            if (ERROR_SUCCESS != dwSts)
            {
                if (ERROR_PIPE_BUSY == dwSts)
                {
                    fSts = WaitNamedPipe((LPCTSTR)bfPipeName, NMPWAIT_USE_DEFAULT_WAIT);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Comm Initiator could not wait for a communication pipe:  %1"),
                            dwSts);
                        throw dwSts;
                    }
                    goto RetryGetInfo;
                }
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not get the security info:  %1"),
                    dwSts);
                throw dwSts;
            }

            if (!AllocateAndInitializeSid(
                &NtAuthority, 1, SECURITY_LOCAL_SERVICE_RID,
                0, 0, 0, 0, 0, 0, 0,
                &pLocalServiceSid))
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not create SID:  %1"),
                    dwSts);
            }
            else
            {
                if (!EqualSid(pLocalServiceSid, pPipeOwnerSid))
                {
                    dwSts = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Initiator could not verify the owner of the pipe:  %1"),
                        dwSts);
                }

                FreeSid(pLocalServiceSid);
            }

            LocalFree(pSD);
            if (ERROR_SUCCESS != dwSts)
            {
                throw dwSts;
            }
        }

RetryCreate:
        hComPipe = CreateFile(
                        (LPCTSTR)bfPipeName,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (!hComPipe.IsValid())
        {
            dwSts = hComPipe.GetLastError();
            switch (dwSts)
            {

            //
            // The resource manager isn't started.
            case ERROR_FILE_NOT_FOUND:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not create communication pipe:  %1"),
                    dwSts);
                throw (DWORD)SCARD_E_NO_SERVICE;
                break;

            //
            // The pipe is busy.
            case ERROR_PIPE_BUSY:
                fSts = WaitNamedPipe((LPCTSTR)bfPipeName, NMPWAIT_USE_DEFAULT_WAIT);
                if (!fSts)
                {
                    dwSts = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Initiator could not wait for a communication pipe:  %1"),
                        dwSts);
                    throw dwSts;
                }
                goto RetryCreate;
                break;

            //
            // A hard error.
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not create communication pipe:  %1"),
                    dwSts);
                throw dwSts;
            }
        }

        creq.dwSync = 0;
        creq.dwVersion = *pdwVersion;


        //
        // Establish the communication.
        //

        pChannel = new CComChannel(hComPipe);
        if (NULL == pChannel)
        {
            dwSts = SCARD_E_NO_MEMORY;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Com Initiator could not allocate a Comm Channel:  %1"),
                dwSts);
            throw dwSts;
        }
        hComPipe.Relinquish();
        pChannel->Send(&creq, sizeof(creq));
        pChannel->Receive(&crsp, sizeof(crsp));
        if (ERROR_SUCCESS != crsp.dwStatus)
            throw crsp.dwStatus;


        //
        // Check the response.
        // In future versions, we may have to negotiate a version.
        //

        if (crsp.dwVersion != *pdwVersion)
            throw (DWORD)SCARD_F_COMM_ERROR;
        *pdwVersion = crsp.dwVersion;
    }

    catch (...)
    {
        if (NULL != pChannel)
            delete pChannel;
        if (hComPipe.IsValid())
            hComPipe.Close();
        throw;
    }

    return pChannel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\comchanl.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ComChanl

Abstract:

    This module implements the CComChannel Communications Class

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>


//
//==============================================================================
//
//  CComChannel
//

/*++

CComChannel:

    This is the standard constructor and destructor for the Comm Channel
    class.  They just call the clean and clear functions, respectively.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::CComChannel")

CComChannel::CComChannel(
    HANDLE hPipe)
:   m_hPipe(DBGT("CComChannel connection pipe")),
    m_hProc(DBGT("CComChannel process handle")),
    m_hOvrWait(DBGT("CComChannel overlapped I/O event"))
{
    m_hPipe = hPipe;
    ZeroMemory(&m_ovrlp, sizeof(m_ovrlp));
    m_ovrlp.hEvent = m_hOvrWait = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hOvrWait.IsValid())
    {
        DWORD dwErr = m_hOvrWait.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Comm Responder failed to create overlapped event: %1"),
            dwErr);
        throw dwErr;
    }
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::~CComChannel")
CComChannel::~CComChannel()
{
    if (m_hPipe.IsValid())
        m_hPipe.Close();
    if (m_hProc.IsValid())
        m_hProc.Close();
    if (m_hOvrWait.IsValid())
        m_hOvrWait.Close();
}


/*++

Send:

    Send data over the communications channel.

Arguments:

    pvData supplies the data to be written.
    cbLen supplies the length of the data, in bytes.

Return Value:

    A DWORD status code.

Throws:

    None.

Author:

    Doug Barlow (dbarlow) 11/4/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::Send")

DWORD
CComChannel::Send(
    LPCVOID pvData,
    DWORD cbLen)
{
    BOOL fSts;
    DWORD dwLen, dwOffset = 0;
    DWORD dwSts = SCARD_S_SUCCESS;

    while (0 < cbLen)
    {
        fSts = WriteFile(
            m_hPipe,
            &((LPBYTE)pvData)[dwOffset],
            cbLen,
            &dwLen,
            &m_ovrlp);
        if (!fSts)
        {
            BOOL fErrorProcessed;
            dwSts = GetLastError();

            do
            {
                fErrorProcessed = TRUE;
                switch (dwSts)
                {
                //
                // Postpone processing
                case ERROR_IO_PENDING:
                    fErrorProcessed = FALSE;
                    WaitForever(
                        m_ovrlp.hEvent,
                        REASONABLE_TIME,
                        DBGT("Comm Channel response write"),
                        (DWORD)0);
                    fSts = GetOverlappedResult(
                                m_hPipe,
                                &m_ovrlp,
                                &dwLen,
                                TRUE);
                    dwSts = fSts ? ERROR_SUCCESS : GetLastError();
                    break;

                //
                // Success after a wait event.
                case ERROR_SUCCESS:
                    break;

                //
                // The pipe may have been closed, for instance, the context
                // may have been marked invalid as a result of a session
                // change.
                case ERROR_BROKEN_PIPE:
                case ERROR_INVALID_HANDLE:
                    throw (DWORD)ERROR_BROKEN_PIPE;
                    break;

                //
                // Some other error.
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Channel could not write to pipe:  %1"),
                        dwSts);
                    goto ErrorExit;
                }
            } while (!fErrorProcessed);
        }
        cbLen -= dwLen;
    }

ErrorExit:
    return dwSts;
}


/*++

Receive:

    This method receives a given number of bytes from the communications
    channel.

Arguments:

    pvData receives the incoming bytes.
    cbLen supplies the length of the data expected.

Return Value:

    None

Throws:

    Transmission errors as a DWORD.

Author:

    Doug Barlow (dbarlow) 11/4/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::Receive")

void
CComChannel::Receive(
    LPVOID pvData,
    DWORD cbLen)
{
    BOOL fSts;
    DWORD dwLen, dwOffset = 0;

    while (0 < cbLen)
    {
        fSts = ReadFile(
                m_hPipe,
                &((LPBYTE)pvData)[dwOffset],
                cbLen,
                &dwLen,
                &m_ovrlp);
        if (!fSts)
        {
            BOOL fErrorProcessed;
            DWORD dwSts = GetLastError();
            DWORD dwWait;

            do
            {
                fErrorProcessed = TRUE;
                switch (dwSts)
                {
                //
                // Postpone processing
                case ERROR_IO_PENDING:
                    dwWait = WaitForAnyObject(
                                    INFINITE,
                                    m_ovrlp.hEvent,
                                    g_hCalaisShutdown,  // Make sure this is last
                                    NULL);
                    switch (dwWait)
                    {
                    case 1:
                        fErrorProcessed = FALSE;
                        fSts = GetOverlappedResult(
                                    m_hPipe,
                                    &m_ovrlp,
                                    &dwLen,
                                    TRUE);
                        dwSts = fSts ? ERROR_SUCCESS : GetLastError();
                        break;
                    case 2:
                        throw (DWORD)SCARD_P_SHUTDOWN;
                        break;
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Wait for comm pipe receive returned invalid value"));
                        throw (DWORD)SCARD_F_INTERNAL_ERROR;
                    }
                    break;

                //
                // Success after a wait event.
                case ERROR_SUCCESS:
                    break;

                //
                // The client exited.
                case ERROR_BROKEN_PIPE:
                case ERROR_INVALID_HANDLE:
                    throw (DWORD)ERROR_BROKEN_PIPE;
                    break;

                //
                // Some other error.
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Channel could not read from pipe:  %1"),
                        dwSts);
                    throw dwSts;
                }
            } while (!fErrorProcessed);
        }

        ASSERT(dwLen <= cbLen);
        cbLen -= dwLen;
        dwOffset += dwLen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\locks.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    locks

Abstract:

    This module provides the implementations of the lock objects used in Calais.

Author:

    Doug Barlow (dbarlow) 6/2/1998

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdarg.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <calcom.h>

//
//==============================================================================
//
//  CAccessLock
//

/*++

CONSTRUCTOR:

    A CAccessLock provides a multiple-reader, single writer lock on a structure.

Arguments:

    dwTimeout supplies a reasonable timeout value for any lock.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::CAccessLock")

CAccessLock::CAccessLock(
    DWORD dwTimeout)
    :   m_csLock(CSID_ACCESSCONTROL),
    m_hSignalNoReaders(DBGT("CAccessLock No Readers Event")),
    m_hSignalNoWriters(DBGT("CAccessLock No Writers Event"))
#ifdef DBG
        , m_rgdwReaders()
#endif
{
    m_hSignalNoReaders = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hSignalNoReaders.IsValid())
    {
        DWORD dwSts = m_hSignalNoReaders.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot create the No Readers signal:  %1"),
            dwSts);
        throw dwSts; // Force a shutdown.
    }
    m_hSignalNoWriters = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hSignalNoWriters.IsValid())
    {
        DWORD dwSts = m_hSignalNoWriters.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot create the No Writers signal:  %1"),
            dwSts);
        throw dwSts; // Force a shutdown.
    }
    m_dwOwner = 0;
    m_dwReadCount = m_dwWriteCount = 0;
    m_dwTimeout = dwTimeout;
}


/*++

DESTRUCTOR:

    This cleans up after a CAccessLock.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::~CAccessLock")

CAccessLock::~CAccessLock()
{
    if (InitFailed())
        return;

    {
        CLockWrite rwLock(this);
        m_csLock.Enter(
            __SUBROUTINE__,
            DBGT("Closing down the CAccessLock"));
    }
#ifdef DBG
    {
        ASSERT(0 == m_dwReadCount);
        for (DWORD ix = m_rgdwReaders.Count(); ix > 0;)
        {
            ix -= 1;
            ASSERT(0 == m_rgdwReaders[ix]);
        }
    }
#endif
    if (m_hSignalNoReaders.IsValid())
        m_hSignalNoReaders.Close();
    if (m_hSignalNoWriters.IsValid())
        m_hSignalNoWriters.Close();
}


/*++

Wait:

    Wait for the usage signal to trigger.

Arguments:

    hSignal supplies the handle to use for the wait.

Return Value:

    None

Throws:

    None

Remarks:

    This routine blocks until the usage signal fires.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::Wait")

void
CAccessLock::Wait(
    HANDLE hSignal)
{
    WaitForever(
        hSignal,
        m_dwTimeout,
        DBGT("Waiting for Read/Write Lock signal (owner %2): %1"),
        m_dwOwner);
}


/*++

Signal:

    This routine signals the usage signal that the structure is available.

Arguments:

    hSignal supplies the handle to be signaled.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::Signal")

void
CAccessLock::Signal(
    HANDLE hSignal)
{
    if (!SetEvent(hSignal))
    {
        DWORD dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot set its signal:  %1"),
            dwSts);
        throw dwSts;
    }
}


/*++

Unsignal:

    This method is used to notify other threads that the lock has been taken.

Arguments:

    hSignal supplies the handle to be reset.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::Unsignal")

void
CAccessLock::Unsignal(
    HANDLE hSignal)
{
    if (!ResetEvent(hSignal))
    {
        DWORD dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot reset its signal:  %1"),
            dwSts);
        throw dwSts;
    }
}


#ifdef DBG
/*
    Trivial Internal consistency check routines.
*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::NotReadLocked")

BOOL
CAccessLock::NotReadLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock State"));
    BOOL fReturn = TRUE;

    for (DWORD ix = m_rgdwReaders.Count(); ix > 0;)
    {
        ix -= 1;
        if (GetCurrentThreadId() == m_rgdwReaders[ix])
        {
            fReturn = FALSE;
            break;
        }
    }
    return fReturn;
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::IsReadLocked")

BOOL
CAccessLock::IsReadLocked(
    void)
{
    return !NotReadLocked();
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::NotWriteLocked")

BOOL
CAccessLock::NotWriteLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock state"));
    return (GetCurrentThreadId() != m_dwOwner);
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::IsWriteLocked")

BOOL
CAccessLock::IsWriteLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock state"));
    return (GetCurrentThreadId() == m_dwOwner);
}
#endif


//
//==============================================================================
//
//  CLockRead
//

/*++

CONSTRUCTOR:

    This is the constructor for a CLockRead object.  The existence of this
    object forms a sharable read lock on the supplied CAccessLock object.

Arguments:

    pLock supplies the CAccessLock object against which a read request is to
        be posted.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockRead::CLockRead")

CLockRead::CLockRead(
    CAccessLock *pLock)
{
    m_pLock = pLock;


    //
    // Quick check to see if we're already a writer.
    //

    {
        LockSection(&m_pLock->m_csLock, DBGT("Make sure we're not the writer"));
        if (m_pLock->m_dwOwner == GetCurrentThreadId())
        {
            ASSERT(0 < m_pLock->m_dwWriteCount);
            m_pLock->m_dwReadCount += 1;
            ASSERT(0 < m_pLock->m_dwReadCount);
#ifdef DBG
            DWORD dwCurrentThread = GetCurrentThreadId();
            for (DWORD ix = 0; 0 != m_pLock->m_rgdwReaders[ix]; ix += 1);
                // Empty loop body
            m_pLock->m_rgdwReaders.Set(ix, dwCurrentThread);
#endif
            m_pLock->UnsignalNoReaders();
            return;
        }
    }


    //
    // We're not a writer.  Acquire the read lock.
    //

    for (;;)
    {
        m_pLock->WaitOnWriters();
        {
            LockSection(&m_pLock->m_csLock, DBGT("Get the read lock"));
            if ((0 == m_pLock->m_dwWriteCount)
                || (m_pLock->m_dwOwner == GetCurrentThreadId()))
            {
                m_pLock->m_dwReadCount += 1;
                ASSERT(0 < m_pLock->m_dwReadCount);
#ifdef DBG
                DWORD dwCurrentThread = GetCurrentThreadId();
                for (DWORD ix = 0; 0 != m_pLock->m_rgdwReaders[ix]; ix += 1);
                    // Empty loop body
                m_pLock->m_rgdwReaders.Set(ix, dwCurrentThread);
#endif
                m_pLock->UnsignalNoReaders();
                break;
            }
        }
    }
}


/*++

DESTRUCTOR:

    The CLockRead destructor frees the outstanding read lock on the CAccessLock
    object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockRead::~CLockRead")

CLockRead::~CLockRead()
{
    if (InitFailed())
        return;

    LockSection(&m_pLock->m_csLock, DBGT("Releasing the read lock"));
    ASSERT(0 < m_pLock->m_dwReadCount);
    m_pLock->m_dwReadCount -= 1;
#ifdef DBG
    DWORD dwCurrentThread = GetCurrentThreadId();
    for (DWORD ix = m_pLock->m_rgdwReaders.Count(); ix > 0;)
    {
        ix -= 1;
        if (dwCurrentThread == m_pLock->m_rgdwReaders[ix])
        {
            m_pLock->m_rgdwReaders.Set(ix, 0);
            break;
        }
        ASSERT(0 < ix);
    }
#endif
    if (0 == m_pLock->m_dwReadCount)
        m_pLock->SignalNoReaders();
}


//
//==============================================================================
//
//  CLockWrite
//

/*++

CONSTRUCTOR:

    This is the constructor for a CLockWrite object.  The existence of this
    object forms a unshared write lock on the supplied CAccessLock object.

Arguments:

    pLock supplies the CAccessLock object against which a write request is to
        be posted.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockWrite::CLockWrite")

CLockWrite::CLockWrite(
    CAccessLock *pLock)
{
    m_pLock = pLock;


    //
    // Quick check to see if we're already a writer.
    //

    {
        LockSection(&m_pLock->m_csLock, DBGT("See if we're already a writer"));
        if (m_pLock->m_dwOwner == GetCurrentThreadId())
        {
            ASSERT(0 < m_pLock->m_dwWriteCount);
            m_pLock->m_dwWriteCount += 1;
            return;
        }
    }


    //
    // We're not a writer.  Acquire the write lock.
    //

    for (;;)
    {
        m_pLock->WaitOnWriters();
        {
            LockSection(&m_pLock->m_csLock, DBGT("Get the Write lock"));
            if (0 == m_pLock->m_dwWriteCount)
            {
                ASSERT(m_pLock->NotReadLocked());
                ASSERT(0 == m_pLock->m_dwOwner);
                m_pLock->m_dwWriteCount += 1;
                m_pLock->m_dwOwner = GetCurrentThreadId();
                m_pLock->UnsignalNoWriters();
                break;
            }
        }
    }

    for (;;)
    {
        m_pLock->WaitOnReaders();
        {
            LockSection(&m_pLock->m_csLock, DBGT("See if we got the read lock"));
            if (0 == m_pLock->m_dwReadCount)
                break;
#ifdef DBG
            else
            {
                DWORD dwIndex;
                for (dwIndex = m_pLock->m_rgdwReaders.Count(); dwIndex > 0;)
                {
                     dwIndex -= 1;
                    if (0 != m_pLock->m_rgdwReaders[dwIndex])
                        break;
                    ASSERT(0 < dwIndex); // No one will ever respond!
                }
            }
#endif
        }
    }
}


/*++

DESTRUCTOR:

    The CLockWrite destructor frees the outstanding write lock on the
    CAccessLock object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockWrite::~CLockWrite")

CLockWrite::~CLockWrite()
{
    if (InitFailed())
        return;

    LockSection(&m_pLock->m_csLock, DBGT("Releasing the write lock"));
    ASSERT(0 == m_pLock->m_dwReadCount);
    ASSERT(0 < m_pLock->m_dwWriteCount);
    ASSERT(m_pLock->m_dwOwner == GetCurrentThreadId());
    m_pLock->m_dwWriteCount -= 1;
    if (0 == m_pLock->m_dwWriteCount)
    {
        m_pLock->m_dwOwner = 0;
        m_pLock->SignalNoWriters();
    }
}


//
//==============================================================================
//
//  CMutex
//

/*++

CONSTRUCTOR:

    The constructor for a CMutex object.  A CMutex allows threads to synchronize
    on it.  It differs from a regular mutex in that it is possible for one
    thread to take this mutex away from another thread.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::CMutex")

CMutex::CMutex(
    void)
:   m_csAccessLock(CSID_MUTEX),
    m_hAvailableEvent(DBGT("CMutex Availability event"))

{
    m_dwOwnerThreadId = 0;
    m_dwGrabCount = 0;
    m_dwValidityCount = 0;
    m_hAvailableEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    if (!m_hAvailableEvent.IsValid())
    {
        DWORD dwErr = m_hAvailableEvent.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Mutex Object cannot create its signal:  %1"),
            dwErr);
    }
}


/*++

DESTRUCTOR:

    This cleans up the mutex object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::~CMutex")

CMutex::~CMutex()
{
    if (InitFailed())
        return;

    Invalidate();
    if (m_hAvailableEvent.IsValid())
        m_hAvailableEvent.Close();
}


/*++

Grab:

    Get a hold of the Mutex, blocking other threads that also need it.

Arguments:

    None

Return Value:

    none

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Grab")

void
CMutex::Grab(
    void)
{
    DWORD dwValid;

    {
        LockSection(&m_csAccessLock, DBGT("See if we have the mutex already"));
        if (GetCurrentThreadId() == m_dwOwnerThreadId)
        {
            ASSERT(0 < m_dwGrabCount);
            m_dwGrabCount += 1;
            return;
        }
        dwValid = m_dwValidityCount;
    }
    WaitForever(
        m_hAvailableEvent,
        REASONABLE_TIME,
        DBGT("Waiting to grab CMutex (owner %2): %1"),
        m_dwOwnerThreadId);
    LockSection(&m_csAccessLock, DBGT("Grab the Mutex"));
    if (dwValid == m_dwValidityCount)
    {
        ASSERT(0 == m_dwGrabCount);
        ASSERT(0 == m_dwOwnerThreadId);
        m_dwOwnerThreadId = GetCurrentThreadId();
        m_dwGrabCount = 1;
    }
    else
    {
        if (!SetEvent(m_hAvailableEvent))
        {
            DWORD dwErr = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Mutex Object cannot set its signal:  %1"),
                dwErr);
            throw dwErr;
        }
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Attempt to grab reader a failed -- grab invalidated"));
        throw (DWORD)SCARD_E_READER_UNAVAILABLE; // ?SCARD_E_SYSTEM_CANCELLED?
    }
}


/*++

Share:

    This method is called when the owning thread no longer requires the mutex.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Share")

BOOL
CMutex::Share(
    void)
{
    BOOL fRtn = FALSE;

    LockSection(&m_csAccessLock, DBGT("Release the mutex"));
    if (m_dwOwnerThreadId == GetCurrentThreadId())
    {
        ASSERT(0 < m_dwGrabCount);
        m_dwGrabCount -= 1;
        if (0 == m_dwGrabCount)
        {
            m_dwOwnerThreadId = 0;
            if (!SetEvent(m_hAvailableEvent))
            {
                DWORD dwErr = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Mutex Object cannot set its signal:  %1"),
                    dwErr);
            }
        }
        fRtn = TRUE;
    }

    return fRtn;
}


/*++

Invalidate:

    This method causes any owning thread to lose the mutex, making it available
    for others.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    This routine waits until it can access the originally supplied HANDLE before
    stealing the mutex.  That way, the owning thread can make critical areas
    where the mutex is guaranteed to not be taken away.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Invalidate")

void
CMutex::Invalidate(
    void)
{
    LockSection(&m_csAccessLock, DBGT("Invalidate any outstanding grabs"));
    m_dwValidityCount += 1;
    m_dwOwnerThreadId = 0;
    m_dwGrabCount = 0;
    if (!SetEvent(m_hAvailableEvent))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Mutex Object cannot set its signal:  %1"),
            GetLastError());
    }
}


/*++

Take:

    This method causes any owning thread to lose the mutex, reassigning the
    mutex to the current calling thread.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    This routine waits until it can access the originally supplied HANDLE before
    stealing the mutex.  That way, the owning thread can make critical areas
    where the mutex is guaranteed to not be taken away.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Take")

void
CMutex::Take(
    void)
{
    LockSection(&m_csAccessLock, DBGT("Take the mutex"));
    if (!ResetEvent(m_hAvailableEvent))
    {
        DWORD dwErr = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Mutex Object cannot reset its signal:  %1"),
            dwErr);
    }
    m_dwValidityCount += 1;
    m_dwOwnerThreadId = GetCurrentThreadId();
    m_dwGrabCount = 1;
}


/*++
    Simple state checking services
--*/

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::IsGrabbed")
BOOL
CMutex::IsGrabbed(
    void)
{
    LockSection(&m_csAccessLock, DBGT("Is the mutex owned?"));
    return (m_dwOwnerThreadId != 0);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::IsGrabbedBy")
BOOL
CMutex::IsGrabbedBy(
    DWORD dwThreadId)
{
    LockSection(&m_csAccessLock, DBGT("Check mutex ownership"));
    return (m_dwOwnerThreadId == dwThreadId);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::IsGrabbedByMe")
BOOL
CMutex::IsGrabbedByMe(
    void)
{
    return IsGrabbedBy(GetCurrentThreadId());
}


//
//==============================================================================
//
//  CMultiEvent
//


/*++

CONSTRUCTOR:

    This is the constructor for a CMultiEvent object.  A MultiEvent object is
    used for events that need a single event, but which listeners may not be
    quick to watch for.  It has an array of events, and sets them round robin,
    so that a waiter politely waits for their particular event.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::CMultiEvent")

CMultiEvent::CMultiEvent(
    void)
:   m_csLock(CSID_MULTIEVENT)
{
    for (DWORD ix = 0; ix < sizeof(m_rghEvents) / sizeof(HANDLE); ix += 1)
        m_rghEvents[ix] = NULL;
    for (ix = 0; ix < sizeof(m_rghEvents) / sizeof(HANDLE); ix += 1)
    {
        m_rghEvents[ix] = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == m_rghEvents[ix])
            throw GetLastError();
    }
    m_dwEventIndex = 0;
}


/*++

DESTRUCTOR:

    This method cleans up after a CMultiEvent object is no longer needed.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::~CMultiEvent")

CMultiEvent::~CMultiEvent()
{
    for (DWORD ix = 0; ix < sizeof(m_rghEvents) / sizeof(HANDLE); ix += 1)
    {
        if (NULL != m_rghEvents[ix])
        {
            if (!CloseHandle(m_rghEvents[ix]))
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close MultiEvent handle: %1"),
                    GetLastError());
        }
    }
}


/*++

WaitHandle:

    This method returns the handle of the current event, suitable for waiting
    on.

Arguments:

    None

Return Value:

    The value of the handle which can be waited on.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::WaitHandle")

HANDLE
CMultiEvent::WaitHandle(
    void)
{
    LockSection(&m_csLock, DBGT("Obtaining the current wait handle"));
    return m_rghEvents[m_dwEventIndex];
}


/*++

Signal:

    This method signals the current handle, and moves onto the next handle in
    the array.  This way it can leave the current handle set for a significant
    time period, but still provide new waiters with reason to block.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::Signal")

void
CMultiEvent::Signal(
    void)
{
    LockSection(&m_csLock, DBGT("Signal the current event"));
    if (!SetEvent(m_rghEvents[m_dwEventIndex]))
        throw GetLastError();
    m_dwEventIndex += 1;
    m_dwEventIndex %= sizeof(m_rghEvents) / sizeof(HANDLE);
    if (!ResetEvent(m_rghEvents[m_dwEventIndex]))
        throw GetLastError();
}


/*++

WaitForAnObject:

    This routine performs object waiting services.  It really doesn't have
    anything to do with locking except that there are so many error conditions
    to check for that it's more convenient to have it off in its own routine.

Arguments:

    hWaitOn supplies the handle to wait on.

    dwTimeout supplies the wait timeout value.

Return Value:

    The error code, if any

Throws:

    None

Author:

    Doug Barlow (dbarlow) 6/19/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForAnObject")

DWORD
WaitForAnObject(
    HANDLE hWaitOn,
    DWORD dwTimeout)
{
    DWORD dwReturn = SCARD_S_SUCCESS;
    DWORD dwSts;

    ASSERT(INVALID_HANDLE_VALUE != hWaitOn);
    ASSERT(NULL != hWaitOn);
    dwSts = WaitForSingleObject(hWaitOn, dwTimeout);
    switch (dwSts)
    {
    case WAIT_FAILED:
        dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object failed:  %1"),
            dwSts);
        dwReturn = dwSts;
        break;
    case WAIT_TIMEOUT:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object timed out"));
        dwReturn = SCARD_F_WAITED_TOO_LONG;
        break;
    case WAIT_ABANDONED:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object received wait abandoned"));
        // That's OK, we still got it.
        break;

    case WAIT_OBJECT_0:
        break;

    default:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object got invalid response"));
        dwReturn = SCARD_F_INTERNAL_ERROR;
    }

    return dwReturn;
}


/*++

WaitForObjects:

    This routine is a utility to allow waiting for multiple objects.  It returns
    the index of the object that completed.

Arguments:

    dwTimeout supplies the timeout value, in milliseconds, or INFINITE.

    hObject and following supply the list of objects to wait for.  This list
        must be NULL terminated.

Return Value:

    The number of the object completed.  1 implies the first one, 2 implies the
    second one, etc.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 6/17/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForAnyObject")

DWORD
WaitForAnyObject(
    DWORD dwTimeout,
    ...)
{
    va_list ap;
    HANDLE h, rgh[4];
    DWORD dwIndex = 0, dwWait, dwErr;

    va_start(ap, dwTimeout);
    for (h = va_arg(ap, HANDLE); NULL != h; h = va_arg(ap, HANDLE))
    {
        ASSERT(dwIndex < sizeof(rgh) / sizeof(HANDLE));
        ASSERT(INVALID_HANDLE_VALUE != h);
        if (INVALID_HANDLE_VALUE != h)
            rgh[dwIndex++] = h;
    }
    va_end(ap);

    ASSERT(0 < dwIndex);
    if (0 < dwIndex)
        dwWait = WaitForMultipleObjects(dwIndex, rgh, FALSE, dwTimeout);
    else
    {
        dwWait = WAIT_FAILED;
        SetLastError(ERROR_INVALID_EVENT_COUNT);
        // That's a good symbolic name, but a lousy user message.
    }

    switch (dwWait)
    {
    case WAIT_FAILED:
        dwErr = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("WaitForObjects failed its wait:  %1"),
            dwErr);
        throw dwErr;
        break;

    case WAIT_TIMEOUT:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("WaitForObjects timed out on its wait"));
        throw (DWORD)ERROR_TIMEOUT;
        break;

    default:
        C_ASSERT(WAIT_OBJECT_0 == 0);
        ASSERT(WAIT_OBJECT_0 < WAIT_ABANDONED_0);
        if ((dwWait >= WAIT_ABANDONED_0)
            && (dwWait < (WAIT_ABANDONED_0 + WAIT_ABANDONED_0 - WAIT_OBJECT_0)))
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WaitForObjects received a Wait Abandoned warning"));
            dwIndex = dwWait - WAIT_ABANDONED_0 + 1;
        }
        else if (dwWait < WAIT_ABANDONED_0)
        {
            dwIndex = dwWait - WAIT_OBJECT_0 + 1;
        }
        else
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WaitForObjects received unknown error code: %1"),
                dwWait);
            throw dwWait;
        }
    }

    return dwIndex;
}


#ifdef DBG
//
//  Critical Section Support.
//
//  The following Classes aid in debugging Critical Section Conflicts.
//

static const TCHAR l_szUnowned[] = TEXT("<Unowned>");
static const LPCTSTR l_rgszLockList[]
    = { DBGT("Service Status Critical Section"),        // CSID_SERVICE_STATUS
        DBGT("Lock for Calais control commands."),      // CSID_CONTROL_LOCK
        DBGT("Lock for server thread enumeration."),    // CSID_SERVER_THREADS
        DBGT("MultiEvent Critical Access Section"),     // CSID_MULTIEVENT
        DBGT("Mutex critical access section"),          // CSID_MUTEX
        DBGT("Access Lock control"),                    // CSID_ACCESSCONTROL
        DBGT("Lock for tracing output."),               // CSID_TRACEOUTPUT
        NULL };


//
//==============================================================================
//
//  CCriticalSectionObject
//

/*++

CONSTRUCTOR:

    This method builds the critical section object and coordinates its tracking.

Arguments:

    szDescription supplies a description of what this critical section object
        is used for.  This aids identification.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::CCriticalSectionObject")

CCriticalSectionObject::CCriticalSectionObject(
    DWORD dwCsid)
{
    m_fInitFailed = TRUE;
    try {
        // Preallocate the event used by the EnterCriticalSection
        // function to prevent an exception from being thrown in
        // CCriticalSectionObject::Enter
        if (! InitializeCriticalSectionAndSpinCount(
                &m_csLock, 0x80000000))
            return;
    }
    catch (HRESULT hr) {
        return;
    }

    m_dwCsid = dwCsid;
    m_bfOwner.Set((LPCBYTE)l_szUnowned, sizeof(l_szUnowned));
    m_bfComment.Set((LPCBYTE)DBGT(""), sizeof(TCHAR));
    m_dwOwnerThread = 0;
    m_dwRecursion = 0;
    
    m_fInitFailed = FALSE;
}


/*++

DESTRUCTOR:

    This method cleans up the critical section object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::~CCriticalSectionObject")

CCriticalSectionObject::~CCriticalSectionObject()
{
    if (m_fInitFailed)
        return;

    if (0 == m_dwOwnerThread)
    {
        ASSERT(0 == m_dwRecursion);
    }
    else
    {
        ASSERT(IsOwnedByMe());
        ASSERT(1 == m_dwRecursion);
        LeaveCriticalSection(&m_csLock);
    }
    
    DeleteCriticalSection(&m_csLock);
}


/*++

Enter:

    This method enters a critical section, and tracks the owner.

Arguments:

    szOwner supplies the name of the calling subroutine.

    szComment supplies an additional comment to help distinguish between
        multiple calls within a subroutine.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Enter")

void
CCriticalSectionObject::Enter(
    LPCTSTR szOwner,
    LPCTSTR szComment)
{
    if (m_fInitFailed)
        throw (DWORD)SCARD_E_NO_MEMORY;

    EnterCriticalSection(&m_csLock);
    if (0 == m_dwRecursion)
    {
        ASSERT(0 == m_dwOwnerThread);
        m_dwOwnerThread = GetCurrentThreadId();
        m_bfOwner.Set(
            (LPCBYTE)szOwner,
            (lstrlen(szOwner) + 1) * sizeof(TCHAR));
        m_bfComment.Set(
            (LPCBYTE)szComment,
            (lstrlen(szComment) + 1) * sizeof(TCHAR));
    }
    else
    {
        ASSERT(GetCurrentThreadId() == m_dwOwnerThread);
        CalaisDebug((
            DBGT("Critical Section '%s' already owned by %s (%s)\nCalled from %s (%s)\n"),
            Description(),
            Owner(),
            Comment(),
            szOwner,
            szComment));
    }
    m_dwRecursion += 1;
    ASSERT(0 < m_dwRecursion);
}


/*++

Leave:

    This method exits a critical section.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Leave")

void
CCriticalSectionObject::Leave(
    void)
{
    ASSERT(0 < m_dwRecursion);
    m_dwRecursion -= 1;
    if (0 == m_dwRecursion)
    {
        m_bfOwner.Set((LPCBYTE)l_szUnowned, sizeof(l_szUnowned));
        m_bfComment.Set((LPCBYTE)DBGT(""), sizeof(TCHAR));
        m_dwOwnerThread = 0;
    }
    LeaveCriticalSection(&m_csLock);
}


/*++

Description:

    Translate the Critical Section Id number to a descriptive string.

Arguments:

    None

Return Value:

    The descriptive string corresponding to this critical section type.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Description")

LPCTSTR
CCriticalSectionObject::Description(
    void)
const
{
    return l_rgszLockList[m_dwCsid];
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\comobjs.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    comObjs

Abstract:

    This file provides the implementation for the communcation objects used in
    Calais.  A communications object (CComObject and it's derivatives) is
    capable of transmitting itself across a CComChannel.

Author:

    Doug Barlow (dbarlow) 11/6/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>
#include <limits.h>

//
// Maximum size for the payload of a service request or response.  
//
// Current value is max size of an unsigned WORD, as this is the max 
// card packet size defined by ISO.
//
#define cbMAX_COM_REQUEST_RESPONSE_SIZE     USHRT_MAX

const DWORD
    CComObject::AUTOCOUNT = 0,              // Force computing string length.
    CComObject::MULTISTRING = (DWORD)(-1);  // Force computing multistring len.


//
//==============================================================================
//
//  CComObject and derivatives.
//

/*++

CComObject:

    This is the base constructor for a CComObject.  These objects assume that
    they are not in charge of anything past their own internal buffers.
    Therefore they won't close handles, etc, when destructing.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::CComObject")

CComObject::CComObject(
    void)
:   m_bfRequest(),
    m_bfResponse()
{
    m_pbfActive = NULL;
}


/*++

ReceiveComObject:

    This is a static member routine that creates the proper CComObject child
    object for the data coming in on a CComChannel.

Arguments:

    pChannel supplies a pointer to the CComChannel on which the transfer
        structure will come in.

Return Value:

    The newly created CComObject child object.  This object must be cleaned up
    via the delete command.

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::ReceiveComObject")

CComObject *
CComObject::ReceiveComObject(
    CComChannel *pChannel)
{
    CComObject *pCom = NULL;
    DWORD dwMinSize = (DWORD)(-1);

    try
    {
        DWORD rgdwInData[2];


        //
        // See what's coming.
        //

        pChannel->Receive(rgdwInData, sizeof(rgdwInData));
        if (sizeof(rgdwInData) > rgdwInData[1])
            throw (DWORD)SCARD_F_COMM_ERROR;

        switch (rgdwInData[0])  // dwCommndId
        {
        case EstablishContext_request:
            dwMinSize = sizeof(ComEstablishContext::CObjEstablishContext_request);
            pCom = new ComEstablishContext;
            break;
        case EstablishContext_response:
            dwMinSize = sizeof(ComEstablishContext::CObjEstablishContext_response);
            pCom = new ComEstablishContext;
            break;
        case ReleaseContext_request:
            dwMinSize = sizeof(ComReleaseContext::CObjReleaseContext_request);
            pCom = new ComReleaseContext;
            break;
        case ReleaseContext_response:
            dwMinSize = sizeof(ComReleaseContext::CObjReleaseContext_response);
            pCom = new ComReleaseContext;
            break;
        case IsValidContext_request:
            dwMinSize = sizeof(ComIsValidContext::CObjIsValidContext_request);
            pCom = new ComIsValidContext;
            break;
        case IsValidContext_response:
            dwMinSize = sizeof(ComIsValidContext::CObjIsValidContext_response);
            pCom = new ComIsValidContext;
            break;
        case ListReaders_request:
            dwMinSize = sizeof(ComListReaders::CObjListReaders_request);
            pCom = new ComListReaders;
            break;
        case ListReaders_response:
            dwMinSize = sizeof(ComListReaders::CObjListReaders_response);
            pCom = new ComListReaders;
            break;
#if 0
        case ListReaderGroups_request:
            dwMinSize = sizeof(ComListReaderGroups::CObjListReaderGroups_request);
            pCom = new ComListReaderGroups;
            break;
        case ListReaderGroups_response:
            dwMinSize = sizeof(ComListReaderGroups::CObjListReaderGroups_response);
            pCom = new ComListReaderGroups;
            break;
        case ListCards_request:
            dwMinSize = sizeof(ComListCards::CObjListCards_request);
            pCom = new ComListCards;
            break;
        case ListCards_response:
            dwMinSize = sizeof(ComListCards::CObjListCards_response);
            pCom = new ComListCards;
            break;
        case ListInterfaces_request:
            dwMinSize = sizeof(ComListInterfaces::CObjListInterfaces_request);
            pCom = new ComListInterfaces;
            break;
        case ListInterfaces_response:
            dwMinSize = sizeof(ComListInterfaces::CObjListInterfaces_response);
            pCom = new ComListInterfaces;
            break;
        case GetProviderId_request:
            dwMinSize = sizeof(ComGetProviderId::CObjGetProviderId_request);
            pCom = new ComGetProviderId;
            break;
        case GetProviderId_response:
            dwMinSize = sizeof(ComGetProviderId::CObjGetProviderId_response);
            pCom = new ComGetProviderId;
            break;
        case IntroduceReaderGroup_request:
            dwMinSize = sizeof(ComIntroduceReaderGroup::CObjIntroduceReaderGroup_request);
            pCom = new ComIntroduceReaderGroup;
            break;
        case IntroduceReaderGroup_response:
            dwMinSize = sizeof(ComIntroduceReaderGroup::CObjIntroduceReaderGroup_response);
            pCom = new ComIntroduceReaderGroup;
            break;
        case ForgetReaderGroup_request:
            dwMinSize = sizeof(ComForgetReaderGroup::CObjForgetReaderGroup_request);
            pCom = new ComForgetReaderGroup;
            break;
        case ForgetReaderGroup_response:
            dwMinSize = sizeof(ComForgetReaderGroup::CObjForgetReaderGroup_response);
            pCom = new ComForgetReaderGroup;
            break;
        case IntroduceReader_request:
            dwMinSize = sizeof(ComIntroduceReader::CObjIntroduceReader_request);
            pCom = new ComIntroduceReader;
            break;
        case IntroduceReader_response:
            dwMinSize = sizeof(ComIntroduceReader::CObjIntroduceReader_response);
            pCom = new ComIntroduceReader;
            break;
        case ForgetReader_request:
            dwMinSize = sizeof(ComForgetReader::CObjForgetReader_request);
            pCom = new ComForgetReader;
            break;
        case ForgetReader_response:
            dwMinSize = sizeof(ComForgetReader::CObjForgetReader_response);
            pCom = new ComForgetReader;
            break;
        case AddReaderToGroup_request:
            dwMinSize = sizeof(ComAddReaderToGroup::CObjAddReaderToGroup_request);
            pCom = new ComAddReaderToGroup;
            break;
        case AddReaderToGroup_response:
            dwMinSize = sizeof(ComAddReaderToGroup::CObjAddReaderToGroup_response);
            pCom = new ComAddReaderToGroup;
            break;
        case RemoveReaderFromGroup_request:
            dwMinSize = sizeof(ComRemoveReaderFromGroup::CObjRemoveReaderFromGroup_request);
            pCom = new ComRemoveReaderFromGroup;
            break;
        case RemoveReaderFromGroup_response:
            dwMinSize = sizeof(ComRemoveReaderFromGroup::CObjRemoveReaderFromGroup_response);
            pCom = new ComRemoveReaderFromGroup;
            break;
        case IntroduceCardType_request:
            dwMinSize = sizeof(ComIntroduceCardType::CObjIntroduceCardType_request);
            pCom = new ComIntroduceCardType;
            break;
        case IntroduceCardType_response:
            dwMinSize = sizeof(ComIntroduceCardType::CObjIntroduceCardType_response);
            pCom = new ComIntroduceCardType;
            break;
        case ForgetCardType_request:
            dwMinSize = sizeof(ComForgetCardType::CObjForgetCardType_request);
            pCom = new ComForgetCardType;
            break;
        case ForgetCardType_response:
            dwMinSize = sizeof(ComForgetCardType::CObjForgetCardType_response);
            pCom = new ComForgetCardType;
            break;
        case FreeMemory_request:
            dwMinSize = sizeof(ComFreeMemory::CObjFreeMemory_request);
            pCom = new ComFreeMemory;
            break;
        case FreeMemory_response:
            dwMinSize = sizeof(ComFreeMemory::CObjFreeMemory_response);
            pCom = new ComFreeMemory;
            break;
        case Cancel_request:
            dwMinSize = sizeof(ComCancel::CObjCancel_request);
            pCom = new ComCancel;
            break;
        case Cancel_response:
            dwMinSize = sizeof(ComCancel::CObjCancel_response);
            pCom = new ComCancel;
            break;
#endif
        case LocateCards_request:
            dwMinSize = sizeof(ComLocateCards::CObjLocateCards_request);
            pCom = new ComLocateCards;
            break;
        case LocateCards_response:
            dwMinSize = sizeof(ComLocateCards::CObjLocateCards_response);
            pCom = new ComLocateCards;
            break;
        case GetStatusChange_request:
            dwMinSize = sizeof(ComGetStatusChange::CObjGetStatusChange_request);
            pCom = new ComGetStatusChange;
            break;
        case GetStatusChange_response:
            dwMinSize = sizeof(ComGetStatusChange::CObjGetStatusChange_response);
            pCom = new ComGetStatusChange;
            break;
        case Connect_request:
            dwMinSize = sizeof(ComConnect::CObjConnect_request);
            pCom = new ComConnect;
            break;
        case Connect_response:
            dwMinSize = sizeof(ComConnect::CObjConnect_response);
            pCom = new ComConnect;
            break;
        case Reconnect_request:
            dwMinSize = sizeof(ComReconnect::CObjReconnect_request);
            pCom = new ComReconnect;
            break;
        case Reconnect_response:
            dwMinSize = sizeof(ComReconnect::CObjReconnect_response);
            pCom = new ComReconnect;
            break;
        case Disconnect_request:
            dwMinSize = sizeof(ComDisconnect::CObjDisconnect_request);
            pCom = new ComDisconnect;
            break;
        case Disconnect_response:
            dwMinSize = sizeof(ComDisconnect::CObjDisconnect_response);
            pCom = new ComDisconnect;
            break;
        case BeginTransaction_request:
            dwMinSize = sizeof(ComBeginTransaction::CObjBeginTransaction_request);
            pCom = new ComBeginTransaction;
            break;
        case BeginTransaction_response:
            dwMinSize = sizeof(ComBeginTransaction::CObjBeginTransaction_response);
            pCom = new ComBeginTransaction;
            break;
        case EndTransaction_request:
            dwMinSize = sizeof(ComEndTransaction::CObjEndTransaction_request);
            pCom = new ComEndTransaction;
            break;
        case EndTransaction_response:
            dwMinSize = sizeof(ComEndTransaction::CObjEndTransaction_response);
            pCom = new ComEndTransaction;
            break;
        case Status_request:
            dwMinSize = sizeof(ComStatus::CObjStatus_request);
            pCom = new ComStatus;
            break;
        case Status_response:
            dwMinSize = sizeof(ComStatus::CObjStatus_response);
            pCom = new ComStatus;
            break;
        case Transmit_request:
            dwMinSize = sizeof(ComTransmit::CObjTransmit_request);
            pCom = new ComTransmit;
            break;
        case Transmit_response:
            dwMinSize = sizeof(ComTransmit::CObjTransmit_response);
            pCom = new ComTransmit;
            break;
        case OpenReader_request:
            dwMinSize = sizeof(ComOpenReader::CObjOpenReader_request);
            pCom = new ComOpenReader;
            break;
        case OpenReader_response:
            dwMinSize = sizeof(ComOpenReader::CObjOpenReader_response);
            pCom = new ComOpenReader;
            break;
        case Control_request:
            dwMinSize = sizeof(ComControl::CObjControl_request);
            pCom = new ComControl;
            break;
        case Control_response:
            dwMinSize = sizeof(ComControl::CObjControl_response);
            pCom = new ComControl;
            break;
        case GetAttrib_request:
            dwMinSize = sizeof(ComGetAttrib::CObjGetAttrib_request);
            pCom = new ComGetAttrib;
            break;
        case GetAttrib_response:
            dwMinSize = sizeof(ComGetAttrib::CObjGetAttrib_response);
            pCom = new ComGetAttrib;
            break;
        case SetAttrib_request:
            dwMinSize = sizeof(ComSetAttrib::CObjSetAttrib_request);
            pCom = new ComSetAttrib;
            break;
        case SetAttrib_response:
            dwMinSize = sizeof(ComSetAttrib::CObjSetAttrib_response);
            pCom = new ComSetAttrib;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Invalid Comm Object Id on pipe"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }

        if (NULL == pCom)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("No memory for incoming comm object"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }
        if (dwMinSize > rgdwInData[1])
            throw (DWORD)SCARD_F_COMM_ERROR;
        if (0 == (rgdwInData[0] & 0x01))    // Request or response?
            pCom->m_pbfActive = &pCom->m_bfRequest;
        else
            pCom->m_pbfActive = &pCom->m_bfResponse;


        //
        // Pull it in.
        //

        if (cbMAX_COM_REQUEST_RESPONSE_SIZE < rgdwInData[1])
            throw (DWORD) SCARD_E_INVALID_PARAMETER;   

        pCom->m_pbfActive->Resize(rgdwInData[1]);
        CopyMemory(
            pCom->m_pbfActive->Access(),
            rgdwInData,
            sizeof(rgdwInData));
        pChannel->Receive(
            pCom->m_pbfActive->Access(sizeof(rgdwInData)),
            rgdwInData[1] - sizeof(rgdwInData));
#ifdef DBG
        WriteApiLog(pCom->m_pbfActive->Access(), pCom->m_pbfActive->Length());
        for (DWORD ix = 0; ix < rgdwInData[1] / sizeof(DWORD); ix += 1)
        {
            ASSERT(0xcdcdcdcd != *(LPDWORD)pCom->m_pbfActive->Access(
                                                    ix * sizeof(DWORD)));
        }
#endif
    }

    catch (...)
    {
        if (NULL != pCom)
            delete pCom;
        throw;
    }

    return pCom;
}


/*++

Receive:

    This function receives a specific com object.

Arguments:

    pChannel supplies a pointer to the CComChannel on which the transfer
        structure will come in.

Return Value:

    None

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/18/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Receive")

CComObject::CObjGeneric_response *
CComObject::Receive(
    CComChannel *pChannel)
{
    DWORD rgdwInData[2];
    CComObject::CObjGeneric_response *pRsp
        = (CComObject::CObjGeneric_response *)Data();

    pChannel->Receive(rgdwInData, sizeof(rgdwInData));
    if (rgdwInData[0] != pRsp->dwCommandId)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Comm Object receive object mismatch"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    if (rgdwInData[1] < sizeof(CComObject::CObjGeneric_response))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Comm Object receive object invalid"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    ASSERT(m_pbfActive == ((0 == (rgdwInData[0] & 0x01)
                            ? &m_bfRequest
                            : &m_bfResponse)));


    //
    // Pull it in.
    //

    m_pbfActive->Resize(rgdwInData[1]);
    CopyMemory(
        m_pbfActive->Access(),
        rgdwInData,
        sizeof(rgdwInData));
    pChannel->Receive(
        m_pbfActive->Access(sizeof(rgdwInData)),
        rgdwInData[1] - sizeof(rgdwInData));
#ifdef DBG
    for (DWORD ix = 0; ix < rgdwInData[1] / sizeof(DWORD); ix += 1)
    {
        ASSERT(0xcdcdcdcd != *(LPDWORD)m_pbfActive->Access(ix * sizeof(DWORD)));
    }
    WriteApiLog(m_pbfActive->Access(), m_pbfActive->Length());
#endif
    return (CComObject::CObjGeneric_response *)m_pbfActive->Access();
}


/*++

Send:

    This function sends the ComObject over the given Comm Channel.

Arguments:

    pChannel supplies a pointer to the CComChannel on which the transfer
        structure will be sent.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/5/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Send")

DWORD
CComObject::Send(
    CComChannel *pChannel)
{
#ifdef DBG
    ComObjCheck;
    WriteApiLog(Data(), Length());
#endif
    return pChannel->Send(Data(), Length());
}


/*++

InitStruct:

    This method implements simple base class preparation to build request and
    response structures.

Arguments:

    dwCommandId supplies the command identifier.
    dwDataOffset supplies the size of the structure to be inserted.

Return Value:

    None

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::InitStruct")

void
CComObject::InitStruct(
    DWORD dwCommandId,
    DWORD dwDataOffset,
    DWORD dwExtra)
{
    if (0 == (dwCommandId & 0x01))
        m_pbfActive = &m_bfRequest;
    else
        m_pbfActive = &m_bfResponse;
    ASSERT(NULL != m_pbfActive);
    ASSERT(0 == dwDataOffset % sizeof(DWORD));
    CObjGeneric_request *pReq =
        (CObjGeneric_request *)m_pbfActive->Presize(dwDataOffset + dwExtra);
    m_pbfActive->Resize(dwDataOffset, TRUE);
    pReq->dwCommandId = dwCommandId;
    pReq->dwTotalLength = dwDataOffset;
    pReq->dwDataOffset = dwDataOffset;
}


/*++

Append:

    These methods append data to the transfer structure, updating the Total
    Length.  Note that this action may affect the address of the structure being
    appended to.  This routine returns the address of that structure, in case it
    changes.

Arguments:

    dsc supplies the descriptor to fill in with the offset and length.

    szString supplies the data to be appended as a string value.

    cchLen supplies the length of the data to be appended in characters, or one
        of the following special flags:

        AUTOCOUNT - The string's size should be determined via lstrlen.

        MULTISTRING - The string's size should be determined via mstrlen;

Return Value:

    The address of the updated structure, which may have moved in memory.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Append")

LPBYTE
CComObject::Append(
    CComObject::Desc &dsc,
    LPCTSTR szString,
    DWORD cchLen)
{
    DWORD dwLen;
    switch (cchLen)
    {
    case AUTOCOUNT:
        dwLen = lstrlen(szString) + 1;  // Include trailing null char.
        break;
    case MULTISTRING:
        dwLen = MStrLen(szString);      // It includes trailing null char.
        break;
    default:
        dwLen = cchLen;
    }
    dwLen *= sizeof(TCHAR);
    return Append(dsc, (LPCBYTE)szString, dwLen);
}

LPBYTE
CComObject::Append(
    CComObject::Desc &dsc,
    LPCBYTE pbData,
    DWORD cbLength)
{
    static const DWORD dwZero = 0;
    DWORD
        dwDataLength,
        dwPadLen;
    CObjGeneric_request *pData;

    ComObjCheck;

    dwPadLen = sizeof(DWORD) - cbLength % sizeof(DWORD);
    if (sizeof(DWORD) == dwPadLen)
        dwPadLen = 0;
    dwDataLength = m_pbfActive->Length() + cbLength + dwPadLen;
    dsc.dwOffset = m_pbfActive->Length();
    dsc.dwLength = cbLength;

    // Now we might change the address of dsc.
    m_pbfActive->Presize(dwDataLength, TRUE);
    m_pbfActive->Append(pbData, cbLength);
    m_pbfActive->Append((LPCBYTE)&dwZero, dwPadLen);
    pData = (CObjGeneric_request *)m_pbfActive->Access();
    pData->dwTotalLength = dwDataLength;
    return m_pbfActive->Access();
}


/*++

Parse:

    This routine converts a given descriptor in the current communications
    object buffer back into a pointer and optional length.

Arguments:

    dsc supplies the descriptor of the current communications object to be
        parsed.
    pcbLen receives the length, in bytes, of the value referenced by the
        descriptor.  If this parameter is NULL, no length value is returned.

Return Value:

    The address of the value referenced by the descriptor.

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 12/11/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Parse")

LPCVOID
CComObject::Parse(
    Desc &dsc,
    LPDWORD pcbLen)
{
    CObjGeneric_request *pGen;

    ComObjCheck;
    pGen = (CObjGeneric_request *)m_pbfActive->Access();

    ASSERT((LPCVOID)&dsc > (LPCVOID)m_pbfActive->Access());
    ASSERT((LPCVOID)&dsc
           < (LPCVOID)m_pbfActive->Access(m_pbfActive->Length() - 1));
    ASSERT((LPCVOID)&dsc
           < (LPCVOID)m_pbfActive->Access(pGen->dwDataOffset - 1));

    if (dsc.dwOffset + dsc.dwLength > m_pbfActive->Length())
        throw (DWORD)SCARD_F_COMM_ERROR;
    if (NULL != pcbLen)
        *pcbLen = dsc.dwLength;
    return m_pbfActive->Access(dsc.dwOffset);
}


#ifdef DBG
/*++

dbgCheck:

    This routine validates the internal structure of a CComObject.

Arguments:

    None

Return Value:

    None

Throws:

    None, but it will assert if something is wrong.

Author:

    Doug Barlow (dbarlow) 12/11/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::dbgCheck")

void
CComObject::dbgCheck(
    void)
const
{
    DWORD
        dwCommandId,
        dwDataLength,
        dwDataOffset;
    CObjGeneric_request *pData;

    ASSERT(EstablishContext_request == 0);
    ASSERT(NULL != m_pbfActive);
    ASSERT(3 * sizeof(DWORD) <= m_pbfActive->Length());
    pData = (CObjGeneric_request *)m_pbfActive->Access();
    dwCommandId = pData->dwCommandId;
    dwDataLength = pData->dwTotalLength;
    dwDataOffset = pData->dwDataOffset;
    ASSERT(dwDataLength == m_pbfActive->Length());
    ASSERT(dwDataOffset <= dwDataLength);
    ASSERT(0 == dwDataOffset % sizeof(DWORD));
    ASSERT(0 == dwDataLength % sizeof(DWORD));
    ASSERT(m_pbfActive
            == ((0 == (dwCommandId & 0x01))
                ? &m_bfRequest
                : &m_bfResponse));
}

typedef struct
{
    SYSTEMTIME stLogTime;
    DWORD dwProcId;
    DWORD dwThreadId;
} LogStamp;

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WriteApiLog")
void
WriteApiLog(
    LPCVOID pvData,
    DWORD cbLength)
{
    static HANDLE hLogMutex = NULL;
    BOOL fGotMutex = FALSE;
    HANDLE hLogFile = INVALID_HANDLE_VALUE;

    try
    {
        hLogFile = CreateFile(
                        CalaisString(CALSTR_APITRACEFILENAME),
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        if (INVALID_HANDLE_VALUE != hLogFile)
        {
            LogStamp stamp;
            DWORD dwLen;
            DWORD dwSts;
            BOOL fSts;

            if (NULL == hLogMutex)
            {
                CSecurityDescriptor acl;

                acl.Initialize();
                acl.Allow(
                    &acl.SID_World,
                    SEMAPHORE_ALL_ACCESS);
                hLogMutex = CreateMutex(
                                acl,
                                FALSE,
                                TEXT("Microsoft Smart Card Logging synchronization"));
            }

            dwSts = WaitForAnObject(hLogMutex, 1000);  // One second max.
            if (ERROR_SUCCESS == dwSts)
            {
                fGotMutex = TRUE;
                dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
                ASSERT(-1 != dwLen);
                GetLocalTime(&stamp.stLogTime);
                stamp.dwProcId = GetCurrentProcessId();
                stamp.dwThreadId = GetCurrentThreadId();
                fSts = WriteFile(
                    hLogFile,
                    &stamp,
                    sizeof(stamp),
                    &dwLen,
                    NULL);
                ASSERT(fSts);
                fSts = WriteFile(
                    hLogFile,
                    pvData,
                    cbLength,
                    &dwLen,
                    NULL);
                ASSERT(fSts);
                ASSERT(dwLen == cbLength);
            }
        }
    }
    catch (...) {}

    if (fGotMutex)
        ReleaseMutex(hLogMutex);
    if (INVALID_HANDLE_VALUE != hLogFile)
        CloseHandle(hLogFile);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\scevents.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scEvents

Abstract:

    This module provides access to the Calais subsystem internal events.
    Currently two events are defined:

    Microsoft Smart Card Resource Manager Started - This event is set when the
        resource manager starts up.

    Microsoft Smart Card Resource Manager New Reader - This event is set when
        the resource manager adds a new reader via Plug 'n Play.

Author:

    Doug Barlow (dbarlow) 7/1/1998

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <winscard.h>
#include <CalMsgs.h>
#include <calcom.h>

static HANDLE
    l_hStartedEvent = NULL,
    l_hNewReaderEvent = NULL,
    l_hStoppedEvent = NULL;


/*++

AccessStartedEvent:

    This function obtains a local handle to the Calais Resource Manager Start
    event.  The handle must be released via the ReleaseStartedEvent
    service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessStartedEvent")

HANDLE
AccessStartedEvent(
    void)
{
    if (NULL == l_hStartedEvent)
    {
        try
        {
            CSecurityDescriptor acl;
            acl.Initialize();
            acl.Allow(
                &acl.SID_LocalService,
                EVENT_ALL_ACCESS);
            acl.Allow(
                &acl.SID_Interactive,
                SYNCHRONIZE);
            acl.Allow(
                &acl.SID_System,
                SYNCHRONIZE);
            l_hStartedEvent =
                CreateEvent(
                    acl,        // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    CalaisString(CALSTR_STARTEDEVENTNAME)); // event-object name
            if (NULL == l_hStartedEvent)
            {
                l_hStartedEvent = OpenEvent(SYNCHRONIZE, FALSE, CalaisString(CALSTR_STARTEDEVENTNAME));
            }
        }
        catch (...)
        {
            ASSERT(NULL == l_hStartedEvent);
        }
    }
    return l_hStartedEvent;
}



/*++

AccessStoppedEvent:

    This function obtains a local handle to the Calais Resource Manager Stopped
    event.  

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:


--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessStoppedEvent")

HANDLE
AccessStoppedEvent(
    void)
{
    if (NULL == l_hStoppedEvent)
    {
        try
        {
            CSecurityDescriptor acl;
            acl.Initialize();
            acl.Allow(
                &acl.SID_LocalService,
                EVENT_ALL_ACCESS);
            acl.Allow(
                &acl.SID_Interactive,
                SYNCHRONIZE);
            acl.Allow(
                &acl.SID_System,
                SYNCHRONIZE);
            l_hStoppedEvent =
                CreateEvent(
                    acl,        // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    CalaisString(CALSTR_STOPPEDEVENTNAME)); // event-object name
            if (NULL == l_hStoppedEvent)
            {
                l_hStoppedEvent = OpenEvent(SYNCHRONIZE, FALSE, CalaisString(CALSTR_STOPPEDEVENTNAME));
            }
        }
        catch (...)
        {
            ASSERT(NULL == l_hStoppedEvent);
        }
    }
    return l_hStoppedEvent;
}



/*++

AccessNewReaderEvent:

    This function obtains a local handle to the Calais Resource Manager's New
    Reader event.  The handle must be released via the
    ReleaseNewReaderEvent service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessNewReaderEvent")

HANDLE
AccessNewReaderEvent(
    void)
{
    if (NULL == l_hNewReaderEvent)
    {
        try
        {
            CSecurityDescriptor acl;
            acl.Initialize();
            acl.Allow(
                &acl.SID_LocalService,
                EVENT_ALL_ACCESS);
            acl.Allow(
                &acl.SID_Interactive,
                SYNCHRONIZE);
            acl.Allow(
                &acl.SID_System,
                SYNCHRONIZE);
            l_hNewReaderEvent
                = CreateEvent(
                    acl,        // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    CalaisString(CALSTR_NEWREADEREVENTNAME)); // pointer to event-object name
        }
        catch (...)
        {
            ASSERT(NULL == l_hNewReaderEvent);
        }

    }
    return l_hNewReaderEvent;
}



/*++

ReleaseStartedEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager Start event.  The handle must be obtained via the
    AccessStartedEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseStartedEvent")

void
ReleaseStartedEvent(
    void)
{
    if (NULL != l_hStartedEvent)
    {
        CloseHandle(l_hStartedEvent);
        l_hStartedEvent = NULL;
    }
}


/*++

ReleaseStoppedEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager Stopped event.  The handle must be obtained via the
    AccessStoppedEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.


--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseStoppedEvent")

void
ReleaseStoppedEvent(
    void)
{
    if (NULL != l_hStoppedEvent)
    {
        CloseHandle(l_hStoppedEvent);
        l_hStoppedEvent = NULL;
    }
}


/*++

ReleaseNewReaderEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager New Reader event.  The handle must be obtained via the
    AccessNewReaderEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseNewReaderEvent")

void
ReleaseNewReaderEvent(
    void)
{
    if (NULL != l_hNewReaderEvent)
    {
        CloseHandle(l_hNewReaderEvent);
        l_hNewReaderEvent = NULL;
    }
}


/*++

ReleaseAllEvents:

    This is a catch-all routine that releases all known special event handles.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

Author:

    Doug Barlow (dbarlow) 7/6/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseAllEvents")

void
ReleaseAllEvents(
    void)
{
    ReleaseNewReaderEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\comrspnd.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ComRspnd

Abstract:

    This module implements the Calais Communication Responder class.

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:



--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>
#include <stdlib.h>

#define CALCOM_PIPE_TIMEOUT 5000


//
//==============================================================================
//
//  CComResponder
//

/*++

CComResponder:

    This is the standard constructor and destructor for the Comm Responder
    class.  They just call the clean and clear functions, respectively.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::CComResponder")

CComResponder::CComResponder(
    void)
:   m_bfPipeName(),
    m_aclPipe(),
    m_hComPipe(DBGT("CComResponder's Comm Pipe")),
    m_hAccessMutex(DBGT("CComResponder's Access Mutex")),
    m_hOvrWait(DBGT("CComResponder Overlapped I/O completion event"))
{
    Clean();
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::~CComResponder")
CComResponder::~CComResponder()
{
    Clear();
}


/*++

Clean:

    This method sets the object to its default state.  It does not perform any
    tear down -- use Clear for that.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Clean")

void
CComResponder::Clean(
    void)
{
    ZeroMemory(&m_ovrlp, sizeof(m_ovrlp));
    m_bfPipeName.Reset();
}


/*++

Clear:

    This method performs object tear-down and returns it to its initial state.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Clear")

void
CComResponder::Clear(
    void)
{
    if (m_hAccessMutex.IsValid())
    {
        WaitForever(
            m_hAccessMutex,
            CALAIS_LOCK_TIMEOUT,
            DBGT("Waiting for final Service Thread quiescence: %1"),
            (LPCTSTR)NULL);
        m_hAccessMutex.Close();
    }

    if (m_hComPipe.IsValid())
    {
        if (!DisconnectNamedPipe(m_hComPipe))
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder could not disconnect Comm pipe:  %1"),
                GetLastError());
        }

        m_hComPipe.Close();
    }

    if (m_hOvrWait.IsValid())
        m_hOvrWait.Close();
    Clean();
}


/*++

Create:

    This method Establishes the named target.  Close or the destructor takes it
    away.

Arguments:

    szName supplies the name of the communication object to connect to.

Return Value:

    None

Throws:

    DWORDs containing the error code, should an error be encountered.

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Create")

void
CComResponder::Create(
    LPCTSTR szName)
{
    LPCTSTR szPipeHdr = CalaisString(CALSTR_PIPEDEVICEHEADER);
    static DWORD s_nPipeNo = 0;
    static HKEY s_hCurrentKey = NULL;
    TCHAR szPipeNo[sizeof(s_nPipeNo)*2 + 1];    // Twice as many hex digits + zero

    try
    {
        DWORD cbPipeHeader = lstrlen(szPipeHdr) * sizeof(TCHAR);
        DWORD dwLen;
        DWORD dwError;

        dwLen = lstrlen(szName) * sizeof(TCHAR);
        m_bfPipeName.Presize(cbPipeHeader + dwLen + sizeof(szPipeNo));

        if (s_hCurrentKey == NULL)
        {
            HKEY  hKey;

            //
            // Open the key to the Calais tree.
            //
            dwError = RegOpenKeyEx(
                           HKEY_LOCAL_MACHINE,
                           CalaisString(CALSTR_CALAISREGISTRYKEY),
                           0,                       // options (ignored)
                           KEY_WRITE,               // KEY_SET_VALUE | KEY_CREATE_SUB_KEY
                           &hKey
                           );
            if (ERROR_SUCCESS != dwError)
            {
                CalaisError(__SUBROUTINE__, 104, dwError);
                throw dwError;
            }

            //
            // Create a new  key (or open existing one).
            //
            dwError = RegCreateKeyEx(
                            hKey,
                            _T("Current"),
                            0,
                            0,
                            REG_OPTION_VOLATILE, // options
                            KEY_SET_VALUE,       // desired access
                            NULL,
                            &s_hCurrentKey,
                            NULL);

            RegCloseKey(hKey);

            if (ERROR_SUCCESS != dwError)
            {
                CalaisError(__SUBROUTINE__, 103, dwError);
                throw dwError;
            }
        }

        //
        // Build the pipe ACL.
        //

        ASSERT(!m_hComPipe.IsValid());
        m_aclPipe.InitializeFromProcessToken();
        m_aclPipe.AllowOwner(
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL);
        m_aclPipe.Allow(
            &m_aclPipe.SID_Interactive, 
            (FILE_GENERIC_WRITE | FILE_GENERIC_READ)
            & ~FILE_CREATE_PIPE_INSTANCE);
        m_aclPipe.Allow(
            &m_aclPipe.SID_System,
            (FILE_GENERIC_WRITE | FILE_GENERIC_READ)
            & ~FILE_CREATE_PIPE_INSTANCE);


        for (;;)
        {
                //
                // Build the pipe name.
                //
            _itot(s_nPipeNo, szPipeNo, 16);

            m_bfPipeName.Set((LPCBYTE)szPipeHdr, cbPipeHeader);
            m_bfPipeName.Append((LPCBYTE)szName, dwLen);
            m_bfPipeName.Append((LPCBYTE)szPipeNo, sizeof(szPipeNo));

            //
            // Build the Pipe (First instance)
            //

            m_hComPipe = CreateNamedPipe(
                            (LPCTSTR)m_bfPipeName.Access(),
                            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
                            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                            PIPE_UNLIMITED_INSTANCES,
                            CALAIS_COMM_MSGLEN,
                            CALAIS_COMM_MSGLEN,
                            CALCOM_PIPE_TIMEOUT,
                            m_aclPipe);
            if (!m_hComPipe.IsValid())
            {
                dwError = m_hComPipe.GetLastError();
                if (dwError == ERROR_ACCESS_DENIED)
                {
                    s_nPipeNo++;
                    continue;
                }
                CalaisError(__SUBROUTINE__, 109, dwError);
                throw dwError;
            }
            else
                break;
        }

        dwError = RegSetValueEx(
                       s_hCurrentKey,
                       NULL,           // Use key's unnamed value
                       0,
                       REG_DWORD,
                       (LPBYTE) &s_nPipeNo,
                       sizeof(DWORD));
        if (ERROR_SUCCESS != dwError)
        {
            CalaisError(__SUBROUTINE__, 102, dwError);
            throw dwError;
        }

        //
        // Prepare the overlapped structure.
        //

        m_hOvrWait = m_ovrlp.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_hOvrWait.IsValid())
        {
            DWORD dwErr = m_hOvrWait.GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder failed to create overlapped event: %1"),
                dwErr);
            throw dwErr;
        }
    }

    catch (...)
    {
        CalaisError(__SUBROUTINE__, 110);
        Clear();
        throw;
    }

}


/*++

Listen:

    This method listens on the previously created Communication channel for an
    incoming connection request.  When one comes in, it establishes a containing
    CComChannel object for it, and returns it.  To disconnect the comm channel,
    just delete the returned CComChannel object.

Arguments:

    None

Return Value:

    The CComChannel established.

Throws:

    DWORDs containing any error codes encountered.

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Listen")

CComChannel *
CComResponder::Listen(
    void)
{
    CComChannel *pChannel = NULL;

    for (;;)
    {
        CHandleObject hComPipe(DBGT("Comm Pipe handle from CComResponder::Listen"));

        try
        {
            BOOL fSts;


            //
            // Wait for an incoming connect request.
            //

RetryConnect:
            fSts = ConnectNamedPipe(m_hComPipe, &m_ovrlp);
            if (!fSts)
            {
                BOOL fErrorProcessed;
                DWORD dwSts = GetLastError();
                DWORD dwSize;
                DWORD dwWait;

                do
                {
                    fErrorProcessed = TRUE;
                    switch (dwSts)
                    {
                    //
                    // Block until something happens.
                    case ERROR_IO_PENDING:
                        dwWait = WaitForAnyObject(
                                    INFINITE,
                                    m_ovrlp.hEvent,
                                    g_hCalaisShutdown,
                                    NULL);
                        switch (dwWait)
                        {
                        case 1: // We've got a connect request
                            fErrorProcessed = FALSE;
                            fSts = GetOverlappedResult(
                                        m_hComPipe,
                                        &m_ovrlp,
                                        &dwSize,
                                        TRUE);
                            dwSts = fSts ? ERROR_SUCCESS : GetLastError();
                            break;
                        case 2: // Application shutdown
                            throw (DWORD)SCARD_P_SHUTDOWN;
                            break;
                        default:
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Wait for connect pipe returned invalid value"));
                            throw (DWORD)SCARD_F_INTERNAL_ERROR;
                        }
                        break;

                    //
                    // Success after a wait event.
                    case ERROR_SUCCESS:
                        break;

                    //
                    // Non-error.  Just ignore it.
                    case ERROR_PIPE_CONNECTED:
                        break;

                    //
                    // The client has closed its end 
                    case ERROR_NO_DATA:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("ConnectNamedPipe returned ERROR_NO_DATA, disconnecting and retrying"));
                        DisconnectNamedPipe(m_hComPipe);
                        goto RetryConnect;

                    //
                    // Unexpected error.  Report it.
                    default:
                        CalaisError(__SUBROUTINE__, 108, dwSts);
                        throw dwSts;
                    }
                } while (!fErrorProcessed);
            }


            //
            // Kick off another Pipe instance for the next request.
            //


            hComPipe = m_hComPipe.Relinquish();
            // m_hComPipe = INVALID_HANDLE_VALUE;
            m_hComPipe = CreateNamedPipe(
                            (LPCTSTR)m_bfPipeName.Access(),
                            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                            PIPE_UNLIMITED_INSTANCES,
                            CALAIS_COMM_MSGLEN,
                            CALAIS_COMM_MSGLEN,
                            CALCOM_PIPE_TIMEOUT,
                            m_aclPipe);
            if (!m_hComPipe.IsValid())
            {
                DWORD dwErr = m_hComPipe.GetLastError();
                CalaisError(__SUBROUTINE__, 105, dwErr);
                throw dwErr;
            }


            //
            // Handle the connect request data.
            //


            pChannel = new CComChannel(hComPipe);
            if (NULL == pChannel)
            {
                DWORD dwSts = SCARD_E_NO_MEMORY;
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Com Responder could not allocate a Comm Channel:  %1"),
                    dwSts);
                throw dwSts;
            }
            hComPipe.Relinquish();
            break;
        }

        catch (...)
        {
            if (NULL != pChannel)
            {
                delete pChannel;
                pChannel = NULL;
            }
            if (hComPipe.IsValid())
                hComPipe.Close();
            throw;
        }
    }

    return pChannel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\inc\ctrllib.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CtrlLib

Abstract:

    This header file describes the service startup and shutdown routines.

Author:

    Doug Barlow (dbarlow) 2/11/1997

Environment:

    Win32

Notes:

--*/

#ifndef _CTRLLIB_H_
#define _CTRLLIB_H_

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD
InstallCalais(
    LPCTSTR szFile,
    LPCTSTR szUser,
    LPCTSTR szPasswd);

extern DWORD
StartCalais(
    LPCTSTR szFile,
    LPCTSTR szUser,
    LPCTSTR szPasswd);

extern DWORD
RestartCalais(
    LPCTSTR szFile,
    LPCTSTR szUser,
    LPCTSTR szPasswd);

extern DWORD
StopCalais(
    void);

#ifdef __cplusplus
}
#endif
#endif // _CTRLLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\comms\startsvr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    StartSvc

Abstract:

    This module provides a Starter service for Calais.

Author:

    Doug Barlow (dbarlow) 2/10/1997

Environment:

    Win32, C++

Notes:



--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <winscard.h>
#include <CalMsgs.h>
#include <CalaisLb.h>


/*++

StartCalaisService:

    This function starts the Calais service.

Arguments:

    None

Return Value:

    a DWORD status code.  ERROR_SUCCESS implies success.

Throws:

    None.

Author:

    Doug Barlow (dbarlow) 2/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("StartCalaisService")

DWORD
StartCalaisService(
    void)
{
    // return ERROR_SERVICE_DISABLED;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwGiveUpCount;
    DWORD dwSts;
    BOOL fSts;

    try
    {
        SERVICE_STATUS ssStatus;    // current status of the service

        schSCManager = OpenSCManager(
                            NULL,           // machine (NULL == local)
                            NULL,           // database (NULL == default)
                            GENERIC_READ);  // access required
        dwSts = NULL == schSCManager ? GetLastError() : ERROR_SUCCESS;
        if (NULL == schSCManager)
            throw dwSts;

        schService = OpenService(
                        schSCManager,
                        CalaisString(CALSTR_PRIMARYSERVICE),
                        SERVICE_QUERY_STATUS | SERVICE_START);
        dwSts = NULL == schService ? GetLastError() : ERROR_SUCCESS;
        if (NULL == schService)
            throw dwSts;

        // try to start the service
        fSts = StartService(schService, 0, NULL);
        dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        if (!fSts)
        {
            dwSts = GetLastError();
            switch (dwSts)
            {
            case ERROR_SERVICE_ALREADY_RUNNING:
                break;
            default:
                throw dwSts;
            }
        }
        dwGiveUpCount = 60;
        Sleep(1000);

        for (;;)
        {
            fSts = QueryServiceStatus(schService, &ssStatus);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
            if (!fSts)
                break;

            if (ssStatus.dwCurrentState == SERVICE_START_PENDING)
            {
                if (0 < --dwGiveUpCount)
                    Sleep(1000);
                else
                    throw (DWORD)SCARD_E_NO_SERVICE;
            }
            else
                break;
        }

        if (ssStatus.dwCurrentState != SERVICE_RUNNING)
            throw GetLastError();

        fSts = CloseServiceHandle(schService);
        dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        schService = NULL;

        fSts = CloseServiceHandle(schSCManager);
        dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        schSCManager = NULL;
    }

    catch (DWORD dwErr)
    {
        if (NULL != schService)
        {
            fSts = CloseServiceHandle(schService);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        if (NULL != schSCManager)
        {
            fSts = CloseServiceHandle(schSCManager);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        dwReturn = dwErr;
    }

    catch (...)
    {
        if (NULL != schService)
        {
            fSts = CloseServiceHandle(schService);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        if (NULL != schSCManager)
        {
            fSts = CloseServiceHandle(schSCManager);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\inc\calmsgs.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    calmsgs

Abstract:

    This header file describes the symbols and macros used in the Calais Event
    Logging components.

Author:

    Doug Barlow (dbarlow) 5/15/1997

Environment:

    C++, Win32

Notes:

--*/

#ifndef _CALMSGS_H_
#define _CALMSGS_H_
#include <tchar.h>
#ifdef DBG
#include <eh.h>
#endif

#define CALSTR_CALAISEXECUTABLE          1    // "%windir%\\system32\\SCardSvr.exe"
#define CALSTR_PRIMARYSERVICE            2    // "SCardSvr"
#define CALSTR_CALAISREGISTRYKEY         4    // "SOFTWARE\\Microsoft\\Cryptography\\Calais"
#define CALSTR_READERREGISTRYKEY         5    // "SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"
#define CALSTR_SMARTCARDREGISTRYKEY      6    // "SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"
#define CALSTR_READERREGISTRYSUBKEY      7    // "Readers"
#define CALSTR_DEVICEREGISTRYSUBKEY      8    // "Device"
#define CALSTR_GROUPSREGISTRYSUBKEY      9    // "Groups"
#define CALSTR_ATRREGISTRYSUBKEY        10    // "ATR"
#define CALSTR_ATRMASKREGISTRYSUBKEY    11    // "ATRMask"
#define CALSTR_INTERFACESREGISTRYSUBKEY 12    // "Supported Interfaces"
#define CALSTR_PRIMARYPROVIDERSUBKEY    13    // "Primary Provider"
#define CALSTR_CRYPTOPROVIDERSUBKEY     14    // "Crypto Provider"
#define CALSTR_SERVICESREGISTRYKEY      15    // "SYSTEM\\CurrentControlSet\\Services"
#define CALSTR_EVENTLOGREGISTRYKEY      16    // "SYSTEM\\CurrentControlSet\\Services\\EventLog"
#define CALSTR_SYSTEMREGISTRYSUBKEY     17    // "System"
#define CALSTR_EVENTMESSAGEFILESUBKEY   18    // "EventMessageFile"
#define CALSTR_TYPESSUPPORTEDSUBKEY     19    // "TypesSupported"
#define CALSTR_PNPDEVICEREGISTRYKEY     20    // "SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{50dd5230-ba8a-11d1-bf5d-0000f805f530}"
#define CALSTR_SYMBOLICLINKSUBKEY       21    // "SymbolicLink"
#define CALSTR_VXDPATHREGISTRYKEY       22    // "System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices"
#define CALSTR_LEGACYDEPENDONGROUP      23    // "+Smart Card Reader"
#define CALSTR_NEWREADEREVENTNAME       24    // "Global\\Microsoft Smart Card Resource Manager New Reader"
#define CALSTR_STARTEDEVENTNAME         25    // "Global\\Microsoft Smart Card Resource Manager Started"
#define CALSTR_CANCELEVENTPREFIX        26    // "Global\\Microsoft Smart Card Cancel Event for %1!d!"
#define CALSTR_COMMPIPENAME             27    // "Microsoft Smart Card Resource Manager"
#define CALSTR_LEGACYDEVICEHEADER       28    // "\\\\.\\"
#define CALSTR_LEGACYDEVICENAME         29    // "SCReader"
#define CALSTR_MAXLEGACYDEVICES         30    // "MaxLegacyDevices"
#define CALSTR_MAXDEFAULTBUFFER         31    // "MaxDefaultBuffer"
#define CALSTR_PIPEDEVICEHEADER         32    // "\\\\.\\pipe\\"
#define CALSTR_SERVICEDEPENDENCIES      33    // "PlugPlay\000"
#define CALSTR_SPECIALREADERHEADER      34    // "\\\\?PNP?\\"
#define CALSTR_ACTIVEREADERCOUNTREADER  35    // "NOTIFICATION"
#define CALSTR_CERTPROPREGISTRY         36    // "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify"
#define CALSTR_CERTPROPKEY              37    // "ScCertProp"
#define CALSTR_DLLNAME                  38    // "DLLName"
#define CALSTR_LOGON                    39    // "Logon"
#define CALSTR_LOGOFF                   40    // "Logoff"
#define CALSTR_LOCK                     41    // "Lock"
#define CALSTR_UNLOCK                   42    // "Unlock"
#define CALSTR_ENABLED                  43    // "Enabled"
#define CALSTR_IMPERSONATE              44    // "Impersonate"
#define CALSTR_ASYNCHRONOUS             45    // "Asynchronous"
#define CALSTR_CERTPROPDLL              46    // "WlNotify.dll"
#define CALSTR_CERTPROPSTART            47    // "SCardStartCertProp"
#define CALSTR_CERTPROPSTOP             48    // "SCardStopCertProp"
#define CALSTR_CERTPROPSUSPEND          49    // "SCardSuspendCertProp"
#define CALSTR_CERTPROPRESUME           50    // "SCardResumeCertProp"
#define CALSTR_SMARTCARDINSERTION       51    // "SmartcardInsertion"
#define CALSTR_SMARTCARDREMOVAL         52    // "SmartcardRemoval"
#define CALSTR_APPEVENTS                53    // "AppEvents"
#define CALSTR_EVENTLABELS              54    // "EventLabels"
#define CALSTR_DOT_DEFAULT              55    // ".Default"
#define CALSTR_DOT_CURRENT              56    // ".Current"
#define CALSTR_SOUNDSREGISTRY           57    // "Schemes\\Apps\\.Default"
#define CALSTR_LOGONREGISTRY            58    //  "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define CALSTR_LOGONREMOVEOPTION        59    //  "ScRemoveOption"
#define CALSTR_STOPPEDEVENTNAME         60    // "Global\\Microsoft Smart Card Resource Manager Stopped"

// Unused
//      CALSTR_TEMPLATEREGISTRYKEY      ?n?    // "SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCard Templates"
//      CALSTR_OEMCONFIGREGISTRYSUBKEY  ?n?    // "OEM Configuration"

// Debug only
#define CALSTR_DEBUGSERVICE             61    // "SCardDbg"
#define CALSTR_DEBUGREGISTRYSUBKEY      62    // "Debug"

#ifdef DBG
#define CALSTR_DEBUGLOGSUBKEY           63    // "Debug"
#define CALSTR_GUIWARNINGSUBKEY         64    // "GuiWarnings"
#define CALSTR_LOGSEVERITYSUBKEY        65    // "LogSeverity"
#define CALSTR_GUISEVERITYSUBKEY        66    // "GuiSeverity"
#define CALSTR_APITRACEFILENAME         67    // "C:\\SCard.log"
#define CALSTR_DRIVERTRACEFILENAME      68    // "C:\\Calais.log"
#define CALSTR_MESSAGETAG               69    // " *MESSAGE* "
#define CALSTR_INFOMESSAGETAG           70    // " *INFO* "
#define CALSTR_WARNINGMESSAGETAG        71    // " *WARNING* "
#define CALSTR_ERRORMESSAGETAG          72    // " *ERROR* "
#define CALSTR_DEBUGSERVICEDISPLAY      73    // "Smart Card Debug"
#define CALSTR_DEBUGSERVICEDESC         74    // "Start this service first to debug Smart card service startup"
#endif


// Internationalizable
#define CALSTR_RESOURCELIMIT           100    // String Ids larger than this are resources
#define CALSTR_PRIMARYSERVICEDISPLAY   CALSTR_RESOURCELIMIT + IDS_PRIMARYSERVICEDISPLAY // "Smart Card"
#define CALSTR_LEGACYSERVICEDISPLAY    CALSTR_RESOURCELIMIT + IDS_LEGACYSERVICEDISPLAY  // "Smart Card Helper"
#define CALSTR_SMARTCARD_INSERTION     CALSTR_RESOURCELIMIT + IDS_SMARTCARD_INSERTION   // "Smart Card Insertion"
#define CALSTR_SMARTCARD_REMOVAL       CALSTR_RESOURCELIMIT + IDS_SMARTCARD_REMOVAL     // "Smart Card Removal"
#define CALSTR_PRIMARYSERVICEDESC      CALSTR_RESOURCELIMIT + IDS_PRIMARYSERVICEDESC
#define CALSTR_LEGACYSERVICEDESC       CALSTR_RESOURCELIMIT + IDS_LEGACYSERVICEDESC

extern const LPCTSTR g_rgszDefaultStrings[];

extern void
CalaisMessageInit(
    LPCTSTR szTitle,
    HANDLE hEventLogger = NULL,
    BOOL fServer = FALSE);
extern void
CalaisMessageClose(
    void);
extern LPCTSTR
CalaisString(
    DWORD dwStringId);

#ifdef DBG

#define DBGT(x) _T(x)
#define DEBUG_TEXT LPCTSTR
#define CalaisDebug(a) _CalaisDebug a

extern void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    DWORD dwLineNo = 0);
extern void
_CalaisDebug(
    DEBUG_TEXT szMessage,
    ...);
extern void
CalaisSetDebug(
    BOOLEAN Debug
    );
extern void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    DEBUG_TEXT szMessageStr,
    DEBUG_TEXT *rgszParams = NULL,
    LPCVOID pvBinaryData = NULL,
    DWORD cbBinaryData = 0);
extern void
WriteApiLog(
    LPCVOID pvData,
    DWORD cbLength);

#else

#define DBGT(x) ((LPCBYTE)(0))
#define DEBUG_TEXT LPCBYTE
#define CalaisDebug(a)

inline void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}
inline void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}
inline void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}
inline void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}

#endif

extern void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    DWORD dwMessageId,
    LPCTSTR *rgszParams = NULL,
    LPCVOID pvBinaryData = NULL,
    DWORD cbBinaryData = 0);

#ifndef ASSERT
#if defined(_DEBUG)
#define ASSERT(x) _ASSERTE(x)
#if !defined(DBG)
#define DBG
#endif
#elif defined(DBG)
#define ASSERT(x) if (!(x)) { \
        CalaisError(DBGT("Assert"), DBGT("Failed Assertion: %1 at %2(%3)"), #x, __FILE__, __LINE__); \
        DebugBreak(); }
#else
#define ASSERT(x)
#endif
#endif

#endif // _CALMSGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\inc\calcom.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CalCom

Abstract:

    This header file describes the classes used to implement communication
    between the Calais API DLL and the Calais Service Manager Server.

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CALCOM_H_
#define _CALCOM_H_

#include <winSCard.h>
#include <CalaisLb.h>

#define CALAIS_COMM_V1_00          0 // Version identifier for communications
#define CALAIS_COMM_V2_02 0x00020002 // 2.2 Designation
#define CALAIS_COMM_CURRENT   CALAIS_COMM_V2_02
#define CALAIS_LOCK_TIMEOUT    20000 // Milliseconds to wait before a lock is
                                     // declared dead.
#define CALAIS_THREAD_TIMEOUT  30000 // Milliseconds to wait before a thread is
                                     // declared dead.
#define CALAIS_COMM_MSGLEN       512 // Expected reasonable size of a message

#include "Locks.h"

class CComInitiator;
class CComResponder;

extern HANDLE g_hCalaisShutdown;    // We declare it here, since we don't know
                                    // if it comes from the client or server.

extern DWORD StartCalaisService(void);
extern HANDLE AccessStartedEvent(void);
extern HANDLE AccessStoppedEvent(void);
extern HANDLE AccessNewReaderEvent(void);
extern void ReleaseStartedEvent(void);
extern void ReleaseStoppedEvent(void);
extern void ReleaseNewReaderEvent(void);
extern void ReleaseAllEvents(void);
extern "C" DWORD WINAPI ServiceMonitor(LPVOID pvParameter);


//
// An INTERCHANGEHANDLE is an internal identifier for communications between
// the client and server.  It isn't exposed to users.  For now, it's a simple
// 32-bit unsigned index value.
//

typedef DWORD INTERCHANGEHANDLE;


//
//==============================================================================
//
//  CComChannel
//

class CComChannel
{
public:

    //  Constructors & Destructor
    ~CComChannel();

    //  Properties

    //  Methods
    DWORD Send(LPCVOID pvData, DWORD cbLen);
    void Receive(LPVOID pvData, DWORD cbLen);

    void ClosePipe()
    {
        if (m_hPipe.IsValid())
            m_hPipe.Close();
    };

    HANDLE Process(void) const
    { return m_hProc; };
    void Process(HANDLE hProc)
    { ASSERT(!m_hProc.IsValid());
      m_hProc = hProc; };

    //  Operators

protected:

    // Internal comm structures
    typedef struct
    {
        DWORD dwSync;
        DWORD dwVersion;
    } CONNECT_REQMSG;    // Connect request message.

    typedef struct
    {
        DWORD dwStatus;
        DWORD dwVersion;
    } CONNECT_RSPMSG;   // Connect response message.

    //  Constructors & Destructor
    CComChannel(HANDLE hPipe);

    //  Properties
    CHandleObject m_hPipe;
    CHandleObject m_hProc;
    CHandleObject m_hOvrWait;
    OVERLAPPED m_ovrlp;

    //  Methods

    // Friends
    friend class CComInitiator;
    friend class CComResponder;
    friend DWORD WINAPI ServiceMonitor(LPVOID pvParameter);
};


//
//==============================================================================
//
//  CComInitiator
//

class CComInitiator
{
public:

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CComChannel *Initiate(LPCTSTR szName, LPDWORD pdwVersion) const;

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
//==============================================================================
//
//  CComResponder
//

class CComResponder
{
public:

    //  Constructors & Destructor
    CComResponder();
    ~CComResponder();

    //  Properties

    //  Methods
    void Create(LPCTSTR szName);
    CComChannel *Listen(void);

    //  Operators

protected:
    //  Properties
    CHandleObject m_hComPipe;
    CHandleObject m_hAccessMutex;
    CBuffer m_bfPipeName;
    CSecurityDescriptor m_aclPipe;
    OVERLAPPED m_ovrlp;
    CHandleObject m_hOvrWait;

    //  Methods
    void Clean(void);
    void Clear(void);
};


//
//==============================================================================
//
//  CComObject and derivatives.
//

class CComObject
{
public:
    typedef enum
    {
        EstablishContext_request = 0,
        EstablishContext_response,
        ReleaseContext_request,
        ReleaseContext_response,
        IsValidContext_request,
        IsValidContext_response,
#if 0
        ListReaderGroups_request,
        ListReaderGroups_response,
#endif
        ListReaders_request,
        ListReaders_response,
#if 0
        ListCards_request,
        ListCards_response,
        ListInterfaces_request,
        ListInterfaces_response,
        GetProviderId_request,
        GetProviderId_response,
        IntroduceReaderGroup_request,
        IntroduceReaderGroup_response,
        ForgetReaderGroup_request,
        ForgetReaderGroup_response,
        IntroduceReader_request,
        IntroduceReader_response,
        ForgetReader_request,
        ForgetReader_response,
        AddReaderToGroup_request,
        AddReaderToGroup_response,
        RemoveReaderFromGroup_request,
        RemoveReaderFromGroup_response,
        IntroduceCardType_request,
        IntroduceCardType_response,
        ForgetCardType_request,
        ForgetCardType_response,
        FreeMemory_request,
        FreeMemory_response,
#endif
        LocateCards_request,
        LocateCards_response,
        GetStatusChange_request,
        GetStatusChange_response,
#if 0
        Cancel_request,
        Cancel_response,
#endif
        Connect_request,
        Connect_response,
        Reconnect_request,
        Reconnect_response,
        Disconnect_request,
        Disconnect_response,
        BeginTransaction_request,
        BeginTransaction_response,
        EndTransaction_request,
        EndTransaction_response,
        Status_request,
        Status_response,
        Transmit_request,
        Transmit_response,
        OpenReader_request,
        OpenReader_response,
        Control_request,
        Control_response,
        GetAttrib_request,
        GetAttrib_response,
        SetAttrib_request,
        SetAttrib_response,
        OutofRange
    } COMMAND_ID;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjGeneric_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjGeneric_response;
    typedef struct
    {
        DWORD
            dwOffset,
            dwLength;
    } Desc;
    static const DWORD
        AUTOCOUNT,      // Append symbol to force computing string length.
        MULTISTRING;    // Append symbol to force computing multistring length.

    //  Constructors & Destructor
    CComObject();
    virtual ~CComObject()  /* Mandatory Base Class Destructor */ 
    {
        // Our storage buffer may contain sensitive data such as user
        // PINs.  Scrub this buffer if it exists.
        if (NULL != m_pbfActive)
        {
            RtlSecureZeroMemory(m_pbfActive->Access(), m_pbfActive->Length());
        }
    };

    //  Properties

    //  Methods
#ifdef DBG
    void dbgCheck(void) const;
#define ComObjCheck dbgCheck()
#else
#define ComObjCheck
#endif
    static CComObject *
    ReceiveComObject(       // Spit out the type of Com Object coming in.
        CComChannel *pChannel);
    CObjGeneric_response *Receive(CComChannel *pChannel);
    DWORD Send(CComChannel *pChannel);
    LPBYTE Request(void) const
    { return m_bfRequest.Access(); };
    LPBYTE Response(void) const
    { return m_bfResponse.Access(); };
    LPBYTE Data(void) const
    {
        ComObjCheck;
        return m_pbfActive->Access();
    };
    DWORD Length(void) const
    {
        ComObjCheck;
        return m_pbfActive->Length();
    };
    COMMAND_ID Type(void) const
    {
        ComObjCheck;
        return (COMMAND_ID)(*(LPDWORD)Data());
    };
    void Presize(DWORD cbSize)
    {
        ComObjCheck;
        m_pbfActive->Presize(cbSize);
    };
    LPVOID Prep(Desc &dsc, DWORD cbLength);
    LPBYTE Append(Desc &dsc, LPCGUID rgguid, DWORD cguid)
    { return Append(dsc, (LPCBYTE)rgguid, cguid * sizeof(GUID)); };
    LPBYTE Append(Desc &dsc, LPCTSTR szString, DWORD cchLen = AUTOCOUNT);
    LPBYTE Append(Desc &dsc, LPCBYTE pbData, DWORD cbLength);
    LPCVOID Parse(Desc &dsc, LPDWORD pcbLen = NULL);

    //  Operators

protected:
    //  Properties
    CBuffer *m_pbfActive;
    CBuffer m_bfRequest;
    CBuffer m_bfResponse;

    //  Methods
    void InitStruct(DWORD dwCommandId, DWORD dwDataOffset, DWORD dwExtra);

    // Friends
    friend CComObject * ReceiveComObject(HANDLE hFile);
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Access Services
//
//      The following services are used to manage user and terminal contexts for
//      smartcards.
//
//      The first few fields are very specific.  For request structures they
//      must be:
//
//          DWORD
//              dwCommandId,
//              dwTotalLength,
//              dwDataOffset;
//
//      and for response structures they must be:
//
//          DWORD
//              dwCommandId,
//              dwTotalLength,
//              dwDataOffset,
//              dwStatus;
//
//      As defined for CObjGeneric_request and CObjGeneric_response,
//      respectively.
//

//
// ComEstablishContext
//

class ComEstablishContext
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        DWORD dwProcId;
        UINT64 hptrCancelEvent;
    } CObjEstablishContext_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        DWORD dwProcId;
        UINT64 hptrCancelEvent;
    } CObjEstablishContext_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjEstablishContext_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            EstablishContext_request,
            sizeof(CObjEstablishContext_request),
            dwExtraLen);
        return (CObjEstablishContext_request *)Data();
    };
    CObjEstablishContext_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            EstablishContext_response,
            sizeof(CObjEstablishContext_response),
            dwExtraLen);
        return (CObjEstablishContext_response *)Data();
    };
    CObjEstablishContext_response *Receive(CComChannel *pChannel)
    {
        return (CObjEstablishContext_response *)CComObject::Receive(pChannel);
    };


    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComReleaseContext
//

class ComReleaseContext
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjReleaseContext_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjReleaseContext_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjReleaseContext_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ReleaseContext_request,
            sizeof(CObjReleaseContext_request),
            dwExtraLen);
        return (CObjReleaseContext_request *)Data();
    };
    CObjReleaseContext_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ReleaseContext_response,
            sizeof(CObjReleaseContext_response),
            dwExtraLen);
        return (CObjReleaseContext_response *)Data();
    };
    CObjReleaseContext_response *Receive(CComChannel *pChannel)
    {
        return (CObjReleaseContext_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIsValidContext
//

class ComIsValidContext
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjIsValidContext_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIsValidContext_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIsValidContext_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IsValidContext_request,
            sizeof(CObjIsValidContext_request),
            dwExtraLen);
        return (CObjIsValidContext_request *)Data();
    };
    CObjIsValidContext_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IsValidContext_response,
            sizeof(CObjIsValidContext_response),
            dwExtraLen);
        return (CObjIsValidContext_response *)Data();
    };
    CObjIsValidContext_response *Receive(CComChannel *pChannel)
    {
        return (CObjIsValidContext_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

//
// ComLocateCards
//

class ComLocateCards
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscAtrs;           // ATR strings w/ leading byte length.
        Desc dscAtrMasks;       // ATR Masks w/ leading byte length.
        Desc dscReaders;        // mszReaders as device names
        Desc dscReaderStates;   // rgdwReaderStates
    } CObjLocateCards_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscReaderStates;   // rgdwReaderStates
        Desc dscAtrs;           // ATR strings w/ leading byte length.
    } CObjLocateCards_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjLocateCards_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            LocateCards_request,
            sizeof(CObjLocateCards_request),
            dwExtraLen);
        return (CObjLocateCards_request *)Data();
    };
    CObjLocateCards_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            LocateCards_response,
            sizeof(CObjLocateCards_response),
            dwExtraLen);
        return (CObjLocateCards_response *)Data();
    };
    CObjLocateCards_response *Receive(CComChannel *pChannel)
    {
        return (CObjLocateCards_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComGetStatusChange
//

class ComGetStatusChange
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        DWORD dwTimeout;
        Desc dscReaders;        // mszReaders as device names.
        Desc dscReaderStates;   // rgdwReaderStates
    } CObjGetStatusChange_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscReaderStates;   // rgdwReaderStates
        Desc dscAtrs;           // ATR strings w/ leading byte length.
    } CObjGetStatusChange_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjGetStatusChange_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            GetStatusChange_request,
            sizeof(CObjGetStatusChange_request),
            dwExtraLen);
        return (CObjGetStatusChange_request *)Data();
    };
    CObjGetStatusChange_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            GetStatusChange_response,
            sizeof(CObjGetStatusChange_response),
            dwExtraLen);
        return (CObjGetStatusChange_response *)Data();
    };
    CObjGetStatusChange_response *Receive(CComChannel *pChannel)
    {
        return (CObjGetStatusChange_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

//
// ComConnect
//

class ComConnect
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
        Desc dscReader;     // szReader
    } CObjConnect_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        INTERCHANGEHANDLE hCard;
        DWORD dwActiveProtocol;
    } CObjConnect_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjConnect_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Connect_request,
            sizeof(CObjConnect_request),
            dwExtraLen);
        return (CObjConnect_request *)Data();
    };
    CObjConnect_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Connect_response,
            sizeof(CObjConnect_response),
            dwExtraLen);
        return (CObjConnect_response *)Data();
    };
    CObjConnect_response *Receive(CComChannel *pChannel)
    {
        return (CObjConnect_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComReconnect
//

class ComReconnect
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
        DWORD dwInitialization;
    } CObjReconnect_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        DWORD dwActiveProtocol;
    } CObjReconnect_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjReconnect_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Reconnect_request,
            sizeof(CObjReconnect_request),
            dwExtraLen);
        return (CObjReconnect_request *)Data();
    };
    CObjReconnect_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Reconnect_response,
            sizeof(CObjReconnect_response),
            dwExtraLen);
        return (CObjReconnect_response *)Data();
    };
    CObjReconnect_response *Receive(CComChannel *pChannel)
    {
        return (CObjReconnect_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComDisconnect
//

class ComDisconnect
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwDisposition;
    } CObjDisconnect_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjDisconnect_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjDisconnect_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Disconnect_request,
            sizeof(CObjDisconnect_request),
            dwExtraLen);
        return (CObjDisconnect_request *)Data();
    };
    CObjDisconnect_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Disconnect_response,
            sizeof(CObjDisconnect_response),
            dwExtraLen);
        return (CObjDisconnect_response *)Data();
    };
    CObjDisconnect_response *Receive(CComChannel *pChannel)
    {
        return (CObjDisconnect_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComBeginTransaction
//

class ComBeginTransaction
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
    } CObjBeginTransaction_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjBeginTransaction_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjBeginTransaction_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            BeginTransaction_request,
            sizeof(CObjBeginTransaction_request),
            dwExtraLen);
        return (CObjBeginTransaction_request *)Data();
    };
    CObjBeginTransaction_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            BeginTransaction_response,
            sizeof(CObjBeginTransaction_response),
            dwExtraLen);
        return (CObjBeginTransaction_response *)Data();
    };
    CObjBeginTransaction_response *Receive(CComChannel *pChannel)
    {
        return (CObjBeginTransaction_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComEndTransaction
//

class ComEndTransaction
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwDisposition;
    } CObjEndTransaction_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjEndTransaction_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjEndTransaction_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            EndTransaction_request,
            sizeof(CObjEndTransaction_request),
            dwExtraLen);
        return (CObjEndTransaction_request *)Data();
    };
    CObjEndTransaction_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            EndTransaction_response,
            sizeof(CObjEndTransaction_response),
            dwExtraLen);
        return (CObjEndTransaction_response *)Data();
    };
    CObjEndTransaction_response *Receive(CComChannel *pChannel)
    {
        return (CObjEndTransaction_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComStatus
//

class ComStatus
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
    } CObjStatus_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        DWORD dwState;
        DWORD dwProtocol;
        Desc dscAtr;        // pbAtr
        Desc dscSysName;    // szReader
    } CObjStatus_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjStatus_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Status_request,
            sizeof(CObjStatus_request),
            dwExtraLen);
        return (CObjStatus_request *)Data();
    };
    CObjStatus_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Status_response,
            sizeof(CObjStatus_response),
            dwExtraLen);
        return (CObjStatus_response *)Data();
    };
    CObjStatus_response *Receive(CComChannel *pChannel)
    {
        return (CObjStatus_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComTransmit
//

class ComTransmit
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwPciLength;
        DWORD dwRecvLength;
        Desc dscSendPci;    // pioSendPci
        Desc dscSendBuffer; // pbSendBuffer
    } CObjTransmit_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscRecvPci;    // pioRecvPci
        Desc dscRecvBuffer; // pbRecvBuffer
    } CObjTransmit_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjTransmit_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Transmit_request,
            sizeof(CObjTransmit_request),
            dwExtraLen);
        return (CObjTransmit_request *)Data();
    };
    CObjTransmit_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Transmit_response,
            sizeof(CObjTransmit_response),
            dwExtraLen);
        return (CObjTransmit_response *)Data();
    };
    CObjTransmit_response *Receive(CComChannel *pChannel)
    {
        return (CObjTransmit_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Control Routines
//
//      The following services provide for direct, low-level manipulation of the
//      reader by the calling application allowing it control over the
//      attributes of the communications with the card.  This control is done
//      via an SCARD_ATTRIBUTES structure, which is defined as follows:
//

//
// ComOpenReader
//

class ComOpenReader
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReader;     // szReader
    } CObjOpenReader_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        INTERCHANGEHANDLE hReader;
        DWORD dwState;
    } CObjOpenReader_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjOpenReader_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            OpenReader_request,
            sizeof(CObjOpenReader_request),
            dwExtraLen);
        return (CObjOpenReader_request *)Data();
    };
    CObjOpenReader_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            OpenReader_response,
            sizeof(CObjOpenReader_response),
            dwExtraLen);
        return (CObjOpenReader_response *)Data();
    };
    CObjOpenReader_response *Receive(CComChannel *pChannel)
    {
        return (CObjOpenReader_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComControl
//

class ComControl
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwControlCode;
        DWORD dwOutLength;
        Desc dscInBuffer;       // lpInBuffer
    } CObjControl_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscOutBuffer;      // lpOutBuffer
    } CObjControl_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjControl_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Control_request,
            sizeof(CObjControl_request),
            dwExtraLen);
        return (CObjControl_request *)Data();
    };
    CObjControl_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Control_response,
            sizeof(CObjControl_response),
            dwExtraLen);
        return (CObjControl_response *)Data();
    };
    CObjControl_response *Receive(CComChannel *pChannel)
    {
        return (CObjControl_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComGetAttrib
//

class ComGetAttrib
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwAttrId;
        DWORD dwOutLength;
    } CObjGetAttrib_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscAttr;       // pbAttr
    } CObjGetAttrib_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjGetAttrib_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            GetAttrib_request,
            sizeof(CObjGetAttrib_request),
            dwExtraLen);
        return (CObjGetAttrib_request *)Data();
    };
    CObjGetAttrib_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            GetAttrib_response,
            sizeof(CObjGetAttrib_response),
            dwExtraLen);
        return (CObjGetAttrib_response *)Data();
    };
    CObjGetAttrib_response *Receive(CComChannel *pChannel)
    {
        return (CObjGetAttrib_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComSetAttrib
//

class ComSetAttrib
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwAttrId;
        Desc dscAttr;       // pbAttr
    } CObjSetAttrib_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjSetAttrib_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjSetAttrib_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            SetAttrib_request,
            sizeof(CObjSetAttrib_request),
            dwExtraLen);
        return (CObjSetAttrib_request *)Data();
    };
    CObjSetAttrib_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            SetAttrib_response,
            sizeof(CObjSetAttrib_response),
            dwExtraLen);
        return (CObjSetAttrib_response *)Data();
    };
    CObjSetAttrib_response *Receive(CComChannel *pChannel)
    {
        return (CObjSetAttrib_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Smartcard Database Management Services
//
//      The following services provide for managing the Smartcard Database.
//

//
// ComListReaders
//

class ComListReaders
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaders;     // mszReaders
    } CObjListReaders_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscReaders;    // rgfReaderActive
    } CObjListReaders_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListReaders_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaders_request,
            sizeof(CObjListReaders_request),
            dwExtraLen);
        return (CObjListReaders_request *)Data();
    };
    CObjListReaders_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaders_response,
            sizeof(CObjListReaders_response),
            dwExtraLen);
        return (CObjListReaders_response *)Data();
    };
    CObjListReaders_response *Receive(CComChannel *pChannel)
    {
        return (CObjListReaders_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


#if 0
//
// ComListReaderGroups
//

class ComListReaderGroups
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjListReaderGroups_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscGroups;     // mszGroups
    } CObjListReaderGroups_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListReaderGroups_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaderGroups_request,
            sizeof(CObjListReaderGroups_request),
            dwExtraLen);
        return (CObjListReaderGroups_request *)Data();
    };
    CObjListReaderGroups_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaderGroups_response,
            sizeof(CObjListReaderGroups_response),
            dwExtraLen);
        return (CObjListReaderGroups_response *)Data();
    };
    CObjListReaderGroups_response *Receive(CComChannel *pChannel)
    {
        return (CObjListReaderGroups_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComListCards
//

class ComListCards
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscAtr;        // pbAtr
        Desc dscInterfaces; // pguidInterfaces
    } CObjListCards_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscCards;      // mszCards
    } CObjListCards_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListCards_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListCards_request,
            sizeof(CObjListCards_request),
            dwExtraLen);
        return (CObjListCards_request *)Data();
    };
    CObjListCards_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListCards_response,
            sizeof(CObjListCards_response),
            dwExtraLen);
        return (CObjListCards_response *)Data();
    };
    CObjListCards_response *Receive(CComChannel *pChannel)
    {
        return (CObjListCards_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComListInterfaces
//

class ComListInterfaces
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCard;       // szCard
    } CObjListInterfaces_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscInterfaces; // pguidInterfaces
    } CObjListInterfaces_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListInterfaces_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListInterfaces_request,
            sizeof(CObjListInterfaces_request),
            dwExtraLen);
        return (CObjListInterfaces_request *)Data();
    };
    CObjListInterfaces_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListInterfaces_response,
            sizeof(CObjListInterfaces_response),
            dwExtraLen);
        return (CObjListInterfaces_response *)Data();
    };
    CObjListInterfaces_response *Receive(CComChannel *pChannel)
    {
        return (CObjListInterfaces_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComGetProviderId
//

class ComGetProviderId
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCard;       // szCard
    } CObjGetProviderId_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscProviderId; // pguidProviderId
    } CObjGetProviderId_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjGetProviderId_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            GetProviderId_request,
            sizeof(CObjGetProviderId_request),
            dwExtraLen);
        return (CObjGetProviderId_request *)Data();
    };
    CObjGetProviderId_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            GetProviderId_response,
            sizeof(CObjGetProviderId_response),
            dwExtraLen);
        return (CObjGetProviderId_response *)Data();
    };
    CObjGetProviderId_response *Receive(CComChannel *pChannel)
    {
        return (CObjGetProviderId_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIntroduceReaderGroup
//

class ComIntroduceReaderGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscGroupName;  // szGroupName
    } CObjIntroduceReaderGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIntroduceReaderGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIntroduceReaderGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReaderGroup_request,
            sizeof(CObjIntroduceReaderGroup_request),
            dwExtraLen);
        return (CObjIntroduceReaderGroup_request *)Data();
    };
    CObjIntroduceReaderGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReaderGroup_response,
            sizeof(CObjIntroduceReaderGroup_response),
            dwExtraLen);
        return (CObjIntroduceReaderGroup_response *)Data();
    };
    CObjIntroduceReaderGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjIntroduceReaderGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComForgetReaderGroup
//

class ComForgetReaderGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscGroupName;  // szGroupName
    } CObjForgetReaderGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjForgetReaderGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjForgetReaderGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReaderGroup_request,
            sizeof(CObjForgetReaderGroup_request),
            dwExtraLen);
        return (CObjForgetReaderGroup_request *)Data();
    };
    CObjForgetReaderGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReaderGroup_response,
            sizeof(CObjForgetReaderGroup_response),
            dwExtraLen);
        return (CObjForgetReaderGroup_response *)Data();
    };
    CObjForgetReaderGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjForgetReaderGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIntroduceReader
//

class ComIntroduceReader
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
        Desc dscDeviceName; // szDeviceName
    } CObjIntroduceReader_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIntroduceReader_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIntroduceReader_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReader_request,
            sizeof(CObjIntroduceReader_request),
            dwExtraLen);
        return (CObjIntroduceReader_request *)Data();
    };
    CObjIntroduceReader_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReader_response,
            sizeof(CObjIntroduceReader_response),
            dwExtraLen);
        return (CObjIntroduceReader_response *)Data();
    };
    CObjIntroduceReader_response *Receive(CComChannel *pChannel)
    {
        return (CObjIntroduceReader_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComForgetReader
//

class ComForgetReader
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
    } CObjForgetReader_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjForgetReader_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjForgetReader_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReader_request,
            sizeof(CObjForgetReader_request),
            dwExtraLen);
        return (CObjForgetReader_request *)Data();
    };
    CObjForgetReader_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReader_response,
            sizeof(CObjForgetReader_response),
            dwExtraLen);
        return (CObjForgetReader_response *)Data();
    };
    CObjForgetReader_response *Receive(CComChannel *pChannel)
    {
        return (CObjForgetReader_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComAddReaderToGroup
//

class ComAddReaderToGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
        Desc dscGroupName;  // szGroupName
    } CObjAddReaderToGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjAddReaderToGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjAddReaderToGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            AddReaderToGroup_request,
            sizeof(CObjAddReaderToGroup_request),
            dwExtraLen);
        return (CObjAddReaderToGroup_request *)Data();
    };
    CObjAddReaderToGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            AddReaderToGroup_response,
            sizeof(CObjAddReaderToGroup_response),
            dwExtraLen);
        return (CObjAddReaderToGroup_response *)Data();
    };
    CObjAddReaderToGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjAddReaderToGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComRemoveReaderFromGroup
//

class ComRemoveReaderFromGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
        Desc dscGroupName;  // szGroupName
    } CObjRemoveReaderFromGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjRemoveReaderFromGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjRemoveReaderFromGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            RemoveReaderFromGroup_request,
            sizeof(CObjRemoveReaderFromGroup_request),
            dwExtraLen);
        return (CObjRemoveReaderFromGroup_request *)Data();
    };
    CObjRemoveReaderFromGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            RemoveReaderFromGroup_response,
            sizeof(CObjRemoveReaderFromGroup_response),
            dwExtraLen);
        return (CObjRemoveReaderFromGroup_response *)Data();
    };
    CObjRemoveReaderFromGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjRemoveReaderFromGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIntroduceCardType
//

class ComIntroduceCardType
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCardName;   // szCardName
        Desc dscPrimaryProvider;    // pguidPrimaryProvider
        Desc dscInterfaces; // rgguidInterfaces
        Desc dscAtr;        // pbAtr
        Desc dscAtrMask;    // pbAtrMask
    } CObjIntroduceCardType_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIntroduceCardType_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIntroduceCardType_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceCardType_request,
            sizeof(CObjIntroduceCardType_request),
            dwExtraLen);
        return (CObjIntroduceCardType_request *)Data();
    };
    CObjIntroduceCardType_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceCardType_response,
            sizeof(CObjIntroduceCardType_response),
            dwExtraLen);
        return (CObjIntroduceCardType_response *)Data();
    };
    CObjIntroduceCardType_response *Receive(CComChannel *pChannel)
    {
        return (CObjIntroduceCardType_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComForgetCardType
//

class ComForgetCardType
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCardName;   // szCardName
    } CObjForgetCardType_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjForgetCardType_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjForgetCardType_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetCardType_request,
            sizeof(CObjForgetCardType_request),
            dwExtraLen);
        return (CObjForgetCardType_request *)Data();
    };
    CObjForgetCardType_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetCardType_response,
            sizeof(CObjForgetCardType_response),
            dwExtraLen);
        return (CObjForgetCardType_response *)Data();
    };
    CObjForgetCardType_response *Receive(CComChannel *pChannel)
    {
        return (CObjForgetCardType_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};
#endif


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Support Routines
//
//      The following services are supplied to simplify the use of the Service
//      Manager API.
//

#if 0
//
// ComCancel
//

class ComCancel
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjCancel_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjCancel_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjCancel_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Cancel_request,
            sizeof(CObjCancel_request),
            dwExtraLen);
        return (CObjCancel_request *)Data();
    };
    CObjCancel_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Cancel_response,
            sizeof(CObjCancel_response),
            dwExtraLen);
        return (CObjCancel_response *)Data();
    };
    CObjCancel_response *Receive(CComChannel *pChannel)
    {
        return (CObjCancel_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComFreeMemory
//

class ComFreeMemory
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        LPVOID pvMem;
    } CObjFreeMemory_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjFreeMemory_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjFreeMemory_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            FreeMemory_request,
            sizeof(CObjFreeMemory_request),
            dwExtraLen);
        return (CObjFreeMemory_request *)Data();
    };
    CObjFreeMemory_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            FreeMemory_response,
            sizeof(CObjFreeMemory_response),
            dwExtraLen);
        return (CObjFreeMemory_response *)Data();
    };
    CObjFreeMemory_response *Receive(CComChannel *pChannel)
    {
        return (CObjFreeMemory_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};
#endif
#endif // _CALCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\scardsvr\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF


$(O)\scardmsg.mc: $(PROJECT_ROOT)\published\scard\scarderr.mc scardmsg.mch
    copy $(PROJECT_ROOT)\published\scard\scarderr.mc + scardmsg.mch $@

$(O)\scardmsg.h $(O)\scardmsg.rc $(O)\msg00001.bin: $(O)\scardmsg.mc
    mc -r .\$(O) -h .\$(O) $(O)\scardmsg.mc

scardsvr.rc2: $(O)\scardmsg.rc

scardmsg.rc: $(O)\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\scredir\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 2000

Module Name:

    makefile.inc.

!ENDIF

$(O)\scredir.idl: $(DS_INC_PATH)\scredir.idl
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\scardsvr\scappdev.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scappdev

Abstract:

    This module provides the device-specific operations that must be performed
    by the controlling resource manager application.  Due to Plug 'n Play, there
    can't be a clean separation between device controller classes and the
    application driving them.  This module provides the hooks to isolate these
    interdependencies as much as possible.

Author:

    Doug Barlow (dbarlow) 4/3/1998

Environment:

    Win32, C++

Notes:

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <winsvc.h>
#include <dbt.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <calcom.h>
#include <scardlib.h>

static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };

static SERVICE_STATUS_HANDLE l_hService = NULL;
static DWORD l_dwType = 0;
static HDEVNOTIFY l_hIfDev = NULL;


/*++

AppInitializeDeviceRegistration:

    This routine is called by a controlling application in order to enable
    PnP and Power Management Events.

Arguments:

    hService supplies the handle to the service application.

    dwType supplies the type of handle supplied.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppInitializeDeviceRegistration")

void
AppInitializeDeviceRegistration(
    SERVICE_STATUS_HANDLE hService,
    DWORD dwType)
{
    DEV_BROADCAST_DEVICEINTERFACE dbcIfFilter;


    //
    // Save off the application information.
    //

    ASSERT(NULL == l_hService);
    l_hService = hService;
    l_dwType = dwType;
    ASSERT(NULL == l_hIfDev);


    //
    // Register for PnP events.
    //

    ZeroMemory(&dbcIfFilter, sizeof(dbcIfFilter));
    dbcIfFilter.dbcc_size = sizeof(dbcIfFilter);
    dbcIfFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    // dbcIfFilter.dbcc_reserved = NULL;
    CopyMemory(
        &dbcIfFilter.dbcc_classguid,
        &l_guidSmartcards,
        sizeof(GUID));
    // dbcIfFilter.dbcc_name[1];

    l_hIfDev = RegisterDeviceNotification(
                    l_hService,
                    &dbcIfFilter,
                    l_dwType);
    if (NULL == l_hIfDev)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Initialize device registration failed to register for PnP events: %1"),
            GetLastError());
    }
}


/*++

AppTerminateDeviceRegistration:

    This routine is called by a controlling application in order to terminate
    PnP and Power Management Events.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppTerminateDeviceRegistration")

void
AppTerminateDeviceRegistration(
    void)
{
    BOOL fSts;


    //
    // Unregister for PnP events.
    //

    if (NULL != l_hIfDev)
    {
        try
        {
            fSts = UnregisterDeviceNotification(l_hIfDev);
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Terminate device registration failed to unregister from PnP events: Exception raised"));
        }
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Terminate device registration failed to unregister from PnP events: %1"),
                GetLastError());
        }
    }

    l_hService = NULL;
    l_dwType = 0;
    l_hIfDev = NULL;
}


/*++

AppRegisterDevice:

    This routine is called by a Reader Device Object to inform the controlling
    application that it exists and is ready to follow the OS rules for removal.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppRegisterDevice")

void
AppRegisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{

    //
    // Platform-specific initialization.
    //

    DEV_BROADCAST_HANDLE dbcHandleFilter;
    HDEVNOTIFY *phDevNotify = (HDEVNOTIFY *)ppvAppState;

    //
    // Register for PnP events.
    //

    if (NULL != l_hService)
    {
        ASSERT(NULL == *phDevNotify);
        ZeroMemory(&dbcHandleFilter, sizeof(dbcHandleFilter));
        dbcHandleFilter.dbch_size = sizeof(dbcHandleFilter);
        dbcHandleFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        dbcHandleFilter.dbch_handle = hReader;

        *phDevNotify = RegisterDeviceNotification(
            l_hService,
            &dbcHandleFilter,
            l_dwType);
        if (NULL == *phDevNotify)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Register device failed to register '%2' for PnP Device removal: %1"),
                GetLastError(),
                szReader);
        }
    }
}


/*++

AppUnregisterDevice:

    This routine is called when a device wants to let the controlling
    application know that it is officially ceasing to exist.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppUnregisterDevice")

void
AppUnregisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{
    try
    {

        //
        // Platform-specific initialization.
        //

        BOOL fSts;
        HDEVNOTIFY hDevNotify = *(HDEVNOTIFY *)ppvAppState;


        //
        // Unregister from PnP events.
        //

        ASSERT(NULL != l_hIfDev);
        if (NULL != hDevNotify)
        {
            try
            {
                fSts = UnregisterDeviceNotification(hDevNotify);
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Unregister device failed to unregister '%2' from PnP Device removal: EXCEPTION"),
                    GetLastError(),
                    szReader);
                fSts = TRUE;
            }
            if (!fSts)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Unregister device failed to unregister '%2' from PnP Device removal: %1"),
                    GetLastError(),
                    szReader);
            }
            *ppvAppState = NULL;
        }
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Unregister device received unexpected exception."));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\scardsvr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SCardSvr.rc
//
#define IDS_STRING1                     1
#define CALSTRING_SCARDSVR              1
#define IDS_PRIMARYSERVICEDISPLAY       1
#define CALSTRING_SCARDDRV              2
#define IDS_LEGACYSERVICEDISPLAY        2
#define IDS_SMARTCARD_INSERTION         3
#define IDS_SMARTCARD_REMOVAL           4
#define IDS_PRIMARYSERVICEDESC          5
#define IDS_LEGACYSERVICEDESC           6
#define IDS_STRING200                   115

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\scardsvr\scardsvr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardSvr

Abstract:

    This module provides the startup logic to make the Calais Resource Manager
    act as a server application under Windows NT.

Author:

    Doug Barlow (dbarlow) 1/16/1997

Environment:

    Win32

Notes:

    This file detects which operating system it's running on, and acts
    accordingly.

--*/

#if defined(_DEBUG)
#define DEBUG_SERVICE
#endif

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <aclapi.h>
#include <dbt.h>
#include <CalServe.h>
#include "resource.h"   // Pick up resource string Ids.

// Keep one global copy of the structure which contains common initialized
// sids.  This way we can control the creation and cleanup of the pointer
// and allow the service worker threads to safely access it.
static PSERVICE_THREAD_SECURITY_INFO g_pServiceThreadSecurityInfo = NULL;

static const DWORD l_dwWaitHint = CALAIS_THREAD_TIMEOUT;
static const GUID l_guidSmartcards
    = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
        0x50DD5230,
        0xBA8A,
        0x11D1,
        { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30}};
static const DWORD l_dwInteractiveAccess
    =                   READ_CONTROL
//                        | SYNCHRONIZE
                        | SERVICE_QUERY_CONFIG
//                      | SERVICE_CHANGE_CONFIG
                        | SERVICE_QUERY_STATUS
                        | SERVICE_ENUMERATE_DEPENDENTS
                        | SERVICE_START
//                      | SERVICE_STOP
//                      | SERVICE_PAUSE_CONTINUE
                        | SERVICE_INTERROGATE
                        | SERVICE_USER_DEFINED_CONTROL
                        | 0;

static const DWORD l_dwSystemAccess
    =                   READ_CONTROL
                        | SERVICE_USER_DEFINED_CONTROL
                        | SERVICE_START
                        | SERVICE_STOP
                        | SERVICE_QUERY_CONFIG
                        | SERVICE_QUERY_STATUS
                        | SERVICE_PAUSE_CONTINUE
                        | SERVICE_INTERROGATE
                        | SERVICE_ENUMERATE_DEPENDENTS
                        | 0;

static CCriticalSectionObject *l_pcsStatusLock = NULL;
static SERVICE_STATUS l_srvStatus, l_srvNonPnP;
static SERVICE_STATUS_HANDLE l_hService = NULL, l_hNonPnP = NULL;
static HANDLE l_hShutdownEvent = NULL;

#ifdef DEBUG_SERVICE
static SERVICE_STATUS l_srvDebug;
static SERVICE_STATUS_HANDLE l_hDebug = NULL;
static HANDLE l_hDebugDoneEvent = NULL;
static void WINAPI
DebugMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv);
static void WINAPI
DebugHandler(
    IN DWORD dwOpCode);
#endif

static void WINAPI
CalaisMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv);
static DWORD WINAPI
CalaisHandlerEx(
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN PVOID EventData,
    IN PVOID pData);

//
// Retrieve the global pointer to the service thread security info
// structure.
//
PSERVICE_THREAD_SECURITY_INFO 
GetServiceThreadSecurityInfo(void)
{
    return g_pServiceThreadSecurityInfo;
}

//
// Frees the SIDs contained in the passed struct, then frees
// the struct itself.  The service must ensure that all service threads
// are shutdown and no longer referencing this structure before
// calling this routine.
//
DWORD FreeServiceThreadSecurityInfo(
    PSERVICE_THREAD_SECURITY_INFO *ppInfo)
{
    PSERVICE_THREAD_SECURITY_INFO pLocal = *ppInfo;

    if (pLocal->pServiceSid)
    {
        FreeSid(pLocal->pServiceSid);
        pLocal->pServiceSid = NULL;
    }
    if (pLocal->pSystemSid)
    {
        FreeSid(pLocal->pSystemSid);
        pLocal->pSystemSid = NULL;
    }

    HeapFree(GetProcessHeap(), 0, pLocal);

    *ppInfo = NULL;

    return SCARD_S_SUCCESS;
}

//
// Builds the SIDs contained in the structure allocated by this function.
//
DWORD InitializeServiceThreadSecurityInfo(
    PSERVICE_THREAD_SECURITY_INFO *ppInfo)
{
    DWORD dwSts = SCARD_S_SUCCESS;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSERVICE_THREAD_SECURITY_INFO pLocal = NULL;

    *ppInfo = NULL;

    pLocal = (PSERVICE_THREAD_SECURITY_INFO) HeapAlloc(
        GetProcessHeap(), 
        HEAP_ZERO_MEMORY, 
        sizeof(SERVICE_THREAD_SECURITY_INFO));

    if (NULL == pLocal)
        return SCARD_E_NO_MEMORY;

    if (! AllocateAndInitializeSid(
        &NtAuthority,
        1,
        SECURITY_LOCAL_SYSTEM_RID, 
        0, 0, 0, 0, 0, 0, 0,
        &pLocal->pSystemSid))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    if (! AllocateAndInitializeSid(
        &NtAuthority,
        1,
        SECURITY_SERVICE_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pLocal->pServiceSid))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    *ppInfo = pLocal;
    pLocal = NULL;

Ret:
    if (pLocal)
        FreeServiceThreadSecurityInfo(&pLocal);

    return dwSts;
}

/*++

Main:

    This routine is the entry point for the Resource Manager.

Arguments:

    Per standard Windows applications

Return Value:

    Per standard Windows applications

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("main")

extern "C" int __cdecl
main(
    int nArgCount,
    LPCTSTR *rgszArgs)
{
    NEW_THREAD;
    SERVICE_TABLE_ENTRY rgsteDispatchTable[3];
    DWORD dwI = 0;
    DWORD dwSts = ERROR_SUCCESS;

    //
    // Command line options are no longer supported.
    //

    if (1 < nArgCount)
    {
        dwSts = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Initiating Smart Card Services Process"));
    try
    {
#ifdef DEBUG_SERVICE
        rgsteDispatchTable[dwI].lpServiceName = (LPTSTR)CalaisString(CALSTR_DEBUGSERVICE);
        rgsteDispatchTable[dwI].lpServiceProc = DebugMain;
        dwI += 1;
#endif
        rgsteDispatchTable[dwI].lpServiceName = (LPTSTR)CalaisString(CALSTR_PRIMARYSERVICE);
        rgsteDispatchTable[dwI].lpServiceProc = CalaisMain;
        dwI += 1;

        rgsteDispatchTable[dwI].lpServiceName = NULL;
        rgsteDispatchTable[dwI].lpServiceProc = NULL;

        if (!StartServiceCtrlDispatcher(rgsteDispatchTable))
        {
            dwSts = GetLastError();
            CalaisError(__SUBROUTINE__, 505, dwSts);
            goto ServiceExit;
        }
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Service Main Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Service Main Routine received unexpected exception."));
        dwSts = SCARD_F_UNKNOWN_ERROR;
    }

ServiceExit:
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Terminating Smart Card Services Process: %1"),
        dwSts);
    return dwSts;

ErrorExit:
    if (ERROR_SUCCESS != dwSts)
    {
        LPCTSTR szErr = NULL;
        
        try
        {
            szErr = ErrorString(dwSts);
        }
        catch(...)
        {
            // Not enough memory to build the error message
            // Nothing else to do
        }

        if (NULL == szErr)
            _tprintf(_T("0x%08x"), dwSts);    // Same form as in ErrorString
                                                // if message can't be found
        else
            _putts(szErr);
    }
    return dwSts;
}


#ifdef _DEBUG
/*++

RunNow:

    This routine kicks off the resource manager running as an application
    process.  That makes the internals easier to debug.

Arguments:

    None

Return Value:

    S_OK

Throws:

    None

Remarks:

    For private debugging only.

Author:

    Doug Barlow (dbarlow) 2/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("RunNow")

static HRESULT
RunNow(
    void)
{
    DWORD dwStatus;

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Initiating Smart Card Services Application"));

    l_pcsStatusLock = new CCriticalSectionObject(CSID_SERVICE_STATUS);
    if (NULL == l_pcsStatusLock)
    {
        CalaisError(__SUBROUTINE__, 501);
        goto FinalExit;
    }
    if (l_pcsStatusLock->InitFailed())
    {
        delete l_pcsStatusLock;
        l_pcsStatusLock = NULL;
        return SCARD_E_NO_MEMORY;
    }
    CalaisMessageInit(TEXT("Calais Application"));

    try
    {
        l_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == l_hShutdownEvent)
        {
            CalaisError(__SUBROUTINE__, 504, GetLastError());
            goto FinalExit;
        }

        //
        // Start the Calais Service.
        //

        dwStatus = CalaisStart();
        if (SCARD_S_SUCCESS != dwStatus)
            goto ServiceExit;


        //
        // Tell interested parties that we've started.
        //

        ResetEvent(AccessStoppedEvent());
        SetEvent(AccessStartedEvent());        

        //
        // Now just hang around until we're supposed to stop.
        //

        dwStatus = WaitForSingleObject(l_hShutdownEvent, INFINITE);
        switch (dwStatus)
        {
        case WAIT_FAILED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager cannot wait for shutdown:  %1"),
                GetLastError());
            break;
        case WAIT_ABANDONED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait abandoned"));
            // Fall through intentionally
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait time out"));
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received invalid wait return code"));
        }

        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisStop();
ServiceExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisInfo(__SUBROUTINE__, DBGT("Calais Stopping"));

FinalExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        if (NULL != l_hShutdownEvent)
        {
            if (!CloseHandle(l_hShutdownEvent))
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close Calais Shutdown Event: %1"),
                    GetLastError());
            l_hShutdownEvent = NULL;
        }
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais RunNow Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais RunNow Routine received unexpected exception."));
    }
    CalaisMessageClose();
    return S_OK;
}
#endif


#ifdef DEBUG_SERVICE
/*++

DebugMain:

    This helper function supplies a simple debuggable process so that
    the resource manager can be debugged as a service.

Arguments:

    dwArgc supplies the number of command line arguments

    pszArgv supplies pointers to each of the arguments.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 8/25/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DebugMain")

static void WINAPI
DebugMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv)
{
    NEW_THREAD;
    BOOL fSts;

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Debug service Start"));
    try
    {
        l_hDebugDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        ASSERT(NULL != l_hDebugDoneEvent);

        l_srvDebug.dwServiceType =              SERVICE_INTERACTIVE_PROCESS |
            SERVICE_WIN32_SHARE_PROCESS;
        l_srvStatus.dwCurrentState =            SERVICE_START_PENDING;
        l_srvDebug.dwControlsAccepted =         SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_SHUTDOWN;
        l_srvDebug.dwWin32ExitCode =            NO_ERROR;
        l_srvDebug.dwServiceSpecificExitCode =  0;
        l_srvDebug.dwCheckPoint =               0;
        l_srvDebug.dwWaitHint =                 0;
        l_hDebug = RegisterServiceCtrlHandler(
            CalaisString(CALSTR_DEBUGSERVICE),
            DebugHandler);
        ASSERT(l_hDebug != NULL);

        l_srvDebug.dwCurrentState =             SERVICE_RUNNING;
        fSts = SetServiceStatus(l_hDebug, &l_srvDebug);
        ASSERT(fSts == TRUE);

        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Ready for debugging"));
        WaitForSingleObject(l_hDebugDoneEvent, INFINITE);

        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Debugger service Stopping"));
        l_srvDebug.dwCurrentState  = SERVICE_STOPPED;
        fSts = SetServiceStatus(l_hDebug, &l_srvDebug);
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Main Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Main Routine received unexpected exception."));
    }

    if (NULL != l_hDebugDoneEvent)
    {
        fSts = CloseHandle(l_hDebugDoneEvent);
        l_hDebugDoneEvent = NULL;
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to close Debug Service Handle: %1"),
                GetLastError());
        }
    }
    CalaisInfo(__SUBROUTINE__, DBGT("Debug service Complete"));
}


/*++

DebugHandler:

    This routine services Debug requests.

Arguments:

    dwOpCode supplies the service request.

Return Value:

    None

Throws:

    None

Remarks:

    Standard Service processing routine.  In theory, this will never get
    called, but just in case...

Author:

    Doug Barlow (dbarlow) 8/25/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DebugHandler")

static void WINAPI
DebugHandler(
    IN DWORD dwOpCode)
{
    NEW_THREAD;
    DWORD nRetVal = NO_ERROR;


    //
    // Process the command.
    //

    CalaisInfo(__SUBROUTINE__, DBGT("Debug Handler Entered"));
    try
    {
        switch (dwOpCode)
        {
        case SERVICE_CONTROL_PAUSE:
            l_srvDebug.dwCurrentState = SERVICE_PAUSED;
            break;

        case SERVICE_CONTROL_CONTINUE:
            l_srvDebug.dwCurrentState = SERVICE_RUNNING;
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            l_srvDebug.dwCurrentState = SERVICE_STOP_PENDING;
            l_srvDebug.dwCheckPoint = 0;
            l_srvDebug.dwWaitHint = 0;
            SetEvent(l_hDebugDoneEvent);
            break;

        default: // No action
            break;
        }

        l_srvDebug.dwWin32ExitCode = nRetVal;
        if (!SetServiceStatus(l_hDebug, &l_srvDebug))
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to register Debug service status: %1"),
                GetLastError());
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Handler Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Handler Routine received unexpected exception."));
    }
    CalaisInfo(__SUBROUTINE__, DBGT("Debug Handler Returned"));
}
#endif

//
// Permanently removes unneeded privileges from the service.
//
DWORD DisableUnnecessaryPrivileges(void)
{
    DWORD dwSts = ERROR_SUCCESS;
    HANDLE hToken = NULL;
    PTOKEN_PRIVILEGES pTokenPrivileges = NULL; 
    DWORD cbTokenPrivileges = 0;
    LUID_AND_ATTRIBUTES rgAttributes [] = {
        { RtlConvertUlongToLuid(SE_SECURITY_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_CREATE_TOKEN_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_TAKE_OWNERSHIP_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_CREATE_PAGEFILE_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_LOCK_MEMORY_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_INCREASE_QUOTA_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_INC_BASE_PRIORITY_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_CREATE_PERMANENT_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_DEBUG_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_AUDIT_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_SYSTEM_ENVIRONMENT_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_BACKUP_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_RESTORE_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_SHUTDOWN_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_PROF_SINGLE_PROCESS_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_SYSTEMTIME_PRIVILEGE), SE_PRIVILEGE_REMOVED },
        { RtlConvertUlongToLuid(SE_UNDOCK_PRIVILEGE), SE_PRIVILEGE_REMOVED }
    };

    // PTOKEN_PRIVILEGES is one ULONG count followed by the privileges
    // array.
    cbTokenPrivileges = 
        sizeof(rgAttributes) + sizeof(ULONG);

    pTokenPrivileges = (PTOKEN_PRIVILEGES) HeapAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY, cbTokenPrivileges);

    if (NULL == pTokenPrivileges)
        return ERROR_NOT_ENOUGH_MEMORY;

    pTokenPrivileges->PrivilegeCount = 
        sizeof(rgAttributes) / sizeof(rgAttributes[0]);

    // Taking the hit of copying the array after it's been set up.  This method
    // seems to generate a lot less code than setting up each array item
    // one by one, but not sure which way is faster.
    memcpy(
        pTokenPrivileges->Privileges,
        rgAttributes,
        sizeof(rgAttributes));

    // Get our token.
    if (! OpenThreadToken(
        GetCurrentThread(), 
        TOKEN_ADJUST_PRIVILEGES, 
        TRUE, 
        &hToken))
    {
        if (! OpenProcessToken(
            GetCurrentProcess(), 
            TOKEN_ADJUST_PRIVILEGES, 
            &hToken))
        {
            dwSts = GetLastError();
            goto Ret;         
        }                  
    }

    // Permenantly remove this set of privileges for this process.
    if (! AdjustTokenPrivileges(
        hToken, 
        FALSE,
        pTokenPrivileges,
        cbTokenPrivileges,
        NULL,
        NULL))
    {
        dwSts = GetLastError();
        goto Ret;
    }

Ret:
    
    if (hToken)
        CloseHandle(hToken);
    if (pTokenPrivileges)
        HeapFree(GetProcessHeap(), 0, pTokenPrivileges);

    return dwSts;
}

/*++

CalaisMain:

    This is the ServiceMain service entry point.  It is only called under the
    NT operating system, and makes that assumption.

Arguments:

    argc supplies the number of command line arguments

    argv supplies pointers to each of the arguments.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMain")

static void WINAPI
CalaisMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv)
{
    NEW_THREAD;
    CalaisMessageInit(CalaisString(CALSTR_PRIMARYSERVICE), NULL, TRUE);
    CalaisInfo(__SUBROUTINE__, DBGT("CalaisMain Entered"));

    l_pcsStatusLock = new CCriticalSectionObject(CSID_SERVICE_STATUS);
    if (NULL == l_pcsStatusLock)
    {
        CalaisError(__SUBROUTINE__, 507);
        return;
    }
    if (l_pcsStatusLock->InitFailed())
    {
        CalaisError(__SUBROUTINE__, 502);
        delete l_pcsStatusLock;
        l_pcsStatusLock = NULL;
        return;
    }

    try
    {
        DWORD dwStatus;
        BOOL fSts;

        l_srvStatus.dwServiceType =
#ifdef DBG
            SERVICE_INTERACTIVE_PROCESS |
#endif
            SERVICE_WIN32_SHARE_PROCESS;
        l_srvStatus.dwCurrentState =            SERVICE_START_PENDING;
        l_srvStatus.dwControlsAccepted =
#ifdef SERVICE_ACCEPT_POWER_EVENTS
            SERVICE_ACCEPT_POWER_EVENTS |
#endif
#ifdef SERVICE_ACCEPT_DEVICE_EVENTS
            SERVICE_ACCEPT_DEVICE_EVENTS |
#endif
            SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_SHUTDOWN;
        l_srvStatus.dwWin32ExitCode           = NO_ERROR;
        l_srvStatus.dwServiceSpecificExitCode = 0;
        l_srvStatus.dwCheckPoint              = 0;
        l_srvStatus.dwWaitHint                = 0;

        l_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == l_hShutdownEvent)
        {
            CalaisError(__SUBROUTINE__, 504, GetLastError());
            goto FinalExit;
        }


        //
        // Initialize the service and the internal data structures.
        //

        l_hService = RegisterServiceCtrlHandlerEx(
                            CalaisString(CALSTR_PRIMARYSERVICE),
                            CalaisHandlerEx,
                            NULL);
        if (NULL == l_hService)
        {
            CalaisError(__SUBROUTINE__, 506, GetLastError());
            goto FinalExit;
        }


        //
        // Tell the Service Manager that we're trying to start.
        //

        {
            LockSection(l_pcsStatusLock, DBGT("Service Start Pending"));
            l_srvStatus.dwCurrentState  = SERVICE_START_PENDING;
            l_srvStatus.dwCheckPoint    = 0;
            l_srvStatus.dwWaitHint      = l_dwWaitHint;

            fSts = SetServiceStatus(l_hService, &l_srvStatus);
            dwStatus = fSts ? ERROR_SUCCESS : GetLastError();
        }

        if (ERROR_SUCCESS != dwStatus)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to update Service Manager status: %1"),
                dwStatus);
        }


        //
        // Register for future Plug 'n Play events.
        //

        try
        {
            AppInitializeDeviceRegistration(
                l_hService,
                DEVICE_NOTIFY_SERVICE_HANDLE);
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager failed to register PnP events"));
        }

        // 
        // Setup the shared security data used by the service threads.
        //
        dwStatus = InitializeServiceThreadSecurityInfo(
            &g_pServiceThreadSecurityInfo);

        if (SCARD_S_SUCCESS != dwStatus)
            goto ServiceExit;

        dwStatus = DisableUnnecessaryPrivileges();

        if (ERROR_SUCCESS != dwStatus)
            goto ServiceExit;

        //
        // Start the Calais Service.
        //

        dwStatus = CalaisStart();
        if (SCARD_S_SUCCESS != dwStatus)
            goto ServiceExit;
        else
        {
            LockSection(l_pcsStatusLock, DBGT("Declare Service Running"));
            l_srvStatus.dwCurrentState  = SERVICE_RUNNING;
            l_srvStatus.dwCheckPoint    = 0;
            l_srvStatus.dwWaitHint      = 0;
            fSts = SetServiceStatus(l_hService, &l_srvStatus);
            dwStatus = fSts ? ERROR_SUCCESS : GetLastError();
        }
        if (ERROR_SUCCESS != dwStatus)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to update Service Manager status: %1"),
                dwStatus);


        //
        // Tell interested parties that we've started.
        //

        ResetEvent(AccessStoppedEvent());
        SetEvent(AccessStartedEvent());
        
        //
        // Now just hang around until we're supposed to stop.
        //

        dwStatus = WaitForSingleObject(l_hShutdownEvent, INFINITE);
        switch (dwStatus)
        {
        case WAIT_FAILED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager cannot wait for shutdown:  %1"),
                GetLastError());
            break;
        case WAIT_ABANDONED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait abandoned"));
            // Fall through intentionally
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait time out"));
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received invalid wait return code"));
        }

        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisStop();
ServiceExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisInfo(__SUBROUTINE__, DBGT("Calais Main Stopping"));
        AppTerminateDeviceRegistration();
        {
            LockSection(l_pcsStatusLock, DBGT("Declare service stopped"));
            l_srvStatus.dwCurrentState  = SERVICE_STOPPED;
            l_srvStatus.dwWin32ExitCode = dwStatus;
            l_srvStatus.dwCheckPoint    = 0;
            l_srvStatus.dwWaitHint      = 0;
            fSts = SetServiceStatus(l_hService, &l_srvStatus);
            dwStatus = fSts ? ERROR_SUCCESS : GetLastError();
        }
        if (ERROR_SUCCESS != dwStatus)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to update Service Manager status: %1"),
                dwStatus);

FinalExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        if (NULL != l_hShutdownEvent)
        {
            fSts = CloseHandle(l_hShutdownEvent);
            l_hShutdownEvent = NULL;
            if (!fSts)
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close Calais Shutdown Event: %1"),
                    GetLastError());
        }
        ReleaseAllEvents();

        if (NULL != g_pServiceThreadSecurityInfo)
            FreeServiceThreadSecurityInfo(
                &g_pServiceThreadSecurityInfo);
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais Main Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais Main Routine received unexpected exception."));
    }
    CalaisInfo(__SUBROUTINE__, DBGT("CalaisMain Ended"));
    CalaisMessageClose();
    if (NULL != l_pcsStatusLock)
    {
        delete l_pcsStatusLock;
        l_pcsStatusLock = NULL;
    }
}


/*++

CalaisHandlerEx:

    The handler service function for Calais on NT5.  This version gets PnP and
    Power Management notifications, too.

Arguments:

    dwOpCode supplies the operation to perform.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisHandlerEx")

static DWORD WINAPI
CalaisHandlerEx(
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN PVOID EventData,
    IN PVOID pData)
{
    NEW_THREAD;
    DWORD nRetVal = NO_ERROR;
    LockSection(l_pcsStatusLock, DBGT("Responding to service event"));

    CalaisDebug((DBGT("SCARDSVR!CalaisHandlerEx: Enter\n")));
    try
    {

        //
        // Process the command.
        //

        switch (dwControl)
        {
        case SERVICE_CONTROL_PAUSE:
            // ?noSupport?
            l_srvStatus.dwCurrentState = SERVICE_PAUSED;
            break;

        case SERVICE_CONTROL_CONTINUE:
            l_srvStatus.dwCurrentState = SERVICE_RUNNING;
            // ?noSupport?
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            l_srvStatus.dwCurrentState = SERVICE_STOP_PENDING;
            l_srvStatus.dwCheckPoint = 0;
            l_srvStatus.dwWaitHint = l_dwWaitHint;
            if (!SetEvent(l_hShutdownEvent))
                CalaisError(__SUBROUTINE__, 516, GetLastError());
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
        {
            DWORD dwSts;
            CTextString tzReader;
            LPCTSTR szReader = NULL;
            DEV_BROADCAST_HDR *pDevHdr = (DEV_BROADCAST_HDR *)EventData;

            CalaisInfo(
                __SUBROUTINE__,
                DBGT("Processing Device Event"));
            switch (dwEventType)
            {
            //
            // A device has been inserted and is now available.
            case DBT_DEVICEARRIVAL:
            {
                DEV_BROADCAST_DEVICEINTERFACE *pDev
                    = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Arrival Event"));
                    if (DBT_DEVTYP_DEVICEINTERFACE == pDev->dbcc_devicetype)
                    {
                        ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE)
                               < pDev->dbcc_size);
                        ASSERT(0 == memcmp(
                                        &pDev->dbcc_classguid,
                                        &l_guidSmartcards,
                                        sizeof(GUID)));
                        ASSERT(0 != pDev->dbcc_name[0]);

                        if (0 == pDev->dbcc_name[1])
                            tzReader = (LPCWSTR)pDev->dbcc_name;
                        else
                            tzReader = (LPCTSTR)pDev->dbcc_name;
                        szReader = tzReader;
                        dwSts = CalaisAddReader(szReader, RDRFLAG_PNPMONITOR);
                        if (ERROR_SUCCESS != dwSts)
                            throw dwSts;
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("New device '%1' added."),
                            szReader);
                    }
                    else
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device arrival event."));
                }
                catch (DWORD dwError)
                {
                    CalaisError(__SUBROUTINE__, 514, dwError, szReader);
                }
                catch (...)
                {
                    CalaisError(__SUBROUTINE__, 517, szReader);
                }
                break;
            }

            //
            // Permission to remove a device is requested. Any application can
            // deny this request and cancel the removal.
            case DBT_DEVICEQUERYREMOVE:
            {
                DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Query Remove Event"));
                    if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                    {
                        ASSERT(FIELD_OFFSET(
                                    DEV_BROADCAST_HANDLE,
                                    dbch_eventguid)
                                <= pDev->dbch_size);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if (NULL != pDev->dbch_handle)
                        {
                            if (!CalaisQueryReader(pDev->dbch_handle))
                            {
                                CalaisError(
                                    __SUBROUTINE__,
                                    520,
                                    TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                                nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                            }
                            else
                            {
                                szReader = CalaisDisableReader(
                                                (LPVOID)pDev->dbch_handle);
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Device '%1' removal pending."),
                                    szReader);
                            }
                        }
                        else
                        {
                            CalaisError(
                                __SUBROUTINE__,
                                523,
                                TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                            nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                        }
                    }
                    else
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device removal query event."));
                        nRetVal = TRUE;
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error querying device busy state on reader %2: %1"),
                        dwError,
                        szReader);
                    nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Exception querying device busy state on reader %1"),
                        szReader);
                    CalaisError(
                        __SUBROUTINE__,
                        522,
                        TEXT("DBT_DEVICEQUERYREMOVE"));
                    nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                }
                break;
            }

            //
            // Request to remove a device has been canceled.
            case DBT_DEVICEQUERYREMOVEFAILED:
            {
                CBuffer bfDevice;
                DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Query Remove Failed Event"));
                    if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                    {
                        ASSERT(FIELD_OFFSET(
                                    DEV_BROADCAST_HANDLE,
                                    dbch_eventguid)
                                <= pDev->dbch_size);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if (NULL != pDev->dbch_handle)
                        {
                            szReader = CalaisConfirmClosingReader(
                                            pDev->dbch_handle);
                            if (NULL != szReader)
                            {
                                bfDevice.Set(
                                            (LPBYTE)szReader,
                                            (lstrlen(szReader) + 1) * sizeof(TCHAR));
                                szReader = (LPCTSTR)bfDevice.Access();
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Smart Card Resource Manager asked to cancel release of reader %1"),
                                    szReader);
                                if (NULL != pDev->dbch_hdevnotify)
                                {
                                    CalaisRemoveReader(
                                        (LPVOID)pDev->dbch_hdevnotify);
                                    if (NULL != szReader)
                                        dwSts = CalaisAddReader(
                                                    szReader,
                                                    RDRFLAG_PNPMONITOR);
                                }
                            }
                            else
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Smart Card Resource Manager asked to cancel release on unreleased reader"));
                        }
                        else
                            CalaisError(
                                __SUBROUTINE__,
                                521,
                                TEXT("DBT_DEVICEQUERYREMOVEFAILED/dbch_handle"));
                    }
                    else
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device removal query failure event."));
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error cancelling removal on reader %2: %1"),
                        dwError,
                        szReader);
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Exception cancelling removal on reader %1"),
                        szReader);
                    CalaisError(
                        __SUBROUTINE__,
                        513,
                        TEXT("DBT_DEVICEQUERYREMOVEFAILED"));
                }
                break;
            }

            //
            // Device is about to be removed. Cannot be denied.
            case DBT_DEVICEREMOVEPENDING:
            {
                DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Remove Pending Event"));
                    if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                    {
                        ASSERT(FIELD_OFFSET(
                                    DEV_BROADCAST_HANDLE,
                                    dbch_eventguid)
                                <= pDev->dbch_size);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if (NULL != pDev->dbch_handle)
                        {
                            szReader = CalaisDisableReader(pDev->dbch_handle);
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Device '%1' being removed."),
                                szReader);
                        }
                        else
                            CalaisError(
                                __SUBROUTINE__,
                                512,
                                TEXT("DBT_DEVICEREMOVEPENDING/dbch_handle"));
                    }
                    else
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device removal pending event."));
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error removing reader %2: %1"),
                        dwError,
                        szReader);
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Exception removing reader %1"),
                        szReader);
                    CalaisError(
                        __SUBROUTINE__,
                        511,
                        TEXT("DBT_DEVICEREMOVEPENDING"));
                }
                break;
            }

            //
            // Device has been removed.
            case DBT_DEVICEREMOVECOMPLETE:
            {
                try
                {
                    switch (pDevHdr->dbch_devicetype)
                    {
                    case DBT_DEVTYP_HANDLE:
                    {
                        DEV_BROADCAST_HANDLE *pDev =
                            (DEV_BROADCAST_HANDLE *)EventData;
                        try
                        {
                            CalaisInfo(
                                __SUBROUTINE__,
                                DBGT("Processing Device Remove Complete by handle Event"));
                            ASSERT(FIELD_OFFSET(
                                        DEV_BROADCAST_HANDLE,
                                        dbch_eventguid)
                                    <= pDev->dbch_size);
                            ASSERT(DBT_DEVTYP_HANDLE == pDev->dbch_devicetype);
                            ASSERT(NULL != pDev->dbch_handle);
                            ASSERT(NULL != pDev->dbch_hdevnotify);

                            if ((NULL != pDev->dbch_handle)
                                && (NULL != pDev->dbch_hdevnotify))
                            {
                                szReader = CalaisDisableReader(
                                                pDev->dbch_handle);
                                CalaisRemoveReader(
                                    (LPVOID)pDev->dbch_hdevnotify);
                                if (NULL != szReader)
                                    CalaisWarning(
                                        __SUBROUTINE__,
                                        DBGT("Device '%1' removed."),
                                        szReader);
                            }
                            else
                            {
                                if (NULL == pDev->dbch_handle)
                                    CalaisError(
                                        __SUBROUTINE__,
                                        510,
                                        TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_handle"));
                                if (NULL == pDev->dbch_hdevnotify)
                                    CalaisError(
                                        __SUBROUTINE__,
                                        519,
                                        TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_hdevnotify"));
                            }
                        }
                        catch (DWORD dwError)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Error completing removal of reader %2: %1"),
                                dwError,
                                szReader);
                        }
                        catch (...)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Exception completing removal of reader %1"),
                                szReader);
                            CalaisError(
                                __SUBROUTINE__,
                                509,
                                TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE"));
                        }
                        break;
                    }
                    case DBT_DEVTYP_DEVICEINTERFACE:
                    {
                        DEV_BROADCAST_DEVICEINTERFACE *pDev
                            = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;

                        try
                        {
                            CalaisInfo(
                                __SUBROUTINE__,
                                DBGT("Processing Device Remove Complete by interface Event"));
                            ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE)
                                    < pDev->dbcc_size);
                            ASSERT(DBT_DEVTYP_DEVICEINTERFACE
                                    == pDev->dbcc_devicetype);
                            ASSERT(0 == memcmp(
                                            &pDev->dbcc_classguid,
                                            &l_guidSmartcards,
                                            sizeof(GUID)));
                            ASSERT(0 != pDev->dbcc_name[0]);

                            if (0 == pDev->dbcc_name[1])
                                tzReader = (LPCWSTR)pDev->dbcc_name;
                            else
                                tzReader = (LPCTSTR)pDev->dbcc_name;
                            szReader = tzReader;
                            dwSts = CalaisRemoveDevice(szReader);
                            if (ERROR_SUCCESS == dwSts)
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Device '%1' Removed."),
                                    szReader);
                            else
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Error removing device '%2': %1"),
                                    dwSts,
                                    szReader);
                        }
                        catch (DWORD dwError)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Error completing removal of reader %2: %1"),
                                dwError,
                                szReader);
                        }
                        catch (...)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Exception completing removal of reader %1"),
                                szReader);
                            CalaisError(
                                __SUBROUTINE__,
                                508,
                                TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_DEVICEINTERFACE"));
                        }
                        break;
                    }
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Unrecognized PnP Device Removal Type"));
                        break;
                    }
                }
                catch (...)
                {
                    CalaisError(
                        __SUBROUTINE__,
                        518,
                        TEXT("DBT_DEVICEREMOVECOMPLETE"));
                }
                break;
            }

            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Unrecognized PnP Event"));
                break;
            }
            break;
        }

        case SERVICE_CONTROL_POWEREVENT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received Power Event!"));
            break;

        default: // No action
            break;
        }
    }
    catch (DWORD dwError)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Smart Card Resource Manager received error on service action: %1"),
            dwError);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Smart Card Resource Manager recieved exception on service action"));
    }

    l_srvStatus.dwWin32ExitCode = nRetVal;
    if (!SetServiceStatus(l_hService, &l_srvStatus))
        CalaisError(__SUBROUTINE__, 515, GetLastError());

    CalaisDebug(
        (DBGT("SCARDSVR!CalaisHandlerEx: Exit (%lx)\n"),
        nRetVal));
    return nRetVal;
}


/*++

CalaisTerminate:

    This function is called if the C Run Time Library wants to declare a fault.
    If we get here, we're not coming back.

Arguments:

    None

Return Value:

    None (program exits on return)

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 12/2/1998

--*/

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisTerminate")
void __cdecl
CalaisTerminate(
    void)
{
    ResetEvent(AccessStartedEvent());
    SetEvent(AccessStoppedEvent());
#ifdef DBG
    TCHAR szTid[sizeof(DWORD) * 2 + 3];
    _stprintf(szTid, TEXT("0x%p"), GetCurrentThreadId);
    CalaisError(
        __SUBROUTINE__,
        DBGT("Fatal Unhandled Exception: TID=%1"),
        szTid);
    DebugBreak();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\scardsvr\waitsam.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    waitsam

Abstract:

    This module provides back-door access to some internal NT routines.  This
    is needed to get at the SAM Startup Event -- it has an illegal name from
    the Win32 routines, so we have to sneak back and pull it up from NT
    directly.

Author:

    Doug Barlow (dbarlow) 5/3/1998

Notes:

    As taken from code suggested by MacM

--*/

#define __SUBROUTINE__
#if !defined(_X86_) && !defined(_ALPHA_)
#define _X86_ 1
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#ifndef UNICODE
#define UNICODE     // Force this module to use UNICODE.
#endif
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <windows.h>

/*++

AccessSAMEvent:

    This procedure opens the handle to the SAM Startup Event handle.

Arguments:

    None

Return Value:

    The handle, or NULL on an error.

Author:

    Doug Barlow (dbarlow) 5/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessSAMEvent")

HANDLE
AccessSAMEvent(
    void)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    CHandleObject EventHandle(DBGT("Event Handle from AccessSAMEvent"));

    //
    // Open the event
    //
    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED" );
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtCreateEvent( &EventHandle,
        SYNCHRONIZE,
        &EventAttributes,
        NotificationEvent,
        FALSE );


    //
    // If the event already exists, just open it.
    //
    if( Status == STATUS_OBJECT_NAME_EXISTS || Status == STATUS_OBJECT_NAME_COLLISION ) {

        Status = NtOpenEvent( &EventHandle,
            SYNCHRONIZE,
            &EventAttributes );
    }
    return EventHandle;
}


/*++

WaitForSAMEvent:

    This procedure can be used to wait for the SAM Startup event using NT
    internal calls.  I don't know how to specify a timeout value, so this
    routine isn't complete.

Arguments:

    hSamActive supplies the handle to the SAM Startup Event.

    dwTimeout supplies the time to wait for the startup event, in milliseconds.

Return Value:

    TRUE - The event was set.

    FALSE - The timeout expired

Throws:

    Any errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 5/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForSAMEvent")

BOOL
WaitForSAMEvent(
    HANDLE hSamActive,
    DWORD dwTimeout)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = NtWaitForSingleObject(hSamActive, TRUE, NULL);
    return Status;
}


/*++

CloseSamEvent:

    This procedure uses the NT internal routine to close a handle.

Arguments:

    hSamActive supplies the handle to be closed.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CloseSAMEvent")

void
CloseSAMEvent(
    HANDLE hSamActive)
{
    NtClose(hSamActive);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\inc\locks.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Locks

Abstract:

    The following three classes implement a simple single writer, multiple
    readers lock.  CAccessLock is the lock, then the CLockRead and CLockWrite
    objects envoke the lock while they are in scope.  They are all implemented
    inline.

    The CMultiEvent class implements an automatic waitable object that will
    release all threads waiting on it when signaled.

Author:

    Doug Barlow (dbarlow) 10/24/1996

Environment:

    Win32, C++ w/ exceptions

Notes:

    ?Notes?

--*/

#ifndef _LOCKS_H_
#define _LOCKS_H_

#include <WinSCard.h>
#include "CalMsgs.h"
#include <SCardLib.h>
#ifdef DBG
#define REASONABLE_TIME 2 * 60 * 1000   // Two minutes
#else
#define REASONABLE_TIME INFINITE
#endif

extern DWORD
WaitForAnyObject(
    DWORD dwTimeout,
    ...);

extern DWORD
WaitForAnObject(
    HANDLE hWaitOn,
    DWORD dwTimeout);

#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForEverObject")

inline void
WaitForEverObject(
    HANDLE hWaitOn,
    DWORD dwTimeout,
    DEBUG_TEXT szReason,
    LPCTSTR szObject = NULL)
{
    DWORD dwSts;
    while (ERROR_SUCCESS != (dwSts = WaitForAnObject(hWaitOn, dwTimeout)))
        CalaisWarning(__SUBROUTINE__, szReason, dwSts, szObject);
}
inline void
WaitForEverObject(
    HANDLE hWaitOn,
    DWORD dwTimeout,
    DEBUG_TEXT szReason,
    DWORD dwObject)
{
    DWORD dwSts;
    TCHAR szNum[16];

    wsprintf(szNum, TEXT("0x%08x"), dwObject);
    while (ERROR_SUCCESS != (dwSts = WaitForAnObject(hWaitOn, dwTimeout)))
        CalaisWarning(__SUBROUTINE__, szReason, dwSts, szNum);
}
#define WaitForever(hWaitOn, dwTimeout, szReason, szObject) \
    WaitForEverObject(hWaitOn, dwTimeout, szReason, szObject)

#else

inline void
WaitForEverObject(
    HANDLE hWaitOn)
{
    while (ERROR_SUCCESS != WaitForAnObject(hWaitOn, INFINITE));
        // Empty body
}
#define WaitForever(hWaitOn, dwTimeout, szReason, szObject) \
    WaitForEverObject(hWaitOn)

#endif


//
//  Critical Section Support.
//
//  The following Classes and Macros aid in debugging Critical Section
//  Conflicts.
//

//
// Critical section Ids.  Locks must be obtained in the order from lowest
// to highest.  An attempt to access a lower-numbered lock while holding a
// higher numbered lock will result in an ASSERT.
//

// Server side lock IDs
#define CSID_SERVICE_STATUS 0   // Service Status Critical Section
#define CSID_CONTROL_LOCK   1   // Lock for Calais control commands.
#define CSID_SERVER_THREADS 2   // Lock for server thread enumeration.
#define CSID_MULTIEVENT     3   // MultiEvent Critical Access Section
#define CSID_MUTEX          4   // Mutex critical access section
#define CSID_ACCESSCONTROL  5   // Access Lock control
#define CSID_TRACEOUTPUT    6   // Lock for tracing output.

// Client side lock IDs
#define CSID_USER_CONTEXT   0   // User context lock
#define CSID_SUBCONTEXT     1   // Subcontext lock


//
//==============================================================================
//
//  CCriticalSectionObject
//

class CCriticalSectionObject
{
public:

    //  Constructors & Destructor
    CCriticalSectionObject(DWORD dwCsid);
    ~CCriticalSectionObject();

    //  Properties
    //  Methods
    virtual void Enter(DEBUG_TEXT szOwner, DEBUG_TEXT szComment);
    virtual void Leave(void);
    virtual BOOL InitFailed(void) { return m_fInitFailed; }

#ifdef DBG
    LPCTSTR Description(void) const;

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CCriticalSectionObject::Owner")
    LPCTSTR Owner(void) const
        { return (LPCTSTR)m_bfOwner.Access(); };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CCriticalSectionObject::Comment")
    LPCTSTR Comment(void) const
        { return (LPCTSTR)m_bfComment.Access(); };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CCriticalSectionObject::IsOwnedByMe")
    BOOL IsOwnedByMe(void) const
        { return (GetCurrentThreadId() == m_dwOwnerThread); };
#endif
    //  Operators

protected:
    //  Properties
    CRITICAL_SECTION m_csLock;
    BOOL m_fInitFailed;
#ifdef DBG
    DWORD m_dwCsid;
    CBuffer m_bfOwner;
    CBuffer m_bfComment;
    DWORD m_dwOwnerThread;
    DWORD m_dwRecursion;    
#endif

    //  Methods
};


//
//==============================================================================
//
//  COwnCriticalSection
//

class COwnCriticalSection
{
public:

    //  Constructors & Destructor
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("COwnCriticalSection::COwnCriticalSection")
        COwnCriticalSection(
            CCriticalSectionObject *pcs,
            DEBUG_TEXT szSubroutine,
            DEBUG_TEXT szComment)
        {
            m_pcsLock = pcs;
            m_pcsLock->Enter(szSubroutine, szComment);
        };

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("COwnCriticalSection::~COwnCriticalSection")
    ~COwnCriticalSection()
    {
        m_pcsLock->Leave();
    };

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CCriticalSectionObject *m_pcsLock;

    //  Methods
};

#define LockSection(cx, reason) \
        COwnCriticalSection csLock(cx, __SUBROUTINE__, reason)

#define LockSection2(cx, reason) \
        COwnCriticalSection csLock2(cx, __SUBROUTINE__, reason)

#ifndef DBG

//
//In-line the simple Critical Section calls.
//

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::CCriticalSectionObject")
inline
CCriticalSectionObject::CCriticalSectionObject(
    DWORD dwCsid)
{
    m_fInitFailed = FALSE;
    try {
        // Preallocate the event used by the EnterCriticalSection
        // function to prevent an exception from being thrown in
        // CCriticalSectionObject::Enter
        if (! InitializeCriticalSectionAndSpinCount(
                &m_csLock, 0x80000000))
            m_fInitFailed = TRUE;
    }
    catch (HRESULT hr) {
        m_fInitFailed = TRUE;
    }
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::~CCriticalSectionObject")
inline
CCriticalSectionObject::~CCriticalSectionObject()
{
    if (m_fInitFailed)
        return;

    DeleteCriticalSection(&m_csLock);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Enter")
inline void
CCriticalSectionObject::Enter(
    DEBUG_TEXT szOwner,
    DEBUG_TEXT szComment)
{
    if (m_fInitFailed)
        throw (DWORD)SCARD_E_NO_MEMORY;

    EnterCriticalSection(&m_csLock);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Leave")
inline void
CCriticalSectionObject::Leave(
    void)
{
    LeaveCriticalSection(&m_csLock);
}

#endif // !DBG


//
//==============================================================================
//
//  CHandleObject
//

class CHandleObject
{
public:

    //  Constructors & Destructor
    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::CHandleObject")
    CHandleObject(DEBUG_TEXT szName)
#ifdef DBG
    :   m_bfName((LPCBYTE)szName, (lstrlen(szName) + 1) * sizeof(TCHAR))
#endif
    {
        m_hHandle = NULL;
        m_dwError = ERROR_SUCCESS;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::~CHandleObject")
    ~CHandleObject()
    {
        if (IsValid())
        {
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unclosed handle '%1' -- fixing."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
            Close();
        }
    };

    //  Properties
    //  Methods
    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::IsValid")
    BOOL IsValid(void) const
    {
        return (NULL != m_hHandle) && (INVALID_HANDLE_VALUE != m_hHandle);
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Value")
    HANDLE Value(void) const
    {
#ifdef _DEBUG
        if (!IsValid())
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Accessing invalid '%1' handle value."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        return m_hHandle;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::GetLastError")
    DWORD GetLastError(void) const
    {
        return m_dwError;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Open")
    HANDLE Open(HANDLE h)
    {
        if ((NULL == h) || (INVALID_HANDLE_VALUE == h))
        {
            m_dwError = ::GetLastError();
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Attempt to assign invalid handle value to '%1'."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        }
        else
            m_dwError = ERROR_SUCCESS;
        if (IsValid())
        {
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Overwriting handle '%1' -- fixing"),
                (DEBUG_TEXT)m_bfName.Access());
#endif
            Close();
        }
        m_hHandle = h;
        return m_hHandle;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Close")
    DWORD Close(void)
    {
        DWORD dwSts = ERROR_SUCCESS;

        if (IsValid())
        {
            BOOL fSts;

            fSts = CloseHandle(m_hHandle);
#ifdef DBG
            if (!fSts)
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close handle '%2': %1"),
                    dwSts,
                    (DEBUG_TEXT)m_bfName.Access());
            }
#endif
            m_hHandle = NULL;
        }
#ifdef DBG
        else
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Attempt to re-close handle '%1'"),
                (DEBUG_TEXT)m_bfName.Access());
        }
#endif
        return dwSts;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Relinquish")
    HANDLE Relinquish(void)
    {
        HANDLE hTmp = m_hHandle;
#ifdef _DEBUG
        if (!IsValid())
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Relinquishing invalid '%1' handle"),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        m_hHandle = NULL;
        return hTmp;
    };

    //  Operators

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::operator HANDLE")
    operator HANDLE(void) const
    {
#ifdef _DEBUG
        ASSERT(IsValid());  // Assert should be in callers
#endif
        return Value();
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::operator=")
    HANDLE operator=(HANDLE h)
    {
        return Open(h);
    };

protected:
    //  Properties
    HANDLE m_hHandle;
    DWORD m_dwError;
#ifdef DBG
    CBuffer m_bfName;
#endif

    //  Methods
};

#ifdef DBG
//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicValArray
{
public:

    //  Constructors & Destructor

    CDynamicValArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicValArray()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T 
    Set(
        IN int nItem,
        IN T pvItem);

    T const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };

    //  Operators
    T const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T *
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T
CDynamicValArray<T>::Set(
    IN int nItem,
    IN T pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T *newList = new T[newSize];
        if (NULL == newList)
            throw (DWORD)ERROR_OUTOFMEMORY;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;
}

/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T const
CDynamicValArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return 0;
    else
        return m_pvList[nItem];
}

#endif


//
//==============================================================================
//
//  CAccessLock
//

class CAccessLock
{
public:
    //  Constructors & Destructor

    CAccessLock(DWORD dwTimeout = CALAIS_LOCK_TIMEOUT);
    ~CAccessLock();

    BOOL InitFailed(void) { return m_csLock.InitFailed(); }

#ifdef DBG
    BOOL NotReadLocked(void);
    BOOL IsReadLocked(void);
    BOOL NotWriteLocked(void);
    BOOL IsWriteLocked(void);
#endif

protected:
    //  Properties

    CCriticalSectionObject m_csLock;
    DWORD m_dwReadCount;
    DWORD m_dwWriteCount;
    DWORD m_dwTimeout;
    CHandleObject m_hSignalNoReaders;
    CHandleObject m_hSignalNoWriters;
    DWORD m_dwOwner;
#ifdef DBG
    CDynamicValArray<DWORD> m_rgdwReaders;
#endif


    //  Methods

    void Wait(HANDLE hSignal);
    void Signal(HANDLE hSignal);
    void Unsignal(HANDLE hSignal);

    void WaitOnReaders(void)
    {
        Wait(m_hSignalNoReaders);
    };
    void WaitOnWriters(void)
    {
        Wait(m_hSignalNoWriters);
    };
    void SignalNoReaders(void)
    {
        Signal(m_hSignalNoReaders);
    };
    void SignalNoWriters(void)
    {
        Signal(m_hSignalNoWriters);
    };
    void UnsignalNoReaders(void)
    {
        Unsignal(m_hSignalNoReaders);
    };
    void UnsignalNoWriters(void)
    {
        Unsignal(m_hSignalNoWriters);
    };

    friend class CLockRead;
    friend class CLockWrite;
};


//
//==============================================================================
//
//  CLockRead
//

class CLockRead
{
public:

    //  Constructors & Destructor
    CLockRead(CAccessLock *pLock);
    ~CLockRead();

    BOOL InitFailed(void) { return m_pLock->InitFailed(); }

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CAccessLock * m_pLock;

    //  Methods
};


//
//==============================================================================
//
//  CLockWrite
//

class CLockWrite
{
public:

    //  Constructors & Destructor

    CLockWrite(CAccessLock *pLock);
    ~CLockWrite();

    BOOL InitFailed(void) { return m_pLock->InitFailed(); }

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties

    CAccessLock *m_pLock;


    //  Methods
};


//
//==============================================================================
//
//  CMutex
//

class CMutex
{
public:

    //  Constructors & Destructor
    CMutex();
    ~CMutex();

    //  Properties

    //  Methods
    void Grab(void);
    BOOL Share(void);
    void Invalidate(void);
    void Take(void);
    BOOL IsGrabbed(void);
    BOOL IsGrabbedByMe(void);
    BOOL IsGrabbedBy(DWORD dwThreadId);
    BOOL InitFailed(void) { return m_csAccessLock.InitFailed(); }

    //  Operators

protected:
    //  Properties
    CCriticalSectionObject m_csAccessLock;
    DWORD m_dwOwnerThreadId;
    DWORD m_dwGrabCount;
    DWORD m_dwValidityCount;
    CHandleObject m_hAvailableEvent;

    //  Methods
};


//
//==============================================================================
//
//  CMultiEvent
//

class CMultiEvent
{
public:

    //  Constructors & Destructor

    CMultiEvent();
    ~CMultiEvent();


    //  Properties
    //  Methods
    HANDLE WaitHandle(void);
    void Signal(void);
    BOOL InitFailed(void) { return m_csLock.InitFailed(); }

    //  Operators

protected:
    //  Properties
    CCriticalSectionObject m_csLock;
    HANDLE m_rghEvents[4];  // Adjust this as necessary.
    DWORD m_dwEventIndex;

    //  Methods
};

#endif // _LOCKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\scredir\scredir.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    scredir

Abstract:

    This module redirects the SCard* API calls

Author:

    reidk 7/27/2000


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <winscard.h>
#include "scredir.h"
#include "scioctl.h"
#include "calmsgs.h"
#include "calaislb.h"
#include "rdpdr.h"

//
// from secpkg.h
//
typedef NTSTATUS (NTAPI LSA_IMPERSONATE_CLIENT) (VOID);
typedef LSA_IMPERSONATE_CLIENT * PLSA_IMPERSONATE_CLIENT;


#define wszWinSCardRegKeyRedirector (L"Software\\Microsoft\\SmartCard\\Redirector")
#define wszWinSCardRegVersion       (L"Version")
#define wszWinSCardRegName          (L"Name")
#define wszWinSCardRegNameValue     (L"scredir.dll")

// This is the version number of the interface.
// The high word is the major version which must match exactly.
// The low word is the minor version. The dll must implement
// a minor version that is greater than or equal to the system
// minor version. This means that if we add a new funtion to the API,
// we increase the minor version and a remoting DLL can still be
// backward compatible. This is just like RPC version numbers
#define REDIRECTION_VERSION 0x00010000


#define ERROR_RETURN(x)     lReturn = x; goto ErrorReturn;


#define MAX_SCARDCONTEXT_SIZE 32
#define MAX_SCARDHANDLE_SIZE  32

typedef struct _REDIR_LOCAL_SCARDCONTEXT
{
    REDIR_SCARDCONTEXT  Context;
    HANDLE              hHeap;
} REDIR_LOCAL_SCARDCONTEXT;

typedef struct _REDIR_LOCAL_SCARDHANDLE
{
    REDIR_LOCAL_SCARDCONTEXT    *pRedirContext;
    REDIR_SCARDHANDLE           Handle;
} REDIR_LOCAL_SCARDHANDLE;

//
// This structure is used to maintain a list of buffers that are
// used for the _SendSCardIOCTL calls
//
#define INITIAL_BUFFER_SIZE   512
typedef struct _BUFFER_LIST_STRUCT
{
    void            *pNext;
    BOOL            fInUse;
    BYTE            *pbBytes;
    unsigned long   cbBytes;
    unsigned long   cbBytesUsed;
} BUFFER_LIST_STRUCT;


HMODULE             g_hModule                               = NULL;

CRITICAL_SECTION    g_CreateCS;
CRITICAL_SECTION    g_SetStartedEventStateCS;
CRITICAL_SECTION    g_StartedEventCreateCS;
CRITICAL_SECTION    g_ProcessDetachEventCreateCS;
CRITICAL_SECTION    g_BufferListCS;

HANDLE              g_hRdpdrDeviceHandle                    = INVALID_HANDLE_VALUE;
HANDLE              g_hRedirStartedEvent                    = NULL;
HANDLE              g_hProcessDetachEvent                   = NULL;
LONG                g_lProcessDetachEventClients            = 0;

BOOL                g_fInTheProcessOfSettingStartedEvent    = FALSE;
HANDLE              g_hRegisteredWaitHandle                 = NULL;
HANDLE              g_hWaitEvent                            = NULL;
IO_STATUS_BLOCK     g_StartedStatusBlock;

HANDLE              g_hUnifiedStartedEvent                  = NULL;

BOOL                g_fInProcessDetach                      = FALSE;

BUFFER_LIST_STRUCT  *g_pBufferList                          = NULL;

#define IOCTL_RETURN_BUFFER_SIZE   256
BYTE                g_rgbIOCTLReturnBuffer[IOCTL_RETURN_BUFFER_SIZE];
unsigned long       g_cbIOCTLReturnBuffer;


#define _TRY_(y)    __try                                   \
                    {                                       \
                        y;                                  \
                    }                                       \
                    __except(EXCEPTION_EXECUTE_HANDLER)     \
                    {                                       \
                        ERROR_RETURN(GetExceptionCode())    \
                    }

#define _TRY_2(y)   __try                                   \
                    {                                       \
                        y;                                  \
                    }                                       \
                    __except(EXCEPTION_EXECUTE_HANDLER){} // do nothing



//
// Forward declarations
//
NTSTATUS
_SendSCardIOCTLWithWaitForCallback(
    ULONG               IoControlCode,
    PVOID               InputBuffer,
    ULONG               InputBufferLength,
    WAITORTIMERCALLBACK Callback);

void
SafeMesHandleFree(
    handle_t            *ph);

LONG
I_DecodeLongReturn(
    BYTE *pb,
    unsigned long cb);

BOOL
_SetStartedEventToCorrectState(void);


//---------------------------------------------------------------------------------------
//
//  MIDL allocation routines
//
//---------------------------------------------------------------------------------------
void __RPC_FAR *__RPC_USER  MIDL_user_allocate(size_t size)
{
    void *pv;

    if (NULL == (pv = (void *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size)))
    {
        SetLastError(ERROR_OUTOFMEMORY);
    }

    return (pv);
}

void __RPC_USER  MIDL_user_free(void __RPC_FAR *pv)
{
    if (pv != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pv);
    }
}

void * SCRedirAlloc(REDIR_LOCAL_SCARDCONTEXT *pRedirContext, size_t size)
{
    return (HeapAlloc(
                (pRedirContext != NULL) ? pRedirContext->hHeap : GetProcessHeap(),
                HEAP_ZERO_MEMORY,
                size));
}

LONG
_MakeSCardError(NTSTATUS Status)
{
    switch (Status)
    {
    case STATUS_DEVICE_NOT_CONNECTED:
        return (SCARD_E_NO_SERVICE);
        break;

    case STATUS_CANCELLED:
        return (SCARD_E_SYSTEM_CANCELLED);
        break;

    default:
        return (SCARD_E_NO_SERVICE);
    }
}


//---------------------------------------------------------------------------------------
//
//  DllRegisterServer
//
//---------------------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
    HRESULT hr              = ERROR_SUCCESS;
    HKEY    hKey;
    DWORD   dwDisposition;
    DWORD   dwVersion       = REDIRECTION_VERSION;

    hr = RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            wszWinSCardRegKeyRedirector,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition);

    if (hr == ERROR_SUCCESS)
    {
        hr = RegSetValueExW(
                hKey,
                wszWinSCardRegName,
                0,
                REG_SZ,
                (BYTE *) wszWinSCardRegNameValue,
                (wcslen(wszWinSCardRegNameValue) + 1) * sizeof(WCHAR));

        if (hr == ERROR_SUCCESS)
        {
            hr = RegSetValueExW(
                    hKey,
                    wszWinSCardRegVersion,
                    0,
                    REG_DWORD,
                    (BYTE *) &dwVersion,
                    sizeof(DWORD));
        }

        RegCloseKey(hKey);
    }

    return (hr);
}


//---------------------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//---------------------------------------------------------------------------------------
STDAPI
DllUnregisterServer(void)
{
    HRESULT hr              = ERROR_SUCCESS;
    HKEY    hKey;
    DWORD   dwDisposition;
    DWORD   dwVersion       = REDIRECTION_VERSION;

    hr = RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            wszWinSCardRegKeyRedirector,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition);

    if (hr == ERROR_SUCCESS)
    {
        RegDeleteValueW(hKey, wszWinSCardRegName);
        RegDeleteValueW(hKey, wszWinSCardRegVersion);
        RegCloseKey(hKey);
    }

    return (hr);
}


//---------------------------------------------------------------------------------------
//
//  DllMain
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
DllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    DWORD               dwTryCount              = 0;
    DWORD               dwCritSecsInitialized   = 0;
    BUFFER_LIST_STRUCT  *pTemp                  = NULL;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:

        g_hModule = hInstDLL;
         __try
        {
            InitializeCriticalSection(&g_CreateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_SetStartedEventStateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_StartedEventCreateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_ProcessDetachEventCreateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_BufferListCS);
            dwCritSecsInitialized++;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            if (dwCritSecsInitialized >= 1)
            {
                DeleteCriticalSection(&g_CreateCS);
            }

            if (dwCritSecsInitialized >= 2)
            {
                DeleteCriticalSection(&g_SetStartedEventStateCS);
            }

            if (dwCritSecsInitialized >= 3)
            {
                DeleteCriticalSection(&g_StartedEventCreateCS);
            }

            if (dwCritSecsInitialized >= 4)
            {
                DeleteCriticalSection(&g_ProcessDetachEventCreateCS);
            }

            if (dwCritSecsInitialized >= 5)
            {
                DeleteCriticalSection(&g_BufferListCS);
            }

            SetLastError(GetExceptionCode());
            return (FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:

        g_fInProcessDetach = TRUE;

        //
        // The third parameter, lpvReserved, passed to DllMain
        // is NULL for FreeLibrary and non-NULL for ProcessExit.
        // Only clean up for FreeLibrary
        //
        //if (lpvReserved == NULL)
        {
            //
            // If we are currently waiting for the started event then kill
            // that wait
            //
            EnterCriticalSection(&g_SetStartedEventStateCS);

            if (g_hRegisteredWaitHandle != NULL)
            {
                UnregisterWaitEx(g_hRegisteredWaitHandle, INVALID_HANDLE_VALUE);
                g_hRegisteredWaitHandle = NULL;
            }

            if (g_hWaitEvent != NULL)
            {
                CloseHandle(g_hWaitEvent);
                g_hWaitEvent = NULL;
            }

            LeaveCriticalSection(&g_SetStartedEventStateCS);

            //
            // If there are clients waiting on IOCTLs to complete, then let them go.
            //
            if (g_hProcessDetachEvent != NULL)
            {
                SetEvent(g_hProcessDetachEvent);
            }

            if (g_hProcessDetachEvent != NULL)
            {
                //
                // wait for all clients until they are done with the event
                //
                while ((g_lProcessDetachEventClients > 0) && (dwTryCount < 50))
                {
                    Sleep(10);
                    dwTryCount++;
                }

                if (dwTryCount < 50)
                {
                    CloseHandle(g_hProcessDetachEvent);
                }
            }

            if (g_hRdpdrDeviceHandle != INVALID_HANDLE_VALUE)
            {
                CloseHandle(g_hRdpdrDeviceHandle);
            }

            if (g_hRedirStartedEvent != NULL)
            {
                CloseHandle(g_hRedirStartedEvent);
            }

            //
            // Free all the buffers used for the IOCTL calls
            //
            pTemp = g_pBufferList;
            while (pTemp != NULL)
            {
                g_pBufferList = (BUFFER_LIST_STRUCT *) pTemp->pNext;
                MIDL_user_free(pTemp->pbBytes);
                MIDL_user_free(pTemp);
                pTemp = g_pBufferList;
            }

            DeleteCriticalSection(&g_CreateCS);
            DeleteCriticalSection(&g_SetStartedEventStateCS);
            DeleteCriticalSection(&g_StartedEventCreateCS);
            DeleteCriticalSection(&g_ProcessDetachEventCreateCS);
            DeleteCriticalSection(&g_BufferListCS);
        }

        break;
    }

    return (TRUE);
}

//---------------------------------------------------------------------------------------
//
//  GetBuffer
//
//---------------------------------------------------------------------------------------
BUFFER_LIST_STRUCT *
GetBuffer(void)
{
    BUFFER_LIST_STRUCT *pTemp = NULL;
    BUFFER_LIST_STRUCT *p1    = NULL;
    BUFFER_LIST_STRUCT *p2    = NULL;

    EnterCriticalSection(&g_BufferListCS);

    //
    // See if there are any buffers allocated yet
    //
    if (g_pBufferList == NULL)
    {
        g_pBufferList = (BUFFER_LIST_STRUCT *)
                            MIDL_user_allocate(sizeof(BUFFER_LIST_STRUCT));

        if (g_pBufferList == NULL)
        {
            goto Return;
        }

        g_pBufferList->pbBytes = (BYTE *) MIDL_user_allocate(INITIAL_BUFFER_SIZE);

        if (g_pBufferList->pbBytes == NULL)
        {
            MIDL_user_free(g_pBufferList);
            goto Return;
        }

        g_pBufferList->pNext = NULL;
        g_pBufferList->fInUse = TRUE;
        g_pBufferList->cbBytes = INITIAL_BUFFER_SIZE;

        pTemp = g_pBufferList;
        goto Return;
    }

    //
    // Walk the existing list to see if a free buffer can be found
    //
    pTemp = g_pBufferList;
    while ((pTemp != NULL) && (pTemp->fInUse))
    {
        pTemp = (BUFFER_LIST_STRUCT *)pTemp->pNext;
    }

    if (pTemp != NULL)
    {
        pTemp->fInUse = TRUE;

        //
        // Get rid of any buffers that exist which aren't being used
        //
        p1 = pTemp;
        p2 = (BUFFER_LIST_STRUCT *) pTemp->pNext;
        while (p2 != NULL)
        {
            if (!(p2->fInUse))
            {
                p1->pNext = p2->pNext;

                MIDL_user_free(p2->pbBytes);
                MIDL_user_free(p2);

                p2 = (BUFFER_LIST_STRUCT *) p1->pNext;
            }
            else
            {
                p1 = (BUFFER_LIST_STRUCT *) p1->pNext;
                p2 = (BUFFER_LIST_STRUCT *) p2->pNext;
            }
        }

        goto Return;
    }

    //
    // No free buffers, so create a new one
    //
    pTemp = (BUFFER_LIST_STRUCT *)
                            MIDL_user_allocate(sizeof(BUFFER_LIST_STRUCT));

    if (pTemp == NULL)
    {
        goto Return;
    }

    pTemp->pbBytes = (BYTE *) MIDL_user_allocate(INITIAL_BUFFER_SIZE);

    if (pTemp->pbBytes == NULL)
    {
        MIDL_user_free(pTemp);
        goto Return;
    }

    pTemp->fInUse = TRUE;
    pTemp->cbBytes = INITIAL_BUFFER_SIZE;

    pTemp->pNext = g_pBufferList;
    g_pBufferList = pTemp;

Return:

    LeaveCriticalSection(&g_BufferListCS);
    return(pTemp);
}


//---------------------------------------------------------------------------------------
//
//  FreeBuffer
//
//---------------------------------------------------------------------------------------
void
FreeBuffer(BUFFER_LIST_STRUCT *pBuffer)
{
    if (pBuffer != NULL)
    {
        pBuffer->fInUse = FALSE;
    }
}

//---------------------------------------------------------------------------------------
//
//  GrowBuffer
//
//---------------------------------------------------------------------------------------
BOOL
GrowBuffer(BUFFER_LIST_STRUCT *pBuffer)
{
    BYTE *pTemp;
    BOOL fRet = TRUE;

    pTemp = pBuffer->pbBytes;

    pBuffer->pbBytes = (BYTE *) MIDL_user_allocate(pBuffer->cbBytes * 2);

    if (pBuffer->pbBytes == NULL)
    {
        pBuffer->pbBytes = pTemp;
        fRet = FALSE;
    }
    else
    {
        MIDL_user_free(pTemp);
        pBuffer->cbBytes = pBuffer->cbBytes * 2;
    }

    return (fRet);
}



//---------------------------------------------------------------------------------------
//
//  _GetProcessDetachEventHandle
//
//---------------------------------------------------------------------------------------
HANDLE
_GetProcessDetachEventHandle(void)
{
    EnterCriticalSection(&g_ProcessDetachEventCreateCS);

    if (NULL == g_hProcessDetachEvent)
    {
        try
        {
            g_hProcessDetachEvent =
                CreateEvent(
                    NULL,       // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    NULL);      // event-object name
        }
        catch (...)
        {
            goto Return;
        }
    }

    LeaveCriticalSection(&g_ProcessDetachEventCreateCS);

Return:

    if (g_hProcessDetachEvent != NULL)
    {
        InterlockedIncrement(&g_lProcessDetachEventClients);
    }

    return (g_hProcessDetachEvent);
}

void
_ReleaseProcessDetachEventHandle(void)
{
    InterlockedDecrement(&g_lProcessDetachEventClients);
}



//---------------------------------------------------------------------------------------
//
// All the code below is to solve the problem of weather or not the redirect Smart
// Card Subsystem is available.  It is available if we are connected to the client,
// and if the clients Smart Card Subsystem is running
//
//---------------------------------------------------------------------------------------

HANDLE
_GetStartedEventHandle(void)
{
    EnterCriticalSection(&g_StartedEventCreateCS);

    if (NULL == g_hRedirStartedEvent)
    {
        g_hRedirStartedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    }

    LeaveCriticalSection(&g_StartedEventCreateCS);

    return (g_hRedirStartedEvent);
}


VOID CALLBACK
AccessStartedEventIOCTLCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    HANDLE  h        = NULL;
    BOOL    fRetry  = FALSE;
    //OutputDebugString("SCREDIR: AccessStartedEventIOCTLCallback\n");

    //
    // Close the handle that was used to fire this callback
    //
    EnterCriticalSection(&g_SetStartedEventStateCS);

    h = g_hRegisteredWaitHandle;
    g_hRegisteredWaitHandle = NULL;

    LeaveCriticalSection(&g_SetStartedEventStateCS);
    //OutputDebugString("SCREDIR: AccessStartedEventIOCTLCallback - through the CS\n");

    if (h != NULL)
    {
        UnregisterWait(h);
    }

    //
    // Make sure the AccessStartedEvent IOCTL completed and wasn't timed out
    //
    if (!TimerOrWaitFired)
    {
        //
        // Make sure the AccessStartedEvent IOCTL completed successfully
        //
        if (g_StartedStatusBlock.Status == STATUS_SUCCESS)
        {
            //OutputDebugString("SCREDIR: AccessStartedEventIOCTLCallback - g_StartedStatusBlock.Status == STATUS_SUCCESS\n");
            g_cbIOCTLReturnBuffer =
                    (unsigned long) g_StartedStatusBlock.Information;

            //
            // Look at the value returned from the SCARD_IOCTL_ACCESSSTARTEDEVENT
            // call to see if we should set the local started event
            //
            if (I_DecodeLongReturn(
                    g_rgbIOCTLReturnBuffer,
                    g_cbIOCTLReturnBuffer) == SCARD_S_SUCCESS)
            {
                //OutputDebugString("SCREDIR: AccessStartedEventIOCTLCallback - SetEvent\n");
                SetEvent(g_hRedirStartedEvent);
            }
        }
        else if (g_StartedStatusBlock.Status == STATUS_CANCELLED)
        {
            //OutputDebugString("SCREDIR: AccessStartedEventIOCTLCallback - Got STATUS_CANCELLED\n");
            //
            // Retry
            //
            fRetry = TRUE;
        }
        else
        {
            char a[256];
            sprintf(a, "SCREDIR: AccessStartedEventIOCTLCallback - Status = %lx\n", g_StartedStatusBlock.Status);
            //OutputDebugString(a);
        }


    }
    else
    {
        //OutputDebugString("SCREDIR: AccessStartedEventIOCTLCallback - Timed out\n");
    }

    //
    // Unset the g_fInTheProcessOfSettingStartedEvent boolean
    //
    EnterCriticalSection(&g_SetStartedEventStateCS);
    g_fInTheProcessOfSettingStartedEvent = FALSE;
    LeaveCriticalSection(&g_SetStartedEventStateCS);

    if (fRetry)
    {
        _SetStartedEventToCorrectState();
    }
}

VOID CALLBACK
SCardOnLineIOCTLCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    BOOL        fOperationDone      = FALSE;
    NTSTATUS    Status              = STATUS_SUCCESS;
    BYTE        rgb[4];
    HANDLE      h                   = NULL;

    //
    // Close the handle that was used to fire this callback
    //
    EnterCriticalSection(&g_SetStartedEventStateCS);
    h = g_hRegisteredWaitHandle;
    g_hRegisteredWaitHandle = NULL;
    LeaveCriticalSection(&g_SetStartedEventStateCS);

    if (h != NULL)
    {
        UnregisterWait(h);
    }

    //
    // Make sure the online IOCTL completed and wasn't timed out
    //
    if (TimerOrWaitFired)
    {
        //
        // Timed out, so just cancel operation
        //
        fOperationDone = TRUE;
    }
    else
    {
        //
        // Make sure the SCardOnLine IOCTL completed successfully, then try to
        // send the IOCTL which will wait on the clients started event
        //
        if (g_StartedStatusBlock.Status == STATUS_SUCCESS)
        {
            Status = _SendSCardIOCTLWithWaitForCallback(
                            SCARD_IOCTL_ACCESSSTARTEDEVENT,
                            rgb,
                            4,
                            AccessStartedEventIOCTLCallback);
            if (Status == STATUS_SUCCESS)
            {
                //OutputDebugString("SCREDIR: SCardOnLineIOCTLCallback - _SendSCardIOCTLWithWaitForCallback(SCARD_IOCTL_ACCESSSTARTEDEVENT) - suceeded\n");
                g_cbIOCTLReturnBuffer =
                    (unsigned long) g_StartedStatusBlock.Information;

                //
                // Look at the value returned from the SCARD_IOCTL_ACCESSSTARTEDEVENT
                // call to see if we should set the local started event
                //
                if (I_DecodeLongReturn(
                        g_rgbIOCTLReturnBuffer,
                        g_cbIOCTLReturnBuffer) == SCARD_S_SUCCESS)
                {
                    SetEvent(g_hRedirStartedEvent);
                }

                fOperationDone = TRUE;
            }
            else if (Status == STATUS_PENDING)
            {
                //OutputDebugString("SCREDIR: SCardOnLineIOCTLCallback - _SendSCardIOCTLWithWaitForCallback(SCARD_IOCTL_ACCESSSTARTEDEVENT) - PENDING\n");
                //
                // This OK, since the AccessStartedEventIOCTLCallback function
                // will handle the return once the operation is complete
                //
            }
            else
            {
                fOperationDone = TRUE;
            }
        }
        else
        {
            fOperationDone = TRUE;
        }
    }

    if (fOperationDone)
    {
        EnterCriticalSection(&g_SetStartedEventStateCS);
        g_fInTheProcessOfSettingStartedEvent = FALSE;
        LeaveCriticalSection(&g_SetStartedEventStateCS);
    }
}


BOOL
_SetStartedEventToCorrectState(void)
{
    BOOL        fRet                = TRUE;
    BOOL        fOperationDone      = FALSE;
    HANDLE      h                   = NULL;
    NTSTATUS    Status              = STATUS_SUCCESS;
    BYTE        rgb[4];

    //
    // Make sure the event is created
    //
    if (NULL == (h = _GetStartedEventHandle()))
    {
        fRet = FALSE;
        goto Return;
    }

    //
    // If the event is already set then just return
    //
    /*if (WAIT_OBJECT_0 == WaitForSingleObject(h, 0))
    {
        //OutputDebugString("SCREDIR: _SetStartedEventToCorrectState - Event already set\n");
        goto Return;
    }*/

    EnterCriticalSection(&g_SetStartedEventStateCS);

    //
    // If we are already in the process of setting the started event, then just get out
    //
    if (g_fInTheProcessOfSettingStartedEvent)
    {
        //OutputDebugString("SCREDIR: _SetStartedEventToCorrectState - g_fInTheProcessOfSettingStartedEvent set\n");
        LeaveCriticalSection(&g_SetStartedEventStateCS);
        goto Return;
    }

    g_fInTheProcessOfSettingStartedEvent = TRUE;
    LeaveCriticalSection(&g_SetStartedEventStateCS);

    ResetEvent(g_hRedirStartedEvent);

    //
    // Make the blocking call to rdpdr.sys that will only return after the
    // client is connected, and the scard device announce has been processed
    //
    // NOTE: If this fails, then we can't do much,
    //
    Status = _SendSCardIOCTLWithWaitForCallback(
                    SCARD_IOCTL_SMARTCARD_ONLINE,
                    NULL,
                    0,
                    SCardOnLineIOCTLCallback);
    if (Status == STATUS_SUCCESS)
    {
        //OutputDebugString("SCREDIR: _SetStartedEventToCorrectState - _SendSCardIOCTLWithWaitForCallback(SCARD_IOCTL_SMARTCARD_ONLINE) - suceeded\n");
        //
        // Since the SCARD_IOCTL_SMARTCARD_ONLINE succeeded immediately, we
        // can just make the SCARD_IOCTL_ACCESSSTARTEDEVENT right now.
        //
        Status = _SendSCardIOCTLWithWaitForCallback(
                        SCARD_IOCTL_ACCESSSTARTEDEVENT,
                        rgb,
                        4,
                        AccessStartedEventIOCTLCallback);
        if (Status == STATUS_SUCCESS)
        {
            //OutputDebugString("SCREDIR: _SetStartedEventToCorrectState - _SendSCardIOCTLWithWaitForCallback(SCARD_IOCTL_ACCESSSTARTEDEVENT) - suceeded\n");
            g_cbIOCTLReturnBuffer =
                (unsigned long) g_StartedStatusBlock.Information;

            //
            // Look at the value returned from the SCARD_IOCTL_ACCESSSTARTEDEVENT
            // call to see if we should set the local started event
            //
            if (I_DecodeLongReturn(
                    g_rgbIOCTLReturnBuffer,
                    g_cbIOCTLReturnBuffer) == SCARD_S_SUCCESS)
            {
                SetEvent(g_hRedirStartedEvent);
            }

            fOperationDone = TRUE;
        }
        else if (Status == STATUS_PENDING)
        {
            //OutputDebugString("SCREDIR: _SetStartedEventToCorrectState - _SendSCardIOCTLWithWaitForCallback(SCARD_IOCTL_ACCESSSTARTEDEVENT) - PENDING\n");
            //
            // This OK, since the AccessStartedEventIOCTLCallback function
            // will handle the return once the operation is complete
            //
        }
        else
        {
            fOperationDone = TRUE;
        }
    }
    else if (Status == STATUS_PENDING)
    {
        //OutputDebugString("SCREDIR: _SetStartedEventToCorrectState - _SendSCardIOCTLWithWaitForCallback(SCARD_IOCTL_SMARTCARD_ONLINE) - PENDING\n");
        //
        // This is OK, the SCardOnLineIOCTLCallback will make the next call
        // to _SendSCardIOCTLWithWaitForCallback with SCARD_IOCTL_ACCESSSTARTEDEVENT
        //
    }
    else
    {
        fOperationDone = TRUE;
    }


    if (fOperationDone)
    {
        EnterCriticalSection(&g_SetStartedEventStateCS);
        g_fInTheProcessOfSettingStartedEvent = FALSE;
        LeaveCriticalSection(&g_SetStartedEventStateCS);
    }

    //
    // Now check to see if the operation completed successfully
    //
    if ((Status != STATUS_PENDING) && (Status != STATUS_SUCCESS))
    {
        fRet = FALSE;
    }

Return:

    return (fRet);
}


//---------------------------------------------------------------------------------------
//
//  _CreateRdpdrDeviceHandle
//
//---------------------------------------------------------------------------------------
HANDLE
_CreateRdpdrDeviceHandle()
{
    WCHAR   wszDeviceName[56];

    swprintf(wszDeviceName, L"\\\\TSCLIENT\\%S", DR_SMARTCARD_SUBSYSTEM);

    return (CreateFileW(
                wszDeviceName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_FLAG_OVERLAPPED,
                NULL));
}


//---------------------------------------------------------------------------------------
//
//  _CreateGlobalRdpdrHandle
//
//---------------------------------------------------------------------------------------
NTSTATUS
_CreateGlobalRdpdrHandle()
{
    NTSTATUS Status = STATUS_SUCCESS;

    EnterCriticalSection(&g_CreateCS);

    //
    // Check to see if the SCardDevice handle has been created
    // yet, if not, then create it
    //
    if (g_hRdpdrDeviceHandle == INVALID_HANDLE_VALUE)
    {
        g_hRdpdrDeviceHandle = _CreateRdpdrDeviceHandle();

        if (g_hRdpdrDeviceHandle == INVALID_HANDLE_VALUE)
        {
            Status = STATUS_OPEN_FAILED;
        }
    }

    LeaveCriticalSection(&g_CreateCS);

    return (Status);
}


//---------------------------------------------------------------------------------------
//
//  _SendSCardIOCTLWithWaitForCallback
//
//---------------------------------------------------------------------------------------
NTSTATUS
_SendSCardIOCTLWithWaitForCallback(
    ULONG               IoControlCode,
    PVOID               InputBuffer,
    ULONG               InputBufferLength,
    WAITORTIMERCALLBACK Callback)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (g_fInProcessDetach)
    {
        goto ErrorReturn;
    }

    Status = _CreateGlobalRdpdrHandle();
    if (Status != STATUS_SUCCESS)
    {
        return (Status);
    }

    //
    // Create the event which is set when the function successfully completes
    //
    if (g_hWaitEvent == NULL)
    {
        g_hWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (g_hWaitEvent == NULL)
        {
            goto ErrorReturn;
        }
    }
    else
    {
        ResetEvent(g_hWaitEvent);
    }

    Status = NtDeviceIoControlFile(
            g_hRdpdrDeviceHandle,
            g_hWaitEvent,
            NULL,
            NULL,
            &g_StartedStatusBlock,
            IoControlCode,
            InputBuffer,
            InputBufferLength,
            g_rgbIOCTLReturnBuffer,
            IOCTL_RETURN_BUFFER_SIZE);

    if (Status == STATUS_PENDING)
    {
        EnterCriticalSection(&g_SetStartedEventStateCS);

        //
        // The g_hWaitEvent being set by the driver will trigger this registered callback
        //
        if (!RegisterWaitForSingleObject(
                &g_hRegisteredWaitHandle,
                g_hWaitEvent,
                Callback,
                NULL,
                INFINITE,
                WT_EXECUTEONLYONCE))
        {
            LeaveCriticalSection(&g_SetStartedEventStateCS);
            goto ErrorReturn;
        }

        LeaveCriticalSection(&g_SetStartedEventStateCS);
    }
    else if (Status == STATUS_SUCCESS)
    {
        g_cbIOCTLReturnBuffer = (unsigned long) g_StartedStatusBlock.Information;
    }
    else
    {
        g_cbIOCTLReturnBuffer = 0;
    }

Return:

    return (Status);

ErrorReturn:

    Status = STATUS_INSUFFICIENT_RESOURCES;

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  _SendSCardIOCTL
//
//---------------------------------------------------------------------------------------
NTSTATUS
_SendSCardIOCTL(
    ULONG               IoControlCode,
    PVOID               InputBuffer,
    ULONG               InputBufferLength,
    BUFFER_LIST_STRUCT  **ppOutputBuffer)
{
    NTSTATUS        Status              = STATUS_SUCCESS;
    IO_STATUS_BLOCK StatusBlock;
    HANDLE          rgWaitHandles[2];
    DWORD           dwIndex;

    *ppOutputBuffer = NULL;

    rgWaitHandles[0] = NULL;
    rgWaitHandles[1] = NULL;

    //
    // Make sure the handle to the rdpdr device is created
    //
    Status = _CreateGlobalRdpdrHandle();
    if (Status != STATUS_SUCCESS)
    {
        return (Status);
    }

    //
    // Get an output buffer for the call
    //
    *ppOutputBuffer = GetBuffer();
    if (*ppOutputBuffer == NULL)
    {
        return (STATUS_NO_MEMORY);
    }

    //
    // Create the event that will be signaled when the IOCTL is complete
    //
    rgWaitHandles[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (rgWaitHandles[0]  == NULL)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    while (1)
    {
        Status = NtDeviceIoControlFile(
                    g_hRdpdrDeviceHandle,
                    rgWaitHandles[0],
                    NULL,
                    NULL,
                    &StatusBlock,
                    IoControlCode,
                    InputBuffer,
                    InputBufferLength,
                    (*ppOutputBuffer)->pbBytes,
                    (*ppOutputBuffer)->cbBytes);

        if (Status == STATUS_PENDING)
        {
            rgWaitHandles[1] = _GetProcessDetachEventHandle();
            if (rgWaitHandles[1] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            dwIndex = WaitForMultipleObjects(2, rgWaitHandles, FALSE, INFINITE);
            if (dwIndex != WAIT_FAILED)
            {
                dwIndex = dwIndex - WAIT_OBJECT_0;

                //
                // The IOCTL wait event was signaled if dwIndex == 0.  Otherwise the
                // process detach event was signaled
                //
                if (dwIndex == 0)
                {
                    Status = StatusBlock.Status;
                }
            }
            else
            {
                Status = STATUS_UNEXPECTED_IO_ERROR;
            }

            _ReleaseProcessDetachEventHandle();
        }

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            if (!GrowBuffer(*ppOutputBuffer))
            {
                Status = STATUS_NO_MEMORY;
                break;
            }

            ResetEvent(rgWaitHandles[0]);
        }
        else
        {
            break;
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        //
        // If we got the STATUS_DEVICE_NOT_CONNECTED error, then go back to waiting
        // for a connect
        //
        if (Status == STATUS_DEVICE_NOT_CONNECTED)
        {
            _SetStartedEventToCorrectState();
        }
        else if ((Status == STATUS_CANCELLED) &&
                 (g_hUnifiedStartedEvent != NULL))
        {
            //OutputDebugString("SCREDIR: _SendSCardIOCTL: resetting g_hUnifiedStartedEvent\n");
            ResetEvent(g_hUnifiedStartedEvent);
            _SetStartedEventToCorrectState();
        }

        (*ppOutputBuffer)->cbBytesUsed = 0;
        goto Return;
    }

    (*ppOutputBuffer)->cbBytesUsed = (unsigned long) StatusBlock.Information;

Return:

    if (rgWaitHandles[0] != NULL)
    {
        CloseHandle(rgWaitHandles[0]);
    }

    return (Status);
}


//---------------------------------------------------------------------------------------
//
//  SafeMesHandleFree
//
//---------------------------------------------------------------------------------------
void
SafeMesHandleFree(handle_t *ph)
{
    if (*ph != 0)
    {
        MesHandleFree(*ph);
        *ph = 0;
    }
}


//---------------------------------------------------------------------------------------
//
//  _CalculateNumBytesInMultiStringA
//
//---------------------------------------------------------------------------------------
DWORD
_CalculateNumBytesInMultiStringA(LPCSTR psz)
{
    DWORD   dwTotal     = sizeof(char); // trailing '/0'
    DWORD   dwNumChars  = 0;
    LPCSTR  pszCurrent  = psz;

    if (psz == NULL)
    {
        return (0);
    }

    if (pszCurrent[0] == '\0')
    {
        if (pszCurrent[1] == '\0')
        {
            return (2 * sizeof(char));
        }

        pszCurrent++;
        dwTotal += sizeof(char);
    }

    while (pszCurrent[0] != '\0')
    {
        dwNumChars = strlen(pszCurrent) + 1;
        dwTotal += dwNumChars * sizeof(char);
        pszCurrent += dwNumChars;
    }

    return (dwTotal);
}


//---------------------------------------------------------------------------------------
//
//  _CalculateNumBytesInMultiStringW
//
//---------------------------------------------------------------------------------------
DWORD
_CalculateNumBytesInMultiStringW(LPCWSTR pwsz)
{
    DWORD   dwTotal     = sizeof(WCHAR); // trailing L'/0'
    DWORD   dwNumChars  = 0;
    LPCWSTR pwszCurrent = pwsz;

    if (pwsz == NULL)
    {
        return (0);
    }

    if (pwszCurrent[0] == L'\0')
    {
        if (pwszCurrent[1] == L'\0')
        {
            (2 * sizeof(WCHAR));
        }

        pwszCurrent++;
        dwTotal += sizeof(WCHAR);
    }

    while (pwszCurrent[0] != L'\0')
    {
        dwNumChars = wcslen(pwszCurrent) + 1;
        dwTotal += dwNumChars * sizeof(WCHAR);
        pwszCurrent += dwNumChars;
    }

    return (dwTotal);
}


//---------------------------------------------------------------------------------------
//
//  _CalculateNumBytesInAtr
//
//---------------------------------------------------------------------------------------
DWORD
_CalculateNumBytesInAtr(LPCBYTE pbAtr)
{
    DWORD   dwAtrLen = 0;

    if (ParseAtr(pbAtr, &dwAtrLen, NULL, NULL, 33))
    {
        return (dwAtrLen);
    }
    else
    {
        return (0);
    }
}


//---------------------------------------------------------------------------------------
//
//  _CopyReturnToCallerBuffer
//
//---------------------------------------------------------------------------------------
#define BYTE_TYPE_RETURN    1
#define SZ_TYPE_RETURN      2
#define WSZ_TYPE_RETURN     3

LONG
_CopyReturnToCallerBuffer(
    REDIR_LOCAL_SCARDCONTEXT    *pRedirContext,
    LPBYTE                      pbReturn,
    DWORD                       cbReturn,
    LPBYTE                      pbUserBuffer,
    LPDWORD                     pcbUserBuffer,
    DWORD                       dwReturnType)
{
    LPBYTE  *ppBuf;
    BOOL    fAutoAllocate       = (*pcbUserBuffer == SCARD_AUTOALLOCATE);
    DWORD   dwEnd;
    DWORD   dwCallersBufferSize = *pcbUserBuffer;

    //
    // The number of chars or bytes, depending on the type of return.
    //
    if (dwReturnType == WSZ_TYPE_RETURN)
    {
        *pcbUserBuffer = cbReturn / sizeof(WCHAR);
    }
    else if (dwReturnType == SZ_TYPE_RETURN)
    {
        *pcbUserBuffer = cbReturn / sizeof(char);
    }
    else
    {
        *pcbUserBuffer = cbReturn;
    }

    //
    // If pbUserBuffer is not NULL, then the caller wants the data,
    // not just the size, so give it to em'
    //
    if ((pbReturn != NULL) &&
        (pbUserBuffer != NULL))
    {
        //
        // validate the data
        //
        if (dwReturnType == WSZ_TYPE_RETURN)
        {
            //
            // If we aren't auto allocating and the users buffer is too small then
            // get out.  This is just extra protection to ensure that the client
            // isn't ill behaved.  Since the client was passed the size of our
            // callers buffer the client should really fail if the buffer isn't
            // big enough, but since we can't trust the client, do this extra check.
            //
            if ((!fAutoAllocate) && (dwCallersBufferSize < (cbReturn / sizeof(WCHAR))))
            {
                return (SCARD_E_UNEXPECTED);
            }

            dwEnd = cbReturn / sizeof(WCHAR);

            if ((dwEnd < 2)                             ||  // must be at least two chars
                (((LPWSTR) pbReturn)[dwEnd-1] != L'\0') ||  // last char must be '\0'
                (((LPWSTR) pbReturn)[dwEnd-2] != L'\0'))    // second to last char must be '\0'
            {
                return (SCARD_E_UNEXPECTED);
            }
        }
        else if (dwReturnType == SZ_TYPE_RETURN)
        {
            //
            // If we aren't auto allocating and the users buffer is too small then
            // get out.  This is just extra protection to ensure that the client
            // isn't ill behaved.  Since the client was passed the size of our
            // callers buffer the client should really fail if the buffer isn't
            // big enough, but since we can't trust the client, do this extra check.
            //
            if ((!fAutoAllocate) && (dwCallersBufferSize < (cbReturn / sizeof(char))))
            {
                return (SCARD_E_UNEXPECTED);
            }

            dwEnd = cbReturn / sizeof(char);

            if ((dwEnd < 2)                             ||  // must be at least two chars
                (((LPSTR) pbReturn)[dwEnd-1] != '\0')   ||  // last char must be '\0'
                (((LPSTR) pbReturn)[dwEnd-2] != '\0'))      // second to last char must be '\0'
            {
                return (SCARD_E_UNEXPECTED);
            }
        }
        else
        {
            //
            // If we aren't auto allocating and the users buffer is too small then
            // get out.  This is just extra protection to ensure that the client
            // isn't ill behaved.  Since the client was passed the size of our
            // callers buffer the client should really fail if the buffer isn't
            // big enough, but since we can't trust the client, do this extra check.
            //
            if ((!fAutoAllocate) && (dwCallersBufferSize < cbReturn))
            {
                return (SCARD_E_UNEXPECTED);
            }
        }

        //
        // Allocate space for caller if requested, else, copy to callers
        // supplied buffer
        //
        if (fAutoAllocate)
        {
            ppBuf = (LPBYTE *) pbUserBuffer;

            *ppBuf = (LPBYTE) SCRedirAlloc(pRedirContext, cbReturn);
            if (*ppBuf != NULL)
            {
                memcpy(*ppBuf, pbReturn, cbReturn);
            }
            else
            {
                return (SCARD_E_NO_MEMORY);
            }
        }
        else
        {
            memcpy(pbUserBuffer, pbReturn, cbReturn);
        }
    }

    return (SCARD_S_SUCCESS);
}


//---------------------------------------------------------------------------------------
//
//  I_DecodeLongReturn
//
//---------------------------------------------------------------------------------------
LONG
I_DecodeLongReturn(
    BYTE *pb,
    unsigned long cb)
{
    handle_t    h           = 0;
    RPC_STATUS  rpcStatus;
    Long_Return LongReturn;
    LONG        lReturn;

    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pb,
                        cb,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED);
    }

    memset(&LongReturn, 0, sizeof(LongReturn));
    _TRY_(Long_Return_Decode(h, &LongReturn))

    lReturn =  LongReturn.ReturnCode;

    _TRY_2(Long_Return_Free(h, &LongReturn))

Return:

    SafeMesHandleFree(&h);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardEstablishContext
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardEstablishContext(
    IN DWORD dwScope,
    IN LPCVOID pvReserved1,
    IN LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext)
{
    LONG                    lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                Status                  = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus               = RPC_S_OK;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                h                       = 0;
    BOOL                    fFreeDecode             = FALSE;
    BUFFER_LIST_STRUCT      *pOutputBuffer          = NULL;
    EstablishContext_Call   EstablishContextCall;
    EstablishContext_Return EstablishContextReturn;

    //
    // This event is the "smart card subsystem started" event that
    // winscard.dll and scredir.dll share.  scredir will Reset this event
    // if it gets a STATUS_CANCELLED returned from the rdpdr driver, or if it
    // gets and indication that the clients scardsvr service was stopped (it
    // gets these indications via SCardEstablishContext returing SCARD_E_NO_SERVICE
    // or by SCardGetStatusChange returning SCARD_E_SYSTEM_CANCELLED).  It
    // does this so that the event goes into the unsignalled state as soon as
    // possible when a disconnect or service shutdown is detected... a STATUS_CANCELLED
    // returned from rdpdr happens when a disconnect takes place
    //
    g_hUnifiedStartedEvent = (HANDLE) pvReserved2;

    //
    // Validate input params and initialize the out param
    //
    if (phContext == NULL)
    {
        ERROR_RETURN(SCARD_E_INVALID_PARAMETER)
    }
    else
    {
        *phContext = NULL;
    }
    if ((SCARD_SCOPE_USER != dwScope)
            // && (SCARD_SCOPE_TERMINAL != dwScope) // Maybe NT V5+?
            && (SCARD_SCOPE_SYSTEM != dwScope))
    {
        ERROR_RETURN(SCARD_E_INVALID_VALUE)
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the EstablishContext params
    //
    EstablishContextCall.dwScope = dwScope;
    _TRY_(EstablishContext_Call_Encode(h, &EstablishContextCall))

    //
    // Make the EstablishContext call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_ESTABLISHCONTEXT,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&EstablishContextReturn, 0, sizeof(EstablishContextReturn));
    _TRY_(EstablishContext_Return_Decode(h, &EstablishContextReturn))
    fFreeDecode = TRUE;

    lReturn =  EstablishContextReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        REDIR_LOCAL_SCARDCONTEXT *pRedirLocalContext = NULL;

        //
        // The value that represents the SCARDCONTEXT on the remote client
        // machine is a variable size, so allocate memory for the struct
        // that holds the variable length context size and pointer, plus
        // the actual bytes for the context... but first, make sure the
        // context is a reasonable size
        //

        if (EstablishContextReturn.Context.cbContext > MAX_SCARDCONTEXT_SIZE)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        pRedirLocalContext = (REDIR_LOCAL_SCARDCONTEXT *)
                                MIDL_user_allocate(
                                    sizeof(REDIR_LOCAL_SCARDCONTEXT) +
                                    EstablishContextReturn.Context.cbContext);

        if (pRedirLocalContext != NULL)
        {
            pRedirLocalContext->Context.cbContext = EstablishContextReturn.Context.cbContext;
            pRedirLocalContext->Context.pbContext = ((BYTE *) pRedirLocalContext) +
                                                    sizeof(REDIR_LOCAL_SCARDCONTEXT);
            memcpy(
                pRedirLocalContext->Context.pbContext,
                EstablishContextReturn.Context.pbContext,
                EstablishContextReturn.Context.cbContext);

            pRedirLocalContext->hHeap = (HANDLE) pvReserved1;

            *phContext = (SCARDCONTEXT) pRedirLocalContext;
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }
    else if ((lReturn == SCARD_E_NO_SERVICE) &&
             (g_hUnifiedStartedEvent != NULL))
    {
        //
        // This error indicates that the clients scardsvr service has been stopped,
        // so reset the unified started event
        //
        //OutputDebugString("SCREDIR: SCardEstablishContext: resetting g_hUnifiedStartedEvent\n");
        ResetEvent(g_hUnifiedStartedEvent);
        _SetStartedEventToCorrectState();
    }

Return:

    if (fFreeDecode)
    {
        _TRY_2(EstablishContext_Return_Free(h, &EstablishContextReturn))
    }

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    if ((phContext != NULL) && (*phContext != NULL))
    {
        MIDL_user_free((void *) *phContext);
        *phContext = NULL;
    }

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  I_ContextCallWithLongReturn
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_ContextCallWithLongReturn(
    IN SCARDCONTEXT hContext,
    ULONG IoControlCode)
{
    LONG                    lReturn             = SCARD_S_SUCCESS;
    NTSTATUS                Status              = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus           = RPC_S_OK;
    char                    *pbEncodedBuffer    = NULL;
    unsigned long           cbEncodedBuffer     = 0;
    handle_t                h                   = 0;
    BUFFER_LIST_STRUCT      *pOutputBuffer      = NULL;
    Context_Call            ContextCall;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ContextCall params
    //
    ContextCall.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    _TRY_(Context_Call_Encode(h, &ContextCall))

    //
    // Make the IoControl call to the client
    //
    Status = _SendSCardIOCTL(
                    IoControlCode,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }

    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardReleaseContext
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardReleaseContext(
    IN SCARDCONTEXT hContext)
{
    LONG lReturn = SCARD_S_SUCCESS;

    __try
    {
        if (hContext == NULL)
        {
            return (SCARD_E_INVALID_PARAMETER);
        }

        lReturn = I_ContextCallWithLongReturn(
                        hContext,
                        SCARD_IOCTL_RELEASECONTEXT);

        MIDL_user_free((REDIR_LOCAL_SCARDCONTEXT *) hContext);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    return (lReturn);
}


//---------------------------------------------------------------------------------------
//
//  SCardIsValidContext
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardIsValidContext(
    IN SCARDCONTEXT hContext)
{
    return (I_ContextCallWithLongReturn(
                hContext,
                SCARD_IOCTL_ISVALIDCONTEXT));
}


//---------------------------------------------------------------------------------------
//
//  SCardListReaderGroups
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_SCardListReaderGroups(
    IN SCARDCONTEXT hContext,
    OUT LPBYTE mszGroups,
    IN OUT LPDWORD pcchGroups,
    IN BOOL fUnicode)
{
    LONG                    lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                Status                  = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus               = RPC_S_OK;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                h                       = 0;
    BUFFER_LIST_STRUCT      *pOutputBuffer          = NULL;
    ListReaderGroups_Call   ListReaderGroupsCall;
    ListReaderGroups_Return ListReaderGroupsReturn;

    if (pcchGroups == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ListReaderGroups params
    //
    if (hContext != NULL)
    {
        ListReaderGroupsCall.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    }
    else
    {
        ListReaderGroupsCall.Context.pbContext = NULL;
        ListReaderGroupsCall.Context.cbContext = 0;
    }
    ListReaderGroupsCall.fmszGroupsIsNULL   = (mszGroups == NULL);
    ListReaderGroupsCall.cchGroups          = *pcchGroups;
    _TRY_(ListReaderGroups_Call_Encode(h, &ListReaderGroupsCall))

    //
    // Make the ListReaderGroups call to the client
    //
    Status = _SendSCardIOCTL(
                    fUnicode ?  SCARD_IOCTL_LISTREADERGROUPSW :
                                SCARD_IOCTL_LISTREADERGROUPSA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ListReaderGroupsReturn, 0, sizeof(ListReaderGroupsReturn));
    _TRY_(ListReaderGroups_Return_Decode(h, &ListReaderGroupsReturn))

    //
    // If successful, then copy the returned multi string
    //
    if (ListReaderGroupsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        lReturn = _CopyReturnToCallerBuffer(
                        (REDIR_LOCAL_SCARDCONTEXT *) hContext,
                        ListReaderGroupsReturn.msz,
                        ListReaderGroupsReturn.cBytes,
                        mszGroups,
                        pcchGroups,
                        fUnicode ? WSZ_TYPE_RETURN : SZ_TYPE_RETURN);
    }
    else
    {
        lReturn = ListReaderGroupsReturn.ReturnCode;
    }

    _TRY_2(ListReaderGroups_Return_Free(h, &ListReaderGroupsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI
SCardListReaderGroupsA(
    IN SCARDCONTEXT hContext,
    OUT LPSTR mszGroups,
    IN OUT LPDWORD pcchGroups)
{
    return (I_SCardListReaderGroups(
                hContext,
                (LPBYTE) mszGroups,
                pcchGroups,
                FALSE));
}

WINSCARDAPI LONG WINAPI
SCardListReaderGroupsW(
    IN SCARDCONTEXT hContext,
    OUT LPWSTR mszGroups,
    IN OUT LPDWORD pcchGroups)
{
    return (I_SCardListReaderGroups(
                hContext,
                (LPBYTE) mszGroups,
                pcchGroups,
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  SCardListReaders
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_SCardListReaders(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE mszGroups,
    OUT LPBYTE mszReaders,
    IN OUT LPDWORD pcchReaders,
    IN BOOL fUnicode)
{
    LONG                    lReturn             = SCARD_S_SUCCESS;
    NTSTATUS                Status              = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus           = RPC_S_OK;
    char                    *pbEncodedBuffer    = NULL;
    unsigned long           cbEncodedBuffer     = 0;
    handle_t                h                   = 0;
    BUFFER_LIST_STRUCT      *pOutputBuffer      = NULL;
    ListReaders_Call        ListReadersCall;
    ListReaders_Return      ListReadersReturn;

    if (pcchReaders == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ListReaders params
    //
    if (hContext != NULL)
    {
        ListReadersCall.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    }
    else
    {
        ListReadersCall.Context.pbContext = NULL;
        ListReadersCall.Context.cbContext = 0;
    }
    ListReadersCall.cBytes              = fUnicode ?
                                                _CalculateNumBytesInMultiStringW((LPCWSTR) mszGroups) :
                                                _CalculateNumBytesInMultiStringA((LPCSTR) mszGroups);
    ListReadersCall.mszGroups           = mszGroups;
    ListReadersCall.fmszReadersIsNULL   = (mszReaders == NULL);
    ListReadersCall.cchReaders          = *pcchReaders;
    _TRY_(ListReaders_Call_Encode(h, &ListReadersCall))

    //
    // Make the ListReaders call to the client
    //
    Status = _SendSCardIOCTL(
                        fUnicode ?  SCARD_IOCTL_LISTREADERSW :
                                    SCARD_IOCTL_LISTREADERSA,
                        pbEncodedBuffer,
                        cbEncodedBuffer,
                        &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ListReadersReturn, 0, sizeof(ListReadersReturn));
    _TRY_(ListReaders_Return_Decode(h, &ListReadersReturn))

    //
    // If successful, then copy the returned multi string
    //
    if (ListReadersReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        lReturn = _CopyReturnToCallerBuffer(
                        (REDIR_LOCAL_SCARDCONTEXT *) hContext,
                        ListReadersReturn.msz,
                        ListReadersReturn.cBytes,
                        mszReaders,
                        pcchReaders,
                        fUnicode ? WSZ_TYPE_RETURN : SZ_TYPE_RETURN);
    }
    else
    {
        lReturn =  ListReadersReturn.ReturnCode;
    }

    _TRY_2(ListReaders_Return_Free(h, &ListReadersReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI
SCardListReadersA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR mszGroups,
    OUT LPSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    return (I_SCardListReaders(
                hContext,
                (LPCBYTE) mszGroups,
                (LPBYTE) mszReaders,
                pcchReaders,
                FALSE));
}

WINSCARDAPI LONG WINAPI
SCardListReadersW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszGroups,
    OUT LPWSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    return (I_SCardListReaders(
                hContext,
                (LPCBYTE) mszGroups,
                (LPBYTE) mszReaders,
                pcchReaders,
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  I_ContextAndStringCallWithLongReturn
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_ContextAndStringCallWithLongReturn(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE sz,
    IN BOOL fUnicode,
    ULONG IoControlCode)
{
    LONG                        lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                    Status                  = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    char                        *pbEncodedBuffer        = NULL;
    unsigned long               cbEncodedBuffer         = 0;
    handle_t                    h                       = 0;
    BUFFER_LIST_STRUCT          *pOutputBuffer          = NULL;
    ContextAndStringA_Call      ContextAndStringCallA;
    ContextAndStringW_Call      ContextAndStringCallW;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    else if (sz == NULL)
    {
        return (SCARD_E_INVALID_VALUE);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ContextAndString params
    //
    ContextAndStringCallA.Context =
        ContextAndStringCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;

    if (fUnicode)
    {
        ContextAndStringCallW.sz = (LPCWSTR) sz;
        _TRY_(ContextAndStringW_Call_Encode(h, &ContextAndStringCallW))
    }
    else
    {
        ContextAndStringCallA.sz = (LPCSTR) sz;
        _TRY_(ContextAndStringA_Call_Encode(h, &ContextAndStringCallA))
    }

    //
    // Make the call to the client
    //
    Status = _SendSCardIOCTL(
                IoControlCode,
                pbEncodedBuffer,
                cbEncodedBuffer,
                &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }

    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardIntroduceReaderGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_INTRODUCEREADERGROUPA));
}

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_INTRODUCEREADERGROUPW));
}


//---------------------------------------------------------------------------------------
//
//  SCardForgetReaderGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_FORGETREADERGROUPA));
}

WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_FORGETREADERGROUPW));
}


//---------------------------------------------------------------------------------------
//
//  I_ContextAndTwoStringCallWithLongReturn
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_ContextAndTwoStringCallWithLongReturn(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE sz1,
    IN LPCBYTE sz2,
    IN BOOL fUnicode,
    ULONG IoControlCode)
{
    LONG                        lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                    Status                      = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus                   = RPC_S_OK;
    char                        *pbEncodedBuffer            = NULL;
    unsigned long               cbEncodedBuffer             = 0;
    handle_t                    h                           = 0;
    BUFFER_LIST_STRUCT          *pOutputBuffer              = NULL;
    ContextAndTwoStringA_Call   ContextAndTwoStringCallA;
    ContextAndTwoStringW_Call   ContextAndTwoStringCallW;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    else if ((sz1 == NULL) ||
             (sz2 == NULL))
    {
        return (SCARD_E_INVALID_VALUE);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ContextAndTwoString params
    //
    ContextAndTwoStringCallA.Context =
        ContextAndTwoStringCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;

    if (fUnicode)
    {
        ContextAndTwoStringCallW.sz1 = (LPCWSTR) sz1;
        ContextAndTwoStringCallW.sz2 = (LPCWSTR) sz2;
        _TRY_(ContextAndTwoStringW_Call_Encode(h, &ContextAndTwoStringCallW))
    }
    else
    {
        ContextAndTwoStringCallA.sz1 = (LPCSTR) sz1;
        ContextAndTwoStringCallA.sz2 = (LPCSTR) sz2;
        _TRY_(ContextAndTwoStringA_Call_Encode(h, &ContextAndTwoStringCallA))
    }

    //
    // Make the call to the client
    //
    Status = _SendSCardIOCTL(
                    IoControlCode,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        MesHandleFree(h);
        ERROR_RETURN(_MakeSCardError(Status))
    }

    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardIntroduceReader
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardIntroduceReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szDeviceName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                (LPCBYTE) szDeviceName,
                FALSE,
                SCARD_IOCTL_INTRODUCEREADERA));
}

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szDeviceName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                (LPCBYTE) szDeviceName,
                TRUE,
                SCARD_IOCTL_INTRODUCEREADERW));
}


//---------------------------------------------------------------------------------------
//
//  SCardForgetReader
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardForgetReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                FALSE,
                SCARD_IOCTL_FORGETREADERA));
}

WINSCARDAPI LONG WINAPI
SCardForgetReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                TRUE,
                SCARD_IOCTL_FORGETREADERW));
}


//---------------------------------------------------------------------------------------
//
//  SCardAddReaderToGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_ADDREADERTOGROUPA));
}

WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_ADDREADERTOGROUPW));
}


//---------------------------------------------------------------------------------------
//
//  SCardRemoveReaderFromGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_REMOVEREADERFROMGROUPA));
}

WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext,
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_REMOVEREADERFROMGROUPW));
}


//---------------------------------------------------------------------------------------
//
//  _AllocAndCopyReaderState*StructsForCall and _CopyReaderState*StructsForReturn
//
//---------------------------------------------------------------------------------------
LONG
_AllocAndCopyReaderStateAStructsForCall(
    DWORD                   cReaders,
    ReaderStateA            **prgReaderStatesToEncodeA,
    LPSCARD_READERSTATE_A   rgReaderStates)
{
    DWORD           i;
    ReaderStateA    *rgAlloced;

    rgAlloced = (ReaderStateA *)
            MIDL_user_allocate(cReaders * sizeof(ReaderStateA));

    if (rgAlloced == NULL)
    {
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cReaders; i++)
    {
        rgAlloced[i].Common.dwCurrentState =
                rgReaderStates[i].dwCurrentState;
        rgAlloced[i].Common.dwEventState =
                rgReaderStates[i].dwEventState;
        rgAlloced[i].Common.cbAtr =
            rgReaderStates[i].cbAtr;
        memcpy(
            rgAlloced[i].Common.rgbAtr,
            rgReaderStates[i].rgbAtr,
            36);
        rgAlloced[i].szReader =
                rgReaderStates[i].szReader;
    }

    *prgReaderStatesToEncodeA = rgAlloced;

    return (SCARD_S_SUCCESS);
}

LONG
_AllocAndCopyReaderStateWStructsForCall(
    DWORD                   cReaders,
    ReaderStateW            **prgReaderStatesToEncodeW,
    LPSCARD_READERSTATE_W   rgReaderStates)
{
    DWORD           i;
    ReaderStateW    *rgAlloced;

    rgAlloced = (ReaderStateW *)
            MIDL_user_allocate(cReaders * sizeof(ReaderStateW));

    if (rgAlloced == NULL)
    {
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cReaders; i++)
    {
        rgAlloced[i].Common.dwCurrentState =
                rgReaderStates[i].dwCurrentState;
        rgAlloced[i].Common.dwEventState =
                rgReaderStates[i].dwEventState;
        rgAlloced[i].Common.cbAtr =
            rgReaderStates[i].cbAtr;
        memcpy(
            rgAlloced[i].Common.rgbAtr,
            rgReaderStates[i].rgbAtr,
            36);
        rgAlloced[i].szReader =
                rgReaderStates[i].szReader;
    }

    *prgReaderStatesToEncodeW = rgAlloced;

    return (SCARD_S_SUCCESS);
}

void
_CopyReaderStateAStructsForReturn(
    DWORD                   cReaders,
    LPSCARD_READERSTATE_A   rgReaderStates,
    ReaderState_Return      *rgReaderStatesReturned)
{
    DWORD i;

    for (i=0; i<cReaders; i++)
    {
        rgReaderStates[i].dwCurrentState =
                rgReaderStatesReturned[i].dwCurrentState;
        rgReaderStates[i].dwEventState =
                rgReaderStatesReturned[i].dwEventState;
        rgReaderStates[i].cbAtr =
                rgReaderStatesReturned[i].cbAtr;
        memcpy(
            rgReaderStates[i].rgbAtr,
            rgReaderStatesReturned[i].rgbAtr,
            36);
    }
}

void
_CopyReaderStateWStructsForReturn(
    DWORD                   cReaders,
    LPSCARD_READERSTATE_W   rgReaderStates,
    ReaderState_Return      *rgReaderStatesReturned)
{
    DWORD i;

    for (i=0; i<cReaders; i++)
    {
        rgReaderStates[i].dwCurrentState =
                rgReaderStatesReturned[i].dwCurrentState;
        rgReaderStates[i].dwEventState =
                rgReaderStatesReturned[i].dwEventState;
        rgReaderStates[i].cbAtr =
                rgReaderStatesReturned[i].cbAtr;
        memcpy(
            rgReaderStates[i].rgbAtr,
            rgReaderStatesReturned[i].rgbAtr,
            36);
    }
}


//---------------------------------------------------------------------------------------
//
//  _AllocAndCopyATRMasksForCall
//
//---------------------------------------------------------------------------------------
LONG
_AllocAndCopyATRMasksForCall(
    DWORD                   cAtrs,
    LocateCards_ATRMask     **prgATRMasksToEncode,
    LPSCARD_ATRMASK         rgAtrMasks)
{
    DWORD               i;
    LocateCards_ATRMask *rgAlloced;

    rgAlloced = (LocateCards_ATRMask *)
            MIDL_user_allocate(cAtrs * sizeof(LocateCards_ATRMask));

    if (rgAlloced == NULL)
    {
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cAtrs; i++)
    {
        rgAlloced[i].cbAtr = rgAtrMasks[i].cbAtr;
        memcpy(
            rgAlloced[i].rgbAtr,
            rgAtrMasks[i].rgbAtr,
            36);
        memcpy(
            rgAlloced[i].rgbMask,
            rgAtrMasks[i].rgbMask,
            36);
    }

    *prgATRMasksToEncode = rgAlloced;

    return (SCARD_S_SUCCESS);
}

//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsA
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardLocateCardsA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR mszCards,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG                lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS            Status                      = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus                   = RPC_S_OK;
    char                *pbEncodedBuffer            = NULL;
    unsigned long       cbEncodedBuffer             = 0;
    handle_t            h                           = 0;
    LocateCardsA_Call   LocateCardsCallA;
    LocateCards_Return  LocateCardsReturn;
    ReaderStateA        *rgReaderStatesToEncodeA    = NULL;
    BUFFER_LIST_STRUCT  *pOutputBuffer              = NULL;
    DWORD               i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    else if (mszCards == NULL)
    {
        return (SCARD_E_INVALID_VALUE);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    LocateCardsCallA.Context =  ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsCallA.cBytes = _CalculateNumBytesInMultiStringA(mszCards);
    LocateCardsCallA.mszCards = (LPCBYTE) mszCards;
    LocateCardsCallA.cReaders = cReaders;

    lReturn = _AllocAndCopyReaderStateAStructsForCall(
                    cReaders,
                    &rgReaderStatesToEncodeA,
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsCallA.rgReaderStates = rgReaderStatesToEncodeA;

    _TRY_(LocateCardsA_Call_Encode(h, &LocateCardsCallA))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0 , sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))

    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Validate return info
        //
        if (cReaders != LocateCardsReturn.cReaders)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        _CopyReaderStateAStructsForReturn(
                cReaders,
                rgReaderStates,
                LocateCardsReturn.rgReaderStates);
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeA);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsW
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardLocateCardsW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszCards,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG                lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS            Status                      = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus                   = RPC_S_OK;
    char                *pbEncodedBuffer            = NULL;
    unsigned long       cbEncodedBuffer             = 0;
    handle_t            h                           = 0;
    LocateCardsW_Call   LocateCardsCallW;
    LocateCards_Return  LocateCardsReturn;
    ReaderStateW        *rgReaderStatesToEncodeW    = NULL;
    BUFFER_LIST_STRUCT  *pOutputBuffer              = NULL;
    DWORD               i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    else if (mszCards == NULL)
    {
        return (SCARD_E_INVALID_VALUE);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    LocateCardsCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsCallW.cBytes = _CalculateNumBytesInMultiStringW(mszCards);
    LocateCardsCallW.mszCards = (LPCBYTE) mszCards;
    LocateCardsCallW.cReaders = cReaders;

    lReturn = _AllocAndCopyReaderStateWStructsForCall(
                    cReaders,
                    &rgReaderStatesToEncodeW,
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsCallW.rgReaderStates = rgReaderStatesToEncodeW;

    _TRY_(LocateCardsW_Call_Encode(h, &LocateCardsCallW))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSW,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0, sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))

    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Validate return info
        //
        if (cReaders != LocateCardsReturn.cReaders)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        _CopyReaderStateWStructsForReturn(
                cReaders,
                rgReaderStates,
                LocateCardsReturn.rgReaderStates);
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeW);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsByATRA
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRA(
    IN SCARDCONTEXT hContext,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    LocateCardsByATRA_Call  LocateCardsByATRA_Call;
    LocateCards_ATRMask     *rgATRMasksToEncode         = NULL;
    LocateCards_Return      LocateCardsReturn;
    ReaderStateA            *rgReaderStatesToEncodeA    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    LocateCardsByATRA_Call.Context =  ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsByATRA_Call.cAtrs = cAtrs;
    LocateCardsByATRA_Call.cReaders = cReaders;

    lReturn = _AllocAndCopyATRMasksForCall(
                    cAtrs,
                    &rgATRMasksToEncode,
                    rgAtrMasks);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRA_Call.rgAtrMasks = rgATRMasksToEncode;

    lReturn = _AllocAndCopyReaderStateAStructsForCall(
                    cReaders,
                    &rgReaderStatesToEncodeA,
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRA_Call.rgReaderStates = rgReaderStatesToEncodeA;

    _TRY_(LocateCardsByATRA_Call_Encode(h, &LocateCardsByATRA_Call))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSBYATRA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0 , sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))

    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Validate return info
        //
        if (cReaders != LocateCardsReturn.cReaders)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        _CopyReaderStateAStructsForReturn(
                cReaders,
                rgReaderStates,
                LocateCardsReturn.rgReaderStates);
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgATRMasksToEncode);

    MIDL_user_free(rgReaderStatesToEncodeA);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsByATRW
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRW(
    IN SCARDCONTEXT hContext,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    LocateCardsByATRW_Call  LocateCardsByATRW_Call;
    LocateCards_ATRMask     *rgATRMasksToEncode         = NULL;
    LocateCards_Return      LocateCardsReturn;
    ReaderStateW            *rgReaderStatesToEncodeW    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    LocateCardsByATRW_Call.Context =  ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsByATRW_Call.cAtrs = cAtrs;
    LocateCardsByATRW_Call.cReaders = cReaders;

    lReturn = _AllocAndCopyATRMasksForCall(
                    cAtrs,
                    &rgATRMasksToEncode,
                    rgAtrMasks);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRW_Call.rgAtrMasks = rgATRMasksToEncode;

    lReturn = _AllocAndCopyReaderStateWStructsForCall(
                    cReaders,
                    &rgReaderStatesToEncodeW,
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRW_Call.rgReaderStates = rgReaderStatesToEncodeW;

    _TRY_(LocateCardsByATRW_Call_Encode(h, &LocateCardsByATRW_Call))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSBYATRW,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0 , sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))

    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Validate return info
        //
        if (cReaders != LocateCardsReturn.cReaders)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        _CopyReaderStateWStructsForReturn(
                cReaders,
                rgReaderStates,
                LocateCardsReturn.rgReaderStates);
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgATRMasksToEncode);

    MIDL_user_free(rgReaderStatesToEncodeW);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardGetStatusChangeA
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardGetStatusChangeA(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    GetStatusChangeA_Call   GetStatusChangeCallA;
    GetStatusChange_Return  GetStatusChangeReturn;
    ReaderStateA            *rgReaderStatesToEncodeA    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    GetStatusChangeCallA.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    GetStatusChangeCallA.dwTimeOut = dwTimeout;
    GetStatusChangeCallA.cReaders = cReaders;

    lReturn = _AllocAndCopyReaderStateAStructsForCall(
                    cReaders,
                    &rgReaderStatesToEncodeA,
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }

    GetStatusChangeCallA.rgReaderStates = rgReaderStatesToEncodeA;

    _TRY_(GetStatusChangeA_Call_Encode(h, &GetStatusChangeCallA))

    //
    // Make the GetStatusChange call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_GETSTATUSCHANGEA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&GetStatusChangeReturn, 0, sizeof(GetStatusChangeReturn));
    _TRY_(GetStatusChange_Return_Decode(h, &GetStatusChangeReturn))

    lReturn = GetStatusChangeReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Validate return info
        //
        if (cReaders != GetStatusChangeReturn.cReaders)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        _CopyReaderStateAStructsForReturn(
                cReaders,
                rgReaderStates,
                GetStatusChangeReturn.rgReaderStates);
    }
    else if ((lReturn == SCARD_E_SYSTEM_CANCELLED) &&
             (g_hUnifiedStartedEvent != NULL))
    {
        //
        // This error indicates that the clients scardsvr service has been stopped,
        // so reset the unified started event
        //
        //OutputDebugString("SCREDIR: SCardGetStatusChangeA: resetting g_hUnifiedStartedEvent\n");
        ResetEvent(g_hUnifiedStartedEvent);
        _SetStartedEventToCorrectState();
    }

    _TRY_2(GetStatusChange_Return_Free(h, &GetStatusChangeReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeA);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardGetStatusChangew
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardGetStatusChangeW(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    GetStatusChangeW_Call   GetStatusChangeCallW;
    GetStatusChange_Return  GetStatusChangeReturn;
    ReaderStateW            *rgReaderStatesToEncodeW    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    GetStatusChangeCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    GetStatusChangeCallW.dwTimeOut = dwTimeout;
    GetStatusChangeCallW.cReaders = cReaders;

    lReturn = _AllocAndCopyReaderStateWStructsForCall(
                    cReaders,
                    &rgReaderStatesToEncodeW,
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }

    GetStatusChangeCallW.rgReaderStates = rgReaderStatesToEncodeW;

    _TRY_(GetStatusChangeW_Call_Encode(h, &GetStatusChangeCallW))

    //
    // Make the GetStatusChange call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_GETSTATUSCHANGEW,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&GetStatusChangeReturn, 0, sizeof(GetStatusChangeReturn));
    _TRY_(GetStatusChange_Return_Decode(h, &GetStatusChangeReturn))

    lReturn = GetStatusChangeReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Validate return info
        //
        if (cReaders != GetStatusChangeReturn.cReaders)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        _CopyReaderStateWStructsForReturn(
                cReaders,
                rgReaderStates,
                GetStatusChangeReturn.rgReaderStates);
    }
    else if ((lReturn == SCARD_E_SYSTEM_CANCELLED) &&
             (g_hUnifiedStartedEvent != NULL))
    {
        //
        // This error indicates that the clients scardsvr service has been stopped,
        // so reset the unified started event
        //
        //OutputDebugString("SCREDIR: SCardGetStatusChangeW: resetting g_hUnifiedStartedEvent\n");
        ResetEvent(g_hUnifiedStartedEvent);
        _SetStartedEventToCorrectState();
    }

    _TRY_2(GetStatusChange_Return_Free(h, &GetStatusChangeReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeW);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI
SCardCancel(
    IN SCARDCONTEXT hContext)
{
    return (I_ContextCallWithLongReturn(
                hContext,
                SCARD_IOCTL_CANCEL));
}


//---------------------------------------------------------------------------------------
//
//  SCardConnect
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_SCardConnect(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE szReader,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT LPSCARDHANDLE phCard,
    OUT LPDWORD pdwActiveProtocol,
    IN BOOL fUnicode)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    ConnectA_Call       ConnectCallA;
    ConnectW_Call       ConnectCallW;
    Connect_Return      ConnectReturn;

    if ((hContext == NULL) ||
        (phCard == NULL) ||
        (pdwActiveProtocol == NULL))
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    else if (szReader == NULL)
    {
        return (SCARD_E_INVALID_VALUE);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Connect params
    //
    ConnectCallA.Common.Context =
        ConnectCallW.Common.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    ConnectCallA.Common.dwShareMode =
        ConnectCallW.Common.dwShareMode = dwShareMode;
    ConnectCallA.Common.dwPreferredProtocols =
        ConnectCallW.Common.dwPreferredProtocols = dwPreferredProtocols;

    if (fUnicode)
    {
        ConnectCallW.szReader = (LPCWSTR) szReader;
        _TRY_(ConnectW_Call_Encode(h, &ConnectCallW))
    }
    else
    {
        ConnectCallA.szReader = (LPCSTR) szReader;
        _TRY_(ConnectA_Call_Encode(h, &ConnectCallA))
    }

    //
    // Make the ListInterfaces call to the client
    //
    Status = _SendSCardIOCTL(
                    fUnicode ?  SCARD_IOCTL_CONNECTW :
                                SCARD_IOCTL_CONNECTA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ConnectReturn, 0, sizeof(ConnectReturn));
    _TRY_(Connect_Return_Decode(h, &ConnectReturn))

    lReturn =  ConnectReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        REDIR_LOCAL_SCARDHANDLE *pRedirHandle = NULL;

        //
        // The value that represents the SCARDHANDLE on the remote client
        // machine is a variable size, so allocate memory to for the struct
        // that holds the variable length handle size and pointer, plus
        // the actual bytes for the handle, it also holds the context
        //

        if (ConnectReturn.hCard.cbHandle > MAX_SCARDHANDLE_SIZE)
        {
            ERROR_RETURN(SCARD_E_UNEXPECTED)
        }

        pRedirHandle = (REDIR_LOCAL_SCARDHANDLE *)
                                MIDL_user_allocate(
                                    sizeof(REDIR_LOCAL_SCARDHANDLE)   +
                                    ConnectReturn.hCard.cbHandle);

        if (pRedirHandle != NULL)
        {
            pRedirHandle->pRedirContext = (REDIR_LOCAL_SCARDCONTEXT *) hContext;

            pRedirHandle->Handle.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;

            pRedirHandle->Handle.cbHandle = ConnectReturn.hCard.cbHandle;
            pRedirHandle->Handle.pbHandle = ((BYTE *) pRedirHandle) +
                                                sizeof(REDIR_LOCAL_SCARDHANDLE);
            memcpy(
                pRedirHandle->Handle.pbHandle,
                ConnectReturn.hCard.pbHandle,
                ConnectReturn.hCard.cbHandle);

            *phCard = (SCARDHANDLE) pRedirHandle;

            // The original Winscard API implements this parameter as
            // Optional.  We need to preserve that behavior.
            if (NULL != pdwActiveProtocol)
                *pdwActiveProtocol = ConnectReturn.dwActiveProtocol;
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }

    _TRY_2(Connect_Return_Free(h, &ConnectReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI
SCardConnectA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReader,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT LPSCARDHANDLE phCard,
    OUT LPDWORD pdwActiveProtocol)
{
    return (I_SCardConnect(
                hContext,
                (LPCBYTE) szReader,
                dwShareMode,
                dwPreferredProtocols,
                phCard,
                pdwActiveProtocol,
                FALSE));
}

WINSCARDAPI LONG WINAPI
SCardConnectW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReader,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT LPSCARDHANDLE phCard,
    OUT LPDWORD pdwActiveProtocol)
{
    return (I_SCardConnect(
                hContext,
                (LPCBYTE) szReader,
                dwShareMode,
                dwPreferredProtocols,
                phCard,
                pdwActiveProtocol,
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  SCardReconnect
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardReconnect(
    IN SCARDHANDLE hCard,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    IN DWORD dwInitialization,
    OUT LPDWORD pdwActiveProtocol)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Reconnect_Call      ReconnectCall;
    Reconnect_Return    ReconnectReturn;

    if ((hCard == NULL) ||
        (pdwActiveProtocol == NULL))
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    ReconnectCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    ReconnectCall.dwShareMode = dwShareMode;
    ReconnectCall.dwPreferredProtocols = dwPreferredProtocols;
    ReconnectCall.dwInitialization = dwInitialization;

    _TRY_(Reconnect_Call_Encode(h, &ReconnectCall))

    //
    // Make the Reconnect call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_RECONNECT,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ReconnectReturn, 0, sizeof(ReconnectReturn));
    _TRY_(Reconnect_Return_Decode(h, &ReconnectReturn))

    lReturn =  ReconnectReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        // The original Winscard API implements this parameter as
        // Optional.  We need to preserve that behavior.
        if (NULL != pdwActiveProtocol)
            *pdwActiveProtocol = ReconnectReturn.dwActiveProtocol;
    }

    _TRY_2(Reconnect_Return_Free(h, &ReconnectReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  I_HCardAndDispositionCall
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_HCardAndDispositionCall(
    IN SCARDHANDLE hCard,
    IN DWORD dwDisposition,
    ULONG IoControlCode)
{
    LONG                        lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                    Status                  = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    char                        *pbEncodedBuffer        = NULL;
    unsigned long               cbEncodedBuffer         = 0;
    handle_t                    h                       = 0;
    BUFFER_LIST_STRUCT          *pOutputBuffer          = NULL;
    HCardAndDisposition_Call    HCardAndDispositionCall;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    HCardAndDispositionCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    HCardAndDispositionCall.dwDisposition = dwDisposition;

    _TRY_(HCardAndDisposition_Call_Encode(h, &HCardAndDispositionCall))

    //
    // Make the Reconnect call to the client
    //
    Status = _SendSCardIOCTL(
                    IoControlCode,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }

    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardDisconnect
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardDisconnect(
    IN SCARDHANDLE hCard,
    IN DWORD dwDisposition)
{
    LONG lReturn = SCARD_S_SUCCESS;

    lReturn = I_HCardAndDispositionCall(
                    hCard,
                    dwDisposition,
                    SCARD_IOCTL_DISCONNECT);

    MIDL_user_free((REDIR_SCARDHANDLE *) hCard);

    return (lReturn);
}


//---------------------------------------------------------------------------------------
//
//  SCardBeginTransaction
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardBeginTransaction(
    IN SCARDHANDLE hCard)
{
    return (I_HCardAndDispositionCall(
                hCard,
                0, // SCardBeginTransaction doesn't use a dispostion, so just set to 0
                SCARD_IOCTL_BEGINTRANSACTION));
}


//---------------------------------------------------------------------------------------
//
//  SCardEndTransaction
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardEndTransaction(
    IN SCARDHANDLE hCard,
    IN DWORD dwDisposition)
{
    return (I_HCardAndDispositionCall(
                hCard,
                dwDisposition,
                SCARD_IOCTL_ENDTRANSACTION));
}


//---------------------------------------------------------------------------------------
//
//  SCardState
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardState(
    IN SCARDHANDLE hCard,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    State_Call          StateCall;
    State_Return        StateReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    StateCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    StateCall.fpbAtrIsNULL = (pbAtr == NULL);
    StateCall.cbAtrLen = *pcbAtrLen;

    _TRY_(State_Call_Encode(h, &StateCall))

    //
    // Make the Reconnect call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_STATE,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&StateReturn, 0, sizeof(StateReturn));
    _TRY_(State_Return_Decode(h, &StateReturn))

    lReturn =  StateReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // The original Winscard API implements each of these
        // parameters as Optional.  We need to preserve that behavior.
        //

        if (NULL != pdwState)
            *pdwState = StateReturn.dwState;

        if (NULL != pdwProtocol)
            *pdwProtocol = StateReturn.dwProtocol;

        if (NULL != pcbAtrLen)
        {
            lReturn = _CopyReturnToCallerBuffer(
                            ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                            StateReturn.rgAtr,
                            StateReturn.cbAtrLen,
                            pbAtr,
                            pcbAtrLen,
                            BYTE_TYPE_RETURN);
        }
    }

    _TRY_2(State_Return_Free(h, &StateReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardStatus
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
I_SCardStatus(
    IN SCARDHANDLE hCard,
    OUT LPBYTE mszReaderNames,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen,
    IN BOOL fUnicode)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Status_Call         StatusCall;
    Status_Return       StatusReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    StatusCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    StatusCall.fmszReaderNamesIsNULL = (mszReaderNames == NULL);
    StatusCall.cchReaderLen = *pcchReaderLen;
    StatusCall.cbAtrLen = *pcbAtrLen;

    _TRY_(Status_Call_Encode(h, &StatusCall))

    //
    // Make the Status call to the client
    //
    Status = _SendSCardIOCTL(
                    fUnicode ?  SCARD_IOCTL_STATUSW :
                                SCARD_IOCTL_STATUSA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&StatusReturn, 0, sizeof(StatusReturn));
    _TRY_(Status_Return_Decode(h, &StatusReturn))

    if (StatusReturn.cbAtrLen > sizeof(StatusReturn.pbAtr))
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    lReturn =  StatusReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // The original Winscard API implements each of these
        // parameters as Optional.  We need to preserve that behavior.
        //

        if (NULL != pcchReaderLen)
        {
            lReturn = _CopyReturnToCallerBuffer(
                            ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                            StatusReturn.mszReaderNames,
                            StatusReturn.cBytes,
                            mszReaderNames,
                            pcchReaderLen,
                            fUnicode ? WSZ_TYPE_RETURN : SZ_TYPE_RETURN);
        }

        if (lReturn == SCARD_S_SUCCESS)
        {
            if (NULL != pdwState)
                *pdwState = StatusReturn.dwState;

            if (NULL != pdwProtocol)
                *pdwProtocol = StatusReturn.dwProtocol;

            if (NULL != pcbAtrLen)
            {
                if ((NULL != pbAtr) && (*pcbAtrLen >= StatusReturn.cbAtrLen))
                {
                    memcpy(
                        pbAtr,
                        StatusReturn.pbAtr,
                        StatusReturn.cbAtrLen);
                }

                *pcbAtrLen = StatusReturn.cbAtrLen;
            }
        }
    }

    _TRY_2(Status_Return_Free(h, &StatusReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI
SCardStatusA(
    IN SCARDHANDLE hCard,
    OUT LPSTR mszReaderNames,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    return (I_SCardStatus(
                hCard,
                (LPBYTE) mszReaderNames,
                pcchReaderLen,
                pdwState,
                pdwProtocol,
                pbAtr,
                pcbAtrLen,
                FALSE));
}

WINSCARDAPI LONG WINAPI
SCardStatusW(
    IN SCARDHANDLE hCard,
    OUT LPWSTR mszReaderNames,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    return (I_SCardStatus(
                hCard,
                (LPBYTE) mszReaderNames,
                pcchReaderLen,
                pdwState,
                pdwProtocol,
                pbAtr,
                pcbAtrLen,
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  SCardTransmit
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardTransmit(
    IN SCARDHANDLE hCard,
    IN LPCSCARD_IO_REQUEST pioSendPci,
    IN LPCBYTE pbSendBuffer,
    IN DWORD cbSendLength,
    IN OUT LPSCARD_IO_REQUEST pioRecvPci,
    OUT LPBYTE pbRecvBuffer,
    IN OUT LPDWORD pcbRecvLength)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Transmit_Call       TransmitCall;
    Transmit_Return     TransmitReturn;
    SCardIO_Request     ioRecvPci;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Transmit params
    //
    TransmitCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    TransmitCall.ioSendPci.dwProtocol = pioSendPci->dwProtocol;

    TransmitCall.ioSendPci.cbExtraBytes = pioSendPci->cbPciLength -
                                            sizeof(SCARD_IO_REQUEST);
    if (TransmitCall.ioSendPci.cbExtraBytes != 0)
    {
        TransmitCall.ioSendPci.pbExtraBytes = ((BYTE *) pioSendPci) +
                                                sizeof(SCARD_IO_REQUEST);
    }
    else
    {
        TransmitCall.ioSendPci.pbExtraBytes = NULL;
    }

    TransmitCall.cbSendLength = cbSendLength;
    TransmitCall.pbSendBuffer = pbSendBuffer;

    if (pioRecvPci != NULL)
    {
        TransmitCall.pioRecvPci = &ioRecvPci;
        ioRecvPci.dwProtocol = pioRecvPci->dwProtocol;
        ioRecvPci.cbExtraBytes = pioRecvPci->cbPciLength - sizeof(SCARD_IO_REQUEST);
        if (ioRecvPci.cbExtraBytes != 0)
        {
            ioRecvPci.pbExtraBytes = ((LPBYTE) pioRecvPci) + sizeof(SCARD_IO_REQUEST);
        }
        else
        {
            ioRecvPci.pbExtraBytes = NULL;
        }
    }
    else
    {
        TransmitCall.pioRecvPci = NULL;
    }

    TransmitCall.fpbRecvBufferIsNULL = (pbRecvBuffer == NULL);
    TransmitCall.cbRecvLength = *pcbRecvLength;

    _TRY_(Transmit_Call_Encode(h, &TransmitCall))

    //
    // Make the Status call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_TRANSMIT,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&TransmitReturn, 0, sizeof(TransmitReturn));
    _TRY_(Transmit_Return_Decode(h, &TransmitReturn))

    lReturn =  TransmitReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        if ((pioRecvPci != NULL) &&
            (TransmitReturn.pioRecvPci != NULL))
        {
            pioRecvPci->dwProtocol = TransmitReturn.pioRecvPci->dwProtocol;
            if ((TransmitReturn.pioRecvPci->cbExtraBytes != 0) &&
                (TransmitReturn.pioRecvPci->cbExtraBytes <=
                    (pioSendPci->cbPciLength - sizeof(SCARD_IO_REQUEST))))
            {
                memcpy(
                    ((LPBYTE) pioRecvPci) + sizeof(SCARD_IO_REQUEST),
                    TransmitReturn.pioRecvPci->pbExtraBytes,
                    TransmitReturn.pioRecvPci->cbExtraBytes);
            }
        }

        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        TransmitReturn.pbRecvBuffer,
                        TransmitReturn.cbRecvLength,
                        pbRecvBuffer,
                        pcbRecvLength,
                        BYTE_TYPE_RETURN);
    }

    _TRY_2(Transmit_Return_Free(h, &TransmitReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardControl
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardControl(
    IN SCARDHANDLE hCard,
    IN DWORD dwControlCode,
    IN LPCVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT LPVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Control_Call        ControlCall;
    Control_Return      ControlReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Control params
    //
    ControlCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    ControlCall.dwControlCode = dwControlCode;
    ControlCall.cbInBufferSize = cbInBufferSize;
    ControlCall.pvInBuffer = (LPCBYTE) pvInBuffer;
    ControlCall.fpvOutBufferIsNULL = (pvOutBuffer == NULL);
    ControlCall.cbOutBufferSize = cbOutBufferSize;

    _TRY_(Control_Call_Encode(h, &ControlCall))

    //
    // Make the Control call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_CONTROL,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ControlReturn, 0, sizeof(ControlReturn));
    _TRY_(Control_Return_Decode(h, &ControlReturn))

    lReturn =  ControlReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        *pcbBytesReturned = ControlReturn.cbOutBufferSize;
        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        ControlReturn.pvOutBuffer,
                        ControlReturn.cbOutBufferSize,
                        (LPBYTE) pvOutBuffer,
                        pcbBytesReturned,
                        BYTE_TYPE_RETURN);
    }

    _TRY_2(Control_Return_Free(h, &ControlReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardGetAttrib
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    GetAttrib_Call      GetAttribCall;
    GetAttrib_Return    GetAttribReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the GetAttrib params
    //
    GetAttribCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    GetAttribCall.dwAttrId = dwAttrId;;
    GetAttribCall.fpbAttrIsNULL = (pbAttr == NULL);
    GetAttribCall.cbAttrLen = *pcbAttrLen;

    _TRY_(GetAttrib_Call_Encode(h, &GetAttribCall))

    //
    // Make the GetAttrib call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_GETATTRIB,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes,
                        pOutputBuffer->cbBytesUsed,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&GetAttribReturn, 0, sizeof(GetAttribReturn));
    _TRY_(GetAttrib_Return_Decode(h, &GetAttribReturn))

    lReturn =  GetAttribReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        GetAttribReturn.pbAttr,
                        GetAttribReturn.cbAttrLen,
                        (LPBYTE) pbAttr,
                        pcbAttrLen,
                        BYTE_TYPE_RETURN);
    }

    _TRY_2(GetAttrib_Return_Free(h, &GetAttribReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardSetAttrib
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardSetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    IN LPCBYTE pbAttr,
    IN DWORD cbAttrLen)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    SetAttrib_Call      SetAttribCall;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the SetAttrib params
    //
    SetAttribCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    SetAttribCall.dwAttrId = dwAttrId;;
    SetAttribCall.pbAttr = pbAttr;
    SetAttribCall.cbAttrLen = cbAttrLen;

    _TRY_(SetAttrib_Call_Encode(h, &SetAttribCall))

    //
    // Make the SetAttrib call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_SETATTRIB,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }

    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardAccessStartedEvent
//
//---------------------------------------------------------------------------------------
WINSCARDAPI HANDLE WINAPI
SCardAccessStartedEvent(void)
{
    HANDLE h;

    h = _GetStartedEventHandle();

    if ((h == NULL) || !_SetStartedEventToCorrectState())
    {
        //
        // Either we couldn't create the event, or we couldn't start the thread to set
        // the event, so return NULL
        //
        return (NULL);
    }

    //
    // Check to see if the event is already set, if not, give the thread which sets
    // the event a chance to run and set the event before returning
    //
    if (WAIT_OBJECT_0 != WaitForSingleObject(h, 0))
    {
        WaitForSingleObject(h, 10);
    }

    //
    // This API has old semantics where it just return the handle straight away
    // instead of duplicating it.
    //
    return (h);
}


//---------------------------------------------------------------------------------------
//
//  SCardReleaseStartedEvent
//
//---------------------------------------------------------------------------------------
WINSCARDAPI void WINAPI
SCardReleaseStartedEvent(void)
{
    return;
}


//---------------------------------------------------------------------------------------
//
//  SCardReleaseBadContext
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI
SCardReleaseBadContext(
    IN SCARDCONTEXT hContext)
{
    MIDL_user_free((REDIR_LOCAL_SCARDCONTEXT *) hContext);
    return (SCARD_S_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\server\calserve.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CalServe

Abstract:

    This is the primary header file for the Calais Service Manager Server
    application.  It stores common definitions and references the other major
    header files.

Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CALSERVE_H_
#define _CALSERVE_H_

#include <eh.h>
#include <WinSCard.h>
#include <calmsgs.h>
#include <SCardLib.h>
#include <CalCom.h>
#include <SCardErr.h>

#define CALAIS_STACKSIZE 0 // Default stack.

#define NEW_THREAD set_terminate(CalaisTerminate)


//
// Critical Sections and reference numbers.
// &g_csControlLocks[CSLOCK_SERVERLOCK]
//

#define CSLOCK_CALAISCONTROL    0   // Lock for Calais control commands.
#define CSLOCK_SERVERLOCK       1   // Lock for server thread enumeration.

#ifdef DBG
#define CSLOCK_TRACELOCK        2   // Lock for tracing output.

#define CSLOCK_MAXLOCKS         3
#else
#define CSLOCK_MAXLOCKS         2
#endif

extern CCriticalSectionObject *g_pcsControlLocks[CSLOCK_MAXLOCKS];
extern CMultiEvent *g_phReaderChangeEvent;
extern DWORD g_dwDefaultIOMax;


//
// Calais Control definitions.
//

class CReader;
class CReaderReference;

extern DWORD
CalaisStart(
    void);

extern DWORD
CalaisReaderCount(
    void);

extern DWORD
CalaisCountReaders(
    void);

extern CReaderReference *
CalaisLockReader(
    LPCTSTR szReader);

extern void
CalaisReleaseReader(
    CReaderReference **ppRdrRef);

extern DWORD
CalaisAddReader(
    IN CReader *pRdr);

extern DWORD
CalaisAddReader(
    IN LPCTSTR szReader,
    IN DWORD dwFlags);

extern BOOL
CalaisQueryReader(
    HANDLE hReader);

extern LPCTSTR
CalaisDisableReader(
    HANDLE hDriver);

extern LPCTSTR
CalaisConfirmClosingReader(
    HANDLE hDriver);

extern DWORD
CalaisRemoveReader(
    IN LPCTSTR szReader);

extern DWORD
CalaisRemoveReader(
    LPVOID hAppCtrl);

extern DWORD
CalaisRemoveReader(
    DWORD dwIndex);

extern DWORD
CalaisRemoveDevice(
    LPCTSTR szDevice);

extern void
CalaisStop(
    void);

extern DWORD WINAPI
CalaisTerminateReader(
    LPVOID pvParam);    // Don't call this except from CalaisRemoveReader.

extern HANDLE g_hCalaisShutdown;

extern void
AppInitializeDeviceRegistration(
    SERVICE_STATUS_HANDLE hService,
    DWORD dwType);

extern void
AppTerminateDeviceRegistration(
    void);

extern void
AppRegisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState);

extern void
AppUnregisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState);

extern void __cdecl
CalaisTerminate(
    void);


//
//==============================================================================
//
//  CReader
//

#define RDRFLAG_PNPMONITOR  0x0001  // This reader should be monitored by the
                                    // PnP subsystem.

class CReader
{
public:

    typedef enum {
        Undefined,      // Used to indicate an unset value
        Idle,           // No card inserted, unconnected
        Present,        // Card present, but not reset
        Unresponsive,   // Tried to initalize, but failed
        Unsupported,    // The card isn't supported by this reader
        Ready,          // Card inserted, powered, w/ ATR, unconnected
        Shared,         // Ready + connected shared
        Exclusive,      // Ready + connected exclusive
        Direct,         // Connected in raw mode.
        Closing,        // Shutting down, no new connections accepted.
        Broken,         // Something is wrong, reader disabled
        Inactive        // Starting up or completely shut down.
    } AvailableState;

    typedef struct {
        DWORD dwInsertCount;
        DWORD dwRemoveCount;
        DWORD dwResetCount;
    } ActiveState;

    //  Constructors & Destructor
    CReader();
    virtual ~CReader();

    BOOL InitFailed(void) 
    { 
        return 
            m_rwLock.InitFailed() || 
            m_mtxGrab.InitFailed() ||
            m_ChangeEvent.InitFailed();
    }

    //  Properties

    //  Overridable Methods
    virtual void Initialize(void);
    virtual void Close(void);
    virtual void Disable(void);
    virtual HANDLE ReaderHandle(void) const;
    virtual LPCTSTR DeviceName(void) const;
    virtual DWORD
    Control(
        DWORD dwCode,
        LPCBYTE pbSend = NULL,
        DWORD cbSend = 0,
        LPBYTE pbRecv = NULL,
        LPDWORD pcbLen = NULL,
        BOOL fLogError = TRUE);

    // Trivial inline methods
    AvailableState AvailabilityStatus(void)
    {
        CLockRead rwLock(&m_rwLock);
        return m_dwAvailStatus;
    };
    HANDLE ChangeEvent(void)
    { return m_ChangeEvent.WaitHandle(); };
    LPCTSTR ReaderName(void) const
    { return (LPCTSTR)m_bfReaderName.Access(); };
    void Atr(CBuffer &bfAtr)
    {
        CLockRead rwLock(&m_rwLock);
        bfAtr.Set(m_bfCurrentAtr.Access(), m_bfCurrentAtr.Length());
    };
    DWORD Protocol(void)
    {
        CLockRead rwLock(&m_rwLock);
        return m_dwCurrentProtocol;
    };
    WORD ActivityHash(void)
    {
        CLockRead rwLock(&m_rwLock);
        return (WORD)(0x0000ffff &
                      (m_ActiveState.dwInsertCount
                       + m_ActiveState.dwRemoveCount));
    };
    BOOL IsGrabbedBy(DWORD dwThreadId)
    { return m_mtxGrab.IsGrabbedBy(dwThreadId); };
    BOOL IsGrabbedByMe(void)
    { return m_mtxGrab.IsGrabbedByMe(); };
    BOOL IsLatchedBy(DWORD dwThreadId)
    { return m_mtxLatch.IsGrabbedBy(dwThreadId); };
    BOOL IsLatchedByMe(void)
    { return m_mtxLatch.IsGrabbedByMe(); };
    BOOL ShareReader(void)
    { return m_mtxGrab.Share(); };
    BOOL Unlatch(void)
    { return m_mtxLatch.Share(); };
    DWORD GetCurrentState(void)
    {
        CLockRead rwLock(&m_rwLock);
        return m_dwCurrentState;
    };

    //  Base Object Methods
    void GrabReader(void);
    void LatchReader(const ActiveState *pActiveState);
    void VerifyActive(const ActiveState *pActiveState);
    void VerifyState(void);
    void Dispose(
        IN DWORD dwDisposition,
        IN OUT CReader::ActiveState *pActiveState);
    void Connect(
        IN DWORD dwShareMode,
        IN DWORD dwPreferredProtocols,
        OUT ActiveState *pActState);
    void Disconnect(
        IN OUT ActiveState *pActState,
        IN DWORD dwDisposition,
        OUT LPDWORD pdwDispSts);
    void Reconnect(
        IN DWORD dwShareMode,
        IN DWORD dwPreferredProtocols,
        IN DWORD dwDisposition,
        IN OUT ActiveState *pActState,
        OUT LPDWORD pdwDispSts);
    void Free(
        DWORD dwThreadId,
        DWORD dwDisposition);
    BOOL IsInUse(void);

    // Convenience routines
    void GetReaderAttr(DWORD dwAttr, CBuffer &bfValue, BOOL fLogError = TRUE);
    void SetReaderAttr(DWORD dwAttr, LPCVOID pvValue, DWORD cbValue, BOOL fLogError = TRUE);
    void SetReaderProto(DWORD dwProto);
    void ReaderTransmit(LPCBYTE pbSend, DWORD cbSend, CBuffer &bfRecv);
    void ReaderSwallow(void);
    void ReaderColdReset(CBuffer &bfAtr);
    void ReaderWarmReset(CBuffer &bfAtr);
    void ReaderPowerDown(void);
    void ReaderEject(void);
#ifdef SCARD_CONFISCATE_CARD
    void ReaderConfiscate(void);
#endif
    DWORD GetReaderState(void);
    DWORD
    GetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        BOOL fLogError = TRUE);
    void
    SetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        DWORD dwValue,
        BOOL fLogError = TRUE);
    DWORD GetReaderAttr(DWORD dwAttr, BOOL fLogError = TRUE);
    void SetReaderAttr(DWORD dwAttr, DWORD dwValue, BOOL fLogError = TRUE);
    DWORD
    Control(
        ActiveState *pActiveState,
        DWORD dwCode,
        LPCBYTE pbSend = NULL,
        DWORD cbSend = 0,
        LPBYTE pbRecv = NULL,
        LPDWORD pcbLen = NULL,
        BOOL fLogError = TRUE);
    void
    GetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        CBuffer &bfValue,
        BOOL fLogError = TRUE);
    void
    SetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        LPCVOID pvValue,
        DWORD cbValue,
        BOOL fLogError = TRUE);
    void
    SetReaderProto(
        ActiveState *pActiveState,
        DWORD dwProto);
    void
    SetActive(
        IN BOOL fActive);
    void
    ReaderTransmit(
        ActiveState *pActiveState,
        LPCBYTE pbSend,
        DWORD cbSend,
        CBuffer &bfRecv);
    void
    ReaderSwallow(
        ActiveState *pActiveState);
    void
    ReaderColdReset(
        ActiveState *pActiveState,
        CBuffer &bfAtr);
    void
    ReaderWarmReset(
        ActiveState *pActiveState,
        CBuffer &bfAtr);
    void
    ReaderPowerDown(
        ActiveState *pActiveState);
    void
    ReaderEject(
        ActiveState *pActiveState);
#ifdef SCARD_CONFISCATE_CARD
    void
    ReaderConfiscate(
        ActiveState *pActiveState);
#endif
    DWORD
    GetReaderState(
        ActiveState *pActiveState);

    //  Operators

protected:

    //
    //  Properties
    //

    // Read-Only information.
    CBuffer m_bfReaderName;
    DWORD m_dwCapabilities;
    DWORD m_dwFlags;

    // Read/Write via Access Lock information.
    CAccessLock m_rwLock;
    CBuffer m_bfCurrentAtr;
    AvailableState m_dwAvailStatus;
    ActiveState m_ActiveState;
    DWORD m_dwOwnerThreadId;
    DWORD m_dwShareCount;
    DWORD m_dwCurrentProtocol;
    BOOL m_fDeviceActive;
    DWORD m_dwCurrentState;

    // Device I/O mutexes & events
    CMutex m_mtxGrab;
    CMutex m_mtxLatch;
    CMultiEvent m_ChangeEvent;
    CAccessLock m_rwActive;

    //  Methods
    void SetAvailabilityStatusLocked(AvailableState state)
    {
        CLockWrite rwLock(&m_rwLock);
        SetAvailabilityStatus(state);
    };

    void SetAvailabilityStatus(AvailableState state);
    void Dispose(DWORD dwDisposition);
    void PowerUp(void);
    void PowerDown(void);
    void Clean(void);
    void InvalidateGrabs(void);
    void TakeoverReader(void);

    // Friends
    friend class CReaderReference;
    friend class CTakeReader;
    friend void CalaisStop(void);
    friend DWORD WINAPI CalaisTerminateReader(LPVOID pvParam);
};


//
//==============================================================================
//
//  CLatchReader
//
//      An inline utility class to ensure that Latched readers get unlatched.
//      This also grabs the reader, just in case.
//

class CLatchReader
{
public:

    //  Constructors & Destructor

    CLatchReader(
        CReader *pRdr,
        const CReader::ActiveState *pActiveState = NULL)
    {
        m_pRdr = NULL;
        pRdr->GrabReader();
        try
        {
            pRdr->LatchReader(pActiveState);
            m_pRdr = pRdr;
        }
        catch (...)
        {
            pRdr->ShareReader();
            throw;
        }
    };

    ~CLatchReader()
    {
        if (NULL != m_pRdr)
        {
            if (m_pRdr->InitFailed())
                return;

            m_pRdr->Unlatch();
            m_pRdr->ShareReader();
        }
    };


    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CReader *m_pRdr;

    //  Methods
};


//
//==============================================================================
//
//  CTakeReader
//
//      An inline utility class to ensure that confiscated readers get
//      released.  This class is only for use by system threads.
//

class CTakeReader
{
public:

    //  Constructors & Destructor

    CTakeReader(
        CReader *pRdr)
    {
        m_pRdr = pRdr;
        m_pRdr->TakeoverReader();
    };

    ~CTakeReader()
    {
        m_pRdr->Unlatch();
        m_pRdr->ShareReader();
    };


    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CReader *m_pRdr;

    //  Methods
};


//
//==============================================================================
//
//  CReaderReference
//

class CReaderReference
{
public:
    //  Properties
    //  Methods
    CReader *Reader(void)
    { return m_pReader; };
    CReader::ActiveState *ActiveState(void)
    { return &m_actState; };
    DWORD Mode(void)
    { return m_dwMode; };
    void Mode(DWORD dwMode)
    { m_dwMode = dwMode; };

    //  Operators

protected:
    //  Constructors & Destructor
    CReaderReference(CReader *pRdr)
    {
        ZeroMemory(&m_actState, sizeof(CReader::ActiveState));
        m_dwMode = 0;
        m_pReader = pRdr;
        m_pLock = new CLockRead(&pRdr->m_rwActive);
    };
    ~CReaderReference()
    {
        if (NULL != m_pLock)
            delete m_pLock;
    };

    //  Properties
    CReader *m_pReader;
    CLockRead *m_pLock;
    CReader::ActiveState m_actState;
    DWORD m_dwMode;

    //  Methods

    //  Friends
    friend CReaderReference *CalaisLockReader(LPCTSTR szReader);
    friend void CalaisReleaseReader(CReaderReference **ppRdrRef);
};


//
//==============================================================================
//
//  CServiceThread
//

extern BOOL
DispatchInit(
    void);
extern void
DispatchTerm(
    void);
extern "C" DWORD WINAPI
DispatchMonitor(
    LPVOID pvParameter);
extern "C" DWORD WINAPI
ServiceMonitor(
    LPVOID pvParameter);

typedef struct _SERVICE_THREAD_SECURITY_INFO
{
    PSID pServiceSid;
    PSID pSystemSid;
} SERVICE_THREAD_SECURITY_INFO, *PSERVICE_THREAD_SECURITY_INFO;

PSERVICE_THREAD_SECURITY_INFO 
GetServiceThreadSecurityInfo(void);

class CServiceThread
{
public:

    //  Constructors & Destructor
    ~CServiceThread();

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Constructors & Destructor
    CServiceThread(DWORD dwServerIndex);

    //  Properties
    DWORD m_dwServerIndex;
    CComChannel *m_pcomChannel;
    CHandleObject m_hThread;
    DWORD m_dwThreadId;
    CHandleObject m_hCancelEvent;
    CHandleObject m_hExitEvent;
    CDynamicArray<CReaderReference> m_rgpReaders;

    //  Methods
    void Watch(CComChannel *pcomChannel);
    void DoEstablishContext(ComEstablishContext *pCom);
    void DoReleaseContext(ComReleaseContext *pCom);
    void DoIsValidContext(ComIsValidContext *pCom);
    void DoListReaders(ComListReaders *pCom);
    void DoLocateCards(ComLocateCards *pCom);
    void DoGetStatusChange(ComGetStatusChange *pCom);
    void DoConnect(ComConnect *pCom);
    void DoReconnect(ComReconnect *pCom);
    void DoDisconnect(ComDisconnect *pCom);
    void DoBeginTransaction(ComBeginTransaction *pCom);
    void DoEndTransaction(ComEndTransaction *pCom);
    void DoStatus(ComStatus *pCom);
    void DoTransmit(ComTransmit *pCom);
    void DoControl(ComControl *pCom);
    void DoGetAttrib(ComGetAttrib *pCom);
    void DoSetAttrib(ComSetAttrib *pCom);

    //  Friends
    friend DWORD WINAPI DispatchMonitor(LPVOID pvParameter);
    friend DWORD WINAPI ServiceMonitor(LPVOID pvParameter);
    friend void DispatchTerm(void);
};


//
//==============================================================================
//
//  CReaderDriver
//

extern DWORD
AddReaderDriver(
    IN LPCTSTR szDevice,
    IN DWORD dwFlags);

extern DWORD
AddAllWdmDrivers(
    void);

extern DWORD
AddAllPnPDrivers(
    void);

extern "C" DWORD WINAPI
MonitorReader(
    LPVOID pvParameter);

class CReaderDriver
:   public CReader
{
public:

    //  Constructors & Destructor
    CReaderDriver(
        IN HANDLE hReader,
        IN LPCTSTR szDevice,
        IN DWORD dwFlags);
    virtual ~CReaderDriver();

    //  Properties
    //  Methods
    virtual void Initialize(void);
    virtual void Close(void);
    virtual void Disable(void);
    virtual HANDLE ReaderHandle(void) const;
    virtual LPCTSTR DeviceName(void) const;
    virtual DWORD
    Control(
        DWORD dwCode,
        LPCBYTE pbSend = NULL,
        DWORD cbSend = 0,
        LPBYTE pbRecv = NULL,
        LPDWORD pcbRecv = NULL,
        BOOL fLogError = TRUE);

    //  Operators

protected:

    //
    //  Properties
    //

    // Read-Only information.
    CHandleObject m_hThread;
    DWORD m_dwThreadId;
    CBuffer m_bfDosDevice;
    CHandleObject m_hReader;
    LPVOID m_pvAppControl;

    // Read/Write via Access Lock information.
    OVERLAPPED m_ovrlp;
    CHandleObject m_hOvrWait;

    // Device I/O mutexes & events
    CHandleObject m_hRemoveEvent;

    //  Methods
    LPCTSTR DosDevice(void) const
    { return (LPCTSTR)m_bfDosDevice.Access(); };
    void Clean(void);
    DWORD SyncIoControl(
        DWORD dwIoControlCode,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesReturned,
        BOOL fLogError = TRUE);

    // Friends
    friend DWORD WINAPI MonitorReader(LPVOID pvParameter);
};

#endif // _CALSERVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\server\reader.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Reader

Abstract:

    This module provides the implementation of the Calais CReader class.

Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    The CReader object has several levels of locking.  It is critical that the
    locking be done in the correct order, to prevent deadlocks.  Here are the
    levels of locking, in the order they must be performed.  A level may be
    skipped, but once a given level is reached, you may not attempt to request
    a lock from a lower numbered level.

    1)  Grabbed - A reader object may be Grabbed.  This is the weakest lock,
        and is used to maintain Transactions requested from client
        applications.  Since clients may have errors, internal threads may
        override this lock if necessary.

    2)  Latched - A reader object may be Latched.  This is similar to a Grab,
        but is done by routines within the Resource Manager.  Latches may not
        be overridden by other threads.

    3)  Write Lock - A thread that needs write access to the CReader
        properties must establish a write lock on the CReader object.  This is
        an exclusive lock.  A thread with a Write Lock may also request Read
        Locks.

    4)  Read Lock - A thread that needs read access to the CReader properties
        must establish a read lock on the CReader Object.  There can be
        multiple simoultaneous readers.  If you have a read lock, it cannot be
        changed to a write lock!

    All locks are counted, so that obtaining one twice by the same thread is
    supported.

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <CalServe.h>

#define SCARD_IO_TIMEOUT 15000  // Maximum time to allow for an I/O operation
                                // before complaining.
#ifdef DBG
extern BOOL g_fGuiWarnings;
#endif


//
//==============================================================================
//
//  CReader
//

/*++

CReader:

    This is the constructor for a CReader class.  It just zeroes out the data
    structures in preparation for the Initialize call.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::CReader")

CReader::CReader(
    void)
:   m_rwLock(),
    m_bfReaderName(),
    m_bfCurrentAtr(36),
    m_ChangeEvent(),
    m_mtxGrab()
{
    Clean();
}


/*++

~CReader:

    This is the destructor for the reader class.  It just uses the Close service
    to shut down.  Note that it is *NOT* declared virtual, in order to improve
    performance.  Should it be desirable to subclass this class, this will have
    to change.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::~CReader")

CReader::~CReader()
{
    if (InitFailed())
        return;

    TakeoverReader();
    Close();
}


/*++

Clean:

    This routine is used to initialize all the property values.  It does *NOT*
    do any deallocation or locking!  Use Close() for that.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Clean")

void
CReader::Clean(
    void)
{
    m_bfReaderName.Reset();
    m_bfCurrentAtr.Reset();
    m_dwFlags = 0;
    m_dwCapabilities = 0;
    m_dwAvailStatus = Inactive;
    m_ActiveState.dwInsertCount = 0;
    m_ActiveState.dwRemoveCount = 0;
    m_ActiveState.dwResetCount = 0;
    m_dwOwnerThreadId = 0;
    m_dwShareCount = 0;
    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
    m_fDeviceActive = TRUE;
    m_dwCurrentState = SCARD_UNKNOWN;
}


/*++

Initialize:

    This method initializes a clean CReader object to a running state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Initialize")

void
CReader::Initialize(
    void)
{
    CLatchReader latch(this);
    try
    {

        //
        // Get it's Device Name.  Note device names always come in from the
        // driver in ASCII characters.
        //

        TCHAR szUnit[32];
        CTextString szVendor, szDevice, szName;
        CBuffer bfAttr(MAXIMUM_ATTR_STRING_LENGTH + 2 * sizeof(WCHAR));
        DWORD dwUnit, cchUnit;
        CLockWrite rwLock(&m_rwLock);

        try
        {
            GetReaderAttr(
                SCARD_ATTR_VENDOR_NAME,
                bfAttr);
            if (0 == bfAttr.Length())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader driver reports NULL Vendor"));
            }
            else
            {
                bfAttr.Append((LPBYTE)"\000", sizeof(CHAR));
                szVendor = (LPCSTR)bfAttr.Access();
            }
        }
        catch (DWORD dwError)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object failed to obtain reader vendor name:  %1"),
                dwError);
            szVendor.Reset();
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object received exception while trying to obtain reader vendor name"));
            szVendor.Reset();
        }

        try
        {
            GetReaderAttr(
                SCARD_ATTR_VENDOR_IFD_TYPE,
                bfAttr);
            if (0 == bfAttr.Length())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader driver reports NULL device type"));
            }
            else
            {
                bfAttr.Append((LPBYTE)"\000", sizeof(CHAR));
                szDevice = (LPCSTR)bfAttr.Access();
            }
        }
        catch (DWORD dwError)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object failed to obtain reader device type:  %1"),
                dwError);
            szDevice.Reset();
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object received exception while trying to obtain reader device type"));
            szDevice.Reset();
        }

        if ((0 == szVendor.Length()) && (0 == szDevice.Length()))
        {
            CalaisError(__SUBROUTINE__, 406);
            throw (DWORD)SCARD_E_READER_UNSUPPORTED;
        }

        try
        {
            dwUnit = GetReaderAttr(SCARD_ATTR_DEVICE_UNIT);
            cchUnit = wsprintf(szUnit, TEXT("%lu"), dwUnit);
            if (0 >= cchUnit)
                throw GetLastError();
        }
        catch (DWORD dwError)
        {
            *szUnit = 0;
            cchUnit = 0;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader '%2' failed to obtain reader device type:  %1"),
                dwError,
                ReaderName());
        }
        catch (...)
        {
            *szUnit = 0;
            cchUnit = 0;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader '%1' received exception while trying to obtain reader device type"),
                ReaderName());
        }


        //
        // Put all the pieces together.
        //

        szName.Reset();
        if (0 < szVendor.Length())
            szName += szVendor;
        if (0 < szDevice.Length())
        {
            if (0 < szName.Length())
                szName += TEXT(" ");
            szName += szDevice;
        }
        if (0 < cchUnit)
        {
            if (0 < szName.Length())
                szName += TEXT(" ");
            szName += szUnit;
        }
        ASSERT(0 < szName.Length());
        m_bfReaderName.Set(
            (LPCBYTE)((LPCTSTR)szName),
            (szName.Length() + 1) * sizeof(TCHAR));
    }

    catch (...)
    {
        Close();
        throw;
    }
}


/*++

Close:

    This routine does the work of closing down a CReader class, and returning it
    to it's default state.  It does not assume any particular state, other than
    that the class has been Clean()ed once (at construction).

Arguments:

    None

Return Value:

    None

Throws:

    None

Notes:

    You must not have a read lock when calling this routine.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Close")

void
CReader::Close(
    void)
{
    ASSERT(IsLatchedByMe());
    CLockWrite rwLock(&m_rwActive);
    if (Inactive != m_dwAvailStatus)
    {
        try
        {
            SetAvailabilityStatusLocked(Closing);
            Dispose(SCARD_EJECT_CARD);
        }
        catch (DWORD dwErr)
        {
            if (SCARD_E_NO_SMARTCARD != dwErr)
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader '%2' shutdown cannot eject card:  %1"),
                    dwErr,
                    ReaderName());
        }
        catch (...)
        {
            CalaisError(__SUBROUTINE__, 401);
        }

        while (Unlatch())
            ;   // Empty Loop Body
        while (m_mtxGrab.Share())
            ;   // Empty Loop Body
        Clean();
    }
}


/*++

Disable:

    This method releases any physical resources associated with the reader
    object, and marks the object offline.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORDs

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Disable")

void
CReader::Disable(
    void)
{
    try
    {
        CTakeReader take(this);
        Dispose(SCARD_EJECT_CARD);
    }
    catch (...) {}
    SetAvailabilityStatusLocked(Closing);
}


/*++

GetReaderState:

    This routine is the default implementation of the base method.  It
    just passes the same operation on to the control method.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    A DWORD representing the reader state.  This must be one of the following
    values:

        SCARD_UNKNOWN     This value implies the driver is unaware
                          of the current state of the reader.
        SCARD_ABSENT      This value implies there is no card in
                          the reader.
        SCARD_PRESENT     This value implies there is a card is
                          present in the reader, but that it has
                          not been moved into position for use.
        SCARD_SWALLOWED   This value implies there is a card in the
                          reader in position for use.  The card is
                          not powered.
        SCARD_POWERED     This value implies there is power is
                          being provided to the card, but the
                          Reader Driver is unaware of the mode of
                          the card.
        SCARD_NEGOTIABLE  This value implies the card has been
                          reset and is awaiting PTS negotiation.
        SCARD_SPECIFIC    This value implies the card has been
                          reset and specific communication
                          protocols have been established.

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::GetReaderState")

DWORD
CReader::GetReaderState(
    void)
{
    DWORD dwReaderSts = 0;
    DWORD dwLength = sizeof(DWORD);
    DWORD dwSts;

    ASSERT(IsGrabbedByMe());
    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_GET_STATE,
                NULL, 0,
                (LPBYTE)&dwReaderSts,
                &dwLength);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    if (SCARD_UNKNOWN == dwReaderSts)
    {
        {
            CLockWrite rwLock(&m_rwLock);
            SetAvailabilityStatus(Broken);
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
        }
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("GetReaderState received unknown device state"));
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
    m_dwCurrentState = dwReaderSts;
    return dwReaderSts;
}

DWORD
CReader::GetReaderState(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    return GetReaderState();
}


/*++

GrabReader:

    This routine obtains the reader for this thread, ensuring that the reader is
    in a useable state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 4/21/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::GrabReader")

void
CReader::GrabReader(
    void)
{
    ASSERT(m_rwLock.NotReadLocked());
    ASSERT(m_rwLock.NotWriteLocked());
    ASSERT(!IsLatchedByMe());
    m_mtxGrab.Grab();
}


/*++

InvalidateGrabs:

    This method is for use by internal system threads.  It politlely invalidates
    any existing grabs that might be outstanding by clients.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    This routine intentionally cheats on the locking order.  It first latches a
    reader to be sure that no active threads are currently using it.  It then
    modifies the Grab mutex to appear that no one had a grab lock.

    This results in the appearance that the locking order had been followed.

Author:

    Doug Barlow (dbarlow) 6/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::InvalidateGrabs")

void
CReader::InvalidateGrabs(
    void)
{
    ASSERT(!IsLatchedByMe());
    m_mtxLatch.Grab();
    m_mtxGrab.Invalidate();
    m_mtxLatch.Share();
}


/*++

TakeoverReader:

    This method is for use by internal system threads.  It politlely invalidates
    any existing grabs that might be outstanding by clients, and reassigns the
    grab lock to this thread.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    This routine intentionally cheats on the locking order.  It first latches a
    reader to be sure that no active threads are currently using it.  It then
    modifies the Grab mutex to appear that we had previously grabbed the reader.

    This results in the appearance that the locking order had been followed.

Author:

    Doug Barlow (dbarlow) 6/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::TakeoverReader")

void
CReader::TakeoverReader(
    void)
{
    if (!IsLatchedByMe())
    {
        m_mtxLatch.Grab();
        m_mtxGrab.Take();
    }
    ASSERT(IsLatchedByMe());
    ASSERT(IsGrabbedByMe());
}


/*++

LatchReader:

    This routine obtains the reader for this thread, ensuring that the reader is
    in a useable state.

Arguments:

    pActState receives the snapshot of the active state to use in future access
        requests.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 4/21/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::LatchReader")

void
CReader::LatchReader(
    const ActiveState *pActiveState)
{
    VerifyActive(pActiveState);
    ASSERT(m_rwLock.NotReadLocked());
    ASSERT(m_rwLock.NotWriteLocked());
    m_mtxLatch.Grab();
    if (NULL != pActiveState)
    {
        try
        {
            VerifyState();
            VerifyActive(pActiveState);
        }
        catch (...)
        {
            m_mtxLatch.Share();
            throw;
        }
    }
}


/*++

VerifyState:

    This method ensures the reader and card are usable in the current context.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 5/30/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::VerifyState")

void
CReader::VerifyState(
    void)
{
    DWORD dwNewState, dwOldState;

    ASSERT(IsGrabbedByMe());


    //
    // As long as the current state isn't what we thought it was,
    // bring this reader up to date.
    //

    if (Direct != AvailabilityStatus())
    {
        CLockWrite rwLock(&m_rwLock);
        for (;;)
        {

            //
            // Compare where we think the device is to where the device
            // controller thinks the device is.  If they're the same, we're
            // done.
            //

            dwOldState = GetCurrentState();
            dwNewState = GetReaderState();
            if (dwOldState == dwNewState)
                break;


            //
            // Our opinions differ on where the reader is.  Bring us into sync.
            //

            switch (dwOldState)
            {

            //
            // If we're here, then we're booting up the reader.
            //

            case SCARD_UNKNOWN:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    if (Direct > m_dwAvailStatus)
                        SetAvailabilityStatus(Idle);
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                case SCARD_SPECIFIC:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwInsertCount += 1;
                    if (Direct > m_dwAvailStatus)
                        PowerUp();
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We don't think there's a card in the reader.  If we're wrong,
            // power it up.
            //

            case SCARD_ABSENT:
                switch (dwNewState)
                {
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    m_ActiveState.dwInsertCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            //  We think there's a card there that needs to be powered up.
            //

            case SCARD_PRESENT:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    break;
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think that a card was in place for use, but hasn't been
            // powered.
            //

            case SCARD_SWALLOWED:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    break;
                case SCARD_PRESENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_ActiveState.dwResetCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think the card is just waiting to be reset.
            //

            case SCARD_POWERED:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_ActiveState.dwResetCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think the card is ready to go, but needs a decision on which
            // protocol to use.
            //

            case SCARD_NEGOTIABLE:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_ActiveState.dwRemoveCount += 1;
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_ActiveState.dwResetCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                case SCARD_SPECIFIC:
                        if (Direct > m_dwAvailStatus)
                        {
                            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                            m_bfCurrentAtr.Reset();
                            PowerUp();
                        }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think the card has a protocol established.
            //

            case SCARD_SPECIFIC:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_ActiveState.dwRemoveCount += 1;
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_ActiveState.dwResetCount += 1;
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // Oops.  We don't know diddly about what's going on.
            //

            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("VerifyState of '%1' thinks it is in an unrecognized state"),
                    ReaderName());
            }
        }
    }
}


/*++

PowerUp:

    This routine brings a reader up to a ready state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors that might occur.

Author:

    Doug Barlow (dbarlow) 1/7/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::PowerUp")

void
CReader::PowerUp(
    void)
{
    BOOL fDone = FALSE;
    DWORD dwSts, dwRetry;
    DWORD dwReaderSts;
    DWORD dwLastSts = SCARD_UNKNOWN;
    DWORD dwAtrLen;
    BOOL fSts;
    DWORD dwErrorCount = 3;

    ASSERT(IsGrabbedByMe());
    ASSERT(IsLatchedByMe());

    CLockWrite rwLock(&m_rwLock);
    while (!fDone)
    {

        //
        // Get the current reader status, and make sure it's changing.
        //

        dwReaderSts = GetReaderState();
        if (dwReaderSts != dwLastSts)
        {
            dwLastSts = dwReaderSts;
            dwErrorCount = 3;
        }
        else
        {
            ASSERT(0 < dwErrorCount);
            dwErrorCount -= 1;
            if (0 == dwErrorCount)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader '%1' won't change state!"),
                    ReaderName());
                m_bfCurrentAtr.Reset();
                m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                SetAvailabilityStatus(Unsupported);
                throw (DWORD)SCARD_E_CARD_UNSUPPORTED;
            }
        }

        switch (dwReaderSts)
        {
        case SCARD_ABSENT:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwRemoveCount += 1;
            if (Direct > m_dwAvailStatus)
                SetAvailabilityStatus(Idle);
            throw (DWORD)SCARD_E_NO_SMARTCARD;
            break;
        case SCARD_PRESENT:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            if (0 != (SCARD_READER_SWALLOWS & m_dwCapabilities))
            {
                try
                {
                    ReaderSwallow();
                    continue;   // Continue the loop.
                }
                catch (DWORD dwError)
                {
                    switch (dwError)
                    {
                    case ERROR_NOT_SUPPORTED:
                        m_dwCapabilities &= ~SCARD_READER_SWALLOWS;
                        break;      // Fall through to SWALLOWED.
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%2' failed to swallow card:  %1"),
                            dwError,
                            ReaderName());
                    }
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%1' got exception trying to swallow card"),
                        ReaderName());
                }
            }
            // Fall through on purpose.
        case SCARD_SWALLOWED:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            dwRetry = 3;
            dwSts = ERROR_SUCCESS;
            do
            {
                try
                {
                    ReaderColdReset(m_bfCurrentAtr);
                    dwSts = ERROR_SUCCESS;
                }
                catch (DWORD dwError)
                {
                    dwSts = dwError;
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%2' failed to power card:  %1"),
                        dwError,
                        ReaderName());
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%1' got exception trying to power card"),
                        ReaderName());
                    dwSts = SCARD_F_INTERNAL_ERROR;
                }

                switch (dwSts)
                {
                case ERROR_BAD_COMMAND:
                case ERROR_MEDIA_CHANGED:
                case ERROR_NO_MEDIA_IN_DRIVE:
                case ERROR_UNRECOGNIZED_MEDIA:
                    continue;
                    break;
                // default:
                //      no action
                }
            } while ((0 < --dwRetry) && (ERROR_SUCCESS != dwSts));
            if (ERROR_SUCCESS != dwSts)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerUp on '%1' abandoning attempt to power card"),
                    ReaderName());
                m_bfCurrentAtr.Reset();
                if (Direct > m_dwAvailStatus)
                    SetAvailabilityStatus(Unresponsive);
                fDone = TRUE;
            }
            else
            {
                if (Ready > m_dwAvailStatus)
                {
                    SetAvailabilityStatus(Ready);
                    SetActive(FALSE);
                }
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwResetCount += 1;
            break;

        case SCARD_POWERED:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            try
            {
               ReaderWarmReset(m_bfCurrentAtr);
                if (Ready > m_dwAvailStatus)
                {
                    SetAvailabilityStatus(Ready);
                    SetActive(FALSE);
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerUp on '%2' failed to reset card:  %1"),
                    dwError,
                    ReaderName());
                if (Direct > m_dwAvailStatus)
                    SetAvailabilityStatus(Unresponsive);
                m_bfCurrentAtr.Reset();
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerUp on '%1' received exception attempting to warm reset card"),
                    ReaderName());
                if (Direct > m_dwAvailStatus)
                    SetAvailabilityStatus(Unresponsive);
                m_bfCurrentAtr.Reset();
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwResetCount += 1;
            break;

        case SCARD_NEGOTIABLE:
            ASSERT(SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol);
            if ((Direct > m_dwAvailStatus) && (2 > m_bfCurrentAtr.Length()))
            {
                try
                {
                    GetReaderAttr(
                        SCARD_ATTR_ATR_STRING,
                        m_bfCurrentAtr);
                    if (Ready > m_dwAvailStatus)
                    {
                        SetAvailabilityStatus(Ready);
                        SetActive(FALSE);
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%2' cannot get Current ATR:  %1"),
                        dwError,
                        ReaderName());
                    SetAvailabilityStatus(Unresponsive);
                    m_bfCurrentAtr.Reset();
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%1' received exception trying to get Current ATR"),
                        ReaderName());
                    SetAvailabilityStatus(Unresponsive);
                    m_bfCurrentAtr.Reset();
                }
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            fDone = TRUE;
            break;

        case SCARD_SPECIFIC:
            if (Direct > m_dwAvailStatus)
            {
                if (2 > m_bfCurrentAtr.Length())
                {
                    try
                    {
                        GetReaderAttr(SCARD_ATTR_ATR_STRING, m_bfCurrentAtr);
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%2' cannot get Current ATR:  %1"),
                            dwError,
                            ReaderName());
                        SetAvailabilityStatus(Unresponsive);
                        m_bfCurrentAtr.Reset();
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        fDone = TRUE;
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%1' received exception trying to get Current ATR"),
                            ReaderName());
                        SetAvailabilityStatus(Unresponsive);
                        m_bfCurrentAtr.Reset();
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        fDone = TRUE;
                    }
                }
                if (SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol)
                {
                    try
                    {
                        m_dwCurrentProtocol = GetReaderAttr(
                                    SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%2' cannot get Current Protocol:  %1"),
                            dwError,
                            ReaderName());
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%1' received exception trying to get Current Protocol"),
                            ReaderName());
                    }
                }
            }
            if (Ready > m_dwAvailStatus)
            {
                SetAvailabilityStatus(Ready);
                SetActive(FALSE);
            }
            fDone = TRUE;
            break;

        case SCARD_UNKNOWN:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerUp on '%1' received unknown device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
            break;

        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerUp on '%1' received invalid current device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
            break;
        }
    }
    if ((Direct > m_dwAvailStatus) && (0 != m_bfCurrentAtr.Length()))
    {
        fSts = ParseAtr(
            m_bfCurrentAtr,
            &dwAtrLen,
            NULL,
            NULL,
            m_bfCurrentAtr.Length());
        if (!fSts || (m_bfCurrentAtr.Length() != dwAtrLen))
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reported ATR from '%1' is invalid."),
                ReaderName());
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            SetAvailabilityStatus(Unsupported);
            throw (DWORD)SCARD_E_CARD_UNSUPPORTED;
        }
    }
}


/*++

PowerDown:

    This method brings the smartcard down.

Arguments:

    None

Return Value:

    None

Throws:

    Errors encountered, as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/7/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::PowerDown")

void
CReader::PowerDown(
    void)
{
    BOOL fDone = FALSE;
    DWORD dwReaderSts;
    DWORD dwLastSts = SCARD_UNKNOWN;
    DWORD dwErrorCount = 3;


    //
    // Bring down the card.
    //

    ASSERT(IsGrabbedByMe());
    ASSERT(IsLatchedByMe());
    CLockWrite rwLock(&m_rwLock);
    while (!fDone)
    {

        //
        // Get the current reader status.
        //

        try
        {
            dwReaderSts = GetReaderState();
        }
        catch (DWORD dwError)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%2' failed to obtain reader status:  %1"),
                dwError,
                ReaderName());
            throw;
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%1' received exception trying to obtain reader status"),
                ReaderName());
            throw;
        }


        //
        // Make sure it's changing.
        //

        if (dwReaderSts != dwLastSts)
        {
            dwLastSts = dwReaderSts;
            dwErrorCount = 3;
        }
        else
        {
            ASSERT(0 < dwErrorCount);
            dwErrorCount -= 1;
            if (0 == dwErrorCount)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader '%1' won't change state!"),
                    ReaderName());
                m_bfCurrentAtr.Reset();
                m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                SetAvailabilityStatus(Unsupported);
                throw (DWORD)SCARD_E_CARD_UNSUPPORTED;
            }
        }

        switch (dwReaderSts)
        {
        case SCARD_SPECIFIC:
            ASSERT(SCARD_PROTOCOL_UNDEFINED != m_dwCurrentProtocol);
            // Fall through intentionally.

        case SCARD_NEGOTIABLE:
            ASSERT(Unresponsive != m_dwAvailStatus
                   ? 2 <= m_bfCurrentAtr.Length()
                   : TRUE);
            // Fall through intentionally.

        case SCARD_POWERED:
            ASSERT((SCARD_POWERED != dwReaderSts)
                    || (SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol));
            try
            {
                ReaderPowerDown();
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerDown on '%2' failed to unpower card:  %1"),
                    dwError,
                    ReaderName());
                throw;
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerDown on '%1' received exception attempting to unpower card"),
                    ReaderName());
                throw;
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwResetCount += 1;
            break;

        case SCARD_SWALLOWED:
        case SCARD_PRESENT:
            fDone = TRUE;
            if (Direct > m_dwAvailStatus)
                SetAvailabilityStatus(Present);
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            break;

        case SCARD_ABSENT:
            ASSERT(0 == m_bfCurrentAtr.Length());
            ASSERT(SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol);
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            throw (DWORD)SCARD_E_NO_SMARTCARD;
            break;

        case SCARD_UNKNOWN:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%1' received unknown device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
            break;

        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%1' received invalid current device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }
    }
}


/*++

SetAvailabilityStatus:

    This method controls the availability status indicator, maintains the last
    state, and manages the change event flag.

Arguments:

    state supplies the new state to take effect.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/15/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetAvailabilityStatus")

void
CReader::SetAvailabilityStatus(
    CReader::AvailableState state)
{
    ASSERT(m_rwLock.IsWriteLocked());
    if (m_dwAvailStatus != state)
    {
        m_dwAvailStatus = state;
        if (Ready >= m_dwAvailStatus)
        {
            m_dwOwnerThreadId = 0;
            m_dwShareCount = 0;
        }
        m_ChangeEvent.Signal();
    }
}


/*++

VerifyActive:

    This method verifies that the card hasn't been removed or reset since the
    last operation.

Arguments:

    pActiveState supplies a pointer to a structure containing the state the
        caller believes we're in.

Return Value:

    None

Throws:

    If a discrepancy is detected, we throw the error code indicating the
    discrepancy.

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::VerifyActive")

void
CReader::VerifyActive(
    const CReader::ActiveState *pActiveState)
{
    if (NULL != pActiveState)
    {
        CLockRead rwLock(&m_rwLock);
        switch (m_dwAvailStatus)
        {
        case Idle:
        case Present:
        case Unresponsive:
        case Unsupported:
        case Ready:
        case Shared:
        case Exclusive:
        {
            if (pActiveState->dwInsertCount != m_ActiveState.dwInsertCount)
                throw (DWORD)SCARD_W_REMOVED_CARD;
            if (pActiveState->dwRemoveCount != m_ActiveState.dwRemoveCount)
                throw (DWORD)SCARD_W_REMOVED_CARD;
            if (pActiveState->dwResetCount != m_ActiveState.dwResetCount)
                throw (DWORD)SCARD_W_RESET_CARD;
             break;
       }
        case Direct:
            break;
        case Closing:
        case Broken:
        case Inactive:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Verification failed on disabled reader '%1'"),
                ReaderName());
            throw (DWORD)SCARD_E_READER_UNAVAILABLE;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Invalid reader active state from '%1' to Verify Active"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }
    }
}


/*++

Dispose:

    This method performs a card disposition command.

Arguments:

    dwDisposition supplies the type of disposition to perform.

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.  This structure is updated following card
        disposition, so that it remains valid.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/26/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Dispose")

void
CReader::Dispose(
    DWORD dwDisposition,
    CReader::ActiveState *pActiveState)
{
    VerifyActive(pActiveState);
    if (SCARD_LEAVE_CARD != dwDisposition)
    {
        ASSERT(!IsLatchedByMe());
        CLatchReader latch(this, pActiveState);
        Dispose(dwDisposition);
        if (NULL != pActiveState)
            pActiveState->dwResetCount = m_ActiveState.dwResetCount;
    }
}

void
CReader::Dispose(
    DWORD dwDisposition)
{
    switch (dwDisposition)
    {
    case SCARD_LEAVE_CARD:      // Don't do anything special.
        break;
    case SCARD_RESET_CARD:      // Warm Reset the card.
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        CLockWrite rwLock(&m_rwLock);
        m_bfCurrentAtr.Reset();
        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
        m_ActiveState.dwResetCount += 1;
        ReaderWarmReset(m_bfCurrentAtr);
        break;
    }
    case SCARD_UNPOWER_CARD:    // Power down the card
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        PowerDown();
        break;
    }
#ifdef SCARD_CONFISCATE_CARD
    case SCARD_CONFISCATE_CARD: // Confiscate the card
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        PowerDown();
        ReaderConfiscate();
        break;
    }
#endif
    case SCARD_EJECT_CARD:      // Eject the card on close
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        PowerDown();
        ReaderEject();
        break;
    }
    default:
        throw (DWORD)SCARD_E_INVALID_VALUE;
    }
}



/*++

Connect:

    This method allows a service thread to connect to this reader.

Arguments:

    dwShareMode supplies the share mode indicator.

    dwPreferredProtocols supplies a bitmask of acceptable protocols to
        negotiate.

    pActState receives the snapshot of the active state to use in future access
        requests.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Connect")

void
CReader::Connect(
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT ActiveState *pActState)
{
    AvailableState avlState;
    DWORD dwOwnerThreadId;
    DWORD dwShareCount;

    if ((SCARD_SHARE_DIRECT != dwShareMode) && (0 == dwPreferredProtocols))
        throw (DWORD)SCARD_E_INVALID_VALUE;

    {
        CLockWrite rwLock(&m_rwLock);
        avlState = m_dwAvailStatus;
        dwOwnerThreadId = m_dwOwnerThreadId;
        dwShareCount = m_dwShareCount;

        switch (avlState)
        {
        case Idle:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Unresponsive:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            default:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
            }
            break;

        case Unsupported:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Present:
            if ((SCARD_SHARE_DIRECT == dwShareMode) && (0 != dwPreferredProtocols))
                throw (DWORD)SCARD_E_NOT_READY;
            // Fall through intentionally

        case Ready:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                dwShareCount += 1;
                avlState = Shared;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Shared:
            ASSERT(0 != m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_DIRECT:
            case SCARD_SHARE_EXCLUSIVE:
                throw (DWORD)SCARD_E_SHARING_VIOLATION;
                break;
            case SCARD_SHARE_SHARED:
                avlState = Shared;
                dwShareCount += 1;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Exclusive:
        case Direct:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 != m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
            case SCARD_SHARE_DIRECT:
                throw (DWORD)SCARD_E_SHARING_VIOLATION;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Closing:
        case Broken:
        case Inactive:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Connecting to disabled reader '%1'"),
                ReaderName());
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
            case SCARD_SHARE_DIRECT:
                throw (DWORD)SCARD_E_READER_UNAVAILABLE;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        default:
            CalaisError(__SUBROUTINE__, 410);
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }


        //
        // It's official!  Write the changes back to the structure.
        //

        CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        m_dwOwnerThreadId = dwOwnerThreadId;
        m_dwShareCount = dwShareCount;
        SetAvailabilityStatus(avlState);
    }


    //
    // Adjust the protocol settings and confirm the request.
    //
    // Since we can't get a latch while a write lock is in effect, we consider
    // the caller officially connected at this point.  Now we try and set the
    // protocol request, and if we fail, we disconnect again.
    //

    if (0 != dwPreferredProtocols)
    {
        try
        {
            DWORD dwCurrentProtocol;

            CLatchReader latch(this, &m_ActiveState);
            PowerUp();
            SetActive(TRUE);
            dwCurrentProtocol = GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
            if (SCARD_PROTOCOL_UNDEFINED == dwCurrentProtocol)
            {
                SetReaderProto(dwPreferredProtocols);
                dwCurrentProtocol =
                    GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                ASSERT(0 != dwCurrentProtocol);
            }
            else
            {
                if (0 == (dwPreferredProtocols & dwCurrentProtocol))
                {
                    switch (dwPreferredProtocols)
                    {
                    case SCARD_PROTOCOL_RAW:
                        {
                            if (Exclusive > avlState)
                                throw (DWORD)SCARD_E_SHARING_VIOLATION;
                            SetReaderProto(dwPreferredProtocols);
                            dwCurrentProtocol = GetReaderAttr(
                                SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                            ASSERT(0 != dwCurrentProtocol);
                            break;
                        }
                    case SCARD_PROTOCOL_DEFAULT:
                        ASSERT(SCARD_PROTOCOL_UNDEFINED != dwCurrentProtocol);
                        break;
                    default:
                        throw (DWORD)SCARD_E_PROTO_MISMATCH;
                    }
                }
            }
            CLockWrite rwLock(&m_rwLock);
            m_dwCurrentProtocol = dwCurrentProtocol;
            CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        }
        catch (...)
        {
            try
            {
                DWORD dwDispStatus;

                Disconnect(
                    pActState,
                    SCARD_LEAVE_CARD,
                    &dwDispStatus);
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to autodisconnect during connect error recovery: %1"),
                    dwError);
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Exception on disconnect during connect error recovery"));
            }
            throw;
        }
    }
}


/*++

Disconnect:

    This method relases a previously established connection between a service
    thread and this reader object.

Arguments:

    pActiveState = This supplies the active state structure, to make sure that
        this is the same card as expected.  This structure is updated following
        card disposition, so that it remains valid.

    hShutdown - This supplies the active handle of the calling dispatch thread.

    dwDisposition supplies an indication as to what to do to the card upon
        completion.

    pdwDispSts receives a disposition status code, indicating whether or not
        the requested disposition was carried out successfully.

Return Value:

    None

Throws:

    This method may throw exceptions if internal invalid states are detected.

Author:

    Doug Barlow (dbarlow) 12/26/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Disconnect")

void
CReader::Disconnect(
    ActiveState *pActState,
    DWORD dwDisposition,
    LPDWORD pdwDispSts)
{
    enum { Unverified, Verified, Reset, Invalid } nValid = Unverified;


    //
    // Attempt to dispose of the card as requested.  It's possible that we
    // aren't still active, so this might fail.
    //

    try
    {
        VerifyActive(pActState);
        nValid = Verified;
    }
    catch (DWORD dwError)
    {
        *pdwDispSts = dwError;
        dwDisposition = SCARD_LEAVE_CARD;
        switch (dwError)
        {
        case SCARD_W_RESET_CARD:
            nValid = Reset;
            break;
        case SCARD_W_REMOVED_CARD:
        case SCARD_E_READER_UNAVAILABLE:
            nValid = Invalid;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unrecognized validation error code '%1'.  Assuming Invalid."),
                dwError);
            nValid = Invalid;
        }
    }
    ASSERT(Unverified != nValid);


    //
    // Change the card's internal state.
    //

    try {
        CLockWrite rwLock(&m_rwLock);
        switch (m_dwAvailStatus)
        {
        case Idle:
        case Unresponsive:
        case Unsupported:
        case Present:
        case Ready:
            ASSERT(Invalid == nValid);
            throw (DWORD)SCARD_W_REMOVED_CARD;
            break;

        case Shared:
            ASSERT(0 < m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                m_dwShareCount -= 1;
                if (0 == m_dwShareCount)
                    SetAvailabilityStatus(Ready);
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }
            break;

        case Exclusive:
            ASSERT(0 == m_dwShareCount);
            ASSERT(m_dwOwnerThreadId == GetCurrentThreadId());
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                m_dwOwnerThreadId = 0;
                SetAvailabilityStatus(Ready);
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }
            break;

        case Direct:
            ASSERT(0 == m_dwShareCount);
            ASSERT(m_dwOwnerThreadId == GetCurrentThreadId());
            m_dwOwnerThreadId = 0;
            m_dwCurrentState = SCARD_UNKNOWN;
            m_dwAvailStatus = Undefined;
            break;

        case Closing:
        case Broken:
        case Inactive:
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                if (0 != m_dwOwnerThreadId)
                {
                    ASSERT(m_dwOwnerThreadId == GetCurrentThreadId());
                    m_dwOwnerThreadId = 0;
                }
                else
                {
                    ASSERT(0 < m_dwShareCount);
                    m_dwShareCount -= 1;
                }
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Disconnecting from disabled reader '%1'"),
                ReaderName());
            break;

        default:
            CalaisError(__SUBROUTINE__, 403);
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }
    }

    // Catch expected errors, so that Disconnect doesn't bail.  Very often, this is the default
    //  route to clean up after some sort of error, so it should be as failure-proof as possible
    catch (DWORD dwErr)
    {
#ifdef DBG
        // In debug versions, document unexpected conditions
        if (dwErr == SCARD_W_REMOVED_CARD)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Disconnecting from reader in nonconnected state '%1'"),
                ReaderName());
        }
        else
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unexpected availability status value on '%1'"),
                ReaderName());
        }
#endif
        ;
    }

    //
    // Verify our state is consistent, and dispose of the card as requested.
    //

    try
    {
        CLatchReader latch(this);
        VerifyState();
        VerifyActive(pActState);
        Dispose(dwDisposition);
        *pdwDispSts = SCARD_S_SUCCESS;
    }
    catch (DWORD dwErr)
    {
        *pdwDispSts = dwErr;
    }


    //
    // Release any mutex held by this thread.
    //

    while (m_mtxGrab.Share())
        ;   // empty loop body


    //
    // Check to see if the reader can be powered down.  We peek to see if
    // we should bother, and if so, go through the trouble of acquiring the
    // locks.  Then we check again to make sure it's still appropriate to
    // power it down.
    //

    if (Ready == AvailabilityStatus())
    {
        CLatchReader latch(this);
        CLockWrite rwLock(&m_rwLock);
        if (Ready == m_dwAvailStatus)
        {
            SetActive(FALSE);
            ReaderPowerDown();
            SetAvailabilityStatus(Present);
        }
    }
}


/*++

Reconnect:

    This method allows a service thread to adjust it's connection to this
    reader.

Arguments:

    dwShareMode supplies the share mode indicator.

    dwPreferredProtocols supplies a bitmask of acceptable protocols to
        negotiate.

    dwDisposition supplies an indication as to what to do to the card upon
        completion.

    pActiveState = This supplies the active state structure, to make sure that
        this is the same card as expected, and receives the snapshot of the
        active state to use in future access requests.

    pdwDispSts receives a disposition status code, indicating whether or not
        the requested disposition was carried out successfully.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/28/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Reconnect")

void
CReader::Reconnect(
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    IN DWORD dwDisposition,
    IN OUT ActiveState *pActState,
    OUT LPDWORD pdwDispSts)
{
    enum { Unverified, Verified, Reset, Invalid } nValid = Unverified;
    AvailableState avlState;
    DWORD dwOwnerThreadId;
    DWORD dwShareCount;
    AvailableState avlState_bkup;
    DWORD dwOwnerThreadId_bkup;
    DWORD dwShareCount_bkup;
    ActiveState actState_bkup;
    DWORD dwRealReaderState;


    //
    // Reconnect to the card.
    //

    if ((SCARD_SHARE_DIRECT != dwShareMode) && (0 == dwPreferredProtocols))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Validate any existing connection.
    //

    try
    {
        VerifyActive(pActState);
        nValid = Verified;
    }
    catch (DWORD dwError)
    {
        switch (dwError)
        {
        case SCARD_W_RESET_CARD:
            nValid = Reset;
            break;
        case SCARD_W_REMOVED_CARD:
            nValid = Invalid;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unrecognized validation error code '%1'.  Assuming Invalid."),
                dwError);
            nValid = Invalid;
        }
    }
    ASSERT(Unverified != nValid);

    *pdwDispSts = SCARD_E_CANT_DISPOSE;
    if (Verified == nValid)
    {

        //
        // Attempt to dispose of the card as requested.
        //

        try
        {
            while (m_mtxGrab.Share())
                ;   // Empty loop body
            CLatchReader latch(this, NULL);
            Dispose(dwDisposition);
            dwRealReaderState = GetReaderState();
            *pdwDispSts = SCARD_S_SUCCESS;
        }
        catch (DWORD dwError)
        {
            *pdwDispSts = dwError;
        }
        catch (...)
        {
            *pdwDispSts = SCARD_E_CANT_DISPOSE;
        }
    }
    else
        dwRealReaderState = GetReaderState(NULL);


    //
    // Change the card's internal state.
    //

    {
        CLockWrite rwLock(&m_rwLock);
        avlState_bkup = avlState = m_dwAvailStatus;
        dwOwnerThreadId_bkup = dwOwnerThreadId = m_dwOwnerThreadId;
        dwShareCount_bkup = dwShareCount = m_dwShareCount;
        CopyMemory(&actState_bkup, pActState, sizeof(ActiveState));

        switch (avlState)
        {
        case Idle:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Unresponsive:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            default:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
            }
            break;

        case Unsupported:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Present:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            if ((SCARD_SHARE_DIRECT == dwShareMode) && (0 != dwPreferredProtocols))
                throw (DWORD)SCARD_E_NOT_READY;
            // Fall through intentionally

        case Ready:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                dwShareCount += 1;
                avlState = Shared;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Shared:
            ASSERT(0 < dwShareCount);
            ASSERT(0 == dwOwnerThreadId);

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                dwShareCount -= 1;
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_DIRECT:
                if (0 != dwShareCount)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_EXCLUSIVE:
                if (0 != dwShareCount)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                avlState = Shared;
                dwShareCount += 1;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Exclusive:
            ASSERT(0 == dwShareCount);
            ASSERT(0 != dwOwnerThreadId);

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                ASSERT(0 == m_dwShareCount);
                ASSERT(dwOwnerThreadId == GetCurrentThreadId());
                dwOwnerThreadId = 0;
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Shared;
                dwShareCount += 1;
                break;
            case SCARD_SHARE_DIRECT:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Direct:
            ASSERT(0 == dwShareCount);
            ASSERT(0 != dwOwnerThreadId);

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                ASSERT(0 == m_dwShareCount);
                ASSERT(dwOwnerThreadId == GetCurrentThreadId());
                dwOwnerThreadId = 0;
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                if (SCARD_PRESENT > dwRealReaderState)
                    throw (DWORD)SCARD_E_NO_SMARTCARD;
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                if (SCARD_PRESENT > dwRealReaderState)
                    throw (DWORD)SCARD_E_NO_SMARTCARD;
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Shared;
                dwShareCount += 1;
                break;
            case SCARD_SHARE_DIRECT:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Closing:
        case Broken:
        case Inactive:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reconnecting to disabled reader '%1'"),
                ReaderName());

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                if (0 != dwOwnerThreadId)
                    dwOwnerThreadId = 0;
                else
                {
                    ASSERT(0 < dwShareCount);
                    dwShareCount -= 1;
                }
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
            case SCARD_SHARE_DIRECT:
                throw (DWORD)SCARD_E_READER_UNAVAILABLE;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        default:
            CalaisError(__SUBROUTINE__, 402);
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }


        //
        // It's official!  Write the changes back to the structure.
        //

        CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        m_dwOwnerThreadId = dwOwnerThreadId;
        m_dwShareCount = dwShareCount;
        m_dwAvailStatus = avlState;
    }


    //
    // Verify the protocol settings.
    //

    if (0 != dwPreferredProtocols)
    {
        try
        {
            DWORD dwCurrentProtocol;

            CLatchReader latch(this, &m_ActiveState);
            PowerUp();
            SetActive(TRUE);
            dwCurrentProtocol = GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
            if (SCARD_PROTOCOL_UNDEFINED == dwCurrentProtocol)
            {
                SetReaderProto(dwPreferredProtocols);
                dwCurrentProtocol =
                    GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                ASSERT(0 != dwCurrentProtocol);
            }
            else
            {
                if (0 == (dwPreferredProtocols & dwCurrentProtocol))
                {
                    switch (dwPreferredProtocols)
                    {
                    case SCARD_PROTOCOL_RAW:
                    {
                        if (Exclusive > avlState)
                            throw (DWORD)SCARD_E_SHARING_VIOLATION;
                        SetReaderProto(dwPreferredProtocols);
                        dwCurrentProtocol = GetReaderAttr(
                            SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                        ASSERT(0 != dwCurrentProtocol);
                        break;
                    }
                    case SCARD_PROTOCOL_DEFAULT:
                        ASSERT(SCARD_PROTOCOL_UNDEFINED != dwCurrentProtocol);
                        break;
                    default:
                        throw (DWORD)SCARD_E_PROTO_MISMATCH;
                    }
                }
            }
            CLockWrite rwLock(&m_rwLock);
            m_dwCurrentProtocol = dwCurrentProtocol;
            CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        }
        catch (...)
        {

            //
            // Back out the latest changes.
            //

            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to establish protocol on reconnect"));

            CLockWrite rwLock(&m_rwLock);
            avlState = m_dwAvailStatus;
            dwOwnerThreadId = m_dwOwnerThreadId;
            dwShareCount = m_dwShareCount;

            switch (avlState)
            {

            //
            // We know from above that we're connected.  Other cases
            // can't possibly happen.
            //

            case Idle:
            case Unresponsive:
            case Unsupported:
            case Present:
            case Ready:
                ASSERT(Direct == avlState_bkup);
                m_dwAvailStatus = avlState_bkup ;
                m_dwOwnerThreadId = dwOwnerThreadId_bkup;
                m_dwShareCount = dwShareCount_bkup;
                break;

            case Shared:
                ASSERT(0 < dwShareCount);
                ASSERT(0 == dwOwnerThreadId);
#if 0
                // removed: bug 531317
                dwShareCount -= 1;
                if (0 == dwShareCount)
                    avlState = Ready;
#endif
                break;

            case Exclusive:
            case Direct:
                ASSERT(0 == dwShareCount);
                ASSERT(dwOwnerThreadId == GetCurrentThreadId());
                dwOwnerThreadId = 0;
                avlState = avlState_bkup;
                break;

            case Closing:
            case Broken:
            case Inactive:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Dis-Reconnecting from disabled reader '%1'"),
                    ReaderName());
                if (0 != dwOwnerThreadId)
                    dwOwnerThreadId = 0;
                else
                {
                    ASSERT(0 < dwShareCount);
                    dwShareCount -= 1;
                }
                break;

            default:
                CalaisError(__SUBROUTINE__, 411);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }


            //
            // We've rolled back to the original state.  Commit the changes.
            //

            CopyMemory(pActState, &actState_bkup, sizeof(ActiveState));
            m_dwOwnerThreadId = dwOwnerThreadId;
            m_dwShareCount = dwShareCount;
            SetAvailabilityStatus(avlState);
            throw;
        }
    }


    //
    // Ok, we can now admit to the changes
    //

    SetAvailabilityStatusLocked(avlState);
}


/*++

Free:

    This method is used to terminate another thread's hold on the reader.  It
    should be used only by thread termination code.

Arguments:

    dwThreadId supplies the thread believed to be holding the object.

    dwDisposition supplies the disposition of the card.

Return Value:

    None

Throws:

    Errors as DWORDs

Author:

    Doug Barlow (dbarlow) 6/19/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Free")

void
CReader::Free(
    DWORD dwThreadId,
    DWORD dwDisposition)
{
    BOOL fGrabbed = FALSE;

    try
    {
        if (m_mtxGrab.IsGrabbedBy(dwThreadId))
        {

            //
            // Careful!  We only want to take it away from the specified
            // thread, so we can't use the more general take routines.
            //

            m_mtxGrab.Take();
            fGrabbed = TRUE;

            CLatchReader latch(this);
            Dispose(dwDisposition);
            CLockWrite rwLock(&m_rwLock);
            switch (m_dwAvailStatus)
            {
            case Ready:
            case Idle:
            case Present:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Freeing hold on unheld reader!"));
                ASSERT(0 == m_dwShareCount);
                ASSERT(0 == m_dwOwnerThreadId);
                break;

            case Shared:
                ASSERT(0 < m_dwShareCount);
                ASSERT(0 == m_dwOwnerThreadId);
                m_dwShareCount -= 1;
                if (0 == m_dwShareCount)
                {
                    SetAvailabilityStatus(Ready);
                    SetActive(FALSE);
                    ReaderPowerDown();
                }
                break;

            case Exclusive:
            case Direct:
                ASSERT(0 == m_dwShareCount);
                ASSERT(m_dwOwnerThreadId == dwThreadId);
                m_dwOwnerThreadId = 0;
                SetAvailabilityStatus(Ready);
                SetActive(FALSE);
                ReaderPowerDown();
                break;

            case Closing:
            case Broken:
            case Inactive:
            case Unresponsive:
            case Unsupported:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Freeing hold on freed reader!"));
                break;

            default:
                CalaisError(__SUBROUTINE__, 412);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
        }
    }
    catch (...) {}

    if (fGrabbed)
        m_mtxGrab.Share();
}


/*++

IsInUse:

    This method provides a simple mechanism to determine whether or not this
    reader is in use by any applications.

Arguments:

    None

Return Value:

    TRUE - The reader is in use.
    FALSE - The reader is not in use.

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 4/21/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::IsInUse")

BOOL
CReader::IsInUse(
    void)
{
    BOOL fReturn = FALSE;

    switch (AvailabilityStatus())
    {
    case Idle:
    case Unresponsive:
    case Unsupported:
    case Present:
    case Ready:
    case Broken:
        fReturn = FALSE;
        break;

    case Shared:
    case Exclusive:
    case Direct:
        fReturn = TRUE;
        break;

    case Closing:
    case Inactive:
        fReturn = FALSE;
        break;

    default:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("IsInUse detected reader in invalid state"));
    }
    return fReturn;
}


/*++

ReaderPowerDown:

    This routine is the default implementation of the base method.  It
    just passes the same operation on to the control method.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderPowerDown")

void
CReader::ReaderPowerDown(
    void)
{
    DWORD dwSts;
    DWORD dwAction = SCARD_POWER_DOWN;

    ASSERT(IsLatchedByMe());

    dwSts = Control(
                IOCTL_SMARTCARD_POWER,
                (LPCBYTE)&dwAction,
                sizeof(DWORD));
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    CLockWrite rwLock(&m_rwLock);
    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
}

void
CReader::ReaderPowerDown(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    ReaderPowerDown();
}


/*++

GetReaderAttr:

    Get attributes from the reader driver.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    dwAttr - This supplies the identifier of the attribute being requested.

    bfValue - This buffer receives the returned attribute value.

    dwValue - This DWORD receives the returned attribute value.

    fLogError - This supplies a flag as to whether or not an error to this
        operation needs to be logged.  The default value is TRUE, to enable
        logging.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::GetReaderAttr")

void
CReader::GetReaderAttr(
    DWORD dwAttr,
    CBuffer &bfValue,
    BOOL fLogError)
{
    ASSERT(IsLatchedByMe());
    DWORD cbLen = bfValue.Space();
    DWORD dwSts = Control(
                    IOCTL_SMARTCARD_GET_ATTRIBUTE,
                    (LPCBYTE)&dwAttr,
                    sizeof(dwAttr),
                    bfValue.Access(),
                    &cbLen,
                    fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfValue.Resize(cbLen);
}

DWORD
CReader::GetReaderAttr(
    DWORD dwAttr,
    BOOL fLogError)
{
    DWORD dwRetAttr = 0;
    DWORD cbLen = sizeof(DWORD);

    ASSERT(IsLatchedByMe());
    DWORD dwSts = Control(
                    IOCTL_SMARTCARD_GET_ATTRIBUTE,
                    (LPCBYTE)&dwAttr,
                    sizeof(dwAttr),
                    (LPBYTE)&dwRetAttr,
                    &cbLen,
                    fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    return dwRetAttr;
}

void
CReader::GetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    CBuffer &bfValue,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    GetReaderAttr(dwAttr, bfValue, fLogError);
}

DWORD
CReader::GetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    return GetReaderAttr(dwAttr, fLogError);
}


/*++

SetReaderAttr:

    Set driver attributes.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    dwAttr - This supplies the identifier of the attribute being set.

    pvValue - This supplies the value of the attribute being set, if any.

    cbValue - This supples the length of any buffer suppoed in pvValue,
        in bytes.

    dwValue - This supplies the value of the attribute being set as a DWORD.

    fLogError - This supplies a flag as to whether or not an error to this
        operation needs to be logged.  The default value is TRUE, to enable
        logging.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetReaderAttr")

void
CReader::SetReaderAttr(
    DWORD dwAttr,
    LPCVOID pvValue,
    DWORD cbValue,
    BOOL fLogError)
{
    DWORD dwSts;
    CBuffer bfAttr(sizeof(DWORD) + cbValue);

    ASSERT(IsLatchedByMe());
    bfAttr.Set((LPCBYTE)&dwAttr, sizeof(DWORD));
    bfAttr.Append((LPCBYTE)pvValue, cbValue);
    dwSts = Control(
                IOCTL_SMARTCARD_SET_ATTRIBUTE,
                bfAttr.Access(),
                bfAttr.Length(),
                NULL,
                NULL,
                fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::SetReaderAttr(
    DWORD dwAttr,
    DWORD dwValue,
    BOOL fLogError)
{
    DWORD dwSts, rgdwValue[2];

    ASSERT(IsLatchedByMe());
    rgdwValue[0] = dwAttr;
    rgdwValue[1] = dwValue;
    dwSts = Control(
                IOCTL_SMARTCARD_SET_ATTRIBUTE,
                (LPCBYTE)rgdwValue,
                sizeof(rgdwValue),
                NULL,
                NULL,
                fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::SetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    LPCVOID pvValue,
    DWORD cbValue,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    SetReaderAttr(dwAttr, pvValue, cbValue, fLogError);
}

void
CReader::SetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    DWORD dwValue,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    SetReaderAttr(dwAttr, dwValue, fLogError);
}


/*++

SetReaderProto:

    Set the driver protocol.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    dwProto - This supplies the protocol to which to force the smartcard in the
        current reader.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetReaderProto")

void
CReader::SetReaderProto(
    DWORD dwProto)
{
    DWORD dwSts, dwNew, dwLen;

    ASSERT(IsLatchedByMe());
    dwLen = sizeof(DWORD);
    dwNew = 0;
    dwSts = Control(
                IOCTL_SMARTCARD_SET_PROTOCOL,
                (LPCBYTE)&dwProto,
                sizeof(DWORD),
                (LPBYTE)&dwNew,
                &dwLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::SetReaderProto(
    ActiveState *pActiveState,
    DWORD dwProto)
{
    CLatchReader latch(this, pActiveState);
    SetReaderProto(dwProto);
}


/*++

SetActive:

    Tell the driver it's active.

Arguments:

    fActive supplies the indication to be passed to the driver.

Return Value:

    None

Throws:

    None - It specifically swallows any errors.

Author:

    Doug Barlow (dbarlow) 7/15/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetActive")

#define DISABLED 0xff00
void
CReader::SetActive(
    IN BOOL fActive)
{
    ASSERT(DISABLED != TRUE);
    ASSERT(DISABLED != FALSE);
    ASSERT(IsLatchedByMe());
    CLockWrite lock(&m_rwLock);

    if ((DISABLED != m_fDeviceActive) && (fActive != m_fDeviceActive))
    {
        try
        {
            // Don't report any errors
            SetReaderAttr(SCARD_ATTR_DEVICE_IN_USE, fActive, FALSE);
        }
        catch (...)
        {
            fActive = DISABLED;
        }
        m_fDeviceActive = fActive;
    }
}


/*++

ReaderTransmit:

    Transmit data to the driver.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    pbSendData supplies the data to be sent,

    cbSendData supplies the length of the data to be sent, in bytes.

    bfRecvData receives the returned data.  It is assumed that this buffer has
        been presized to receive the largest maximum return.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderTransmit")

void
CReader::ReaderTransmit(
    LPCBYTE pbSendData,
    DWORD cbSendData,
    CBuffer &bfRecvData)
{
    DWORD dwSts, cbLen;

    ASSERT(IsLatchedByMe());

    cbLen = bfRecvData.Space();
    dwSts = Control(
                IOCTL_SMARTCARD_TRANSMIT,
                pbSendData,
                cbSendData,
                bfRecvData.Access(),
                &cbLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfRecvData.Resize(cbLen);
}

void
CReader::ReaderTransmit(
    ActiveState *pActiveState,
    LPCBYTE pbSendData,
    DWORD cbSendData,
    CBuffer &bfRecvData)
{
    CLatchReader latch(this, pActiveState);
    ReaderTransmit(pbSendData, cbSendData, bfRecvData);
}


/*++

ReaderSwallow:

    Tell the reader driver to swallow a card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderSwallow")

void
CReader::ReaderSwallow(
    void)
{
    DWORD dwSts;

    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_SWALLOW);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::ReaderSwallow(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    ReaderSwallow();
}


/*++

ReaderColdReset:

    Tell the driver to do a cold reset on the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    bfAtr - This receives the reported ATR string of the card.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderColdReset")

void
CReader::ReaderColdReset(
    CBuffer &bfAtr)
{
    DWORD dwSts;
    DWORD dwAction = SCARD_COLD_RESET;
    DWORD cbLen;
#ifdef DBG
    CBuffer cfAtrSiCrypt((PBYTE) "\x3B\xEF\x00\x00\x81\x31\x20\x49\x00\x5C\x50\x43\x54\x10\x27\xF8\xD2\x76\x00\x00\x38\x33\x00\x4D", 24);
#endif

    ASSERT(IsLatchedByMe());

    bfAtr.Presize(33);
    cbLen = bfAtr.Space();
    dwSts = Control(
                IOCTL_SMARTCARD_POWER,
                (LPCBYTE)&dwAction,
                sizeof(DWORD),
                bfAtr.Access(),
                &cbLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfAtr.Resize(cbLen, TRUE);
    if ((2 > cbLen) && (Direct > AvailabilityStatus()))
    {
        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Reader '%1' Unresponsive to cold reset"),
            ReaderName());
        throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
    }
#ifdef DBG
    if(bfAtr.Compare(cfAtrSiCrypt) == 0) {

        DebugBreak();
    }
#endif
}

void
CReader::ReaderColdReset(
    ActiveState *pActiveState,
    CBuffer &bfAtr)
{
    CLatchReader latch(this, pActiveState);
    ReaderColdReset(bfAtr);
}


/*++

ReaderWarmReset:

    Tell the reader driver to do a warm reset on the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    bfAtr - This receives the reported ATR string of the card.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderWarmReset")

void
CReader::ReaderWarmReset(
    CBuffer &bfAtr)
{
    DWORD dwSts;
    DWORD dwAction = SCARD_WARM_RESET;
    DWORD cbLen;

    ASSERT(IsLatchedByMe());

    bfAtr.Presize(33);
    cbLen = bfAtr.Space();
    dwSts = Control(
                IOCTL_SMARTCARD_POWER,
                (LPCBYTE)&dwAction,
                sizeof(DWORD),
                bfAtr.Access(),
                &cbLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfAtr.Resize(cbLen, TRUE);
    if ((2 > cbLen) && (Direct > AvailabilityStatus()))
    {
        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Reader '%1' Unresponsive to warm reset"),
            ReaderName());
        throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
    }
}

void
CReader::ReaderWarmReset(
    ActiveState *pActiveState,
    CBuffer &bfAtr)
{
    CLatchReader latch(this, pActiveState);
    ReaderWarmReset(bfAtr);
}


/*++

ReaderEject:

    Tell the driver to eject the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderEject")

void
CReader::ReaderEject(
    void)
{
    DWORD dwSts;

    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_EJECT);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::ReaderEject(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    ReaderEject();
}


#ifdef  SCARD_CONFISCATE_CARD
/*++

ReaderConfiscate:

    Tell the driver to confiscate the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderConfiscate")

void
CReader::ReaderConfiscate(
    void)
{
    DWORD dwSts, dwRetLen;

    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_CONFISCATE);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::ReaderConfiscate(
    ActiveState *pActiveState)
{
    CLatchReader grab(this, pActiveState);
    ReaderConfiscate();
}
#endif


//
///////////////////////////////////////////////////////////////////////////////
//
// The following routines are default actions for child reader classes.
//


/*++

Control:

    The default implementation of Control just returns the error code
    'NO_SUPPORT'.

Arguments:

    dwCode - This supplies the control code for the operation. This value
        identifies the specific operation to be performed.

    pbSend - This supplies a pointer to a buffer that contains the data required
        to perform the operation.  This parameter can be NULL if the dwCode
        parameter specifies an operation that does not require input data.

    cbSend - This supplies the size, in bytes, of the buffer pointed to by
        pbSend.

    pbRedv = This buffer recieves the return value, if any.  If none is
        expected, this parameter may be NULL.

    pcbRecv - This supplies the length of the pbRecv buffer in bytes, and
        receives the actual length of the return value, in bytes.  This
        parameter may be NULL if and only if pbRecv is NULL.

    fLogError - This supplies a flag indicating whether or not errors should
        be logged.  The default is TRUE.

Return Value:

    As returned from the driver or handler.

Throws:

    Per VerifyActive.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Control")

DWORD
CReader::Control(
    ActiveState *pActiveState,
    DWORD dwCode,
    LPCBYTE pbSend,
    DWORD cbSend,
    LPBYTE pbRecv,
    LPDWORD pcbLen,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    return Control(dwCode, pbSend, cbSend, pbRecv, pcbLen, fLogError);
}

DWORD
CReader::Control(
    DWORD dwCode,
    LPCBYTE pbSend,
    DWORD cbSend,
    LPBYTE pbRecv,
    LPDWORD pcbRecv,
    BOOL fLogError)
{
    return ERROR_NOT_SUPPORTED;
}


/*++

ReaderHandle:

    This method returns a designated value identifying the reader.  The actual
    value is dependent on the object's type and state, and is not guaranteed to
    be unique among readers.

Arguments:

    None

Return Value:

    The designated handle of this reader.

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderHandle")

HANDLE
CReader::ReaderHandle(
    void)
const
{
    return INVALID_HANDLE_VALUE;
}


/*++

DeviceName:

    This method returns any low level name associated with the reader.

Arguments:

    None

Return Value:

    The low level name of the reader.

Author:

    Doug Barlow (dbarlow) 4/15/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::DeviceName")

LPCTSTR
CReader::DeviceName(
    void)
const
{
    return TEXT("");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\server\driver.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    driver

Abstract:

    This file implements the driver subclass of the reader class.  This subclass
    is specific to drivers conforming to the PC/SC and Calais specifications.

Author:

    Doug Barlow (dbarlow) 6/3/1997

Environment:

    Win32, C++

Notes:

    This subclass uses interrupts to monitor insertion and removal events.

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS 0x0400
#endif

#include <windows.h>
#include <stdlib.h>
#include <dbt.h>
#include <setupapi.h>
#include <CalServe.h>

#define MONITOR_MAX_TRIES 3     // We'll try waiting for a card 3 times before
                                // we kill the thread.
#define SCARD_IO_TIMEOUT 15000  // Maximum time to allow for an I/O operation
                                // before complaining.
#define POWERDOWN_TIMEOUT 15    // Number of seconds to wait before powering
                                // down a newly inserted but unused card.
#ifdef DBG
#define SCARD_TRACE_ENABLED
static LPCTSTR MapIoControlCodeToString(ULONG IoControlCode);
#endif

#ifdef SCARD_TRACE_ENABLED
typedef struct {
    DWORD dwStructLen;      // Actual structure length
    SYSTEMTIME StartTime;   // Time request was posted
    SYSTEMTIME EndTime;     // Time request completed
    DWORD dwProcId;         // Process Id
    DWORD dwThreadId;       // Thread Id
    HANDLE hDevice;         // I/O handle
    DWORD dwIoControlCode;  // I/O control code issued
    DWORD nInBuffer;        // Offset to input buffer
    DWORD nInBufferSize;    // Input buffer size
    DWORD nOutBuffer;       // Offset to output buffer
    DWORD nOutBufferSize;   // Size of user's receive buffer
    DWORD nBytesReturned;   // Actual size of returned data
    DWORD dwStatus;         // Returned status code
                            // InBuffer and OutBuffer follow.
} RequestTrace;
#endif

static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };
static const LARGE_INTEGER l_ftPowerdownTime
                        = { (DWORD)(-(POWERDOWN_TIMEOUT * 10000000)), -1 };
static DWORD l_dwMaxWdmReaders = 0;


/*++

AddAllWdmDrivers:

    This routine adds all the PC/SC compliant WDM drivers and
    non-interrupting drivers that it can find into the Resource Manager.

Arguments:

    None

Return Value:

    The number of readers added

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AddAllWdmDrivers")

DWORD
AddAllWdmDrivers(
    void)
{
    if (0 == l_dwMaxWdmReaders)
    {
        l_dwMaxWdmReaders = MAXIMUM_SMARTCARD_READERS;

        try
        {
            CRegistry regCalais(
                        HKEY_LOCAL_MACHINE,
                        CalaisString(CALSTR_CALAISREGISTRYKEY),
                        KEY_READ,
                        REG_OPTION_EXISTS);
            l_dwMaxWdmReaders = regCalais.GetNumericValue(
                                    CalaisString(CALSTR_MAXLEGACYDEVICES));
        }
        catch (...) {}
    }

    LPCTSTR szDevHeader = CalaisString(CALSTR_LEGACYDEVICEHEADER);
    LPCTSTR szDevName = CalaisString(CALSTR_LEGACYDEVICENAME);
    DWORD cchDevHeader = lstrlen(szDevHeader);
    DWORD cchDevName = lstrlen(szDevName);
    TCHAR szDevice[MAX_PATH];
    DWORD dwSts, dwIndex, dwCount = 0;
    int nSts;


    //
    // Look for usable devices.
    //

    for (dwIndex = 0; dwIndex < l_dwMaxWdmReaders; dwIndex += 1)
    {
        nSts = wsprintf(
                    szDevice,
                    TEXT("%s%s%lu"),
                    szDevHeader,
                    szDevName,
                    dwIndex);
        if (0 >= nSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Server control cannot build device name:  %1"),
                GetLastError());
            continue;
        }

        dwSts = AddReaderDriver(szDevice, 0);
        if (ERROR_SUCCESS != dwSts)
            continue;
        dwCount += 1;
    }
    return dwCount;
}


/*++

AddAllPnPDrivers:

    This routine adds all the PC/SC compliant PnP drivers that it can find into
    the Resource Manager.

Arguments:

    None

Return Value:

    The number of readers added

Author:

    Doug Barlow (dbarlow) 3/26/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AddAllPnPDrivers")

DWORD
AddAllPnPDrivers(
    void)
{
#if 0
    DWORD dwSts;
    BOOL fSts;
    HDEVINFO hDevInfoSet = INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA DeviceData;
    DWORD dwIndex;
    DWORD dwLength;
    DWORD dwCount = 0;
    LPCTSTR szDevice;
    GUID guidSmartcards;


    //
    // Get a list of PnP Smart Card Readers on this system.
    //

    try
    {
        CBuffer bfDevDetail;
        PSP_DEVICE_INTERFACE_DETAIL_DATA pDevDetail;

        CopyMemory(&guidSmartcards, &l_guidSmartcards, sizeof(GUID));
        hDevInfoSet = SetupDiGetClassDevs(
            &guidSmartcards,
            NULL,
            NULL,
            DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
        if (INVALID_HANDLE_VALUE == hDevInfoSet)
        {
            dwSts = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Server control cannot enumerate PnP devices:  %1"),
                dwSts);
            throw dwSts;
        }

        bfDevDetail.Resize(sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA));
        for (dwIndex = 0;; dwIndex += 1)
        {
            try
            {

                //
                // Get one device at a time.
                //

                ZeroMemory(&DeviceData, sizeof(DeviceData));
                DeviceData.cbSize = sizeof(DeviceData);
                fSts = SetupDiEnumDeviceInterfaces(
                    hDevInfoSet,
                    NULL,
                    &guidSmartcards,
                    dwIndex,
                    &DeviceData);
                if (!fSts)
                {
                    dwSts = GetLastError();
                    if (ERROR_NO_MORE_ITEMS == dwSts)
                        break;
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Server control failed device enumeration:  %1"),
                        dwSts);
                    continue;
                }


                //
                // Get the device name.
                //

                do
                {
                    ZeroMemory(
                        bfDevDetail.Access(),
                        bfDevDetail.Space());
                    pDevDetail =
                        (PSP_DEVICE_INTERFACE_DETAIL_DATA)bfDevDetail.Access();
                    pDevDetail->cbSize =
                        sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                    fSts = SetupDiGetDeviceInterfaceDetail(
                        hDevInfoSet,
                        &DeviceData,
                        pDevDetail,
                        bfDevDetail.Space(),
                        &dwLength,
                        NULL);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Server control failed to get PnP device details:  %1"),
                                dwSts);
                            throw dwSts;
                        }
                    }
                    bfDevDetail.Resize(dwLength, fSts);
                } while (!fSts);
                szDevice = pDevDetail->DevicePath;


                //
                // Start the device.
                //

                dwSts = CalaisAddReader(szDevice, RDRFLAG_PNPMONITOR);
                if (ERROR_SUCCESS == dwSts)
                    dwCount += 1;
            }
            catch (...) {}
        }
        fSts = SetupDiDestroyDeviceInfoList(hDevInfoSet);
        hDevInfoSet = INVALID_HANDLE_VALUE;
        if (!fSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Server control cannot destroy PnP device enumeration:  %1"),
                GetLastError());
    }
    catch (...)
    {
        if (INVALID_HANDLE_VALUE != hDevInfoSet)
        {
            fSts = SetupDiDestroyDeviceInfoList(hDevInfoSet);
            if (!fSts)
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Server control cannot destroy PnP device enumeration:  %1"),
                    GetLastError());
        }
    }
    return dwCount;
#else
    DWORD dwIndex = 0, dwSubindex = 0, dwSts = ERROR_SUCCESS, dwCount = 0;
    LPCTSTR szBus, szPort, szDevice;
    CRegistry regBus, regPort;
    CRegistry regPnPList(HKEY_LOCAL_MACHINE, CalaisString(CALSTR_PNPDEVICEREGISTRYKEY), KEY_READ);


    //
    // Look for usable devices.
    //


    for (dwIndex = 0;; dwIndex += 1)
    {
        try
        {
            szBus = regPnPList.Subkey(dwIndex);
            if (NULL == szBus)
                break;
            regBus.Open(regPnPList, szBus, KEY_READ);
            for (dwSubindex = 0;; dwSubindex += 1)
            {
                try
                {
                    szPort = regBus.Subkey(dwSubindex);
                }
                catch (...)
                {
                    szPort = NULL;
                }
                if (NULL == szPort)
                    break;
                try
                {
                    regPort.Open(regBus, szPort, KEY_READ);
                    szDevice = regPort.GetStringValue(
                                    CalaisString(CALSTR_SYMBOLICLINKSUBKEY));
                    if (NULL != szDevice)
                    {
                        dwSts = CalaisAddReader(szDevice, RDRFLAG_PNPMONITOR);
                        
                        if (ERROR_SUCCESS == dwSts)
                            dwCount += 1;
                    }

                    regPort.Close();
                }
                catch (...)
                {
                    regPort.Close();
                }
            }
            regBus.Close();
        }
        catch (...)
        {
            regBus.Close();
            szBus = NULL;
        }
        if (NULL == szBus)
            break;
    }
    return dwCount;
#endif
}


/*++

AddReaderDriver:

    This routine adds a given driver by name.

Arguments:

    szDevice supplies the device name of the reader to be added.

    dwFlags supplies the set of flags requested for this reader.

Return Value:

    A status code as a DWORD value.  ERROR_SUCCESS implies success.

Author:

    Doug Barlow (dbarlow) 3/26/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AddReaderDriver")

DWORD
AddReaderDriver(
    IN LPCTSTR szDevice,
    IN DWORD dwFlags)
{
    CHandleObject hReader(DBGT("Reader to be added in AddReaderDriver"));
    CReader *pRdr = NULL;
    DWORD dwReturn = ERROR_SUCCESS;

    try
    {
        DWORD dwSts;


        //
        // See if we can get to the reader.
        //

        hReader = CreateFile(
                    szDevice,
                    GENERIC_READ | GENERIC_WRITE,
                    0,      // No sharing
                    NULL,   // No inheritance
                    OPEN_EXISTING,
                    FILE_FLAG_OVERLAPPED,
                    NULL);
        if (!hReader.IsValid())
        {
            dwSts = hReader.GetLastError();
            if ((ERROR_BAD_DEVICE != dwSts)
                && (ERROR_BAD_UNIT != dwSts)
                && (ERROR_FILE_NOT_FOUND != dwSts))
                CalaisError(__SUBROUTINE__, 602, dwSts);
            // throw dwSts;
            return dwSts;   // More efficient.
        }

        pRdr = new CReaderDriver(
                        hReader,
                        szDevice,
                        dwFlags);
        if (NULL == pRdr)
        {
            CalaisError(__SUBROUTINE__, 603, szDevice);
            return (DWORD)SCARD_E_NO_MEMORY;
        }
        if (pRdr->InitFailed())
        {
            CalaisError(__SUBROUTINE__, 611);
            delete pRdr;
            pRdr = NULL;
            return (DWORD) SCARD_E_NO_MEMORY;
        }
        hReader.Relinquish();


        //
        // Finalize initialization.
        //

        pRdr->Initialize();
        dwSts = CalaisAddReader(pRdr);
        if (SCARD_S_SUCCESS != dwSts)
            throw dwSts;
        pRdr = NULL;


        //
        // Clean up.
        //

        ASSERT(!hReader.IsValid());
        ASSERT(NULL == pRdr);
    }
    catch (DWORD dwError)
    {
        if (hReader.IsValid())
            hReader.Close();
        if (NULL != pRdr)
            delete pRdr;
        dwReturn = dwError;
    }
    catch (...)
    {
        if (hReader.IsValid())
            hReader.Close();
        if (NULL != pRdr)
            delete pRdr;
        dwReturn = SCARD_F_UNKNOWN_ERROR;
    }

    return dwReturn;
}


#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("MapIoControlCodeToString")
static LPCTSTR
MapIoControlCodeToString(
    ULONG IoControlCode
    )
{
    ULONG i;

    static const struct {

        ULONG   IoControlCode;
        LPCTSTR String;

    } IoControlList[] = {

        IOCTL_SMARTCARD_POWER,          TEXT("POWER"),
        IOCTL_SMARTCARD_GET_ATTRIBUTE,  TEXT("GET_ATTRIBUTE"),
        IOCTL_SMARTCARD_SET_ATTRIBUTE,  TEXT("SET_ATTRIBUTE"),
        IOCTL_SMARTCARD_CONFISCATE,     TEXT("CONFISCATE"),
        IOCTL_SMARTCARD_TRANSMIT,       TEXT("TRANSMIT"),
        IOCTL_SMARTCARD_EJECT,          TEXT("EJECT"),
        IOCTL_SMARTCARD_SWALLOW,        TEXT("SWALLOW"),
        IOCTL_SMARTCARD_IS_PRESENT,     TEXT("IS_PRESENT"),
        IOCTL_SMARTCARD_IS_ABSENT,      TEXT("IS_ABSENT"),
        IOCTL_SMARTCARD_SET_PROTOCOL,   TEXT("SET_PROTOCOL"),
        IOCTL_SMARTCARD_GET_STATE,      TEXT("GET_STATE"),
        IOCTL_SMARTCARD_GET_LAST_ERROR, TEXT("GET_LAST_ERROR")
    };

    for (i = 0; i < sizeof(IoControlList) / sizeof(IoControlList[0]); i++) {

        if (IoControlCode == IoControlList[i].IoControlCode) {

            return IoControlList[i].String;
        }
    }

    return TEXT("*** UNKNOWN ***");
}
#endif


//
//==============================================================================
//
//  CReaderDriver
//

/*++

CReaderDriver:

    This is the constructor for a CReaderDriver class.  It just zeroes out the
    data structures in preparation for the Initialize call.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::CReaderDriver")

CReaderDriver::CReaderDriver(
    HANDLE hReader,
    LPCTSTR szDevice,
    DWORD dwFlags)
:   m_bfDosDevice(),
    m_hReader(DBGT("CReaderDriver's reader handle")),
    m_hThread(DBGT("CReaderDriver's Thread Handle")),
    m_hRemoveEvent(DBGT("CReaderDriver's Remove Event")),
    m_hOvrWait(DBGT("CReaderDriver's Overlapped I/O completion event"))
{
    // don't do any initialization if the CReader object failed
    // to initialize correctly
    if (InitFailed())
        return;

    Clean();
    m_bfDosDevice.Set(
        (LPBYTE)szDevice,
        (lstrlen(szDevice) + 1) * sizeof(TCHAR));
    m_hReader = hReader;
    m_dwCapabilities = 0;
    m_dwFlags |= dwFlags;
}


/*++

~CReaderDriver:

    This is the destructor for the reader class.  It just uses the Close service
    to shut down.  Note that it is *NOT* declared virtual, in order to improve
    performance.  Should it be desirable to subclass this class, this will have
    to change.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::~CReaderDriver")

CReaderDriver::~CReaderDriver()
{
    if (InitFailed())
        return;

    TakeoverReader();
    Close();
}


/*++

Clean:

    This routine is used to initialize all the property values.  It does *NOT*
    do any deallocation or locking!  Use Close() for that.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Clean")

void
CReaderDriver::Clean(
    void)
{
    m_pvAppControl = NULL;
    m_dwThreadId = 0;
    m_bfDosDevice.Reset();
    ZeroMemory(&m_ovrlp, sizeof(m_ovrlp));
    ASSERT(m_dwAvailStatus == Inactive);
    // CReader::Clean();
}


/*++

Close:

    This routine does the work of closing down a CReaderDriver class, and
    returning it to it's default state.  It does not assume any particular
    state, other than that the class has been Clean()ed once (at construction).

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Close")

void
CReaderDriver::Close(
    void)
{
    AppUnregisterDevice(m_hReader, DosDevice(), &m_pvAppControl);
    if (m_hReader.IsValid())
        CReader::Close();
    if (m_hThread.IsValid())
    {
        ASSERT(m_hRemoveEvent.IsValid());
        if (!SetEvent(m_hRemoveEvent))
        {
            DWORD dwErr = GetLastError();
            CalaisError(__SUBROUTINE__, 604, dwErr);
        }
        WaitForever(
            m_hThread,
            CALAIS_THREAD_TIMEOUT,
            DBGT("Waiting for Reader Driver thread %2: %1"),
            m_dwThreadId);
        m_hThread.Close();
        m_hRemoveEvent.Close();
    }

    if (m_hReader.IsValid())
        m_hReader.Close();
    if (m_hRemoveEvent.IsValid())
        m_hRemoveEvent.Close();
    if (m_hOvrWait.IsValid())
        m_hOvrWait.Close();
    Clean();
}


/*++

Initialize:

    This method initializes a clean CReaderDriver object to a running state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Initialize")

void
CReaderDriver::Initialize(
    void)
{
    ASSERT(m_hReader.IsValid());
    ASSERT(!m_hRemoveEvent.IsValid());
    ASSERT(NULL == m_ovrlp.hEvent);

    try
    {
        DWORD dwSts;


        //
        // Prep the Overlapped structure.
        //

        m_hOvrWait = m_ovrlp.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_hOvrWait.IsValid())
        {
            dwSts = m_hOvrWait.GetLastError();
            CalaisError(__SUBROUTINE__, 605, dwSts);
            throw dwSts;
        }


        //
        // Determine the characteristics.
        //

        try
        {
            CLatchReader latch(this);
            m_dwCapabilities = GetReaderAttr(SCARD_ATTR_CHARACTERISTICS);
        }
        catch (...)
        {
            m_dwCapabilities = SCARD_READER_EJECTS;   // Safe assumption
        }


        //
        // Do common initialization.
        //

        CReader::Initialize();
        if (0 != (m_dwFlags & RDRFLAG_PNPMONITOR))
            AppRegisterDevice(m_hReader, DosDevice(), &m_pvAppControl);


        //
        // Kick off the monitor thread.
        //

        m_hRemoveEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_hRemoveEvent.IsValid())
        {
            dwSts = m_hRemoveEvent.GetLastError();
            CalaisError(__SUBROUTINE__, 606, dwSts);
            throw dwSts;
        }
        m_hThread = CreateThread(
                        NULL,   // Not inheritable
                        CALAIS_STACKSIZE,   // Default stack size
                        MonitorReader,
                        this,
                        CREATE_SUSPENDED,
                        &m_dwThreadId);
        if (!m_hThread.IsValid())
        {
            dwSts = m_hThread.GetLastError();
            CalaisError(__SUBROUTINE__, 607, dwSts);
            throw dwSts;
        }
        if ((DWORD)(-1) == ResumeThread(m_hThread))
        {
            dwSts = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Monitor Thread won't resume:  %1"),
                dwSts);
        }
    }

    catch (...)
    {
        Close();
        throw;
    }
}


/*++

Disable:

    This method releases any physical resources associated with the reader
    object, and marks the object offline.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORDs

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Disable")

void
CReaderDriver::Disable(
    void)
{
    DWORD dwSts;

    CReader::Disable();
    ASSERT(m_hRemoveEvent.IsValid());
    if (!SetEvent(m_hRemoveEvent))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Reader Driver Disable can't notify '%2's monitor thread: %1"),
            GetLastError(),
            ReaderName());
    if (m_hThread.IsValid())
    {
        dwSts = WaitForAnObject(m_hThread, CALAIS_THREAD_TIMEOUT);
        if (ERROR_SUCCESS != dwSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Abandoning wait for Reader Driver Disable: Closing reader %1"),
                ReaderName());
    }
    CalaisWarning(
        __SUBROUTINE__,
        DBGT("Reader Driver Disable: Closing reader %1"),
        ReaderName());
    CLockWrite rwLock(&m_rwLock);
    if (m_hReader.IsValid())
        m_hReader.Close();
}


/*++

ReaderHandle:

    This method returns a designated value identifying the reader.  The actual
    value is dependent on the object's type and state, and is not guaranteed to
    be unique among readers.

Arguments:

    None

Return Value:

    The designated handle of this reader.

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::ReaderHandle")

HANDLE
CReaderDriver::ReaderHandle(
    void)
const
{
    if (m_hReader.IsValid())
        return m_hReader.Value();
    else
        return m_pvAppControl;  // A bit of magic to help find closed readers.
}


/*++

DeviceName:

    This method returns any low level name associated with the reader.

Arguments:

    None

Return Value:

    The low level name of the reader.

Author:

    Doug Barlow (dbarlow) 4/15/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::DeviceName")

LPCTSTR
CReaderDriver::DeviceName(
    void)
const
{
    return DosDevice();
}


/*++

Control:

    This method performs an I/O control operation on the reader.

Arguments:

    dwCode supplies the IOCTL code to be performed.

    pbSend supplies the buffer to be sent to the reader.

    cbSend supplies the length of the buffer to be sent, in bytes.

    pbRecv receives the data returned from the reader.

    cbRecv supplies the length of the receive buffer, in bytes.

    pcbRecv receives the actual length of the receive buffer used, in bytes.

    fLogError supplies a boolean indicator as to whether or not to log any errors
        that may occur.

Return Value:

    The returned status indication.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/26/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Control")

DWORD
CReaderDriver::Control(
    DWORD dwCode,
    LPCBYTE pbSend,
    DWORD cbSend,
    LPBYTE pbRecv,
    LPDWORD pdwLen,
    BOOL fLogError)
{
    DWORD dwStatus;
    DWORD dwSpace, dwLength;

    ASSERT(IsLatchedByMe());
    if (NULL == pdwLen)
    {
        dwSpace = 0;
        pdwLen = &dwLength;
    }
    else
        dwSpace = *pdwLen;
    *pdwLen = 0;

    dwStatus = SyncIoControl(
                    dwCode,
                    (LPVOID)pbSend,
                    cbSend,
                    pbRecv,
                    dwSpace,
                    pdwLen,
                    fLogError);
    if ((ERROR_SUCCESS != dwStatus) && fLogError)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Driver '%2' returned error code to control request:  %1"),
            dwStatus,
            ReaderName());
    }
    return dwStatus;
}


/*++

SyncIoControl:

    This service performs a synchronous I/O control service, blocking out other
    access.

Arguments:

    dwIoControlCodesupplies the control code of the operation to perform

    lpInBuffersupplies a pointer to buffer to supply input data

    nInBufferSize supplies the size of input buffer

    lpOutBuffer receives any output data

    nOutBufferSize supplies the size of output buffer

    lpBytesReturned receives the output byte count

    lpOverlapped supplies the overlapped structure for asynchronous operation

    fLogError supplies a boolean indicator as to whether or not to log any errors
        that may occur.

Return Value:

    ERROR_SUCCESS if all went well, otherwise the error code.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/17/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::SyncIoControl")

DWORD
CReaderDriver::SyncIoControl(
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    BOOL fLogError)
{
    DWORD dwReturn = ERROR_SUCCESS;
    BOOL fSts;

#ifdef SCARD_TRACE_ENABLED
    static DWORD l_cbStructLen = 0;
    static LPBYTE l_pbStruct = NULL;

    DWORD cbTraceStruct = sizeof(RequestTrace) + nInBufferSize + nOutBufferSize;
    RequestTrace *prqTrace;
    LPBYTE pbData;
    HANDLE hLogFile = INVALID_HANDLE_VALUE;

    try
    {
        if (NULL == l_pbStruct)
        {
            l_pbStruct = (LPBYTE)malloc(cbTraceStruct);
            if (NULL == l_pbStruct)
            {
                DWORD dwErr = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Can't allocate trace buffer: %1"),
                    dwErr);
                throw dwErr;

            }
            l_cbStructLen = cbTraceStruct;
        }
        else
        {
            if (l_cbStructLen < cbTraceStruct)
            {
                free(l_pbStruct);
                l_pbStruct = (LPBYTE)malloc(cbTraceStruct);
                if (NULL == l_pbStruct)
                {
                    DWORD dwErr = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Can't enlarge trace buffer: %1"),
                        dwErr);
                    throw dwErr;

                }
                l_cbStructLen = cbTraceStruct;
            }
        }

        prqTrace = (RequestTrace *)l_pbStruct;
        pbData = l_pbStruct + sizeof(RequestTrace);
        GetLocalTime(&prqTrace->StartTime);
        prqTrace->dwProcId = GetCurrentProcessId();
        prqTrace->dwThreadId = GetCurrentThreadId();
        prqTrace->hDevice = m_hReader;
        prqTrace->dwIoControlCode = dwIoControlCode;
        CopyMemory(pbData, lpInBuffer, nInBufferSize);
        prqTrace->nInBuffer = (DWORD)(pbData - (LPBYTE)prqTrace);
        prqTrace->nInBufferSize = nInBufferSize;
        pbData += nInBufferSize;
        prqTrace->nOutBufferSize = nOutBufferSize;
    }
    catch (...)
    {
        if (NULL != l_pbStruct)
            free(l_pbStruct);
        l_pbStruct = NULL;
        l_cbStructLen = 0;
    }
#endif

    ASSERT(IsLatchedByMe());
    if (m_hReader.IsValid())
    {
        fSts = DeviceIoControl(
                    m_hReader,
                    dwIoControlCode,
                    lpInBuffer,
                    nInBufferSize,
                    lpOutBuffer,
                    nOutBufferSize,
                    lpBytesReturned,
                    &m_ovrlp);
        if (!fSts)
        {
            DWORD dwSts;

            dwSts = GetLastError();
            if (ERROR_IO_PENDING == dwSts)
            {
                for (;;)
                {
                    dwSts = WaitForAnObject(m_ovrlp.hEvent, SCARD_IO_TIMEOUT);
                    if (ERROR_SUCCESS == dwSts)
                        break;
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("I/O wait on device '%2' has timed out: %1"),
                        dwSts,
                        ReaderName());
                }
                fSts = GetOverlappedResult(
                    m_hReader,
                    &m_ovrlp,
                    lpBytesReturned,
                    TRUE);
                if (!fSts)
                    dwReturn = GetLastError();
            }
            else
                dwReturn = dwSts;
        }
    }
    else
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("I/O attempted to Reader '%1' with handle INVALID"),
            ReaderName());
        dwReturn = ERROR_DEVICE_REMOVED;
    }

#ifdef SCARD_TRACE_ENABLED
    if (0 < l_cbStructLen)
    {
        GetLocalTime(&prqTrace->EndTime);
        prqTrace->dwStatus = dwReturn;
        prqTrace->nOutBuffer = (DWORD)(pbData - (LPBYTE)prqTrace);
        prqTrace->nBytesReturned = *lpBytesReturned;
        CopyMemory(pbData, lpOutBuffer, *lpBytesReturned);
        prqTrace->dwStructLen = sizeof(RequestTrace)
            + nInBufferSize + *lpBytesReturned;

        LockSection(
            g_pcsControlLocks[CSLOCK_TRACELOCK],
            DBGT("Logging Synchronous I/O to the reader"));
        hLogFile = CreateFile(
                        CalaisString(CALSTR_DRIVERTRACEFILENAME),
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        if (INVALID_HANDLE_VALUE != hLogFile)
        {
            DWORD dwLen;
            dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
            fSts = WriteFile(
                        hLogFile,
                        prqTrace,
                        prqTrace->dwStructLen,
                        &dwLen,
                        NULL);
            CloseHandle(hLogFile);
        }
    }
#endif

    if ((ERROR_SUCCESS != dwReturn) && fLogError)
    {
        TCHAR szIoctl[20];  // Ugly but enough to fit all messages below
        DWORD dwReport = dwReturn;

        switch(dwIoControlCode)
        {
        case IOCTL_SMARTCARD_POWER:
            _tcscpy(szIoctl, _T("POWER"));

                // Remap "The disk media is not recognized. It may not be formatted."
                // to "The smart card is not responding to a reset."
            if (dwReturn == ERROR_UNRECOGNIZED_MEDIA)
                dwReport = SCARD_W_UNRESPONSIVE_CARD;
            break;
        case IOCTL_SMARTCARD_GET_ATTRIBUTE:
            _tcscpy(szIoctl, _T("GET_ATTRIBUTE"));
            break;
        case IOCTL_SMARTCARD_SET_ATTRIBUTE:
            _tcscpy(szIoctl, _T("SET_ATTRIBUTE"));
            break;
        case IOCTL_SMARTCARD_CONFISCATE:
            _tcscpy(szIoctl, _T("CONFISCATE"));
            break;
        case IOCTL_SMARTCARD_TRANSMIT:
            _tcscpy(szIoctl, _T("TRANSMIT"));
            break;
        case IOCTL_SMARTCARD_EJECT:
            _tcscpy(szIoctl, _T("EJECT"));
            break;
        case IOCTL_SMARTCARD_SWALLOW:
            _tcscpy(szIoctl, _T("SWALLOW"));
            break;
        case IOCTL_SMARTCARD_IS_PRESENT:
            _tcscpy(szIoctl, _T("IS_PRESENT"));
            break;
        case IOCTL_SMARTCARD_IS_ABSENT:
            _tcscpy(szIoctl, _T("IS_ABSENT"));
            break;
        case IOCTL_SMARTCARD_SET_PROTOCOL:
            _tcscpy(szIoctl, _T("SET_PROTOCOL"));
            break;
        case IOCTL_SMARTCARD_GET_STATE:
            _tcscpy(szIoctl, _T("GET_STATE"));
            break;
        case IOCTL_SMARTCARD_GET_LAST_ERROR:
            _tcscpy(szIoctl, _T("GET_LAST_ERROR"));
            break;
        case IOCTL_SMARTCARD_GET_PERF_CNTR:
            _tcscpy(szIoctl, _T("GET_PERF_CNTR"));
            break;
        default:
            _tcscpy(szIoctl, _T("0x"));
            _ultot(dwIoControlCode, szIoctl+2, 16);
        }

        CalaisError(
            __SUBROUTINE__,
            610,
            dwReport,
            ReaderName(),
            szIoctl);
        // "Smart Card Reader '%2' rejected IOCTL 0x%3: %1"
    }
    return dwReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  CReaderDriver friends
//

/*++

MonitorReader:

    This routine monitors card insertion events for a reader, and maintains the
    status flags in the associated CReaderDriver object.

    Since this routine runs as a separate thread, it must grab the reader prior
    to passing requests other than wait functions to it.

Arguments:

    pvParameter supplies the value from the CreateThread call.  In this case,
        it's the address of the associated CReaderDriver object.

Return Value:

    Zero - Normal termination
    One - Abnormal termination

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("MonitorReader")

DWORD WINAPI
MonitorReader(
    LPVOID pvParameter)
{
    NEW_THREAD;
    BOOL fAllDone = FALSE;
    BOOL fDeleteWhenDone = FALSE;
    BOOL fHardError;
    BOOL fSts;
    DWORD dwRetLen, dwErr, dwTries, dwWait, dwDrvrErr;
    DWORD dwErrRetry = MONITOR_MAX_TRIES;
    CReader::AvailableState avlState;
    CReaderDriver *pRdr = (CReaderDriver *)pvParameter;
    OVERLAPPED ovrWait;
    CHandleObject hOvrWait(DBGT("Overlapped wait event in MonitorReader"));
    CHandleObject hPowerDownTimer(DBGT("Power Down Timer in MonitorReader"));
#ifdef SCARD_TRACE_ENABLED
    RequestTrace rqTrace;
#endif
#ifdef DBG
    static const LPCTSTR l_pchWait[] = {
        TEXT("internal error"), TEXT("power down"), TEXT("io completion"),
        TEXT("shut down"), TEXT("shut down")
    };
#endif

    try
    {

        //
        // Prep work.
        //

        fSts = SetThreadPriority(
                    pRdr->m_hThread,
                    THREAD_PRIORITY_ABOVE_NORMAL);
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to prioritize reader '%2' monitor thread: %1"),
                GetLastError(),
                pRdr->ReaderName());
        }
        hOvrWait = ovrWait.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!hOvrWait.IsValid())
        {
            dwErr = hOvrWait.GetLastError();
            CalaisError(__SUBROUTINE__, 609, dwErr);
            throw dwErr;
        }
        hPowerDownTimer = CreateWaitableTimer(NULL, FALSE, NULL);
        if (!hPowerDownTimer.IsValid())
        {
            dwErr = hPowerDownTimer.GetLastError();
            CalaisError(__SUBROUTINE__, 608, dwErr);
            throw dwErr;
        }


        //
        // At startup, declare the reader active.
        //

        {
            CLockWrite rwLock(&pRdr->m_rwLock);
            ASSERT(CReader::Inactive == pRdr->m_dwAvailStatus);
            pRdr->SetAvailabilityStatus(CReader::Idle);
        }
        g_phReaderChangeEvent->Signal();


        //
        // Loop watching for card insertion/removals while the service is
        // running.
        //

        while (!fAllDone)
        {
            try
            {

                //
                // Look for a smartcard insertion.
                //

                dwTries = MONITOR_MAX_TRIES;
                for (;;)
                {
#ifdef SCARD_TRACE_ENABLED
                    GetLocalTime(&rqTrace.StartTime);
                    rqTrace.dwProcId = GetCurrentProcessId();
                    rqTrace.dwThreadId = GetCurrentThreadId();
                    rqTrace.hDevice = pRdr->m_hReader;
                    rqTrace.dwIoControlCode = IOCTL_SMARTCARD_IS_PRESENT;
                    rqTrace.nInBuffer = NULL;
                    rqTrace.nInBufferSize = 0;
                    rqTrace.nOutBufferSize = 0;
#endif
                    ASSERT(!pRdr->IsLatchedByMe());
                    fSts = DeviceIoControl(
                                pRdr->m_hReader,
                                IOCTL_SMARTCARD_IS_PRESENT,
                                NULL, 0,
                                NULL, 0,
                                &dwRetLen,
                                &ovrWait);
                    if (!fSts)
                    {
                        BOOL fErrorProcessed;

                        dwErr = dwDrvrErr = GetLastError();
                        do
                        {
                            fErrorProcessed = TRUE;
                            fHardError = FALSE;
                            switch (dwErr)
                            {

                            //
                            // The driver will let us know.
                            //

                            case ERROR_IO_PENDING:
                                dwWait = WaitForAnyObject(
                                                INFINITE,
                                                ovrWait.hEvent,
                                                pRdr->m_hRemoveEvent.Value(),
                                                g_hCalaisShutdown,
                                                NULL);

                                switch (dwWait)
                                {
                                case 1: // I/O Completed
                                {
                                    pRdr->LatchReader(NULL);
                                    fErrorProcessed = FALSE;
                                    fSts = GetOverlappedResult(
                                                pRdr->m_hReader,
                                                &ovrWait,
                                                &dwRetLen,
                                                TRUE);
                                    if (!fSts)
                                        dwErr = dwDrvrErr = GetLastError();
                                    else
                                        dwErr = dwDrvrErr = ERROR_SUCCESS;
                                    pRdr->Unlatch();
                                    break;
                                }

                                case 2: // Shutdown indicator
                                case 3:
                                    fAllDone = TRUE;
                                    dwErr = ERROR_SUCCESS;
                                    dwDrvrErr = SCARD_P_SHUTDOWN;
                                    break;

                                default:
                                    CalaisWarning(
                                        __SUBROUTINE__,
                                        DBGT("Wait for card insertion returned invalid value"));
                                    throw (DWORD)SCARD_F_INTERNAL_ERROR;
                                }
                                break;


                            //
                            // Success.  Continue monitoring for events.
                            //

                            case ERROR_SUCCESS:         // Success after a wait event.
                                break;


                            //
                            // PnP Shutdown errors -- handle them gracefully.
                            //

                            case ERROR_DEVICE_REMOVED:  // PnP Device yanked out of system
                            case ERROR_DEV_NOT_EXIST:
                            case ERROR_INVALID_FUNCTION:
                                fDeleteWhenDone = TRUE;
                                // Fall through intentionally
                            case ERROR_INVALID_HANDLE:  // We must be shutting down.
                            case ERROR_OPERATION_ABORTED:   // PnP Polite shutdown request
                                fAllDone = TRUE;
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader return code takes reader '%2' offline:  %1"),
                                    dwErr,
                                    pRdr->DeviceName());
                                dwErr = ERROR_SUCCESS;
                                break;


                            //
                            // A hard error.  Log it, and declare the device broken.
                            //

                            default:
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader insertion monitor failed wait:  %1"),
                                    dwErr);
                                fHardError = TRUE;
                            }
                        } while (!fErrorProcessed);
                    }
                    else
                        dwErr = dwDrvrErr = ERROR_SUCCESS;
#ifdef SCARD_TRACE_ENABLED
                    {
                        GetLocalTime(&rqTrace.EndTime);
                        rqTrace.dwStatus = dwDrvrErr;
                        rqTrace.nOutBuffer = NULL;
                        rqTrace.nBytesReturned = 0;
                        rqTrace.dwStructLen = sizeof(RequestTrace);

                        LockSection(
                            g_pcsControlLocks[CSLOCK_TRACELOCK],
                            DBGT("Logging a card insertion"));
                        HANDLE hLogFile = INVALID_HANDLE_VALUE;

                        hLogFile = CreateFile(
                                        CalaisString(CALSTR_DRIVERTRACEFILENAME),
                                        GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
                        if (INVALID_HANDLE_VALUE != hLogFile)
                        {
                            DWORD dwLen;
                            dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
                            fSts = WriteFile(
                                        hLogFile,
                                        &rqTrace,
                                        rqTrace.dwStructLen,
                                        &dwLen,
                                        NULL);
                            CloseHandle(hLogFile);
                        }
                    }
#endif
                    if (ERROR_SUCCESS == dwErr)
                        break;
                    if (fHardError)
                    {
                        ASSERT(0 < dwTries);
                        if (0 == --dwTries)
                        {
                            pRdr->SetAvailabilityStatusLocked(CReader::Broken);
                            CalaisError(__SUBROUTINE__, 612, dwErr);
                            throw dwErr;
                        }
                    }
                }
                if (fAllDone)
                    continue;

                {
                    CLockWrite rwLock(&pRdr->m_rwLock);
                    pRdr->m_ActiveState.dwInsertCount += 1;
                    pRdr->m_ActiveState.dwResetCount = 0;
                    avlState = pRdr->m_dwAvailStatus;
                }

                if (CReader::Direct > avlState)
                {
                    try
                    {
                        ASSERT(!pRdr->m_mtxLatch.IsGrabbed());
                        ASSERT(!pRdr->m_mtxGrab.IsGrabbed());
                        CLatchReader latch(pRdr);   // Take reader
                        pRdr->PowerUp();
                    }
                    catch (...) {}
                }
                else
                {
                    if (CReader::Present > pRdr->m_dwAvailStatus)
                        pRdr->SetAvailabilityStatus(CReader::Present);
                }


                //
                // Start the power-down timer.
                //

                fSts = SetWaitableTimer(
                            hPowerDownTimer,
                            &l_ftPowerdownTime,
                            0,
                            NULL,
                            NULL,
                            FALSE);
                if (!fSts)
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Reader Monitor can't request powerdown timeout: %1"),
                        GetLastError());


                //
                // Look for a smartcard removal.
                //

                dwTries = MONITOR_MAX_TRIES;
                for (;;)
                {
#ifdef SCARD_TRACE_ENABLED
                    GetLocalTime(&rqTrace.StartTime);
                    rqTrace.dwProcId = GetCurrentProcessId();
                    rqTrace.dwThreadId = GetCurrentThreadId();
                    rqTrace.hDevice = pRdr->m_hReader;
                    rqTrace.dwIoControlCode = IOCTL_SMARTCARD_IS_ABSENT;
                    rqTrace.nInBuffer = NULL;
                    rqTrace.nInBufferSize = 0;
                    rqTrace.nOutBufferSize = 0;
#endif
                    ASSERT(!pRdr->IsLatchedByMe());

                    fSts = DeviceIoControl(
                                pRdr->m_hReader,
                                IOCTL_SMARTCARD_IS_ABSENT,
                                NULL, 0,
                                NULL, 0,
                                &dwRetLen,
                                &ovrWait);
                    if (!fSts)
                    {
                        BOOL fErrorProcessed;

                        dwErr = dwDrvrErr = GetLastError();
                        do
                        {
                            fErrorProcessed = TRUE;
                            fHardError = FALSE;
                            switch (dwErr)
                            {

                            //
                            // The driver will let us know.
                            //

                            case ERROR_IO_PENDING:
                                dwWait = WaitForAnyObject(
                                                INFINITE,
                                                hPowerDownTimer.Value(),
                                                ovrWait.hEvent,
                                                pRdr->m_hRemoveEvent.Value(),
                                                g_hCalaisShutdown,
                                                NULL);
                                switch (dwWait)
                                {
                                case 1: // Powerdown indicator
                                    if (!pRdr->IsInUse())
                                        pRdr->ReaderPowerDown(NULL);
                                    dwErr = ERROR_IO_PENDING;   // Keep looping
                                    fErrorProcessed = FALSE;
                                    break;

                                case 2: // I/O completed
                                {
                                    pRdr->LatchReader(NULL);
                                    fErrorProcessed = FALSE;
                                    fSts = GetOverlappedResult(
                                                pRdr->m_hReader,
                                                &ovrWait,
                                                &dwRetLen,
                                                TRUE);
                                    if (!fSts)
                                        dwErr = dwDrvrErr = GetLastError();
                                    else
                                        dwErr = ERROR_SUCCESS;
                                    pRdr->Unlatch();
                                    break;
                                }

                                case 3: // Shutdown indicator
                                case 4:
                                    fAllDone = TRUE;
                                    dwErr = ERROR_SUCCESS;
                                    dwDrvrErr = SCARD_P_SHUTDOWN;
                                    break;

                                default:
                                    CalaisWarning(
                                        __SUBROUTINE__,
                                        DBGT("Wait for card removal returned invalid value"));
                                    throw (DWORD)SCARD_F_INTERNAL_ERROR;
                                }
                                break;


                            //
                            // Success.  Continue monitoring for events.
                            //

                            case ERROR_SUCCESS:         // Success after a wait event.
                                break;


                            //
                            // PnP Shutdown errors -- handle them gracefully.
                            //

                            case ERROR_DEVICE_REMOVED:  // PnP Device yanked out of system
                            case ERROR_DEV_NOT_EXIST:
                            case ERROR_INVALID_FUNCTION:
                                fDeleteWhenDone = TRUE;
                                // Fall through intentionally
                            case ERROR_INVALID_HANDLE:  // We're shutting down.
                            case ERROR_OPERATION_ABORTED:   // PnP Polite shutdown request
                                dwErr = ERROR_SUCCESS;
                                fAllDone = TRUE;
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader return code takes reader '%2' offline:  %1"),
                                    dwErr,
                                    pRdr->DeviceName());
                                break;


                            //
                            // A hard error.  Log it, and declare the device broken.
                            //

                            default:
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader removal monitor failed wait:  %1"),
                                    dwErr);
                                fHardError = TRUE;
                            }
                        } while (!fErrorProcessed);
                    }
                    else
                        dwErr = dwDrvrErr = ERROR_SUCCESS;

#ifdef SCARD_TRACE_ENABLED
                    {
                        GetLocalTime(&rqTrace.EndTime);
                        rqTrace.dwStatus = dwDrvrErr;
                        rqTrace.nOutBuffer = NULL;
                        rqTrace.nBytesReturned = 0;
                        rqTrace.dwStructLen = sizeof(RequestTrace);

                        LockSection(
                            g_pcsControlLocks[CSLOCK_TRACELOCK],
                            DBGT("Logging a card removal"));
                        HANDLE hLogFile = INVALID_HANDLE_VALUE;

                        hLogFile = CreateFile(
                                        CalaisString(CALSTR_DRIVERTRACEFILENAME),
                                        GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
                        if (INVALID_HANDLE_VALUE != hLogFile)
                        {
                            DWORD dwLen;
                            dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
                            fSts = WriteFile(
                                        hLogFile,
                                        &rqTrace,
                                        rqTrace.dwStructLen,
                                        &dwLen,
                                        NULL);
                            CloseHandle(hLogFile);
                        }
                    }
#endif
                    if (ERROR_SUCCESS == dwErr)
                        break;
                    if (fHardError)
                    {
                        ASSERT(0 < dwTries);
                        if (0 == --dwTries)
                        {
                            pRdr->SetAvailabilityStatusLocked(CReader::Broken);
                            CalaisError(__SUBROUTINE__, 615, dwErr);
                            throw dwErr;
                        }
                    }
                }
                fSts = CancelWaitableTimer(hPowerDownTimer);
                if (!fSts)
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Reader Monitor can't cancel powerdown timeout: %1"),
                        GetLastError());
                if (fAllDone)
                    continue;

                {
                    CLockWrite rwLock(&pRdr->m_rwLock);
                    pRdr->m_bfCurrentAtr.Reset();
                    pRdr->m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    pRdr->m_ActiveState.dwRemoveCount += 1;
                }
                if (CReader::Direct > pRdr->AvailabilityStatus())
                {
                    pRdr->InvalidateGrabs();
                    pRdr->SetAvailabilityStatusLocked(CReader::Idle);
                }

                dwErrRetry = MONITOR_MAX_TRIES;
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader Monitor '%2' caught processing error: %1"),
                    dwError,
                    pRdr->ReaderName());
                if (fHardError)
                    throw;
                try
                {
                    pRdr->ReaderPowerDown(NULL);
                }
                catch (...) {}
                ASSERT(0 != dwErrRetry);
                if (0 == --dwErrRetry)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error threshold reached, abandoning reader %1."),
                        pRdr->ReaderName());
                    throw;
                }
            }
        }

        CLockWrite rwLock(&pRdr->m_rwLock);
        if (CReader::Closing > pRdr->m_dwAvailStatus)
            pRdr->SetAvailabilityStatus(CReader::Inactive);
    }

    catch (DWORD dwError)
    {
        CalaisError(__SUBROUTINE__, 616, dwError, pRdr->ReaderName());
        pRdr->SetAvailabilityStatusLocked(CReader::Broken);
    }

    catch (...)
    {
        CalaisError(__SUBROUTINE__, 617, pRdr->ReaderName());
        pRdr->SetAvailabilityStatusLocked(CReader::Broken);
    }


    //
    // Cleanup code.
    //

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Reader monitor for '%1' is shutting down."),
        pRdr->ReaderName());
    if (hOvrWait.IsValid())
        hOvrWait.Close();
    if (hPowerDownTimer.IsValid())
        hPowerDownTimer.Close();
    if (fDeleteWhenDone)
    {
        {
            CLockWrite rwLock(&pRdr->m_rwLock);
            pRdr->m_bfCurrentAtr.Reset();
            pRdr->m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            pRdr->m_ActiveState.dwRemoveCount += 1;
            pRdr->m_hThread = NULL;
        }
        CalaisRemoveReader(pRdr->ReaderName());
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\changpin\chpin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPin.cpp
//
//--------------------------------------------------------------------------

// chPin.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "chPin.h"
#include "chPinDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp

BEGIN_MESSAGE_MAP(CChangePinApp, CWinApp)
    //{{AFX_MSG_MAP(CChangePinApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp construction

CChangePinApp::CChangePinApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CChangePinApp object

CChangePinApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp initialization

BOOL CChangePinApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CChangePinDlg dlg;
    m_pMainWnd = &dlg;
    int nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\changpin\chpin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPin.h
//
//--------------------------------------------------------------------------

// ChangePin.h : main header file for the CHANGEPIN application
//

#if !defined(AFX_CHANGEPIN_H__99CC45B5_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
#define AFX_CHANGEPIN_H__99CC45B5_C1C8_11D2_88F3_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp:
// See ChangePin.cpp for the implementation of this class
//

class CChangePinApp : public CWinApp
{
public:
	CChangePinApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangePinApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CChangePinApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHANGEPIN_H__99CC45B5_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\server\dispatch.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    dispatch

Abstract:

    This module implements the Calais Server communication and dispatch
    services.

Author:

    Doug Barlow (dbarlow) 12/3/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <scarderr.h>   // This picks up extra definitions
#include "CalServe.h"
#ifdef DBG
#include <stdio.h>
#include <tchar.h>
#endif

#define DEFAULT_OUT_BUFFER_SPACE 264

// Convert between an interchange handle and an index.
#define H2L(x) ((DWORD)(x))
#define L2H(x) ((INTERCHANGEHANDLE)(x))

#define szMAX_SERVICE_THREADS  TEXT("MaxServiceThreads")

DWORD g_dwDefaultIOMax = DEFAULT_OUT_BUFFER_SPACE;
static CComResponder *l_pcomResponder = NULL;
static HANDLE l_hDispatchThread = NULL;
static DWORD l_dwDispatchThreadId = 0;
static CDynamicArray<CServiceThread> l_rgServers;
static DWORD l_cServiceThreads = 0;

//
// Decrement the number of current service threads
//
// If the CSLOCK_SERVERLOCK is already held by the caller, the 
// fServerLockHeld param should be set to TRUE.
//
void RemoveServiceThread(BOOL fServerLockHeld)
{
    if (FALSE == fServerLockHeld)
    {
        LockSection(
            g_pcsControlLocks[CSLOCK_SERVERLOCK],
            DBGT("Decrementing service thread counter"));

        l_cServiceThreads--;
    }
    else
    {
        l_cServiceThreads--;
    }
}

//
// Determine if the number of current service threads is at the maximum
// allowed value.  If current thread count is below the max, return Success.  
// Otherwise, return an error.
//
// Assumes that the CSLOCK_SERVERLOCK is held by the caller.
//
DWORD AddServiceThread(DWORD dwMaxServiceThreads)
{
    if (l_cServiceThreads >= dwMaxServiceThreads)
        return SCARD_E_SERVER_TOO_BUSY;

    l_cServiceThreads++;

    return ERROR_SUCCESS;
}

//
////////////////////////////////////////////////////////////////////////////////
//
//  Dispach service routines.
//

/*++

DispatchInit:

    This routine establishes communications and kicks off the dispatcher thread.

Arguments:

    None

Return Value:

    TRUE - Success
    FALSE - Error starting

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/3/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DispatchInit")

BOOL
DispatchInit(
    void)
{
    BOOL fReturn = FALSE;
    DWORD dwLastErr;

    try
    {
        l_pcomResponder = new CComResponder;
        if (NULL == l_pcomResponder)
        {
            CalaisError(__SUBROUTINE__, 301);
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        l_pcomResponder->Create(CalaisString(CALSTR_COMMPIPENAME));
        l_hDispatchThread = CreateThread(
                        NULL,   // Not inheritable
                        CALAIS_STACKSIZE,   // Default stack size
                        (LPTHREAD_START_ROUTINE)DispatchMonitor,
                        l_pcomResponder,
                        0,      // Run immediately
                        &l_dwDispatchThreadId);
        if (NULL == l_hDispatchThread)
        {
            dwLastErr = GetLastError();
            CalaisError(__SUBROUTINE__, 302, dwLastErr);
            throw dwLastErr;
        }

        fReturn = TRUE;
    }

    catch (...)
    {
        if (NULL != l_pcomResponder)
        {
            delete l_pcomResponder;
            l_pcomResponder = NULL;
        }
        throw;
    }

    return fReturn;
}


/*++

DispatchTerm:

    This routine stops the dispatcher.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/2/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DispatchTerm")

void
DispatchTerm(
    void)
{
    DWORD dwSts, ix, dwCount;
    CServiceThread *pSvr;
    BOOL fRemaining = TRUE;
    HANDLE hThread; // Temporary handle holder


    //
    // Terminate all the service threads.
    //

    {
        LockSection(
            g_pcsControlLocks[CSLOCK_SERVERLOCK],
            DBGT("Get the count of service threads"));
        dwCount = l_rgServers.Count();
    }
    while (fRemaining)
    {
        fRemaining = FALSE;
        for (ix = dwCount; 0 < ix;)
        {
            {
                LockSection(
                    g_pcsControlLocks[CSLOCK_SERVERLOCK],
                    DBGT("Get the active thread"));
                pSvr = l_rgServers[--ix];
                if (NULL != pSvr)
                {
                    l_rgServers.Set(ix, NULL);
                    hThread = pSvr->m_hThread;
                }
            }
            if (NULL != pSvr)
            {
                if (NULL != hThread)
                {
                    dwSts = WaitForAnObject(hThread, CALAIS_THREAD_TIMEOUT);
                    if (ERROR_SUCCESS != dwSts)
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Leaking a Service Thread: %1"),
                            dwSts);
                }
                fRemaining = TRUE;
            }
        }
    }


    //
    // Terminate the main responder.
    //

    if (NULL != l_hDispatchThread)
    {
        dwSts = WaitForAnObject(l_hDispatchThread, CALAIS_THREAD_TIMEOUT);
        if (ERROR_SUCCESS != dwSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Leaking the Dispatch Thread: %1"),
                dwSts);
        if (!CloseHandle(l_hDispatchThread))
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to close Dispatch Thread Handle: %1"),
                GetLastError());
        l_hDispatchThread = NULL;
    }
    if (NULL != l_pcomResponder)
    {
        delete l_pcomResponder;
        l_pcomResponder = NULL;
    }
}

/*++

DispatchMonitor:

    This is the main code for monitoring incoming communication connection
    requests.

Arguments:

    pvParam supplies the parameter from the CreateThread call.  In this case,
        it's the address of the CComResponder object to monitor.

Return Value:

    Zero

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/24/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DispatchMonitor")

DWORD WINAPI
DispatchMonitor(
    LPVOID pvParameter)
{
    NEW_THREAD;
    BOOL fDone = FALSE;
    CComResponder *pcomResponder = (CComResponder *)pvParameter;
    CComChannel *pcomChannel = NULL;
    CServiceThread *pService = NULL;
    DWORD dwIndex = 0;
    DWORD dwSts = ERROR_SUCCESS;
    BOOL fIncrementedServiceThreads = FALSE;
    DWORD dwMaxServiceThreads = 0;
    HKEY hKey = 0;
    DWORD cbData = 0;

    // Find the maximum number of service threads allowed; look in the 
    // Calais registry.
    dwSts = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        SCARD_REG_SCARD,
        0,
        KEY_QUERY_VALUE,
        &hKey);

    if (ERROR_SUCCESS != dwSts)
        return dwSts;

    cbData = sizeof(dwMaxServiceThreads);
    dwSts = RegQueryValueEx(
        hKey,
        szMAX_SERVICE_THREADS,
        NULL,
        NULL,
        (PBYTE) &dwMaxServiceThreads, 
        &cbData);

    if (ERROR_SUCCESS != dwSts)
    {
        RegCloseKey(hKey);
        return dwSts;
    }

    do
    {

        // Reset this flag to begin the loop
        fIncrementedServiceThreads = FALSE;

        //
        // Look for an incoming connection.
        //

        try
        {
            pcomChannel = pcomResponder->Listen();
        }
        catch (DWORD dwError)
        {
            if (SCARD_P_SHUTDOWN == dwError)
                fDone = TRUE;   // Stop service request.
            else
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Error listening for an incoming connect request: %1"),
                    dwError);
            continue;
        }
        catch (...)
        {
            CalaisError(__SUBROUTINE__, 303);
            fDone = TRUE;       // Shut down, we're insane.
            continue;
        }


        //
        // Connection request established, pass off to service thread.
        //

        try
        {
            LockSection(
                g_pcsControlLocks[CSLOCK_SERVERLOCK],
                DBGT("Find a service thread slot"));
            for (dwIndex = 0; NULL != l_rgServers[dwIndex]; dwIndex += 1);
                // empty body.
            l_rgServers.Set(dwIndex, NULL);   // Make sure we can create it.

            //
            // Prevent callers from opening too many simultaneous service 
            // threads.
            //

            dwSts = AddServiceThread(dwMaxServiceThreads);
            if (ERROR_SUCCESS != dwSts)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Maximum number of service threads exceeded: %1"),
                    dwSts);
                throw dwSts;
            }

            fIncrementedServiceThreads = TRUE;

            pService = new CServiceThread(dwIndex);
            if (NULL == pService)
            {
                CalaisError(__SUBROUTINE__, 307);
                throw (DWORD)SCARD_E_NO_MEMORY;
            }
            pService->Watch(pcomChannel);
            l_rgServers.Set(dwIndex, pService);
            pcomChannel = NULL;
            pService = NULL;

        }

        catch ( ... )
        {
            if (fIncrementedServiceThreads)
            {
                // If thread was created, delete it.  Destructor calls RemoveServiceThread
                if (NULL != pService)
                {
                    delete pService;
                    pService = NULL;
                }
                else
                    RemoveServiceThread(FALSE);
            }
            if (NULL != pcomChannel)
            {
                delete pcomChannel;
                pcomChannel = NULL;
            }
        }
        
    } while (!fDone);

    if (hKey)
        RegCloseKey(hKey);

    return 0;
}

//
// Determines if the named pipe caller should be allowed to be serviced by
// the resource manager.
//
// Assumes that the named pipe caller is already being impersonated.
//
DWORD CheckCallerPrivilege(void)
{
    DWORD dwSts = ERROR_SUCCESS;
    HANDLE hToken = NULL;
    DWORD dwCallerSessionId = 0;
    DWORD cbSize = 0;
    BOOL fIsMember = FALSE;
    PSERVICE_THREAD_SECURITY_INFO pSecurityInfo = 
        GetServiceThreadSecurityInfo();

    if (! OpenThreadToken(
        GetCurrentThread(),
        TOKEN_QUERY,
        TRUE,
        &hToken))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    // Get the caller's session Id
    if (! GetTokenInformation(
        hToken,
        TokenSessionId,
        (PVOID) &dwCallerSessionId,
        sizeof(dwCallerSessionId),
        &cbSize))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    if (dwCallerSessionId != USER_SHARED_DATA->ActiveConsoleId)
    {
        //
        // The caller's session is not the same as the active console session.
        // However, if the caller is a system service and someone is currently
        // remotely connected to the console session, then we don't want to
        // block the service from using the server pipe.
        //

        // Check if member of Local System
        if (! CheckTokenMembership(
            hToken,
            pSecurityInfo->pSystemSid,
            &fIsMember))
        {
            dwSts = GetLastError();
            goto Ret;
        }

        if (fIsMember)
            goto Ret;

        // Not a member of Local System, so check if member of
        // Service.
        if (! CheckTokenMembership(
            hToken,
            pSecurityInfo->pServiceSid,
            &fIsMember))
        {
            dwSts = GetLastError();
            goto Ret;
        }

        if (FALSE == fIsMember)
            dwSts = ERROR_ACCESS_DENIED;
    }

Ret:
    if (hToken)
        CloseHandle(hToken);

    return dwSts;
}

/*++

ServiceMonitor:

    This is the main code for monitoring existing connections for requests for
    service, and dispatching the requests.

Arguments:

    pvParam supplies the parameter from the CreateThread call.  In this case,
        it's the address of the controlling CServiceThread object.

Return Value:

    Zero

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/24/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ServiceMonitor")

extern "C" DWORD WINAPI
ServiceMonitor(
    LPVOID pvParameter)
{
    NEW_THREAD;
    CServiceThread *pSvc = (CServiceThread *)pvParameter;
    CComObject *pCom = NULL;
    BOOL fDone = FALSE;
    BOOL fSts;
    DWORD dwSts;
    CComObject::COMMAND_ID cid;


    //
    // Establish the connection.
    //

#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Context Create (TID = %1)"),
        szTid);
    try
    {
        CComChannel::CONNECT_REQMSG crq;
        CComChannel::CONNECT_RSPMSG crsp;
        CComChannel *pChannel = pSvc->m_pcomChannel;

        pChannel->Receive(&crq, sizeof(crq));


        //
        // Be the caller, just in case of funny business.
        //

        fSts = ImpersonateNamedPipeClient(pChannel->m_hPipe);
        if (!fSts)
        {
            dwSts = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Context TID=%2 Failed to impersonate caller: %1"),
                dwSts,
                szTid);
            throw dwSts;
        }

        //
        // Determine if this caller is allowed to talk to us
        //

        dwSts = CheckCallerPrivilege();

        if (ERROR_SUCCESS != dwSts)
            throw dwSts;

        //
        // Verify the connect request information.
        //

        if (0 != crq.dwSync)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder Context TID=%1 got invalid sync data on connection pipe"),
                szTid);
            throw (DWORD)SCARD_F_COMM_ERROR;
        }

        if (CALAIS_COMM_CURRENT != crq.dwVersion)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder Context TID=%1 got invalid connect verion from connection pipe."),
                szTid);
            throw (DWORD)SCARD_F_COMM_ERROR;
        }


        //
        // Confirm the connect request.
        //

        crsp.dwStatus = SCARD_S_SUCCESS;
        crsp.dwVersion = CALAIS_COMM_CURRENT;
        dwSts = pChannel->Send(&crsp, sizeof(crsp));
        if (ERROR_SUCCESS != dwSts)
            fDone = TRUE;
    }
    catch (...)
    {
        fDone = TRUE;
    }


    //
    // Loop for as long as there are services to perform.
    //

    while (!fDone)
    {
        ASSERT(NULL == pCom);
        try
        {
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("TID=%1: Waiting for request..."),
                szTid);
            pCom = CComObject::ReceiveComObject(pSvc->m_pcomChannel);
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("TID=%1: ...Processing request"),
                szTid);
            cid = pCom->Type();
            try
            {
                switch (cid)
                {
                case CComObject::EstablishContext_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Establish Context Start..."),
                        szTid);
                    pSvc->DoEstablishContext(
                            (ComEstablishContext *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Establish Context Complete"),
                        szTid);
                    break;

                case CComObject::IsValidContext_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Is Valid Context Start..."),
                        szTid);
                    pSvc->DoIsValidContext((ComIsValidContext *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Is Valid Context Complete"),
                        szTid);
                    break;

                case CComObject::ReleaseContext_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Release Context Start..."),
                        szTid);
                    pSvc->DoReleaseContext((ComReleaseContext *)pCom);
                    fDone = TRUE;
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Release Context Complete"),
                        szTid);
                    break;

                case CComObject::LocateCards_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Locate Cards Start..."),
                        szTid);
                    pSvc->DoLocateCards((ComLocateCards *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Locate Cards Complete"),
                        szTid);
                    break;

                case CComObject::GetStatusChange_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Get Status Change Start..."),
                        szTid);
                    pSvc->DoGetStatusChange((ComGetStatusChange *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Get Status Change Complete"),
                        szTid);
                    break;

                case CComObject::ListReaders_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: List Readers Start..."),
                        szTid);
                    pSvc->DoListReaders((ComListReaders *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... List Readers Complete"),
                        szTid);
                    break;

                case CComObject::Connect_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Connect Start..."),
                        szTid);
                    pSvc->DoConnect((ComConnect *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Connect Complete"),
                        szTid);
                    break;

                case CComObject::Reconnect_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Reconnect Start..."),
                        szTid);
                    pSvc->DoReconnect((ComReconnect *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Reconnect Complete"),
                        szTid);
                    break;

                case CComObject::Disconnect_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Disconnect Start..."),
                        szTid);
                    pSvc->DoDisconnect((ComDisconnect *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Disconnect Complete"),
                        szTid);
                    break;

                case CComObject::BeginTransaction_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Begin Transaction Start..."),
                        szTid);
                    pSvc->DoBeginTransaction((ComBeginTransaction *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Begin Transaction Complete"),
                        szTid);
                    break;

                case CComObject::EndTransaction_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: End Transaction Start..."),
                        szTid);
                    pSvc->DoEndTransaction((ComEndTransaction *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... End Transaction Complete"),
                        szTid);
                    break;

                case CComObject::Status_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Status Request Start..."),
                        szTid);
                    pSvc->DoStatus((ComStatus *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Status Request Complete"),
                        szTid);
                    break;

                case CComObject::Transmit_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Transmit Start..."),
                        szTid);
                    pSvc->DoTransmit((ComTransmit *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Transmit Complete"),
                        szTid);
                    break;

                case CComObject::Control_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Control Start..."),
                        szTid);
                    pSvc->DoControl((ComControl *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Control Complete"),
                        szTid);
                    break;

                case CComObject::GetAttrib_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Get Attribute Start..."),
                        szTid);
                    pSvc->DoGetAttrib((ComGetAttrib *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Get Attribute Complete"),
                        szTid);
                    break;

                case CComObject::SetAttrib_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Set Attribute Start..."),
                        szTid);
                    pSvc->DoSetAttrib((ComSetAttrib *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Set Attribute Complete"),
                        szTid);
                    break;

                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Service Monitor received invalid request"));
                    throw (DWORD)SCARD_F_COMM_ERROR;
                }

                dwSts = pCom->Send(pSvc->m_pcomChannel);
                delete pCom;
                pCom = NULL;
                if (ERROR_SUCCESS != dwSts)
                    fDone = TRUE;
            }

            catch (DWORD dwError)
            {
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("TID=%2: Caught error return: %1"),
                    dwError,
                    szTid);
                CComObject::CObjGeneric_response rsp;

                rsp.dwCommandId = cid + 1;
                rsp.dwTotalLength =
                    rsp.dwDataOffset =
                        sizeof(CComObject::CObjGeneric_response);
                rsp.dwStatus = dwError;
                dwSts = pSvc->m_pcomChannel->Send(&rsp, sizeof(rsp));
                if (ERROR_SUCCESS != dwSts)
                    fDone = TRUE;
#ifdef DBG
                WriteApiLog(&rsp, sizeof(rsp));
#endif
                if (NULL != pCom)
                {
                    delete pCom;
                    pCom = NULL;
                }
            }

            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Responder TID=%1: Caught exception!"),
                    szTid);
                CComObject::CObjGeneric_response rsp;

                rsp.dwCommandId = cid + 1;
                rsp.dwTotalLength =
                    rsp.dwDataOffset =
                        sizeof(CComObject::CObjGeneric_response);
                rsp.dwStatus = SCARD_F_UNKNOWN_ERROR;
                dwSts = pSvc->m_pcomChannel->Send(&rsp, sizeof(rsp));
                if (ERROR_SUCCESS != dwSts)
                    fDone = TRUE;
#ifdef DBG
                WriteApiLog(&rsp, sizeof(rsp));
#endif
                if (NULL != pCom)
                {
                    delete pCom;
                    pCom = NULL;
                }
            }
        }

        catch (DWORD dwError)
        {
            switch (dwError)
            {
            case ERROR_NO_DATA:
            case ERROR_BROKEN_PIPE:
            case SCARD_P_SHUTDOWN:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Service thread TID=%2 terminating due to unexpected error:  %1"),
                    dwError,
                    szTid);
            }
            if (NULL != pCom)
                delete pCom;
            fDone = TRUE;
        }

        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Service thread TID=%1 terminating due to unexpected exception"),
                szTid);
            if (NULL != pCom)
                delete pCom;
            fDone = TRUE;
        }
#ifdef DBG
        CReaderReference *pRdrRef;
        CReader * pRdr;

        for (DWORD dwIndex = pSvc->m_rgpReaders.Count(); 0 < dwIndex;)
        {
            dwIndex -= 1;
            pRdrRef = pSvc->m_rgpReaders[dwIndex];
            if (NULL != pRdrRef)
            {
                pRdr = pRdrRef->Reader();
                if (NULL != pRdr)
                {
                    ASSERT(!pRdr->IsLatchedByMe());
                }
            }
        }
#endif
    }

    delete pSvc;
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Context Close, TID = %1"),
        szTid);
    return 0;
}


//
//==============================================================================
//
//  CServiceThread
//

/*++

CServiceThread:

    This is the constructor for a CServiceThread.  It merely initializes the
    object.  The Watch method kicks off the thread.  Note this is protected, so
    that only the Dispatch Monitor may start a Service Thread.

Arguments:

    dwServerIndex supplies a cross link into the l_rgServers array, so that this
        object can clean up after itself.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::CServiceThread")

CServiceThread::CServiceThread(
    DWORD dwServerIndex)
:   m_rgpReaders(),
    m_hThread(DBGT("CServiceThread Worker Thread")),
    m_hCancelEvent(DBGT("CServiceThread Cancel event")),
    m_hExitEvent(DBGT("CServiceThread Exit event"))
{
    m_dwServerIndex = dwServerIndex;
    m_pcomChannel = NULL;
    m_dwThreadId = 0;
}


/*++

~CServiceThread:

    This is the destructor for a CServiceThread.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::~CServiceThread")

CServiceThread::~CServiceThread()
{
    DWORD dwIndex, dwSts;
    BOOL fSts;
    CReaderReference *pRdrRef;


    //
    // Take us out of the service thread list.
    //

    {
        LockSection(
            g_pcsControlLocks[CSLOCK_SERVERLOCK],
            DBGT("Removing deleted service thread from the worker thread list"));
        l_rgServers.Set(m_dwServerIndex, NULL);
        RemoveServiceThread(TRUE);
    }


    m_hThread.Close();


    //
    // Break any outstanding Connections left open on the thread.
    //

    for (dwIndex = m_rgpReaders.Count(); dwIndex > 0;)
    {
        dwIndex -= 1;
        pRdrRef = m_rgpReaders[dwIndex];
        if (NULL != pRdrRef)
        {
            CReader *pRdr = pRdrRef->Reader();
            ASSERT(NULL != pRdr);
            try
            {
                pRdr->Disconnect(
                        pRdrRef->ActiveState(),
                        SCARD_RESET_CARD,
                        &dwSts);
            }
            catch (...) {}
            m_rgpReaders.Set(dwIndex, NULL);
            ASSERT(!pRdr->IsLatchedBy(m_dwThreadId));
            ASSERT(!pRdr->IsGrabbedBy(m_dwThreadId));
            CalaisReleaseReader(&pRdrRef);
        }
    }


    //
    // Final resource cleanup.
    //

    if (NULL != m_pcomChannel)
    {
        delete m_pcomChannel;
        m_pcomChannel = NULL;
    }
    if (m_hCancelEvent.IsValid())
        m_hCancelEvent.Close();
    if (m_hExitEvent.IsValid())
        m_hExitEvent.Close();
}


/*++

Watch:

    This method kicks off the service thread for this object.

Arguments:

    pcomChannel supplies the communications channel to service.

Return Value:

    None

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::Watch")

void
CServiceThread::Watch(
    CComChannel *pcomChannel)
{
    DWORD dwLastErr;

    ASSERT(!m_hThread.IsValid());
    ASSERT(0 == m_dwThreadId);

    m_hThread = CreateThread(
                    NULL,   // Not inheritable
                    CALAIS_STACKSIZE,   // Default stack size
                    (LPTHREAD_START_ROUTINE)ServiceMonitor,
                    this,
                    0,      // Run immediately
                    &m_dwThreadId);
    if (!m_hThread.IsValid())
    {
        dwLastErr = m_hThread.GetLastError();
        CalaisError(__SUBROUTINE__, 304, dwLastErr);
        throw dwLastErr;
    }

    // Set this member pointer only if CreateThread succeeded.
    m_pcomChannel = pcomChannel;
}


/*++

DoEstablishContext:

    This method performs the EstablishContext service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoEstablishContext")

void
CServiceThread::DoEstablishContext(
    ComEstablishContext *pCom)
{
    static const TCHAR szEmptyString[] = TEXT("");
    BOOL fSts;
    CHandleObject hCancelEvent(DBGT("Cancel Event in DoEstablishContext"));
    CHandleObject hTargetProc(DBGT("Target Process in DoEstablishContext"));
    BOOL fNewCancelEvent = FALSE;
    HANDLE h = NULL;
    CSecurityDescriptor acl;

    try
    {
        DWORD dwSts;
        ComEstablishContext::CObjEstablishContext_request *pReq
            = (ComEstablishContext::CObjEstablishContext_request *)pCom->Request();


        //
        // The caller must supply a cancel event; see if we can use it.
        //

        if (INVALID_HANDLE_VALUE != (HANDLE) pReq->hptrCancelEvent)
        {

            //
            // Get a handle to the caller so that we can tell if it exits.
            //

            hTargetProc = OpenProcess(
                            PROCESS_DUP_HANDLE | SYNCHRONIZE, // access flag
                            FALSE,              // handle inheritance flag
                            pReq->dwProcId);    // process identifier
            if (!hTargetProc.IsValid())
            {
                dwSts = hTargetProc.GetLastError();

                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Comm Responder can't duplicate handles from received procId:  %1"),
                    dwSts);

                if (ERROR_ACCESS_DENIED != dwSts)
                    throw dwSts;

                //
                // We failed to acquire a handle to the calling process with 
                // sufficient access rights.  This is probably due to the 
                // caller being local system, but calling us while 
                // impersonating.  
                //
                // To recover, create a new event and ACL it for the caller.
                // Send the new event handle back for the caller to duplicate.
                //

                acl.InitializeFromThreadToken(FALSE, FALSE);
                acl.AllowOwner(
                    EVENT_ALL_ACCESS);
                acl.Allow(
                    &acl.SID_LocalService,
                    EVENT_ALL_ACCESS);

                hCancelEvent = CreateEvent(
                                    acl,            // pointer to security attributes
                                    TRUE,           // flag for manual-reset event
                                    FALSE,          // flag for initial state
                                    NULL);          // pointer to event-object name
                if (!hCancelEvent.IsValid())
                {
                    dwSts = hCancelEvent.GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Responder can't create cancel event:  %1"),
                        dwSts);
                    throw dwSts;
                }

                fNewCancelEvent = TRUE;
            }
            else
            {
                fSts = DuplicateHandle(
                            hTargetProc,        // handle to process
                            (HANDLE) pReq->hptrCancelEvent, // handle to duplicate
                            GetCurrentProcess(),// handle to process to duplicate to
                            &h,                 // pointer to duplicate handle
                            SYNCHRONIZE,        // access for duplicate handle
                            FALSE,              // handle inheritance flag
                            0);                 // optional actions
                if (!fSts)
                {
                    dwSts = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Responder could not dup offered cancel event:  %1"),
                        dwSts);
                    ASSERT(NULL == h);

                    throw dwSts;
                }

                hCancelEvent = h;
            }
        }
        else
        {
            // We require a valid Cancel Event from the caller.
            throw INVALID_HANDLE_VALUE;
        }

        m_hExitEvent = hTargetProc.Relinquish();
        m_hCancelEvent = hCancelEvent.Relinquish();
        ComEstablishContext::CObjEstablishContext_response *pRsp
            = (ComEstablishContext::CObjEstablishContext_response *)pCom->InitResponse(0);

        if (fNewCancelEvent)
        {
            pRsp->dwProcId = GetCurrentProcessId();
            pRsp->hptrCancelEvent = (HANDLE_PTR) m_hCancelEvent.Value();
        }
        else
        {
            pRsp->dwProcId = 0;
            pRsp->hptrCancelEvent = NULL;
        }

        pRsp->dwStatus = SCARD_S_SUCCESS;
    }

    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to establish context"));
        if (hCancelEvent.IsValid())
            hCancelEvent.Close();
        if (hTargetProc.IsValid())
            hTargetProc.Close();
        throw;
    }
}


/*++

DoReleaseContext:

    This method performs the ReleaseContext service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoReleaseContext")

void
CServiceThread::DoReleaseContext(
    ComReleaseContext *pCom)
{
    ComReleaseContext::CObjReleaseContext_request *pReq =
        (ComReleaseContext::CObjReleaseContext_request *)pCom->Request();
    ComReleaseContext::CObjReleaseContext_response *pRsp =
        (ComReleaseContext::CObjReleaseContext_response *)pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoIsValidContext:

    This method performs the IsValidContext service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoIsValidContext")

void
CServiceThread::DoIsValidContext(
    ComIsValidContext *pCom)
{
    ComIsValidContext::CObjIsValidContext_request *pReq =
        (ComIsValidContext::CObjIsValidContext_request *)pCom->Request();
    ComIsValidContext::CObjIsValidContext_response *pRsp =
        (ComIsValidContext::CObjIsValidContext_response *)pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoListReaders:

    This method performs the ListReaders service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 5/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoListReaders")

void
CServiceThread::DoListReaders(
    ComListReaders *pCom)
{
    CReaderReference *pRdrRef;
    CReader *pReader;
    CBuffer bfReaderStates;
    LPBOOL rgfReaderStates;
    DWORD dwReaderCount, dwActiveReaderCount;
    LPCTSTR szReader, mszQueryReaders;
    ComListReaders::CObjListReaders_request *pReq =
        (ComListReaders::CObjListReaders_request *)pCom->Request();

    mszQueryReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
    dwReaderCount = MStringCount(mszQueryReaders);
    ComListReaders::CObjListReaders_response *pRsp =
        (ComListReaders::CObjListReaders_response *)pCom->
            InitResponse(dwReaderCount * sizeof(BOOL));
    rgfReaderStates = (LPBOOL)bfReaderStates.Resize(
                                    dwReaderCount * sizeof(BOOL));

    dwReaderCount = dwActiveReaderCount = 0;
    for (szReader = FirstString(mszQueryReaders);
         NULL != szReader;
         szReader = NextString(szReader))
     {
        rgfReaderStates[dwReaderCount] = FALSE;
        try
        {
            pRdrRef = NULL;
            pRdrRef = CalaisLockReader(szReader);
            ASSERT(NULL != pRdrRef);
            pReader = pRdrRef->Reader();
            ASSERT(NULL != pReader);
            if (CReader::Closing > (BYTE)pReader->AvailabilityStatus())
            {
                rgfReaderStates[dwReaderCount] = TRUE;
                dwActiveReaderCount += 1;
            }
            CalaisReleaseReader(&pRdrRef);
        }
        catch (DWORD dwError)
        {
            if (NULL != pRdrRef)
                CalaisReleaseReader(&pRdrRef);
            if (SCARD_E_UNKNOWN_READER != dwError)
                throw;
        }
        catch (...)
        {
            if (NULL != pRdrRef)
                CalaisReleaseReader(&pRdrRef);
            throw;
        }
        dwReaderCount += 1;
    }

    if (0 == dwActiveReaderCount)
        throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
    ASSERT(dwReaderCount == bfReaderStates.Length() / sizeof(BOOL));
    pRsp = (ComListReaders::CObjListReaders_response *)
        pCom->Append(
            pRsp->dscReaders,
            bfReaderStates.Access(),
            bfReaderStates.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoLocateCards:

    This method performs the LocateCards service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoLocateCards")

void
CServiceThread::DoLocateCards(
    ComLocateCards *pCom)
{
    DWORD dwStateCount;
    DWORD cbTotAtrs, cbTotMasks;
    CBuffer bfAtrs, bfAtr;
    BYTE bAtrLen;
    ComLocateCards::CObjLocateCards_request *pReq =
        (ComLocateCards::CObjLocateCards_request *)pCom->Request();
    ComLocateCards::CObjLocateCards_response *pRsp;
    CDynamicArray<const BYTE> rgbAtrs;
    CDynamicArray<const BYTE> rgbMasks;
    CDynamicArray<const BYTE> rgbAtrLens;
    DWORD cbLength, dwAtrLen;
    DWORD dwIndex;


    //
    // Pull in and parse the command parameters.
    //

    LPBYTE pbAtrs = (LPBYTE)pCom->Parse(pReq->dscAtrs, &cbTotAtrs);
    LPCBYTE pbMasks = (LPCBYTE)pCom->Parse(pReq->dscAtrMasks, &cbTotMasks);
    LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(
                                pReq->dscReaderStates,
                                &dwStateCount);
    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    if ((0 == cbTotAtrs)
        || (0 == cbTotMasks)
        || (0 == dwStateCount)
        || (0 != dwStateCount % sizeof(DWORD)))
        throw (DWORD)SCARD_E_INVALID_VALUE;
    dwStateCount /= sizeof(DWORD);


    //
    // Extract the ATRs and Masks.
    //

    while (0 < cbTotAtrs)
    {
        rgbAtrLens.Add(pbAtrs);
        cbLength = *pbAtrs++;
        if (cbLength > cbTotAtrs)
            throw (DWORD)SCARD_F_COMM_ERROR;
        dwAtrLen = cbLength;
        if (33 < dwAtrLen)
            throw (DWORD)SCARD_E_INVALID_ATR;
        cbLength = *pbMasks++;
        if (cbLength > cbTotMasks)
            throw (DWORD)SCARD_F_COMM_ERROR;
        if (0 == cbLength)
            rgbMasks.Add(NULL);
        else
        {
            if (dwAtrLen != cbLength)
                throw (DWORD)SCARD_E_INVALID_ATR;
            for (dwIndex = 0; dwIndex < dwAtrLen; dwIndex += 1)
                pbAtrs[dwIndex] &= pbMasks[dwIndex];
            rgbMasks.Add(pbMasks);
        }
        rgbAtrs.Add(pbAtrs);
        cbTotAtrs -= dwAtrLen + 1;
        pbAtrs += dwAtrLen;

        cbTotMasks -= cbLength + 1;
        pbMasks += cbLength;
    }
    if (0 != cbTotMasks)
        throw (DWORD)SCARD_F_COMM_ERROR;


    //
    // Look for the card.
    //

    CReaderReference *pRdrRef = NULL;
    LPCTSTR szReader;
    DWORD dwRdrStatus;
    DWORD dwRdrCount;
    DWORD ix;
    CReader::AvailableState avlState;
    WORD wActivityCount = 0;

    dwRdrCount = 0;
    for (dwIndex = 0, szReader = FirstString(mszReaders);
         dwIndex < dwStateCount;
         dwIndex += 1, szReader = NextString(szReader))
    {

        //
        // Make sure we have something to do.
        //

        if (0 != (rgdwStates[dwIndex] & SCARD_STATE_IGNORE))
        {
            rgdwStates[dwIndex] = SCARD_STATE_IGNORE;
            bAtrLen = 0;
            bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));   // No ATR.
            continue;
        }


        //
        // Look for the named reader device and get its state.
        //

        try
        {
            CReader *pReader = NULL;
            try
            {
                pRdrRef = CalaisLockReader(szReader);
                ASSERT(NULL != pRdrRef);
                pReader = pRdrRef->Reader();
                ASSERT(NULL != pReader);
            }
            catch (...)
            {
                pRdrRef = NULL;
            }

            if (NULL == pRdrRef)
            {
                rgdwStates[dwIndex] = SCARD_STATE_UNKNOWN
                    | SCARD_STATE_CHANGED
                    | SCARD_STATE_IGNORE;
                bAtrLen = 0;
                bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));   // No ATR.
                continue;
            }
            dwRdrCount += 1;

            avlState = pReader->AvailabilityStatus();
            wActivityCount = pReader->ActivityHash();
            switch (avlState)
            {
            case CReader::Unresponsive:
            case CReader::Unsupported:
                dwRdrStatus = SCARD_STATE_PRESENT | SCARD_STATE_MUTE;
                break;
            case CReader::Idle:
                dwRdrStatus = SCARD_STATE_EMPTY;
                break;
            case CReader::Present:
                dwRdrStatus = SCARD_STATE_PRESENT | SCARD_STATE_UNPOWERED;
                break;
            case CReader::Ready:
                dwRdrStatus = SCARD_STATE_PRESENT;
                break;
            case CReader::Shared:
                dwRdrStatus = SCARD_STATE_PRESENT | SCARD_STATE_INUSE;
                break;
            case CReader::Exclusive:
                dwRdrStatus = SCARD_STATE_PRESENT
                              | SCARD_STATE_INUSE
                              | SCARD_STATE_EXCLUSIVE;
                break;
            case CReader::Closing:
            case CReader::Broken:
            case CReader::Inactive:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Locate sees reader in unavailable state"));
                dwRdrStatus = SCARD_STATE_UNAVAILABLE
                              | SCARD_STATE_IGNORE;
                wActivityCount = 0;
                break;
            case CReader::Direct:
                dwRdrStatus = SCARD_STATE_UNAVAILABLE;
                break;
            case CReader::Undefined:
                dwRdrStatus = SCARD_STATE_UNKNOWN
                              | SCARD_STATE_IGNORE;
                wActivityCount = 0;
                break;
            default:
                CalaisError(__SUBROUTINE__, 305);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }


            //
            // Return the ATR, if any.
            //

            pReader->Atr(bfAtr);
            CalaisReleaseReader(&pRdrRef);
            // pReader = NULL;
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Locate Cards received an unexpected exception"));
            CalaisReleaseReader(&pRdrRef);
            throw;
        }

        ASSERT(33 >= bfAtr.Length());
        bAtrLen = (BYTE)bfAtr.Length();
        bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));
        bfAtrs.Append(bfAtr.Access(), bfAtr.Length());


        //
        // See if the ATR matches.
        //

        if (SCARD_STATE_PRESENT
            == (dwRdrStatus & (SCARD_STATE_PRESENT | SCARD_STATE_MUTE)))
        {
            ASSERT(2 <= bfAtr.Length());
            for (ix = 0; ix < rgbAtrs.Count(); ix += 1)
            {
                cbLength = *rgbAtrLens[ix];
                if (AtrCompare(bfAtr, rgbAtrs[ix], rgbMasks[ix], cbLength))
                {
                    dwRdrStatus |= SCARD_STATE_ATRMATCH;
                    break;
                }
            }
        }


        //
        // See if that's what the user expects.
        //

        if (dwRdrStatus != (rgdwStates[dwIndex] & (
            SCARD_STATE_UNKNOWN
            | SCARD_STATE_UNAVAILABLE
            | SCARD_STATE_EMPTY
            | SCARD_STATE_PRESENT
            | SCARD_STATE_ATRMATCH
            | SCARD_STATE_EXCLUSIVE
            | SCARD_STATE_INUSE)))
            dwRdrStatus |= SCARD_STATE_CHANGED;


        //
        // Report back the status.
        //

        dwRdrStatus += (DWORD)(wActivityCount) << (sizeof(WORD) * 8);
        rgdwStates[dwIndex] = dwRdrStatus;
    }


    //
    // Report back to the caller.
    //

    if (0 == dwRdrCount)
        throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
    pRsp = pCom->InitResponse(
            dwStateCount + bfAtrs.Length() + 2 * sizeof(DWORD));
    pRsp = (ComLocateCards::CObjLocateCards_response *)
            pCom->Append(
                pRsp->dscReaderStates,
                (LPCBYTE)rgdwStates,
                dwStateCount * sizeof(DWORD));
    pRsp = (ComLocateCards::CObjLocateCards_response *)
            pCom->Append(
                pRsp->dscAtrs,
                bfAtrs.Access(),
                bfAtrs.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoGetStatusChange:

    This method performs the GetStatusChange service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoGetStatusChange")

void
CServiceThread::DoGetStatusChange(
    ComGetStatusChange *pCom)
{
#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    DWORD dwStateCount;
    DWORD dwRdrCount;
    BOOL fPnPNotify = FALSE;
    CBuffer bfAtrs, bfAtr;
    BYTE bAtrLen;
    CReaderReference *pRdrRef = NULL;
    CDynamicArray<CReaderReference> rgpReaders;
    CDynamicArray<void> rgpvWaitHandles;

    ComGetStatusChange::CObjGetStatusChange_request *pReq =
        (ComGetStatusChange::CObjGetStatusChange_request *)pCom->Request();
    LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(
                                pReq->dscReaderStates,
                                &dwStateCount);
    ComGetStatusChange::CObjGetStatusChange_response *pRsp;

    //
    // Pull in and parse the command parameters.
    //

    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    if ((0 == dwStateCount)
        || (0 != dwStateCount % sizeof(DWORD)))
        throw (DWORD)SCARD_E_INVALID_VALUE;
    dwStateCount /= sizeof(DWORD);

    //
    // Scan for Changes.
    //

    for (;;)
    {
        LPCTSTR szReader;
        DWORD dwIndex, dwJ;
        DWORD dwRdrStatus;
        BOOL fChangeDetected = FALSE;
        HANDLE hChangeEvent = NULL; // Temporary storage, never closed.
        CReader *pReader = NULL;
        CReader::AvailableState avlState;
        WORD wActivityCount = 0;

        try
        {

            //
            // Compare the statuses.
            //

            dwRdrCount = 0;
            bfAtrs.Reset();
            rgpvWaitHandles.Empty();
            for (dwIndex = 0, szReader = FirstString(mszReaders);
                 dwIndex < dwStateCount;
                 dwIndex += 1, szReader = NextString(szReader))
            {

                //
                // Make sure we have something to do.
                //

                if (0 != (rgdwStates[dwIndex] & SCARD_STATE_IGNORE))
                {
                    bAtrLen = 0;
                    bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));   // No ATR.
                    rgdwStates[dwIndex] = SCARD_STATE_IGNORE;
                    continue;
                }


                //
                // Look for the named reader device and get its state.
                //

                if (NULL == rgpReaders[dwIndex])
                {
                    try
                    {
                        pRdrRef = CalaisLockReader(szReader);
                        ASSERT(NULL != pRdrRef);
                        pReader = pRdrRef->Reader();
                        ASSERT(NULL != pReader);
                    }
                    catch (...)
                    {
                        pRdrRef = NULL;
                    }

                    if (NULL == pRdrRef)
                    {
                        DWORD cchHeader = lstrlen(CalaisString(CALSTR_SPECIALREADERHEADER));


                        //
                        // See if it's a specal case reader name.
                        // Special notariety goes to Craig Delthony
                        // for inventing this backdoor mechanism.
                        //

                        bfAtr.Reset();
                        if (0 == _tcsncicmp(
                                    szReader,
                                    CalaisString(CALSTR_SPECIALREADERHEADER),
                                    cchHeader))
                        {
                            LPCTSTR szSpecial = szReader + cchHeader;
                            CalaisInfo(
                                __SUBROUTINE__,
                                DBGT("Special Reader Name Flag '%2', TID = %1"),
                                szTid,
                                szSpecial);

                            if (0 == lstrcmpi(
                                            szSpecial,
                                            CalaisString(CALSTR_ACTIVEREADERCOUNTREADER)))
                            {

                                //
                                // Report the number of active readers.
                                //
                                //  The high order word of the Reader Status
                                //  contains the number of active readers.
                                //

                                rgdwStates[dwIndex] &= (SCARD_STATE_UNKNOWN
                                                        | (((DWORD)((WORD)(-1)))
                                                           << sizeof(WORD) * 8));
                                                           // 8 Bits per byte
                                dwRdrStatus = CalaisCountReaders();
                                dwRdrStatus <<= sizeof(WORD) * 8;   // 8 Bits per byte
                                dwRdrCount += 1;
                                fPnPNotify = TRUE;
                                goto CheckChange;
                            }
                            // Other flags can be added here
                            else
                            {

                                //
                                // Unrecognized special reader name.
                                //

                                dwRdrStatus = SCARD_STATE_UNKNOWN
                                              | SCARD_STATE_IGNORE;
                                goto CheckChange;
                            }
                        }
                        else
                        {
                            dwRdrStatus = SCARD_STATE_UNKNOWN
                                          | SCARD_STATE_IGNORE;
                            goto CheckChange;
                        }
                    }
                    rgpReaders.Set(dwIndex, pRdrRef);
                    pRdrRef = NULL;
                }
                else
                    pReader = rgpReaders[dwIndex]->Reader();
                dwRdrCount += 1;

                try
                {
                    pReader->Atr(bfAtr);
                    avlState = pReader->AvailabilityStatus();
                    hChangeEvent = pReader->ChangeEvent();
                    wActivityCount = pReader->ActivityHash();
                }
                catch (...)
                {
                    bfAtr.Reset();
                    avlState = CReader::Undefined;
                    hChangeEvent = NULL;
                    wActivityCount = 0;
                }

                switch (avlState)
                {
                case CReader::Unresponsive:
                case CReader::Unsupported:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_MUTE;
                    break;
                case CReader::Idle:
                    dwRdrStatus = SCARD_STATE_EMPTY;
                    break;
                case CReader::Present:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_UNPOWERED;
                    break;
                case CReader::Ready:
                    dwRdrStatus = SCARD_STATE_PRESENT;
                    break;
                case CReader::Shared:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_INUSE;
                    break;
                case CReader::Exclusive:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_INUSE
                                  | SCARD_STATE_EXCLUSIVE;
                    break;
                case CReader::Closing:
                case CReader::Inactive:
                case CReader::Broken:
                    dwRdrStatus = SCARD_STATE_UNAVAILABLE
                                  | SCARD_STATE_IGNORE;
                    pRdrRef = rgpReaders[dwIndex];
                    rgpReaders.Set(dwIndex, NULL);
                    CalaisReleaseReader(&pRdrRef);
                    pReader = NULL;
                    hChangeEvent = NULL;
                    wActivityCount = 0;
                    break;
                case CReader::Direct:
                    dwRdrStatus = SCARD_STATE_UNAVAILABLE;
                    break;
                case CReader::Undefined:
                    dwRdrStatus = SCARD_STATE_UNKNOWN
                                  | SCARD_STATE_IGNORE;
                    bfAtr.Reset();
                    hChangeEvent = NULL;
                    wActivityCount = 0;
                    break;
                default:
                    CalaisError(__SUBROUTINE__, 306);
                    throw (DWORD)SCARD_F_INTERNAL_ERROR;
                }

                dwRdrStatus += (DWORD)(wActivityCount) << (sizeof(WORD) * 8);
                rgdwStates[dwIndex] &= (0xffff0000
                                        | SCARD_STATE_UNKNOWN
                                        | SCARD_STATE_UNAVAILABLE
                                        | SCARD_STATE_EMPTY
                                        | SCARD_STATE_PRESENT
                                        | SCARD_STATE_EXCLUSIVE
                                        | SCARD_STATE_INUSE
                                        | SCARD_STATE_MUTE
                                        | SCARD_STATE_UNPOWERED);


                if (
                    ((rgdwStates[dwIndex] & SCARD_STATE_PRESENT) && 
                     (dwRdrStatus & SCARD_STATE_PRESENT) ||
                    ((rgdwStates[dwIndex] & 0x0000ffff) == (dwRdrStatus & 0x0000ffff)))
                    && ((rgdwStates[dwIndex] & 0xffff0000) != (dwRdrStatus & 0xffff0000))
                    && ((rgdwStates[dwIndex] & 0xffff0000) != 0))
                {
                    // 
                    // Two situations bring us into this block:
                    //  1)  The caller thinks the reader is in some sort of 
                    //  Present state (such as Present-Exclusive or 
                    //  Present-InUse) and the reader actually is in _any_
                    //  of those Present states, but the current Activity
                    //  Count on this device doesn't match the activity count
                    //  that the caller was last given.  That means the caller
                    //  probably missed a card withdrawal, so we're going to 
                    //  toggle the state.
                    //
                    //  2)  The following more specific case where the "new"
                    //  and "old" states match exactly.
                    //
                    //  The state has changed back to what the caller originally
                    //  thought it was.  Rather than loose an event, we simulate
                    //  a pseudo-event, to ensure the caller is up to date on
                    //  what all has already happened.  Then when they call us
                    //  again, we'll correct that pseudo-state to the real thing.
                    //

                    dwRdrStatus ^= (SCARD_STATE_EMPTY | SCARD_STATE_PRESENT);

                    bfAtr.Reset();      // Do not send back any ATR in any case

                    dwRdrStatus &= 0x0000ffff;  // We indeed backtrack by one event
                    dwRdrStatus += (DWORD)(--wActivityCount) << (sizeof(WORD) * 8);

                    switch (dwRdrStatus & (SCARD_STATE_EMPTY | SCARD_STATE_PRESENT))
                    {
                    case SCARD_STATE_EMPTY:
                            // Mask the bits according to spec (no card)
                        dwRdrStatus &= ~(SCARD_STATE_EXCLUSIVE
                                        | SCARD_STATE_INUSE
                                        | SCARD_STATE_MUTE);
                        break;
                    case SCARD_STATE_PRESENT:
                            // We claim that a card is present but we lie.
                            // We'd better declare it mute. It doesn't really matter as
                            // it is already withdrawn
                        dwRdrStatus |= SCARD_STATE_MUTE;
                        break;
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Card state invalid"));
                        throw (DWORD)SCARD_F_INTERNAL_ERROR;
                    }
                }

                if (NULL != hChangeEvent)
                {
                    for (dwJ = rgpvWaitHandles.Count(); dwJ > 0;)
                    {
                        if (rgpvWaitHandles[--dwJ] == hChangeEvent)
                        {
                            hChangeEvent = NULL;
                            break;
                        }
                    }
                    if (NULL != hChangeEvent)
                        rgpvWaitHandles.Add(hChangeEvent);
                }


                //
                // Return the ATR, if any.
                //

CheckChange:
                ASSERT(33 >= bfAtr.Length());
                bAtrLen = (BYTE)bfAtr.Length();
                bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));
                bfAtrs.Append(bfAtr.Access(), bfAtr.Length());


                //
                // See if that's what the user expects.
                //

                if (0 != (dwRdrStatus ^ rgdwStates[dwIndex]))
                {
                    rgdwStates[dwIndex] = dwRdrStatus | SCARD_STATE_CHANGED;
                    fChangeDetected = TRUE;
                }
                else
                    rgdwStates[dwIndex] = dwRdrStatus;
            }

            if (0 == dwRdrCount)
                throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
            if (fChangeDetected)
                break;


            //
            // If nothing has changed, wait for something to happen.
            //

            ASSERT(WAIT_ABANDONED_0 > WAIT_OBJECT_0);
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("Status Change Block, TID = %1"),
                szTid);
            ASSERT(m_hCancelEvent.IsValid());
            rgpvWaitHandles.Add(m_hCancelEvent);
            if (m_hExitEvent.IsValid())
                rgpvWaitHandles.Add(m_hExitEvent);
            if (fPnPNotify)
                rgpvWaitHandles.Add(g_phReaderChangeEvent->WaitHandle());
            rgpvWaitHandles.Add(g_hCalaisShutdown);
            dwIndex = WaitForMultipleObjects(
                            rgpvWaitHandles.Count(),
                            (LPHANDLE)rgpvWaitHandles.Array(),
                            FALSE,
                            pReq->dwTimeout);
            if (WAIT_FAILED == dwIndex)
            {
                DWORD dwErr = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Command dispatch TID=%2 cannot wait for Reader changes:  %1"),
                    dwErr,
                    szTid);
                throw dwErr;
            }
            C_ASSERT(WAIT_OBJECT_0 == 0);
            if (WAIT_TIMEOUT == dwIndex)
                throw (DWORD)SCARD_E_TIMEOUT;
            if (WAIT_ABANDONED_0 <= dwIndex)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Wait Abandoned received TID=%1 while waiting for Reader changes"),
                    szTid);
                dwIndex -= WAIT_ABANDONED_0;
            }
            if (dwIndex >= rgpvWaitHandles.Count())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid wait response TID=%1 while waiting for Reader changes"),
                    szTid);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("Status Change Unblock, TID = %1"),
                szTid);
            ASSERT(NULL != rgpvWaitHandles[dwIndex]);
            ASSERT(INVALID_HANDLE_VALUE != rgpvWaitHandles[dwIndex]);
            if (rgpvWaitHandles[dwIndex] == g_hCalaisShutdown)
                throw (DWORD)SCARD_E_SYSTEM_CANCELLED;
            if (rgpvWaitHandles[dwIndex] == m_hExitEvent.Value())
                throw (DWORD)SCARD_E_CANCELLED; // Caller exited.
            if (m_hCancelEvent.Value() == rgpvWaitHandles[dwIndex])
                throw (DWORD)SCARD_E_CANCELLED; // Caller canceled.
        }
        catch (DWORD dwError)
        {
            DWORD ix;
            switch (dwError)
            {
            case SCARD_E_CANCELLED:
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID = %1 Cancelled by user"),
                    szTid);
                break;
            case SCARD_E_SYSTEM_CANCELLED:
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID = %1 Cancelled by system"),
                    szTid);
                break;
            case SCARD_E_TIMEOUT:
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID = %1 timeout"),
                    szTid);
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID=%2 received unexpected exception: %1"),
                    dwError,
                    szTid);
            }
            CalaisReleaseReader(&pRdrRef);
            for (ix = rgpReaders.Count(); ix > 0;)
            {
                ix -= 1;
                pRdrRef = rgpReaders[ix];
                CalaisReleaseReader(&pRdrRef);
            }
            throw;
        }
        catch (...)
        {
            DWORD ix;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Get Status Change TID=%1 received unexpected exception"),
                szTid);
            CalaisReleaseReader(&pRdrRef);
            for (ix = rgpReaders.Count(); ix > 0;)
            {
                ix -= 1;
                pRdrRef = rgpReaders[ix];
                CalaisReleaseReader(&pRdrRef);
            }
            throw;
        }
    }


    //
    // Clean up.
    //

    CalaisReleaseReader(&pRdrRef);
    for (DWORD ix = rgpReaders.Count(); ix > 0;)
    {
        ix -= 1;
        pRdrRef = rgpReaders[ix];
        CalaisReleaseReader(&pRdrRef);
    }


    //
    // Report back to the caller.
    //

    pRsp = pCom->InitResponse(dwStateCount);
    pRsp = (ComGetStatusChange::CObjGetStatusChange_response *)
            pCom->Append(
                pRsp->dscReaderStates,
                (LPCBYTE)rgdwStates,
                dwStateCount * sizeof(DWORD));
    pRsp = (ComGetStatusChange::CObjGetStatusChange_response *)
            pCom->Append(
                pRsp->dscAtrs,
                bfAtrs.Access(),
                bfAtrs.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoConnect:

    This method performs the Connect service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoConnect")

void
CServiceThread::DoConnect(
    ComConnect *pCom)
{
    CReaderReference *pRdrRef = NULL;
    CReader *pReader = NULL;

    try
    {
        LPCTSTR szReader;
        DWORD dwIndex;
        ComConnect::CObjConnect_request *pReq
            = (ComConnect::CObjConnect_request *)pCom->Request();
        szReader = (LPCTSTR)pCom->Parse(pReq->dscReader);


        //
        //  Find the requested reader.
        //

        if (0 == *szReader)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        pRdrRef = CalaisLockReader(szReader);
        ASSERT(NULL != pRdrRef);
        pReader = pRdrRef->Reader();
        ASSERT(NULL != pReader);


        //
        // Try to establish the requested ownership.
        //

        pReader->Connect(
            pReq->dwShareMode,
            pReq->dwPreferredProtocols,
            pRdrRef->ActiveState());
        pRdrRef->Mode(pReq->dwShareMode);
        for (dwIndex = 0; NULL != m_rgpReaders[dwIndex]; dwIndex += 1);
            // null body
        m_rgpReaders.Set(dwIndex, pRdrRef);
        pRdrRef = NULL;

        ComConnect::CObjConnect_response *pRsp = pCom->InitResponse(0);
        pRsp->hCard = L2H(dwIndex);
        pRsp->dwActiveProtocol = pReader->Protocol();
        pRsp->dwStatus = SCARD_S_SUCCESS;
    }

    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to Connect to reader"));
        CalaisReleaseReader(&pRdrRef);
        throw;
    }
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoReconnect:

    This method performs the Reconnect service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoReconnect")

void
CServiceThread::DoReconnect(
    ComReconnect *pCom)
{
    ComReconnect::CObjReconnect_request *pReq
        = (ComReconnect::CObjReconnect_request *)pCom->Request();
    DWORD dwIndex = (DWORD)pReq->hCard;
    DWORD dwDispSts;
    CReaderReference * pRdrRef = m_rgpReaders[dwIndex];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_HANDLE;
    CReader *pReader = pRdrRef->Reader();
    pReader->Reconnect(
            pReq->dwShareMode,
            pReq->dwPreferredProtocols,
            pReq->dwInitialization,
            pRdrRef->ActiveState(),
            &dwDispSts);
    pRdrRef->Mode(pReq->dwShareMode);

    ComReconnect::CObjReconnect_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwActiveProtocol = pReader->Protocol();
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoDisconnect:

    This method performs the Disconnect service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoDisconnect")

void
CServiceThread::DoDisconnect(
    ComDisconnect *pCom)
{
    CReaderReference *pRdrRef = NULL;
    ComDisconnect::CObjDisconnect_request *pReq
        = (ComDisconnect::CObjDisconnect_request *)pCom->Request();
    DWORD dwIndex = (DWORD)pReq->hCard;
    DWORD dwDispSts;

    pRdrRef = m_rgpReaders[dwIndex];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_HANDLE;
    CReader *pRdr = pRdrRef->Reader();
    try
    {
        pRdr->Disconnect(
            pRdrRef->ActiveState(),
            pReq->dwDisposition,
            &dwDispSts);
    }
    catch (...) {}
    m_rgpReaders.Set(dwIndex, NULL);
    CalaisReleaseReader(&pRdrRef);

    ComDisconnect::CObjDisconnect_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoBeginTransaction:

    This method performs the BeginTransaction service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoBeginTransaction")

void
CServiceThread::DoBeginTransaction(
    ComBeginTransaction *pCom)
{
    CReader *pRdr = NULL;
#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    try
    {
        ComBeginTransaction::CObjBeginTransaction_request *pReq
            = (ComBeginTransaction::CObjBeginTransaction_request *)
                pCom->Request();
        CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
        if (NULL == pRdrRef)
            throw (DWORD)SCARD_E_INVALID_VALUE;
        CReader *pRdr2 = pRdrRef->Reader();
        pRdr2->VerifyActive(pRdrRef->ActiveState());
        pRdr2->GrabReader();
        pRdr = pRdr2;
        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Begin Transaction, TID = %1"),
            szTid);
        ComBeginTransaction::CObjBeginTransaction_response *pRsp
            = pCom->InitResponse(0);
        pRsp->dwStatus = SCARD_S_SUCCESS;
    }
    catch (...)
    {
        if (NULL != pRdr)
        {
            pRdr->ShareReader();
            ASSERT(!pRdr->IsLatchedByMe());
        }
        throw;
    }
    ASSERT(!pRdr->IsLatchedByMe());
    ASSERT(pRdr->IsGrabbedByMe());
}


/*++

DoEndTransaction:

    This method performs the EndTransaction service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoEndTransaction")

void
CServiceThread::DoEndTransaction(
    ComEndTransaction *pCom)
{
#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    ComEndTransaction::CObjEndTransaction_request *pReq
        = (ComEndTransaction::CObjEndTransaction_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    CReader *pReader = pRdrRef->Reader();

    pReader->VerifyActive(pRdrRef->ActiveState());
    if (!pReader->IsGrabbedByMe())
        throw (DWORD)SCARD_E_NOT_TRANSACTED;

    switch (pReq->dwDisposition)
    {
    case SCARD_LEAVE_CARD:
        break;
    case SCARD_RESET_CARD:
    case SCARD_UNPOWER_CARD:
#ifdef SCARD_CONFISCATE_CARD
    case SCARD_CONFISCATE_CARD:
#endif
    case SCARD_EJECT_CARD:
        pReader->Dispose(pReq->dwDisposition, pRdrRef->ActiveState());
        break;

    default:
        throw (DWORD)SCARD_E_INVALID_VALUE;
    }

    if (!pReader->ShareReader())
        throw (DWORD)SCARD_E_NOT_TRANSACTED;
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("End Transaction, TID = %1"),
        szTid);
    ComEndTransaction::CObjEndTransaction_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoStatus:

    This method performs the Status service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoStatus")

void
CServiceThread::DoStatus(
    ComStatus *pCom)
{
    CBuffer bfAtr;
    LPCTSTR szName;
    DWORD dwNameLen;
    ComStatus::CObjStatus_request *pReq
        = (ComStatus::CObjStatus_request *)pCom->Request();
    DWORD dwIndex = (DWORD)pReq->hCard;
    CReaderReference * pRdrRef = m_rgpReaders[dwIndex];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_HANDLE;
    CReader *pReader = pRdrRef->Reader();

    szName = pReader->ReaderName();
    dwNameLen = (lstrlen(szName) + 1) * sizeof(TCHAR);
    pReader->Atr(bfAtr);

    ComStatus::CObjStatus_response *pRsp
        = pCom->InitResponse(36 + dwNameLen);   // Room for an ATR.
    pRsp->dwState = pReader->GetReaderState(
                pRdrRef->ActiveState());
    pRsp->dwProtocol = pReader->Protocol();
    pRsp = (ComStatus::CObjStatus_response *)
        pCom->Append(pRsp->dscAtr, bfAtr.Access(), bfAtr.Length());
    pRsp = (ComStatus::CObjStatus_response *)
        pCom->Append(pRsp->dscSysName, szName, dwNameLen);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoTransmit:

    This method performs the Transmit service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoTransmit")

void
CServiceThread::DoTransmit(
    ComTransmit *pCom)
{
    CBuffer bfSendData;
    CBuffer bfRecvData;
    LPCBYTE pbSendData;
    DWORD dwLen;
    SCARD_IO_REQUEST *pioReq;
    ComTransmit::CObjTransmit_request *pReq
        = (ComTransmit::CObjTransmit_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    pioReq = (SCARD_IO_REQUEST *)pCom->Parse(pReq->dscSendPci, &dwLen);
    if (dwLen < sizeof(SCARD_IO_REQUEST))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Transmit data request too small."));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    if (dwLen != pioReq->cbPciLength)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Transmit Request PCI length exceeds data."));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    if (0 != (dwLen % sizeof(DWORD)))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Badly formed Transmit Request PCI data."));
        throw (DWORD)SCARD_E_INVALID_VALUE;
    }
    pbSendData = (LPCBYTE)pCom->Parse(pReq->dscSendBuffer, &dwLen);
    bfSendData.Presize(pioReq->cbPciLength + dwLen);
    if (0 != pReq->dwRecvLength)
        bfRecvData.Presize(pReq->dwPciLength + pReq->dwRecvLength);
    else
        bfRecvData.Presize(pReq->dwPciLength + g_dwDefaultIOMax);

    CReader *pReader = pRdrRef->Reader();
    if (0 == pioReq->dwProtocol)
        pioReq->dwProtocol = pReader->Protocol();
    bfSendData.Set((LPCBYTE)pioReq, pioReq->cbPciLength);
    bfSendData.Append(pbSendData, dwLen);
    try
    {
        pReader->ReaderTransmit(
            pRdrRef->ActiveState(),
            bfSendData.Access(),
            bfSendData.Length(),
            bfRecvData);

        // The SendData buffer may contain sensitive information such as a 
        // user Pin.  Scrub that buffer.
        RtlSecureZeroMemory(bfSendData.Access(), bfSendData.Length());
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Card Transmission Error reported: %1"),
            dwErr);
#ifdef SCARD_E_COMM_DATA_LOST
        if (ERROR_SEM_TIMEOUT == dwErr)
            dwErr = SCARD_E_COMM_DATA_LOST;
#endif
        throw dwErr;
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Card Transmission exception reported"));
        throw (DWORD)SCARD_F_UNKNOWN_ERROR;
    }

    if (bfRecvData.Length() < sizeof(SCARD_IO_REQUEST))
    {
        CalaisError(__SUBROUTINE__, 308, pReader->ReaderName());
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
    pioReq = (SCARD_IO_REQUEST *)bfRecvData.Access();
    if (bfRecvData.Length() < pioReq->cbPciLength)
    {
        CalaisError(__SUBROUTINE__, 309, pReader->ReaderName());
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }

    ComTransmit::CObjTransmit_response *pRsp
        = pCom->InitResponse(pioReq->cbPciLength + sizeof(DWORD));
    pRsp = (ComTransmit::CObjTransmit_response *)pCom->Append(
                pRsp->dscRecvPci,
                (LPCBYTE)pioReq,
                pioReq->cbPciLength);
    pRsp = (ComTransmit::CObjTransmit_response *)pCom->Append(
                pRsp->dscRecvBuffer,
                bfRecvData.Access(pioReq->cbPciLength),
                bfRecvData.Length() - pioReq->cbPciLength);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoControl:

    This method performs the Control service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoControl")

void
CServiceThread::DoControl(
    ComControl *pCom)
{
    LPCBYTE pbInData;
    DWORD cbInData, dwSts, dwLen;
    CBuffer bfOutData(g_dwDefaultIOMax);
    ComControl::CObjControl_request *pReq
        = (ComControl::CObjControl_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    pbInData = (LPCBYTE)pCom->Parse(pReq->dscInBuffer, &cbInData);
    bfOutData.Presize(pReq->dwOutLength);

    CReader *pRdr = pRdrRef->Reader();
    dwLen = bfOutData.Space();
    dwSts = pRdr->Control(
                pRdrRef->ActiveState(),
                pReq->dwControlCode,
                pbInData,
                cbInData,
                bfOutData.Access(),
                &dwLen);
    if (ERROR_SUCCESS != dwSts)
        throw dwSts;
    bfOutData.Resize(dwLen, TRUE);

    ComControl::CObjControl_response *pRsp
        = pCom->InitResponse(pReq->dwOutLength);
    pRsp = (ComControl::CObjControl_response *)pCom->Append(
                pRsp->dscOutBuffer,
                bfOutData.Access(),
                bfOutData.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pRdr->IsLatchedByMe());
}


/*++

DoGetAttrib:

    This method performs the GetAttrib service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoGetAttrib")

void
CServiceThread::DoGetAttrib(
    ComGetAttrib *pCom)
{
    CBuffer bfOutData(g_dwDefaultIOMax);
    ComGetAttrib::CObjGetAttrib_request *pReq
        = (ComGetAttrib::CObjGetAttrib_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    bfOutData.Presize(pReq->dwOutLength);

    CReader *pRdr = pRdrRef->Reader();
    switch (pReq->dwAttrId)
    {
#ifdef UNICODE
    case SCARD_ATTR_DEVICE_SYSTEM_NAME_A:
    case SCARD_ATTR_DEVICE_FRIENDLY_NAME_A:
#else
    case SCARD_ATTR_DEVICE_SYSTEM_NAME_W:
    case SCARD_ATTR_DEVICE_FRIENDLY_NAME_W:
#endif
    case SCARD_ATTR_DEVICE_FRIENDLY_NAME:
        throw (DWORD)SCARD_E_INVALID_VALUE;
        break;
    case SCARD_ATTR_DEVICE_SYSTEM_NAME:
    {
        LPCTSTR szName = pRdr->ReaderName();
        bfOutData.Set(
            (LPCBYTE)szName,
            (lstrlen(szName) + 1) * sizeof(TCHAR));
        break;
    }
    default:
        pRdr->GetReaderAttr(
                    pRdrRef->ActiveState(),
                    pReq->dwAttrId,
                    bfOutData);
    }

    ComGetAttrib::CObjGetAttrib_response *pRsp
        = pCom->InitResponse(pReq->dwOutLength);

    pRsp = (ComGetAttrib::CObjGetAttrib_response *)pCom->Append(
                pRsp->dscAttr,
                bfOutData.Access(),
                bfOutData.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pRdr->IsLatchedByMe());
}


/*++

DoSetAttrib:

    This method performs the SetAttrib service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoSetAttrib")

void
CServiceThread::DoSetAttrib(
    ComSetAttrib *pCom)
{
    LPCBYTE pbAttr;
    DWORD cbAttr;
    ComSetAttrib::CObjSetAttrib_request *pReq
        = (ComSetAttrib::CObjSetAttrib_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    pbAttr = (LPCBYTE)pCom->Parse(pReq->dscAttr, &cbAttr);

    CReader *pRdr = pRdrRef->Reader();
    pRdr->SetReaderAttr(
                pRdrRef->ActiveState(),
                pReq->dwAttrId,
                pbAttr,
                cbAttr);

    ComSetAttrib::CObjSetAttrib_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pRdr->IsLatchedByMe());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\server\server\control.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Control

Abstract:

    This module provides the common control operations of the Calais Service
    Manager.

Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#undef __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "CalServe.h"

class WORKER_THREAD
{
public:
    WORKER_THREAD(void) : hThread(DBGT("Worker Thread handle")) {};
    CHandleObject hThread;
    DWORD dwThreadId;
};

CCriticalSectionObject *g_pcsControlLocks[CSLOCK_MAXLOCKS];
const DWORD g_dwControlLockDesc[]
    = {
        CSID_CONTROL_LOCK,      // Lock for Calais control commands.
        CSID_SERVER_THREADS,    // Lock for server thread enumeration.
        CSID_TRACEOUTPUT        // Lock for tracing output.
      };
#if (CSLOCK_MAXLOCKS > 3)   // Make sure global locks get named!
#error "You're missing some global lock names"
#endif

static BOOL
    l_fActive = FALSE,
    l_fStarted = FALSE;
static CDynamicArray<CReader> l_rgReaders;
static CDynamicArray<WORKER_THREAD> l_rgWorkerThreads;
HANDLE g_hCalaisShutdown = NULL;
CMultiEvent *g_phReaderChangeEvent;


static CReader *LocateReader(LPCTSTR szReader);
static CReader *LocateReader(HANDLE hReader);


/*++

CalaisStart:

    This is the main entry routine into Calais.  It starts all the other threads
    needed in Calais, initializes control values, etc., then returns.

Arguments:

    None

Return Value:

    A DWORD success code, indicating success or the error code.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisStart")

DWORD
CalaisStart(
    void)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;
    DWORD dwReaderCount = 0;

    if (!l_fStarted)
    {
        DWORD dwIndex;

        for (dwIndex = 0; dwIndex < CSLOCK_MAXLOCKS; dwIndex += 1)
        {
            g_pcsControlLocks[dwIndex]
                = new CCriticalSectionObject(g_dwControlLockDesc[dwIndex]);
            if (NULL == g_pcsControlLocks[dwIndex])
                return (DWORD)SCARD_E_NO_MEMORY;
            if (g_pcsControlLocks[dwIndex]->InitFailed())
            {
                delete g_pcsControlLocks[dwIndex];
                g_pcsControlLocks[dwIndex] = NULL;
                do
                {
                    dwIndex--;
                    delete g_pcsControlLocks[dwIndex];
                    g_pcsControlLocks[dwIndex] = NULL;
                }
                while (0 != dwIndex);

                return (DWORD)SCARD_E_NO_MEMORY;
            }
        }

        try
        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Initializing Calais"));
            l_fStarted = TRUE;
            g_phReaderChangeEvent = new CMultiEvent;
            if (NULL == g_phReaderChangeEvent)
            {
                CalaisError(__SUBROUTINE__, 206);
                return (DWORD)SCARD_E_NO_MEMORY;
            }
            if (g_phReaderChangeEvent->InitFailed())
            {
                CalaisError(__SUBROUTINE__, 207);
                delete g_phReaderChangeEvent;
                g_phReaderChangeEvent = NULL;
                return (DWORD)SCARD_E_NO_MEMORY;
            }
            g_hCalaisShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == g_hCalaisShutdown)
            {
                DWORD dwError = GetLastError();
                CalaisError(__SUBROUTINE__, 204, dwError);
                throw dwError;
            }


            //
            // Make sure the system registries exist.
            //

            try
            {
                CRegistry regCalais(
                    HKEY_LOCAL_MACHINE,
                    CalaisString(CALSTR_CALAISREGISTRYKEY),
                    KEY_READ,
                    REG_OPTION_EXISTS,
                    NULL);

                regCalais.Status(); // Will throw if key was not found

                try
                {
                    g_dwDefaultIOMax = regCalais.GetNumericValue(
                                            CalaisString(CALSTR_MAXDEFAULTBUFFER));
                }
                catch (DWORD) {}
            }
            catch (DWORD dwErr)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to verify Calais registry entries: %1"),
                    dwErr);
                throw;
            }


            //
            // Kick off the various reader classes.
            //

            l_fActive = TRUE;
            dwReaderCount += AddAllPnPDrivers();

            //
            // Initialize communications.
            //

            DispatchInit();
        }

        catch (DWORD dwError)
        {
            dwExitCode = dwError;
            CalaisError(__SUBROUTINE__, 201, dwExitCode);
            if (NULL != g_hCalaisShutdown)
            {
                if (!CloseHandle(g_hCalaisShutdown))
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Failed to close Calais Shutdown Event: %1"),
                        GetLastError());
                g_hCalaisShutdown = NULL;
            }
        }

        catch (...)
        {
            dwExitCode = SCARD_F_UNKNOWN_ERROR;
            CalaisError(__SUBROUTINE__, 202);
            if (NULL != g_hCalaisShutdown)
            {
                if (!CloseHandle(g_hCalaisShutdown))
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Failed to close Calais Shutdown Event: %1"),
                        GetLastError());
                g_hCalaisShutdown = NULL;
            }
        }
    }

    return dwExitCode;
}


/*++

CalaisReaderCount:

    This routine gets the number of possible known readers, with locking.

Arguments:

    None

Return Value:

    The number of available slots in the Known Reader array.  Some of the slots
    may have NULL values.

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisReaderCount")

DWORD
CalaisReaderCount(
    void)
{
    ASSERT(l_fStarted);
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Counting the readers"));
    return l_rgReaders.Count();
}


/*++

CalaisCountReaders:

    This routine takes a more proactive approach to counting readers.  It goes
    through the array and deducts any non-functional readers from the total.

Arguments:

    None

Return Value:

    The number of truely active readers.

Author:

    Doug Barlow (dbarlow) 1/11/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisCountReaders")

DWORD
CalaisCountReaders(
    void)
{
    ASSERT(l_fStarted);
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Authoritative reader count"));
    DWORD dwIndex, dwReaders = l_rgReaders.Count();
    CReader *pRdr;

    for (dwIndex = dwReaders; 0 < dwIndex;)
    {
        dwIndex -= 1;
        pRdr = l_rgReaders[dwIndex];
        if (NULL == pRdr)
            dwReaders -= 1;
        else if (CReader::Closing <= pRdr->AvailabilityStatus())
            dwReaders -= 1;
    }

    return dwReaders;
}


/*++

CalaisLockReader:

    This routine returns the value in the known reader list at the given
    location, with locking, so that the reader object won't go away until
    released.

Arguments:

    szReader supplies the name of the reader to search for.

Return Value:

    A Reader reference object for the entry at that index.

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisLockReader")

CReaderReference *
CalaisLockReader(
    LPCTSTR szReader)
{
    ASSERT(l_fStarted);
    CReader * pReader = NULL;
    CReaderReference *pRdrRef = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Marking Reader as in use."));

    pReader = LocateReader(szReader);
    if (NULL == pReader)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    pRdrRef = new CReaderReference(pReader);
    if (NULL == pRdrRef)
    {
        CalaisError(__SUBROUTINE__, 203);
        throw (DWORD)SCARD_E_NO_MEMORY;
    }
    return pRdrRef;
}


/*++

CalaisReleaseReader:

    This routine releases a reader obtained via CalaisLockReader.

Arguments:

    ppRdrRef supplies the address of the pointer to a reader reference.
    It is automatically set to NULL when it is freed.

Return Value:

    None

Throws:

    Errors are thrown as DWORDs

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisReleaseReader")

void
CalaisReleaseReader(
    CReaderReference **ppRdrRef)
{
    ASSERT(l_fStarted);
    ASSERT(NULL != ppRdrRef);
    if (NULL != *ppRdrRef)
    {
        ASSERT(!(*ppRdrRef)->Reader()->IsLatchedByMe());
        delete *ppRdrRef;
        *ppRdrRef = NULL;
    }
}


/*++

CalaisAddReader:

    This routine adds a reader into the active device list.

Arguments:

    pRdr supplies a CReader object to be added.

    szReader supplies the name of the reader to be added.

    dwFlags supplies requested flags for this reader.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 4/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisAddReader")

DWORD
CalaisAddReader(
    LPCTSTR szReader,
    DWORD dwFlags)
{
    DWORD dwIndex;
    DWORD dwReturn = ERROR_SUCCESS;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Adding a new reader to the list"));

    for (dwIndex = l_rgReaders.Count(); 0 < dwIndex;)
    {
        dwIndex -= 1;
        pReader = l_rgReaders[dwIndex];
        if (NULL != pReader)
        {
            if (0 == lstrcmpi(szReader, pReader->DeviceName()))
            {
                dwReturn = SCARD_E_DUPLICATE_READER;
                break;
            }
        }
    }

    if (ERROR_SUCCESS == dwReturn)
        dwReturn = AddReaderDriver(szReader, dwFlags);
    return dwReturn;
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisAddReader")

DWORD
CalaisAddReader(
    CReader *pRdr)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Adding a reader to the list."));

    try
    {
        if (!l_fActive)
            throw (DWORD)SCARD_E_SYSTEM_CANCELLED;
        DWORD dwIndex;
        LPCTSTR szReader = pRdr->ReaderName();


        //
        // Make sure this is a unique device name.
        //

        if (NULL != LocateReader(szReader))
        {
            CalaisError(__SUBROUTINE__, 205, szReader);
            throw (DWORD)SCARD_E_DUPLICATE_READER;
        }


        //
        // Make sure the reader has a name in the system.
        //

        CBuffer bfTmp;

        ListReaderNames(SCARD_SCOPE_SYSTEM, szReader, bfTmp);
        if (NULL == FirstString(bfTmp))
            IntroduceReader(
                SCARD_SCOPE_SYSTEM,
                szReader,
                szReader);


        //
        // Add it to the list.
        //

        dwIndex = 0;
        while (NULL != l_rgReaders[dwIndex])
            dwIndex += 1;
        l_rgReaders.Set(dwIndex, pRdr);
        PulseEvent(AccessNewReaderEvent());
    }

    catch (DWORD dwError)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Server Control received error attempting to create reader object: %1"),
            dwError);
        dwExitCode = dwError;
    }

    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Server Control received exception attempting to create reader object"));
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }

    return dwExitCode;
}


/*++

CalaisQueryReader:

    This routine queries a device to see if it can be removed from the active
    device list.

Arguments:

    hReader supplies the handle by which the reader can be identified.

Return Value:

    TRUE - The device can be deactived.
    FALSE - The device should not be deactivated.

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisQueryReader")

BOOL
CalaisQueryReader(
    HANDLE hReader)
{
    BOOL fReturn = FALSE;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Checking reader usage"));

    pReader = LocateReader(hReader);
    if (NULL != pReader)
        fReturn = !pReader->IsInUse();
    else
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("CalaisQueryReader was asked for nonexistent reader"));
        fReturn = FALSE;
    }
    return fReturn;
}


/*++

CalaisDisableReader:

    This routine moves a reader to an inactive state pending removal.

Arguments:

    hDriver supplies the handle by which the reader can be identified.

Return Value:

    The name of the reader being disabled.

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisDisableReader")

LPCTSTR
CalaisDisableReader(
    HANDLE hDriver)
{
    LPCTSTR szReturn = NULL;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Disabing the reader"));

    pReader = LocateReader(hDriver);
    if (NULL != pReader)
    {
        pReader->Disable();
        szReturn = pReader->DeviceName();
    }
    return szReturn;
}


/*++

CalaisConfirmClosingReader:

    This routine ensures a reader is marked Closing, then moves a reader to
    an inactive state pending removal.

Arguments:

    hDriver supplies the handle by which the reader can be identified.

Return Value:

    The name of the reader being disabled.

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisConfirmClosingReader")

LPCTSTR
CalaisConfirmClosingReader(
    HANDLE hDriver)
{
    LPCTSTR szReturn = NULL;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Confirm closing the reader"));

    pReader = LocateReader(hDriver);
    if (NULL != pReader)
    {
        if (CReader::Closing <= pReader->AvailabilityStatus())
        {
            pReader->Disable();
            szReturn = pReader->DeviceName();
        }
    }
    return szReturn;
}


/*++

CalaisRemoveReader:

    This routine removes a reader from the active device list.

Arguments:

    szReader supplies the internal name of the reader to be removed.

    dwIndex supplies the global reader array index to be removed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 4/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisRemoveReader")

DWORD
CalaisRemoveReader(
    LPCTSTR szReader)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;

    try
    {
        CReader *pRdr = NULL;
        DWORD dwIndex;


        //
        // Look for it in the reader list, and remove it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Removing reader from list"));

            for (dwIndex = l_rgReaders.Count(); dwIndex > 0;)
            {
                pRdr = l_rgReaders[--dwIndex];
                if (NULL == pRdr)
                    continue;
                if (0 == lstrcmpi(szReader, pRdr->ReaderName()))
                    break;
                pRdr = NULL;
            }
        }
        if (NULL == pRdr)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        CalaisRemoveReader(dwIndex);
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }
    return dwExitCode;
}

DWORD
CalaisRemoveReader(
    LPVOID hAppCtrl)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;

    try
    {
        CReader *pRdr = NULL;
        DWORD dwIndex;


        //
        // Look for it in the reader list, and remove it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Removing reader from list"));
            for (dwIndex = l_rgReaders.Count(); dwIndex > 0;)
            {
                pRdr = l_rgReaders[--dwIndex];
                if (NULL == pRdr)
                    continue;
                if (hAppCtrl == pRdr->ReaderHandle())
                    break;
                pRdr = NULL;
            }
        }
        if (NULL == pRdr)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        CalaisRemoveReader(dwIndex);
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }
    return dwExitCode;
}

DWORD
CalaisRemoveReader(
    DWORD dwIndex)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;
    WORKER_THREAD *pWrkThread = NULL;

    try
    {
        CReader *pRdr;

        //
        // Lock the global reader array and remove the entry, so no other
        // threads can access it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Removing Reader from list"));
            if (l_rgReaders.Count() <= dwIndex)
                throw (DWORD)SCARD_E_UNKNOWN_READER;
            pRdr = l_rgReaders[dwIndex];
            l_rgReaders.Set(dwIndex, NULL);
            g_phReaderChangeEvent->Signal();
        }


        //
        // Disable the device, and wait for all outstanding references to clear.
        // Then delete it.
        //

        if (NULL != pRdr)
        {
            pWrkThread = new WORKER_THREAD;
            if (NULL == pWrkThread)
                throw (DWORD)SCARD_E_NO_MEMORY;

            pWrkThread->hThread = CreateThread(
                                        NULL,               // Not inheritable
                                        CALAIS_STACKSIZE,   // Default stack size
                                        CalaisTerminateReader,
                                        pRdr,
                                        CREATE_SUSPENDED,
                                        &pWrkThread->dwThreadId);
            if (!pWrkThread->hThread.IsValid())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to start background terminator: %1"),
                    pWrkThread->hThread.GetLastError());
                delete pWrkThread;
                pWrkThread = NULL;
            }

            {
                LockSection(
                    g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                    DBGT("Deleting the reader"));
                for (dwIndex = 0; NULL != l_rgWorkerThreads[dwIndex]; dwIndex += 1);
                // Null Loop body
                l_rgWorkerThreads.Set(dwIndex, pWrkThread);
                ResumeThread(pWrkThread->hThread);
                pWrkThread = NULL;
            }
        }
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
        if (NULL != pWrkThread)
            delete pWrkThread;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
        if (NULL != pWrkThread)
            delete pWrkThread;
    }
    return dwExitCode;
}


/*++

CalaisRemoveDevice:

    This routine removes a reader from the active device list, identified by
    it's low level name.

Arguments:

    szDevice supplies the internal name of the reader to be removed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 4/15/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisRemoveDevice")

DWORD
CalaisRemoveDevice(
    LPCTSTR szDevice)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;

    try
    {
        CReader *pRdr = NULL;
        DWORD dwIndex;


        //
        // Look for it in the reader list, and remove it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Remove the device"));
            for (dwIndex = l_rgReaders.Count(); dwIndex > 0;)
            {
                pRdr = l_rgReaders[--dwIndex];
                if (NULL == pRdr)
                    continue;
                if (0 == lstrcmpi(szDevice, pRdr->DeviceName()))
                    break;
                pRdr = NULL;
            }
        }
        if (NULL == pRdr)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        CalaisRemoveReader(dwIndex);
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }
    return dwExitCode;
}


/*++

CalaisStop:

    This routine is called when it is time for the Calais subsystem to close
    down.  It cleanly terminates the threads and shuts down the interface, and
    returns when it is completed.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisStop")

void
CalaisStop(
    void)
{
    DWORD dwIndex, dwSts, dwCount;
    BOOL fSts;


    //
    // Mark all the readers as Closing.
    //

    ASSERT(l_fActive);
    ASSERT(l_fStarted);
    fSts = SetEvent(g_hCalaisShutdown);
    ASSERT(fSts);
    Sleep(2000);    // Let the event have it's effect.
    {
        LockSection(
            g_pcsControlLocks[CSLOCK_CALAISCONTROL],
            DBGT("Close down all the readers"));
        l_fActive = FALSE;
        dwCount = l_rgReaders.Count();
        for (dwIndex = dwCount; dwIndex > 0;)
        {
            CReader *pRdr;
            pRdr = l_rgReaders[--dwIndex];
            if (NULL != pRdr)
            {
                pRdr->InvalidateGrabs();
                if (CReader::Closing > pRdr->AvailabilityStatus())
                    pRdr->SetAvailabilityStatusLocked(CReader::Closing);
            }
        }
    }


    //
    // Terminate Service processing.
    //

    DispatchTerm();


    //
    // Disable all the readers.
    //

    for (dwIndex = dwCount; dwIndex > 0;)
    {
        dwSts = CalaisRemoveReader(--dwIndex);
        if (SCARD_S_SUCCESS != dwSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Calais Stop failed to remove reader"));
    }


    //
    // Wait for those readers to be closed.
    //

    {
        LockSection(
            g_pcsControlLocks[CSLOCK_CALAISCONTROL],
            DBGT("Get the length of the reader list"));
        dwCount = l_rgWorkerThreads.Count();
    }
    for (dwIndex = dwCount; 0 < dwIndex;)
    {
        HANDLE hThread;
        DWORD dwThreadId;
        WORKER_THREAD *pWrkThread = NULL;

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Get the worker thread"));
            pWrkThread = l_rgWorkerThreads[--dwIndex];
            if (NULL == pWrkThread)
                continue;
            hThread = pWrkThread->hThread.Value();
            dwThreadId = pWrkThread->dwThreadId;

        }

        WaitForever(
            hThread,
            REASONABLE_TIME,
            DBGT("Waiting for reader termination, thread %2"),
            dwThreadId);
    }


    //
    // All done.  Close out any remaining handles and return.
    //

    l_fStarted = FALSE;
    if (!CloseHandle(g_hCalaisShutdown))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to close Calais Shutdown Event: %1"),
            GetLastError());
    ReleaseAllEvents();
    if (NULL != g_phReaderChangeEvent)
    {
        delete g_phReaderChangeEvent;
        g_phReaderChangeEvent = NULL;
    }

    for (dwIndex = 0; dwIndex < CSLOCK_MAXLOCKS; dwIndex += 1)
    {
        delete g_pcsControlLocks[dwIndex];
        g_pcsControlLocks[dwIndex] = NULL;
    }
}


/*++

LocateReader:

    This function locates a reader in the global reader array by name.
    It assumes the reader array has already been locked.

Arguments:

    szReader supplies the name of the reader to search for.

Return Value:

    The pointer to the reader, or NULL if none is found.

Author:

    Doug Barlow (dbarlow) 6/17/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("LocateReader")

static CReader *
LocateReader(
    LPCTSTR szReader)
{
    DWORD dwIndex;
    CReader * pReader = NULL;

    for (dwIndex = l_rgReaders.Count(); 0 < dwIndex;)
    {
        dwIndex -= 1;
        pReader = l_rgReaders[dwIndex];
        if (NULL != pReader)
        {
            if (0 == lstrcmpi(szReader, pReader->ReaderName()))
                return pReader;
        }
    }
    return NULL;
}

static CReader *
LocateReader(
    HANDLE hReader)
{
    DWORD dwIndex;
    CReader * pReader = NULL;

    for (dwIndex = l_rgReaders.Count(); 0 < dwIndex;)
    {
        dwIndex -= 1;
        pReader = l_rgReaders[dwIndex];
        if (NULL != pReader)
        {
            if (hReader == pReader->ReaderHandle())
                return pReader;
        }
    }
    return NULL;
}


/*++

CalaisTerminateReader:

    This routine removes a reader.  It is designed so that it has the option
    of being called as a background thread.

Arguments:

    pvParam is actually the DWORD index to be removed.

Return Value:

    A DWORD success code, indicating success or the error code.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 4/8/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisTerminateReader")

DWORD WINAPI
CalaisTerminateReader(
    LPVOID pvParam)
{
    NEW_THREAD;
    WORKER_THREAD *pWrkThread = NULL;
    DWORD dwReturn = 0;
    CReader *pRdr = (CReader *)pvParam;

    try
    {

        //
        // Make sure all outstanding references are invalidated.
        //

        {
            CTakeReader myReader(pRdr);
            CLockWrite rwLock(&pRdr->m_rwLock);
            pRdr->m_ActiveState.dwRemoveCount += 1;
            pRdr->SetAvailabilityStatus(CReader::Inactive);
        }
        {
            CLockWrite rwActive(&pRdr->m_rwActive);
        }
        delete pRdr;
    }
    catch (DWORD dwErr)
    {
        dwReturn = dwErr;
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to Terminate a reader object: %1"),
            dwErr);
    }
    catch (...)
    {
        dwReturn = SCARD_E_INVALID_PARAMETER;
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Exception during attempt to Terminate a reader object."));
    }


    {
        LockSection(
            g_pcsControlLocks[CSLOCK_CALAISCONTROL],
            DBGT("Remove this thread from the worker list"));
        for (DWORD dwIndex = l_rgWorkerThreads.Count();
             0 < dwIndex;)
        {
            pWrkThread = l_rgWorkerThreads[--dwIndex];
            if (NULL != pWrkThread)
            {
                if (GetCurrentThreadId() == pWrkThread->dwThreadId)
                {
                    l_rgWorkerThreads.Set(dwIndex, NULL);
                    break;
                }
                else
                    pWrkThread = NULL;
            }
        }
    }

    ASSERT(NULL != pWrkThread); // How did we get started?
    if (NULL != pWrkThread)
    {
        if (pWrkThread->hThread.IsValid())
            pWrkThread->hThread.Close();
        delete pWrkThread;
    }
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\changpin\chpindlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPinDlg.cpp
//
//--------------------------------------------------------------------------

// chPinDlg.cpp : implementation file
//

#include "stdafx.h"
#include <winscard.h>
#include <wincrypt.h>
#include <scardlib.h>
#include "chPin.h"
#include "chPinDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static UINT AFX_CDECL WorkThread(LPVOID);
static DWORD CSPType(IN LPCTSTR szProvider);

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog

CChangePinDlg::CChangePinDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CChangePinDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CChangePinDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CChangePinDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChangePinDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CChangePinDlg, CDialog)
    //{{AFX_MSG_MAP(CChangePinDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_MESSAGE(APP_ALLDONE, OnAllDone)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg message handlers

BOOL CChangePinDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    // TODO: Add extra initialization here
    m_pThread = AfxBeginThread(WorkThread, this);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CChangePinDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CChangePinDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CChangePinDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

static UINT AFX_CDECL
WorkThread(
    LPVOID pv)
{
    static TCHAR szReader[MAX_PATH];
    static TCHAR szCard[MAX_PATH];
    static TCHAR szProvider[MAX_PATH];
    static BYTE  pbSignature[(1024 / 8) + (4 * sizeof(DWORD))];
    CChangePinDlg *pDlg = (CChangePinDlg *)pv;
    OPENCARDNAME_EX ocn;
    OPENCARD_SEARCH_CRITERIA ocsc;
    SCARDCONTEXT hCtx = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    DWORD dwSts, dwLen, dwKeyType;
    DWORD dwProvType;
    BOOL fSts;
    CString szFqcn;

    dwSts = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hCtx);
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;

    ZeroMemory(&ocsc, sizeof(ocsc));
    ocsc.dwStructSize = sizeof(ocsc);
    // LPSTR           lpstrGroupNames;        // OPTIONAL reader groups to include in
    // DWORD           nMaxGroupNames;         //          search.  NULL defaults to
    //                                         //          SCard$DefaultReaders
    // LPCGUID         rgguidInterfaces;       // OPTIONAL requested interfaces
    // DWORD           cguidInterfaces;        //          supported by card's SSP
    // LPSTR           lpstrCardNames;         // OPTIONAL requested card names; all cards w/
    // DWORD           nMaxCardNames;          //          matching ATRs will be accepted
    // LPOCNCHKPROC    lpfnCheck;              // OPTIONAL if NULL no user check will be performed.
    // LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL if lpfnConnect is provided,
    // LPOCNDSCPROC    lpfnDisconnect;         //          lpfnDisconnect must also be set.
    // LPVOID          pvUserData;             // OPTIONAL parameter to callbacks
    // DWORD           dwShareMode;            // OPTIONAL must be set if lpfnCheck is not null
    // DWORD           dwPreferredProtocols;   // OPTIONAL

    ZeroMemory(&ocn, sizeof(ocn));
    ocn.dwStructSize = sizeof(ocn);
    ocn.hSCardContext = hCtx;
    ocn.hwndOwner = pDlg->m_hWnd;
    ocn.dwFlags = SC_DLG_FORCE_UI;
    ocn.lpstrTitle = TEXT("Change PIN Card Selection");
    ocn.lpstrSearchDesc = TEXT("Select the Smart Card who's PIN is to be changed.");
//    HICON           hIcon;                  // OPTIONAL 32x32 icon for your brand insignia
    ocn.pOpenCardSearchCriteria = &ocsc;
//    LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL - performed on successful selection
//    LPVOID          pvUserData;             // OPTIONAL parameter to lpfnConnect
//    DWORD           dwShareMode;            // OPTIONAL - if lpfnConnect is NULL, dwShareMode and
//    DWORD           dwPreferredProtocols;   // OPTIONAL   dwPreferredProtocols will be used to
//                                            //            connect to the selected card
    ocn.lpstrRdr = szReader;
    ocn.nMaxRdr = sizeof(szReader) / sizeof(TCHAR);
    ocn.lpstrCard = szCard;
    ocn.nMaxCard = sizeof(szCard) / sizeof(TCHAR);
//    DWORD               dwActiveProtocol;       // [OUT] set only if dwShareMode not NULL
//    SCARDHANDLE         hCardHandle;            // [OUT] set if a card connection was indicated

    dwSts = SCardUIDlgSelectCard(&ocn);
    if (NULL != ocn.hCardHandle)
        dwSts = SCardDisconnect(ocn.hCardHandle, SCARD_LEAVE_CARD);
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;


    //
    // The user has selected a card.  Translate that into a CSP.
    //

    dwLen = sizeof(szProvider) / sizeof(TCHAR);
    dwSts = SCardGetCardTypeProviderName(
                hCtx,
                szCard,
                SCARD_PROVIDER_CSP,
                szProvider,
                &dwLen);
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;
    dwSts = SCardReleaseContext(hCtx);
    hCtx = NULL;
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;
    dwProvType = CSPType(szProvider);
    if (0 == dwProvType)
    {
        dwSts = NTE_PROV_TYPE_ENTRY_BAD;
        goto ErrorExit;
    }
    szFqcn = TEXT("\\\\.\\");
    szFqcn += szReader;


    //
    // Activate a Key on the card.
    //

    fSts = CryptAcquireContext(&hProv, szFqcn, szProvider, dwProvType, 0);
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }
    for (dwKeyType = AT_KEYEXCHANGE; dwKeyType <= AT_SIGNATURE; dwKeyType += 1)
    {
        fSts = CryptGetUserKey(hProv, dwKeyType, &hKey);
        if (fSts)
            break;
    }
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }


    //
    // Use the CSP to force a PIN prompt.
    //

    fSts = CryptCreateHash(hProv, CALG_SHA, NULL, 0, &hHash);
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }
    fSts = CryptHashData(hHash, (LPBYTE)szProvider, sizeof(szProvider), 0);
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }
    dwLen = sizeof(pbSignature);
    fSts = CryptSignHash(hHash, dwKeyType, NULL, 0, pbSignature, &dwLen);


    //
    // All done.  Clean up and notify the main thread that we're done.
    //

ErrorExit:
    if (NULL != hHash)
        CryptDestroyHash(hHash);
    if (NULL != hKey)
        CryptDestroyKey(hKey);
    if (NULL != hProv)
        CryptReleaseContext(hProv, 0);
    if (NULL != hCtx)
        SCardReleaseContext(hCtx);
    if (SCARD_S_SUCCESS != dwSts)
        AfxMessageBox(ErrorString(dwSts), MB_ICONEXCLAMATION | MB_OK);
    pDlg->PostMessage(APP_ALLDONE);
    return 0;
}




/*++

CSPType:

    This function converts a CSP Name to a CSP Type.

Arguments:

    szProvider supplies the name of the CSP.

Return Value:

    The CSP type of the given CSP, or zero if no such CSP can be found.

Author:

    Doug Barlow (dbarlow) 1/14/1999

--*/

static DWORD
CSPType(
    IN LPCTSTR szProvider)
{
    LONG nSts;
    HKEY hList = NULL;
    HKEY hProv = NULL;
    DWORD dwProvType, dwValType, dwValLen;

    nSts = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                0,
                KEY_READ,
                &hList);
    if (ERROR_SUCCESS != nSts)
        goto ErrorExit;
    nSts = RegOpenKeyEx(
                hList,
                szProvider,
                0,
                KEY_READ,
                &hProv);
    if (ERROR_SUCCESS != nSts)
        goto ErrorExit;
    dwValLen = sizeof(DWORD);
    dwProvType = 0; // Assumes little endian.
    nSts = RegQueryValueEx(
                hProv,
                TEXT("Type"),
                0,
                &dwValType,
                (LPBYTE)&dwProvType,
                &dwValLen);
    if (ERROR_SUCCESS != nSts)
        goto ErrorExit;
    RegCloseKey(hProv);
    RegCloseKey(hList);
    return dwProvType;

ErrorExit:
    if (NULL != hProv)
        RegCloseKey(hProv);
    if (NULL != hList)
        RegCloseKey(hList);
    return 0;
}

LRESULT
CChangePinDlg::OnAllDone(
    WPARAM wParam,
    LPARAM lParam)
{
    WaitForSingleObject(m_pThread->m_hThread, INFINITE);
    CDialog::OnOK();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\changpin\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ChangePin.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define APP_ALLDONE                     101
#define IDD_CHANGEPIN_DIALOG            102
#define IDR_MAINFRAME                   128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\changpin\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	ChangePin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\changpin\chpindlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPinDlg.h
//
//--------------------------------------------------------------------------

// ChangePinDlg.h : header file
//

#if !defined(AFX_CHANGEPINDLG_H__99CC45B7_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
#define AFX_CHANGEPINDLG_H__99CC45B7_C1C8_11D2_88F3_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog

class CChangePinDlg : public CDialog
{
// Construction
public:
	CChangePinDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CChangePinDlg)
	enum { IDD = IDD_CHANGEPIN_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangePinDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;
    CWinThread *m_pThread;

	// Generated message map functions
	//{{AFX_MSG(CChangePinDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
    afx_msg LRESULT OnAllDone(WPARAM, LPARAM);
    //}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHANGEPINDLG_H__99CC45B7_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\changpin\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__99CC45B9_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
#define AFX_STDAFX_H__99CC45B9_C1C8_11D2_88F3_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
// #include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
// #include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__99CC45B9_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\cspsigck\cspsigck.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cspsigck.cpp
//
//--------------------------------------------------------------------------

// cspsigck.cpp : Defines the entry point for the console application.
//

// #ifndef WIN32_LEAN_AND_MEAN
// #define WIN32_LEAN_AND_MEAN
// #endif
// #include <windows.h>                    //  All the Windows definitions.
#include "afx.h"
#include <iostream.h>
#ifndef WINVER
#define WINVER 0x0500
#endif
#include <wincrypt.h>

static LPCTSTR
ErrorString(
    DWORD dwErrorCode);
static void
FreeErrorString(
    LPCTSTR szErrorString);

DWORD __cdecl
main(
     int argc, 
     char* argv[])
{
    static TCHAR szDots[] =
            TEXT("........................................................................");
    DWORD dwReturn = 0;
    HCRYPTPROV hProv = NULL;
    DWORD dwIndex, dwLength, dwSts, dwProvType;
    BOOL fSts;
    CString szProvider;

    cout << TEXT("==============================================================================\n")
         << TEXT("           Cryptographic Service Provider Signature validation\n")
         << TEXT("------------------------------------------------------------------------------\n")
         << flush;

    dwIndex = 0;
    for (;;)
    {
        dwLength = 0;
        fSts = CryptEnumProviders(
                    dwIndex,
                    NULL,
                    0,
                    &dwProvType,
                    NULL,
                    &dwLength);
        if (fSts)
        {
            fSts = CryptEnumProviders(
                        dwIndex,
                        NULL,
                        0,
                        &dwProvType,
                        szProvider.GetBuffer(dwLength / sizeof(TCHAR)),
                        &dwLength);
            dwSts = GetLastError();
            szProvider.ReleaseBuffer();
            if (!fSts)
            {
                cerr << TEXT("\n ERROR Can't obtain provider name: ")
                     << ErrorString(dwSts)
                     << endl;
                goto ErrorExit;
            }
        }
        else
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwSts)
                break;
            cerr << TEXT("\n ERROR Can't obtain provider name length: ")
                 << ErrorString(dwSts)
                 << endl;
            goto ErrorExit;
        }

        cout << szProvider << &szDots[szProvider.GetLength()] << flush;
        fSts = CryptAcquireContext(
                    &hProv,
                    NULL,
                    szProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT);
        if (fSts)
        {
            cout << TEXT("passed") << endl;
            fSts = CryptReleaseContext(hProv, 0);
            hProv = NULL;
            if (!fSts)
            {
                dwSts = GetLastError();
                cerr << TEXT("\n ERROR Can't release context: ")
                     << ErrorString(dwSts)
                     << endl;
                goto ErrorExit;
            }
        }
        else
        {
            dwSts = GetLastError();
            dwReturn = dwSts;
            cout << TEXT("FAILED\n")
                 << TEXT("    ") << ErrorString(dwSts)
                 << endl;
            ASSERT(NULL == hProv);
        }

        dwIndex += 1;
    }
    cout << TEXT("------------------------------------------------------------------------------\n")
         << TEXT("Final Status") << &szDots[12]
         << (LPCTSTR)((ERROR_SUCCESS == dwReturn) ? TEXT("passed\n") : TEXT("FAILED\n"))
         << TEXT("==============================================================================\n")
         << flush;
	dwReturn = 0;

ErrorExit:
    if (hProv != NULL)
        CryptReleaseContext(hProv, 0);
    return dwReturn;
}


/*++

ErrorString:

    This routine does it's very best to translate a given error code into a
    text message.  Any trailing non-printable characters are striped from the
    end of the text message, such as carriage returns and line feeds.

Arguments:

    dwErrorCode supplies the error code to be translated.

Return Value:

    The address of a freshly allocated text string.  Use FreeErrorString to
    dispose of it.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

static LPCTSTR
ErrorString(
    DWORD dwErrorCode)
{
    LPTSTR szErrorString = NULL;

    try
    {
        DWORD dwLen;
        LPTSTR szLast;

        dwLen = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwErrorCode,
                    LANG_NEUTRAL,
                    (LPTSTR)&szErrorString,
                    0,
                    NULL);
        if (0 == dwLen)
        {
            ASSERT(NULL == szErrorString);
            dwLen = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(NULL),
                        dwErrorCode,
                        LANG_NEUTRAL,
                        (LPTSTR)&szErrorString,
                        0,
                        NULL);
            if (0 == dwLen)
            {
                ASSERT(NULL == szErrorString);
                szErrorString = (LPTSTR)LocalAlloc(
                                        LMEM_FIXED,
                                        32 * sizeof(TCHAR));
                if (NULL == szErrorString)
                    throw (DWORD)SCARD_E_NO_MEMORY;
                _stprintf(szErrorString, TEXT("0x%08x"), dwErrorCode);
            }
        }

        ASSERT(NULL != szErrorString);
        for (szLast = szErrorString + lstrlen(szErrorString) - 1;
             szLast > szErrorString;
             szLast -= 1)
         {
            if (_istgraph(*szLast))
                break;
            *szLast = 0;
         }
    }
    catch (...)
    {
        FreeErrorString(szErrorString);
        throw;
    }

    return szErrorString;
}


/*++

FreeErrorString:

    This routine frees the Error String allocated by the ErrorString service.

Arguments:

    szErrorString supplies the error string to be deallocated.

Return Value:

    None

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

static void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\csptrace\csptrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspTrace

Abstract:

    This program performs analysis on a CSP Function trace.

Author:

    Doug Barlow (dbarlow) 2/19/1998

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include <tchar.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <scardlib.h>
#include "cspTrace.h"

LPCTSTR g_szMajorAction = TEXT("Initialization");
LPCTSTR g_szMinorAction = NULL;

static const TCHAR l_szLogCsp[] = TEXT("LogCsp.dll");
static const TCHAR l_szCspNames[] = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider");
static const TCHAR l_szImagePath[] = TEXT("Image Path");
static const TCHAR l_szLogCspRegistry[] = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Logging Crypto Provider");
static const TCHAR l_szTargetCsp[] = TEXT("Target");
static const TCHAR l_szLogFile[] = TEXT("Logging File");
static const TCHAR l_szDefaultFile[] = TEXT("C:\\cspTrace.log");

static void
ShowSyntax(
    ostream &outStr);
static void
DoInstall(
    IN LPCTSTR szProvider,
    IN LPCTSTR szInFile);
static void
DoRemove(
    void);
static void
DoClearLog(
    void);
static void
DoShowStatus(
    void);


/*++

main:

    This is the main entry point for the program.

Arguments:

    dwArgCount supplies the number of arguments.

    szrgArgs supplies the argument strings.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1997

--*/

void _cdecl
main(
    IN DWORD dwArgCount,
    IN LPCTSTR szrgArgs[])
{
    LPCTSTR szInFile = NULL;
    LPCTSTR szProvider = NULL;
    DWORD dwArgIndex = 0;
    enum TraceAction {
            Undefined = 0,
            Install,
            Remove,
            ClearLog,
            ShowStatus,
            ShowTrace,
            ScriptTrace
    } nTraceAction = Undefined;


    //
    // Check for command line options
    //

    while (NULL != szrgArgs[++dwArgIndex])
    {
        switch (SelectString(szrgArgs[dwArgIndex],
                    TEXT("INSTALL"),    TEXT("REMOVE"),     TEXT("CLEAR"),
                    TEXT("RESET"),      TEXT("STATUS"),     TEXT("PARSE"),
                    TEXT("DISPLAY"),    TEXT("SCRIPT"),     TEXT("TCL"),
                    TEXT("-FILE"),      TEXT("-PROVIDER"),  TEXT("-CSP"),
                    NULL))
        {
        case 1:     // install
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = Install;
            break;
        case 2:     // remove
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = Remove;
            break;
        case 3:     // clear
        case 4:     // reset
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ClearLog;
            break;
        case 5:     // status
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowStatus;
            break;
        case 6:     // parse
        case 7:     // display
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowTrace;
            break;
        case 8:     // script
        case 9:     // tcl
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ScriptTrace;
            break;
        case 10:    // -file
            if (NULL != szInFile)
                ShowSyntax(cerr);
            szInFile = szrgArgs[++dwArgIndex];
            if (NULL == szInFile)
                ShowSyntax(cerr);
            break;
        case 11:    // -provider
        case 12:    // -csp
            if (NULL != szProvider)
                ShowSyntax(cerr);
            szProvider = szrgArgs[++dwArgIndex];
            if (NULL == szProvider)
                ShowSyntax(cerr);
            break;
        default:
            ShowSyntax(cerr);
        }
    }


    //
    // Perform the requested Action
    //

    try
    {
        switch (nTraceAction)
        {
        case Install:
            ACTION("Installation");
            if (NULL == szInFile)
                szInFile = l_szDefaultFile;
            DoInstall(szProvider, szInFile);
            break;
        case Remove:
            ACTION("Removal");
            DoRemove();
            break;
        case ClearLog:
            ACTION("Clearing Log File");
            DoClearLog();
            break;
        case ShowStatus:
            ACTION("Displaying Status");
            DoShowStatus();
            break;
        case Undefined:
        case ShowTrace:
            ACTION("Log File Interpretation");
            if (NULL == szInFile)
                szInFile = l_szDefaultFile;
            DoShowTrace(szInFile);
            break;
        case ScriptTrace:
            ACTION("Log File Scripting");
            if (NULL == szInFile)
                szInFile = l_szDefaultFile;
            DoTclTrace(szInFile);
            break;
        default:
            ShowSyntax(cerr);
        }
    }
    catch (DWORD dwError)
    {
        cerr << TEXT("ERROR: Failed during ")
             << g_szMajorAction
             << endl;
        if (NULL != g_szMinorAction)
            cerr << TEXT("       Action: ")
                 << g_szMinorAction
                 << endl;
        if (ERROR_SUCCESS != dwError)
            cerr << TEXT("       Error:  ")
                 << CErrorString(dwError)
                 << endl;
    }
    exit(0);
}


/*++

ShowSyntax:

    Display the command line usage model.

Arguments:

    None

Return Value:

    This routine calls exit(0), so it never returns.

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

static void
ShowSyntax(
    ostream &outStr)
{
    outStr << TEXT("Usage:\n")
           << TEXT("----------------------------------------------------------\n")
           << TEXT("install [-file <logFile] [-provider <cspName>]\n")
           << TEXT("remove\n")
           << TEXT("clear\n")
           << TEXT("status\n")
           << TEXT("display [-file <logFile]\n")
           << TEXT("script [-file <logFile]\n")
           << endl;
    exit(1);
}


/*++

DoInstall:

    This routine performs an installation of the logging CSP.

Arguments:

    szProvider supplies the name of the CSP to log.  If this is NULL, the
        routine prompts for which CSP to use.

    szInFile supplies the name of the logging file.  If this is NULL, the
        default file is used.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoInstall(
    IN LPCTSTR szProvider,
    IN LPCTSTR szInFile)
{
    LPCTSTR szLogCsp = FindLogCsp();
    CRegistry regChosenCsp;
    LPCTSTR szCspImage;


    //
    // Make sure we're not already installed.
    //

    DoRemove();


    //
    // Choose the CSP to be logged.
    //

    if (NULL == szProvider)
    {
        SUBACTION("Enumerating CSPs");
        CRegistry regCsps(HKEY_LOCAL_MACHINE, l_szCspNames, KEY_READ);
        DWORD dwIndex, dwChoice;
        LPCTSTR szCsp;

        do
        {
            cout << TEXT("Choose the CSP to be logged:") << endl;
            for (dwIndex = 0;; dwIndex += 1)
            {
                szCsp = regCsps.Subkey(dwIndex);
                if (NULL == szCsp)
                    break;
                cout << TEXT("  ") << dwIndex + 1 << TEXT(") ") << szCsp << endl;
            }
            cout << TEXT("Selection: ") << flush;
            cin >> dwChoice;
        } while ((0 == dwChoice) || (dwChoice > dwIndex));

        SUBACTION("Selecting Chosen CSP");
        szCsp = regCsps.Subkey(dwChoice - 1);
        regChosenCsp.Open(regCsps, szCsp, KEY_ALL_ACCESS);
    }
    else
    {
        SUBACTION("Selecting Specified CSP");
        CRegistry regCsps(HKEY_LOCAL_MACHINE, l_szCspNames, KEY_READ);
        regChosenCsp.Open(regCsps, szProvider, KEY_ALL_ACCESS);
    }


    //
    // Wedge in the Logging CSP.
    //

    SUBACTION("Wedging the Logging CSP");
    szCspImage = regChosenCsp.GetStringValue(l_szImagePath);
    CRegistry regLogCsp(
                HKEY_LOCAL_MACHINE,
                l_szLogCspRegistry,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
    if (NULL != szInFile)
        regLogCsp.SetValue(l_szLogFile, szInFile);
    if (NULL == _tcschr(szCspImage, TEXT('%')))
        regLogCsp.SetValue(l_szTargetCsp, szCspImage, REG_SZ);
    else
        regLogCsp.SetValue(l_szTargetCsp, szCspImage, REG_EXPAND_SZ);
    regChosenCsp.SetValue(l_szImagePath, szLogCsp, REG_SZ);


    //
    // Initialize the logging file.
    //

    DoClearLog();
}


/*++

DoRemove:

    This routine Removes the Logging CSP.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoRemove(
    void)
{
    LPCTSTR szLoggedCsp = FindLoggedCsp();

    if (NULL != szLoggedCsp)
    {
        SUBACTION("Accessing Registry Keys");
        CRegistry regCsps(HKEY_LOCAL_MACHINE, l_szCspNames, KEY_READ);
        CRegistry regLoggedCsp(regCsps, szLoggedCsp);
        CRegistry regLogCsp(HKEY_LOCAL_MACHINE, l_szLogCspRegistry);
        LPCTSTR szCspImage = regLogCsp.GetStringValue(l_szTargetCsp);

        SUBACTION("Changing Registry Values");
        if (NULL == _tcschr(szCspImage, TEXT('%')))
            regLoggedCsp.SetValue(l_szImagePath, szCspImage, REG_SZ);
        else
            regLoggedCsp.SetValue(l_szImagePath, szCspImage, REG_EXPAND_SZ);
        regLogCsp.DeleteValue(l_szLogFile, TRUE);
        regLogCsp.DeleteValue(l_szTargetCsp);
    }
}


/*++

DoClearLog:

    This routine resets the log file.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoClearLog(
    void)
{
    SUBACTION("Getting Log File Name");
    CRegistry regLogCsp(HKEY_LOCAL_MACHINE, l_szLogCspRegistry, KEY_READ);
    LPCTSTR szLogFile = regLogCsp.GetStringValue(l_szLogFile);
    HANDLE hLogFile;

    SUBACTION("Creating Log File");
    hLogFile = CreateFile(
                    szLogFile,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
        throw GetLastError();
    CloseHandle(hLogFile);
}


/*++

DoShowStatus:

    This routine displays the current status of the logging CSP.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoShowStatus(
    void)
{
    LPCTSTR szLoggedCsp = NULL;
    TCHAR szLogFile[MAX_PATH] = TEXT("<Unavailable>");
    LPCTSTR szFileAccessibility = NULL;
    CErrorString szErrStr;
    DWORD dwFileSize = 0xffffffff;


    //
    // Obtain the CSP being logged.
    //

    try
    {
        szLoggedCsp = FindLoggedCsp();
        if (NULL == szLoggedCsp)
            szLoggedCsp = TEXT("<none>");
    }
    catch (DWORD)
    {
        szLoggedCsp = TEXT("<unavailable>");
    }


    //
    // Obtain the Logging file.
    //

    try
    {
        CRegistry regLogCsp(HKEY_LOCAL_MACHINE, l_szLogCspRegistry, KEY_READ);
        LPCTSTR szLogFileTmp = regLogCsp.GetStringValue(l_szLogFile);

        if (NULL != szLogFileTmp)
        {
            lstrcpy(szLogFile, szLogFileTmp);
            HANDLE hLogFile;

            hLogFile = CreateFile(
                szLogFileTmp,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
            if (INVALID_HANDLE_VALUE != hLogFile)
            {
                dwFileSize = GetFileSize(hLogFile, NULL);
                CloseHandle(hLogFile);
                szFileAccessibility = TEXT("Success");
            }
            else
            {
                szErrStr.SetError(GetLastError());
                szFileAccessibility = szErrStr.Value();
            }
        }
    }
    catch (DWORD)
    {
        lstrcpy(szLogFile , TEXT("<Unset>"));
        szFileAccessibility = TEXT("N/A");
    }


    //
    // Tell the user what we know.
    //

    cout << TEXT("CSP Logging Status:") << endl
         << TEXT("  Logged CSP:   ") << szLoggedCsp << endl
         << TEXT("  Logging File: ") << szLogFile << endl
         << TEXT("  File Status:  ") << szFileAccessibility << endl
         << TEXT("  File Size:    ");
    if (0xffffffff == dwFileSize)
        cout << TEXT("N/A") << endl;
    else
        cout << dwFileSize << TEXT(" bytes") << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\checksc\checksc.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

	CheckSC

Abstract:

    This application is used to provide a snapshot of the Calais (Smart Card
	Resource Manager) service's status, and to display certificates on smart
	cards via the common WinNT UI.

	CheckSC -- describes the RM status and displays each available sc cert(s)
			
	-r Readername	-- for just one reader
	-sig			-- display signature key certs only
	-ex				-- display exchange key certs only
	-nocert			-- don't look for certs to display
	-key			-- verify keyset public key matches cert public key

Author:

    Amanda Matlosz (AMatlosz) 07/14/1998

Environment:

    Win32 Console App

Notes:

    For use in NT5 public key rollout testing

--*/

/*++
	need to include the following libs:

    calaislb.lib (unicode build: calaislbw.lib)
	winscard.lib
--*/
#include <iostream.h>
#include <stdlib.h>
#include <stdio.h>
// #include <string.h>
// #include <stdarg.h>
#include <winscard.h>
#include <SCardLib.h>
#include <winsvc.h>
#include <scEvents.h>
#include <cryptui.h>



#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#endif

#define KERB_PKINIT_CLIENT_CERT_TYPE szOID_PKIX_KP_CLIENT_AUTH

// 
// Globals
//

int g_nKeys;
DWORD g_rgKeySet[2]; // { AT_KEYEXCHANGE , AT_SIGNATURE };
SCARDCONTEXT g_hSCardCtx;
LPTSTR g_szReaderName;
DWORD g_dwNumReaders;
BOOL g_fReaderNameAllocd;
BOOL g_fChain = FALSE;
BOOL g_fPublicKeyCheck = FALSE;
SCARD_READERSTATE* g_pReaderStatusArray;
const char* g_szEx = TEXT("exchange");
const char* g_szSig = TEXT("signature");


//
// Functions
//

///////////////////////////////////////////////////////////////////////////////
// DisplayUsage does easy UI
void DisplayUsage()
{
    cout << "\n"
         << "CheckSC [-sig|-ex|-nocert|-chain|-key] [-r \"Readername\"]\n"
		 << " -sig    Displays only signature key certificates.\n"
		 << " -ex     Displays only signature key certificates.\n"
         << " -nocert Does not display smart card certificates.\n"
         << " -chain  Check trust status.\n"  
		 << " -key    Verify keyset public key matches certificate public key.\n"
         << endl;
}

///////////////////////////////////////////////////////////////////////////////
// ProcessCommandLine does the dirty work, sets behavior globals
bool ProcessCommandLine(DWORD cArgs, LPCTSTR rgszArgs[])
{

	// set everything to default

    g_szReaderName = NULL;  // no reader
	g_rgKeySet[0] = AT_KEYEXCHANGE; // certs for both kinds of keys
	g_rgKeySet[1] = AT_SIGNATURE;
	g_nKeys = 2;
	
    if (cArgs == 1) 
    {
        return true;
    }

	// For each arg, verify that it's a real arg and deal with it

	bool fLookForReader = false;
	bool fCertOptionSpecified = false;
	bool fBogus = FALSE;

	for (DWORD n=1; n<cArgs; n++)
	{
		if ('/' == *rgszArgs[n] || '-' == *rgszArgs[n])
		{
			if (0 == _stricmp("r", rgszArgs[n]+1*sizeof(TCHAR))) // reader
			{
				fLookForReader = true;
			}
			else if (0 == _stricmp("sig",rgszArgs[n]+1*sizeof(TCHAR))) // signature cert only
			{
				if (true == fCertOptionSpecified)
				{
					// bogus!
					fBogus = true;
					break;
				}
				g_rgKeySet[0] = AT_SIGNATURE;
				g_nKeys = 1;
			}
			else if (0 == _stricmp("ex",rgszArgs[n]+1*sizeof(TCHAR))) // exchange cert only
			{
				if (true == fCertOptionSpecified)
				{
					// bogus!
					fBogus = true;
					break;
				}
				g_rgKeySet[0] = AT_KEYEXCHANGE;
				g_nKeys = 1;
			}
			else if (0 == _stricmp("nocert",rgszArgs[n]+1*sizeof(TCHAR))) // no certs
			{
				if (true == fCertOptionSpecified)
				{
					// bogus!
					fBogus = true;
					break;
				}
				g_nKeys = 0;
			}
			else if (0 == _stricmp("chain",rgszArgs[n]+1*sizeof(TCHAR))) // verify chain
			{
			    g_fChain = TRUE;

			}
			else if (0 == _stricmp("key",rgszArgs[n]+1*sizeof(TCHAR))) // verify cert & keyset
			{
				g_fPublicKeyCheck = TRUE;
			}
			else
			{
				// bogus!!
				fBogus = true;
				break;
			}
		}
		else if (fLookForReader)
		{
			fLookForReader = false;
			g_szReaderName = (LPTSTR)rgszArgs[n];
		}
		else
		{
			// Bogus!
			fBogus = true;
			break;
		}
	}

	if (!fLookForReader && !fBogus)
	{
		// All's well, we're set to go
		return true;
	}

	//
	// educate user when args incorrect
	//

	DisplayUsage();
	return false;
}


///////////////////////////////////////////////////////////////////////////////
bool IsCalaisRunning()
{
	bool fCalaisUp = false;
    HANDLE hCalaisStarted = NULL;

    HMODULE hDll = GetModuleHandle( TEXT("WINSCARD.DLL") );

    typedef HANDLE (WINAPI *PFN_SCARDACCESSSTARTEDEVENT)(VOID);
    PFN_SCARDACCESSSTARTEDEVENT pSCardAccessStartedEvent;

    pSCardAccessStartedEvent = (PFN_SCARDACCESSSTARTEDEVENT) GetProcAddress(hDll, "SCardAccessStartedEvent");

    if (pSCardAccessStartedEvent)
    {
        hCalaisStarted = pSCardAccessStartedEvent();
    }

    if (hCalaisStarted)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hCalaisStarted, 1000))
        {
            fCalaisUp = true;
        }
    }


	//
	// Display status
	//

	if (fCalaisUp)
	{
		cout << "\n"
			 << "The Microsoft Smart Card Resource Manager is running.\n"
			 << endl;
	}
	else
	{
		cout << "\n"
			 << "The Microsoft Smart Card Resource Manager is not running.\n"
			 << endl;
	}

    //
    // Clean up
    //

	return fCalaisUp;
}


///////////////////////////////////////////////////////////////////////////////
// DisplayReaderList tries to set g_hSCardCtx, get a list of currently available
// smart card readers, and display their status
void DisplayReaderList()
{
	long lReturn = SCARD_S_SUCCESS;

	cout << "Current reader/card status:\n" << endl;

	// Acquire global SCARDCONTEXT from resource manager if possible

    lReturn = SCardEstablishContext(SCARD_SCOPE_USER,
									NULL,
									NULL,
									&g_hSCardCtx);

	if (SCARD_S_SUCCESS != lReturn)
	{
		cout << "SCardEstablishContext failed for user scope.\n"
			 << "A list of smart card readers cannot be determined.\n"
			 << endl;

		return;
	}

	// Build a readerstatus array from either a list of readers; or use the one the user specified

	g_dwNumReaders = 0;
	if (NULL == g_szReaderName)
	{
		DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
		g_fReaderNameAllocd = true;
		lReturn = SCardListReaders(g_hSCardCtx,
									SCARD_DEFAULT_READERS,
									(LPTSTR)&g_szReaderName,
									&dwAutoAllocate);

		if (SCARD_S_SUCCESS != lReturn)
		{
			TCHAR szMsg[128]; // %Xx
			sprintf(szMsg, 
					"SCardListReaders failed for SCARD_ALL_READERS with: 0x%X.\n",
					lReturn);

			cout << szMsg;
			if (SCARD_E_NO_READERS_AVAILABLE == lReturn)
			{
				cout << "No smart card readers are currently available.\n";
			}
			else
			{
				cout << "A list of smart card readers could not be determined.\n";
			}
			cout << endl;

			return;
		}

		// Build a readerstatus array...

		LPCTSTR szReaderName = g_szReaderName;
		g_dwNumReaders = MStringCount(szReaderName);

		g_pReaderStatusArray = new SCARD_READERSTATE[g_dwNumReaders];
		::ZeroMemory((LPVOID)g_pReaderStatusArray, sizeof(g_pReaderStatusArray));

		szReaderName = FirstString(szReaderName);

		for (DWORD dwRdr = 0; NULL != szReaderName && dwRdr < g_dwNumReaders; szReaderName = NextString(szReaderName), dwRdr++)
		{
			g_pReaderStatusArray[dwRdr].szReader = (LPCTSTR)szReaderName;
			g_pReaderStatusArray[dwRdr].dwCurrentState = SCARD_STATE_UNAWARE;
		}
	}
	else
	{
		g_dwNumReaders = 1;
		g_pReaderStatusArray = new SCARD_READERSTATE;
		g_pReaderStatusArray->szReader = (LPCTSTR)g_szReaderName;
		g_pReaderStatusArray->dwCurrentState = SCARD_STATE_UNAWARE;
	}

	// ...And get the reader status from the resource manager
		
	lReturn = SCardGetStatusChange(g_hSCardCtx,
		                            INFINITE, // hardly
				                    g_pReaderStatusArray,
					                g_dwNumReaders);

	if (SCARD_S_SUCCESS != lReturn)
	{
		TCHAR szMsg[128]; // %Xx
		sprintf(szMsg, 
				"SCardGetStatusChange failed with: 0x%X.\n",
				lReturn);

		cout << szMsg << endl;

		sprintf(szMsg, 
				"MStringCount returned %d readers.\n",
				g_dwNumReaders);
		cout << szMsg << endl;

		return;
	}

	// Finally, display all reader information

	DWORD dwState = 0;
	for (DWORD dwRdrSt = 0; dwRdrSt < g_dwNumReaders; dwRdrSt++)
	{

		//--- reader: readerName\n
		cout << TEXT("--- reader: ") 
			<< g_pReaderStatusArray[dwRdrSt].szReader 
			<< TEXT("\n");

		//--- status: /bits/\n
		bool fOr = false;
		cout << TEXT("--- status: ");
		dwState = g_pReaderStatusArray[dwRdrSt].dwEventState;

		if (0 != (dwState & SCARD_STATE_UNKNOWN))
		{
			cout << TEXT("SCARD_STATE_UNKNOWN ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_UNAVAILABLE))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_UNAVAILABLE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_EMPTY))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_EMPTY ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_PRESENT))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_PRESENT ";)
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_EXCLUSIVE))
		{
			if (fOr)
			{
				cout << TEXT("| ";)
			}
			cout << TEXT("SCARD_STATE_EXCLUSIVE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_INUSE))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_INUSE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_MUTE))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_MUTE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_UNPOWERED))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_UNPOWERED");
			fOr = true;
		}
		cout << TEXT("\n");
		
		//--- status: what scstatus would say\n
		cout << TEXT("--- status: ");
		
		// NO CARD
		if(dwState & SCARD_STATE_EMPTY)
		{
			cout << TEXT("No card.");// SC_STATUS_NO_CARD;
		}
		// CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?
		else if(dwState & SCARD_STATE_PRESENT)
		{
			if (dwState & SCARD_STATE_MUTE)
			{
				cout << TEXT("The card is unrecognized or not responding.");// SC_STATUS_UNKNOWN;
			}
			else if (dwState & SCARD_STATE_INUSE)
			{
				if(dwState & SCARD_STATE_EXCLUSIVE)
				{
					cout << TEXT("Card is in use exclusively by another process.");// SC_STATUS_EXCLUSIVE;
				}
				else
				{
					cout << TEXT("The card is being shared by a process.");// SC_STATUS_SHARED;
				}
			}
			else
			{
				cout << TEXT("The card is available for use.");// SC_SATATUS_AVAILABLE;
			}
		}
		// READER ERROR: at this point, something's gone wrong
		else // dwState & SCARD_STATE_UNAVAILABLE
		{
			cout << TEXT("Card/Reader not responding.");// SC_STATUS_ERROR;
		}

		cout << TEXT("\n");

		//- card name(s):\n\n
		cout << TEXT("---   card: ");
		if (0 < g_pReaderStatusArray[dwRdrSt].cbAtr)
		{
			//
			// Get the name of the card
			//
			LPTSTR szCardName = NULL;
			DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
			lReturn = SCardListCards(g_hSCardCtx,
									g_pReaderStatusArray[dwRdrSt].rgbAtr,
									NULL,
									0,
									(LPTSTR)&szCardName,
									&dwAutoAllocate);
			if (SCARD_S_SUCCESS != lReturn || NULL == szCardName)
			{
				cout << TEXT("Unknown Card.");
			}
			else
			{
				LPCTSTR szName = szCardName;
				bool fNotFirst = false;
				for (szName = FirstString(szName); NULL != szName; szName = NextString(szName))
				{
					if (fNotFirst) cout << TEXT(", ");
					cout << szName;
					fNotFirst = true;
				}
			}

			if (NULL != szCardName)
			{
				SCardFreeMemory(g_hSCardCtx, (PVOID)szCardName);
			}

		}

		cout << TEXT("\n") << endl;
	}
}


///////////////////////////////////////////////////////////////////////////////
// GetCertContext -- called by DisplayCerts
PCCERT_CONTEXT GetCertContext(HCRYPTPROV* phProv, HCRYPTKEY* phKey, DWORD dwKeySpec)
{
	PCCERT_CONTEXT pCertCtx = NULL;
	LONG lResult = SCARD_S_SUCCESS;
	BOOL fSts = FALSE;

	PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    LPSTR szContainerName = NULL;
    LPSTR szProvName = NULL;
    LPWSTR wszContainerName = NULL;
	LPWSTR wszProvName = NULL;
    DWORD cbContainerName, cbProvName;
    LPBYTE pbCert = NULL;
    DWORD cbCertLen;
	int nLen = 0;

	//
	// Get the cert from this key
	//

    fSts = CryptGetKeyParam(
                *phKey,
                KP_CERTIFICATE,
                NULL,
                &cbCertLen,
                0);
    if (!fSts)
    {
        lResult = GetLastError();
        if (ERROR_MORE_DATA != lResult)
        {
            return NULL;
        }
    }
    lResult = SCARD_S_SUCCESS;
    pbCert = (LPBYTE)LocalAlloc(LPTR, cbCertLen);
    if (NULL == pbCert)
    {
        return NULL;
    }
    fSts = CryptGetKeyParam(
                *phKey,
                KP_CERTIFICATE,
                pbCert,
                &cbCertLen,
                0);
    if (!fSts)
    {
        return NULL;
    }

    //
    // Convert the certificate into a Cert Context.
    //
    pCertCtx = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    pbCert,
                    cbCertLen);
    if (NULL == pCertCtx)
    {
        lResult = GetLastError();
        goto ErrorExit;
    }

	//
	// Perform public key check
	//

	if (g_fPublicKeyCheck) // -key
	{
        cout << "\nPerforming public key matching test...\n";

		DWORD dwPCBsize = 0;

		fSts = CryptExportPublicKeyInfo(
				*phProv,        // in  
				dwKeySpec,              // in
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,     // in  
				NULL, 
				&dwPCBsize               // in, out
				);
		if (!fSts)
		{
			lResult = GetLastError();

		    TCHAR sz[256];
			sprintf(sz,"CryptExportPublicKeyInfo failed: 0x%x\n ", lResult);
			cout << sz;

			goto ErrorExit;
		}
		if (dwPCBsize == 0)
		{
			lResult = SCARD_E_UNEXPECTED; // huh?

			cout << "CryptExportPublicKeyInfo succeeded but returned size==0\n";

			goto ErrorExit;
		}

	    pInfo = (PCERT_PUBLIC_KEY_INFO)LocalAlloc(LPTR, dwPCBsize);
		if (NULL == pInfo)
		{
			lResult = E_OUTOFMEMORY;
			cout << "Could not complete key test; out of memory.\n";
			goto ErrorExit;
		}

		fSts = CryptExportPublicKeyInfo(
				*phProv,
				dwKeySpec, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
				pInfo, 
				&dwPCBsize               
				);
		if (!fSts)
		{
			lResult = GetLastError();

		    TCHAR sz[256];
			sprintf(sz,"CryptExportPublicKeyInfo failed: 0x%x\n ", lResult);
			cout << sz;

			goto ErrorExit;
		}

		fSts = CertComparePublicKeyInfo(
			  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,      
			  pInfo,										// from the private keyset
			  &(pCertCtx->pCertInfo->SubjectPublicKeyInfo)	// public key from cert
			  );
		if (!fSts)
		{
			lResult = GetLastError();
			goto ErrorExit;
		}

        cout << "Public key matching test succeeded.\n";

	}

    //
    //  Associate cryptprovider w/ the private key property of this cert
    //

    //  ... need the container name

    fSts = CryptGetProvParam(
            *phProv,
            PP_CONTAINER,
            NULL,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
    szContainerName = (LPSTR)LocalAlloc(LPTR, cbContainerName);
    fSts = CryptGetProvParam(
            *phProv,
            PP_CONTAINER,
            (PBYTE)szContainerName,
            &cbContainerName,
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
	nLen = MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			szContainerName, 
			-1, 
			NULL, 
			0);
	if (0 < nLen)
	{
		wszContainerName = (LPWSTR)LocalAlloc(LPTR, nLen*sizeof(WCHAR));

		nLen = MultiByteToWideChar(
				GetACP(),
				MB_PRECOMPOSED, 
				szContainerName,
				-1,
				wszContainerName,
				nLen);
		if (0 == nLen)
		{
			lResult = GetLastError();
			goto ErrorExit;
		}
	}

    //  ... need the provider name

    fSts = CryptGetProvParam(
            *phProv,
            PP_NAME,
            NULL,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
    szProvName = (LPSTR)LocalAlloc(LPTR, cbProvName);
    fSts = CryptGetProvParam(
            *phProv,
            PP_NAME,
            (PBYTE)szProvName,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
	nLen = MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			szProvName, 
			-1, 
			NULL, 
			0);
	if (0 < nLen)
	{
		wszProvName = (LPWSTR)LocalAlloc(LPTR, nLen*sizeof(WCHAR));

		nLen = MultiByteToWideChar(
				GetACP(),
				MB_PRECOMPOSED, 
				szProvName,
				-1,
				wszProvName,
				nLen);
		if (0 == nLen)
		{
			lResult = GetLastError();
			goto ErrorExit;
		}
	}

	//
	// Set the cert context properties to reflect the prov info
	//

    KeyProvInfo.pwszContainerName = wszContainerName;
    KeyProvInfo.pwszProvName = wszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = dwKeySpec;

    fSts = CertSetCertificateContextProperty(
                pCertCtx,
                CERT_KEY_PROV_INFO_PROP_ID,
                0, 
                (void *)&KeyProvInfo);
    if (!fSts)
    {
        lResult = GetLastError();

		// the cert's been incorrectly created -- scrap it.
		CertFreeCertificateContext(pCertCtx);
		pCertCtx = NULL;

        got