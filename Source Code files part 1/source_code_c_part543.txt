 NULL,
                                NULL );

}


/*********************************************************************/


BOOL load_registry_data( VOID )
{

   HKEY hKey;

   DWORD value_type;

   DWORD value_size;

   DWORD sizeof_value;

   BYTE value[ 4 ];

   if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "Software\\Microsoft\\SPECweb99 ISAPI",
                      0,
                      KEY_QUERY_VALUE,
                      &hKey ) )
   {

      return( FALSE );

   }

   value_size = sizeof_value = sizeof( value );

   if ( RegQueryValueEx( hKey,
                         "VECTOR_SEND_IO_MODE_CONFIG",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_vector_send_io_mode_config = *( ( DWORD* )value );
   }

   value_size = sizeof_value;

   if ( RegQueryValueEx( hKey,
                         "VECTOR_SEND_ASYNC_RANGE_START",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_vector_send_async_range_start = *( ( DWORD * )value );
   }

   value_size = sizeof( g_root_dir );

   if ( RegQueryValueEx( hKey,
                         "ROOT_DIR",
                         NULL,
                         &value_type,
                         ( BYTE * )g_root_dir,
                         &value_size ) == NO_ERROR )
   {
      g_root_dir_length = value_size - 1;
   }
   else
   {
      return( FALSE );
   }

   return( TRUE );

}


/*********************************************************************/


BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
/*++

Routine Description:

   Implementation of the GetExtensionVersion ISAPI entry point.
   Carries out general initialization tasks and provides IS with
   version information.

Arguments:

   pVer - Pointer to the version information struct to be populated.

Return Value:

   Returns TRUE.

--*/
{


   // 
   // Carry out general initialization steps.
   //

   load_registry_data();

   initialize_isapi_response_stack();

   
   //
   // Write version information.
   //

   pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, 
                                        HSE_VERSION_MAJOR );

   strcpy( pVer->lpszExtensionDesc, 
           "SPECweb99-GET ISAPI Extension");

   return( TRUE );

}


/*********************************************************************/


DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB )
/*++

Routine Description:

   Implementation of the HttpExtensionProc ISAPI entry point.
   Handles a SPECweb99 standard dynamic GET request.

Arguments:

   pECB - Pointer to the relevant extension control block.

Return Value:

   DWORD - If synchronous VectorSend is used or an error page is to be
           sent, HSE_STATUS_SUCCESS is returned.  Otherwise, if 
           asynchronous VectorSend is used, HSE_STATUS_PENDING is returned.

--*/
{

   BOOL use_async_vector_send;

   WIN32_FILE_ATTRIBUTE_DATA fileinfo;

   ISAPI_RESPONSE local_isapi_response;

   ISAPI_RESPONSE *isapi_response_ptr = &local_isapi_response;

   DWORD return_value = HSE_STATUS_SUCCESS;

   HANDLE hFile;

   CHAR filename[ MAX_PATH ];

   DWORD bytes_read;

   DWORD query_string_length = strlen( pECB->lpszQueryString );

   CHAR server_name[ 32 ];
   
   CHAR server_port[ 32 ];
   
   DWORD server_name_size = 32;

   DWORD server_port_size = 32;

   DWORD server_name_length;
   
   DWORD server_port_length;
   
   DWORD app_pool_name_size = 1024; // 1024 == sizeof( g_app_pool_name )

   DWORD ii;
   

   if ( InterlockedExchange( &g_fragment_cache_key_base_not_initialized, 0 ) )
   {

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "SERVER_NAME",
                                     server_name,
                                     &server_name_size ) )
      {

         return( HSE_STATUS_ERROR );

      }

      server_name_length = server_name_size - 1;

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "SERVER_PORT",
                                     server_port,
                                     &server_port_size ) )
      {

         return( HSE_STATUS_ERROR );

      }

      server_port_length = server_port_size - 1;

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "APP_POOL_ID",
                                     g_app_pool_name,
                                     &app_pool_name_size ) )
      {
        
        return( HSE_STATUS_ERROR );

      }

      g_app_pool_name_length = app_pool_name_size - 1;

      strcpy( g_fragment_cache_key_base, g_app_pool_name );

      memcpy( g_fragment_cache_key_base + g_app_pool_name_length, "/http://", 8 );

      ii = g_app_pool_name_length + 8;

      memcpy( g_fragment_cache_key_base + ii, server_name, server_name_length );

      ii += server_name_length;

      g_fragment_cache_key_base[ ii ] = ':';

      ii += 1;

      memcpy( g_fragment_cache_key_base + ii, server_port, server_port_length );

      ii += server_port_length;

      g_fragment_cache_key_base[ ii ] = '/';

      g_fragment_cache_key_base[ ii + 1 ] = '\0';

      g_fragment_cache_key_base_length = strlen( g_fragment_cache_key_base );

   }


   //
   // Determine the size of the file requested.
   //

   memcpy( filename, g_root_dir, g_root_dir_length );

   memcpy( filename + g_root_dir_length, pECB->lpszQueryString, query_string_length + 1 );

   if ( !GetFileAttributesEx( filename,
                              GetFileExInfoStandard,
                              &fileinfo ) )
   {

      return( send_error_page( pECB,
                               "File inaccessible.",
                               g_pszStatus_404,
                               query_string_length ) );

   }


   //
   // Determine the I/O mode to use with VectorSend.
   //

   switch( g_vector_send_io_mode_config )
   {

      case USE_ASYNC_IO:
      {

         use_async_vector_send = TRUE;

         break;

      }

      case USE_SYNC_IO:
      {

         use_async_vector_send = FALSE;

         break;

      }

      case USE_ADAPTABLE_IO:
      {

         use_async_vector_send = ( fileinfo.nFileSizeLow >= g_vector_send_async_range_start );

         break;

      }

   }


   //
   // Set isapi_response_ptr to point to an ISAPI response struct on
   // the heap if using asynchronous I/O.  Also set the VectorSend
   // completion callback and return value.
   //

   if ( use_async_vector_send )
   {

      if ( !( isapi_response_ptr = allocate_isapi_response() ) )
      {

         return( HSE_STATUS_ERROR );

      }

      pECB->ServerSupportFunction( pECB->ConnID,
                                   HSE_REQ_IO_COMPLETION,
                                   vector_send_completion_callback,
                                   NULL,
                                   ( DWORD * )isapi_response_ptr );

      return_value = HSE_STATUS_PENDING;

   }


   //
   // Initialize the ISAPI response struct.
   //

   initialize_isapi_response( isapi_response_ptr,
                              pECB, 
                              fileinfo.nFileSizeLow, 
                              use_async_vector_send,
                              query_string_length );


   //
   // Execute the VectorSend operation. If ServerSupportFunction 
   // returns TRUE, handle the cache hit case.  Otherwise, assume 
   // a cache miss and handle it.
   //

   if ( pECB->ServerSupportFunction( pECB->ConnID,
                                     HSE_REQ_VECTOR_SEND,
                                     &( isapi_response_ptr->response_vector ),
                                     NULL,
                                     NULL ) )
   {

      return( return_value );

   }          


   //
   // Get a handle to the file requested.
   //

   if ( ( hFile = CreateFile( filename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL ) ) == INVALID_HANDLE_VALUE )
   {

      if ( use_async_vector_send )
      {
      
         free_isapi_response( isapi_response_ptr );

      }

      return( send_error_page( pECB,
                               "File inaccessible.",
                               g_pszStatus_404,
                               query_string_length ) );

   }
    

   //
   // Add the file data to the HTTP.SYS fragment cache.
   //

   isapi_response_ptr->vector_element.ElementType = HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE;

   isapi_response_ptr->vector_element.pvContext = hFile;

   isapi_response_ptr->vector_element.cbSize = fileinfo.nFileSizeLow;

   isapi_response_ptr->vector_element.cbOffset = 0; 

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_ADD_FRAGMENT_TO_CACHE,
                                      &isapi_response_ptr->vector_element,
                                      ( DWORD * )isapi_response_ptr->unicode_fragment_cache_key,
                                      NULL ) )
   {

      isapi_response_ptr->vector_element_array[ 5 ] = isapi_response_ptr->vector_element;

      if ( use_async_vector_send )
      {

         isapi_response_ptr->hFile = hFile;

      }

      if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_VECTOR_SEND,
                                         &( isapi_response_ptr->response_vector ),
                                         NULL,
                                         NULL ) )
      {

         if ( use_async_vector_send )
         {

            isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

            free_isapi_response( isapi_response_ptr );

         }

         CloseHandle( hFile );

         return( HSE_STATUS_ERROR );

      }
      if ( !use_async_vector_send )
      {
          CloseHandle( hFile );
      }

      return( return_value );

   }


   //
   // Retry the VectorSend.
   //

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_VECTOR_SEND,
                                      &( isapi_response_ptr->response_vector ),
                                      NULL,
                                      NULL ) )
   {

      isapi_response_ptr->vector_element_array[ 5 ] = isapi_response_ptr->vector_element;

      if ( use_async_vector_send )
      {

         isapi_response_ptr->hFile = hFile;

      }

      if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_VECTOR_SEND,
                                         &( isapi_response_ptr->response_vector ),
                                         NULL,
                                         NULL ) )
      {

         if ( use_async_vector_send )
         {

            isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

            free_isapi_response( isapi_response_ptr );

         }

         CloseHandle( hFile );

         return( HSE_STATUS_ERROR );

      }

   }

   if ( !use_async_vector_send )
   {
       CloseHandle( hFile );
   }

   return( return_value );

}


/*********************************************************************/


BOOL WINAPI TerminateExtension( DWORD dwFlags )
/*++

Routine Description:

   Carries out all cleanup tasks.

Arguments:

    dwFlags - A DWORD that specifies whether IIS should shut down the
              extension.

Return Value:

   Returns TRUE.

--*/
{


   //
   // Carry out cleanup tasks.
   //

   clear_isapi_response_stack();

   return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\common\html.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "resource.h"

void StartHTML(char * title, int fNoCache)
{
        char szExpireMsg[_MAX_PATH];
        char szReturnMsg[_MAX_PATH];
        char szReturnHtmlMsg[_MAX_PATH*4];
        HINSTANCE hInst = GetModuleHandle(NULL);

        LoadString(hInst, IDS_EXPIREMSG, szExpireMsg, sizeof(szExpireMsg));
        LoadString(hInst, IDS_RETURNMSG, szReturnMsg, sizeof(szReturnMsg));
        LoadString(hInst, IDS_RETURNHTMLMSG, szReturnHtmlMsg, sizeof(szReturnHtmlMsg));
        if (fNoCache)
                printf("%s\r\n", szExpireMsg);

    printf( szReturnHtmlMsg, title, szReturnMsg);
}

void EndHTML()
{
    char szEndHtml[_MAX_PATH];

    HINSTANCE hInst = GetModuleHandle(NULL);
    LoadString(hInst, IDS_ENDHTML, szEndHtml, sizeof(szEndHtml));
    printf( szEndHtml );
}


// translates HTTP escapes to ASCII equivalents
// assumes HTTP escapes are of the form %dd, where the first digit is 0-9 and
// the second is 0-F
void TranslateEscapes(char * p, long l)
{
        char * p2;
        int c1;
        int c2;

        for(p2=p; l; l--) {
                if (*p == '+' )
                        *p = ' ';

                if (*p == '%' && *(p+1) != '%') {
                        p++;
                        c1=toupper(*p);
                        c2=toupper(*(p+1));

                        //*p2++ = (*p-'0')*16 + ((*(p+1))>= 'A' ? *(p+1)-'A'+10 : *(p+1)-'0');

                        *p2++ = (c1>='A' ? c1-'A'+10 : c1-'0')*16 +
                                    (c2>='A' ? c2-'A'+10 : c2-'0');

                        p += 2;
            l -= 2;
            }
                else
                        *p2++=*p++;
        }

}


//
// This is like TranslateEscapes but fixes a problem where the description
// string gets broken
//

void
TranslateEscapes2(
                char * p,
                long len
                )
{
    char * p2;
    int c1;
    int c2;

    for(p2=p; len > 0; len--) {

        if (*p == '+' ) {
            *p = ' ';
        }

        if (*p == '%' && *(p+1) != '%') {

            p++;

            c1=toupper(*p);
            c2=toupper(*(p+1));

            //*p2++ = (*p-'0')*16 + ((*(p+1))>= 'A' ? *(p+1)-'A'+10 : *(p+1)-'0');

            *p2 = (c1>='A' ? c1-'A'+10 : c1-'0')*16 +
                                (c2>='A' ? c2-'A'+10 : c2-'0');

            if (*p2 == '+' ) {
                *p2 = ' ';
            }

            ++p2;

            p += 2;
            len -= 2;

        } else {
            *p2++=*p++;
        }
    }

    *p2 = '\0';

} // TranslateEscapes2



void
ConvertSP2Plus(
    char * String1,
    char * String2
    )
{
    char *p = String1;
    char *q = String2;
    char ch;

    do {

        ch = *p;

        *q = (ch == ' ') ? '+' : ch;

        ++p;
        ++q;

    } while (ch != '\0');

    return;

} // ConvertSP2Plus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\common\dynodbc.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      dynodbc.h

   Abstract:
      This header declares functions for dynamically loading ODBC.

   Author:

       Murali R. Krishnan    ( MuraliK )    3-Nov-1995

   Environment:
       Win32 -- User Mode

   Project:
   
      

   Revision History:
      kyleg 1/9/96  Added SQLConfigDatasource from odbc installer
	                currently only used in NEWDSN.C

--*/

# ifndef _DYNODBC_H_
# define _DYNODBC_H_

/************************************************************
 *     Include Headers
 ************************************************************/


//
// SQL-ODBC interface headers
//
# include "sql.h"
# include "sqlext.h"
# include <odbcinst.h>


/************************************************************
 *   Dynamic Load support
 ************************************************************/

BOOL
DynLoadODBC(
    VOID
    );

//
//  Prototypes form sql.h
//

typedef RETCODE (SQL_API * pfnSQLAllocConnect)(
    HENV        henv,
    HDBC   FAR *phdbc);

typedef RETCODE (SQL_API * pfnSQLAllocEnv)(
    HENV   FAR *phenv);

typedef RETCODE (SQL_API * pfnSQLAllocStmt)(
    HDBC        hdbc,
    HSTMT  FAR *phstmt);

typedef RETCODE (SQL_API * pfnSQLBindCol)(
    HSTMT       hstmt,
    UWORD       icol,
    SWORD       fCType,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLCancel)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLColAttributes)(
    HSTMT       hstmt,
    UWORD       icol,
    UWORD       fDescType,
    PTR         rgbDesc,
	SWORD       cbDescMax,
    SWORD  FAR *pcbDesc,
    SDWORD FAR *pfDesc);

typedef RETCODE (SQL_API * pfnSQLConnect)(
    HDBC        hdbc,
    UCHAR  FAR *szDSN,
    SWORD       cbDSN,
    UCHAR  FAR *szUID,
    SWORD       cbUID,
    UCHAR  FAR *szAuthStr,
    SWORD       cbAuthStr);

typedef RETCODE (SQL_API * pfnSQLDescribeCol)(
    HSTMT       hstmt,
    UWORD       icol,
    UCHAR  FAR *szColName,
    SWORD       cbColNameMax,
    SWORD  FAR *pcbColName,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable);

typedef RETCODE (SQL_API * pfnSQLDisconnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLError)(
    HENV        henv,
    HDBC        hdbc,
    HSTMT       hstmt,
    UCHAR  FAR *szSqlState,
    SDWORD FAR *pfNativeError,
    UCHAR  FAR *szErrorMsg,
    SWORD       cbErrorMsgMax,
    SWORD  FAR *pcbErrorMsg);

typedef RETCODE (SQL_API * pfnSQLExecDirect)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLExecute)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFetch)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFreeConnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLFreeEnv)(
    HENV        henv);

typedef RETCODE (SQL_API * pfnSQLFreeStmt)(
    HSTMT       hstmt,
    UWORD       fOption);

typedef RETCODE (SQL_API * pfnSQLGetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursorMax,
    SWORD  FAR *pcbCursor);

typedef RETCODE (SQL_API * pfnSQLNumResultCols)(
    HSTMT       hstmt,
    SWORD  FAR *pccol);

typedef RETCODE (SQL_API * pfnSQLPrepare)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLRowCount)(
    HSTMT       hstmt,
    SDWORD FAR *pcrow);

typedef RETCODE (SQL_API * pfnSQLSetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursor);

typedef RETCODE (SQL_API * pfnSQLTransact)(
    HENV        henv,
    HDBC        hdbc,
    UWORD       fType);

//
//  Prototypes form sqlext.h
//

typedef RETCODE (SQL_API * pfnSQLSetConnectOption)(
    HDBC        hdbc,
    UWORD       fOption,
    UDWORD      vParam);

typedef RETCODE (SQL_API * pfnSQLDrivers)(
    HENV        henv,
    UWORD       fDirection,
	UCHAR FAR  *szDriverDesc,
	SWORD		cbDriverDescMax,
	SWORD FAR  *pcbDriverDesc,
	UCHAR FAR  *szDriverAttributes,
    SWORD       cbDrvrAttrMax,
    SWORD  FAR *pcbDrvrAttr);

typedef RETCODE (SQL_API * pfnSQLBindParameter)(
    HSTMT       hstmt,
	UWORD		ipar,
	SWORD		fParamType,
    SWORD       fCType,
	SWORD		fSqlType,
    UDWORD      cbColDef,
    SWORD       ibScale,
    PTR         rgbValue,
	SDWORD		cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLDataSources)(
    HENV        henv,
    UWORD       fDirection,
    UCHAR  FAR *szDSN,
    SWORD       cbDSNMax,
    SWORD  FAR *pcbDSN,
    UCHAR  FAR *szDescription,
    SWORD       cbDescriptionMax,
    SWORD  FAR *pcbDescription);

typedef BOOL (INSTAPI * pfnSQLConfigDataSource) (
    HWND       hwndParent,
	WORD       fRequest,
    LPCSTR     lpszDriver,
    LPCSTR     lpszAttributes);




/************************************************************
 *   Variables  
 ************************************************************/

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

extern pfnSQLAllocConnect        pSQLAllocConnect   ;
extern pfnSQLAllocEnv            pSQLAllocEnv       ;
extern pfnSQLAllocStmt           pSQLAllocStmt      ;
extern pfnSQLBindCol             pSQLBindCol        ;
extern pfnSQLCancel              pSQLCancel         ;
extern pfnSQLColAttributes       pSQLColAttributes  ;
extern pfnSQLConnect             pSQLConnect        ;
extern pfnSQLDescribeCol         pSQLDescribeCol    ;
extern pfnSQLDisconnect          pSQLDisconnect     ;
extern pfnSQLError               pSQLError          ;
extern pfnSQLExecDirect          pSQLExecDirect     ;
extern pfnSQLExecute             pSQLExecute        ;
extern pfnSQLFetch               pSQLFetch          ;
extern pfnSQLFreeConnect         pSQLFreeConnect    ;
extern pfnSQLFreeEnv             pSQLFreeEnv        ;
extern pfnSQLFreeStmt            pSQLFreeStmt       ;
extern pfnSQLGetCursorName       pSQLGetCursorName  ;
extern pfnSQLNumResultCols       pSQLNumResultCols  ;
extern pfnSQLPrepare             pSQLPrepare        ;
extern pfnSQLRowCount            pSQLRowCount       ;
extern pfnSQLSetCursorName       pSQLSetCursorName  ;
extern pfnSQLTransact            pSQLTransact       ;

extern pfnSQLSetConnectOption    pSQLSetConnectOption;
extern pfnSQLDrivers             pSQLDrivers         ;
extern pfnSQLDataSources         pSQLDataSources     ;
extern pfnSQLBindParameter       pSQLBindParameter   ;

/* from odbcinst.h*/
extern pfnSQLConfigDataSource    pSQLConfigDataSource;


# endif // _DYNODBC_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\server\caldbg.h ===
/*
 *	C A L D B G . H
 *
 *	Debugging support header
 *	Support functions are implemented in CALDBG.C.
 *
 *	Copyright 1986-1997 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _CALDBG_H_
#define _CALDBG_H_

#include <malloc.h>

/*
 * Debugging Macros -------------------------------------------------------
 *
 *		IFDBG(x)		Results in the expression x if DBG is defined, or
 *						to nothing if DBG is not defined
 *
 *		IFNDBG(x)		Results in the expression x if DBG is not defined,
 *						or to nothing if DBG is defined
 *
 *		Unreferenced(a) Causes a to be referenced so that the compiler
 *						doesn't issue warnings about unused local variables
 *						which exist but are reserved for future use (eg
 *						ulFlags in many cases)
 */
#if defined(DBG)
#define IFDBG(x)			x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)			x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN		extern "C" {
#define EXTERN_C_END		}
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

/*
 *	 Assert Macros ------------------------------------------------------------
 *
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.	 OK'ing an assert traps
 *						into the debugger.
 *
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 */
#if defined(DBG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))

#define Assert(t)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))

#define SideAssert(t)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)


/*
 *	 Trace Macros -------------------------------------------------------------
 *
 *		DebugTrace			Use for arbitrary formatted output. It
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceNoCRLF	Same as DebugTrace, but doesn't add "\r\n".
 *							Good for writing a trace that is part of a longer line.
 *		TraceError			DebugTrace the function name (_func, any string)
 *							INI file entries allow you to filter based on the
 *							error code's failing/succeeding status.
 */

#if defined(DBG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#define DebugTraceCRLF		DebugTraceCRLFFn
#define DebugTraceNoCRLF	DebugTraceNoCRLFFn
#define TraceErrorEx(_err,_func,_flag)	TraceErrorFn(_err,_func,__FILE__,__LINE__,_flag)
#define TraceError(_err,_func)			TraceErrorEx(_err,_func,FALSE)
#else
#define IFTRACE(x)			0
#define DebugTrace			NOP_FUNCTION
#define DebugTraceCRLF		NOP_FUNCTION
#define DebugTraceNoCRLF	NOP_FUNCTION
#define TraceErrorEx(_err,_func,_flag)	NOP_FUNCTION
#define TraceError(_err,_func)			TraceErrorEx(_err,_func,FALSE)
#endif

/*	------------------------------------------------------------------------
 *
 *	.INI triggered traces
 */

#ifdef DBG
#define DEFINE_TRACE(trace)		__declspec(selectany) int g_fTrace##trace = FALSE
#define DO_TRACE(trace)			!g_fTrace##trace ? 0 : DebugTraceFn
#define INIT_TRACE(trace)		g_fTrace##trace = GetPrivateProfileInt( gc_szDbgTraces, #trace, FALSE, gc_szDbgIni )
//	Convenience macro for DBG code.  Will cause an error on non-debug builds.
#define DEBUG_TRACE_TEST(trace)	g_fTrace##trace
#else
#define DEFINE_TRACE(trace)
#define DO_TRACE(trace)			DebugTrace
#define INIT_TRACE(trace)
//#define DEBUG_TRACETEST(trace)	// Purposefully cause an error on non-debug builds
#endif

/* Debugging Functions ---------------------------------------------------- */

#define EXPORTDBG

EXTERN_C_BEGIN

INT EXPORTDBG __cdecl DebugTrapFn (int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceCRLFFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceNoCRLFFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl TraceErrorFn (DWORD error, char *pszFunction,
									char *pszFile, int iLine,
									BOOL fEcTypeError);

EXTERN_C_END

/* Debugging Strings ------------------------------------------------------ */

EXTERN_C_BEGIN

//	Inifile name -- must be set by calling code!
extern const CHAR gc_szDbgIni[];
extern const INT gc_cchDbgIni;

//	Strings set in caldbg.c for use in calling code.
extern const CHAR gc_szDbgDebugTrace[];
extern const CHAR gc_szDbgEventLog[];
extern const CHAR gc_szDbgGeneral[];
extern const CHAR gc_szDbgLogFile[];
extern const CHAR gc_szDbgTraces[];
extern const CHAR gc_szDbgUseVirtual[];

EXTERN_C_END

/* Virtual Allocations ---------------------------------------------------- */

EXTERN_C_BEGIN

VOID * EXPORTDBG __cdecl VMAlloc(ULONG);
VOID * EXPORTDBG __cdecl VMAllocEx(ULONG, ULONG);
VOID * EXPORTDBG __cdecl VMRealloc(VOID *, ULONG);
VOID * EXPORTDBG __cdecl VMReallocEx(VOID *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl VMGetSize(VOID *);
ULONG EXPORTDBG __cdecl VMGetSizeEx(VOID *, ULONG);
VOID EXPORTDBG __cdecl VMFree(VOID *);
VOID EXPORTDBG __cdecl VMFreeEx(VOID *, ULONG);

EXTERN_C_END

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\common\html.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      html.h

   Abstract:
      This header declares functions for starting and ending an HTML page.

   Author:

     Kyle Geiger (kyleg)  1995-12-1

   Revision History:

--*/


# ifndef _HTML_H_
# define _HTML_H_


void StartHTML(char * s, int fNoCache);
void EndHTML();
void TranslateEscapes(char * p, DWORD l);
void TranslateEscapes2(char * p, DWORD l);

//
// Converts SPACE to + for cgi arguments
//

void
ConvertSP2Plus(
    char * String1,
    char * String2
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\common\resource.h ===
// Used by dynodbc.rc
#define IDS_ERRORMSG                    1
#define IDS_ODBCERRMSG                  2

// Used by html.rc
#define IDS_EXPIREMSG                   3
#define IDS_RETURNMSG                   4
#define IDS_RETURNHTMLMSG               5
#define IDS_ENDHTML                     7
#define IDS_CREATE_ODBC_FAIL    8
#define IDS_CREATE_ODBC         10
#define IDS_DSNFORMEXE          11
#define IDS_LIST_ODBC_DRIVERS   12
#define IDS_ACCESS_DRIVER       13
#define IDS_DRIVER              14
#define IDS_DSN                 15
#define IDS_SQL_SERVER          16
#define IDS_SERVER              17
#define IDS_ACCESS_DRIVER_1     18
#define IDS_NEWDB               19
#define IDS_DBQ_EQUAL           20
#define IDS_DBQ                 21
#define IDS_GENERAL             22
#define IDS_ATTR                23
#define IDS_CREATE_DB           24
#define IDS_START_ODBC          25
#define IDS_DATASOURCE_CREATE   26
#define IDS_SUCCESSFUL          27
#define IDS_FAILED              28
#define IDS_SERVER_NAME_ATTR_STR    29
#define IDS_DATABASE_NAME_ATTR_STR  30
#define IDS_SPECIFY_ODBC        31
#define IDS_CREATE_ODBC_GETDRVR 32
#define IDS_CREATE_LOG_TABLE    33
#define IDS_ATTEMPT_CREATE_LOG  34
#define IDS_SELECT_NAME         35
#define IDS_OPTION              36
#define IDS_SELECT              37
#define IDS_CREATE_MS_LOG       38
#define IDS_CREATE_MS_LOG_2     39
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\mkilog\mkilog.c ===
/*++
  
  Copyright (c) 1994  Microsoft Corporation
  
  Module Name:
  
  mkilog.c
  
  Abstract:
  
  This module creates a log table using ODBC data sources.
  
  Author:
  
  Kyle Geiger & Murali R. Krishnan  (MuraliK)  1-Nov-1995
  
  Revision History:
  
  --*/


#include <windows.h>
#include <stdio.h>

# include "dynodbc.h"
#include "html.h"
#include "resource.h"

# define DEFAULT_LEN       ( 256)
# define MAX_DATA       2048

# define FOUND_DRIVER   ( 7)
#define SUCCESS(rc)    (!((rc)>>1))


int __cdecl
main( int argc, char * argv[])
{
    RETCODE rc;          // Return code for ODBC functions
    HENV    henv;           // Environment Handle
    char    szDSN[MAX_DATA+1];  // Variable to hold DSN name
    SWORD   cbDSN;         // Output length of data DSN
    char    szDesc[MAX_DATA+1]; // Variable to hold DSN description
    SWORD   cbDesc;        // Output length of data description
    int     fFirst;
    char    szList[MAX_DATA];
    char    szSQLServer[MAX_DATA];
    char    szCreateLogTable[MAX_DATA];
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ( !DynLoadODBC()) 
        return (1);

    
    pSQLAllocEnv(&henv);
    rc=pSQLDrivers(henv, SQL_FETCH_FIRST, 
                   (UCHAR FAR *) szDSN, 
                   MAX_DATA, &cbDSN, 
                   (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);

    LoadString(hInst, IDS_SQL_SERVER, szSQLServer, sizeof(szSQLServer));
    while (SUCCESS(rc)) {
        if (!_stricmp(szDSN, szSQLServer) )
          rc=FOUND_DRIVER;
        else
          rc=pSQLDrivers(henv, SQL_FETCH_NEXT, 
                         (UCHAR FAR * ) szDSN, MAX_DATA, &cbDSN, 
                         (UCHAR FAR * ) szDesc, MAX_DATA, &cbDesc);
    }
    LoadString(hInst, IDS_CREATE_LOG_TABLE, szCreateLogTable, sizeof(szCreateLogTable));
    StartHTML(szCreateLogTable, 1);
    if (FOUND_DRIVER != rc) {
        char    szAttemptCreateLog[MAX_DATA*3];
        LoadString(hInst, IDS_ATTEMPT_CREATE_LOG, szAttemptCreateLog, sizeof(szAttemptCreateLog));
        printf( szAttemptCreateLog);
        pSQLFreeEnv(henv);
        return (1);
    }

    rc=pSQLDataSources(henv, SQL_FETCH_FIRST, 
                       (UCHAR FAR *) szDSN, MAX_DATA, &cbDSN, 
                       (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);

    fFirst=FALSE;
    while (SUCCESS(rc)) {
        if (!_stricmp(szDesc, szSQLServer) ) {
            char    szOption[MAX_DATA];
            if (!fFirst) {
                char    szSelectName[MAX_DATA];
                fFirst=TRUE;
                LoadString(hInst, IDS_SELECT_NAME, szSelectName, sizeof(szSelectName));
                strcpy(szList,szSelectName);
            }
            LoadString(hInst, IDS_OPTION, szOption, sizeof(szOption));
            sprintf(szList+strlen(szList),szOption, szDSN);
        }
        rc=pSQLDataSources(henv, SQL_FETCH_NEXT, 
                           (UCHAR FAR *) szDSN, MAX_DATA, &cbDSN, 
                           (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);
    } // while data sources found

    /* any datasources for SQL Server found?  if so, generate the form for create*/
    if (fFirst) {
        char    szSelect[MAX_DATA];
        char    szCreateMSLog[MAX_DATA*3];
        LoadString(hInst, IDS_SELECT, szSelect, sizeof(szSelect));
        strcat(szList, szSelect);

        LoadString(hInst, IDS_CREATE_MS_LOG, szCreateMSLog, sizeof(szCreateMSLog));
        printf( szCreateMSLog, szList);
    }
    else {
        char    szCreateMSLog[MAX_DATA*3];
        LoadString(hInst, IDS_CREATE_MS_LOG_2, szCreateMSLog, sizeof(szCreateMSLog));
        printf( szCreateMSLog );
        
    }
    EndHTML(); 
    pSQLFreeEnv(henv);
    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\newdsn\newdsn.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  newdsn.c

  Abstract:

  This module creates a data source given information from DSNFORM.EXE

  Author:

  Kyle Geiger

  Revision History:

  --*/


#include <windows.h>
#include <stdio.h>
#include <odbcinst.h>
#include "dynodbc.h"
#include "cgi.h"
#include "html.h"
#include "resource.h"

# define MAX_DATA       1024

#define SUCCESS(rc)    (!((rc)>>1))


int __cdecl
main( int argc, char * argv[])
{
    BOOL rc;          // Return code for ODBC functions
    char    rgchQuery[MAX_DATA];
    long    dwLen;
        char *  p;
        char    szDriver[MAX_DATA];
        char *  pszDriver;
        char    szAttr[MAX_DATA];
        char *  pszAttr;
        char    szAttr2[MAX_DATA];
        char *  pszAttr2;
        BOOL    fCreateDB=FALSE;
        char    szAccessDriver[MAX_DATA];
        char    szDsn[MAX_DATA];
        char    szSQLServer[MAX_DATA];
        char    szServer[MAX_DATA];
        char    szNewDB[MAX_DATA];
        char    szDBQ[MAX_DATA];
        char    szDBQEqual[MAX_DATA];
        char    szGeneral[MAX_DATA];
        char    szTmp[MAX_DATA];
        char    szSuccessful[MAX_DATA];
        char    szFail[MAX_DATA];
        HINSTANCE hInst = GetModuleHandle(NULL);

    if ( !DynLoadODBC())
        return (1);

    // get dsn name, custom attributes, and attribute string from form
    dwLen = GetEnvironmentVariableA( PSZ_QUERY_STRING_A, rgchQuery, MAX_DATA);
        if (!dwLen)
        {
        // debugging cases
        /*
        strcpy(rgchQuery, "driver=SQL%20Server&dsn=foo2&attr=server%3D%7Bkyleg0%7D%3Bdbq%3Dpubs");
        strcpy(rgchQuery, "driver=Microsoft Access Driver (*.mdb)&dsn=foo4&dbq=c%3A%5Cfoo4.mdb&newdb=CREATE_DB&attr=");
        strcpy(rgchQuery, "driver=Microsoft Access Driver (*.mdb)&dsn=foo5&dbq=c%3A%5Cfoo4.mdb&newdb=dbq&attr=");
        */
        LoadString(hInst, IDS_ACCESS_DRIVER, szAccessDriver, sizeof(szAccessDriver));
        strcpy(rgchQuery, szAccessDriver);
        dwLen=strlen(rgchQuery);

        }

        // get rid of percent junk
        TranslateEscapes2(rgchQuery, dwLen);

        LoadString(hInst, IDS_DRIVER, szDriver, sizeof(szDriver));
        // find driver name from URL
        p=strstr(rgchQuery, szDriver)+7;
        pszDriver=szDriver;
        for(;p && *p && *p!='&'; p++)
                *pszDriver++= *p;
        *pszDriver++='\0';

        LoadString(hInst, IDS_DSN, szDsn, sizeof(szDsn));
        // find dsn name from URL, put in  attribute string
        p=strstr(rgchQuery, szDsn);
        pszAttr=szAttr;
        for(; p && *p && *p!='&'; p++)
                *pszAttr++= *p;
        *pszAttr++='\0';

        LoadString(hInst, IDS_SQL_SERVER, szSQLServer, sizeof(szSQLServer));
        LoadString(hInst, IDS_SERVER, szServer, sizeof(szServer));
        LoadString(hInst, IDS_ACCESS_DRIVER_1, szAccessDriver, sizeof(szAccessDriver));
        LoadString(hInst, IDS_NEWDB, szNewDB, sizeof(szNewDB));
        LoadString(hInst, IDS_DBQ, szDBQ, sizeof(szDBQ));
        LoadString(hInst, IDS_DBQ_EQUAL, szDBQEqual, sizeof(szDBQEqual));
        LoadString(hInst, IDS_GENERAL, szGeneral, sizeof(szGeneral));
        // do special case processing for certain drivers (sql server, access, ddp, other)
        if (!strcmp(szDriver, szSQLServer)) {
                // find server name from URL, put in  attribute string
                p=strstr(rgchQuery, szServer);
                for(; p && *p && *p!='&'; p++)
                        *pszAttr++= *p;
                *pszAttr++='\0';
        }
        else if (!strcmp(szDriver, szAccessDriver)) {
                // find database name from URL, put in  attribute string
                // the radio button group 'newdb' return either CREATE_DB for a new database
                // or DBQ for an existing MDB file
                // the edit control for the database name ('dbq') is appended after the CREATE_DB
                // or DBQ attribute
                p=strstr(rgchQuery, szNewDB)+6;
                fCreateDB=(*p=='C');

                // if creating a database, also need to add the dsn pointing to it
                // this requires two different attribute strings, one like:
                //    dsn=foo;CREATE_DB=<filename>, where the dsn is ignored
                // which is derived from
                //    dsn=foo&newdb=CREATE_DB&dbq=<filename>
                // and
                //    dsn=foo;dbq=<filename>
                // which is derived from
                //    dsn=foo&newdb=dbq&dbq=<filename>
                if (fCreateDB) {
                        strcpy(szAttr2, szAttr);
                        for(; p && *p && *p!='&'; p++)
                                *pszAttr++= *p;
                        // assert: szAttr= "driver=foo\0dsn=bar\0CREATE_DB"
                        // assert: szAttr2= "driver=foo\0dsn=bar\0"
                    p = strstr(rgchQuery, szDBQEqual)+3;
                        pszAttr2=szAttr2+strlen(szAttr2)+1;
                        strcpy(pszAttr2,szDBQ);
                        // assert: szAttr2= "driver=foo\0dsn=bar\0dbq"
                        pszAttr2+=3;
                        for(; p && *p && *p!='&'; p++) {
                            *pszAttr++= *p;
                                *pszAttr2++= *p;
                            }
                        // assert: szAttr= "driver=foo\0dsn=bar\0CREATE_DB=<filename>"
                        // assert: szAttr2= "driver=foo\0dsn=bar\0dbq=<filename>"
                        strcpy(pszAttr, szGeneral);
                    pszAttr+=9;
                        *pszAttr2++='\0';
                        *pszAttr2='\0';

                        // assert: szAttr= "driver=foo\0dsn=bar\0CREATE_DB=<filename> General"

                }
                else {
                p = strstr(rgchQuery, szDBQEqual);
                        for(; p && *p && *p!='&'; p++)
                           *pszAttr++= *p;
                }


        }

        LoadString(hInst, IDS_ATTR, szTmp, sizeof(szTmp));
        // now add any additional items from attribute string
        p=strstr(rgchQuery, szTmp);
        if (p != NULL) {
                p+=5;

        for(; p && *p && *p!='&'; p++) {
                if ( *p == ';' ) {
                        *pszAttr++='\0';
                } else if ( *p == '+') {
                        *pszAttr++=' ';
                } else {
                        *pszAttr++ = *p;
            }
        }
    }

        *pszAttr='\0';

         // call ODBC to add the data source
    rc= SQLConfigDataSource(NULL, ODBC_ADD_SYS_DSN, szDriver, szAttr);

        LoadString(hInst, IDS_CREATE_DB, szTmp, sizeof(szTmp));
        // special case for Access:  if just created a database, now need to add the DSN
        if (rc && strstr(rgchQuery, szTmp)) {
                rc= SQLConfigDataSource(NULL, ODBC_ADD_SYS_DSN, szDriver, szAttr2);
        }

        LoadString(hInst, IDS_START_ODBC, szTmp, sizeof(szTmp));
        StartHTML(szTmp, 1);
        LoadString(hInst, IDS_DATASOURCE_CREATE, szTmp, sizeof(szTmp));
        LoadString(hInst, IDS_SUCCESSFUL, szSuccessful, sizeof(szSuccessful));
        LoadString(hInst, IDS_FAILED, szFail, sizeof(szFail));
        printf( szTmp, (rc) ? szSuccessful : szFail );


    EndHTML();
    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\cofact.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\dsnform\dsnform.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  dsnform.c

  Abstract:

  Displays a driver and prompts for information necessary to create an
  ODBC datasource.   Special cases are made for SQL Server and Access drivers.

  Author:

  Kyle Geiger (kyleg)  1995-12-1

  Revision History:

  --*/


#include <windows.h>
#include <stdio.h>

#include "dynodbc.h"
#include "cgi.h"
#include "html.h"
#include "resource.h"

# define MAX_DATA       2048

#define SUCCESS(rc)    (!((rc)>>1))


int __cdecl
main( int argc, char * argv[])
{
    char    rgchQuery[MAX_DATA];
    CHAR    rgchQueryNS[MAX_DATA];
    char  pszExtra[MAX_DATA*3];
    DWORD   dwLen;
    CHAR    szSQLServer[MAX_DATA];
    CHAR    szAccessDriver[MAX_DATA];
    CHAR    szTmp[MAX_DATA*3];
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ( !DynLoadODBC())
        return (1);

        // Get the driver and attibute information from the link
        dwLen = GetEnvironmentVariableA( PSZ_QUERY_STRING_A, rgchQuery, MAX_DATA);

        // Convert percent escapes
        TranslateEscapes2(rgchQuery, dwLen);

        // do special case processing for certain drivers (sql server, access, ddp, other)
        strcpy(pszExtra,"");
        LoadString(hInst, IDS_SQL_SERVER, szSQLServer, sizeof(szSQLServer));
        LoadString(hInst, IDS_ACCESS_DRIVER_1, szAccessDriver, sizeof(szAccessDriver));
        if (!strcmp(rgchQuery, szSQLServer)) {
                // find server name from URL, put in  attribute string
                LoadString(hInst, IDS_SERVER_NAME_ATTR_STR, pszExtra, sizeof(pszExtra));
        }
        else if (!strcmp(rgchQuery, szAccessDriver)) {
                // find server name from URL, put in  attribute string
                LoadString(hInst, IDS_DATABASE_NAME_ATTR_STR, pszExtra, sizeof(pszExtra));
        }

    //
    // convert SPACE to +
    //

    ConvertSP2Plus(rgchQuery,rgchQueryNS);
//strcpy( rgchQueryNS, rgchQuery);
OutputDebugString("******************");
OutputDebugString(rgchQueryNS);
OutputDebugString("\n\r");

    LoadString(hInst, IDS_SPECIFY_ODBC, szTmp, sizeof(szTmp));
    StartHTML(szTmp, 0);
    LoadString(hInst, IDS_CREATE_ODBC, szTmp, sizeof(szTmp));
    printf( szTmp, rgchQuery, rgchQueryNS, pszExtra);

    EndHTML();

    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\getdrvrs\getdrvrs.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  getdrvrs.c

  Abstract:

  This module returns a web page with all ODBC drivers installed on the web server.
  The drivers are displayed as links, which when clicked will launch another application
  (DSNFORM.EXE) to prompt for the data source name and other driver specific info

  Author:

  Kyle Geiger 17-Nov-1995
  (with thanks to MuraliK for providing the ODBC dynamic loading routines)

  Revision History:

  --*/


#include <windows.h>
#include <stdio.h>
#include "dynodbc.h"
#include "html.h"
#include "resource.h"

#define MAX_DATA       2048

#define SUCCESS(rc)    (!((rc)>>1))

int
__cdecl
main( int argc, char * argv[])
{
    RETCODE rc;                    // Return code for ODBC functions
    HENV    henv;                  // Environment Handle

    char    szDriver[MAX_DATA+1];  // Variable to hold Driver name
    char    szDriverNS[MAX_DATA+1];  // Variable to hold Driver name with space
                                     // converted to +

    SWORD   cbDriver;              // Output length of data Driver
    char    szDesc[MAX_DATA+1];    // Variable to hold Driver description
    SWORD   cbDesc;                // Output length of data description
    BOOL    fFirst;                // flag for first time through loop
    char    szList[MAX_DATA];      // driver list
    HINSTANCE hInst = GetModuleHandle(NULL);
    char szDsnFormExe[MAX_PATH];
    char szListODBCDrivers[MAX_PATH];
    char szCreateODBC[MAX_PATH*3];

           // see if ODBC is installed and can load.  If not, an error is returned
    if ( !DynLoadODBC())
            return (1);

        // retrieve all installed drivers, put in szList formatted as HTML links to DSNFORM.EXE
    pSQLAllocEnv(&henv);
    rc=pSQLDrivers(henv, SQL_FETCH_FIRST,
                   (UCHAR FAR *) szDriver,
                   MAX_DATA, &cbDriver,
                   (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);

        fFirst=FALSE;
        szList[0]='\0';

    while (SUCCESS(rc)) {

        //
        // Replace SP with +
        //

        strcpy(szDriverNS, szDriver);

        if (!fFirst) {
            fFirst=TRUE;
        }

        LoadString(hInst, IDS_DSNFORMEXE, szDsnFormExe, sizeof(szDsnFormExe));

        sprintf(
            szList+strlen(szList),szDsnFormExe,
            szDriverNS, szDriver);

        rc=pSQLDrivers(henv, SQL_FETCH_NEXT,
                     (UCHAR FAR * ) szDriver, MAX_DATA, &cbDriver,
                     (UCHAR FAR * ) szDesc, MAX_DATA, &cbDesc);
    }

        LoadString(hInst, IDS_LIST_ODBC_DRIVERS, szListODBCDrivers, sizeof(szListODBCDrivers));
        StartHTML(szListODBCDrivers, FALSE);
        // if no drivers found, return error page
    if (!fFirst) {
        LoadString(hInst, IDS_CREATE_ODBC_FAIL, szCreateODBC, sizeof(szCreateODBC));
        printf( szCreateODBC );
    }
        // otherwise, display the driver names as links
    else {
        LoadString(hInst, IDS_CREATE_ODBC_GETDRVR, szCreateODBC, sizeof(szCreateODBC));
         printf( szCreateODBC ,szList);
    }
        EndHTML();
    pSQLFreeEnv(henv);
    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\server\httpxpc.cxx ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	HTTPXPC.CXX
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//
//	Monitor-side for W3 integration.
//

#include "w3p.hxx" // W3SVC Precompiled header

#include <windows.h>
#include <winperf.h>
#include "pclib.hxx"
#include "httpxctr.hxx" // Perf counter title index #defines
#include "caldbg.h"  // For DebugTrace()/Assert()


EXTERN_C const WCHAR gc_wszSignature[]	= L"HTTPEXT";
EXTERN_C const CHAR gc_szDbgIni[] = "HTTPXPC.INI";
EXTERN_C const INT gc_cchDbgIni = 11;
EXTERN_C const CHAR gc_szSignature[] = "HTTPXPC";

//
// This is declared here because the shared memory library
// now requires any dll or exe using it to define this function.
// However this function is only used for the shared lock cache
// so we do not need to actually implement it for perf counters.
//
namespace IMPLSTUB
{
	VOID __fastcall SaveHandle(HANDLE hHandle);
}

VOID __fastcall
IMPLSTUB::SaveHandle(HANDLE h)
{
    Assert ( FALSE );
    return;
}
// end of hack working around shared lock cache.


//
//	The following macros, templates and classes are derived from
//	sources in the DAV project.
//

//	========================================================================
//
//	TEMPLATE CLASS Singleton
//
//	Use this template to implement classes that can only have one instance.
//	NOTE: For ref-counted or on-demand global objects, see below
//		(RefCountedGlobal and OnDemandGlobal).
//
//	The Singleton template provides the following:
//
//		o	a common memory layout for singleton classes which
//			allows template folding to reduce overall code size.
//
//		o	an instantiation mechanism that verifies (asserts)
//			that only instance of your class ever exists.
//
//		o	asserts to catch any code which attempts to use
//			your class when it's not initialized.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private Singleton<YourClass>
//		{
//			//
//			//	Declare Singleton as a friend of YourClass
//			//	if YourClass's constructor is private (which it
//			//	should be since YourClass is a singleton and
//			//	should not be allowed to arbitrarily create
//			//	instances of it).
//			//
//			friend class Singleton<YourClass>;
//
//			//
//			//	YourClass private members.  Since the 'staticness'
//			//	of YourClass is provided entirely by this template,
//			//	you do not need to declare your members as 'static'
//			//	and you should use standard Hungarian class member
//			//	naming conventions (e.g. m_dwShoeSize).
//			//
//			[...]
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass which
//			//	would call CreateInstance() and DestroyInstance()
//			//	respectively.  Or, you could just expose these functions
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using Singleton<YourClass>::CreateInstance;
//			//		using Singleton<YourClass>::DestroyInstance;
//			//
//			//	Similarly, YourClass will probably have additional
//			//	static methods which access or operate on the
//			//	singleton instance.  These will call Instance()
//			//	to get at the global instance.  Or, though it's
//			//	not recommended from an encapsulation standpoint,
//			//	you could expose the global instance directly to
//			//	clients with:
//			//
//			//		using Singleton<YourClass>::Instance;
//			//
//			[...]
//		};
//
template<class _X>
class Singleton
{
	//
	//	Space for the sole instance
	//
	static BYTE sm_rgbInstance[];

	//
	//	Pointer to the instance
	//
	static _X * sm_pInstance;

public:
	//	STATICS
	//

	//
	//	Create the single, global instance of class _X.
	//
	static _X& CreateInstance()
	{
		//
		//	This actually calls Singleton::new()
		//	(defined below), but calls to new()
		//	must always be unqualified.
		//
		return *(new _X());
	}

	//
	//	Destroy the single, global instance of class _X.
	//
	static VOID DestroyInstance()
	{
		//
		//	This actually calls Singleton::delete()
		//	(defined below), but calls to delete()
		//	must always be unqualified.
		//
		delete sm_pInstance;
	}

	//
	//	Provide access to the single, global instance of class _X.
	//
	static _X& Instance()
	{
		Assert( sm_pInstance );

		return *sm_pInstance;
	}

	//
	//	Singleton operator new and operator delete "allocate"
	//	space for the object in static memory.  These must be
	//	defined public for syntactic reasons.  Do NOT call them
	//	directly!!  Use CreateInstance()/DestroyInstance().
	//
	static void * operator new(size_t)
	{
		Assert( !sm_pInstance );

		//
		//	Just return a pointer to the space
		//	in which to instantiate the object.
		//
		sm_pInstance = reinterpret_cast<_X *>(sm_rgbInstance);
		return sm_pInstance;
	}

	static void operator delete(void *, size_t)
	{
		Assert( sm_pInstance );

		//
		//	Since nothing was done to allocate space
		//	for the instance, we don't do anything
		//	here to free it.
		//
		sm_pInstance = NULL;
	}

};

//
//	Space for the sole instance of class _X
//
template<class _X>
BYTE Singleton<_X>::sm_rgbInstance[sizeof(_X)];

//
//	Pointer to the instance
//
template<class _X>
_X * Singleton<_X>::sm_pInstance = NULL;


//	========================================================================
//
//	CLASS _Empty
//
//	A completely empty, but instantiatable class.  Use the _Empty class
//	to get around the syntactic inability to instantiate anything of
//	type void (or VOID).
//
//	In retail builds, _Empty has the same memory footprint and code
//	impact as void -- none.
//
//	See the RefCountedGlobal template below for a usage example.
//
class _Empty
{
	//	NOT IMPLEMENTED
	//
	_Empty( const _Empty& );
	_Empty& operator=( const _Empty& );

public:
	_Empty() {}
	~_Empty() {}
};


//	========================================================================
//
//	TEMPLATE CLASS RefCountedGlobal
//
//	Use this template as boilerplate for any class that encapsulates
//	a global, refcounted initialization/deinitialization process.
//
//	This template maintains proper refcounting and synchronization when
//	there are multiple threads trying to initialize and deinitialize
//	references at the same time.  And it does so without a critical
//	section.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private RefCountedGlobal<YourClass>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that they can call your private
//			//	initialization functions.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	should perform any failable initialization of the
//			//	instance of YourClass.  It should return TRUE
//			//	if initialization succeeds, and FALSE otherwise.
//			//	If YourClass does not have any initialization that
//			//	can fail then you should implement this function inline
//			//	to just return TRUE.
//			//
//			BOOL FInit();
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass.  These
//			//	functions would call DwInitRef() and DeinitRef() respectively.
//			//	Or, you could just expose DwInitRef() and DeinitRef()
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using RefCountedGlobal<YourClass>::DwInitRef;
//			//		using RefCountedGlobal<YourClass>::DeinitRef;
//			//
//			[...]
//		};
//
//	If YourClass::FInit() succeeds (returns TRUE), then DwInitRef()
//	returns the new refcount.  If YourClass::FInit() fails (returns
//	FALSE), then DwInitRef() returns 0.
//
//	See \cal\src\inc\memx.h for sample usage.
//
//	If YourClass::FInit() requires initialization parameters, you can
//	still use the RefCountedGlobal template.  You just need to provide
//	your parameter type in the template instantiation and declare your
//	FInit() to take a const reference to a parameter of that type:
//
//		class YourClass : private RefCountedGlobal<YourClass, YourParameterType>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that htey can call your private
//			//	initialization functions.
//			//
//			//	Note the added parameter type to the RefCountedGlobal
//			//	declaration.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass, YourParameterType>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	now takes a const ref to the initialization parameters.
//			//
//			BOOL FInit( const YourParameterType& initParam );
//
//		public:
//			//
//			//	Public declarations for YourClass
//			//
//			[...]
//		};
//
//	See \cal\src\httpext\entry.cpp for an example of this usage.
//
template<class _X, class _ParmType = _Empty>
class RefCountedGlobal : private Singleton<_X>
{
	//
	//	The object's reference count.
	//
	static LONG sm_lcRef;

	//
	//	Set of states which describe the object's state
	//	of initialization.  The object's state is
	//	STATE_UNKNOWN while it is being initialized or
	//	deinitialized.
	//
	enum
	{
		STATE_UNINITIALIZED,
		STATE_INITIALIZED,
		STATE_UNKNOWN
	};

	static LONG sm_lState;

	//
	//	Member template that generates an appropriately-typed,
	//	(inline) function that calls _X::FInit with initialization
	//	parameters.
	//
	template<class _P> static BOOL
	FInit( const _P& parms ) { return Instance().FInit( parms ); }

	//
	//	Specialization of the above member template for
	//	the _Empty parameter type, which calls _X::FInit
	//	without initialization parameters.
	//
	static BOOL FInit( const _Empty& ) { return Instance().FInit(); }

protected:
	//
	//	Expose access to the single instance of class _X
	//
	using Singleton<_X>::Instance;

	//
	//	Expose operator new and operator delete from
	//	the Singleton template so that they will be
	//	used rather than the default new and delete
	//	to "allocate" space for the instance of class _X.
	//
	using Singleton<_X>::operator new;
	using Singleton<_X>::operator delete;

	static BOOL FInitialized()
	{
		return sm_lState == STATE_INITIALIZED;
	}

	static LONG CRef()
	{
		return sm_lcRef;
	}

public:
	static DWORD DwInitRef( const _ParmType& parms )
	{
		LONG lcRef;

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );

		//
		//	Add the reference for the instance we're about
		//	to initialize.  Doing this now simplifies the
		//	code below at the expense of having to decrement
		//	if first time initialization (FInit()) fails.
		//	The only thing critical to the design is that
		//	at any point, when sm_lState is STATE_INITIALIZED,
		//	sm_lcRef is at least 1.
		//
		lcRef = InterlockedIncrement( &sm_lcRef );
		Assert( lcRef > 0 );

		//
		//	Don't proceed until the object is initialized.
		//
		while ( sm_lState != STATE_INITIALIZED )
		{
			//
			//	Simultaneously check whether initialization has
			//	started and, if it has not, start it.
			//
			LONG lStatePrev = InterlockedCompareExchange(
								&sm_lState,
								STATE_UNKNOWN,
								STATE_UNINITIALIZED );

			//
			//	If we're starting first time initialization,
			//	then create and initialize the sole instance.
			//
			if ( lStatePrev == STATE_UNINITIALIZED )
			{
				CreateInstance();

				//	This calls our private member template FInit()
				//	(declared above), which in turn calls _X::Finit()
				//	with the appropriate parameters.
				//
				if ( FInit( parms ) )
				{
					sm_lState = STATE_INITIALIZED;
					break;
				}

				//	We failed to init.
				//	Tear down now.
				//
				
				Assert( lcRef == 1 );
				Assert( sm_lState == STATE_UNKNOWN );

				//	Let go of our ref on the object.
				//	Destroy the object.
				//	And LAST, set the state to UNINITIALIZED.
				//	NOTE: This will let the next caller through the
				//	InterlockedCompare above.
				//
				InterlockedDecrement( &sm_lcRef );
				DestroyInstance();
				sm_lState = STATE_UNINITIALIZED;

				return 0;
			}

			//
			//	If first time initialization is in progress on
			//	another thread, then get out of the way so
			//	it can finish.
			//
			//$OPT	We should probably spin rather than Sleep()
			//$OPT	on multi-proc machines on the assumption that
			//$OPT	we only get here on a processor other than
			//$OPT	the one which is doing the initialization
			//$OPT	and we don't want to invite a task switch
			//$OPT	by calling Sleep() while we are waiting
			//$OPT	for initialization to complete.
			//
			if ( lStatePrev == STATE_UNKNOWN )
				Sleep(0);
		}

		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		return static_cast<DWORD>(lcRef);
	}

	static VOID DeinitRef()
	{
		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		//
		//	Remove that reference.  If it is the last
		//	then deinit the object.
		//
		if ( 0 == InterlockedDecrement( &sm_lcRef ) )
		{
			//
			//	After releasing the last reference, declare that
			//	the object is in an unknown state.  This prevents
			//	other threads trying to re-initialize the object
			//	from proceeding until we're done.
			//
			sm_lState = STATE_UNKNOWN;

			//
			//	There is a tiny window between decrementing the
			//	refcount and changing the state where another
			//	initialization could have come through.  Test this
			//	by rechecking the refcount.
			//
			if ( 0 == sm_lcRef )
			{
				//
				//	If the refcount is still zero, then no
				//	initializations happened before we changed
				//	states.  At this point, if an initialization
				//	starts, it will block until we change state,
				//	so it is safe to actually destroy the instance.
				//
				DestroyInstance();

				//
				//	Once the object has been deinitialized, update
				//	the state information.  This unblocks any
				//	initializations waiting to happen.
				//
				sm_lState = STATE_UNINITIALIZED;
			}
			else // refcount is now non-zero
			{
				//
				//	If the refcount is no longer zero, then an
				//	initialization happened between decrementing
				//	the refcount above and entering the unknown
				//	state.  When that happens, DO NOT deinit --
				//	there is now another valid reference somewhere.
				//	Instead, just restore the object's state to let
				//	other references proceed.
				//
				sm_lState = STATE_INITIALIZED;
			}
		}

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );
	}

	//	This provides a no-parameter version of DwInitRef
	//	for clients that do not need any parameters in FInit().
	//
	static DWORD DwInitRef()
	{
		_Empty e;

		return DwInitRef( e );
	}
};

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lcRef = 0;

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lState = STATE_UNINITIALIZED;


// ========================================================================
// SHARED MEMORY HANDLES
//
// They are always defined as 32 bit values
//
#ifdef _WIN64
 typedef VOID * __ptr32 SHMEMHANDLE;
#else
 typedef HANDLE SHMEMHANDLE;
#endif

// ========================================================================
//
// NAMESPACE SMH
//
// Differentiates the shared memory heap allocation functions
// from all of the other various heap allocation functions
// in existence.
//
// Yes, this could have been done with a prefix just as easily....
//
namespace SMH
{
 BOOL __fastcall FInitialize( IN LPCWSTR pwszInstanceName );
 VOID __fastcall Deinitialize();
 PVOID __fastcall PvAlloc( IN DWORD cbData, OUT SHMEMHANDLE * phsmba );
 VOID __fastcall Free( IN SHMEMHANDLE hsmba );
 PVOID __fastcall PvFromSMBA( IN SHMEMHANDLE hsmba );
};


//	========================================================================
//
//	CLASS CSmhInit
//
//	Initializer for shared memory heap.  Any class containing member objects
//	that reside on the shared memory heap should also include an instance
//	of this class as a member BEFORE the others to ensure that they are
//	properly destroyed before the heap is deinitialized.
//
class CSmhInit
{
	//	NOT IMPLEMENTED
	//
	CSmhInit& operator=( const CSmhInit& );
	CSmhInit( const CSmhInit& );

public:
	CSmhInit()
	{
	}

	BOOL FInitialize( LPCWSTR lpwszSignature )
	{
#ifdef COMPILE_WITHOUT_DAV
		return FALSE;
#else
		return SMH::FInitialize( lpwszSignature );
#endif
	}

	~CSmhInit()
	{
#ifdef COMPILE_WITHOUT_DAV
		// do nothing
#else
		SMH::Deinitialize();
#endif
	}
};


//	========================================================================
//
//	TEMPLATE CLASS auto_ptr
//
//		Stripped down auto_ptr class based on the C++ STL standard one
//
template<class X>
class auto_ptr
{
	mutable X *		owner;
	X *				px;

public:
	explicit auto_ptr(X* p=0) : owner(p), px(p) {}
	auto_ptr(const auto_ptr<X>& r) : owner(r.owner), px(r.relinquish()) {}

	auto_ptr& operator=(const auto_ptr<X>& r)
	{
		if ((void*)&r != (void*)this)
		{
			delete owner;
			owner = r.owner;
			px = r.relinquish();
		}

		return *this;
	}
	//	NOTE: This equals operator is meant to be used to load a
	//	new pointer (not yet held in any auto-ptr anywhere) into this object.
	auto_ptr& operator=(X* p)
	{
		Assert(!owner);		//	Scream on overwrite of good data.
		owner = p;
		px = p;
		return *this;
	}

	~auto_ptr()           { delete owner; }
	bool operator!()const { return (px == NULL); }
	operator X*()	const { return px; }
	X& operator*()  const { return *px; }
	X* operator->() const { return px; }
	X* get()		const { return px; }
	X* relinquish() const { owner = 0; return px; }

	void clear()
	{
		if (owner)
			delete owner;
		owner = 0;
		px = 0;
	}
};


//
//	From here down implements the performance monitor for HTTPEXT and
//	the functionality necessary to merge perf counters from HTTPEXT
//	into the Web Service object defined by W3CTRS.
//

//
//	The first flag says whether the CW3Monitor instance has been created.
//	The second flag says whether it has been initialized.
//	Since the CW3Monitor is created on-demand by the first call to
//	W3MergeDavPerformanceData(), these flags keep us from continually
//	retrying initialization after it fails the first time.
//
BOOL g_fCreatedMonitor = FALSE;
BOOL g_fInitializedMonitor = FALSE;


//	========================================================================
//
//	CLASS CW3Monitor
//
class CW3Monitor : private Singleton<CW3Monitor>
{
	//
	//	Friend declaration required by Singleton template
	//
	friend class Singleton<CW3Monitor>;

	//
	//	Hint about the size of the buffer to use for perf data coming back
	//	from HTTPEXT.  The buffer needs to be about 48K per vroot.  The
	//	initial guess is 48K (one vroot), and scales up geometrically as
	//	necessary.
	//
	DWORD m_cbDavDataAlloc;

	//
	//	Shared memory heap initialization.  Declare before any member
	//	variables which use the shared memory heap to ensure proper
	//	order of destruction.
	//
	CSmhInit m_smh;

	//
	//	Perf counter data
	//
	auto_ptr<ICounterData> m_pCounterData;

	//	CREATORS
	//
	CW3Monitor() :
		m_cbDavDataAlloc(48 * 1024)
	{
	}
	BOOL FInitialize();

	//	ACCESSORS
	//
	DWORD DwCollectPerformanceData( LPBYTE lpbPerfData,
									LPDWORD lpdwcbPerfData )
	{
		DWORD dwcObjectTypes;

		return m_pCounterData->DwCollectData( NULL, // Always query all data
											  0, // Use 0-relative indices
											  reinterpret_cast<LPVOID *>(&lpbPerfData),
											  lpdwcbPerfData,
											  &dwcObjectTypes );
	}

	//	NOT IMPLEMENTED
	//
	CW3Monitor& operator=( const CW3Monitor& );
	CW3Monitor( const CW3Monitor& );

public:
	static BOOL W3MergeDavPerformanceData( DWORD dwServerId, W3_STATISTICS_1 * pW3Stats );
	static VOID W3CloseDavPerformanceData()
	{
		DestroyInstance();
		g_fCreatedMonitor = FALSE;
	}
};

//	------------------------------------------------------------------------
//
//	CW3Monitor::FInitialize()
//
BOOL
CW3Monitor::FInitialize()
{

    //
	//	Initialize the shared memory heap
	//
	if ( !m_smh.FInitialize( gc_wszSignature ) )
	{
		DWORD dwResult = GetLastError();

		DebugTrace( "CW3Monitor::FInitialize() - Error initializing shared memory heap %d\n", dwResult );

		return FALSE;
	}

	//
	//	Bind to the counter data
	//
#ifdef COMPILE_WITHOUT_DAV

#else

    m_pCounterData = NewCounterMonitor( gc_wszSignature );

	if ( !m_pCounterData.get() )
	{

		DWORD dwResult = GetLastError();

		DebugTrace( "CW3Monitor::FInitialize() - Error binding to counter data %d\n", dwResult );

		return FALSE;
	}


#endif

    return TRUE;

}

//	------------------------------------------------------------------------
//
//	CW3Monitor::W3MergeDavPerformanceData()
//
BOOL
CW3Monitor::W3MergeDavPerformanceData( DWORD dwServerId, W3_STATISTICS_1 * pW3Stats )
{

	BYTE * lpbDavData = NULL;
	PERF_OBJECT_TYPE * ppot = NULL;
	PERF_COUNTER_DEFINITION * rgpcd = NULL;
	DWORD dwibServerId = 0;
	PERF_INSTANCE_DEFINITION * ppid = NULL;
	PERF_COUNTER_BLOCK * ppcb;
	LONG lcInstances;
	DWORD iCtr;
	BOOL fRet = FALSE;

	//
	//	Create the monitor on demand
	//

	if ( !g_fCreatedMonitor )
	{
		g_fInitializedMonitor = CreateInstance().FInitialize();
		g_fCreatedMonitor = TRUE;
	}

	//
	//	If we failed to init the monitor, then we can't get any
	//	performance data.  Since we can't fail this call, just leave
	//	the existing statistics alone.
	//
	if ( !g_fInitializedMonitor )
		goto ret;


	//
	//	From here out we always return TRUE
	//
	fRet = TRUE;

	//
	//	Try collecting the data.  If our buffer is too small, double
	//	its size repeatedly until it's big enough.  The initial guess
	//	should be large enough to succeed most of the time.
	//
	for ( ;; )
	{
		DWORD cbDavDataAlloc;
		DWORD cbDavData;
		DWORD dwCollectResult;

		//	If we have a buffer from a previous trip around the loop
		//	then free it.
		//
		if (lpbDavData)
			delete [] lpbDavData;

		cbDavDataAlloc = Instance().m_cbDavDataAlloc;
		cbDavData = cbDavDataAlloc;
		lpbDavData = new BYTE[cbDavData];
		if (NULL == lpbDavData)
		{
			DebugTrace( "W3MergeDavPerformanceData() - OOM allocating buffer for DAV perf data\n" );
			goto ret;
		}

		dwCollectResult = Instance().
						  DwCollectPerformanceData( lpbDavData,
													&cbDavData );

		if ( ERROR_SUCCESS == dwCollectResult )
		{
			if ( 0 != cbDavData )
			{
				break;
			}
			else
			{
				DebugTrace( "W3MergeDavPerformanceData() - No instances from which to collect data\n" );
				goto ret;
			}
		}

		if ( ERROR_MORE_DATA != dwCollectResult )
		{
			DebugTrace( "W3MergeDavPerformanceData() - Error collecting DAV perf data (%d)\n", dwCollectResult );
			goto ret;
		}

		Instance().m_cbDavDataAlloc = 2 * cbDavDataAlloc;
	}

	//
	//	Locate the HTTPEXT perf object (should be the first
	//	thing returned) and make sure it looks reasonable.
	//
	ppot = reinterpret_cast<PERF_OBJECT_TYPE *>( lpbDavData );

	if ( ppot->NumCounters < 1 )
	{
		DebugTrace( "W3MergeDavPerformanceData() - NumCounters < 1?" );
		goto ret;
	}

	if ( ppot->NumInstances < 1 )
	{
		DebugTrace( "W3MergeDavPerformanceData() - NumInstances < 1?" );
		goto ret;
	}

	//
	//	Locate the HTTPEXT counter definitions.
	//
	rgpcd = reinterpret_cast<PERF_COUNTER_DEFINITION *>(
				reinterpret_cast<LPBYTE>(ppot) + ppot->HeaderLength );

	//
	//	Locate the server ID counter.  This counter tells us what
	//	instance of the W3Ctrs data to merge into, so bail if we can't
	//	find it or if it looks wrong.
	//
	for ( iCtr = 0; iCtr < ppot->NumCounters; iCtr++ )
	{
		if ( rgpcd[iCtr].CounterNameTitleIndex == HTTPEXT_COUNTER_SERVER_ID )
		{
			if ( rgpcd[iCtr].CounterSize == sizeof(DWORD) &&
				 rgpcd[iCtr].CounterType == (PERF_DISPLAY_NOSHOW |
											 PERF_SIZE_DWORD |
											 PERF_TYPE_NUMBER) )
			{
				dwibServerId = rgpcd[iCtr].CounterOffset;
				break;
			}
			else
			{
				DebugTrace( "W3MergePerformanceData() - Server ID counter doesn't look right.  Bailing...\n" );
				goto ret;
			}
		}
	}

	if ( !dwibServerId )
	{
		DebugTrace( "W3MergePerformanceData() - Couldn't find server ID counter.  Bailing...\n" );
		goto ret;
	}

	//
	//	Now go through each instance of the HTTPEXT counters and merge the data
	//	from that instance into the correct W3Ctrs counter instance according
	//	to server ID.
	//
	ppid = reinterpret_cast<PERF_INSTANCE_DEFINITION *>(
			reinterpret_cast<LPBYTE>(ppot) + ppot->DefinitionLength );

	for ( lcInstances = ppot->NumInstances;
		  lcInstances-- > 0;
		  ppid = reinterpret_cast<PERF_INSTANCE_DEFINITION *>(
			  reinterpret_cast<LPBYTE>(ppcb) + ppcb->ByteLength ) )
	{
		ppcb = reinterpret_cast<PERF_COUNTER_BLOCK *>(
				reinterpret_cast<LPBYTE>(ppid) + ppid->ByteLength );

		//
		//	Get the server ID of this instance.
		//
		DWORD dwServerIdInstance =
			*reinterpret_cast<LPDWORD>(
				reinterpret_cast<LPBYTE>(ppcb) + dwibServerId);

		//
		//	If the server ID of this instance isn't the one
		//	we want then keep looking.
		//
		if ( dwServerIdInstance != dwServerId )
			continue;

		//
		//	The server IDs match, so sum in the info for this instance.
		//	NOTE: Since each vroot has its own instance, there may be
		//	multiple instances with the same server ID.  Sum them all.
		//
		//	Go through all the counters in the HTTPEXT instance
		//	and update the W3 statistics data.
		//
		for ( DWORD iCounter = 0;
			  iCounter < ppot->NumCounters;
			  iCounter++ )
		{
			PERF_COUNTER_DEFINITION * ppcd = &rgpcd[iCounter];

			switch ( ppcd->CounterNameTitleIndex )
			{
				case HTTPEXT_COUNTER_TOTAL_GET_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_HEAD_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_POST_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_DELETE_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_OTHER_REQUESTS:
				{
					//
					//	These values are already recorded
					//	in the statistics, so don't do anything
					//	more with them here.
					//
					break;
				}

				case HTTPEXT_COUNTER_TOTAL_PUT_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalFilesReceived += dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_OPTIONS_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalOptions += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_COPY_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalCopy += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_MOVE_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalMove += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_MKCOL_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalMkcol += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_PROPFIND_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalPropfind += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_PROPPATCH_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalProppatch += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_SEARCH_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalSearch += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_LOCK_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalLock += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_UNLOCK_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalUnlock += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_404_RESPONSES:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalNotFoundErrors += dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_423_RESPONSES:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalLockedErrors += dwValue;
					}

					break;
				}

				default:
				{
					//
					//	We either don't care about or don't understand
					//	other counters, so skip them.
					//
					break;
				}
			}
		}
	}

ret:
	if (lpbDavData)
		delete [] lpbDavData;

	return fRet;

}


//	========================================================================
//
//	CLASS CW3MonitorInit
//
//	Refcounted global initialization class that controls the lifetime of
//	the singleton CW3Monitor instance.  Calls to collect performance data
//	are done in the scope of a reference to this class so that the server
//	can be taken down on one thread while another thread is in the middle
//	of -- or just beginning to -- collect data.  Whichever thread releases
//	the last reference to this class will be the one to close the counters.
//	
class CW3MonitorInit : private RefCountedGlobal<CW3MonitorInit>
{
	//
	//	Friend declarations required by RefCountedGlobal template
	//
	friend class Singleton<CW3MonitorInit>;
	friend class RefCountedGlobal<CW3MonitorInit>;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CW3MonitorInit()
	{
	}

	BOOL FInit()
	{
		return TRUE;
	}

	~CW3MonitorInit()
	{
		CW3Monitor::W3CloseDavPerformanceData();
	}

	//	NOT IMPLEMENTED
	//
	CW3MonitorInit( const CW3MonitorInit& );
	CW3MonitorInit& operator=( const CW3MonitorInit& );

public:
	using RefCountedGlobal<CW3MonitorInit>::DwInitRef;
	using RefCountedGlobal<CW3MonitorInit>::DeinitRef;
};


//	========================================================================
//
//	PUBLIC INTERFACE
//

//	------------------------------------------------------------------------
//
//	W3MergeDavPerformanceData()
//
EXTERN_C BOOL __fastcall
W3MergeDavPerformanceData( DWORD dwServerId, W3_STATISTICS_1 * pW3Stats )
{
	BOOL fResult;

	CW3MonitorInit::DwInitRef();

	fResult = CW3Monitor::W3MergeDavPerformanceData( dwServerId, pW3Stats );

	CW3MonitorInit::DeinitRef();

	return fResult;
}

//	------------------------------------------------------------------------
//
//	W3OpenDavPerformanceData()
//
EXTERN_C VOID __fastcall
W3OpenDavPerformanceData()
{
	CW3MonitorInit::DwInitRef();
}

//	------------------------------------------------------------------------
//
//	W3CloseDavPerformanceData()
//
EXTERN_C VOID __fastcall
W3CloseDavPerformanceData()
{
	CW3MonitorInit::DeinitRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\comobj.cpp ===
// comobj.cpp : Implementation of CWamregApp and DLL registration.
#include "common.h"
#include "comobj.h"
#include "iwamreg.h"
#include "wamadm.h"

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "auxfunc.h"
#include "dbgutil.h"

//==========================================================================
// Global variables
//
//==========================================================================
CWmRgSrvFactory* 	g_pWmRgSrvFactory = NULL;
DWORD				g_dwRefCount = 0;
DWORD				g_dwWamAdminRegister = 0;

//==========================================================================
// Static functions
//
//==========================================================================

/////////////////////////////////////////////////////////////////////////////
//

/*===================================================================
CWmRgSrv::CWmRgSrv

Constructor for CWmRgSrv. 

Parameter:		NONE
Return:			NONE

Side affect:	Init a Metabase pointer(via UNICODE DCOM interface), Create an Event.
===================================================================*/
CWmRgSrv::CWmRgSrv()
: 	m_cRef(1)
{
	InterlockedIncrement((long *)&g_dwRefCount);
}

/*===================================================================
CWmRgSrv::~CWmRgSrv

Destructor for CWmRgSrv. 

Parameter:		NONE
Return:			NONE

Side affect:	Release the Metabase pointer, and Destroy the internal event object.
===================================================================*/
CWmRgSrv::~CWmRgSrv()
{	
	InterlockedDecrement((long *)&g_dwRefCount);
	DBG_ASSERT(m_cRef == 0);
}

/*===================================================================
CWmRgSrv::QueryInterface

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
STDMETHODIMP CWmRgSrv::QueryInterface(REFIID riid, void ** ppv)
{
	if (riid == IID_IUnknown || riid == IID_IADMEXT)
		{
		*ppv = static_cast<IADMEXT*>(this);
		}
	else
		{
		*ppv = NULL;
		return E_NOINTERFACE;
		}

	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CWmRgSrv::AddRef( )
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWmRgSrv::Release( )
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if ( 0 == cRef )
    {
        delete this;
    }

    return cRef;
}


/*===================================================================
CWmRgSrv::Initialize

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
STDMETHODIMP CWmRgSrv::Initialize( )
{
	HRESULT			hrReturn = NOERROR;
	CWamAdminFactory	*pWamAdminFactory = new CWamAdminFactory();

	if (pWamAdminFactory == NULL)
		{
		DBGPRINTF((DBG_CONTEXT, "WamRegSrv Init failed. error %08x\n",
					GetLastError()));
		hrReturn = E_OUTOFMEMORY;
		goto LExit;
		}

	hrReturn = g_RegistryConfig.LoadWamDllPath();
	
	if (SUCCEEDED(hrReturn))
		{
		hrReturn = WamRegMetabaseConfig::MetabaseInit();
		}

	if (SUCCEEDED(hrReturn))
		{
		hrReturn = CoRegisterClassObject(CLSID_WamAdmin,
										static_cast<IUnknown *>(pWamAdminFactory),
										CLSCTX_SERVER,
										REGCLS_MULTIPLEUSE,
										&g_dwWamAdminRegister);
		if (FAILED(hrReturn))
			{
			DBGPRINTF((DBG_CONTEXT, "WamRegSrv Init failed. error %08x\n",
						GetLastError()));
			}
		}

	if (FAILED(hrReturn))
		{
		if (g_dwWamAdminRegister)
			{
	        //
            // PREfix has a problem with this code because we're not checking
            // the return value of CoRevokeClassObject.  There's really
            // nothing different we could do in the event of failure, so
            // there's no point in checking.
            //

            /* INTRINSA suppress=all */

			CoRevokeClassObject(g_dwWamAdminRegister);
			g_dwWamAdminRegister = 0;
			}
		RELEASE(pWamAdminFactory);
		}

	if (FAILED(hrReturn))
		{
		WamRegMetabaseConfig::MetabaseUnInit();
		}

LExit:
	return hrReturn;
}

/*===================================================================
CWmRgSrv::Terminate

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
HRESULT CWmRgSrv::EnumDcomCLSIDs
(
/* [size_is][out] */CLSID *pclsidDcom, 
/* [in] */ DWORD dwEnumIndex
)
{
	HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

	if (dwEnumIndex == 0)
		{
		*pclsidDcom = CLSID_WamAdmin;
		hr = S_OK;
		}

	return hr;
}

/*===================================================================
CWmRgSrv::Terminate

UNDONE

Parameter:
NONE.

Return:			HRESULT

Side affect:	.
===================================================================*/
STDMETHODIMP CWmRgSrv::Terminate( )
{
	//
    // PREfix has a problem with this code because we're not checking
    // the return value of CoRevokeClassObject.  There's really
    // nothing different we could do in the event of failure, so
    // there's no point in checking.
    //

    /* INTRINSA suppress=all */
    
    CoRevokeClassObject(g_dwWamAdminRegister);
	WamRegMetabaseConfig::MetabaseUnInit();
	
	return S_OK;
}


/*

CWmRgSrvFactory: 	Class Factory IUnknown Implementation

*/

CWmRgSrvFactory::CWmRgSrvFactory()
:	m_pWmRgServiceObj(NULL)
{
	m_cRef = 0;
	InterlockedIncrement((long *)&g_dwRefCount);
}

CWmRgSrvFactory::~CWmRgSrvFactory()
{
	InterlockedDecrement((long *)&g_dwRefCount);
	RELEASE(m_pWmRgServiceObj);
}

STDMETHODIMP CWmRgSrvFactory::QueryInterface(REFIID riid, void ** ppv)
{
	HRESULT hrReturn = S_OK;
	
	if (riid==IID_IUnknown || riid == IID_IClassFactory) 
		{
	    if (m_pWmRgServiceObj == NULL)
	    	{
	        *ppv = (IClassFactory *) this;
			AddRef();
			hrReturn = S_OK;
	    	}
	    else
	    	{
    		*ppv = (IClassFactory *) this;
			AddRef();
			hrReturn = S_OK;
		    }
		}
	else 
		{
    	hrReturn = E_NOINTERFACE;
		}
		
	return hrReturn;
}

STDMETHODIMP_(ULONG) CWmRgSrvFactory::AddRef( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedIncrement((long *)&m_cRef);
	return dwRefCount;

}

STDMETHODIMP_(ULONG) CWmRgSrvFactory::Release( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedDecrement((long *)&m_cRef);
	return dwRefCount;
}

STDMETHODIMP CWmRgSrvFactory::CreateInstance(IUnknown * pUnknownOuter, REFIID riid, void ** ppv)
{
	HRESULT hrReturn = NOERROR;
	
	if (pUnknownOuter != NULL) 
		{
    	hrReturn = CLASS_E_NOAGGREGATION;
		}

	if (m_pWmRgServiceObj == NULL)
		{
		m_pWmRgServiceObj = new CWmRgSrv();
		if (m_pWmRgServiceObj == NULL)
			{
			hrReturn = E_OUTOFMEMORY;
			}
		}

	if (m_pWmRgServiceObj)
		{
		if (FAILED(m_pWmRgServiceObj->QueryInterface(riid, ppv))) 
			{
	    	hrReturn = E_NOINTERFACE;
			}
		}
		
	return hrReturn;
}

STDMETHODIMP CWmRgSrvFactory::LockServer(BOOL fLock)
{
	if (fLock) 
		{
        InterlockedIncrement((long *)&g_dwRefCount);
    	}
    else 
    	{
        InterlockedDecrement((long *)&g_dwRefCount);
    	}
    	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\auxfunc.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: Auxfunc.h

    supporting functions header file.

Owner: LeiJin

Note:

===================================================================*/

#ifndef _WAMREG_AUXFUNC_H
#define _WAMREG_AUXFUNC_H

#include "iadmw.h"
#include "comadmin.h"
#include "wmrgexp.h"
#include "dbgutil.h"
#include "iwamreg.h"
#include "iiscnfg.h"

// EMD_SET        an action to set the corresponding metabase identifier in metabase.
// EMD_DELETE   an action to delete the corresponding metabase identifier in metabase.
// EMD_NONE        an NO-OP action.
#define    EMD_SET       1
#define    EMD_DELETE    2
#define    EMD_NONE      0

// MDPropItem
// Used in WamRegMetabaseConfig, usually created an array of MDPropItem where each elment represents
// one WAMREG application property. 
// 
struct MDPropItem
{
    DWORD    dwMDIdentifier;    // Metabase Indetitifer
    DWORD    dwType;            // Metabase data type
    union
        {
        DWORD    dwVal;        // used if dwType is a METADATA_DWORD type.
        WCHAR*    pwstrVal;    // used if dwType is a METADATA_STRING type.
        };

    DWORD    dwAction;        // EMD_SET / EMD_DELETE / EMD_NONE
    
    HRESULT    hrStatus;
};

//
// Index to Wam Metabase Property
// Each one represents one WAMREG application related metabase property.
//
#define IWMDP_ROOT                0
#define IWMDP_ISOLATED            1
#define IWMDP_WAMCLSID            2
#define IWMDP_PACKAGEID           3
#define IWMDP_PACKAGE_NAME        4
#define IWMDP_LAST_OUTPROC_PID    5
#define IWMDP_FRIENDLY_NAME       6
#define IWMDP_APPSTATE            7
#define IWMDP_OOP_RECOVERLIMIT    8
#define IWMDP_OOP_APP_APPPOOL_ID  9
// Max of the above property.
#define IWMDP_MAX                 10

//
// WamAdmLock is used to create an "Critical Section" when perserve the order of App Create/Delete/etc.
// requests.
//
class WamAdmLock
{
public:
    WamAdmLock();
    BOOL Init();                // Init the WamAdmLock data member.
    BOOL UnInit();                // Uninit the WamAdmLock data member

    VOID AcquireWriteLock();    // Acquire the Lock
    VOID ReleaseWriteLock();    // Release the Lock.

private:

    DWORD    GetNextServiceToken();    
    VOID    Lock();                // Internal CS lock.
    VOID    UnLock();            // Internal CS unlock.

    // Data    
    DWORD                m_dwServiceToken;
    DWORD                m_dwServiceNum;
    HANDLE                m_hWriteLock;
    CRITICAL_SECTION    m_csLock;
};

inline VOID WamAdmLock::Lock()
{
    EnterCriticalSection(&m_csLock);
}

inline VOID WamAdmLock::UnLock()
{
    LeaveCriticalSection(&m_csLock);
}


//
//    WamRegGlobal
//    Contains some default global constant.
//    Contains a WamAdmLock memeber for DCOM level request locking.
//
class WamRegGlobal
{
public:
    WamRegGlobal()    {};
    ~WamRegGlobal()    {};
    BOOL    Init();
    BOOL    UnInit();
    
    VOID    AcquireAdmWriteLock(VOID);
    VOID    ReleaseAdmWriteLock(VOID);

    HRESULT CreatePooledApp
                    ( 
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fInProc,
                    IN BOOL fRecover = FALSE 
                    );
                    
    HRESULT CreateOutProcApp
                    ( 
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fRecover = FALSE,
                    IN BOOL fSaveMB = TRUE 
                    );

    HRESULT CreateOutProcAppReplica
                    (
                    IN LPCWSTR szMetabasePath,
                    IN LPCWSTR szAppName,
                    IN LPCWSTR szWamClsid,
                    IN LPCWSTR szAppId
                    );
                    
    HRESULT DeleteApp
                    (
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fRecoverable,
                    IN BOOL fRemoveAppPool
                    );

    HRESULT RecoverApp
                    (
                    IN LPCWSTR szMetabasePath,
                    IN BOOL fForceRecover
                    );
                    
    HRESULT    SzWamProgID    
                    (
                    IN LPCWSTR pwszMetabasePath,
                    OUT LPWSTR *ppszWamProgID
                    );

    HRESULT W3ServiceUtil
                    (
                    IN LPCWSTR szMDPath,
                    IN DWORD    dwCommand,
                    OUT DWORD*    dwCallBackResult
                    );

    HRESULT ConstructFullPath
                    (
                    IN LPCWSTR pwszMetabasePathPrefix,
                    IN DWORD dwcPrefix,
                    IN LPCWSTR pwszPartialPath,
                    OUT LPWSTR* ppwszResult
                    );

    BOOL    FAppPathAllowConfig
                    (
                    IN LPCWSTR    wszMetabasePath
                    );

	BOOL	FIsW3SVCRoot
					(
					IN LPCWSTR	wszMetabasePath
					);

private:
    HRESULT    GetNewSzGUID
                    (
                    OUT LPWSTR *ppszGUID
                    );    

    HRESULT    GetViperPackageName    
                    (
                    IN LPCWSTR      wszMetabasePath,
                    OUT LPWSTR*     pwszViperPackageName
                    );    

public:

    //Global Constant, self explained.
    static    const WCHAR g_szIISInProcPackageName[/*sizeof(DEFAULT_PACKAGENAME)/sizeof(WCHAR)*/];
    static    const WCHAR g_szIISInProcPackageID[];
    static    const WCHAR g_szInProcWAMCLSID[];
    static    const WCHAR g_szInProcWAMProgID[];
    
    static    const WCHAR g_szIISOOPPoolPackageName[];   
    static    const WCHAR g_szIISOOPPoolPackageID[];
    static    const WCHAR g_szOOPPoolWAMCLSID[];
    static    const WCHAR g_szOOPPoolWAMProgID[];

    static    const WCHAR g_szMDAppPathPrefix[];
    static    const DWORD g_cchMDAppPathPrefix;
    static	  const WCHAR g_szMDW3SVCRoot[];
    static	  const DWORD g_cchMDW3SVCRoot;
    
private:
    static    WamAdmLock    m_WamAdmLock;    // a lock for all DCOM level requests.
};

inline VOID WamRegGlobal::AcquireAdmWriteLock(VOID)
{
    m_WamAdmLock.AcquireWriteLock();
}

inline VOID WamRegGlobal::ReleaseAdmWriteLock(VOID)
{
    m_WamAdmLock.ReleaseWriteLock();
}

//
//    WamRegRegistryConfig
//    Contains functions that access the Reigstry.
//
class WamRegRegistryConfig
{
public:

    WamRegRegistryConfig()        {};
    ~WamRegRegistryConfig()        {};
    HRESULT RegisterCLSID
                        (    
                        IN LPCWSTR szCLSIDEntryIn,
                        IN LPCWSTR szProgIDIn,
                        IN BOOL    fSetVIProgID
                        );

    HRESULT UnRegisterCLSID
                        (
                        IN LPCWSTR wszCLSIDEntryIn, 
                        IN BOOL fDeleteVIProgID
                        );
                        
    HRESULT LoadWamDllPath(VOID);
private:
    
    HRESULT UnRegisterProgID
            (
            IN LPCWSTR szProgIDIn
            );

    static    const REGSAM    samDesired;
    static    CHAR    m_szWamDllPath[MAX_PATH];

};

//
//    WamRegPackageConfig
//    Contains functions that access the MTS Admin API.
//    Class defined to access MTS Admin interface.
//
class WamRegPackageConfig    
{
public:
    WamRegPackageConfig();
    ~WamRegPackageConfig();
    
    HRESULT     CreateCatalog(VOID);        //Create an MTS catalog object
    VOID        Cleanup( VOID);             // used for cleaning up state

    HRESULT     CreatePackage
                        (    
                        IN LPCWSTR    szPackageID,
                        IN LPCWSTR    szPackageName,
                        IN LPCWSTR    szIdentity,
                        IN LPCWSTR    szIdPassword
                        );

    HRESULT     RemovePackage
                        (    
                        IN LPCWSTR    szPackageID
                        );
    
    HRESULT     AddComponentToPackage
                        (    
                        IN LPCWSTR    szPackageID,
                        IN LPCWSTR    szComponentCLSID
                        );

    HRESULT     RemoveComponentFromPackage
                        (    
                        IN LPCWSTR szPackageID,
                        IN LPCWSTR szComponentCLSID,
                        IN DWORD   dwAppIsolated
                        );

    BOOL        IsPackageInstalled
                        (
                        IN LPCWSTR szPackageID,
                        IN LPCWSTR szComponentCLSID
                        );

    HRESULT     GetSafeArrayOfCLSIDs    // Create an one element SafeArray object that contains szComponentCLSID
                        (
                        IN LPCWSTR    szComponentCLSID,
                        OUT SAFEARRAY**    pm_aCLSID
                        );
                        
    VOID    ReleaseAll(VOID);
private:

    enum TECatelogObject{eTPackage, eTComponent};

    HRESULT SetPackageProperties( IN LPCWSTR    * rgpszValues);
    HRESULT    SetPackageObjectProperty    
                        (
                        IN LPCWSTR    szPropertyName,
                        IN LPCWSTR    szPropertyValue
                        );

    HRESULT SetComponentObjectProperties(
                                         IN LPCWSTR    szComponentCLSID
                                         );
    HRESULT    SetComponentObjectProperty    
                        (
                        IN ICatalogObject * pComponent,
                        IN LPCWSTR          szPropertyName,
                        IN LPCWSTR          szPropertyValue,
                        BOOL                fPropertyValue = FALSE
                        );

    ICOMAdminCatalog*       m_pCatalog;
    ICatalogCollection*     m_pPkgCollection;
    ICatalogCollection*     m_pCompCollection;
    ICatalogObject*         m_pPackage;

};

//
//    WamRegMetabaseConfig
//    Class defined to access the metabase, read/write application properties from/to Metabase.
//
class WamRegMetabaseConfig
{
public:

    static HRESULT MetabaseInit
                    (
                    VOID
                    );

    static HRESULT MetabaseUnInit
                    (
                    VOID
                    );
    
    static BOOL Initialized( VOID )
    {
        return ( m_pMetabase != NULL );
    }

    HRESULT UpdateMD    
                    (
                    IN MDPropItem*      prgProp,
                    IN DWORD            dwMDAttributes,
                    IN LPCWSTR          wszMetabasePath,
                    IN BOOL             fSaveData = FALSE
                    );
                    
    HRESULT MDUpdateIISDefault
                    (
                    );

    HRESULT MDCreatePath
                    (
                    IN IMSAdminBase *pMetabaseIn,
                    IN LPCWSTR szMetabasePath
                    );

    BOOL    MDDoesPathExist
                    (
                    IN IMSAdminBase *pMetabaseIn,
                    IN LPCWSTR szMetabasePath
                    );

    HRESULT MDSetStringProperty
                    (
                    IN IMSAdminBase * pMetabaseIn,
                    IN LPCWSTR szMetabasePath,
                    IN DWORD szMetabaseProperty,
                    IN LPCWSTR szMetabaseValue,
                    IN DWORD dwMDUserType = IIS_MD_UT_WAM,
                    IN DWORD dwMDAttributes = METADATA_NO_ATTRIBUTES
                    );

    HRESULT MDSetKeyType
                    (
                    IN IMSAdminBase * pMetabaseIn,
                    IN LPCWSTR szMetabasePath,
                    IN LPCWSTR szKeyType
                    );

    HRESULT MDDeleteKey
                    (
                    IN IMSAdminBase * pMetabaseIn,
                    IN LPCWSTR szMetabasePath,
                    IN LPCWSTR szKey
                    );

    HRESULT MDGetDWORD
                    (
                    IN LPCWSTR szMetabasePath, 
                    IN DWORD dwMDIdentifier,
                    OUT DWORD *pdwData
                    );

    HRESULT MDSetAppState
                    (
                    IN LPCWSTR szMetabasePath, 
                    IN DWORD dwState
                    );

    HRESULT MDGetPropPaths
                    (
                    IN LPCWSTR     szMetabasePath,
                    IN DWORD    dwMDIdentifier,
                    OUT    WCHAR**    pBuffer,
                    OUT DWORD*    pdwBufferSize
                    );

    HRESULT MDGetWAMCLSID
                    (
                    IN LPCWSTR szMetabasePath,
                    IN OUT LPWSTR szWAMCLSID
                    );
                    
    HRESULT MDGetIdentity
                    (
                    IN LPWSTR szIdentity,
                    IN DWORD  cbIdentity,
                    IN LPWSTR szPwd,
                    IN DWORD  cbPwd
                    );

    HRESULT MDGetAppName
                    (
                    IN  LPCWSTR     szMetaPath,
                    OUT LPWSTR *    ppszAppName
                    );
    
    HRESULT MDGetStringAttribute
                    (
                    IN LPCWSTR szMetaPath,
                    DWORD dwMDIdentifier,
                    OUT LPWSTR * ppszBuffer
                    );

    HRESULT MDGetAllSiteRoots
                    (
                    OUT LPWSTR * ppszBuffer
                    );

    HRESULT GetSignatureOnPath
                    (
                    IN LPCWSTR pwszMetabasePath,
                    OUT DWORD* pdwSignature
                    );

                    
    HRESULT GetWebServerName
                    (
                    IN LPCWSTR wszMetabasePath, 
                    IN OUT LPWSTR wszWebServerName, 
                    IN UINT cBuffer
                    );

    HRESULT SaveData
                    (
                    VOID
                    );

    HRESULT MDGetLastOutProcPackageID
                    (
                    IN LPCWSTR szMetabasePath,
                    IN OUT LPWSTR szLastOutProcPackageID
                    );

    HRESULT MDRemoveProperty
                    (
                    IN LPCWSTR pwszMetabasePath,
                    DWORD dwIdentifier,
                    DWORD dwType
                    );

    HRESULT MDRemovePropertyByArray
                    (
                    IN MDPropItem*     prgProp
                    );

    VOID    InitPropItemData
                    (
                    IN OUT MDPropItem* pMDPropItem
                    );
                    
    HRESULT MDGetIDs
                    (
                    IN LPCWSTR  szMetabasePath,
                    OUT LPWSTR  szWAMCLSID,
                    OUT LPWSTR  szPackageID,
                    IN DWORD    dwAppMode
                    );

    VOID    MDSetPropItem
                    (
                    IN MDPropItem* prgProps,    
                    IN DWORD     iIndex, 
                    IN LPCWSTR    pwstrVal
                    );
                    
    VOID    MDSetPropItem
                    (
                    IN MDPropItem* prgProps,
                    IN DWORD     iIndex, 
                    IN DWORD    dwVal
                    );

    VOID    MDDeletePropItem
                    (
                    IN MDPropItem* prgProps,
                    IN DWORD     iIndex
                    );
    BOOL    HasAdminAccess
                    (
                    VOID
                    );

private:

    
    DWORD     WamRegChkSum
                    ( 
                    IN LPCWSTR pszKey, 
                    IN DWORD cchKey
                    );


    // Time out for metabase  = 5 seconds
    static const DWORD            m_dwMDDefaultTimeOut;    
    static const MDPropItem        m_rgMDPropTemplate[];

    //
    //  The global metabase pointer, 
    //   created at the WAMREG start up time, 
    //   deleted when WAMREG is shutdown.
    //
    static    IMSAdminBaseW*        m_pMetabase;
    

};

inline HRESULT WamRegMetabaseConfig::SaveData(VOID)
{
    DBG_ASSERT(m_pMetabase);
    return m_pMetabase->SaveData();
}

inline VOID    WamRegMetabaseConfig::MDSetPropItem
(
IN MDPropItem* prgProps,
IN DWORD     iIndex, 
IN LPCWSTR    pwstrVal
)
{
    DBG_ASSERT(prgProps && iIndex < IWMDP_MAX);
    prgProps[iIndex].dwAction = EMD_SET;
    prgProps[iIndex].pwstrVal = (LPWSTR)pwstrVal;
}

inline VOID    WamRegMetabaseConfig::MDSetPropItem
(
IN MDPropItem* prgProps,
IN DWORD     iIndex, 
IN DWORD    dwVal
)
{
    DBG_ASSERT(prgProps && iIndex < IWMDP_MAX);
    prgProps[iIndex].dwAction = EMD_SET;
    prgProps[iIndex].dwVal = dwVal;
}

inline VOID    WamRegMetabaseConfig::MDDeletePropItem
(
IN MDPropItem* prgProps,
IN DWORD     iIndex
)
{
    DBG_ASSERT(prgProps && iIndex < IWMDP_MAX);
    prgProps[iIndex].dwAction = EMD_DELETE;
}

extern    WamRegGlobal            g_WamRegGlobal;
extern    WamRegRegistryConfig    g_RegistryConfig;

#endif // _WAMREG_AUXFUNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\auxfunc.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: Auxfunc.cpp

    implementation of supporting functions for WAMREG, including

    interface to Register and Unregister WAM CLSID in registry,
    interface to Create Package with MTS,

Owner: LeiJin

Note:

===================================================================*/
#include "common.h"
#include "auxfunc.h"
#include "iiscnfgp.h"
#include "dbgutil.h"
#include "iwamreg.h"
#include <inetinfo.h>

//==================================================================
//    Global data definitions
//
//==================================================================

//
// string contains the physical path of wamreg.dll, ie. c:\winnt\system32\inetsrv\wam.dll
//
CHAR    WamRegRegistryConfig::m_szWamDllPath[MAX_PATH];

//
// the permission to access the registry
//
const REGSAM    WamRegRegistryConfig::samDesired =    KEY_READ | KEY_WRITE;

//
//  A thread will first grab a token, and wait until the token matches the m_dwServiceNum,
//  In such way, the order of threads making the requests are perserved.
//  m_hWriteLock (Event) is used for the blocking other threads
//  m_csWAMREGLock is used for access the m_dwServiceToken and m_dwServiceNum
//
//  private global, static variables for WamAdmLock

WamAdmLock              WamRegGlobal::m_WamAdmLock;
WamRegGlobal            g_WamRegGlobal;

WamRegRegistryConfig    g_RegistryConfig;

// 
// Defined at /LM/W3SVC/
// Default package ID(IIS In-Process Application) and the default WAMCLSID(IISWAM.W3SVC).
//
const WCHAR   WamRegGlobal::g_szIISInProcPackageID[] =
                 W3_INPROC_PACKAGE_ID;
const WCHAR   WamRegGlobal::g_szInProcWAMCLSID[] = 
                 W3_INPROC_WAM_CLSID;
const WCHAR   WamRegGlobal::g_szInProcWAMProgID[] = L"IISWAM.W3SVC";

const WCHAR   WamRegGlobal::g_szIISOOPPoolPackageID[] =
                 W3_OOP_POOL_PACKAGE_ID;
const WCHAR   WamRegGlobal::g_szOOPPoolWAMCLSID[] =
                 W3_OOP_POOL_WAM_CLSID;
const WCHAR   WamRegGlobal::g_szOOPPoolWAMProgID[] = L"IISWAM.OutofProcessPool";

const WCHAR   WamRegGlobal::g_szIISInProcPackageName[] = DEFAULT_PACKAGENAME;
const WCHAR   WamRegGlobal::g_szIISOOPPoolPackageName[] = L"IIS Out-Of-Process Pooled Applications";
const WCHAR   WamRegGlobal::g_szMDAppPathPrefix[] = L"/LM/W3SVC/";
const DWORD   WamRegGlobal::g_cchMDAppPathPrefix = 
                 (sizeof(L"/LM/W3SVC/")/sizeof(WCHAR)) - 1;
const WCHAR   WamRegGlobal::g_szMDW3SVCRoot[] = L"/LM/W3SVC";
const DWORD   WamRegGlobal::g_cchMDW3SVCRoot = (sizeof(L"/LM/W3SVC")/sizeof(WCHAR)) - 1;

#ifndef DBGERROR
#define DBGERROR(args) ((void)0) /* Do Nothing */
#endif

BOOL WamRegGlobal::Init(VOID)
{
    return m_WamAdmLock.Init();
}

BOOL WamRegGlobal::UnInit(VOID)
{
    return m_WamAdmLock.UnInit();
}

WamAdmLock::WamAdmLock()
:   m_dwServiceToken(0),
    m_dwServiceNum(0),
    m_hWriteLock((HANDLE)NULL)
{
}

/*===================================================================
Init

Init certain variables for this supporting module of WAMREG.

Return:        NONE
===================================================================*/
BOOL WamAdmLock::Init()
{        
    BOOL fReturn = TRUE;
    
    INITIALIZE_CRITICAL_SECTION(&m_csLock);

    m_hWriteLock = IIS_CREATE_EVENT(
                       "WamAdmLock::m_hWriteLock",
                       &m_hWriteLock,
                       TRUE,
                       TRUE
                       );

    if (m_hWriteLock == NULL)
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to create m_hWriteLock(Event). error = %08x",
            GetLastError()));
        fReturn = FALSE;
        }
    return fReturn;

}

/*===================================================================
UnInit

Uninit certain variables for this supporting module of WAMREG.

Return:        NONE
===================================================================*/
BOOL WamAdmLock::UnInit()
{
    BOOL fReturn = TRUE;
    DeleteCriticalSection(&m_csLock);
    if (m_hWriteLock)
        {
        BOOL fTemp = CloseHandle(m_hWriteLock);
        if ( fTemp == FALSE)
            {
            DBGPRINTF((DBG_CONTEXT, "error in CloseHandle. errno = %d\n", GetLastError()));
            fReturn = FALSE;
            }
        m_hWriteLock = (HANDLE)0;
        }
    return fReturn;
}

/*===================================================================
GetNextServiceToken

Obtain the next service token when a thread enters WAMREG, if the token
obtained by the thread is not the same as m_dwServiceNum, the thread has
to wait until the token it owns is same as m_dwServiceNum.

The function returns a token value.

Return:        DWORD, Next Service Token
===================================================================*/
DWORD WamAdmLock::GetNextServiceToken( )
{
    DWORD dwToken;

    Lock();
    dwToken = m_dwServiceToken;
    m_dwServiceToken++;
    UnLock();

    return dwToken;
}

/*===================================================================
FAppPathAllowConfig

Test to see if we can make configuration changes(Delete/Create) on a path.  Currently,
this function is used to block changes to the default application/package.  The default
in proc package should not be deleted/altered at runtime.

Parameter:
pwszMetabasePath

Return:         BOOL

Side affect:    TRUE if we can configure the app on the app path.
===================================================================*/
BOOL WamRegGlobal::FAppPathAllowConfig
(
IN LPCWSTR pwszMetabasePath
)
{
    BOOL fReturn = TRUE;
    DWORD cchMDPath = 0;

    DBG_ASSERT(pwszMetabasePath);
    // Since szMDPath has a path that always starts with "/LM/W3SVC/", the input size must be
    // greater that length of "/LM/W3SVC/", This check is necessary to protect that the default
    // IIS (inproc) package being deleted by accident. 
    cchMDPath = wcslen(pwszMetabasePath);
    if (cchMDPath <= WamRegGlobal::g_cchMDAppPathPrefix)
        {
        fReturn = FALSE;
        }

    return fReturn;
}

/*===================================================================
FIsW3SVCRoot

Test to see the MetabasePath is same as L"/LM/W3SVC".

Parameter:
pwszMetabasePath

Return:         BOOL

Side affect:    TRUE if we can configure the app on the app path.
===================================================================*/
BOOL WamRegGlobal::FIsW3SVCRoot
(
IN LPCWSTR	wszMetabasePath
)
{
    INT iReturn;
    DBG_ASSERT(wszMetabasePath != NULL);
    
    iReturn = _wcsnicmp(wszMetabasePath, WamRegGlobal::g_szMDW3SVCRoot, WamRegGlobal::g_cchMDW3SVCRoot+1);
    return (iReturn == 0 ? TRUE : FALSE);
}

/*===================================================================
AcquireLock

Get a write lock, there can only be one thread doing work via DCOM interface, (i.e. has the write lock).
All other threads calling WamAdmin interfaces are blocked in this function.  After returning from
this call, the thread is guaranteed to be a "Critical Section".

A simple CriticalSection only solve half of the problem.  It guarantees the mutual exclusive condition.
But once a thread leaves the CS, the CS can not control which blocking threads can access CS next.

Parameter:
NONE.

Return:         HRESULT

Side affect:    Once returned, thread is in a "Critical Section".
===================================================================*/
VOID WamAdmLock::AcquireWriteLock( )
{
    DWORD     dwWaitReturn = WAIT_OBJECT_0;
    DWORD     dwMyToken = GetNextServiceToken();
    BOOL    fIsMyTurn = FALSE;  // Assume it is not my turn before we try to acquire the lock.
    
    DBG_ASSERT(m_hWriteLock);
    do    {
        dwWaitReturn = WaitForSingleObject(m_hWriteLock, INFINITE);

        //
        // Check for successful return.
        //
        if (dwWaitReturn == WAIT_OBJECT_0)        
            {
            Lock();
            if (dwMyToken == m_dwServiceNum)
                {
                fIsMyTurn = TRUE;
                }
            UnLock();
                
            }
        else
            {
            //
            // A failure down this code path might cause a busy loop...
            // However, such failure is very unlikely.  Attach a debugger can tell the story immediately.
            //
            DBGPRINTF((DBG_CONTEXT, "WaitForSingleObject failed, function returns %08x, errno = %08x\n",
                        dwWaitReturn,
                        GetLastError()));
            DBG_ASSERT(FALSE);
            }
    } while (FALSE == fIsMyTurn);
    
    ResetEvent(m_hWriteLock);
    IF_DEBUG(WAMREG_MTS)
        {
        DBGPRINTF((DBG_CONTEXT, "Thread %08x acquired the WriteLock of WAMREG, ServiceNum is %d.\n",
                    GetCurrentThreadId(),
                    dwMyToken));
        }
}

/*===================================================================
ReleaseLock

Release a write lock.  See comments in CWmRgSrv::AcquireLock.

Parameter:
NONE.

Return:         HRESULT

Side affect:    Leave "Critical Section".
===================================================================*/
VOID WamAdmLock::ReleaseWriteLock( )
{
    //CONSIDER: m_dwServerNum out-of-bound
    Lock();
    IF_DEBUG(WAMREG_MTS)
        {
        DBGPRINTF((DBG_CONTEXT, "Thread %08x released the WriteLock of WAMREG, ServiceNum is %d.\n",
            GetCurrentThreadId(),
            m_dwServiceNum));
        }
        
    m_dwServiceNum++;
    SetEvent(m_hWriteLock);
    UnLock();

}


/*===================================================================
RegisterCLSID

Register a WAM CLSID and a ProgID..After a successful registerCLSID call, you
should have

My Computer\HKEY_CLASSES_ROOT\CLSID\{szCLSIDEntryIn}
                                        \InProcServer32     "...physical location of wam.dll"
                                        \ProgID             szProgIDIn
                                        \VersionIndependentProgID   "IISWAM.W3SVC"

Parameter:
szCLSIDEntryIn:     CLSID for a WAM.
szProgIDIn:         ProgID for the WAM.
fSetVIProgID:       TRUE if this function needs to set the Version Independent ProgID.
                    FALSE, Otherwise.

Return:     HRESULT

NOTE: Registry API should use ANSI version, otherwise, it will cause trouble on Win95.

===================================================================*/
HRESULT WamRegRegistryConfig::RegisterCLSID
(
IN LPCWSTR szCLSIDEntryIn,
IN LPCWSTR szProgIDIn,
IN BOOL fSetVIProgID
)
{
    static const CHAR szWAMDLL[]            = "wam.dll";
    static const CHAR szClassDesc[]         = "Web Application Manager Object";
    static const CHAR szThreadingModel[]    = "ThreadingModel";
    static const CHAR szInprocServer32[]    = "InprocServer32";
    static const CHAR szTEXT_VIProgID[]     = "VersionIndependentProgID";
    static const CHAR szTEXT_ProgID[]       = "ProgID";
    static const CHAR szTEXT_Clsid[]        = "Clsid";
    static const CHAR szFreeThreaded[]      = "Free";
    static const CHAR szVIProgID[]          = "IISWAM.Application";

    HRESULT     hr = E_FAIL;
    HKEY        hkeyT = NULL, hkey2 = NULL;
    CHAR         szCLSIDPath[100] = "CLSID\\";   // CLSID\\{....} , less that 100.
    CHAR        szCLSIDEntry[uSizeCLSID];       // ANSI version of CLSID.
    CHAR*        szProgID = NULL;                // a pointer to ANSI version of ProgID.
    DWORD        dwSizeofProgID = 0;             // # of char of ProgID.
    DBG_ASSERT(szProgIDIn);
    DBG_ASSERT(szCLSIDEntryIn);
    
    //
    //    Make a clsid ID.
    //
    WideCharToMultiByte(CP_ACP, 0, szCLSIDEntryIn, -1, szCLSIDEntry, uSizeCLSID, NULL, NULL);
    strncat(szCLSIDPath, szCLSIDEntry, uSizeCLSID);
    
    //
    //  Make a Prog ID.
    //
    // *2 for DBCS enabling for App MD path
    dwSizeofProgID = wcslen(szProgIDIn)*2 + 1;
    szProgID = new CHAR[dwSizeofProgID];
    
    if (NULL == szProgID)
        {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
        }
    WideCharToMultiByte(CP_ACP, 0, szProgIDIn, -1, szProgID, dwSizeofProgID, NULL, NULL);
    
    // install the CLSID key
    // Setting the value of the description creates the key for the clsid
    //
    if ((RegSetValueA(HKEY_CLASSES_ROOT, szCLSIDPath, REG_SZ, szClassDesc,
        strlen(szClassDesc)) != ERROR_SUCCESS))
        goto LErrExit;
    //
    // Open the CLSID key so we can set values on it
    //
    if    (RegOpenKeyExA(HKEY_CLASSES_ROOT, szCLSIDPath, 0, samDesired, &hkeyT) != ERROR_SUCCESS)
            goto LErrExit;
    //
    // install the InprocServer32 key and open the sub-key to set the named value
    //
    if ((RegSetValueA(hkeyT, szInprocServer32, REG_SZ, m_szWamDllPath, strlen(m_szWamDllPath)) != ERROR_SUCCESS) ||
        (RegOpenKeyExA(hkeyT, szInprocServer32, 0, samDesired, &hkey2) != ERROR_SUCCESS))
        goto LErrExit;
    //
    // install the ProgID key and version independent ProgID key
    //
    if ((RegSetValueA(hkeyT, szTEXT_ProgID, REG_SZ, szProgID, strlen(szProgID)) != ERROR_SUCCESS) ||
        (RegSetValueA(hkeyT, szTEXT_VIProgID, REG_SZ, szVIProgID, strlen(szVIProgID)) != ERROR_SUCCESS))
        goto LErrExit;

    if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
            goto LErrExit;

    hkeyT = hkey2;
    hkey2 = NULL;
    //
    // install the ThreadingModel named value
    //
    if (RegSetValueExA(hkeyT, szThreadingModel, 0, REG_SZ, (const BYTE *)szFreeThreaded,
        strlen(szFreeThreaded)) != ERROR_SUCCESS)
        goto LErrExit;
    if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
        goto LErrExit;
    else
        hkeyT = NULL;

   // Set up ProgID key
    if ((RegSetValueA(HKEY_CLASSES_ROOT, szProgID, REG_SZ, szClassDesc,
        strlen(szClassDesc)) != ERROR_SUCCESS))
        goto LErrExit;

    if  (RegOpenKeyExA(HKEY_CLASSES_ROOT, szProgID, 0, samDesired, &hkeyT) != ERROR_SUCCESS)
        goto LErrExit;

    if ((RegSetValueA(hkeyT, szTEXT_Clsid, REG_SZ, szCLSIDEntry, strlen(szCLSIDEntry)) != ERROR_SUCCESS))
        goto LErrExit;

    if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
        goto LErrExit;
    else
        hkeyT = NULL;

    // Set up Version Independent key only at setup IIS default time
    if (fSetVIProgID)
        {
        if ((RegSetValueA(HKEY_CLASSES_ROOT, szVIProgID, REG_SZ, szClassDesc,
            strlen(szClassDesc)) != ERROR_SUCCESS))
            goto LErrExit;

        if  (RegOpenKeyExA(HKEY_CLASSES_ROOT, szVIProgID, 0, samDesired, &hkeyT) != ERROR_SUCCESS)
            goto LErrExit;

        if ((RegSetValueA(hkeyT, szTEXT_Clsid, REG_SZ, szCLSIDEntry, strlen(szCLSIDEntry)) != ERROR_SUCCESS))
            goto LErrExit;

        if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
            goto LErrExit;
        else
            hkeyT = NULL;
        }

    hr = NOERROR;


LErrExit:
    if (szProgID)
        {
        delete [] szProgID;
        szProgID = NULL;
        }

    if (hkeyT)
        {
        RegCloseKey(hkeyT);
        }
    if (hkey2)
        {
        RegCloseKey(hkey2);
        }

    return hr;
}

/*===================================================================
UnRegisterCLSID    

UnRegister a WAM CLSID & a corresponding WAM PROG ID.

Parameter:
szCLSIDEntryIn:    [in]     CLSID for a WAM.
fDeleteVIProgID:        TRUE, to delete the version independent prog id, FALSE, not touch VI progID.

Return:        HRESULT
===================================================================*/
HRESULT WamRegRegistryConfig::UnRegisterCLSID
(
IN LPCWSTR wszCLSIDEntryIn, 
IN BOOL fDeleteVIProgID
)
{
    HRESULT        hr = E_FAIL;
    HKEY        hkey = NULL;
    CHAR        szCLSIDEntry[uSizeCLSID];
    CHAR        szCLSIDPath[100] = "CLSID\\";
    WCHAR        *szProgID = NULL;
    CLSID       Clsid_WAM;
    static      const WCHAR szVIProgID[]    = L"IISWAM.Application";

    DBG_ASSERT(wszCLSIDEntryIn);
    //
    //    Make a clsid ID.
    //
    WideCharToMultiByte(CP_ACP, 0, wszCLSIDEntryIn, -1, szCLSIDEntry, uSizeCLSID, NULL, NULL);
    strncat(szCLSIDPath, szCLSIDEntry, uSizeCLSID);

    //
    // UnRegister ProgID and Version Independent Prog ID.
    //
    hr = CLSIDFromString((WCHAR *)wszCLSIDEntryIn, &Clsid_WAM);
    if (SUCCEEDED(hr))
        {
        hr = ProgIDFromCLSID(Clsid_WAM, &szProgID);    
        if (SUCCEEDED(hr))
            {
            hr = UnRegisterProgID(szProgID);
            CoTaskMemFree(szProgID);
            szProgID = NULL;
            }
        else
            {
            DBGPRINTF((DBG_CONTEXT, "error = %08x\n", hr));
            }
        }
    else
        {
        DBGPRINTF((DBG_CONTEXT, "error = %08x\n", hr));
        }


    if (fDeleteVIProgID)
        {
        hr = UnRegisterProgID(szVIProgID);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "error = %08x\n", hr));
            }
        }

    DWORD dwReg;
    //
    // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
    //
    dwReg = RegOpenKeyExA(HKEY_CLASSES_ROOT, szCLSIDPath, 0, samDesired, &hkey);
    if    (dwReg == ERROR_SUCCESS)
        {    
        DWORD        iKey = 0;
        CHAR        szKeyName[MAX_PATH];  
        DWORD        cbKeyName;
        //
        // Enumerate all its subkeys, and delete them
        //    for (iKey=0;;iKey++) might not work with multiple sub keys, the last interation has iKey >
        // the actually number of subkeys left.  Set iKey = 0, so that we can always delete them all.
        //
        while(TRUE)
            {
            cbKeyName = sizeof(szKeyName);
            if (RegEnumKeyExA(hkey, iKey, szKeyName, &cbKeyName, 0, NULL, 0, NULL) != ERROR_SUCCESS)
                break;

            if (RegDeleteKeyA(hkey, szKeyName) != ERROR_SUCCESS)
                break;
            }

        // Close the key, and then delete it
        dwReg = RegCloseKey(hkey);
        if ( dwReg != ERROR_SUCCESS)
            {
            DBGPRINTF((DBG_CONTEXT, "error = %08x\n", HRESULT_FROM_WIN32(dwReg)));
            }
        }

    dwReg = RegDeleteKeyA(HKEY_CLASSES_ROOT, szCLSIDPath);
    if ( dwReg != ERROR_SUCCESS)
        {
        DBGPRINTF((DBG_CONTEXT, "error = %08x\n", HRESULT_FROM_WIN32(dwReg)));
        }

    //
    // Return hr Result
    //
    if (SUCCEEDED(hr))
        {
        if (dwReg != ERROR_SUCCESS)
            {
            hr = HRESULT_FROM_WIN32(dwReg);
            }
        }
    else
        {
        DBG_ASSERT((DBG_CONTEXT, "Failed to UnRegisterCLSID, %S, fDeleteVIProgID = %s\n",
            wszCLSIDEntryIn,
            (fDeleteVIProgID ? "TRUE" : "FALSE")));
        }
        
    return hr;
}

/*===================================================================
UnRegisterProgID

UnRegister a Prog ID.

Parameter:
szProgID:    [in]     Prog ID can be a version independent Prog ID.

Return:        HRESULT
===================================================================*/
HRESULT WamRegRegistryConfig::UnRegisterProgID
(
IN LPCWSTR szProgIDIn
)
{
    HKEY        hkey = NULL;
    DWORD        iKey;
    DWORD        cbKeyName;
    DWORD        dwSizeofProgID;
    CHAR        szKeyName[255];
    CHAR*        szProgID = NULL;
    HRESULT        hr = E_FAIL;

    DBG_ASSERT(szProgIDIn);
    //
    //  Make a Prog ID.
    //
    // DBCS enabling *2
    dwSizeofProgID = wcslen(szProgIDIn)*2 + 1;
    szProgID = new CHAR[dwSizeofProgID];
    
    if (NULL == szProgID)
        {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
        }
    WideCharToMultiByte(CP_ACP, 0, szProgIDIn, -1, szProgID, dwSizeofProgID, NULL, NULL);
    
    // Open the HKEY_CLASSES_ROOT\szProgID key so we can delete its subkeys
    if    (RegOpenKeyExA(HKEY_CLASSES_ROOT, szProgID, 0, samDesired, &hkey) != ERROR_SUCCESS)
        goto LErrExit;

    // Enumerate all its subkeys, and delete them
    for (iKey=0;;iKey++)
        {
        cbKeyName = sizeof(szKeyName);
        if (RegEnumKeyExA(hkey, iKey, szKeyName, &cbKeyName, 0, NULL, 0, NULL) != ERROR_SUCCESS)
            break;

        if (RegDeleteKeyA(hkey, szKeyName) != ERROR_SUCCESS)
            goto LErrExit;
        }

    // Close the key, and then delete it
    if (RegCloseKey(hkey) != ERROR_SUCCESS)
        goto LErrExit;
    else
        hkey = NULL;
        
    if (RegDeleteKeyA(HKEY_CLASSES_ROOT, szProgID) != ERROR_SUCCESS)
        goto LErrExit;

    hr = NOERROR;

LErrExit:
    if (szProgID)
        delete [] szProgID;

    if (hkey)
        RegCloseKey(hkey);
        
    return hr;
}


/*===================================================================
LoadWamDllPath    

Read Wam Dll Path from Registry.  This function is implemented in ANSI version
of Registry API(Win95 compatibility).

Parameter:

Return:     HRESULT
Side Affect:
    NONE.
===================================================================*/
HRESULT WamRegRegistryConfig::LoadWamDllPath
(
void
)
{
    LONG    lReg = 0;
    HKEY    hKey = NULL;
    HRESULT hr = NOERROR;

    m_szWamDllPath[0] = '\0';
    
    lReg = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                    "Software\\Microsoft\\InetStp",
                    0,
                    KEY_READ,
                    &hKey);

    if (lReg == ERROR_SUCCESS) 
        {
        LONG    lErr = 0;
        DWORD    dwType;
        CHAR    szWamDllName[] = "\\wam.dll";
        DWORD    cbData = (sizeof(m_szWamDllPath) - sizeof(szWamDllName));

        lErr = RegQueryValueExA(hKey,
                    "InstallPath",
                    0,
                    &dwType,
                    (LPBYTE)m_szWamDllPath,
                    &cbData);

        if (lErr == ERROR_SUCCESS)
            {
            if (dwType == REG_SZ) 
                {    
                strncat(m_szWamDllPath, szWamDllName, sizeof(szWamDllName));
                hr = NOERROR;
                }
            else
                {
                hr = E_UNEXPECTED;
                DBGPRINTF((DBG_CONTEXT, "Wrong Type for InstallPath registry key.dwType = %d\n",
                        dwType));
                }
            }
        else
            {
            hr = HRESULT_FROM_WIN32(lErr);
            }
        RegCloseKey(hKey);
        }
    else
        {
        hr = HRESULT_FROM_WIN32(lReg);
        }

    return hr;
}

/*===================================================================
SzWamProgID    

Make a WAM Prog ID, if the MetabasePath is null, assume it is the default,
that is WAM de
fault, so, it will be IISWAM.W3SVC.  Otherwise, the format is
IISWAM.__1__Application__Path where application path is \\LM\w3svc\1\
Application_path.

Parameter:
szMetabasePath:            [in] MetabasePath.

Return:        
TYPE:    LPWSTR, a string contains ProgID
        NULL, if failed.
        
Side Affect:
    Allocate memory for return result use new.  Caller needs to free szWamProgID 
use delete[].
===================================================================*/
HRESULT WamRegGlobal::SzWamProgID    
(
IN LPCWSTR pwszMetabasePath,
OUT LPWSTR* ppszWamProgID
)
{
    HRESULT            hr = NOERROR;
    static WCHAR    wszIISProgIDPreFix[]    = L"IISWAM.";   
    WCHAR            *pwszResult = NULL;
    WCHAR            *pwszApplicationPath = NULL;
    UINT             uPrefixLen = (sizeof(wszIISProgIDPreFix) / sizeof(WCHAR));


    DBG_ASSERT(pwszMetabasePath);
    *ppszWamProgID = NULL;

    //
    // Make a new WAM Prog ID based on pwszMetabasepath
    //
    WCHAR     *pStr, *pResult;
    UINT    uSize = 0;

    //
    // CONSIDER: use (sizeof(L"/LM/W3SVC/")/sizeof(WCHAR) - 1) for 10
    // CONSIDER: use global const for L"/LM/W3SVC/"
    // Since all paths start with /LM/W3SVC/, omit the prefix.
    //
    if (_wcsnicmp(pwszMetabasePath, L"\\LM\\W3SVC\\", 10) == 0 ||
        _wcsnicmp(pwszMetabasePath, L"/LM/W3SVC/", 10) == 0)
        {
        pwszApplicationPath = (WCHAR *)(pwszMetabasePath + 10);
        }
    else
        {
        *ppszWamProgID = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

    if (SUCCEEDED(hr))
        {
        pStr = pwszApplicationPath;
        //
        // Calculate uSize for allocation
        //
        while(*pStr != NULL)
            {
            //
            // '/' or '\\' will be converted to '__', from 1 char to 2 chars.
            //
            if (*pStr == '\\' || *pStr == '/')
                uSize ++;
            pStr++;
            uSize++;
            }

        DBG_ASSERT(uSize > 0);
        uSize += uPrefixLen;
        
        // uSize takes the null terminator into count.
        pwszResult = new WCHAR[uSize];
        if (pwszResult != NULL)
            {
            wcsncpy(pwszResult, wszIISProgIDPreFix, uPrefixLen);
            pStr = pwszApplicationPath;
            pResult = pwszResult + uPrefixLen - 1;
            
            while(*pStr != NULL)
                {
                if (*pStr == '\\' || *pStr == '/')
                    {
                    *pResult++ = '_';
                    *pResult++ = '_';
                    pStr++;
                    }
                else
                    {
                    *pResult++ = *pStr++;
                    }
                }

            // NULL Terminating the result
            pwszResult[uSize-1] = '\0';
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    if (SUCCEEDED(hr))
        {
        *ppszWamProgID = pwszResult;
        }
        
    return hr;
}

/*===================================================================
GetViperPackageName    

Make a Package Name.  Follow the naming conversion, "IIS-{web site name/
application name}"

Parameter:
szMetabasePath:            [in] MetabasePath.

Return:        HRESULT
Side Affect:
    Allocate memory for return result use new.  Caller needs to free 
szPackageName using delete[].
===================================================================*/
HRESULT    WamRegGlobal::GetViperPackageName    
(
IN LPCWSTR    wszMetabasePath,
OUT LPWSTR*    ppszPackageNameOut
)
{
    static WCHAR    wszPackageNamePreFix[]        = L"IIS-{";
    static WCHAR    wszPackageNamePostFix[]        = L"}";
    WCHAR            wszServerName[500];

    WCHAR*            pwszPackageName;
    WCHAR            *wszResult = NULL;
    WCHAR             *pStr, *pResult;
    
    UINT            cPackageName = 0;
    UINT            cServerName = 0;
    UINT            uSize = 0;

    HRESULT         hr = NOERROR;
    WamRegMetabaseConfig    MDConfig;

    if ((_wcsnicmp(wszMetabasePath, WamRegGlobal::g_szMDAppPathPrefix, WamRegGlobal::g_cchMDAppPathPrefix) == 0) ||
        (_wcsnicmp(wszMetabasePath, WamRegGlobal::g_szMDAppPathPrefix, WamRegGlobal::g_cchMDAppPathPrefix) == 0))
        {
        hr = MDConfig.GetWebServerName(wszMetabasePath, wszServerName, sizeof(wszServerName));
        if (SUCCEEDED(hr))
            {
            cServerName = wcslen(wszServerName);
            }
        }
    else
        {
        hr = E_FAIL;
        DBGPRINTF((DBG_CONTEXT, "Unknown metabase path %S\n", wszMetabasePath));
        DBG_ASSERT(FALSE);    // Confused ??? MetabasePath has other format? not start with /LM/W3SVC/ ???
        }

    if (SUCCEEDED(hr))
        {
        pwszPackageName = (WCHAR *)(wszMetabasePath + 10);
        // Explanation: skip the 1 at /LM/W3SVC/1/, 1 is the virtual server, the 
        // naming conversion
        // will replace the number 1 with some nice name(from GetWebServerName call).
        while(*pwszPackageName != NULL)
            {
                if (*pwszPackageName == L'\\' || *pwszPackageName == L'/')
                    break;
                pwszPackageName++;
            }
        
        DBG_ASSERT(pwszPackageName != NULL);    // We must be able find '\\' or '/' before we scan the whole path.
        cPackageName = wcslen(pwszPackageName);

        pStr = pwszPackageName;
        // 8 = wcslen(TEXT("IIS-{")) + wcslen(TEXT("}")) + '/' + null terminator
        uSize = 8 + cPackageName + cServerName;

        wszResult = new WCHAR [uSize];
        if (wszResult != NULL)
            {
            //
            // IIS-{
            //
            pResult = wszResult;
            wcsncpy(wszResult, wszPackageNamePreFix, sizeof(wszPackageNamePreFix) / sizeof(WCHAR));
            pResult += sizeof(wszPackageNamePreFix) / sizeof(WCHAR) - 1;

            //
            // IIS-{ Web Sever Name
            //
            wcsncpy(pResult, wszServerName, cServerName + 1);
            pResult += cServerName;
            
            //
            // IIS-{  Web Server Name /
            //
            wcsncpy(pResult, L"/", sizeof(L"/"));
            pResult += 1;    // sizeof(TEXT("/")) == 2

            //
            // IIS-{  Web Server Name / PackageName(ApplicationName)
            //
            wcsncpy(pResult, pwszPackageName, cPackageName + 1);
            pResult += cPackageName;

            //
            // IIS-{  Web Server Name / PackageName(ApplicationName)  }  \n
            //
            wcsncpy(pResult, wszPackageNamePostFix, sizeof(wszPackageNamePostFix) / sizeof(WCHAR));
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }
        
    if (FAILED(hr))
        {
        if (wszResult)
            {
            delete[] wszResult;
            wszResult = NULL;
            }
        *ppszPackageNameOut = NULL;
        }
    else
        {
        DBG_ASSERT(wszResult);
        *ppszPackageNameOut = wszResult;
        }
        
    return hr;
}

/*===================================================================
ConstructFullPath

When use GetDataPaths call, it only returns patial path relative to a metabase path.
(sub node of a metabase path).  This fuction will contruct the complete metabase path to
a sub node.

Parameter:
pwszMetabasePathPrefix:         [in] MetabasePath.
pwszPartialPath
ppwszResult                     result buffer
Return:     HRESULT
Side Affect:
    Allocate memory for return result use new.  Caller needs to free
*ppwszResult using delete[].
===================================================================*/
HRESULT WamRegGlobal::ConstructFullPath
(
IN LPCWSTR pwszMetabasePathPrefix,
IN DWORD dwcPrefix,
IN LPCWSTR pwszPartialPath,
OUT LPWSTR* ppwszResult
)
{
    HRESULT    hr = NOERROR;
    DWORD    cchPrefix = dwcPrefix;
    DWORD    cchPartialPath = 0;
    DWORD    cchFullPath = 0;
    WCHAR    *pResult = NULL;
    BOOL    fHasEndSlash = FALSE;

    DBG_ASSERT(pwszPartialPath != NULL);
    
    if (pwszMetabasePathPrefix[dwcPrefix-1] == L'\\' ||
        pwszMetabasePathPrefix[dwcPrefix-1] == L'/')
        {
        cchPrefix--;    
        }

    cchPartialPath = wcslen(pwszPartialPath);

    // Skip the ending '/' of pwszPartialPath if thereis any.
    
    if (cchPartialPath > 0 && 
       (pwszPartialPath[cchPartialPath-1] == L'/' 
       || pwszPartialPath[cchPartialPath-1] == L'\\'))
         {
         cchPartialPath--;
         fHasEndSlash=TRUE;
         }

    cchFullPath = cchPrefix + cchPartialPath + 1;

    pResult = new WCHAR [cchFullPath];

    if (pResult)
        {
        memcpy(pResult, pwszMetabasePathPrefix, cchPrefix*sizeof(WCHAR));
        memcpy(pResult+cchPrefix, pwszPartialPath, cchPartialPath*sizeof(WCHAR));
        pResult[cchFullPath-1] = L'\0';
        }
    else
        {
        hr = E_OUTOFMEMORY;
        }

    *ppwszResult = pResult;

    return hr;
}

/*===================================================================
GetNewSzGUID    

Generate a new GUID and put into *ppszGUID.

Parameter:
LPWSTR *ppszGUID    a pointer to an array, allocated in this function
                    and freed by caller.

Return:     HRESULT
===================================================================*/
HRESULT WamRegGlobal::GetNewSzGUID(OUT LPWSTR *ppszGUID)
{
    GUID    GUID_Temp;
    HRESULT hr;

    DBG_ASSERT(ppszGUID);
    
    // Create a new WAM CLSID
    hr = CoCreateGuid(&GUID_Temp);
    if (SUCCEEDED(hr))
        {
        hr = StringFromCLSID(GUID_Temp, ppszGUID);
        if (FAILED(hr))
            {
            *ppszGUID = NULL;
            }
        }
    return hr;
}

/*===================================================================
CreatePooledApp    

Register a WAM CLSID.

Parameter:
szMetabasePath:        [in]     MetabaseKey.

Return:        HRESULT
===================================================================*/
HRESULT WamRegGlobal::CreatePooledApp
( 
IN LPCWSTR szMetabasePath,
IN BOOL    fInProc,
IN BOOL    fRecover 
)
    {
    HRESULT         hr = NOERROR;
    WamRegMetabaseConfig   MDConfig;
    
    DBG_ASSERT(szMetabasePath);        
    if (SUCCEEDED(hr))
        {
        MDPropItem     rgProp[IWMDP_MAX];

        MDConfig.InitPropItemData(&rgProp[0]);

        // Update APPRoot
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ROOT, szMetabasePath);

        //Update AppIsolated
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ISOLATED, 
                                (fInProc) ? static_cast<DWORD>(eAppRunInProc) 
                                          : static_cast<DWORD>(eAppRunOutProcInDefaultPool));

        //
        // in case this is an recover operation, we do not remove App Friendly Name.
        //
        if (!fRecover)
            {
            MDConfig.MDSetPropItem(&rgProp[0], IWMDP_FRIENDLY_NAME, L"");
            }

        hr = MDConfig.UpdateMD( rgProp, METADATA_INHERIT, szMetabasePath );
        }
            
    if (FAILED(hr))
        {
        HRESULT hrT = NOERROR;

        DBGPRINTF((DBG_CONTEXT, "Failed to create in proc application. path = %S, error = %08x\n",
            szMetabasePath,
            hr));
        }

    return hr;
    }

/*===================================================================
CreateOutProcApp

Create an out prop application.

Parameter:
szMetabasePath:     [in]    MetabaseKey.
fRecover            [in]    if TRUE, we recover/recreate the application.
fSaveMB             [in]    if TRUE, save metabase immediately
Return:     HRESULT
===================================================================*/

HRESULT WamRegGlobal::CreateOutProcApp(
    IN LPCWSTR szMetabasePath,
    IN BOOL fRecover, /* = FALSE */
    IN BOOL fSaveMB   /* = TRUE */
    )
{
    WCHAR        *szWAMCLSID = NULL;
    WCHAR         *szPackageID = NULL; 
    WCHAR        *szNameForNewPackage = NULL;
    HRESULT        hr;
    HRESULT        hrRegister = E_FAIL;
    HRESULT        hrPackage = E_FAIL;
    HRESULT        hrMetabase = E_FAIL;
    WCHAR        szIdentity[MAX_PATH];
    WCHAR        szPwd[MAX_PATH];

    WamRegMetabaseConfig    MDConfig;
    WamRegPackageConfig     PackageConfig;
    
    DBG_ASSERT(szMetabasePath);        

    hr = GetNewSzGUID(&szWAMCLSID);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to create a new szGUID. error = %08x\n", hr));
        return hr;
        }
    else
        {
        WCHAR    *szProgID = NULL;
        // Do WAM CLSID registration
        //
        hr = SzWamProgID(szMetabasePath, &szProgID);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Create WAM ProgID, hr = %08x\n",
                hr));
            }
        else
            {
            hr = g_RegistryConfig.RegisterCLSID(szWAMCLSID, szProgID, FALSE);
            hrRegister = hr;
            delete [] szProgID;
            szProgID = NULL;
            if (FAILED(hrRegister)) 
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to registerCLSID. error %08x\n", hr));
                }
            }
        }

    if (SUCCEEDED(hr))
        {
        WCHAR szLastOutProcPackageID[uSizeCLSID];

        // 
        // When an outproc package gets deleted, it might/might not removed from the MTS,
        // the next time, same app path marked as out-proc again, we try to reuse the outproc
        // package.  Therefore, we need to save the OutprogPackageID as LastOutProcPackageID.
        //
        szLastOutProcPackageID[0] = NULL;
            
        MDConfig.MDGetLastOutProcPackageID(szMetabasePath, szLastOutProcPackageID);        
        if (szLastOutProcPackageID[0] == NULL)
            {
            hr = GetNewSzGUID(&szPackageID);
            }
        else
            {
            szPackageID = (WCHAR *)CoTaskMemAlloc(uSizeCLSID*sizeof(WCHAR));
            if (szPackageID == NULL)
                {
                hr = E_OUTOFMEMORY;
                }
            else
                {
                wcsncpy(szPackageID, szLastOutProcPackageID, uSizeCLSID);
                }
            }
        }

    if (SUCCEEDED(hr))
        {
        hr = GetViperPackageName(szMetabasePath, &szNameForNewPackage);
        }

    if (SUCCEEDED(hr))
        {
        hr = MDConfig.MDGetIdentity(szIdentity, sizeof(szIdentity), szPwd, sizeof(szPwd));
        }

    if (SUCCEEDED(hr))
        {
        //
        // Create the catalog object etc for MTS configuration
        //
        hr = PackageConfig.CreateCatalog();

        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
            }
        else
            {
            hr = PackageConfig.CreatePackage(
                                szPackageID,
                                szNameForNewPackage,
                                szIdentity,
                                szPwd );

            if (SUCCEEDED(hr))
                {
                hr  = PackageConfig.AddComponentToPackage(
                                                szPackageID,
                                                szWAMCLSID);
                if (FAILED(hr))
                    {
                    PackageConfig.RemovePackage(szPackageID);
                    }
                }
            }

        hrPackage = hr;
        }

    
    if (SUCCEEDED(hr))
        {
        MDPropItem     rgProp[IWMDP_MAX];

        MDConfig.InitPropItemData(&rgProp[0]);
        
        // Update WAMCLSID
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_WAMCLSID, szWAMCLSID);
            
        // Update APPRoot
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ROOT, szMetabasePath);

        //Update AppIsolated
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_ISOLATED, 1);

        //Update AppPackageName
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_PACKAGE_NAME, szNameForNewPackage);

        //Update AppPackageID
        MDConfig.MDSetPropItem(&rgProp[0], IWMDP_PACKAGEID, szPackageID);
        
        //
        // in case this is an recover operation, we do not remove App Friendly Name.
        //
        if (!fRecover)
            {
            // It doesn't really make sense to set this on every isolated application.
            // This will be much easier to administer globally if we allow it to be set
            // at a higher level.

            // MDConfig.MDSetPropItem(&rgProp[0], IWMDP_OOP_RECOVERLIMIT, APP_OOP_RECOVER_LIMIT_DEFAULT);
            
            MDConfig.MDSetPropItem(&rgProp[0], IWMDP_FRIENDLY_NAME, L"");
            }
            
        // Attempt to Save the metabase changes immediately. We want to ensure
        // that the COM+ package is not orphaned.
        hr = MDConfig.UpdateMD(rgProp, METADATA_INHERIT, szMetabasePath, fSaveMB );
            
        if (FAILED(hr))
            {
            // Removed AbortUpdateMD call - we shouldn't wax the MB settings or
            // we will orphan the COM+ package.
            DBGPRINTF((
                DBG_CONTEXT, 
                "Failed to set metabase properties on (%S). error == %08x\n",
                szMetabasePath,
                hr
                ));
            }

        hrMetabase = hr;
        }

    if (FAILED(hr))
        {
        HRESULT hrT = NOERROR;

        DBGPRINTF((DBG_CONTEXT, "Failed to create out proc application. path = %S, error = %08x\n",
            szMetabasePath,
            hr));
            
        if (SUCCEEDED(hrPackage))
            {
            hrT = PackageConfig.RemovePackage( szPackageID);
            }
        if (SUCCEEDED(hrRegister))
            {
            hrT = g_RegistryConfig.UnRegisterCLSID(szWAMCLSID, FALSE);    
            if (FAILED(hrT))
                {
                DBGPRINTF((DBG_CONTEXT, "Rollback: Failed to UnRegisterCLSID. error = %08x\n", hr));
                }
            }
        }
    
    if (szWAMCLSID)
        {
        CoTaskMemFree(szWAMCLSID);
        szWAMCLSID = NULL;
        }

    if (szPackageID)
        {
        CoTaskMemFree(szPackageID);
        szWAMCLSID = NULL;
        }

    if (szNameForNewPackage)
        {
        delete [] szNameForNewPackage;
        szNameForNewPackage = NULL;
        }

    return hr;
}

HRESULT 
WamRegGlobal::CreateOutProcAppReplica(
    IN LPCWSTR szMetabasePath,
    IN LPCWSTR szAppName,
    IN LPCWSTR szWamClsid,
    IN LPCWSTR szAppId
    )
/*++
Function:

    Called by the DeSerialize replication method to create a
    new oop application.

Arguments:

    szMetabasePath  
    szAppName       
    szWamClsid      
    szAppId         

Return:

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT(szMetabasePath);
    DBG_ASSERT(szWamClsid);
    DBG_ASSERT(szAppId);

    //
    // Register wam.dll as a new component
    //

    WCHAR * szProgID = NULL;
    BOOL    fRegisteredWam = FALSE;

    hr = SzWamProgID(szMetabasePath, &szProgID);
    if( SUCCEEDED(hr) )
    {
        DBG_ASSERT( szProgID != NULL );
        
        hr = g_RegistryConfig.RegisterCLSID( szWamClsid, 
                                             szProgID, 
                                             FALSE
                                             );
        if( SUCCEEDED(hr) )
        {
            fRegisteredWam = TRUE;
        }

        delete [] szProgID;
        szProgID = NULL;
    }

    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to register wam.dll. hr=%08x\n",
                    hr
                    ));
    }

    //
    // Get required application info
    //
    BOOL    fGetCOMAppInfo = FALSE;
    WCHAR   szIdentity[MAX_PATH];
    WCHAR   szPwd[MAX_PATH];

    WamRegMetabaseConfig    MDConfig;
    
    if( fRegisteredWam )
    {
        hr = MDConfig.MDGetIdentity( szIdentity, 
                                     sizeof(szIdentity), 
                                     szPwd, 
                                     sizeof(szPwd)
                                     );
        if( SUCCEEDED(hr) )
        {
            fGetCOMAppInfo = TRUE;
        }
        else
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed get required COM application info. hr=%08x\n",
                        hr
                        ));
        }
    }

    //
    // Create the COM+ application
    //

    if( fGetCOMAppInfo )
    {
        WamRegPackageConfig PackageConfig;
    
        hr = PackageConfig.CreateCatalog();

        if( SUCCEEDED(hr) )
        {
            hr = PackageConfig.CreatePackage(
                                szAppId,
                                szAppName,
                                szIdentity,
                                szPwd );
            if( SUCCEEDED(hr) )
            {
                hr  = PackageConfig.AddComponentToPackage(
                            szAppId,
                            szWamClsid
                            );
            }

            // On failure we might want to cleanup, but I'm not sure
            // that really makes sense.
        }

        // At this point, we would normally set the metabase properties
        // but we will let the MB replication handle that for us.
        // Note: if the MB replication fails, we will be left with
        // a bunch of orphaned com applications

        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "COM+ App creation failed. AppId(%S) Name(%S) "
                       "Clsid(%S) hr=%08x\n",
                       szAppId,
                       szAppName,
                       szWamClsid,
                       hr
                       ));
        }
    }

    return hr;
}

/*===================================================================
DeleteApp

Register a WAM CLSID.

Parameter:
szMetabasePath:     [in]    MetabaseKey.
fDeletePackage:     [in]    when uninstall, this flag is true, we delete all IIS created packages.
fRemoveAppPool      [in]    Should the AppPoolId Property be removed
Return:     HRESULT
===================================================================*/
HRESULT WamRegGlobal::DeleteApp
(
IN LPCWSTR szMetabasePath,
IN BOOL fRecover,
IN BOOL fRemoveAppPool
)
{
    WCHAR   szWAMCLSID[uSizeCLSID];
    WCHAR   szPackageID[uSizeCLSID];
    DWORD   dwAppMode = eAppRunInProc;
    DWORD   dwCallBack;
    HRESULT hr, hrRegistry;
    METADATA_HANDLE hMetabase = NULL;
    WamRegMetabaseConfig    MDConfig;
    
    hr = MDConfig.MDGetDWORD(szMetabasePath, MD_APP_ISOLATED, &dwAppMode);

    // return immediately, no application is defined, nothing to delete.
    if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
        return NOERROR;
        }

    if (FAILED(hr))
        {
        return hr;
        }
        
    //
    //Set App State to be PAUSE/DISABLE, so that after we remove the application from
    //run time WAM_DICTATOR lookup table, new request won't trigger the application to
    //retstart.
    //WAM_DICTATOR has code to check for this state.
    //
    hr = MDConfig.MDSetAppState(szMetabasePath, APPSTATUS_PAUSE);
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "MDSetAppState Failed hr=%08x\n",
                    hr
                    ));
    }

    hr = W3ServiceUtil(szMetabasePath, APPCMD_DELETE, &dwCallBack);
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "W3ServiceUtil APPCMD_DELETE Failed on (%S) hr=%08x\n",
                    szMetabasePath,
                    hr
                    ));
    }

    if (dwAppMode == eAppRunOutProcIsolated)
        {
        // Get WAM_CLSID, and PackageID.
        hr = MDConfig.MDGetIDs(szMetabasePath, szWAMCLSID, szPackageID, dwAppMode);
        // Remove the WAM from the package.
        if (SUCCEEDED(hr))
            {
            WamRegPackageConfig     PackageConfig;
            HRESULT hrPackage;
            
            hr = PackageConfig.CreateCatalog();

            if ( FAILED( hr)) 
                {
                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to Create MTS catalog hr=%08x\n",
                            hr));
                } 
            else 
                {            
                hr = PackageConfig.RemoveComponentFromPackage(szPackageID, 
                                               szWAMCLSID, 
                                               dwAppMode);
                if (FAILED(hr))    
                    {
                        DBGPRINTF((DBG_CONTEXT, "Failed to remove component from package, \npackageid = %S, wamclsid = %S, hr = %08x\n",
                                   szPackageID,
                                   szWAMCLSID,
                                   hr));
                    }
                }
            hrPackage = hr;
            }

        // Unregister WAM
        hr = g_RegistryConfig.UnRegisterCLSID(szWAMCLSID, FALSE);    
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to UnRegister WAMCLSID(%S), hr = %08x\n",
                szWAMCLSID,
                hr));
            hrRegistry = hr;
            }
        }
        
    if (SUCCEEDED(hr))
        {
        BOOL fChanged = FALSE;
        MDPropItem     rgProp[IWMDP_MAX];
        MDConfig.InitPropItemData(&rgProp[0]);
        if (dwAppMode == static_cast<DWORD>(eAppRunOutProcIsolated))
            {    
            // Delete AppPackageName.  (Inherited from W3SVC)
            // Delete AppPackageID. (Inherited from W3SVC)
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_PACKAGE_NAME);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_PACKAGEID);

            // Delete WAMCLSID
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_WAMCLSID);
            
            if (TsIsNtServer() || TsIsNtWksta())
                {
                MDConfig.MDSetPropItem(&rgProp[0], IWMDP_LAST_OUTPROC_PID, szPackageID);
                }
            fChanged = TRUE;
            }
        // If this is DeleteRecoverable mode, we do not delete APP_ROOT, APP_ISOLATED,
        // OOP_RECOVERLIMIT and APP_STATE.
        if (!fRecover)
            {
            // Delete AppFriendlyName
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_FRIENDLY_NAME);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_ROOT);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_ISOLATED);
            MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_APPSTATE);
            if (fRemoveAppPool)
                {
                MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_OOP_APP_APPPOOL_ID);
                }

            if (dwAppMode == static_cast<DWORD>(eAppRunOutProcIsolated))
                {
                // This will only be set for older isolated applications.
                // Since we ignore the result of UpdateMD below, it is ok
                // for us to try to delete the property.
                MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_OOP_RECOVERLIMIT);
                }
            fChanged = TRUE;
            }

        // For DeleteRecover operation, and the app is not outproc isolated,
        // No property changes, therefore, no need to update metabase.
        if (fChanged)
            {
            MDConfig.UpdateMD(rgProp, METADATA_NO_ATTRIBUTES, szMetabasePath);
            }
        }
        
    return NOERROR;
}

/*===================================================================
RecoverApp

Recover an application based on MD_APP_ISOLATED property.

Parameter:
szMetabasePath:     [in]    MetabaseKey.

Return:     HRESULT
===================================================================*/
HRESULT WamRegGlobal::RecoverApp
(
IN LPCWSTR szMetabasePath,
IN BOOL fForceRecover
)
{
    HRESULT hr = NOERROR;
    DWORD    dwAppMode = 0;
    WamRegMetabaseConfig    MDConfig;

    hr = MDConfig.MDGetDWORD(szMetabasePath, MD_APP_ISOLATED, &dwAppMode);
    if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
        hr = NOERROR;
        }
    else
        {
        if (SUCCEEDED(hr))
            {
            if (fForceRecover)
                {
    			if (dwAppMode == static_cast<DWORD>(eAppRunOutProcInDefaultPool))
    				{
    				hr = CreatePooledApp(szMetabasePath, FALSE);				
    				}
    			else if (dwAppMode == static_cast<DWORD>(eAppRunInProc))
                    {
                    hr = CreatePooledApp(szMetabasePath, TRUE);				
                    }
    			else
    				{
    				hr = CreateOutProcApp(szMetabasePath);
    				}
                }
                
            if (SUCCEEDED(hr))
                {
                HRESULT hrT = NOERROR;
                hrT = MDConfig.MDRemoveProperty(szMetabasePath, MD_APP_STATE, DWORD_METADATA);
                if (FAILED(hrT))
                    {
                    if (hrT != MD_ERROR_DATA_NOT_FOUND)
                        {
                        DBGPRINTF((DBG_CONTEXT, "Failed to remove MD_APP_STATE from path %S, hr = %08x\n",
                            szMetabasePath,
                            hrT));
                        }
                    }
                }
            }
        }
        
    return hr;
}
/*============================================================================
W3ServiceUtil

sink function that unload/shutdown/querystatus of an application currently in the runtime
table.

Parameter:
szMDPath            the application Path.
dwCommand           The command.
pdwCallBackResult   Contains the HRESULT from w3svc.dll.

==============================================================================*/
HRESULT WamRegGlobal::W3ServiceUtil
(
IN LPCWSTR  szMDPath,
IN DWORD    dwCommand,
OUT DWORD*    pdwCallBackResult
)
{
    HRESULT hr = NOERROR;

    if (g_pfnW3ServiceSink)
        {

#ifndef _IIS_6_0

        // DBCS enabling for IIS 5.1
        INT cSize = wcslen(szMDPath)*2 + 1;

        CHAR *szPathT = new CHAR[cSize];

        if (szPathT)
            {
            WideCharToMultiByte(0, 0, szMDPath, -1, szPathT, cSize, NULL, NULL);
            hr = g_pfnW3ServiceSink(szPathT,
                                    dwCommand,
                                    pdwCallBackResult);
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        
        delete [] szPathT;

#else
        //
        // IIS 6's implementation uses UNICODE directly, so
        // we'll avoid the WideCharToMultiByte nonsense and
        // just cast the path to fit the function arguments.
        //
        // We're not changing the function prototype purely
        // because we are minimizing code churn in this module.
        //
        
        
        // IIS 6 gets the unicode directly
        hr = g_pfnW3ServiceSink(reinterpret_cast<LPCSTR>(szMDPath),
                                dwCommand,
                                pdwCallBackResult);
#endif // _IIS_6_0
        }
    else
        {
        *pdwCallBackResult = APPSTATUS_NOW3SVC;
        hr = NOERROR;
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__29822AB4_F302_11D0_9953_00C04FD919C1__INCLUDED_)
#define AFX_DLLDATAX_H__29822AB4_F302_11D0_9953_00C04FD919C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__29822AB4_F302_11D0_9953_00C04FD919C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\common.h ===
#ifndef _WAMREG_COMMON_H
#define _WAMREG_COMMON_H

#ifdef __cplusplus
	extern "C" {
#endif

	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>

#ifdef __cplusplus
	};
#endif	// __cplusplus

#include "wmrgexp.h"
//==========================================================================
// Global Macro defines.
//
//==========================================================================
#define RELEASE(p) {if ( p ) { p->Release(); p = NULL; }}
#define FREEBSTR(p) {if (p) {SysFreeString( p ); p = NULL;}}
//
// 39 is the size of CLSID
//
#define	uSizeCLSID	39

//==========================================================================
// Global data defines
//
//==========================================================================
extern	DWORD				g_dwRefCount;
extern 	PFNServiceNotify 	g_pfnW3ServiceSink;
extern  HINSTANCE           g_hModule;


//==========================================================================
// function declarations
//
//==========================================================================



#endif // _WAMREG_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\comobj.h ===
// comobj.h: Definition of the WmRgSrv class
//
//////////////////////////////////////////////////////////////////////
#ifndef _WAMREG_COMOBJ_H
#define _WAMREG_COMOBJ_H


//#if !defined(AFX_COMOBJ_H__29822ABB_F302_11D0_9953_00C04FD919C1__INCLUDED_)
//#define AFX_COMOBJ_H__29822ABB_F302_11D0_9953_00C04FD919C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "common.h"
#include "resource.h"       // main symbols
#include "iadmw.h"
#include "iiscnfg.h"
#include "iadmext.h"

/////////////////////////////////////////////////////////////////////////////
// WmRgSrv

class CWmRgSrv : 
	public IADMEXT
{
public:
	CWmRgSrv();
	~CWmRgSrv();

//DECLARE_NOT_AGGREGATABLE(WmRgSrv) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

// IWmRgSrv
public:
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(Initialize)();
	STDMETHOD(EnumDcomCLSIDs)(/* [size_is][out] */CLSID *pclsidDcom, /* [in] */ DWORD dwEnumIndex);
	STDMETHOD(Terminate)();	

private:
	// Since wamreg has only one com object.  No need to use static members.
	DWORD				m_cSignature;
	LONG				m_cRef;
};

class CWmRgSrvFactory: 
	public IClassFactory 
{
public:
	CWmRgSrvFactory();
	~CWmRgSrvFactory();

	STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(CreateInstance)(IUnknown * pUnknownOuter, REFIID riid, void ** ppv);
	STDMETHOD(LockServer)(BOOL bLock);

	CWmRgSrv	*m_pWmRgServiceObj;

private:
	ULONG		m_cRef;
};


	
// Global data defines.
extern CWmRgSrvFactory* g_pWmRgSrvFactory; 
extern DWORD			g_dwRefCount;

#endif // _WAMREG_COMOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

// Use the default constants from pudebug.h

# define DEBUG_WAMREG_MTS                 0x00010000
# define DEBUG_WAMREG_REGISTRY            0x00020000
# define DEBUG_WAMREG_METABASE            0x00040000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\export.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG    Wam Registration

File: export.cpp

Owner: LeiJin

Note:

WAMREG Export functions.
===================================================================*/

#define _WAMREG_DLL_
#include "common.h"
#include <stdio.h>

#include "objbase.h"
#include "dbgutil.h"
#include "wmrgexp.h"
#include "auxfunc.h"
#include "iiscnfg.h"
#include "export.h"

PFNServiceNotify g_pfnW3ServiceSink;

//
// Setup support
//
IIS5LOG_FUNCTION            g_pfnSetupWriteLog = NULL;

VOID
LogSetupTraceImpl
(
    LPCSTR      szPrefixFormat,
    LPCSTR      szFilePath,
    INT         nLineNum,
    INT         nTraceLevel,
    LPCSTR      szFormat,
    va_list     argptr
);

class CWamSetupManager
/*++

Class description:

    Collects those helper functions used exclusively by setup.
    Most of these methods were formerly in WamRegGlobal.

Public Interface:

--*/
{
public:

    CWamSetupManager()
        : m_hrCoInit( NOERROR )
    {
    }

    ~CWamSetupManager()
    {
    }

    HRESULT SetupInit( WamRegPackageConfig &refPackageConfig );

    VOID    SetupUnInit( WamRegPackageConfig &refPackageConfig )
    {
        refPackageConfig.Cleanup();
        WamRegMetabaseConfig::MetabaseUnInit();

        if( SUCCEEDED(m_hrCoInit) )
        {
            CoUninitialize();
        }
    }

    HRESULT UpgradeInProcApplications( VOID );

    HRESULT AppCleanupAll( VOID );

private:

    HRESULT DoGoryCoInitialize( VOID );

    HRESULT RemoveWAMCLSIDFromInProcApp( IN LPCWSTR pszMetabasePath );

private:

    HRESULT     m_hrCoInit;
};

#define MAX_SETUP_TRACE_OUTPUTSTR       1024

HRESULT PACKMGR_LIBAPI
InstallWam
(
    HMODULE hIIsSetupModule
)
/*++
Routine Description:

    Setup entry point. The handle to iis.dll is passed in to allow us
    to log to the setup log.

Parameters

    hIIsSetupModule             -

Return Value

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;

    // Get the logging entry point from iis.dll

#ifdef WAMREG_DEBUG_SETUP_LOG
    SetLogFile();
#else
    g_pfnSetupWriteLog = (IIS5LOG_FUNCTION) GetProcAddress( hIIsSetupModule, "IIS5Log");
#endif

    hr = CreateIISPackage();

#ifdef WAMREG_DEBUG_SETUP_LOG
    ClearLogFile();
#endif

    g_pfnSetupWriteLog = NULL;

    return hr;
}

HRESULT PACKMGR_LIBAPI
UnInstallWam
(
    HMODULE hIIsSetupModule
)
/*++
Routine Description:

    Setup entry point. The handle to iis.dll is passed in to allow us
    to log to the setup log.

Parameters

    hIIsSetupModule             -

Return Value

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;

    // Get the logging entry point from iis.dll

#ifdef WAMREG_DEBUG_SETUP_LOG
    SetLogFile();
#else
    g_pfnSetupWriteLog = (IIS5LOG_FUNCTION) GetProcAddress( hIIsSetupModule, "IIS5Log");
#endif

    hr = DeleteIISPackage();

#ifdef WAMREG_DEBUG_SETUP_LOG
    ClearLogFile();
#endif

    g_pfnSetupWriteLog = NULL;

    return hr;
}

VOID
LogSetupTrace
(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         /* pszFunction */,
   IN const char *         pszFormat,
   ...
)
/*++
Routine Description:

    Called by SETUP_TRACE* logging macros. Passes va_list to LogSetupTraceImpl.

Parameters

   IN LPDEBUG_PRINTS       pDebugPrints     - from DBG_CONTEXT unused
   IN const char *         pszFilePath      - from DBG_CONTEXT unused
   IN int                  nLineNum         - from DBG_CONTEXT unused
   IN const char *         pszFormat        - format string

--*/
{
    DBG_ASSERT( pszFormat );

    va_list argsList;

    va_start( argsList, pszFormat);

    LogSetupTraceImpl(
        "[WAMTRACE - %14s : %05d]\t",
        pszFilePath,
        nLineNum,
        LOG_TYPE_TRACE,
        pszFormat,
        argsList
        );

    va_end( argsList);
}

VOID
LogSetupTraceError
(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         /* pszFunction */,
   IN const char *         pszFormat,
   ...
)
/*++
Routine Description:

   Called by SETUP_TRACE* logging macros. Passes va_list to LogSetupTraceImpl.

Parameters

   IN LPDEBUG_PRINTS       pDebugPrints     - from DBG_CONTEXT unused
   IN const char *         pszFilePath      - from DBG_CONTEXT unused
   IN int                  nLineNum         - from DBG_CONTEXT unused
   IN const char *         pszFormat        - format string

--*/
{
    DBG_ASSERT( pszFormat );

    va_list argsList;

    va_start( argsList, pszFormat);

    LogSetupTraceImpl(
        "[WAMERROR - %14s : %05d]\t",
        pszFilePath,
        nLineNum,
        LOG_TYPE_ERROR,
        pszFormat,
        argsList
        );

    va_end( argsList);
}

VOID
LogSetupTraceImpl
(
    LPCSTR      szPrefixFormat,
    LPCSTR      szFilePath,
    INT         nLineNum,
    INT         nTraceLevel,
    LPCSTR      szFormat,
    va_list     argptr
)
/*++
Routine Description:

    All the logging macros resolve to this function. Formats the
    message to be logged and logs it using g_pfnSetupWriteLog.

Parameters

    LPCSTR      szPrefixFormat  -
    LPCSTR      szFilePath      -
    INT         nLineNum        -
    INT         nTraceLevel     - LOG_TYPE_ERROR, LOG_TYPE_TRACE
    LPCSTR      szFormat        - format string
    va_list     argptr          - arguments to format

--*/
{
    WCHAR   wszOutput[MAX_SETUP_TRACE_OUTPUTSTR + 1];
    CHAR    szOutput[MAX_SETUP_TRACE_OUTPUTSTR + 1];

    LPCSTR  szFileName = strrchr( szFilePath, '\\');
    szFileName++;

    int cchPrefix = wsprintf( szOutput, szPrefixFormat, szFileName, nLineNum );

    int cchOutputString = _vsnprintf( szOutput + cchPrefix,
                                      MAX_SETUP_TRACE_OUTPUTSTR - cchPrefix,
                                      szFormat,
                                      argptr
                                      );

    if( -1 == cchOutputString )
    {
        // Terminate properly if too much data
        szOutput[MAX_SETUP_TRACE_OUTPUTSTR] = '\0';
    }

    if( MultiByteToWideChar( CP_ACP,
                             0,
                             szOutput,
                             -1,
                             wszOutput,
                             MAX_SETUP_TRACE_OUTPUTSTR + 1 )
        )
    {
        if( g_pfnSetupWriteLog )
        {
            g_pfnSetupWriteLog( nTraceLevel, wszOutput );
        }
    }
}

HRESULT
PACKMGR_LIBAPI
CreateCOMPlusApplication(
    LPCWSTR      szMDPath,
    LPCWSTR      szOOPPackageID,
    LPCWSTR      szOOPWAMCLSID,
    BOOL       * pfAppCreated
    )
{
    HRESULT                 hr = S_OK;
    WamRegPackageConfig     PackageConfig;
    DWORD                   dwMDPathLen;

    *pfAppCreated = FALSE;

    //
    // Initilize COM+ catalog
    //

    hr = PackageConfig.CreateCatalog();
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( !PackageConfig.IsPackageInstalled( szOOPPackageID,
                                           szOOPWAMCLSID ) )
    {
        hr = g_WamRegGlobal.CreateOutProcApp( szMDPath, FALSE, FALSE );
        if (FAILED(hr))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to create new application on path %S, hr = 08x\n",
                        szMDPath,
                        hr ));
        }

        *pfAppCreated = TRUE;
    }

    return hr;
}

/*===================================================================
CreateIISPackage

Called at IIS Setup time.

This is a pseudo dll entry point. It shouldn't be called by setup directly.
Setup calls InstallWam(). This entry still exists so there is a function
that can be called by rundll32 that takes no parameters and provides
equivalent functionality to setup.

rundll32 wamreg.dll,CreateIISPackage

This routine's logic has changed to do two ways. One, it won't
cleanup when it fails. The cleanup logic made it much more difficult
to determine what worked and what didn't. Two, it doesn't skip steps
when a failure happens. Some multistep actions may be cut short if
there is a failure, but we won't bail and skip an unrelated action
anymore.

Returns:
    HRESULT    - NOERROR on success

Side effects:

===================================================================*/
HRESULT PACKMGR_LIBAPI CreateIISPackage(void)
{
    CWamSetupManager        setupMgr;
    WamRegPackageConfig     PackageConfig;
    WamRegMetabaseConfig    MDConfig;

    HRESULT     hrReturn = NOERROR;
    HRESULT     hrCurrent = NOERROR;

    SETUP_TRACE(( DBG_CONTEXT, "CALL - CreateIISPackage\n" ));

    hrReturn = setupMgr.SetupInit( PackageConfig );
    if( SUCCEEDED(hrReturn) )
    {
        //
        // Determine what packages are currently installed. This will
        // drive the logic of the rest of the install.
        //
        SETUP_TRACE((
            DBG_CONTEXT,
            "CreateIISPackage - Finding installed WAM packages.\n"
            ));

        BOOL fIPPackageInstalled =
            PackageConfig.IsPackageInstalled(
                WamRegGlobal::g_szIISInProcPackageID,
                WamRegGlobal::g_szInProcWAMCLSID
                );

        BOOL fPOOPPackageInstalled =
            PackageConfig.IsPackageInstalled(
                WamRegGlobal::g_szIISOOPPoolPackageID,
                WamRegGlobal::g_szOOPPoolWAMCLSID
                );

        SETUP_TRACE((
            DBG_CONTEXT,
            "CreateIISPackage - IP Package exists (%x) POOL Package exists (%x).\n",
            fIPPackageInstalled,
            fPOOPPackageInstalled
            ));

        SETUP_TRACE((
            DBG_CONTEXT,
            "CreateIISPackage - Registering WAM CLSIDs.\n"
            ));

        hrCurrent = g_RegistryConfig.RegisterCLSID(
                        WamRegGlobal::g_szOOPPoolWAMCLSID,
                        WamRegGlobal::g_szOOPPoolWAMProgID,
                        TRUE
                        );

        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR(( DBG_CONTEXT,
                                "FAIL - RegisterCLSID POOL(%S) - error=%08x\n",
                                WamRegGlobal::g_szOOPPoolWAMCLSID,
                                hrReturn
                                ));
        }

        if( fIPPackageInstalled )
        {
            //
            // Clean up the in process package all in process 
            // configuration is obsolete in IIS6
            //
            
            SETUP_TRACE((
                DBG_CONTEXT,
                "CreateIISPackage - Removing the WAM IP application.\n"
                ));

            hrCurrent = PackageConfig.RemovePackage(
                            WamRegGlobal::g_szIISInProcPackageID
                            );

            if( FAILED(hrCurrent) )
            {
                hrReturn = hrCurrent;
                SETUP_TRACE_ERROR((
                            DBG_CONTEXT,
                            "Failed to remove WAM IP Package(%S). Error %08x\n",
                            WamRegGlobal::g_szIISInProcPackageID,
                            hrReturn
                            ));
            }

            hrCurrent = g_RegistryConfig.UnRegisterCLSID(
                                WamRegGlobal::g_szInProcWAMCLSID,
                                TRUE
                                );

            if( FAILED(hrCurrent) )
            {
                hrReturn = hrCurrent;
                SETUP_TRACE_ERROR((
                            DBG_CONTEXT,
                            "Failed to remove registry entries (%S). Error %08x\n",
                            WamRegGlobal::g_szInProcWAMCLSID,
                            hrReturn
                            ));
            }

        } // create IP package

        if( !fPOOPPackageInstalled )
        {
            //
            // Create the POOP package.
            //
            SETUP_TRACE((
                DBG_CONTEXT,
                "CreateIISPackage - Creating the WAM POOL application.\n"
                ));

            // Get IWAM_* account information.
            WCHAR   szIdentity[MAX_PATH];
            WCHAR   szPwd[MAX_PATH];

            *szIdentity = *szPwd = 0;

            hrCurrent = MDConfig.MDGetIdentity( szIdentity,
                                                sizeof(szIdentity),
                                                szPwd,
                                                sizeof(szPwd)
                                                );
            if( FAILED(hrCurrent) )
            {
                hrReturn = hrCurrent;
                SETUP_TRACE_ERROR((
                    DBG_CONTEXT,
                    "FAIL - MDGetIdentity, Getting the IWAM_* account from the Metabase - error=%08x\n",
                    hrReturn
                    ));
            }
            else
            {
                // succeeded
                hrCurrent = PackageConfig.CreatePackage(
                                WamRegGlobal::g_szIISOOPPoolPackageID,
                                WamRegGlobal::g_szIISOOPPoolPackageName,
                                szIdentity,
                                szPwd );
                if( FAILED(hrCurrent) )
                {
                    hrReturn = hrCurrent;
                    SETUP_TRACE_ERROR((
                        DBG_CONTEXT,
                        "FAIL - CreatePackage POOL(%S) - error=%08x\n",
                        WamRegGlobal::g_szIISOOPPoolPackageID,
                        hrReturn
                        ));
                }
                else
                {
                    hrCurrent = PackageConfig.AddComponentToPackage(
                                    WamRegGlobal::g_szIISOOPPoolPackageID,
                                    WamRegGlobal::g_szOOPPoolWAMCLSID
                                    );
                    if( FAILED(hrCurrent) )
                    {
                        hrReturn = hrCurrent;
                        SETUP_TRACE_ERROR((
                            DBG_CONTEXT,
                            "FAIL - AddComponentToPackage POOL(%S) - error=%08x\n",
                            WamRegGlobal::g_szOOPPoolWAMCLSID,
                            hrReturn
                            ));
                    }
                }
            }
        } // create POOL package

        //
        // Remove the default application /LM/W3SVC Obsolete in IIS6
        //

        SETUP_TRACE((
            DBG_CONTEXT,
            "Cleanup obsolete metabase data.\n"
            ));

        hrCurrent = MDConfig.MDUpdateIISDefault();
        if( FAILED(hrCurrent) )
        {
            SETUP_TRACE((
                DBG_CONTEXT,
                "Unable to remove service defaults - error=%08x\n",
                hrCurrent
                ));
        }

        //
        // This really only needs to happen on IIS4 upgrade. But it 
        // shouldn't actually make any changes unless this is an upgrade.
        //
        // Update inproc applications by removing WAMCLSID from inproc 
        // applications.  This step does not change inproc application to a
        // oop pool application.
        //

        hrCurrent = setupMgr.UpgradeInProcApplications();
        if( FAILED(hrCurrent) )
        {
            SETUP_TRACE((
                DBG_CONTEXT,
                "UpgradeInProcApplications - error=%08x\n",
                hrCurrent
                ));
        }

    } // init succeeded

    setupMgr.SetupUnInit( PackageConfig );

    SETUP_TRACE(( DBG_CONTEXT, "RETURN - CreateIISPackage, hr=%08x\n", hrReturn ));

    return hrReturn;
}

/*===================================================================
DeleteIISPackage

Delete IIS Package from ViperSpace, and unregister the default IIS
CLSID.


Returns:
    HRESULT    - NOERROR on success

Side effects:
    remove IIS default package from Viperspace.

Note:
  No need to delete the metabase entries.
  This function is called when IIS is uninstalled.
   In this case anyway Metabase will go away - so we don't clean it explicitly

===================================================================*/
HRESULT PACKMGR_LIBAPI DeleteIISPackage(void)
{
    HRESULT                 hrReturn = NOERROR;
    HRESULT                 hrCurrent = NOERROR;
    CWamSetupManager        setupMgr;
    WamRegPackageConfig     PackageConfig;

    SETUP_TRACE(( DBG_CONTEXT, "CALL - DeleteIISPackage\n" ));

    hrReturn = setupMgr.SetupInit( PackageConfig );
    if( SUCCEEDED(hrReturn) )
    {
        // Blow away all the applications.

        SETUP_TRACE((
            DBG_CONTEXT,
            "DeleteIISPackage - Removing WAM Applications\n"
            ));

        hrCurrent = setupMgr.AppCleanupAll();
        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR((
                    DBG_CONTEXT,
                    "Failed to remove WAM Applications. Error %08x\n",
                    hrReturn
                    ));
        }

        // Remove the global packages

        SETUP_TRACE((
            DBG_CONTEXT,
            "DeleteIISPackage - Removing WAM packages\n"
            ));

        //
        // Attempt to remove the in process stuff anyway (it shouldn't be there).
        //

        hrCurrent = PackageConfig.RemovePackage(
                        WamRegGlobal::g_szIISInProcPackageID
                        );
        if( FAILED(hrCurrent) )
        {
            SETUP_TRACE((
                        DBG_CONTEXT,
                        "Unable to remove IP package (%S). Error %08x.\n",
                        WamRegGlobal::g_szIISInProcPackageID,
                        hrReturn
                        ));
        }

        hrCurrent = PackageConfig.RemovePackage(
                        WamRegGlobal::g_szIISOOPPoolPackageID
                        );
        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR((
                        DBG_CONTEXT,
                        "Failed to remove POOL package (%S). Error %08x\n",
                        WamRegGlobal::g_szIISOOPPoolPackageID,
                        hrReturn
                        ));
        }

        // Unregister the global WAM CLSIDs

        SETUP_TRACE((
            DBG_CONTEXT,
            "DeleteIISPackage - Removing WAM CLSIDs from the registry\n"
            ));

        hrCurrent = g_RegistryConfig.UnRegisterCLSID(
                            WamRegGlobal::g_szInProcWAMCLSID,
                            TRUE
                            );
        if( FAILED(hrCurrent) )
        {
            SETUP_TRACE((
                        DBG_CONTEXT,
                        "Unable to remove IP registry entries (%S). Error %08x\n",
                        WamRegGlobal::g_szInProcWAMCLSID,
                        hrReturn
                        ));
        }

        hrCurrent = g_RegistryConfig.UnRegisterCLSID(
                        WamRegGlobal::g_szOOPPoolWAMCLSID,
                        FALSE       // Already deleted VI Prog ID
                        );
        if( FAILED(hrCurrent) )
        {
            hrReturn = hrCurrent;
            SETUP_TRACE_ERROR((
                        DBG_CONTEXT,
                        "Failed to remove registry entries (%S). Error %08x\n",
                        WamRegGlobal::g_szOOPPoolWAMCLSID,
                        hrReturn
                        ));
        }
    }

    setupMgr.SetupUnInit( PackageConfig );

    SETUP_TRACE(( DBG_CONTEXT, "RETURN - DeleteIISPackage, hr=%08x\n", hrReturn ));
    return hrReturn;
}

/*===================================================================
WamReg_RegisterSinkNotify

Register a function pointer(a back pointer) to Runtime WAM_Dictator.  So that
any changes in WAMREG will ssync with RunTime WAM_Dictator state.

Returns:
    HRESULT    - NOERROR on success

Side effects:
    register a function pointer.
===================================================================*/
HRESULT PACKMGR_LIBAPI WamReg_RegisterSinkNotify
(
PFNServiceNotify pfnW3ServiceSink
)
{
    g_pfnW3ServiceSink = pfnW3ServiceSink;
    return NOERROR;
}

/*===================================================================
WamReg_RegisterSinkNotify

Register a function pointer(a back pointer) to Runtime WAM_Dictator.  So that
any changes in WAMREG will ssync with RunTime WAM_Dictator state.

Returns:
    HRESULT    - NOERROR on success

Side effects:
    register a function pointer.
===================================================================*/
HRESULT PACKMGR_LIBAPI WamReg_UnRegisterSinkNotify
(
void
)
{
    g_pfnW3ServiceSink = NULL;
    return NOERROR;
}


HRESULT CWamSetupManager::SetupInit( WamRegPackageConfig &refPackageConfig )
{
    HRESULT hrReturn = NOERROR;
    HRESULT hrCurrent = NOERROR;
    DWORD   dwCreateTime = 0;

    SETUP_TRACE(( DBG_CONTEXT, "CALL - SetupInit\n" ));

    hrCurrent = g_RegistryConfig.LoadWamDllPath();
    if( FAILED(hrCurrent) )
    {
        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT,
                            "FAIL - LoadWamDllPath - error=%08x",
                            hrReturn
                            ));
    }

    hrCurrent = DoGoryCoInitialize();
    if( FAILED(hrCurrent) )
    {
        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT,
                            "FAIL - DoGoryCoInitialize - error=%08x",
                            hrReturn
                            ));
    }

    do {
      hrCurrent = refPackageConfig.CreateCatalog();

      if ( hrCurrent == RETURNCODETOHRESULT( ERROR_SERVICE_DATABASE_LOCKED ) )
      {
        Sleep( CREATECATALOG_TRY_INTERVAL );
      }

      dwCreateTime += CREATECATALOG_TRY_INTERVAL;

    } while ( ( hrCurrent == RETURNCODETOHRESULT( ERROR_SERVICE_DATABASE_LOCKED ) ) &&
              ( dwCreateTime < CREATECATALOG_MAX_WAIT ) );

    if( FAILED(hrCurrent) )
    {
        // BUG 512023, trying to catch this error during setup to find out what is causing it
        DBG_ASSERT( hrCurrent != RETURNCODETOHRESULT( ERROR_SERVICE_DATABASE_LOCKED ) );

        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT,
                            "FAIL - CreateCatalog - error=%08x",
                            hrReturn
                            ));
    }

    hrCurrent = WamRegMetabaseConfig::MetabaseInit();
    if( FAILED(hrCurrent) )
    {
        hrReturn = hrCurrent;
        SETUP_TRACE_ERROR(( DBG_CONTEXT,
                            "FAIL - MetabaseInit - error=%08x",
                            hrReturn
                            ));
    }

    SETUP_TRACE((
        DBG_CONTEXT,
        "RETURN - SetupInit. Error(%08x)\n",
        hrReturn
        ));

    return hrReturn;
}


/*===================================================================
UpgradeInProcApplications

From iis v4 to v5, UpgradeInProcApplications removes WAMCLSID from all
inproc applications defined in IIS Version 4.  So, after the upgrade,
There is only one inproc WAMCLSID inside inproc package.

Parameter:
VOID

Return:     HRESULT
===================================================================*/
HRESULT CWamSetupManager::UpgradeInProcApplications( VOID )
{
    HRESULT hr = NOERROR;
    DWORD   dwBufferSizeTemp= 0;
    WCHAR*  pbBufferTemp = NULL;
    WamRegMetabaseConfig    MDConfig;

    SETUP_TRACE((DBG_CONTEXT, "CALL - UpgradeInProcApplications\n"));

    DWORD dwSizePrefix = g_WamRegGlobal.g_cchMDW3SVCRoot;

    hr = MDConfig.MDGetPropPaths( g_WamRegGlobal.g_szMDW3SVCRoot,
                                  MD_APP_ISOLATED,
                                  &pbBufferTemp,
                                  &dwBufferSizeTemp
                                  );

    SETUP_TRACE_ASSERT(pbBufferTemp != NULL);

    if (SUCCEEDED(hr) && pbBufferTemp)
        {
        WCHAR*    pszString = NULL;
        WCHAR*  pszMetabasePath = NULL;

        for (pszString = (LPWSTR)pbBufferTemp;
                *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
                pszString += (wcslen(pszString) + 1))
            {
            //
            // MDGetPropPaths returns patial paths relative to /LM/W3SVC/, therefore,
            // prepend the prefix string to the path
            //
            hr = g_WamRegGlobal.ConstructFullPath(
                        g_WamRegGlobal.g_szMDW3SVCRoot,
                        g_WamRegGlobal.g_cchMDW3SVCRoot,
                        pszString,
                        &pszMetabasePath
                        );

            if (SUCCEEDED(hr))
                {
                //
                // The default application under /LM/W3SVC is created differently with
                // normal application.  Therefore, it requires other code to remove the
                // the application.
                //
                if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {
                    hr = RemoveWAMCLSIDFromInProcApp(pszMetabasePath);

                    if (FAILED(hr))
                        {
                        SETUP_TRACE_ERROR((
                            DBG_CONTEXT,
                            "Failed to upgrade application %S, hr = %08x\n",
                            pszString,
                            hr
                            ));

                        delete [] pszMetabasePath;
                        pszMetabasePath = NULL;
                        break;
                        }
                    }

                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
                }
             else
                 {
                 SETUP_TRACE_ERROR((
                    DBG_CONTEXT,
                    "ConstructFullPath failed, partial path (%S), hr = %08x\n",
                    pszString,
                    hr
                    ));
                }
            }
        }
    else
        {
        DBGPRINTF((
            DBG_CONTEXT,
            "MDGetPropPaths failed hr = %08x\n",
            hr
            ));
        }

    if (pbBufferTemp != NULL)
        {
        delete [] pbBufferTemp;
        pbBufferTemp = NULL;
        }

    SETUP_TRACE((
        DBG_CONTEXT,
        "RETURN - UpgradeInProcApplications. hr = %08x\n",
        hr
        ));

    return hr;

    }


/*===================================================================
RemoveWAMCLSIDFromInProcApp

Remove a WAMCLSID from a inproc application.(called only during update from
iis v4 to v5).  Remove the WAM component from IIS inproc package, unregister
the WAMCLSID and remove the WAMCLSID entry from the metabase.

Parameter:
Metabase path

Return:     HRESULT
===================================================================*/
HRESULT CWamSetupManager::RemoveWAMCLSIDFromInProcApp
(
IN LPCWSTR      szMetabasePath
)
    {
    WCHAR   szWAMCLSID[uSizeCLSID];
    WCHAR   szPackageID[uSizeCLSID];
    DWORD   dwAppMode = 0;
    HRESULT hr, hrRegistry;
    WamRegMetabaseConfig    MDConfig;

    hr = MDConfig.MDGetDWORD(szMetabasePath, MD_APP_ISOLATED, &dwAppMode);

    // return immediately, no application is defined, nothing to delete.
    if (hr == MD_ERROR_DATA_NOT_FOUND  || dwAppMode != 0)
        {
        return NOERROR;
        }

    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT,
            "Unexpected failure getting AppIsolated %0x\n",
            hr
            ));
        return hr;
        }

    // Get WAM_CLSID, and PackageID.
    hr = MDConfig.MDGetIDs(szMetabasePath, szWAMCLSID, szPackageID, dwAppMode);
    if( hr == MD_ERROR_DATA_NOT_FOUND )
        {
        SETUP_TRACE((
            DBG_CONTEXT,
            "Application (%S) is not an IIS4 IP application.\n",
            szMetabasePath
            ));
        return NOERROR;
        }

    // Unregister WAM
    hr = g_RegistryConfig.UnRegisterCLSID(szWAMCLSID, FALSE);
    if (FAILED(hr))
        {
        SETUP_TRACE((
            DBG_CONTEXT,
            "Failed to UnRegister WAMCLSID(%S), hr = %08x\n",
            szWAMCLSID,
            hr
            ));
        }

    // Delete WAMCLSID
    MDPropItem     rgProp[IWMDP_MAX];
    MDConfig.InitPropItemData(&rgProp[0]);
    MDConfig.MDDeletePropItem(&rgProp[0], IWMDP_WAMCLSID);
    MDConfig.UpdateMD(rgProp, METADATA_NO_ATTRIBUTES, szMetabasePath, TRUE);

    return NOERROR;
    }

/*===================================================================
AppCleanupAll

Parameter:
VOID

Return:     HRESULT(DON'T CARE)
===================================================================*/
HRESULT CWamSetupManager::AppCleanupAll(VOID)
{
    HRESULT hr = NOERROR;
    DWORD   dwBufferSizeTemp= 0;
    WCHAR*  pbBufferTemp = NULL;
    WamRegMetabaseConfig    MDConfig;

    SETUP_TRACE((DBG_CONTEXT, "CALL - AppCleanupAll\n"));

    DWORD dwSizePrefix = g_WamRegGlobal.g_cchMDW3SVCRoot;

    hr = MDConfig.MDGetPropPaths( g_WamRegGlobal.g_szMDW3SVCRoot,
                                  MD_APP_ISOLATED,
                                  &pbBufferTemp,
                                  &dwBufferSizeTemp
                                  );

    if (SUCCEEDED(hr))
        {
        WCHAR*    pszString = NULL;
        WCHAR*  pszMetabasePath = NULL;

        DBG_ASSERT(pbBufferTemp != NULL);

        //
        // PREfix has a problem with the below code.  Specifically,
        // it has a problem with the fact that pbBufferTemp might be
        // NULL.  There is no supporting information in the PREfix
        // report that confirms that there's a possible code path
        // where MDGetPropPaths might succeed and yet yield a NULL
        // pbBufferTemp.  Further, we're asserting pbBufferTemp
        // immediately above, which is a sign that we don't expect
        // that pbBufferTemp can ever be NULL in this scenario.
        //

        /* INTRINSA suppress=null_pointers */

        for (pszString = (LPWSTR)pbBufferTemp;
                *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
                pszString += (wcslen(pszString) + 1))
            {
            //
            // MDGetPropPaths returns patial paths relative to /LM/W3SVC/, therefore,
            // prepend the prefix string to the path
            //
            hr = g_WamRegGlobal.ConstructFullPath(
                        g_WamRegGlobal.g_szMDW3SVCRoot,
                        g_WamRegGlobal.g_cchMDW3SVCRoot,
                        pszString,
                        &pszMetabasePath
                        );
            if (SUCCEEDED(hr))
                {
                //
                // The default application under /LM/W3SVC is created differently with
                // normal application.  Therefore, it requires other code to remove the
                // the application.
                //
                if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {
                    hr = g_WamRegGlobal.DeleteApp(pszMetabasePath, FALSE, FALSE);

                    SETUP_TRACE((
                        DBG_CONTEXT,
                        "AppCleanupAll, found application (%S).\n",
                        pszMetabasePath
                        ));

                    if (FAILED(hr))
                        {
                        SETUP_TRACE_ERROR((
                            DBG_CONTEXT,
                            "AppCleanupAll, failed to delete application (%S), hr = %08x\n",
                            pszString,
                            hr
                            ));
                        delete [] pszMetabasePath;
                        pszMetabasePath = NULL;
                        break;
                        }
                    }

                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
                }
             else
                 {
                 SETUP_TRACE_ERROR((
                    DBG_CONTEXT,
                    "AppCleanupAll, failed to construct full path, partial path (%S), hr = %08x\n",
                    pszString,
                    hr
                    ));
                }
            }
        }
    else
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT,
            "AppCleanupAll: GetPropPaths failed hr = %08x\n",
            hr
            ));
        }


    delete [] pbBufferTemp;
    pbBufferTemp = NULL;

    return hr;
}

/*===================================================================
DoGoryCoInitialize

  Description:
     CoInitialize() of COM is extremely funny function. It can fail
     and respond with S_FALSE which is to be ignored by the callers!
     On other error conditions it is possible that there is a threading
     mismatch. Rather than replicate the code in multiple places, here
     we try to consolidate the functionality in some rational manner.


  Arguments:
     None

  Returns:
     HRESULT = NOERROR on (S_OK & S_FALSE)
      other errors if any failure

Side effects:
    Create a Default IIS Package.  This package will exist until
    IIS is de-installed.
===================================================================*/
HRESULT
CWamSetupManager::DoGoryCoInitialize( VOID )
{
    // do the call to CoInitialize()
    m_hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    //
    // S_FALSE and S_OK are success.  Everything else is a failure and you don't need to call CoUninitialize.
    //
    if ( S_FALSE == m_hrCoInit )
    {
        //
        // It is okay to have failure (S_FALSE) in CoInitialize()
        // This error is to be ignored and balanced with CoUninitialize()
        //  We will reset the hr so that subsequent use is rational
        //
        SETUP_TRACE((
            DBG_CONTEXT,
            "DoGoryCoInitialize found duplicate CoInitialize.\n"
            ));
        m_hrCoInit = NOERROR;

    }
    else if( FAILED(m_hrCoInit) )
    {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT,
            "DoGoryCoInitialize() error %08x",
            m_hrCoInit
            ));
    }

    return m_hrCoInit;
} // DoGoryCoInitialize()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__29822AAC_F302_11D0_9953_00C04FD919C1__INCLUDED_)
#define AFX_STDAFX_H__29822AAC_F302_11D0_9953_00C04FD919C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__29822AAC_F302_11D0_9953_00C04FD919C1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\sources.inc ===
#   sources
#   Author: Lei Jin(leijin)
#   Date:   07/03/1997
#
#   This file is used for compiling Proxy web server from code
#    for generic web server
#
#   Describes the macros used for building using NT 'build' command
#

MAJORCOMP=wamreg
MINORCOMP=wamreg

TARGETPATH=obj
TARGETTYPE=DYNLINK

MSC_WARNING_LEVEL=/W4 /WX

DLLDEF=..\wamreg.def


DLLENTRY=_DllMainCRTStartup
BUFFER_OVERFLOW_CHECKS=1 

USE_MSVCRT=1

RAW_TARGETLIBS=\
            $(SDK_LIB_PATH)\user32.lib    \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SDK_LIB_PATH)\ole32.lib     \
            $(SDK_LIB_PATH)\oleaut32.lib     \
            $(SDK_LIB_PATH)\uuid.lib     \
            $(SDK_LIB_PATH)\kernel32.lib   \

TARGETLIBS=$(RAW_TARGETLIBS)

INCLUDES=..\.\;$(IISBASEDIR)\inc;$(IISBASEDIR)\inc\$(O);

SOURCES= ..\wmrgsv.idl \
         ..\wamreg.cpp \
         ..\wamadm.cpp \
         ..\comobj.cpp \
         ..\auxfunc.cpp \
         ..\export.cpp \
         ..\mdconfig.cpp \
         ..\mtsconfig.cpp \
         ..\wamreg.rc \

!IFDEF CAP_PROFILE
TARGETLIBS= $(TARGETLIBS)  $(CAP_LIBS)
!ENDIF

#
# ICAPHOOK.OBJ (ICECAP v3.6) allows user to set specific functions to profile
# without recompile the binary.
# NOTE: icaphook.obj is not available for ALPHA platform.
#
!IFDEF ICAP_PROFILE
TARGETLIBS= ..\..\..\..\libsupp\*\icaphook.obj $(TARGETLIBS) $(ICAP_LIBS)
!ENDIF

INCLUDES=.\;$(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wamreg.rc
//
#define IDS_PROJNAME                    100
#define IDR_WamAdmin                      101
#define IDR_WAMREP                      102
#define IDS_WMRGSRV_DESC                103
#define IDR_WmRgSrv                     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\mdconfig.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: mdconfig.cpp

	interface to update/query WAM related properties in metabase.

Owner: LeiJin

Note:

===================================================================*/
#include "common.h"
#include "auxfunc.h"
#include "iiscnfgp.h"
#include "dbgutil.h"
#include "multisz.hxx"

// Time out for metabase  = 5 seconds
const DWORD		WamRegMetabaseConfig::m_dwMDDefaultTimeOut = 30*1000;

IMSAdminBaseW*  WamRegMetabaseConfig::m_pMetabase = NULL;
//
// Please refer to MDPropItem for definition
// Application properties that might be updated by WAMREG
//
const MDPropItem	WamRegMetabaseConfig::m_rgMDPropTemplate[IWMDP_MAX] =
{
	{MD_APP_ROOT, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_ISOLATED, DWORD_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_WAM_CLSID, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_PACKAGE_ID, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_PACKAGE_NAME, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_LAST_OUTPROC_PID, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_FRIENDLY_NAME, STRING_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_STATE, DWORD_METADATA, 0, EMD_NONE, E_FAIL},
	{MD_APP_OOP_RECOVER_LIMIT, DWORD_METADATA, 0, EMD_NONE, E_FAIL},
        {MD_APP_APPPOOL_ID, STRING_METADATA, 0, EMD_NONE, E_FAIL}
};

/*===================================================================
InitPropItemData

Init a metabase item list, prepare for metabase update.

Parameter:
pMDPropItem:	pointer to MDPropItem which is set to the default values.

Return:		NONE
===================================================================*/
VOID WamRegMetabaseConfig::InitPropItemData(IN OUT MDPropItem* pMDPropItem)
{
    DBG_ASSERT(pMDPropItem != NULL);
	memcpy(pMDPropItem, (void *)m_rgMDPropTemplate, sizeof(m_rgMDPropTemplate));
	return;
}

/*===================================================================
MetabaseInit

Initialize Metabase, and obtain Metabase DCOM interface.

Parameter:
pMetabase:	[out] 	Metabase DCOM interface pointer.

Return:			HRESULT

Side affect:	Create a Metabase object, and get interface pointer.
===================================================================*/
HRESULT WamRegMetabaseConfig::MetabaseInit
(
)
{
	HRESULT hr = NOERROR;

	m_pMetabase = (IMSAdminBase *)NULL;

	hr = CoCreateInstance(CLSID_MSAdminBase
						, NULL
						, CLSCTX_SERVER
						, IID_IMSAdminBase
						, (void**)&(m_pMetabase));

	if (FAILED(hr))
		goto LErrExit;

	return hr;

LErrExit:

	RELEASE((m_pMetabase));
	return hr;
}

/*===================================================================
MetabaseUnInit

release a metabase interface.

Parameter:
pMetabase:	[in/out] 	Metabase DCOM interface pointer.

Return:			HRESULT

Side affect:	Destroy a metabase object.
===================================================================*/
HRESULT WamRegMetabaseConfig::MetabaseUnInit
(
VOID
)
{
	RELEASE((m_pMetabase));
	return NOERROR;
}

/*===================================================================
UpdateMD	

Update a WAM application property in metabase.

Parameter:
pMetabase   a metabase pointer

prgProp     contains the info of updating a WAM properties in metabase.
            refer to the structure definition for more info.

dwMDAttributes  allows caller specified INHERITABLE attribute.

fSaveData       perform a IMSAdminBase::SaveData, defaults to false

Return:			HRESULT

Side affect:	Release pMetabase.
			
===================================================================*/
HRESULT WamRegMetabaseConfig::UpdateMD
(
 IN MDPropItem* 	prgProp,
 IN DWORD	    dwMDAttributes,
 IN LPCWSTR      wszMetabasePath,
 IN BOOL         fSaveData
 )
{
    HRESULT hr = NOERROR;
    INT		iItem  = 0;
    METADATA_HANDLE hMetabase = NULL;
    
    DBG_ASSERT(m_pMetabase);
    DBG_ASSERT(prgProp);
    DBG_ASSERT(wszMetabasePath);
    
    //
    // Open Key
    //
    hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, wszMetabasePath,
        METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase);
    
    if (SUCCEEDED(hr))
    {
        METADATA_RECORD 	recMetaData;
        //
        // Update WAM Application Metabase Properties.
        //
        for (iItem = 0; iItem < IWMDP_MAX; iItem ++)
        {
            if (prgProp[iItem].dwAction == EMD_SET)
            {
                DWORD dwUserType = IIS_MD_UT_WAM;
                
                if (iItem == IWMDP_ROOT)
                {
                    dwUserType = IIS_MD_UT_FILE;
                }
                
                if (prgProp[iItem].dwType == STRING_METADATA)
                {
                    DBG_ASSERT(prgProp[iItem].pwstrVal);
                    MD_SET_DATA_RECORD(&recMetaData, 
                        prgProp[iItem].dwMDIdentifier, 
                        dwMDAttributes, 
                        dwUserType,
                        STRING_METADATA,  
                        (wcslen(prgProp[iItem].pwstrVal)+1)*sizeof(WCHAR), 
                        (unsigned char *)prgProp[iItem].pwstrVal);
                }
                else if (prgProp[iItem].dwType == DWORD_METADATA)
                {
                    MD_SET_DATA_RECORD(&recMetaData, 
                        prgProp[iItem].dwMDIdentifier, 
                        dwMDAttributes, 
                        dwUserType,
                        DWORD_METADATA,  
                        sizeof(DWORD), 
                        (unsigned char *)&(prgProp[iItem].dwVal));
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Unsupported data type by WAMREG.\n"));
                    DBG_ASSERT(FALSE);
                }
                
                hr = m_pMetabase->SetData(hMetabase, NULL, &recMetaData);
                prgProp[iItem].hrStatus = hr;
                if (FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "Metabase SetData failed. Path = %S, id = %08x, error = %08x\n",
                        wszMetabasePath,
                        prgProp[iItem].dwMDIdentifier,
                        hr));
                    break;
                }
            }
            
            if (prgProp[iItem].dwAction == EMD_DELETE)
            {
                hr = m_pMetabase->DeleteData(hMetabase, NULL, prgProp[iItem].dwMDIdentifier, 
                    prgProp[iItem].dwType);
            }
        }
        
        m_pMetabase->CloseKey(hMetabase);
        if (SUCCEEDED(hr) && fSaveData == TRUE)
        {
            hr = m_pMetabase->SaveData();
            if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
            {
                hr = NOERROR;
            }
            if (FAILED(hr))
            {
                DBG_ASSERT((DBG_CONTEXT, "Failed to call metabase->SaveData, Application path = %S,"
                    "hr = %08x\n",
                    wszMetabasePath,
                    hr));
                DBG_ASSERT(SUCCEEDED(hr));
            }
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to open metabase path %S, error = %08x\n",
            wszMetabasePath,
            hr));
    }
    
    return hr;
}

/*===================================================================
MDUpdateIISDefault	

Formerly write the default IIS package info to metabase under key "/LM/W3SVC".
In IIS6 this metadata is obsolete, so remove it all.

Including

IISPackageName
IISPackageID
WAMCLSID

Parameter:

Return: HRESULT

===================================================================*/
HRESULT WamRegMetabaseConfig::MDUpdateIISDefault()
{
    HRESULT hr = NOERROR;

    MDPropItem rgProp[IWMDP_MAX];
    
    DBG_ASSERT(m_pMetabase != NULL);
    
    InitPropItemData(&rgProp[0]);
    
    // Update Package Name
    MDDeletePropItem(&rgProp[0], IWMDP_PACKAGE_NAME);
    // Update Package ID
    MDDeletePropItem(&rgProp[0], IWMDP_PACKAGEID);
    
    // Update DefaultWAMCLSID
    MDDeletePropItem(&rgProp[0], IWMDP_WAMCLSID);
    
    // Update APPRoot
    MDDeletePropItem(&rgProp[0], IWMDP_ROOT);
    
    //Update AppIsolated
    MDDeletePropItem(&rgProp[0], IWMDP_ISOLATED);
    
    MDDeletePropItem(&rgProp[0], IWMDP_LAST_OUTPROC_PID);
    
    MDDeletePropItem(&rgProp[0], IWMDP_FRIENDLY_NAME);

    hr = UpdateMD(rgProp, METADATA_NO_ATTRIBUTES, WamRegGlobal::g_szMDAppPathPrefix, TRUE);

    return hr;
}

HRESULT WamRegMetabaseConfig::MDSetStringProperty
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath,
IN DWORD dwMetabaseProperty,
IN LPCWSTR szMetabaseValue,
IN DWORD dwMDUserType, /* = IIS_MD_UT_WAM */
IN DWORD dwMDAttributes /* = METADATA_NO_ATTRIBUTES */
)
/*===================================================================
MDSetProperty

Set a value of a property at the given path.

Parameters:

pMetabaseIn :           [in]    optional metabase interface
szMetabasePath	:	[in]    metabase key
dwMetabaseProperty  :   [in]    Property to set
szMetabaseValue :       [in]    Value to set on property
dwMDUserType :          [in, optional] UserType to set on property

Return:		BOOL

===================================================================*/
{
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;
    METADATA_RECORD     mdrData;
    ZeroMemory(&mdrData, sizeof(mdrData));

    DBG_ASSERT(szMetabasePath);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_WRITE,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 
    if (FAILED(hr))
    {
        goto done;
    }

    MD_SET_DATA_RECORD(&mdrData,
                       dwMetabaseProperty,
                       dwMDAttributes,
                       dwMDUserType,
                       STRING_METADATA,
                       (wcslen(szMetabaseValue)+1)*sizeof(WCHAR),
                       szMetabaseValue);

    hr = pMetabase->SetData(hMetabase,
                            L"/",
                            &mdrData);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = S_OK;
done:
    if (pMetabase && hMetabase)
    {
        pMetabase->CloseKey(hMetabase);
    }
    return hr;
}

HRESULT WamRegMetabaseConfig::MDSetKeyType
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath,
IN LPCWSTR szKeyType
)
{
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;
    METADATA_RECORD     mdrData;
    ZeroMemory(&mdrData, sizeof(mdrData));

    DBG_ASSERT(szMetabasePath);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_WRITE,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 
    if (FAILED(hr))
    {
        goto done;
    }

    MD_SET_DATA_RECORD(&mdrData,
                       MD_KEY_TYPE,
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       STRING_METADATA,
                       (wcslen(szKeyType)+1)*sizeof(WCHAR),
                       szKeyType);

    hr = pMetabase->SetData(hMetabase,
                            L"/",
                            &mdrData);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = S_OK;
done:
    if (pMetabase && hMetabase)
    {
        pMetabase->CloseKey(hMetabase);
    }
    return hr;
}

HRESULT WamRegMetabaseConfig::MDDeleteKey
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath,
IN LPCWSTR szKey
)
{
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;

    DBG_ASSERT(szMetabasePath);
    DBG_ASSERT(szKey);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_WRITE,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMetabase->DeleteKey(hMetabase,
                              szKey);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = S_OK;
done:
    if (pMetabase && hMetabase)
    {
        pMetabase->CloseKey(hMetabase);
    }
    return hr;
}

BOOL    WamRegMetabaseConfig::MDDoesPathExist
(
IN IMSAdminBase * pMetabaseIn,
IN LPCWSTR szMetabasePath
)

/*===================================================================
MDDoesPathExist

Determine if a given path exists in the metabase

Parameters:

pMetabaseIn :           [in]    optional metabase interface
szMetabasePath	:	[in]	metabase key

Return:		BOOL

===================================================================*/
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    IMSAdminBase*       pMetabase = NULL;
    METADATA_HANDLE     hMetabase = NULL;

    DBG_ASSERT(szMetabasePath);

    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }

    DBG_ASSERT(pMetabase);

    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            szMetabasePath,
                            METADATA_PERMISSION_READ,
                            m_dwMDDefaultTimeOut, 
                            &hMetabase); 

    if (SUCCEEDED(hr))
    {
        fRet = TRUE;
        pMetabase->CloseKey(hMetabase);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

/*===================================================================
MDCreatePath

Create a metabase path.(szMetabasePath)

Parameter:

szMetabasePath	:	[in]	metabase key

Return:		HRESULT

Note: fill in the pdwAppMode, memory buffer provided by the caller.
===================================================================*/
HRESULT WamRegMetabaseConfig::MDCreatePath
(
IN IMSAdminBase *pMetabaseIn,
IN LPCWSTR szMetabasePath
)
{
    HRESULT             hr;
    IMSAdminBase        *pMetabase = NULL;
    WCHAR               *pwszApplicationPath = NULL;
    METADATA_HANDLE     hMetabase = NULL;
    
    DBG_ASSERT(szMetabasePath);
    
    if (pMetabaseIn)
    {
        pMetabase = pMetabaseIn;
    }
    else
    {
        pMetabase = m_pMetabase;
    }
    
    if (_wcsnicmp(szMetabasePath, L"\\LM\\W3SVC\\", 10) == 0 ||
        _wcsnicmp(szMetabasePath, WamRegGlobal::g_szMDAppPathPrefix, WamRegGlobal::g_cchMDAppPathPrefix) == 0)
    {
        pwszApplicationPath = (WCHAR *)(szMetabasePath + 10);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        return hr;
    }
    
    // Open Key
    hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPCWSTR)WamRegGlobal::g_szMDAppPathPrefix,
        METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase); 
    
    if (FAILED(hr))
    {			
        DBGPRINTF((DBG_CONTEXT, "Failed to Open metabase key, path is /LM/W3SVC, hr = %08x\n",
            hr));
    }
    else
    {		
        hr = pMetabase->AddKey(hMetabase, (LPCWSTR)pwszApplicationPath);
        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to AddKey to metabase, path is %S, hr = %08x\n",
                szMetabasePath, 
                hr));
        }
        pMetabase->CloseKey(hMetabase);
    }
    
    return hr;
}

/*===================================================================
MDGetDWORD

Get a DWORD type property from Metabase Key(szMetabasePath)

Parameter:

szMetabasePath	:	[in]	metabase key
dwMDIdentifier  :   [in]    indentifier

Return:		HRESULT

===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetDWORD
(
IN LPCWSTR szMetabasePath, 
IN DWORD dwMDIdentifier,
OUT DWORD *pdwData
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;
	IMSAdminBase 	*pMetabase = NULL;
	
	DBG_ASSERT(pdwData);
	DBG_ASSERT(szMetabasePath);

	pMetabase = m_pMetabase;

	// Open Key
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPCWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);

	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, dwMDIdentifier, METADATA_NO_ATTRIBUTES, 
		IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), (unsigned char *)pdwData);

		hr = pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (FAILED(hr))
			{
			DBGPRINTF((DBG_CONTEXT, "Get MD_APP_ISOLATED failed on MD path %S, id %d, error = %08x\n",
					szMetabasePath,
					dwMDIdentifier,
					hr));
			}
			
		pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

/*===================================================================
MDSetAppState

Set an application state.  (i.e.  If APPSTATE_PAUSE is set, then, the runtime
W3SVC can not launch the application).

Parameter:

szMetabasePath	:	[in]	metabase key
dwState         :           App state to be set.	

Return:		HRESULT
===================================================================*/
HRESULT	WamRegMetabaseConfig::MDSetAppState
(	
IN LPCWSTR szMetabasePath, 
IN DWORD dwState
)
{
	METADATA_RECORD 	recMetaData;
	HRESULT				hr;
	METADATA_HANDLE		hMetabase;

    DBG_ASSERT(m_pMetabase);
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase);

	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_STATE, METADATA_INHERIT, IIS_MD_UT_WAM,
							DWORD_METADATA,  sizeof(DWORD), (unsigned char *)&dwState);
		hr = m_pMetabase->SetData(hMetabase, NULL, &recMetaData);

		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

HRESULT WamRegMetabaseConfig::MDGetWAMCLSID
(
IN LPCWSTR szMetabasePath,
IN OUT LPWSTR szWAMCLSID
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(szWAMCLSID);
	DBG_ASSERT(szMetabasePath);

	szWAMCLSID[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_WAM_CLSID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szWAMCLSID);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBG_ASSERT(FALSE);
			}
			
		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;

}

/*===================================================================
MDGetIdentity

Get pakcage Identity from Metabase Key(szMetabasePath) (WamUserName &
WamPassword)

Parameter:

szIdentity: a string buffer for WamUserName.
cbIdneity:  size of the string buffer for szIdentity.
szPwd:      a string buffer for WamPassword.
cbPwd:      size of the string buffer for szPwd.

Return:		HRESULT

===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetIdentity
(
IN LPWSTR szIdentity,
IN DWORD  cbIdentity,
IN LPWSTR szPwd,
IN DWORD  cbPwd
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(szIdentity);

	szIdentity[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)WamRegGlobal::g_szMDAppPathPrefix,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		// Get WAM user name
		MD_SET_DATA_RECORD(	&recMetaData, MD_WAM_USER_NAME, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  cbIdentity, (unsigned char *)szIdentity);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBGPRINTF((DBG_CONTEXT, "Insufficient buffer for WAM user name. Required size is %d\n",
				dwRequiredLen));
			DBG_ASSERT(FALSE);
			}

        // Get WAM user password
		MD_SET_DATA_RECORD(	&recMetaData, MD_WAM_PWD, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  cbPwd, (unsigned char *)szPwd);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBGPRINTF((DBG_CONTEXT, "Insufficient buffer for WAM user password. Required size is %d\n",
				dwRequiredLen));
			DBG_ASSERT(FALSE);
			}

		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

HRESULT 
WamRegMetabaseConfig::MDGetAppName
(
    IN  LPCWSTR     szMetaPath,
    OUT LPWSTR *    ppszAppName
)
/*++
Function:

    Retrieve the MD_APP_PACKAGE_NAME from the metabase.

Parameters:

    ppszAppName - value of MD_APP_PACKAGE_NAME allocated
                  with new[] free with delete[]

Return:

	{MD_APP_PACKAGE_NAME, STRING_METADATA, 0, EMD_NONE, E_FAIL},


--*/
{
    return MDGetStringAttribute(szMetaPath, MD_APP_PACKAGE_NAME, ppszAppName);
}

HRESULT
WamRegMetabaseConfig::MDGetStringAttribute
(
    IN LPCWSTR szMetaPath,
    DWORD dwMDIdentifier,
    OUT LPWSTR * ppszBuffer
)
{
    DBG_ASSERT( ppszBuffer );
    DBG_ASSERT( m_pMetabase );
    
    HRESULT hr = NOERROR;
    WCHAR * pwcMetaData = NULL;
    DWORD   cbData = 0;
    
    METADATA_HANDLE hKey = NULL;
    METADATA_RECORD	mdr;
    
    *ppszBuffer = NULL;
    
    hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, 
                              szMetaPath,
                              METADATA_PERMISSION_READ, 
                              m_dwMDDefaultTimeOut, 
                              &hKey);
    
    if( SUCCEEDED(hr) )
    {
        MD_SET_DATA_RECORD( &mdr, 
                            dwMDIdentifier, 
                            METADATA_INHERIT, 
                            IIS_MD_UT_WAM,
                            STRING_METADATA,  
                            cbData, 
                            (LPBYTE)pwcMetaData
                           );
        
        hr = m_pMetabase->GetData( hKey, NULL, &mdr, &cbData );
        
        if( HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER )
        {
            pwcMetaData = new WCHAR[ cbData / sizeof(WCHAR) ];
            if( pwcMetaData != NULL )
            {
                mdr.pbMDData = (LPBYTE)pwcMetaData;
                mdr.dwMDDataLen = cbData;
                
                hr = m_pMetabase->GetData( hKey, NULL, &mdr, &cbData );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        m_pMetabase->CloseKey( hKey ); 
    }
    
    //
    // Return AppName
    //
    if( SUCCEEDED(hr) )
    {
        DBG_ASSERT( pwcMetaData != NULL );
        *ppszBuffer = pwcMetaData;
    }
    else
    {
        DBG_ASSERT( *ppszBuffer == NULL );
        delete [] pwcMetaData;
    }
    
    return hr;
}

#ifdef _IIS_6_0

HRESULT
WamRegMetabaseConfig::MDGetAllSiteRoots
(
OUT LPWSTR * ppszBuffer
)
{
    DBG_ASSERT( m_pMetabase );
    DBG_ASSERT(ppszBuffer);
    *ppszBuffer = NULL;

    HRESULT         hr = S_OK;
    METADATA_HANDLE hKey = NULL;
    DWORD           dwEnumKeyIndex = 0;
    WCHAR           szMDName[METADATA_MAX_NAME_LEN] = {0};
    MULTISZ         mszSiteRoots;

    // Loop through all keys below /LM/W3SVC

    hr = m_pMetabase->EnumKeys(METADATA_MASTER_ROOT_HANDLE,
                               L"/LM/W3SVC/",
                               szMDName,
                               dwEnumKeyIndex
                              );
    while(SUCCEEDED(hr))
    {
        int i = _wtoi(szMDName);
        // if this is a site
        if(0 != i)
        {
            // have a valid site number
            WCHAR pTempBuf[METADATA_MAX_NAME_LEN] = {0};
            wcscpy(pTempBuf, L"/LM/W3SVC/");
            wcscat(pTempBuf, szMDName);
            wcscat(pTempBuf, L"/ROOT/");

            if (FALSE == mszSiteRoots.Append(pTempBuf))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
            

        dwEnumKeyIndex++;
        hr = m_pMetabase->EnumKeys(METADATA_MASTER_ROOT_HANDLE,
                                   L"/LM/W3SVC/",
                                   szMDName,
                                   dwEnumKeyIndex
                                  );
    }

    // data is in MULTISZ move to out buffer
    {
        UINT                    cchMulti = 0;
        DWORD                   dwBufferSize = 0;
        
        cchMulti = mszSiteRoots.QueryCCH();

        *ppszBuffer = new WCHAR[cchMulti];
        if (NULL == *ppszBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        dwBufferSize = cchMulti;
        mszSiteRoots.CopyToBuffer(*ppszBuffer, &dwBufferSize);       
    }
    
    hr = S_OK;
done:
    return hr;
}

#endif //_IIS_6_0

/*===================================================================
MDGetIdentity

Get WAMCLSID, Wam PackageID, and fAppIsolated from a metabase path.

Parameter:
szMetabasepath  : get info from this path.
szWAMCLSID:     buffer for WAMCLSID(fixed length buffer).
szPackageID:    buffer for Wam PackageID(fixed length buffer).
fAppIsolated:   if InProc(TRUE), do not retrieve szPackageID.

Return:		HRESULT
===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetIDs
(
IN LPCWSTR  szMetabasePath,
OUT LPWSTR  szWAMCLSID,
OUT LPWSTR  szPackageID,
IN DWORD    dwAppMode
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(m_pMetabase);
	DBG_ASSERT(szWAMCLSID);
	DBG_ASSERT(szPackageID);
	DBG_ASSERT(szMetabasePath);

	szPackageID[0] = NULL;
	szWAMCLSID[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_WAM_CLSID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szWAMCLSID);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBG_ASSERT(FALSE);
			}
			
		if (SUCCEEDED(hr))
			{
			if (dwAppMode == static_cast<DWORD>(eAppRunOutProcIsolated))
				{
				MD_SET_DATA_RECORD(	&recMetaData, MD_APP_PACKAGE_ID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
									STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szPackageID);

				hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
				if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
					{
					DBG_ASSERT(FALSE);
					}
				}
			else if (dwAppMode == static_cast<DWORD>(eAppRunInProc))
				{
				wcsncpy(szPackageID, g_WamRegGlobal.g_szIISInProcPackageID, uSizeCLSID);
				}
		    else
		        {
                wcsncpy(szPackageID, g_WamRegGlobal.g_szIISOOPPoolPackageID, uSizeCLSID);				
		        }
			}
		m_pMetabase->CloseKey(hMetabase);
		}

	return hr;
}

/*===================================================================
MDRemoveProperty

Remove one MD property.

Parameter:

pwszMetabasePath    
dwIdentifier        the MD indentifier to be removed.
dwType              the MD indietifier data type.

Return:		HRESULT
===================================================================*/
HRESULT WamRegMetabaseConfig::MDRemoveProperty
(
IN LPCWSTR pwszMetabasePath,
DWORD dwIdentifier,
DWORD dwType
)
{
	METADATA_RECORD 	recMetaData;
	HRESULT				hr;
	METADATA_HANDLE		hMetabase;
	
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)pwszMetabasePath,
					METADATA_PERMISSION_WRITE, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		hr = m_pMetabase->DeleteData(hMetabase, NULL, dwIdentifier, dwType);
			
		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

/*===================================================================
MDGetLastOutProcPackageID

Get LastOutProcPackageID  from Metabase Key(szMetabasePath)

Parameter:
szMetabasePath	:	[in]		metabase key	
szLastOutProcPackageID	:		[in]		a pointer to LastOutProcPackageID buffer
Return:		HRESULT

Note: fill in the LastOutProcPackageID, memory buffer provided by the caller.
===================================================================*/
HRESULT WamRegMetabaseConfig::MDGetLastOutProcPackageID
(
IN LPCWSTR szMetabasePath,
IN OUT LPWSTR szLastOutProcPackageID
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(szLastOutProcPackageID);
	DBG_ASSERT(szMetabasePath);

	szLastOutProcPackageID[0] = NULL;
	// Open Key
	hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
					METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, MD_APP_LAST_OUTPROC_PID, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM,
							STRING_METADATA,  uSizeCLSID*sizeof(WCHAR), (unsigned char *)szLastOutProcPackageID);

		hr = m_pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBG_ASSERT(FALSE);
			}
			
		m_pMetabase->CloseKey(hMetabase);
		}
		
	return hr;
}

/*===================================================================
GetWebServerName

Look the WebServerName(ServerComment) property under the key (szMetabasePath).

Parameter:
None

Return:		HRESULT

Note: fill in the szWebServerName, memory buffer provided by the caller.
===================================================================*/
HRESULT WamRegMetabaseConfig::GetWebServerName
(
IN LPCWSTR wszMetabasePath, 
IN OUT LPWSTR wszWebServerName, 
IN UINT cBuffer
)
{
	HRESULT 		hr;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	DWORD			dwRequiredLen;

	DBG_ASSERT(wszMetabasePath);
	DBG_ASSERT(wszWebServerName);

	// Open Key
	hr = m_pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE, 
                               wszMetabasePath,
					           METADATA_PERMISSION_READ, 
                               m_dwMDDefaultTimeOut, 
                               &hMetabase
                               );
	if (SUCCEEDED(hr))
		{
		MD_SET_DATA_RECORD(	&recMetaData, 
                            MD_SERVER_COMMENT, 
                            METADATA_INHERIT, 
                            IIS_MD_UT_SERVER,
							STRING_METADATA,  
                            cBuffer, 
                            (unsigned char *)wszWebServerName
                            );
						
		hr = m_pMetabase->GetData(hMetabase, L"", &recMetaData, &dwRequiredLen);
		if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
			{
			DBGPRINTF((DBG_CONTEXT, "Insuffcient buffer for WebServerName. Path = %S\n",
				wszMetabasePath));
			DBG_ASSERT(FALSE);
			}

        //
        // If property MD_SERVER_COMMENT not found, null out the WebServerName.
        //
	    if (hr == MD_ERROR_DATA_NOT_FOUND)
	        {
            wszWebServerName[0] = L'\0';
            hr = NOERROR;
	        }
	        
		if (FAILED(hr))
			{
			DBGPRINTF((DBG_CONTEXT, "Failed to read Metabase for WebServerName. Path = %S, error = %08x\n",
				wszMetabasePath,
				hr));
			}
		
		m_pMetabase->CloseKey(hMetabase);
		}
	else
		{
		DBGPRINTF((DBG_CONTEXT, "Failed to read Metabase for WebServerName. Path = %S, error = %08x\n",
				wszMetabasePath,
				hr));
		}

	return hr;
}

/*===================================================================
GetSignatureOnPath

Get an application signature(AppRoot & AppIsolated) on a metabase path.

Parameter:
pwszMetabasePath
pdwSignature

Return:		HRESULT

Note: Signature is returned via pdwSignature.
===================================================================*/
HRESULT WamRegMetabaseConfig::GetSignatureOnPath
(
IN LPCWSTR pwszMetabasePath,
OUT DWORD* pdwSignature
)
{
	HRESULT hr = NOERROR;
	WCHAR szWAMCLSID[uSizeCLSID];
	WCHAR szPackageID[uSizeCLSID];
	DWORD dwResult = 0;
	DWORD cSize = 0;
	DWORD dwAppMode = 0;

	DBG_ASSERT(pwszMetabasePath);
	
	hr = MDGetDWORD(pwszMetabasePath, MD_APP_ISOLATED, &dwAppMode);
	if (SUCCEEDED(hr))
		{
		hr = MDGetIDs(pwszMetabasePath, szWAMCLSID, szPackageID, (BOOL)dwAppMode);

		if (SUCCEEDED(hr))
			{
			cSize = wcslen(pwszMetabasePath);
			dwResult = WamRegChkSum(pwszMetabasePath, cSize);

			dwResult ^= WamRegChkSum(szWAMCLSID, uSizeCLSID);
			if (dwAppMode == eAppRunOutProcIsolated)
				{
				dwResult ^= WamRegChkSum(szPackageID, uSizeCLSID);
				}
			}
		}

	if (SUCCEEDED(hr))
		{
		*pdwSignature = dwResult;
		}
	else
		{
		*pdwSignature = 0;
		}

	return NOERROR;
}

/*===================================================================
WamRegChkSum

Give a wchar string, calculate a chk sum.

Parameter:
pszKey		wchar string
cchKey		wcslen(of wchar ) string

Return:		ChkSum.

===================================================================*/
DWORD WamRegMetabaseConfig::WamRegChkSum
(
IN LPCWSTR pszKey, 
IN DWORD cchKey
)
{
    DWORD   hash = 0, g;

    while (*pszKey)
        {
        hash = (hash << 4) + *pszKey++;
        if (g = hash & 0xf0000000)
            {
            hash ^= g >> 24;
            }
        hash &= ~g;
        }
    return hash;
}


/*===================================================================
MDGetPropPaths	

Get an array of metabase paths that contains a specific property.

Parameter:
szMetabasePath
dwMDIdentifier
pBuffer			a pointer to a buffer
pdwBufferSize	contains actual buffer size allocated for pBuffer

Return:		
HRESULT
		
Side Affect:
	Allocate memory for return result use new.  Caller needs to free pBuffer
use delete[].
===================================================================*/
HRESULT	WamRegMetabaseConfig::MDGetPropPaths
(
IN LPCWSTR 	szMetabasePath,
IN DWORD	dwMDIdentifier,
OUT WCHAR**	pBuffer,
OUT DWORD*	pdwBufferSize
)
{
    HRESULT hr = NOERROR;
    METADATA_HANDLE	hMetabase = NULL;   // Metabase Handle
    WCHAR	wchTemp;	                // One char buffer, no real usage.
    WCHAR	*pTemp = &wchTemp;		// Start with some buffer, otherwise, 
    // will get RPC_X_NULL_REF_POINTER
    DWORD	dwMDBufferSize = 0;
    DWORD	dwMDRequiredBufferSize = 0;
    
    if (NULL != szMetabasePath)
    {
        // Open Key
        hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)szMetabasePath,
            METADATA_PERMISSION_READ, m_dwMDDefaultTimeOut, &hMetabase);
    }
    else
    {
        hMetabase = METADATA_MASTER_ROOT_HANDLE;
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_pMetabase->GetDataPaths(hMetabase,
                                       NULL,
                                       dwMDIdentifier,
                                       ALL_METADATA,
                                       dwMDBufferSize,
                                       pTemp,
                                       &dwMDRequiredBufferSize);
        if (HRESULTTOWIN32(hr) == ERROR_INSUFFICIENT_BUFFER)
        {
            if (dwMDRequiredBufferSize > 0)
            {
                pTemp = new WCHAR[dwMDRequiredBufferSize];
                if (pTemp == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    DBGPRINTF((DBG_CONTEXT, "Out of memory. \n"));
                }
                else
                {
                    dwMDBufferSize = dwMDRequiredBufferSize;
                    hr = m_pMetabase->GetDataPaths(hMetabase,
                                                   NULL,
                                                   dwMDIdentifier,
                                                   ALL_METADATA,
                                                   dwMDBufferSize,
                                                   (LPWSTR)pTemp,
                                                   &dwMDRequiredBufferSize);
                    if (FAILED(hr))
                    {
                        DBGPRINTF((DBG_CONTEXT, "GetDataPaths failed with identitifier %d, path %S, hr = %08x\n",
                            dwMDIdentifier,
                            szMetabasePath,
                            hr));
                    }
                    else
                    {
                        *pBuffer = pTemp;
                        *pdwBufferSize = dwMDBufferSize;
                    }
                }
            }
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "GetDataPaths failed with identitifier %d, path %S, hr = %08x\n",
                dwMDIdentifier,
                szMetabasePath,
                hr));
        }
        if (hMetabase)
        {
            m_pMetabase->CloseKey(hMetabase);
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to open metabase path %S, hr = %08x\n",
            szMetabasePath,
            hr));
    }
    
    return hr;
}

/*===================================================================
HasAdminAccess	

Determine if the user has appropriate access to the metabase. We'll
use the same, somewhat hacky, method of determining this that the UI
uses. Basically we set a dummy property in the MB that only an admin
has access to. MB will use the call context to validate this.

Parameter:

Return:		
BOOL    - True if user has admin access to the MB
		
Side Affect:
===================================================================*/
BOOL WamRegMetabaseConfig::HasAdminAccess
(
VOID
)
{
    HRESULT         hr = NOERROR;
    METADATA_HANDLE	hMetabase = NULL;
    
    DBG_ASSERT(m_pMetabase);

    hr = m_pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE, 
                               WamRegGlobal::g_szMDW3SVCRoot, 
                               METADATA_PERMISSION_WRITE, 
                               m_dwMDDefaultTimeOut, 
                               &hMetabase );
    if( SUCCEEDED(hr) )
    {
        DWORD           dwDummyValue = 0x1234;
        METADATA_RECORD mdr;

        MD_SET_DATA_RECORD(	&mdr, 
                            MD_ISM_ACCESS_CHECK, 
                            METADATA_NO_ATTRIBUTES, 
                            IIS_MD_UT_FILE,
                            DWORD_METADATA,  
                            sizeof(DWORD), 
                            &dwDummyValue );

        hr = m_pMetabase->SetData( hMetabase, L"", &mdr );

        DBG_REQUIRE( SUCCEEDED(m_pMetabase->CloseKey( hMetabase )) );
    }

    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\mtsconfig.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: mtsconfig.cpp

    implementation of supporting functions for WAMREG, including

    interface to Add/Remove Component from a MTS package,

History: LeiJin created on 9/24/1997

Note:

===================================================================*/
#include "common.h"
#include "auxfunc.h"
#include "dbgutil.h"
#include "export.h"


/*===================================================================
  Define the global variables and types
======================================================================*/

//
// Following is a list of all the WAMREG/MTS properties for Package creation
//  Format:
//     (prop-symbolic-name, property-name-string)
//
//  WAMREG_MTS_PROPERTY()  -> means property for NT & Win9x
//  WAMREG_MTS_NTPROPERTY()  -> means property for NT only
//

# define ALL_WAMREG_MTS_PROPERTY()   \
  WAMREG_MTS_PROPERTY( WM_ID,          L"ID") \
  WAMREG_MTS_PROPERTY( WM_NAME,        L"Name") \
  WAMREG_MTS_PROPERTY( WM_CREATED_BY,  L"CreatedBy") \
  WAMREG_MTS_PROPERTY( WM_RUN_FOREVER, L"RunForever") \
  WAMREG_MTS_NTPROPERTY( WM_IDENTITY,  L"Identity") \
  WAMREG_MTS_NTPROPERTY( WM_PASSWORD,  L"Password") \
  WAMREG_MTS_PROPERTY( WM_ACTIVATION,  L"Activation") \
  WAMREG_MTS_PROPERTY( WM_CHANGEABLE,  L"Changeable") \
  WAMREG_MTS_PROPERTY( WM_DELETABLE,   L"Deleteable") \
  WAMREG_MTS_PROPERTY( WM_SECSUPP,     L"AccessChecksLevel") \
  WAMREG_MTS_PROPERTY( WM_APPLICATIONACCESSCHECKS,L"ApplicationAccessChecksEnabled") \


//
// Let us expand the macros here for defining the symbolic-name
//
//
# define WAMREG_MTS_PROPERTY( symName, pwsz)   symName, 
# define WAMREG_MTS_NTPROPERTY( symName, pwsz)   symName, 

enum WAMREG_MTS_PROP_NAMES {
  ALL_WAMREG_MTS_PROPERTY()  
  MAX_WAMREG_MTS_PROP_NAMES         // sentinel element
};

# undef WAMREG_MTS_PROPERTY
# undef WAMREG_MTS_NTPROPERTY


struct MtsProperty {
    LPCWSTR m_pszPropName;
    BOOL    m_fWinNTOnly;
};

//
// Let us expand the macros here for defining the property strings
//
//
# define WAMREG_MTS_PROPERTY( symName, pwsz)   { pwsz, FALSE },
# define WAMREG_MTS_NTPROPERTY( symName, pwsz)   { pwsz, TRUE },

static const MtsProperty g_rgWamRegMtsProperties[]= {
    ALL_WAMREG_MTS_PROPERTY()  
    { NULL, FALSE}           // sentinel element
};

# define NUM_WAMREG_MTS_PROPERTIES  \
   ((sizeof(g_rgWamRegMtsProperties)/sizeof(g_rgWamRegMtsProperties[0])) - 1)

# undef WAMREG_MTS_PROPERTY
# undef WAMREG_MTS_NTPROPERTY


#define ReleaseInterface(p) if (p) { p->Release(); p = NULL; }


/*===================================================================
WamRegPackageConfig    

Constructor.

Parameter:
NONE;
===================================================================*/
WamRegPackageConfig::WamRegPackageConfig()
:     m_pCatalog(NULL),
    m_pPkgCollection(NULL),
    m_pCompCollection(NULL),
    m_pPackage(NULL)
{

}

/*===================================================================
~WamRegPackageConfig    

Destructor. 
By the time the object gets destructed, all resources should be freed.
We do most of the cleanup inside WamReqPackageConfig::Cleanup() so
 that callers call that function separately to cleanup state
 especially if the caller also calls CoUninitialize().
WamRegPackageConfig should be cleaned up before CoUninitialize()

Parameter:
NONE;
===================================================================*/
WamRegPackageConfig::~WamRegPackageConfig()
{
    Cleanup();

    // insane checks to ensure everything is happy here
    DBG_ASSERT(m_pCatalog == NULL);
    DBG_ASSERT(m_pPkgCollection == NULL);
    DBG_ASSERT(m_pCompCollection == NULL);
    DBG_ASSERT(m_pPackage == NULL);
}

VOID
WamRegPackageConfig::Cleanup(VOID)
{
    if (m_pPackage != NULL ) {
        RELEASE( m_pPackage);
        m_pPackage = NULL;
    }
    
    if (m_pCompCollection != NULL) {
        RELEASE (m_pCompCollection);
        m_pCompCollection = NULL;
    }

    if (m_pPkgCollection != NULL ) {
        RELEASE(m_pPkgCollection);
        m_pPkgCollection = NULL;
    }

    if (m_pCatalog != NULL ) {
        RELEASE(m_pCatalog);
        m_pCatalog = NULL;
    }

} // WamPackageConfig::Cleanup()


/*===================================================================
ReleaseAll

Release all resources.

Parameter:
NONE;
===================================================================*/
VOID WamRegPackageConfig::ReleaseAll
(
)
{
    RELEASE(m_pPackage);
    RELEASE(m_pCompCollection);

    //
    // NOTE: I am not releasing m_pCatalog, m_pPkgCollection
    //  These will be released by the Cleanup().
    //
}

/*===================================================================
CreateCatalog

CoCreateObject of an MTS Catalog object if the Catalog object has not been
created.

Parameter:
NONE;
===================================================================*/
HRESULT WamRegPackageConfig::CreateCatalog
(
VOID
)
{
    HRESULT hr = NOERROR;

    DBG_ASSERT(m_pCatalog == NULL);
    DBG_ASSERT(m_pPkgCollection == NULL);

    // Create instance of the catalog object
    hr = CoCreateInstance(CLSID_COMAdminCatalog
                    , NULL
                    , CLSCTX_SERVER
                    , IID_ICOMAdminCatalog
                    , (void**)&m_pCatalog);

    if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT, 
                   "Failed to CoCreateInstance of Catalog Object.,hr = %08x\n",
                   hr));
    }
    else {
        DBG_ASSERT(m_pCatalog != NULL);

        BSTR  bstr;
        
        //
        // Get the Packages collection
        //
        bstr = SysAllocString(L"Applications");
        hr = m_pCatalog->GetCollection(bstr, (IDispatch**)&m_pPkgCollection);
        FREEBSTR(bstr);
        if (FAILED(hr)) {

            // Release the Catalog in case we are called again
            RELEASE(m_pCatalog);

            DBGPRINTF((DBG_CONTEXT, 
                       "m_pCatalog(%08x)->GetCollection() failed, hr = %08x\n",
                       m_pCatalog,
                       hr));
        } else {
            DBG_ASSERT( m_pPkgCollection != NULL);
        }
            
    }

    return hr;
} // WamRegPackageConfig::CreateCatalog()



/*===================================================================
SetCatalogObjectProperty    

Get a SafeArray contains one ComponentCLSID

Parameter:
szComponentCLSID    the CLSID need to be put in the safe array
paCLSIDs            pointer to a pointer of safe array(safe array provided by caller).

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT WamRegPackageConfig::GetSafeArrayOfCLSIDs
(
IN LPCWSTR    szComponentCLSID,
OUT SAFEARRAY**    paCLSIDs
)
{
    SAFEARRAY*          aCLSIDs = NULL;
    SAFEARRAYBOUND      rgsaBound[1];
    LONG                Indices[1];
    VARIANT                varT;
    HRESULT             hr = NOERROR;

    DBG_ASSERT(szComponentCLSID && paCLSIDs);
    DBG_ASSERT(*paCLSIDs == NULL);
    
    // PopulateByKey is expecting a SAFEARRAY parameter input,
    // Create a one element SAFEARRAY, the one element of the SAFEARRAY contains
    // the packageID.
    rgsaBound[0].cElements = 1;
    rgsaBound[0].lLbound = 0;
    aCLSIDs = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

    if (aCLSIDs)
        {
        Indices[0] = 0;

        VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(szComponentCLSID);
        hr = SafeArrayPutElement(aCLSIDs, Indices, &varT);
        VariantClear(&varT);

        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayPutElement, CLSID is %S, hr %08x\n",
                szComponentCLSID,
                hr));
       
            if (aCLSIDs != NULL)
                {
                HRESULT hrT = SafeArrayDestroy(aCLSIDs);
                if (FAILED(hrT))
                    {
                    DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                        hr));
                    }
                aCLSIDs = NULL;
                }
            }
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayCreate, hr %08x\n",
                hr));
        }

    *paCLSIDs = aCLSIDs;
    return hr;
}



/*===================================================================
SetComponentObjectProperty    

Set component level property.

Parameter:
pComponent     - pointer to the ICatalogObject(MTS) used to update property
szPropertyName - Name of the property
szPropertyValue- Value of the property
fPropertyValue - If szPropertyValue is NULL, use fPropertyValue

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT    WamRegPackageConfig::SetComponentObjectProperty
(
IN ICatalogObject * pComponent,
IN LPCWSTR          szPropertyName,
IN LPCWSTR          szPropertyValue,
BOOL                fPropertyValue
)
{
    BSTR    bstr    = NULL;
    HRESULT hr      = NOERROR;
    VARIANT    varT;
    
    VariantInit(&varT);
    bstr = SysAllocString(szPropertyName);

    if (szPropertyValue != NULL)
        {
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(szPropertyValue);
        }
    else
        {
        //
        // COM+ regcongize -1 as TRUE, and 0 as FALSE.  I believe the root is from VB.
        //
        varT.vt = VT_BOOL;
        varT.boolVal = (fPropertyValue) ? VARIANT_TRUE : VARIANT_FALSE;
        }
        
    hr = pComponent->put_Value(bstr, varT);
        
    FREEBSTR(bstr);
    VariantClear(&varT);

    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT,
                   "MTS-Component(%08x)::SetProperty(%S => %S) failed;"
                   " hr %08x\n",
                   pComponent, szPropertyName, szPropertyValue, hr));
        }        
    return hr;
}


/*===================================================================
WamRegPackageConfig::SetComponentObjectProperties()

Sets the componnet properties for newly created component that houses
the WAM unit

Parameter:
szComponentCLSID  -  CLSID for the component that is newly created

Return:        HRESULT

Side Affect:
  If there is a failure all the previously set values are not cleared.
  The caller should make sure that the proper cleanup of package happens
  on partial errors.

Note:
===================================================================*/
HRESULT
WamRegPackageConfig::SetComponentObjectProperties(
   IN LPCWSTR    szComponentCLSID
)
    {
    HRESULT         hr;
    SAFEARRAY*      aCLSIDs = NULL;
    long            lCompCount = 0;
    ICatalogObject* pComponent = NULL;
    BOOL            fFound;

    DBG_ASSERT( m_pCompCollection != NULL);

    //
    // Create the array containing the CLSIDs from the component name
    //  this will be used to find our object in MTS and set properties
    //   on the same
    //
    
    hr = GetSafeArrayOfCLSIDs(szComponentCLSID, &aCLSIDs);
    if (FAILED(hr)) 
        {
    
        DBGPRINTF((DBG_CONTEXT, 
                   "Failed in GetSafeArrayOfCLSIDs(%S). hr=%08x\n",
                   szComponentCLSID, hr));
        goto LErrExit;
        }
    
    hr = m_pCompCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr)) 
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
                   hr));
        goto LErrExit;
        }

    // Find our component in the list (should be the only one)
    hr = m_pCompCollection->get_Count(&lCompCount);
    if (FAILED(hr)) 
        {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed in CompCollection(%08x)::get_Count(). hr = %08x\n",
                   m_pCompCollection, hr));
        goto LErrExit;
        }

       
    //
    // Load the component object so that we can set properties
    //
    fFound = FALSE;
    if (SUCCEEDED(hr) && lCompCount == 1) 
        {
        hr = m_pCompCollection->get_Item(0, (IDispatch**)&pComponent);
        
        if (FAILED(hr)) 
            {
            
            DBGPRINTF((DBG_CONTEXT,
                       "Failed in CompCollection(%08x)::get component() hr=%08x\n",
                       m_pCompCollection, hr));
            goto LErrExit;
            } 
        else 
            {

            // Found it
            DBG_ASSERT(pComponent);
            fFound = TRUE;
            }
        }
        
    if (fFound) 
        {

        //
        // Component Properties       InProc            OutOfProc
        // ---------------------     --------           ----------
        // Synchronization              0               same
	    // Transaction              "Not Supported"     same
	    // JustInTimeActivation         N               same
	    // IISIntrinsics                N               same
	    // COMTIIntrinsics              N               same
	    // ComponentAccessChecksEnabled     0               same
	    // MustRunInDefaultContext      TRUE            same
	    //

        hr = SetComponentObjectProperty( pComponent, L"Synchronization", L"0");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        
        hr = SetComponentObjectProperty( pComponent, L"ComponentAccessChecksEnabled", L"0");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
                
        hr = SetComponentObjectProperty( pComponent, L"Transaction", L"0");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        
        hr = SetComponentObjectProperty( pComponent, L"JustInTimeActivation",NULL,FALSE);
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }

        hr = SetComponentObjectProperty( pComponent, L"IISIntrinsics", NULL, FALSE);
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }

        hr = SetComponentObjectProperty( pComponent, L"COMTIIntrinsics", NULL, FALSE);
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        
        hr = SetComponentObjectProperty(pComponent, L"EventTrackingEnabled", L"N");
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        
        hr = SetComponentObjectProperty(pComponent, L"MustRunInDefaultContext", NULL, TRUE);
        if (FAILED(hr)) 
            {
            goto LErrExit;
            }
        } 
    else 
        {

        DBGPRINTF((DBG_CONTEXT, 
                   "Unable to find newly created WAM component in package\n"));
        DBG_ASSERT(FALSE);
        }

LErrExit:    
    RELEASE(pComponent);
    
    if (aCLSIDs != NULL) {

        HRESULT hrT = SafeArrayDestroy(aCLSIDs);
        if (FAILED(hrT)) {
            
            DBGPRINTF((DBG_CONTEXT, 
                       "Failed to call SafeArrayDestroy(aCLSIDs=%08x),"
                       " hr = %08x\n",
                       aCLSIDs, hr));
        }
        aCLSIDs = NULL;
    }
    
    return ( hr);
} //  // WamRegPackageConfig::SetComponentObjectProperties()



/*===================================================================
SetPackageObjectProperty    

Set package level property.

Parameter:
szPropertyName  Name of the property
szPropertyValue Value of the property

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT    WamRegPackageConfig::SetPackageObjectProperty
(
IN LPCWSTR        szPropertyName,
IN LPCWSTR        szPropertyValue
)
{
    BSTR    bstr    = NULL;
    HRESULT hr      = NOERROR;
    VARIANT    varT;

    
    VariantInit(&varT);
    bstr = SysAllocString(szPropertyName);
    varT.vt = VT_BSTR;
    varT.bstrVal = SysAllocString(szPropertyValue);
    DBG_ASSERT(m_pPackage != NULL);
    hr = m_pPackage->put_Value(bstr, varT);
        
    FREEBSTR(bstr);
    VariantClear(&varT);

    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT,
                   "Set Catalog Object Property failed, "
                   "Component is %S, hr %08x\n",
                   szPropertyName,
                   hr));
        }        
    return hr;
} // WamRegPackageConfig::SetPackageObjectProperty()




/*===================================================================
WamRegPackageConfig::SetPackageProperties()

Sets package properties for all WAMREG properties.

Parameter:
rgpszValues:   An array containing pointers to string values to be used
               for setting up the WAMREG related properites for MTS catalog.

Return:        HRESULT
Side Affect:
  If there is a failure all the previously set values are not cleared.
  The caller should make sure that the proper cleanup of package happens
  on partial errors.

Note:
===================================================================*/
HRESULT    WamRegPackageConfig::SetPackageProperties
(
IN LPCWSTR    * rgpszValues
)
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( m_pPackage);

    //
    // Loop through all properties and set the values for these 
    //  properties using the passed in array of strings.
    // UGLY: MTS likes to have string properties which need to be 
    //   fed in as BSTRs => very inefficient.
    //

    for (DWORD i = 0; i < NUM_WAMREG_MTS_PROPERTIES; i++) {

        if ( (rgpszValues[i] == NULL)
             ) {
            
            //
            // This parameter is required only for certain cases.
            // Skip this parameter.
            //

            continue;
        }

        DBG_ASSERT( rgpszValues[i] != NULL);

        IF_DEBUG( WAMREG_MTS) {
            DBGPRINTF(( DBG_CONTEXT, 
                        "In Package(%08x) setting property %S to value %S\n",
                        m_pPackage, 
                        g_rgWamRegMtsProperties[i].m_pszPropName,
                        rgpszValues[i]
                        ));
        }

        //
        // Now let us set up the property in the MTS package
        //

        hr = SetPackageObjectProperty(g_rgWamRegMtsProperties[i].m_pszPropName,
                                      rgpszValues[i]);
        if ( FAILED (hr)) {
            DBGPRINTF((DBG_CONTEXT, "Failed to set property %S, value is %S\n",
                g_rgWamRegMtsProperties[i].m_pszPropName,
                rgpszValues[i]));
            break;
        }
    } // for all properties

    return (hr);
} // WamRegPackageConfig::SetPackageProperties()


BOOL WamRegPackageConfig::IsPackageInstalled
(
IN LPCWSTR szPackageID,
IN LPCWSTR szComponentCLSID
)
/*++
Routine Description:

    Determine if the WAM package is installed and is valid. Currently this
    is only called by setup.

Parameters

    IN LPCWSTR szPackageID          - Package ID
    IN LPCWSTR szComponentCLSID     - Component CLSID

Return Value

    BOOL    - True if package contains the component. False otherwise.

--*/
{
    HRESULT     hr;
    SAFEARRAY*  aCLSIDs = NULL;
    SAFEARRAY*  aCLSIDsComponent = NULL;

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    long                    lPkgCount;
    BOOL                    fFound = FALSE;
    ICatalogCollection*     pCompCollection = NULL;
    
    // Only use the trace macro here, even for error conditions.
    // This routine may fail in a variety of ways, but we expect
    // to be able to fix any of them, only report an error if 
    // the failure is likely to impair the functionality of the
    // server.

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "CALL - IsPackageInstalled, Package(%S) Component(%S)\n",
        szPackageID,
        szComponentCLSID
        ));

    //
    // Get the package
    //

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE((
            DBG_CONTEXT, 
            "Failed to GetSafeArrayOfCLSIDs for %S, hr = %08x\n",
            szPackageID,
            hr
            ));
        goto LErrExit;
        }

    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE((
            DBG_CONTEXT, 
            "Failed in m_pPkgCollection(%p)->PopulateByKey(), hr = %08x\n",
            m_pPkgCollection,
            hr
            ));
        goto LErrExit;
        }
    
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        // 
        // We found the package. Now verify that it contains our component.
        //
        SETUP_TRACE((
            DBG_CONTEXT, 
            "Successfully retrieved package (%S).\n",
            szPackageID
            ));

        VARIANT varKey;
        BSTR    bstrComponentCollection;

        VariantInit(&varKey);
        varKey.vt = VT_BSTR;
        varKey.bstrVal = SysAllocString(szPackageID);

        // Get the "ComponentsInPackage" collection.
        bstrComponentCollection = SysAllocString(L"Components");
        hr = m_pPkgCollection->GetCollection(
                    bstrComponentCollection, 
                    varKey, 
                    (IDispatch**)&pCompCollection
                    );
        
        FREEBSTR(bstrComponentCollection);
        VariantClear(&varKey);
        if (FAILED(hr))
            {
            SETUP_TRACE((
                DBG_CONTEXT, 
                "Failed in m_pPkgCollection(%p)->GetCollection(), hr = %08x\n",
                m_pPkgCollection,
                hr
                ));
            goto LErrExit;
            }

        hr = GetSafeArrayOfCLSIDs(szComponentCLSID, &aCLSIDsComponent);
        if (FAILED(hr))
            {
            SETUP_TRACE((
                DBG_CONTEXT, 
                "Failed to GetSafeArrayOfCLSIDs for %S, hr = %08x\n",
                szComponentCLSID,
                hr
                ));
            goto LErrExit;
            }

        hr = pCompCollection->PopulateByKey( aCLSIDsComponent );
        if( FAILED(hr) )
            {
            SETUP_TRACE((
                DBG_CONTEXT, 
                "Failed in pCompCollection(%p)->PopulateByKey, hr = %08x\n",
                pCompCollection,
                hr
                ));
            goto LErrExit;
            }

        hr = pCompCollection->get_Count( &lPkgCount );
        if( SUCCEEDED(hr) && lPkgCount == 1 )
            {
            // Success! We found the package and it contains the 
            // correct component.

            SETUP_TRACE((
                DBG_CONTEXT, 
                "Successfully retrieved component (%S) from package (%S).\n",
                szComponentCLSID,
                szPackageID
                ));

            fFound = TRUE;
            }
        }

LErrExit:
    if (aCLSIDs != NULL)
        {
        SafeArrayDestroy(aCLSIDs);        
        aCLSIDs = NULL;
        }

    if( aCLSIDsComponent != NULL )
        {
        SafeArrayDestroy(aCLSIDsComponent);
        aCLSIDsComponent = NULL;
        }
    
    RELEASE( pCompCollection );  

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "RETURN - IsPackageInstalled, hr=%08x\n", 
        hr 
        ));
    return fFound;
}
/*===================================================================
RemovePackage    

Remove a Viper Package.

Parameter:
    szPackageID:    an MTS package ID.

Return:        HRESULT
Side Affect:

Note:
Remove an IIS package from MTS. So far, only been called from RemoveIISPackage.
RemoveComponentFromPackage() also removes a IIS package sometimes. 
Refer to that function header for info.
===================================================================*/
HRESULT WamRegPackageConfig::RemovePackage
(
IN LPCWSTR    szPackageID
)
{
    HRESULT                hr = NOERROR;
    long                lPkgCount = 0;
    long                lChanges;
    SAFEARRAY*          aCLSIDs = NULL;
    
    DBG_ASSERT(szPackageID);
    
    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);        
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to get SafeArrayofCLSIDs, szPackageID is %S, hr %08x",
            szPackageID,
            hr));
        goto LErrExit;
        }
        
    //
    // Populate it
    //    
    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErrExit;
        }
        
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        IF_DEBUG(ERROR)
                {
                DBGPRINTF((DBG_CONTEXT, "pPkgCollection->Populate() failed, hr = %08x\n",
                    hr));
                }
        goto LErrExit;
        }
        
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = m_pPkgCollection->get_Item(0, (IDispatch**)&m_pPackage);
        if (FAILED(hr))
            {
            goto LErrExit;
            }
            
        // Found it - remove it and call Save Changes
        // First, Set Deleteable = Y property on package
        hr = SetPackageObjectProperty(L"Deleteable", L"Y");
        if (FAILED(hr))
            {
            goto LErrExit;
            }

        RELEASE(m_pPackage);
        
        // Let save the Deletable settings
        hr = m_pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save the Deletable settings failed, hr = %08x\n",
                hr));
            goto LErrExit;
            }
            
        // Now we can delete
        hr = m_pPkgCollection->Remove(0);
        if (FAILED(hr))
            {                
            DBGPRINTF((DBG_CONTEXT, "Remove the Component from package failed, hr = %08x\n",
                hr));
            goto LErrExit;
            }

        // Aha, we should be able to delete now.
        hr = m_pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save changes failed, hr = %08x\n",
                hr));
            goto LErrExit;
            }
        }

LErrExit:
    if (aCLSIDs != NULL)
        {
        HRESULT hrT = SafeArrayDestroy(aCLSIDs);
        if (FAILED(hrT))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                hr));
            }
        aCLSIDs = NULL;
        }
        
    ReleaseAll();
        
    return hr;
}

/*===================================================================
CreatePackage    

Create a viper package.

Parameter:
szPackageID:            [in] Viper Package ID.
szPackageName:            [in] the name of the package.
szIdentity:                [in] Pakcage identity
szIdPassword:           [in] Package idneitty password


Return:        HRESULT
Side Affect:
NONE.

===================================================================*/
HRESULT WamRegPackageConfig::CreatePackage
(    
IN LPCWSTR    szPackageID,
IN LPCWSTR    szPackageName,
IN LPCWSTR    szIdentity,
IN LPCWSTR    szIdPassword
)
    {
    
    HRESULT     hr;
    SAFEARRAY*  aCLSIDs = NULL;

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    long lPkgCount;
    BOOL fFound = FALSE;

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "CALL - CreatePackage ID(%S) Name(%S)\n",
        szPackageID,
        szPackageName
        ));
    
    //
    // Try to get the package.
    //
    SETUP_TRACE((
        DBG_CONTEXT, 
        "Checking to see if package ID(%S) Name(%S) exists.\n",
        szPackageID,
        szPackageName
        ));

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed to GetSafeArrayOfCLSIDs for %S, hr = %08x\n",
            szPackageID,
            hr
            ));
        goto LErrExit;
        }

    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed in m_pPkgCollection(%p)->PopulateByKey(), hr = %08x\n",
            m_pPkgCollection,
            hr
            ));
        goto LErrExit;
        }
    
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        //
        // Found the CLSID in PopulateByKey().
        //
        hr = m_pPkgCollection->get_Item(0, (IDispatch**)&m_pPackage);
        if (FAILED(hr))
            {
            SETUP_TRACE_ERROR((
                DBG_CONTEXT, 
                "Failed in m_pPkgCollection(%p)->get_Item(). Err=%08x\n",
                m_pPkgCollection, 
                hr
                ));
            goto LErrExit;
            }
        else
            {
            SETUP_TRACE(( 
                DBG_CONTEXT, 
                "CreatePackage - Package already exists, ID(%S), Name(%S)\n",
                szPackageID,
                szPackageName
                ));
            DBG_ASSERT(m_pPackage);
            fFound = TRUE;
            }
        }

    if ( SUCCEEDED(hr) )
    {

        if( !fFound )
        {
            SETUP_TRACE(( 
                DBG_CONTEXT, 
                "Package ID(%S) Name(%S) does not exist. Attempting to create it.\n",
                szPackageID,
                szPackageName
                ));
            //
            // The package does not already exist, we need to call Add() to 
            // add this package and then set it's properties.
            //
            hr = m_pPkgCollection->Add((IDispatch**)&m_pPackage);
            if ( FAILED(hr)) 
                {
                SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT, 
                    "Failed in m_pPkgCollection(%p)->Add(). Err=%08x\n",
                    m_pPkgCollection, 
                    hr
                    ));
                goto LErrExit;
                }
        }
        
        DBG_ASSERT( SUCCEEDED( hr));
        DBG_ASSERT( m_pPackage != NULL);

        if( SUCCEEDED(hr) && m_pPackage != NULL )
        {
            //
            // Set the Package properties 
            //  first by initializing the array of values and then
            //  calling SetPackageProperties()
            //
        
            LPCWSTR rgpszValues[ MAX_WAMREG_MTS_PROP_NAMES];

            ZeroMemory( rgpszValues, sizeof( rgpszValues));

            if( fFound )
            {
                // For an existing package, we don't want to set the ID
                rgpszValues[ WM_ID]         = NULL;
            }
            else
            {
                rgpszValues[ WM_ID]         = szPackageID;
            }

            rgpszValues[ WM_NAME]       = szPackageName;
            rgpszValues[ WM_CREATED_BY] = 
                L"Microsoft Internet Information Services";

            rgpszValues[ WM_RUN_FOREVER] = L"Y";

            rgpszValues[ WM_IDENTITY]   = szIdentity;
            rgpszValues[ WM_PASSWORD]   = szIdPassword;
            rgpszValues[ WM_ACTIVATION] = L"Local";
            rgpszValues[ WM_CHANGEABLE] = L"Y";
            rgpszValues[ WM_DELETABLE]  = L"N";
            rgpszValues[ WM_SECSUPP] = L"0";
            rgpszValues[ WM_APPLICATIONACCESSCHECKS ] = L"N";
        
            //
            // Now that we have the properties setup, let us
            //  now set the properties in the MTS using catalog
            //  object
            //
            hr = SetPackageProperties( rgpszValues);
            if ( FAILED( hr)) 
            {
                SETUP_TRACE_ERROR(( 
                    DBG_CONTEXT, 
                    "Failed to set properties for package %p. Err=%08x\n",
                    m_pPackage, 
                    hr
                    ));
                goto LErrExit;
            }

            long lChanges;
    
            hr = m_pPkgCollection->SaveChanges(&lChanges);
            if (FAILED(hr))
            {
                SETUP_TRACE_ERROR((
                    DBG_CONTEXT, 
                    "Failed in m_pPkgCollection(%p)->SaveChanges. error = %08x\n",
                    m_pPkgCollection,
                    hr
                    ));
                goto LErrExit;
            }
        } 
    }
    
LErrExit:

    if (aCLSIDs != NULL)
        {
        SafeArrayDestroy(aCLSIDs);        
        aCLSIDs = NULL;
        }
        
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed to Create Package. Package Name = %S, Package ID = %S, error = %08x\n",
            szPackageName,
            szPackageID,
            hr
            ));
        }
    
    SETUP_TRACE_ASSERT(SUCCEEDED(hr));

    ReleaseAll();
    
    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "RETURN - CreatePackage ID(%S) Name(%S)\n",
        szPackageID,
        szPackageName
        ));

    return hr;
    }

/*===================================================================
AddComponentFromPackage    

Add a Component (a WAM CLSID) from a Viper Package.  Assume the package
is already existed.

Parameter:
szPackageID:            [in] Viper Package ID.
szComponentCLSID:        [in] Component CLSID.
fInProc:                [in] if TRUE, we set certain property on the Component.

Return:        HRESULT
Side Affect:
NONE.

===================================================================*/
HRESULT    WamRegPackageConfig::AddComponentToPackage
(    
IN LPCWSTR    szPackageID,
IN LPCWSTR    szComponentCLSID
)
{
    HRESULT            hr;
    BSTR bstrGUID    = NULL;
    BSTR bstr = NULL;
    VARIANT         varKey;
    long            lChanges;
    BOOL            fFound;
    long            lPkgCount;
    BOOL            fImported = FALSE;
    
    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "CALL - AddComponentToPackage, Package(%S) Component(%S)\n",
        szPackageID,
        szComponentCLSID
        ));

    DBG_ASSERT(szPackageID);
    DBG_ASSERT(szComponentCLSID);
    
    VariantInit(&varKey);
    VariantClear(&varKey);

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    varKey.vt = VT_BSTR;
    varKey.bstrVal = SysAllocString(szPackageID);
    
    bstr = SysAllocString(szPackageID);
    bstrGUID = SysAllocString(szComponentCLSID);
    
    hr = m_pCatalog->ImportComponent(bstr, bstrGUID);
    FREEBSTR(bstr);
    FREEBSTR(bstrGUID);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed in m_pCatalog(%p)->ImportComponent(). error %08x\n",
            m_pCatalog,
            hr
            ));
        goto LErrExit;
        }
    else
        {
        fImported = TRUE;
        }

    // Get the "ComponentsInPackage" collection.
    bstr = SysAllocString(L"Components");
    
    hr = m_pPkgCollection->GetCollection(bstr, varKey, (IDispatch**)&m_pCompCollection);
    FREEBSTR(bstr);
    VariantClear(&varKey);
    if (FAILED(hr))
        {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed in m_pPkgCollection(%p)->GetCollection(). error %08x\n",
            m_pPkgCollection,
            hr
            ));
        goto LErrExit;
        }    

    //
    // Find and Set properties on the component object
    //
    hr = SetComponentObjectProperties( szComponentCLSID);
    if ( FAILED(hr)) 
    {
        SETUP_TRACE_ERROR((
            DBG_CONTEXT, 
            "Failed to SetComponentObjectProperties. error %08x\n",
            hr
            ));
        goto LErrExit;
    }
        
LErrExit:
        
    // Save changes
    if (SUCCEEDED(hr))
        {
        hr = m_pCompCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            SETUP_TRACE_ERROR((
                DBG_CONTEXT, 
                "Failed in m_pCompCollection(%p)->SaveChanges(), error = %08x\n",
                m_pCompCollection,
                hr
                ));
            }
        }
    else
        {
        // CODEWORK - This seems like a bad idea. The release should drop any
        // changes we made, so this cleanup code seems to be asking for trouble.

        // Need to remove component from the package
        if (fImported && m_pCompCollection )
            {
            SETUP_TRACE_ERROR((
                DBG_CONTEXT, 
                "Failed in AddComponentToPackage, removing the component, error = %08x\n",
                hr
                ));

            HRESULT hrT;
            long    lCompCount;

            // Find our component in the list (should be the only one)
            hrT = m_pCompCollection->get_Count(&lCompCount);
            if (SUCCEEDED(hrT))
                {
                fFound = FALSE;
                if (SUCCEEDED(hrT) && lCompCount == 1)
                    {
                    // Found it
                    fFound = TRUE;
                    hrT = m_pCompCollection->Remove(0);
                    if (SUCCEEDED(hrT))
                        {
                        hrT = m_pCompCollection->SaveChanges(&lChanges);
                        if (FAILED(hrT))
                            {
                            SETUP_TRACE_ERROR((
                                DBG_CONTEXT, 
                                "Failed in m_pCompCollection->SaveChanges() during cleanup, error = %08x\n",
                                hrT
                                ));
                            }

                        }
                    else
                        {
                        SETUP_TRACE_ERROR((
                            DBG_CONTEXT, 
                            "Failed in m_pCompCollection->Remove() during cleanup, hr = %08x\n", 
                            hrT
                            ));
                        }
                    }
                }
            }
        }
        
    FREEBSTR(bstr);
    VariantClear(&varKey);
    
    ReleaseAll();

    SETUP_TRACE(( 
        DBG_CONTEXT, 
        "RETURN - AddComponentToPackage, Package(%S) Component(%S), hr=%08x\n",
        szPackageID,
        szComponentCLSID,
        hr
        ));
        
    return hr;
}

/*===================================================================
RemoveComponentFromPackage    

Remove a Component (a WAM CLSID) from a Viper Package.

Parameter:
szPackageID:            [in] Viper Package ID.
szComponentCLSID:        [in] Component CLSID.
fDeletePackage:            [in] if TRUE, we delete the package always. (be very careful, with in-proc
                             package).

Return:        HRESULT
Side Affect:
After remove the component from the package, if the component count in the
package is 0, then delete the whole package.

===================================================================*/
HRESULT    WamRegPackageConfig::RemoveComponentFromPackage
(
IN LPCWSTR szPackageID,
IN LPCWSTR szComponentCLSID,
IN DWORD   dwAppIsolated
)
{    
    HRESULT             hr;
    BSTR                bstr = NULL;
    BSTR                bstrGUID    = NULL;
    VARIANT             varKey;
    VARIANT             varT;
    SAFEARRAY*          aCLSIDs = NULL;
    LONG                Indices[1];
    long                lPkgCount, lCompCount, lChanges;
    long                lPkgIndex = 0;
    BOOL fFound;
    
    VariantInit(&varKey);
    VariantClear(&varKey);
    VariantInit(&varT);
    VariantClear(&varT);

    DBG_ASSERT( m_pCatalog != NULL);
    DBG_ASSERT( m_pPkgCollection != NULL);

    hr = GetSafeArrayOfCLSIDs(szPackageID, &aCLSIDs);
    //
    // Populate it
    //    
    hr = m_pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErrExit;
        }

    // Find our component in the list (should be the only one)
    hr = m_pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
        goto LErrExit;
        }

    fFound = FALSE;
    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = m_pPkgCollection->get_Item(0, (IDispatch**)&m_pPackage);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
            goto LErrExit;
            }
        
        hr = m_pPackage->get_Key(&varKey);
        if (SUCCEEDED(hr))
            {
            // Found it
            DBG_ASSERT(m_pPackage);
            fFound = TRUE;
            }
        }

    // Get the "Components" collection.
    bstr = SysAllocString(L"Components");
    hr = m_pPkgCollection->GetCollection(bstr, varKey, (IDispatch**)&m_pCompCollection);
    FREEBSTR(bstr);
    VariantClear(&varKey);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
        goto LErrExit;
        }
    
    // Repopulate the collection so we can find our object and set properties on it
    Indices[0] = 0;
    VariantInit(&varT);
    varT.vt = VT_BSTR;
    varT.bstrVal = SysAllocString(szComponentCLSID);
    hr = SafeArrayPutElement(aCLSIDs, Indices, &varT);
    VariantClear(&varT);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
            hr));
        }
    //
    // Populate it
    //    
    hr = m_pCompCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErrExit;
        }

    // Find our component in the list (should be the only one)
    hr = m_pCompCollection->get_Count(&lCompCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call MTS Admin API. error %08x\n", hr));
        goto LErrExit;
        }

    fFound = FALSE;
    if (SUCCEEDED(hr) && lCompCount == 1)
        {
        // Found it
        fFound = TRUE;
        hr = m_pCompCollection->Remove(0);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }
        }
        
    DBG_ASSERT(fFound);

    // Save changes
    hr = m_pCompCollection->SaveChanges(&lChanges);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
        goto LErrExit;
        }


    // 
    //  Need to populate again to get the Component count after remove the component from
    //  the package.  The populatebykey only populate 1 component a time.
    //  However, if this package is the default package hosting all in-proc WAM components,
    //  we know that there is at least one component W3SVC always in this package, therefore
    //  we skip the GetComponentCount call here.
    //  The component count for the default package must be at least one, 
    //

    // Set lCompCount = 1, so that the only case that lCompCount becomes 0 is the OutProc
    // Islated package has 0 components.
    lCompCount = 1;
    if (dwAppIsolated == static_cast<DWORD>(eAppRunOutProcIsolated))
        {
        hr = m_pCompCollection->Populate();
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }
            
        // Find our component in the list (should be the only one)
        hr = m_pCompCollection->get_Count(&lCompCount);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }

        // Component count is 0, remove the package.
        if (lCompCount == 0)
            {        
            // Found it - remove it and call Save Changes
            // First, Set Deleteable = Y property on package
            hr = SetPackageObjectProperty(L"Deleteable", L"Y");
            if (FAILED(hr))
                {
                goto LErrExit;
                }

            RELEASE(m_pPackage);
            // Let save the Deletable settings
            hr = m_pPkgCollection->SaveChanges(&lChanges);
            if (FAILED(hr))
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
                goto LErrExit;
                }
                
            hr = m_pPkgCollection->Remove(0);
            if (FAILED(hr))
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
                goto LErrExit;
                }
            }
        else
            {
            // Set Attribute Deleteable = "Y"
            hr = SetPackageObjectProperty(L"Deleteable", L"Y");
            if (FAILED(hr))
                {
                goto LErrExit;
                }

            // Set CreatedBy = ""
            hr = SetPackageObjectProperty(L"CreatedBy", L"");
            if (FAILED(hr))
                {
                goto LErrExit;
                }

            // Set Identity to Interactive User. MTS might use that package with "Interactive User"
            // as the indentity.
            hr = SetPackageObjectProperty(L"Identity", L"Interactive User");
            if (FAILED(hr))
                {
                DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
                goto LErrExit;
                }

            RELEASE(m_pPackage);
            }
            
        hr = m_pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to Call MTS Admin API, hr = %08x\n", hr));
            goto LErrExit;
            }
        }
LErrExit:

    if (aCLSIDs != NULL)
        {
        HRESULT hrT;
        hrT = SafeArrayDestroy(aCLSIDs);

        if (FAILED(hrT))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                hr));
            }

        aCLSIDs = NULL;
        }

    FREEBSTR(bstr);
    
    VariantClear(&varKey);
    VariantClear(&varT);

    ReleaseAll();
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\export.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       export.h

   Abstract:
       Declarations used by export.cpp and other utility functions that
       support wamreg setup.

   Author:
       Taylor Weiss    ( TaylorW )     08-Mar-1999

   Environment:
       User Mode - Win32

   Project:
       iis\svcs\wam\wamreg

--*/

#ifndef _WAMREG_EXPORT_H_
#define _WAMREG_EXPORT_H_


// 0 = log errors only
// 1 = log errors and warnings
// 2 = log errors, warnings and program flow type statemtns
// 3 = log errors, warnings, program flow and basic trace activity
// 4 = log errors, warnings, program flow, basic trace activity and trace to win32 api calls.
#define LOG_TYPE_ERROR                  0
#define LOG_TYPE_WARN                   1
#define LOG_TYPE_PROGRAM_FLOW           2
#define LOG_TYPE_TRACE                  3
#define LOG_TYPE_TRACE_WIN32_API        4

typedef void (*IIS5LOG_FUNCTION)(int iLogType, WCHAR *pszfmt);

#define CREATECATALOG_TRY_INTERVAL        200
#define CREATECATALOG_MAX_WAIT          10000

//
// Local Declarations supporting setup.
//
extern IIS5LOG_FUNCTION             g_pfnSetupWriteLog;

//
// Macros that collapse a debug and setup trace call. Note these will add code to
// fre builds, the setup tracing is always on.
// 
#if DBG

    #define SETUP_TRACE(args) \
        DBGINFO(args); \
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTrace args ; \
        } else {}

    #define SETUP_TRACE_ERROR(args) \
        DBGINFO(args); \
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTraceError args ; \
        } else {}

    #define SETUP_TRACE_ASSERT( exp ) \
    if ( !(exp) ) { \
            if ( g_pfnSetupWriteLog != NULL ) { \
                 LogSetupTraceError( DBG_CONTEXT, "Assertion Failed: (%s)", #exp ); \
            } \
            PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL ); \
        } else {}

#else   // No debug

    // Defining DBG_CONTEXT in fre build. Since the DBG macros do not 
    // disappear, DBG_CONTEXT needs to be defined.
#ifndef DBG_CONTEXT
    #define DBG_CONTEXT         NULL, __FILE__, __LINE__, __FUNCTION__
#endif

    #define SETUP_TRACE(args) \
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTrace args ; \
        } else {}

    #define SETUP_TRACE_ERROR(args) \
        if ( g_pfnSetupWriteLog != NULL ) { \
            LogSetupTraceError args ; \
        } else {}

    #define SETUP_TRACE_ASSERT( exp ) \
        if ( !(exp) ) { \
            if ( g_pfnSetupWriteLog != NULL ) { \
                 LogSetupTraceError( DBG_CONTEXT, "Assertion Failed: (%s)", #exp ); \
            } \
        } else {}

#endif

VOID
LogSetupTrace(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunction,
   IN const char *         pszFormat,
   ...
   );

VOID
LogSetupTraceError(
   IN LPDEBUG_PRINTS       pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunction,
   IN const char *         pszFormat,
   ...
   );

#endif _WAMREG_EXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\vptool\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\wamadm.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: WamAdm.cpp

	Implementation of WamAdm object, including ClassFactory, IWamAdm,
	IMSAdminReplication

Owner: LeiJin

Note:

WamAdm implementation
===================================================================*/
#include "common.h"
#include "iiscnfg.h"
#include "iwamreg.h"
#include "WamAdm.h"
#include "auxfunc.h"
#include "wmrgexp.h"
#include "dbgutil.h"
#include "mtxrepl.h"

#ifdef _IIS_6_0
#include "string.hxx"
#include "multisz.hxx"
#include "w3ctrlps.h"
#include "iiscnfgp.h"
#include "helpfunc.hxx"
#endif // _IIS_6_0

#define ReleaseInterface(p) if (p) { p->Release(); p = NULL; }

const LPCWSTR APPPOOLPATH = L"/LM/W3SVC/AppPools/";

#ifndef DBGERROR
#define DBGERROR(args) ((void)0) /* Do Nothing */
#endif
#ifndef DBGWARN
#define DBGWARN(args) ((void)0) /* Do Nothing */
#endif

/////////////////////////////////////////////////////////////////////////////
// CWamAdmin

/*===================================================================
CWamAdmin

Constructor

Parameter:
NONE.

Return:
===================================================================*/
CWamAdmin::CWamAdmin()
:	m_cRef(1)
{
    InterlockedIncrement((long *)&g_dwRefCount);
}

/*===================================================================
~CWamAdmin

Constructor

Parameter:
NONE.

Return:
===================================================================*/
CWamAdmin::~CWamAdmin()
{
    InterlockedDecrement((long *)&g_dwRefCount);
}

/*===================================================================
CWamAdmin::QueryInterface

QueryInterface, CWamAdmin supports 2 interfaces, one is IID_IWamAdmin,
the other is IID_IMSAdminReplication.

Parameter:
riid
ppv		pointer to Interface pointer


Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWamAdmin)
    {
        *ppv = static_cast<IWamAdmin*>(this);
    }
    else if (riid == IID_IWamAdmin2)
    {
        *ppv = static_cast<IWamAdmin2*>(this);
    }
    else if (riid == IID_IMSAdminReplication)
    {
        *ppv = static_cast<IMSAdminReplication*>(this);
    }
#ifdef _IIS_6_0
    else if (riid == IID_IIISApplicationAdmin)
    {
        *ppv = static_cast<IIISApplicationAdmin*>(this);
    }
#endif //_IIS_6_0
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return NOERROR;
}

/*===================================================================
CWamAdmin::AddRef


Parameter:
	NONE

Return:	HRESULT
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdmin::AddRef( )
{
    return InterlockedIncrement(&m_cRef);
}

/*===================================================================
CWamAdmin::Release


Parameter:
	NONE

Return:	HRESULT
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdmin::Release( )
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if ( 0 == cRef )
    {
        delete this;
    }

    return cRef;
}


/*===================================================================
CWamAdmin::AppCreate

Create an application on szMDPath.  The fInProc indicates whether the
result application is in-proc or out-proc.  If There is already an application
existed on szMDPath, AppCreate will remove the old application if fInProc does not
match with existing application.  Otherwise, it is no-op.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fInProc		TRUE if wants to have an InProc application,
			FALSE if wants to have an outproc application.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppCreate(LPCWSTR szMDPath, BOOL fInProc)
{
    DWORD dwAppMode = (fInProc) ?
                    eAppRunInProc : eAppRunOutProcIsolated;

    return AppCreate2(szMDPath, dwAppMode);
}

/*===================================================================
CWamAdmin::AppDelete

Delete an application on a Metabase Path.  If there is no application existed
before, it is no-op.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to delete applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppDelete(LPCWSTR szMDPath, BOOL fRecursive)
{
    return PrivateDeleteApplication(szMDPath,
                                    fRecursive,
                                    FALSE,   // Recoverable?
                                    TRUE);  // RemoveAppPool?
}

HRESULT
CWamAdmin::PrivateDeleteApplication
(
LPCWSTR szMDPath,
BOOL fRecursive,
BOOL fRecoverable,
BOOL fRemoveAppPool
)
{
    HRESULT hr = NOERROR;
    DWORD	dwAppMode;
    WamRegMetabaseConfig    MDConfig;
    LPWSTR pwszFormattedPath = NULL;

    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Refer to function comment of FormatMetabasePath.
    //
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        return hr;
    }

    if (!g_WamRegGlobal.FAppPathAllowConfig(pwszFormattedPath))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    if (!fRecursive)
    {
        hr = g_WamRegGlobal.DeleteApp(pwszFormattedPath, fRecoverable, fRemoveAppPool);

        if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
            hr = NOERROR;
        }

        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to Delete on path %S, hr = %08x\n",
                szMDPath,
                hr));
        }

    }
    else
    {
        HRESULT hrT = NOERROR;
        DWORD dwSizePrefix;
        WCHAR* pbBufferTemp = NULL;
        DWORD dwBufferSizeTemp = 0;

        dwSizePrefix = wcslen(pwszFormattedPath);

        hr = MDConfig.MDGetPropPaths(pwszFormattedPath, MD_APP_ISOLATED, &pbBufferTemp, &dwBufferSizeTemp);

        if (SUCCEEDED(hr) && pbBufferTemp)
        {
            WCHAR*	pszString = NULL;
            WCHAR*	pszMetabasePath = NULL;

            for (pszString = (LPWSTR)pbBufferTemp;
            *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1))
            {
                hr = g_WamRegGlobal.ConstructFullPath(pwszFormattedPath,
                    dwSizePrefix,
                    pszString,
                    &pszMetabasePath
                    );
                if (SUCCEEDED(hr))
                {
                    if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {
                        hr = g_WamRegGlobal.DeleteApp(pszMetabasePath, fRecoverable, fRemoveAppPool);

                        if (FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "Failed to Delete on path %S, hr = %08x\n",
                                pszString,
                                hr));
                            break;
                        }
                    }

                    delete [] pszMetabasePath;
                    pszMetabasePath = NULL;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Failed to DeleteRecoverable, hr = %08x\n",
                        pszString,
                        hr));
                }
            }

            delete [] pbBufferTemp;
            pbBufferTemp = NULL;
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "Delete: GetPropPaths failed hr = %08x\n", hr));
        }
    }

    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();

    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }

    return hr;
}


/*===================================================================
CWamAdmin::AppUnLoad

UnLoad an application on a Metabase Path.  If there is no application running
it returns NOERROR.

For non-administrators we prevent them from unloading applications
in the pool. If the recursive flag is set, we will silently
ignore failures due to insufficient access.

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to unload applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppUnLoad(LPCWSTR szMDPath, BOOL fRecursive)
{
    HRESULT                 hr = NOERROR;
    DWORD                   dwCallBack = 0;
    WamRegMetabaseConfig    MDConfig;
    DWORD                   dwAppIsolated = 0;
    BOOL                    bIsAdmin = TRUE;

    if (szMDPath == NULL || *szMDPath == L'\0')
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    bIsAdmin = MDConfig.HasAdminAccess();

#ifdef _IIS_6_0
    DWORD dwMode;
    hr = GetProcessMode(&dwMode);
    if (FAILED(hr))
    {
        return hr;
    }
#endif //_IIS_6_0

    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    if (fRecursive)
    {
        DWORD       dwSizePrefix = wcslen(szMDPath);;
        WCHAR*      pbBufferTemp = NULL;
        DWORD       dwBufferSizeTemp = 0;

        hr = MDConfig.MDGetPropPaths( szMDPath,
            MD_APP_ISOLATED,
            &pbBufferTemp,
            &dwBufferSizeTemp);

        if (SUCCEEDED(hr))
        {
            WCHAR*	pszString = NULL;
            WCHAR*	pszMetabasePath = NULL;
            BOOL    bDoUnload;

            for( pszString = (LPWSTR)pbBufferTemp;
            *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1))
            {
                bDoUnload = TRUE;

                hr = g_WamRegGlobal.ConstructFullPath(szMDPath,
                    dwSizePrefix,
                    pszString,
                    &pszMetabasePath
                    );

                if( SUCCEEDED(hr) && !bIsAdmin )
                {
                    hr = MDConfig.MDGetDWORD( pszMetabasePath,
                        MD_APP_ISOLATED,
                        &dwAppIsolated );

                    DBG_ASSERT( SUCCEEDED(hr) );
                    if( SUCCEEDED(hr) && eAppRunOutProcInDefaultPool == dwAppIsolated )
                    {
                        // Do not unload
                        bDoUnload = FALSE;
                        DBGPRINTF((DBG_CONTEXT,
                            "Insufficient Access to unload Application %S, hr = %08x\n",
                            pszMetabasePath,
                            hr));
                    }
                }

#ifdef _IIS_6_0
                if ( 1 == dwMode )
                {
                    // we are in new mode on IIS6
                    RecycleAppPoolContainingApp(pszMetabasePath);
                }
                // otherwise we are in old mode, therefore use the old mode code, below
                else
#endif //_IIS_6_0
                if( SUCCEEDED(hr) && bDoUnload )
                {
                    hr = g_WamRegGlobal.W3ServiceUtil( pszMetabasePath,
                        APPCMD_UNLOAD,
                        &dwCallBack);
                }

                if( pszMetabasePath )
                {
                    delete [] pszMetabasePath;
                    pszMetabasePath = NULL;
                }
            } // for each application
        }
        if (pbBufferTemp != NULL)
        {
            delete [] pbBufferTemp;
            pbBufferTemp = NULL;
        }
    }
    else
    {
        if( !bIsAdmin )
        {
            // Non recursive
            hr = MDConfig.MDGetDWORD( szMDPath,
                MD_APP_ISOLATED,
                &dwAppIsolated );

            if( SUCCEEDED(hr) && eAppRunOutProcInDefaultPool == dwAppIsolated )
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                DBGPRINTF((DBG_CONTEXT,
                    "Insufficient Access to unload Application %S, hr = %08x\n",
                    szMDPath,
                    hr));
            }
        }

#ifdef _IIS_6_0
        if ( 1 == dwMode )
        {
            // we are in new mode on IIS6
            RecycleAppPoolContainingApp(szMDPath);
        }
        // otherwise we are in old mode, therefore use the old mode code, below
        else
#endif //_IIS_6_0

        if( SUCCEEDED(hr) )
        {
            hr = g_WamRegGlobal.W3ServiceUtil(szMDPath, APPCMD_UNLOAD, &dwCallBack);
        }
    }

    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();

    return hr;
}

/*===================================================================
CWamAdmin::AppGetStatus

GetStatus an application on a Metabase Path.  If there is an application on the
metabase path, and the application is currently running, the dwStatus is set to
APPSTATUS_RUNNING, if the application is not running, the dwStatus is set to
APPSTATUS_STOPPED, if there is no application defined on the metabase path, the
dwStatus is set to APPSTATUS_NOTDEFINED.

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
pdwAppStatus	pointer DWORD buffer contains status result.

Return:	HRESULT
NOERROR	if succeeded.
===================================================================*/
STDMETHODIMP CWamAdmin::AppGetStatus(LPCWSTR szMDPath, DWORD* pdwAppStatus)
{
    HRESULT hr = NOERROR;
    HRESULT hrT;
    DWORD	dwCallBack = 0;
    WamRegMetabaseConfig    MDConfig;

    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    hrT = g_WamRegGlobal.W3ServiceUtil(szMDPath, APPCMD_GETSTATUS, &dwCallBack);
    if (dwCallBack == APPSTATUS_Running)
    {
        *pdwAppStatus = APPSTATUS_RUNNING;
    }
    else if (dwCallBack ==  APPSTATUS_Stopped)
    {
        *pdwAppStatus = APPSTATUS_STOPPED;
    }
    else
    {
        DWORD dwAppMode;
        hr = MDConfig.MDGetDWORD(szMDPath, MD_APP_ISOLATED, &dwAppMode);
        if (hr == MD_ERROR_DATA_NOT_FOUND)
        {
            *pdwAppStatus = APPSTATUS_NOTDEFINED;
            hr = NOERROR;
        }
        else if (hr == NOERROR)
        {
            *pdwAppStatus = APPSTATUS_STOPPED;
            hr = NOERROR;
        }
    }

    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();

    return hr;
}


/*===================================================================
CWamAdmin::AppDeleteRecoverable

Delete an application on a Metabase Path.  If there is no application existed
before, it is no-op.  It leaves AppIsolated untouched, because, this value is
needed in Recover operation.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to deleteRecoverable applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppDeleteRecoverable(LPCWSTR szMDPath, BOOL fRecursive)
{
    return PrivateDeleteApplication(szMDPath,
                                    fRecursive,
                                    TRUE,   // Recoverable?
                                    FALSE); // RemoveAppPool?
}

/*===================================================================
CWamAdmin::AppRecover

Recover an application on a Metabase Path.  Based on the AppIsolated value
on the metabase path, this function recreates an application.


Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to Recover applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::AppRecover(LPCWSTR szMDPath, BOOL fRecursive)
{
    HRESULT hr = NOERROR;
    WamRegMetabaseConfig    MDConfig;
    LPWSTR  pwszFormattedPath = NULL;

    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // Refer to function comment.
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        return hr;
    }
    //
    //	Grab the Lock
    //
    g_WamRegGlobal.AcquireAdmWriteLock();

    if (fRecursive)
    {
        DWORD dwSizePrefix;
        WCHAR*	pbBufferTemp = 0;
        DWORD	dwBufferSizeTemp;

        dwSizePrefix = wcslen(pwszFormattedPath);

        hr = MDConfig.MDGetPropPaths(pwszFormattedPath, MD_APP_ISOLATED, &pbBufferTemp, &dwBufferSizeTemp);
        if (SUCCEEDED(hr) && pbBufferTemp)
        {
            WCHAR *pszString = NULL;
            WCHAR *pszMetabasePath = NULL;

            for (pszString = (LPWSTR)pbBufferTemp;
            *pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1))
            {
                hr = g_WamRegGlobal.ConstructFullPath(pwszFormattedPath,
                    dwSizePrefix,
                    pszString,
                    &pszMetabasePath
                    );
                if (SUCCEEDED(hr))
                {
                    if (!g_WamRegGlobal.FIsW3SVCRoot(pszMetabasePath))
                    {
                        hr = g_WamRegGlobal.RecoverApp(pszMetabasePath, TRUE);

                        if (FAILED(hr))
                        {
                            DBGPRINTF((DBG_CONTEXT, "Failed to Recover on path %S, hr = %08x\n",
                                pszMetabasePath,
                                hr));
                            break;
                        }
                    }

                    delete [] pszMetabasePath;
                    pszMetabasePath = NULL;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Failed to Recover, hr = %08x\n",
                        pszString,
                        hr));
                }
            }
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "Recover: GetPropPaths failed hr = %08x\n", hr));
        }

        if (pbBufferTemp != NULL)
        {
            delete [] pbBufferTemp;
            pbBufferTemp = NULL;
        }
    }
    else
    {
       	hr = g_WamRegGlobal.RecoverApp(pwszFormattedPath, TRUE);

        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to Recover on path %S, hr = %08x\n",
                szMDPath,
                hr));
        }

    }

    if (SUCCEEDED(hr))
    {
        MDConfig.SaveData();
    }
    //
    //	Release the Lock
    //
    g_WamRegGlobal.ReleaseAdmWriteLock();

    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }

    return hr;
}

/*==================================================================
CWamAdmin::AppCreate2

Create an application on szMDPath.  The dwAppMode indicates whether the
result application is in-proc or out-proc in a default pool or out proc isolated.
If the application exists with the desired mode, it will be a no op.  Otherwise,
registration is done.

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
dwAppMode
Return:	HRESULT
===================================================================*/
STDMETHODIMP CWamAdmin::AppCreate2(LPCWSTR szMDPath, DWORD dwAppModeIn)
{

    HRESULT hr = NOERROR;
    DWORD	dwAppMode = 0;
    BOOL	fCreateNewApp = FALSE;
    BOOL	fDeleteOldApp = FALSE;
    WamRegMetabaseConfig    MDConfig;
    LPWSTR  pwszFormattedPath = NULL;

    if (szMDPath == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // See FormatMetabasePath comment
    //
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        return hr;
    }

    if (!g_WamRegGlobal.FAppPathAllowConfig(pwszFormattedPath))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    hr = MDConfig.MDGetDWORD(pwszFormattedPath, MD_APP_ISOLATED, &dwAppMode);
    if (hr == MD_ERROR_DATA_NOT_FOUND)
    {
        fCreateNewApp = TRUE;
        hr = NOERROR;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        hr = MDConfig.MDCreatePath(NULL, pwszFormattedPath);
        fCreateNewApp = TRUE;

        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to create metabase path %S, hr = %08x",
                szMDPath,
                hr));
        }
    }
    else if (SUCCEEDED(hr))
    {
        //
        // if the input application mode is not the same as defined
        // in the metabase, we need to delete the old application as
        // defined in the metabase and create a new application as
        // specified by dwAppModeIn, the in parameter.
        //
        if (dwAppMode != dwAppModeIn)
        {
            fDeleteOldApp = TRUE;
            fCreateNewApp = TRUE;
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to get DWORD on metabase path %S, hr = %08x",
            szMDPath,
            hr));
    }

    if (SUCCEEDED(hr))
    {
        if (fDeleteOldApp)
        {
            DBG_ASSERT(fCreateNewApp);
            hr = g_WamRegGlobal.DeleteApp(pwszFormattedPath, FALSE, FALSE);
            if (FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failed to delete old application on path %S, hr = 08x\n",
                    szMDPath,
                    hr));
            }
        }

        if (fCreateNewApp)
        {
            if (dwAppModeIn == eAppRunOutProcInDefaultPool)
            {
                hr = g_WamRegGlobal.CreatePooledApp(pwszFormattedPath, FALSE);
            }
            else if (dwAppModeIn == eAppRunInProc)
            {
                hr = g_WamRegGlobal.CreatePooledApp(pwszFormattedPath, TRUE);
            }
            else
            {
                hr = g_WamRegGlobal.CreateOutProcApp(pwszFormattedPath);
            }

            if (FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failed to create new application on path %S, hr = 08x\n",
                    szMDPath,
                    hr));
            }
        }
    }

    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();

    //
    // if pwszFormattedPath is not same as szMDPath
    // then FormatMetabasePath() did a memory allocation.
    //
    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }

    return hr;
}

//===============================================================================
//	Wam Admin Replication implementation
//
//===============================================================================

/*===================================================================
CWamAdmin::GetSignature

Get signature of application configurations.  A signature in WAMREG is a checksum from
all the metabase paths that define application.

Parameter:


Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::GetSignature
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
/* [out */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
)
{
	HRESULT hr = NOERROR;
	WCHAR	*pbBufferTemp = NULL;
	DWORD	dwBufferSizeTemp = 0;
	DWORD	dwSignature = 0;
	DWORD	dwRequiredSize = 0;
	WamRegMetabaseConfig    MDConfig;
	//
	//	Grab the Lock
	//
	g_WamRegGlobal.AcquireAdmWriteLock();

	hr = MDConfig.MDGetPropPaths(WamRegGlobal::g_szMDW3SVCRoot, MD_APP_ISOLATED, &pbBufferTemp, &dwBufferSizeTemp);
	if (SUCCEEDED(hr))
		{
		WCHAR *pszString = NULL;
		WCHAR *pszMetabasePath = NULL;
        DWORD dwSignatureofPath = 0;

        for (pszString = (LPWSTR)pbBufferTemp;
			*pszString != (WCHAR)'\0' && SUCCEEDED(hr);
            pszString += (wcslen(pszString) + 1))
        	{
            dwRequiredSize += sizeof(DWORD);

            if (dwRequiredSize <= dwBufferSize)
                {
				hr = g_WamRegGlobal.ConstructFullPath(WamRegGlobal::g_szMDW3SVCRoot,
										WamRegGlobal::g_cchMDW3SVCRoot,
										pszString,
										&pszMetabasePath
										);
				if (SUCCEEDED(hr))
					{
					dwSignatureofPath = 0;
		            hr = MDConfig.GetSignatureOnPath(pszMetabasePath, &dwSignatureofPath);
		            if (SUCCEEDED(hr))
		            	{
		            	// Add Signature
		            	*(DWORD*)pbBuffer = dwSignatureofPath;
		            	pbBuffer += sizeof(DWORD);

						DBGPRINTF((DBG_CONTEXT, "Get Signature on path %S, signature = %08x\n",
							pszMetabasePath,
							dwSignatureofPath));
		            	}
		            else
		            	{
		            	DBGPRINTF((DBG_CONTEXT, "Failed to get signature on path %S, hr = %08x\n",
		            		pszString,
		            		hr));
						DBG_ASSERT(hr);
		            	}

					delete [] pszMetabasePath;
					pszMetabasePath = NULL;
		            }
		        }
            }

		if (dwRequiredSize > dwBufferSize)
			{
			*pdwMDRequiredBufferSize = dwRequiredSize;
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			}
		}
	else
		{
		DBGPRINTF((DBG_CONTEXT, "GetSignature: GetPropPaths failed hr = %08x\n", hr));
		}

	if (SUCCEEDED(hr))
		{
		*pdwMDRequiredBufferSize = dwRequiredSize;
		}

	if (pbBufferTemp != NULL)
		{
		delete [] pbBufferTemp;
		}
	//
	//	Release the Lock
	//
	g_WamRegGlobal.ReleaseAdmWriteLock();

	return hr;
}


/*===================================================================
CWamAdmin::Propagate

Unused in WAMREG. NOOP.

Parameter:


Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::Propagate
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer
)
{
	return NOERROR;
}

/*===================================================================
CWamAdmin::Propagate2

This function is called after IIS replication, and triggers MTS to start
replication pakcages, it calls IISComputerToComputer.

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::Propagate2
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
/* [in] */ DWORD dwSignatureMismatch
)
{
    //
    // IISComputerToComputer can not be called from inetinfo.exe, because IISComputerToComputer will
    // make cross-machine RPC call, and inetinfo is set to Local system, therefore, IISComputerToComputer
    // will fail at the authentication level.
    // move IISComputerToComputer to iissync.exe. Where iissync.exe has some user account & password.
    //
	return NOERROR;

}

/*===================================================================
CWamAdmin::Serialize

This function packs all neccessary infomation (path + WAMCLSID) for a target
machine to prepare replication(DeSerialize).

The only applications that we really care about are isolated applications.
We need the path + WAMCLSID + APPID.

CODEWORK

See NT Bug 378371

Replication of IIS COM+ applications has been broken for a long time
but the all of the fixes I considered have some serious drawbacks.

1. Don't use comrepl to move the IIS applications. Serialize/Deserialize
all the data needed to create the isolated applications and then delete
and recreate them on the target. The problem here is that the packages
may in fact be modified by the user and these modifications should be
preserved.

2. Use comrepl as it is and replicate the IWAM_* account. This seems like
a bad idea. The IWAM_ account should ideally never exist on multiple
machines. Another issue is handling the password and account privileges.

3. Use a modified comrepl (or let comrepl fail and leave the package identity
as "interactive user"). Then do a fixup of the activation identity.
This doesn't work, because the Propogate/Propogate2 protocol is
essentially useless. Changing this protocol on the next release
is absolutely something that should be considered, although AppCenter
probably makes it a moot point.

The current implementation is option 1.

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::Serialize
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
/* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
)
{
	HRESULT hr = NOERROR;
	WCHAR	*pbBufferTemp = NULL;
	DWORD	dwBufSizePath = 0;
	DWORD	dwSizeForReturn = sizeof(DWORD);
	WamRegMetabaseConfig    MDConfig;

	//
	//	Grab the Lock
	//
	g_WamRegGlobal.AcquireAdmWriteLock();

	hr = MDConfig.MDGetPropPaths( WamRegGlobal::g_szMDW3SVCRoot,
                                  MD_APP_WAM_CLSID,
                                  &pbBufferTemp,
                                  &dwBufSizePath
                                  );
	if (SUCCEEDED(hr))
    {
        WCHAR   *pszString = NULL;
        WCHAR   *pszMetabasePath = NULL;
        WCHAR   *pszAppName = NULL;
        WCHAR   szWAMCLSID[uSizeCLSID];
        WCHAR   szAppId[uSizeCLSID];
        DWORD   dwSizeofRecord;
        DWORD   cSizeMetabasePath = 0;
        DWORD   cSizeAppName = 0;
        DWORD   dwAppIsolated;


		for( pszString = (LPWSTR)pbBufferTemp;
			 *pszString != (WCHAR)'\0';
             pszString += (wcslen(pszString) + 1))
        {
            // Clean up allocations
            if( pszMetabasePath != NULL )
            {
                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
            }

            if( pszAppName != NULL )
            {
                delete [] pszAppName;
                pszAppName = NULL;
            }

            hr = g_WamRegGlobal.ConstructFullPath(
                        WamRegGlobal::g_szMDW3SVCRoot,
                        WamRegGlobal::g_cchMDW3SVCRoot,
                        pszString,
                        &pszMetabasePath
                        );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT,
                           "ConstructFullPath failed for base (%S) "
                           "partial (%S) hr=%08x\n",
                           WamRegGlobal::g_szMDW3SVCRoot,
                           pszString,
                           hr
                           ));
                break;
            }

            if( g_WamRegGlobal.FIsW3SVCRoot( pszMetabasePath ) )
            {
                // Don't consider the root application
                continue;
            }

            hr = MDConfig.MDGetDWORD( pszMetabasePath,
                                      MD_APP_ISOLATED,
                                      &dwAppIsolated
                                      );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT,
                           "Failed to get MD_APP_ISOLATED, hr=%08x\n",
                           hr
                           ));
                break;
            }

            if( dwAppIsolated != eAppRunOutProcIsolated )
            {
                // Don't consider non-isolated applications
                continue;
            }

	        hr = MDConfig.MDGetIDs( pszMetabasePath,
                                    szWAMCLSID,
                                    szAppId,
                                    dwAppIsolated
                                    );
            if( FAILED(hr) )
            {
				DBGERROR(( DBG_CONTEXT,
                           "Failed to get IDs for %S, hr = %08x\n",
					       pszMetabasePath,
					       hr
                           ));
				break;
            }

            hr = MDConfig.MDGetAppName( pszMetabasePath,
                                        &pszAppName
                                        );
            if( FAILED(hr) )
            {
				DBGERROR(( DBG_CONTEXT,
                           "Failed to get AppName for %S, hr = %08x\n",
					       pszMetabasePath,
					       hr
                           ));
				break;
            }

            cSizeMetabasePath = wcslen(pszMetabasePath) + 1;
            cSizeAppName = wcslen(pszAppName) + 1;
            dwSizeofRecord = sizeof(DWORD) +
                             ((2 * uSizeCLSID) * sizeof(WCHAR)) +
                             (cSizeMetabasePath * sizeof(WCHAR)) +
                             (cSizeAppName * sizeof(WCHAR));

            dwSizeForReturn += dwSizeofRecord;

            if (dwSizeForReturn <= dwBufferSize)
            {
                // Size
                *(DWORD *)pbBuffer = dwSizeofRecord;
                pbBuffer += sizeof(DWORD);

                // WAMCLSID
                memcpy( pbBuffer, szWAMCLSID, sizeof(WCHAR) * uSizeCLSID );
                pbBuffer += sizeof(WCHAR) * uSizeCLSID;

                // APPID
                memcpy( pbBuffer, szAppId, sizeof(WCHAR) * uSizeCLSID );
                pbBuffer += sizeof(WCHAR) * uSizeCLSID;

                // PATH
                memcpy( pbBuffer, pszMetabasePath, cSizeMetabasePath * sizeof(WCHAR) );
                pbBuffer += cSizeMetabasePath * sizeof(WCHAR);

                // APPNAME
                memcpy( pbBuffer, pszAppName, cSizeAppName * sizeof(WCHAR) );
                pbBuffer += cSizeAppName * sizeof(WCHAR);
            }
        }

        if (SUCCEEDED(hr))
        {
            if (dwSizeForReturn <= dwBufferSize)
            {
                *(DWORD*)pbBuffer = 0x0;    // Ending Signature
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            *pdwMDRequiredBufferSize = dwSizeForReturn;
		}

        // Clean up allocations
        if( pszMetabasePath != NULL )
        {
            delete [] pszMetabasePath;
            pszMetabasePath = NULL;
        }

        if( pszAppName != NULL )
        {
            delete [] pszAppName;
            pszAppName = NULL;
        }

    }
	else
    {
        DBGERROR(( DBG_CONTEXT,
                   "Serialize: GetPropPaths failed hr = %08x\n",
                   hr
                   ));
    }

	//
	//	Release the Lock
	//
	g_WamRegGlobal.ReleaseAdmWriteLock();

	if (pbBufferTemp)
    {
        delete [] pbBufferTemp;
    }

	return hr;
}


/*===================================================================
CWamAdmin::DeSerialize

This function unpacks all neccessary infomation (path + WAMCLSID) on a target
machine to prepare replication(DeSerialize).

The only applications that we really care about with replication are
isolated apps. This routine removes the existing out of process apps
and then recreates the applications that are sent over in pbBuffer.

CODEWORK - See comments in Serialize

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdmin::DeSerialize
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pbBuffer
)
{
	DWORD dwBufferSizeTemp= 0;
	WCHAR* pbBufferTemp = NULL;
	HRESULT hr = NOERROR;
    WamRegMetabaseConfig    MDConfig;

	g_WamRegGlobal.AcquireAdmWriteLock();

	hr = MDConfig.MDGetPropPaths( WamRegGlobal::g_szMDW3SVCRoot,
                                  MD_APP_WAM_CLSID,
                                  &pbBufferTemp,
                                  &dwBufferSizeTemp
                                  );
	if (SUCCEEDED(hr))
    {
        //
        // Remove all the existing isolated applications.
        //

        WCHAR * pszString = NULL;
		WCHAR * pszMetabasePath = NULL;
        DWORD   dwAppIsolated;

		for (   pszString = (LPWSTR)pbBufferTemp;
				*pszString != (WCHAR)'\0';
                pszString += (wcslen(pszString) + 1))
        {
            if( pszMetabasePath != NULL )
            {
                delete [] pszMetabasePath;
                pszMetabasePath = NULL;
            }

            hr = g_WamRegGlobal.ConstructFullPath(
                    WamRegGlobal::g_szMDW3SVCRoot,
					WamRegGlobal::g_cchMDW3SVCRoot,
					pszString,
					&pszMetabasePath
					);

            if( FAILED(hr) )
            {
                // This failure is fatal
                DBGERROR(( DBG_CONTEXT,
                           "ConstructFullPath failed for base (%S) "
                           "partial (%S) hr=%08x\n",
                           WamRegGlobal::g_szMDW3SVCRoot,
                           pszString,
                           hr
                           ));
                break;
            }

			hr = MDConfig.MDGetDWORD( pszMetabasePath,
                                      MD_APP_ISOLATED,
                                      &dwAppIsolated
                                      );
            if( FAILED(hr) )
            {
                DBGWARN(( DBG_CONTEXT,
                          "Failed to get MD_APP_ISOLATED at (%S) hr=%08x\n",
                          pszMetabasePath,
                          hr
                          ));

                hr = NOERROR;
                continue;
            }

            if( dwAppIsolated == eAppRunOutProcIsolated )
            {
			    hr = g_WamRegGlobal.DeleteApp( pszMetabasePath, FALSE, FALSE );
			    if (FAILED(hr))
                {
				    DBGWARN(( DBG_CONTEXT,
                              "Unable to delete app at %S, hr = %08x\n",
					          pszMetabasePath,
                              hr
                              ));

                    hr = NOERROR;
                    continue;
                }
            }
        }
        if( pszMetabasePath != NULL )
        {
            delete [] pszMetabasePath;
            pszMetabasePath = NULL;
        }
    }

    //
    // Now go through the serialized data and create the
    // necessary new applications.
    //

    BYTE  * pbTemp = pbBuffer;
    DWORD   cTotalBytes = 0;
    DWORD   cRecBytes = 0;
    WCHAR * szWAMCLSID = NULL;
    WCHAR * szPath = NULL;
    WCHAR * szAppId = NULL;
    WCHAR * szAppName = NULL;

    DBGPRINTF(( DBG_CONTEXT,
                "DeSerialize: buffer size %d, \n",
				dwBufferSize
                ));

    while( *((DWORD*)pbTemp) != 0x0 )
    {
		// SIZE
        cRecBytes = *((DWORD*)pbTemp);
		pbTemp += sizeof(DWORD);

		// CLSID
        szWAMCLSID = (WCHAR *)pbTemp;
		pbTemp += uSizeCLSID * sizeof(WCHAR);

        // APPID
        szAppId = (WCHAR *)pbTemp;
        pbTemp += uSizeCLSID * sizeof(WCHAR);

		// PATH
        szPath = (WCHAR *)pbTemp;
		pbTemp += (wcslen(szPath) + 1) * sizeof(WCHAR);

        // APPNAME
        szAppName = (WCHAR *)pbTemp;
        pbTemp += (wcslen(szAppName) + 1) * sizeof(WCHAR);

		// TODO - This should really be output based on a flag
        DBGPRINTF(( DBG_CONTEXT,
                    "Deserialize path = %S, WAMCLSID = %S.\n",
					szPath,
					szWAMCLSID
                    ));

		// Should never serialize the w3svc root
        DBG_ASSERT( !g_WamRegGlobal.FIsW3SVCRoot(szPath) );


        hr = g_WamRegGlobal.CreateOutProcAppReplica( szPath,
                                                     szAppName,
                                                     szWAMCLSID,
                                                     szAppId
                                                     );

        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed to create COM application. Path(%S) "
                       "Clsid(%S) AppId(%S). hr=%08x\n",
                       szPath,
                       szWAMCLSID,
                       szAppId,
                       hr
                       ));

            // ??? Should we be continuing here ???
            // Don't report an error if we are continuing
            hr = NOERROR;
        }
    }

	if (pbBufferTemp)
    {
        delete [] pbBufferTemp;
    }

	//
	//	Release the Lock
	//
	g_WamRegGlobal.ReleaseAdmWriteLock();

	return hr;
}

/*===================================================================
CWamAdmin::FormatMetabasePath

This function format the input metabase path.  If the metabase path has an
ending '/', this function will allocate a memory block and make a new string
without the ending '/'.  This function will return a pointer to newly allocated
memory block.  Otherwise, the function will return the pointer to
the input metabase path.

Parameter:
pwszMetabasePathIn   input metabase path
ppwszMetabasePathOut pointer to the resulting pointer that contains the formatted
                     metabase path.

Return:	HRESULT
NOERROR	if succeeds

NOTE: if ppwszMetabasePathOut == pwszMetabasePathIn, then no memory allocation.
      Otherwise, there is a memory allocation happened, and caller needs to free the
      memory block passed out in ppwszMetabasePathOut.
===================================================================*/
STDMETHODIMP CWamAdmin::FormatMetabasePath
(
/* [in] */ LPCWSTR pwszMetabasePathIn,
/* [out] */ LPWSTR *ppwszMetabasePathOut
)
{
    HRESULT hr = NOERROR;
    LPWSTR  pResult = NULL;

    DBG_ASSERT(pwszMetabasePathIn);
    DBG_ASSERT(ppwszMetabasePathOut);

    LONG    cch = wcslen(pwszMetabasePathIn);

    if (pwszMetabasePathIn[cch-1] == L'\\' ||
        pwszMetabasePathIn[cch-1] == L'/')
        {
        //
        //  Need to start up with a new string, can not do it with old string.
        //
        pResult = new WCHAR[cch];
        if (pResult != NULL)
            {
            wcsncpy(pResult, pwszMetabasePathIn, cch);
            pResult[cch-1] = L'\0';
            }
        else
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT, "FormatMetabasePath, failed to allocate memory. hr = %08x\n",
                hr));
            }

        if (pResult != NULL)
            {
            *ppwszMetabasePathOut = pResult;
            }
        }
    else
        {
        *ppwszMetabasePathOut = (LPWSTR)pwszMetabasePathIn;
        }

    return hr;
}

//===============================================================================
//
//	IIISApplicationAdmin implementation
//
//===============================================================================

#ifdef _IIS_6_0

/*===================================================================
DoesAppPoolExist

Determine whether the AppPool passed exists

Parameter:
szAppPoolId     a AppPoolId
pfRet           where to place whether or not the appPool exists

Return:	HRESULT
===================================================================*/
HRESULT
DoesAppPoolExist
(
 LPCWSTR szAppPoolId,
 BOOL * pfRet
)
{
    DBG_ASSERT(pfRet);
    WamRegMetabaseConfig    MDConfig;

    HRESULT hr = E_FAIL;
    STACK_STRU(szPoolBuf, 64);

    hr = szPoolBuf.Append(APPPOOLPATH);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = szPoolBuf.Append(szAppPoolId);
    if (FAILED(hr))
    {
        goto done;
    }

    (*pfRet) = MDConfig.MDDoesPathExist(NULL, szPoolBuf.QueryStr());

    hr = S_OK;
done:
    return hr;
}

/*===================================================================
CWamAdmin::CreateApplication

Create an application on szMDPath, and add it to szAppPoolId AppPool.
Optionally create szAppPoolId

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
dwAppMode       mode to create application in
szAppPoolId     AppPool to setup app in.
fCreatePool     Whether or not to create the pool

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::CreateApplication
(
 LPCWSTR szMDPath,
 DWORD dwAppMode,
 LPCWSTR szAppPoolId,
 BOOL fCreatePool
)
{
    HRESULT                 hr = S_OK;
    WamRegMetabaseConfig    MDConfig;
    LPWSTR                  pwszFormattedPath = NULL;

    if (NULL == szMDPath)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto done;
    }

    //
    // See FormatMetabasePath comment
    //
    hr = FormatMetabasePath(szMDPath, &pwszFormattedPath);
    if (FAILED(hr))
    {
        goto done;
    }

    // BUGBUG: Do We need locking around all of this?  Why is locking present in other places?

    hr = AppCreate2(pwszFormattedPath, dwAppMode);
    if (FAILED(hr))
    {
        goto done;
    }

    if (FALSE == fCreatePool && NULL == szAppPoolId)
    {
        //
        // We weren't told to create an application pool
        // and NULL was passed as the application pool,
        // therefore do nothing wil the application pool
        //
        hr = S_OK;
        goto done;
    }

    if (TRUE == fCreatePool)
    {
        //
        // create the application pool that we were passed
        //

        hr = CreateApplicationPool(szAppPoolId);
        if (FAILED(hr) &&
            HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
        {
            goto done;
        }
    }
    else
    {
        //
        // We weren't told to create the application pool,
        // but one was passed in.  Verify that it exists.
        //
        DBG_ASSERT(NULL != szAppPoolId);

        BOOL fRet;

        hr = DoesAppPoolExist(szAppPoolId, &fRet);
        if (FAILED(hr))
        {
            goto done;
        }

        if (FALSE == fRet)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            goto done;
        }
    }

    hr = MDConfig.MDSetStringProperty(NULL,
                                      pwszFormattedPath,
                                      MD_APP_APPPOOL_ID,
                                      szAppPoolId,
                                      IIS_MD_UT_SERVER,
                                      METADATA_INHERIT);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    //
    // if pwszFormattedPath is not same as szMDPath
    // then FormatMetabasePath() did a memory allocation.
    //
    if (pwszFormattedPath != szMDPath)
    {
        delete [] pwszFormattedPath;
        pwszFormattedPath = NULL;
    }
    return hr;
}

/*===================================================================
CWamAdmin::DeleteApplication

Delete an application on a Metabase Path.

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."
fRecursive	TRUE if wants to deleteRecoverable applications from all sub nodes of szMDPath,
			FALSE otherwise.

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::DeleteApplication
(
 LPCWSTR szMDPath,
 BOOL fRecursive
)
{
    return PrivateDeleteApplication(szMDPath,
                                    fRecursive,
                                    FALSE, // Recoverable?
                                    TRUE); // RemoveAppPool?
}

/*===================================================================
CWamAdmin::CreateApplicationPool

Delete an application on a Metabase Path.  If there is no application existed
before, it is no-op.  It leaves AppIsolated untouched, because, this value is
needed in Recover operation.


Parameter:
szAppPool       Application Pool to create

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::CreateApplicationPool
(
 LPCWSTR szAppPool
)
{
    HRESULT                 hr = S_OK;
    WamRegMetabaseConfig    MDConfig;

    STACK_STRU(szBuf, 64);

    // Acquire a Lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    if (NULL == szAppPool)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // concatenate the path into a buffer
    hr = szBuf.Append(APPPOOLPATH);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = szBuf.Append(szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = MDConfig.MDCreatePath(NULL, szBuf.QueryStr());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = MDConfig.MDSetKeyType(NULL, szBuf.QueryStr(), L"IIsApplicationPool");
    if (FAILED(hr))
    {
        goto done;
    }

done:
    // Release a Lock
    g_WamRegGlobal.ReleaseAdmWriteLock();

    return hr;
}

/*===================================================================
CWamAdmin::DeleteApplicationPool

Delete an application pool.  First check to see if ApplicationPool is empty.
If not, return ERROR_NOT_EMPTY.  Otherwise, remove apppool.


Parameter:
szAppPool   Application Pool to remove

Return:	HRESULT
===================================================================*/
STDMETHODIMP
CWamAdmin::DeleteApplicationPool
(
 LPCWSTR szAppPool
)
{
    HRESULT     hr = S_OK;
    UINT        cchBstr = 0;
    BOOL        fRet = FALSE;
    BSTR        bstr = NULL;

    WamRegMetabaseConfig    MDConfig;

    // BUGBUG: need locking around this?

    if (NULL == szAppPool)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = DoesAppPoolExist(szAppPool, &fRet);
    if (FAILED(hr))
    {
        goto done;
    }
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto done;
    }

    hr = EnumerateApplicationsInPool(szAppPool, &bstr);
    if (FAILED(hr))
    {
        goto done;
    }

    cchBstr = SysStringLen(bstr);

    // were there two terminating NULLs to be written into out buffer?
    if (!(cchBstr >= 2 && '\0' == bstr[0] && '\0' == bstr[1]))
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_EMPTY);
        goto done;
    }

    hr = MDConfig.MDDeleteKey(NULL, APPPOOLPATH, szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (bstr)
    {
        SysFreeString(bstr);
    }
    return hr;
}


/*===================================================================
DoesBeginWithLMW3SVCNRoot

Determine whether the string passed in starts with
/lm/w3svc/NNNN/root
where NNNN is greater than 0.


Parameter:
pszApp      an metabase application path
pdwCharsAfter   [OPTIONAL] - storage for the number of characters following /root

Return:	BOOL
===================================================================*/
const WCHAR MB_W3SVC[] = L"/lm/w3svc/";
const int LEN_MB_W3SVC = (sizeof(MB_W3SVC) / sizeof(WCHAR)) - 1;
const WCHAR MB_W3SVC_1_ROOT[] = L"/LM/W3SVC/1/ROOT";
const int LEN_MB_W3SVC_1_ROOT = (sizeof(MB_W3SVC_1_ROOT) / sizeof(WCHAR)) - 1;
const WCHAR MB_ROOT[] = L"/Root";
const int LEN_MB_ROOT = (sizeof(MB_ROOT) / sizeof(WCHAR)) - 1;

BOOL
DoesBeginWithLMW3SVCNRoot
(
 LPCWSTR pszApp,
 DWORD * pdwCharsAfter = NULL
)
{
    DBG_ASSERT(pszApp);

    BOOL fRet = FALSE;
    WCHAR pBuf[256] = {0};
    int iSite;

    // must have at least this many characters to have a chance
    if (wcslen(pszApp) < LEN_MB_W3SVC_1_ROOT)
    {
        goto done;
    }

    // Applications must have \lm\w3svc\ at the front
    if (0 != _wcsnicmp(MB_W3SVC, pszApp, LEN_MB_W3SVC))
    {
        goto done;
    }

    // Advance the pointer by enough characters
    pszApp += LEN_MB_W3SVC;

    // _wtoi returns as many characters as possible in a string before hitting a non-number or NULL
    // if there is no number, the return is 0.
    iSite = _wtoi(pszApp);

    // Applications must then have a number that is >=1
    if (0 == iSite)
    {
        goto done;
    }

    // get the count of numbers read from the string
    _itow(iSite, pBuf, 10);

    // advance the pointer by enough characters.
    pszApp += wcslen(pBuf);

    // Applications must them have "/Root"
    if (0 != _wcsnicmp(pszApp, MB_ROOT, LEN_MB_ROOT))
    {
        goto done;
    }

    // if caller wants a count of characters following /Root
    if (pdwCharsAfter)
    {
        // advance the pointer by enough characters
        pszApp += LEN_MB_ROOT;

        // get the remaining length
        *pdwCharsAfter = wcslen(pszApp);
    }

    fRet = TRUE;
done:
    return fRet;
}


/*===================================================================
IsRootApplication

Determine whether the string passed in is of the form:
/lm/w3svc/NNNN/root/
where NNNN is greater than 0.

And no additional characters following

Parameter:
pszApp      an metabase application path

Return:	BOOL
===================================================================*/
BOOL
IsRootApplication
(
 LPCWSTR pszApp
)
{
    DWORD dwCharsAfter = 0;

    // Root applications must begin with /lm/w3svc/nnn/root
    if (!DoesBeginWithLMW3SVCNRoot(pszApp, &dwCharsAfter))
    {
        return FALSE;
    }

    // we expect at most a trailing '/' after /lm/w3svc/nnn/root.
    // If there is more, this was not a root application
    if(1 < dwCharsAfter)
    {
        return FALSE;
    }

    return TRUE;
}

/*===================================================================
IsApplication

Determine whether or not APP_ISOLATED is set at the passed in path

Parameter:
pszApp      an metabase application path
pfIsApp     If this node is an application

Return:	HRESULT
===================================================================*/
HRESULT
IsApplication
(
 LPCWSTR pszApp,
 BOOL *pfIsApp
)
{
    HRESULT hr = S_OK;
    WamRegMetabaseConfig    MDConfig;
    DWORD dwData;
    
    DBG_ASSERT(pfIsApp);
    *pfIsApp = FALSE;

    if ( !DoesBeginWithLMW3SVCNRoot(pszApp) )
    {
        goto done;
    }
    
    hr = MDConfig.MDGetDWORD(pszApp, MD_APP_ISOLATED, &dwData);
    if (HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND) == hr)
    {
        hr = S_OK;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    // MD_APP_ISOLATED was present at this node, not inherited
    *pfIsApp = TRUE;
    
    hr = S_OK;
done:
    return hr;
}

/*===================================================================
IsAppInAppPool

Determine whether the App is in Pool

Parameter:
pszApp      an metabase application path
pszPool     an applicationPool ID

Return:	BOOL
===================================================================*/
BOOL
IsAppInAppPool
(
 LPCWSTR pszApp,
 LPCWSTR pszPool
)
{
    DBG_ASSERT(pszApp);
    DBG_ASSERT(pszPool);
    HRESULT hr = E_FAIL;
    BOOL fRet = FALSE;
    LPWSTR pBuf = NULL;
    WamRegMetabaseConfig    MDConfig;

    hr = MDConfig.MDGetStringAttribute(pszApp, MD_APP_APPPOOL_ID, &pBuf);
    if (FAILED(hr) || NULL == pBuf)
    {
        goto done;
    }

    if (0 == _wcsicmp(pBuf, pszPool))
    {
        fRet = TRUE;
    }

done:
    delete [] pBuf;
    return fRet;
}

/*===================================================================
CWamAdmin::EnumerateApplicationsInPool

Determine what applications are setup to point to the given pool.

Parameter:
szPool      Application Pool enumerate
pbstrBuffer Where to store the pointer to allocated memory for application paths

Return:	HRESULT
  S_OK if buffer filled with a MULTISZ - if empty, double NULL at beginning
===================================================================*/
STDMETHODIMP
CWamAdmin::EnumerateApplicationsInPool
(
 LPCWSTR szPool,
 BSTR*   pbstrBuffer
)
{
    HRESULT                 hr = E_FAIL;
    WamRegMetabaseConfig    MDConfig;
    MULTISZ                 mszApplicationsInPool;

    WCHAR *                 pBuffer = NULL;
    UINT                    cchMulti = 0;
    DWORD                   dwBufferSize = 0;

    if (NULL == szPool ||
        NULL == pbstrBuffer
       )
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pbstrBuffer = NULL;

    // First get all of the root applications
    {
        hr = MDConfig.MDGetAllSiteRoots(&pBuffer);
        if (FAILED(hr))
        {
            goto done;
        }

        const WCHAR * pTestBuf = pBuffer;

        while(pTestBuf && pTestBuf[0])
        {
            DBG_ASSERT(IsRootApplication(pTestBuf));
            if ( IsAppInAppPool(pTestBuf, szPool) )
            {
                if (FALSE == mszApplicationsInPool.Append(pTestBuf))
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }
            }

            // move pTestBuf beyond end of this string, including NULL terminator.
            pTestBuf += wcslen(pTestBuf) + 1;
        }

        delete [] pBuffer;
        pBuffer = NULL;
    }

    // now get any other applications that have APPISOLATED set
    {
        hr = MDConfig.MDGetPropPaths(NULL,
                                     MD_APP_ISOLATED,
                                     &pBuffer,
                                     &dwBufferSize
                                    );
        if (FAILED(hr))
        {
            goto done;
        }

        {
            const WCHAR * pTestBuf = pBuffer;

            while (pTestBuf && pTestBuf[0])
            {
                // root applications have already been added
                // the path needs to be an application
                // and the application needs to be in the app pool
                if ( !IsRootApplication(pTestBuf) &&
                     DoesBeginWithLMW3SVCNRoot(pTestBuf) &&
                     IsAppInAppPool(pTestBuf, szPool) )
                {
                    if (FALSE == mszApplicationsInPool.Append(pTestBuf))
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                }

                // move pTestBuf beyond end of this string, including NULL terminator.
                pTestBuf += wcslen(pTestBuf) + 1;
            }
        }
    }
    
    // now get any keys that have APPPOOLID set
    {
        hr = MDConfig.MDGetPropPaths(NULL,
                                     MD_APP_APPPOOL_ID,
                                     &pBuffer,
                                     &dwBufferSize
                                    );
        if (FAILED(hr))
        {
            goto done;
        }

        {
            const WCHAR * pTestBuf = pBuffer;

            while (pTestBuf && pTestBuf[0])
            {
                BOOL fIsApplication = FALSE;
                
                // root applications have already been added
                // the path needs to be an application
                // and the application needs to be in the app pool
                hr = IsApplication(pTestBuf, &fIsApplication);
                if (FAILED(hr))
                {
                    goto done;
                }
                
                if ( !IsRootApplication(pTestBuf) &&
                     DoesBeginWithLMW3SVCNRoot(pTestBuf) &&
                     !fIsApplication &&
                     IsAppInAppPool(pTestBuf, szPool) )
                {
                    if (FALSE == mszApplicationsInPool.Append(pTestBuf))
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                }

                // move pTestBuf beyond end of this string, including NULL terminator.
                pTestBuf += wcslen(pTestBuf) + 1;
            }
        }
    }

    // have the data in a MULTISZ - move it to the outgoing BSTR
    cchMulti = mszApplicationsInPool.QueryCCH();
    *pbstrBuffer = SysAllocStringLen(NULL, cchMulti);
    if (NULL == *pbstrBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    dwBufferSize = cchMulti;
    mszApplicationsInPool.CopyToBuffer(*pbstrBuffer, &dwBufferSize);

    hr = S_OK;
done:
    delete [] pBuffer;
    pBuffer = NULL;

    return hr;
}

/*===================================================================
QueryW3SVCStatus

Using the ServiceControlManager, determine the current state of W3SVC

pfRunning   return bool value - TRUE if running, otherwise FALSE

Return:	HRESULT
S_OK if able to read status.  HRESULT_FROM_WIN32 error otherwise
===================================================================*/
HRESULT
QueryW3SVCStatus
(
 BOOL * pfRunning
)
{
    DBG_ASSERT(pfRunning);
    *pfRunning = FALSE;

    HRESULT         hr = E_FAIL;
    BOOL            fRet = FALSE;

    SC_HANDLE       hSCM = 0;
    SC_HANDLE       hService = 0;
    SERVICE_STATUS  ssStatus;
    ZeroMemory(&ssStatus, sizeof(ssStatus));

    // first, get the service control manager
    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (NULL == hSCM)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // now get the w3svc service
    hService = OpenService(hSCM, "W3SVC", SERVICE_QUERY_STATUS);
    if (NULL == hService)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // now ask for the status
    fRet = QueryServiceStatus(hService, &ssStatus);
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if (SERVICE_RUNNING == ssStatus.dwCurrentState)
    {
        *pfRunning = TRUE;
    }

    hr = S_OK;
done:
    if (0 != hService)
    {
        CloseServiceHandle(hService);
    }
    if (0 != hSCM)
    {
        CloseServiceHandle(hSCM);
    }

    return hr;
}

/*===================================================================
GetWASIfRunning

Get a pointer to WAS iff w3svc is already running.

ppiW3Control    where to store the addref'ed pointer if it can be gotten

Return:	HRESULT
S_OK if pointer retrieved
HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) if W3SVC is not up
+other error codes
===================================================================*/
HRESULT
GetWASIfRunning
(
 IW3Control ** ppiW3Control
)
{
    DBG_ASSERT(ppiW3Control);
    *ppiW3Control = NULL;

    HRESULT     hr = E_FAIL;

    //
    // Note we used to have to first check if WAS was running
    // before doing this call, to avoid starting it up by accident.
    // However, now that we have fixed the launch permission acl
    // correctly, we no longer need to do this check.  This should
    // explain the name of this procedure.
    //

    hr = CoCreateInstance(CLSID_W3Control,
                          NULL,
                          CLSCTX_ALL,
                          IID_IW3Control,
                          reinterpret_cast<void**>(ppiW3Control));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

/*===================================================================
ValidateAccessToMetabaseKey

Determine whether the caller has write access to the given metabase key

pPath - path to check write access on
dwAccess - access to check for

Return:	HRESULT
S_OK if access allowed
otherwise failure
===================================================================*/
HRESULT
ValidateAccessToMetabaseKey(LPCWSTR pPath, DWORD dwAccess)
{
    HRESULT hr = S_OK;
    IMSAdminBase * pIMSAdminBase = NULL;
    METADATA_HANDLE hMB = NULL;
    METADATA_RECORD mdr;
    DWORD dwTemp = 0x1234;
    BOOL fImpersonated = FALSE;

    hr = CoCreateInstance(
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoImpersonateClient();
    if (RPC_E_CALL_COMPLETE == hr)
    {
        hr = S_OK;
        goto done;
    }

    if (FAILED(hr))
    {
        goto done;
    }
    fImpersonated = TRUE;

    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                    pPath,
                                    dwAccess,
                                    1, // no need to actually get the handle - therefore set a low timeout.  Access check occurs before the attempt to get the handle
                                    &hMB );
    
    if ( hr == HRESULT_FROM_WIN32( ERROR_PATH_BUSY ) )
    {
        hr = S_OK;
        hMB = NULL;
    }
    
    if ( FAILED(hr) )
    {
        goto done;
    }

    hr = S_OK;
done:
    if ( fImpersonated )
    {
        // ignore the return value on purpose
        CoRevertToSelf();
    }

    if ( hMB )
    {
        DBG_ASSERT( NULL != pIMSAdminBase );
        DBG_REQUIRE( pIMSAdminBase->CloseKey( hMB ) == S_OK );
        hMB = NULL;
    }

    if (pIMSAdminBase)
    {
       pIMSAdminBase->Release();
       pIMSAdminBase = NULL;
    }

    return hr;
}


/*===================================================================
ValidateAccessToAppPool

Determine whether the caller has write access to the given apppool

szAppPool - AppPool to check access on

Return:	HRESULT
S_OK if access allowed
otherwise failure
===================================================================*/
HRESULT
ValidateAccessToAppPool(LPCWSTR pAppPool)
{
    HRESULT hr = S_OK;
    STACK_STRU( strPath, 128 );

    hr = strPath.Copy(L"\\LM\\W3SVC\\AppPools\\");
    if (FAILED(hr))
    {
        goto done;
    }

    hr = strPath.Append(pAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = ValidateAccessToMetabaseKey(strPath.QueryStr(), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


/*===================================================================
CWamAdmin::RecycleApplicationPool

Restart the given application pool

szAppPool - AppPool to restart.

Return:	HRESULT
S_OK if restarted
HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) if W3SVC is not up
+other error codes
===================================================================*/
STDMETHODIMP
CWamAdmin::RecycleApplicationPool
(
 LPCWSTR szAppPool
)
{
    HRESULT     hr = E_FAIL;
    IW3Control* piW3Control = NULL;

    if (NULL == szAppPool)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = ValidateAccessToAppPool(szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetWASIfRunning(&piW3Control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = piW3Control->RecycleAppPool(szAppPool);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    ReleaseInterface(piW3Control);
    return hr;
}

/*===================================================================
CWamAdmin::GetProcessMode

Retrieve the current process mode

pdwMode - where to store the mode
          Populated with 1 if we are in new mode, 0 if we are in old mode

Return:	HRESULT
S_OK if retrieved
HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) if W3SVC is not up
+other error codes
===================================================================*/
STDMETHODIMP
CWamAdmin::GetProcessMode
(
 DWORD * pdwMode
)
{
    HRESULT     hr = E_FAIL;
    IW3Control* piW3Control = NULL;

    if (NULL == pdwMode)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = ValidateAccessToMetabaseKey(L"\\LM\\W3SVC", METADATA_PERMISSION_READ);
    if (FAILED(hr))
    {
        goto done;
    }

    if ( IsSSLReportingBackwardCompatibilityMode() )
    {
        *pdwMode = 0;
    }
    else
    {
        *pdwMode = 1;
    }
    
    hr = S_OK;
done:
    ReleaseInterface(piW3Control);
    return hr;
}

/*===================================================================
CWamAdmin::RecycleAppPoolContainingApp

Recycles the application pool associated with a given application

Parameter:
szMDPath	a Metabase Path, in format of "/LM/W3SVC/..."

Return:	HRESULT
===================================================================*/
HRESULT
CWamAdmin::RecycleAppPoolContainingApp(LPCWSTR szPath)
{
    DBG_ASSERT(szPath);

    HRESULT hr = S_OK;
    WamRegMetabaseConfig    MDConfig;

    // We want to recycle the apppool associated with this application
    LPWSTR pszAppPool = NULL;

    // first get the apppool
    hr = MDConfig.MDGetStringAttribute( szPath,
                                        MD_APP_APPPOOL_ID,
                                        &pszAppPool);

    if (SUCCEEDED(hr))
    {
        hr = RecycleApplicationPool(pszAppPool);
        delete [] pszAppPool;
        pszAppPool = NULL;
    }
    return hr;
}


#endif // _IIS_6_0

/*

CWamAdminFactory: 	Class Factory IUnknown Implementation

*/

/*===================================================================
CWamAdminFactory::CWamAdminFactory

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
CWamAdminFactory::CWamAdminFactory()
:	m_cRef(1)
{
	InterlockedIncrement((long *)&g_dwRefCount);
}

/*===================================================================
CWamAdminFactory::~CWamAdminFactory

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
CWamAdminFactory::~CWamAdminFactory()
{
	InterlockedDecrement((long *)&g_dwRefCount);
}

/*===================================================================
CWamAdminFactory::QueryInterface

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdminFactory::QueryInterface(REFIID riid, void ** ppv)
{
	if (riid==IID_IUnknown || riid == IID_IClassFactory)
		{
        *ppv = static_cast<IClassFactory *>(this);
		AddRef();
		}
	else
		{
		*ppv = NULL;
    	return E_NOINTERFACE;
		}

	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return NOERROR;
}

/*===================================================================
CWamAdminFactory::AddRef

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdminFactory::AddRef( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedIncrement((long *)&m_cRef);
	return dwRefCount;

}

/*===================================================================
CWamAdminFactory::Release

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP_(ULONG) CWamAdminFactory::Release( )
{
	DWORD dwRefCount;

	dwRefCount = InterlockedDecrement((long *)&m_cRef);
	return dwRefCount;
}

/*===================================================================
CWamAdminFactory::CreateInstance

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdminFactory::CreateInstance(IUnknown * pUnknownOuter, REFIID riid, void ** ppv)
{
	if (pUnknownOuter != NULL)
		{
    	return CLASS_E_NOAGGREGATION;
		}

	CWamAdmin *pWamAdmin = new CWamAdmin;
	if (pWamAdmin == NULL)
		{
		return E_OUTOFMEMORY;
		}

	HRESULT hrReturn = pWamAdmin->QueryInterface(riid, ppv);

	pWamAdmin->Release();

	return hrReturn;
}

/*===================================================================
CWamAdminFactory::LockServer

Parameter:

Return:	HRESULT
NOERROR	if succeeds
===================================================================*/
STDMETHODIMP CWamAdminFactory::LockServer(BOOL fLock)
{
	if (fLock)
		{
        InterlockedIncrement((long *)&g_dwRefCount);
    	}
    else
    	{
        InterlockedDecrement((long *)&g_dwRefCount);
    	}
	return NOERROR;
}

#if 0

// OBSOLETE - This fix (335422) was implemented in script but
// some of the code is general enough that it might be worth
// keeping around for a while.


STDMETHODIMP CWamAdmin::SynchWamAccountAll()
/*+
Routine Description:

    Updates all out of process packages with the current IWAM_ account
    values stored in the metabase.

    There are a number of ways that the IWAM_ account information can get
    out of sync between the metabase/sam/com+. The metabase contains code
    to repair the IWAM_ and IUSR_ accounts on startup if there is a disconnect
    with the SAM. If there is a disconnect with com+ calling this method will
    repair it.

    If the IWAM_ account does not match what is stored in the com catalog the
    following error's will happen:

    CoCreateInstance for WAM object returns CO_E_RUNAS_CREATEPROCESS_FAILURE

    Event Log - DCOM 10004 - "Logon error"

Arguments:
    None

Returns:
    HRESULT
-*/
{
    HRESULT hr = NOERROR;

    // Get WAM user info from the metabase

   	WamRegMetabaseConfig    mb;

    // These are way too big...
    WCHAR   wszIWamUser[MAX_PATH];
    WCHAR   wszIWamPass[MAX_PATH];

    hr = mb.MDGetIdentity( wszIWamUser,
                           sizeof(wszIWamUser),
                           wszIWamPass,
                           sizeof(wszIWamPass)
                           );
    if( FAILED(hr) ) return hr;

    // Init the com admin interface

    WamRegPackageConfig     comAdmin;

    hr = comAdmin.CreateCatalog();
    if( FAILED(hr) ) return hr;

    //
    // For each of the out of process applications,
    // get the package and reset the metabase identity.
    //

    // After this failures cause a goto exit, which will release the lock
    g_WamRegGlobal.AcquireAdmWriteLock();

    WCHAR * wszPropPaths        = NULL;
    DWORD   cbPropPaths         = 0;
    WCHAR * pwszPartialPath;
    WCHAR * wszFullPath         = NULL;
    DWORD   dwAppMode;
    WCHAR   wszWamClsid[uSizeCLSID];
    WCHAR   wszAppPackageId[uSizeCLSID];

    // Reset the properties for the pooled package

    hr = comAdmin.ResetPackageActivation(
            g_WamRegGlobal.g_szIISOOPPoolPackageID,
            wszIWamUser,
            wszIWamPass
            );

    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "comAdmin.ResetPackageActivation FAILED(%08x) on (%S)\n",
                    hr,
                    g_WamRegGlobal.g_szIISOOPPoolPackageID
                    ));
        goto exit;
    }

    // Reset the properties for each isolated application

    hr = mb.MDGetPropPaths( g_WamRegGlobal.g_szMDW3SVCRoot,
                            MD_APP_ISOLATED,
                            &wszPropPaths,
                            &cbPropPaths
                            );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "mb.MDGetPropPaths FAILED(%08x)\n",
                    hr
                    ));
        goto exit;
    }

    if( SUCCEEDED(hr) )
    {
        for( pwszPartialPath = wszPropPaths;
             *pwszPartialPath != L'\0';
             pwszPartialPath += ( wcslen( pwszPartialPath ) + 1 )
             )
        {
            if( wszFullPath )
            {
                delete [] wszFullPath;
                wszFullPath = NULL;
            }

            hr = g_WamRegGlobal.ConstructFullPath(
                    WamRegGlobal::g_szMDW3SVCRoot,
                    WamRegGlobal::g_cchMDW3SVCRoot,
                    pwszPartialPath,
                    &wszFullPath
                    );
            if( FAILED(hr) ) goto exit;

            hr = mb.MDGetDWORD( wszFullPath, MD_APP_ISOLATED, &dwAppMode );
            if( FAILED(hr) ) goto exit;

            if( dwAppMode == eAppRunOutProcIsolated )
            {
                hr = mb.MDGetIDs( wszFullPath, wszWamClsid, wszAppPackageId, dwAppMode );
                if( FAILED(hr) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "mb.MDGetIDs FAILED(%08x) on (%S)\n",
                                hr,
                                wszFullPath
                                ));
                    continue;
                }

                hr = comAdmin.ResetPackageActivation( wszAppPackageId, wszIWamUser, wszIWamPass );
                if( FAILED(hr) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "comAdmin.ResetPackageActivation FAILED(%08x) on (%S)\n",
                                hr,
                                wszFullPath
                                ));
                    continue;
                }
            }
        }
    }

// goto exit on catastrophic failures, but if there is just
// an individual malformed application continue
exit:

    g_WamRegGlobal.ReleaseAdmWriteLock();

    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "CWamAdmin::SynchWamAccountAll FAILED(%08x)\n",
                    hr
                    ));
    }

    if( wszPropPaths ) delete [] wszPropPaths;
    if( wszFullPath ) delete [] wszFullPath;

    return hr;
}

// OBSOLETE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\iis60\makefile.inc ===
#
#   makefil0
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_FLAGS       = /I $(SDK_INC_PATH)
INCS            = -I.. -I$(SDK_INC_PATH)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)


#------------------------------------------------------------
# WAMREG DCOM Interface specification and compilation directives
#------------------------------------------------------------

WAMREG_IDL_FILE_NAME = wamreg

WAMREG_HEADER_FILE = ..\..\..\..\inc\$(O)\i$(WAMREG_IDL_FILE_NAME).h
WAMREG_IID_STUB    = $(O)\$(WAMREG_IDL_FILE_NAME)_i.c
WAMREG_PROXY_STUB  = $(O)\$(WAMREG_IDL_FILE_NAME)_p.c
WAMREG_DLL_DATA    = $(O)\dlldata.c
WAMREG_TLB         = $(O)\$(WAMREG_IDL_FILE_NAME).tlb

WAMREG_TARGETS     = $(WAMREG_IID_STUB) $(WAMREG_PROXY_STUB)  \
                     $(WAMREG_HEADER_FILE) $(WAMREG_DLL_DATA)


#------------------------------------------------------------
#  Define output and dependencies
#------------------------------------------------------------

all:    $(WAMREG_TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF clean: delsrc all

delsrc:
        -erase $(WAM_TARGETS) $(WR_TARGETS)


#
#  MIDL Compile stuff
#
$(WAMREG_TARGETS):  ..\$(WAMREG_IDL_FILE_NAME).idl
    midl -no_stamp $(MIDL_OPTIMIZATION_NT5) $(IDL_FLAGS) $(CPP) $(INCS) /header $(WAMREG_HEADER_FILE) /iid $(WAMREG_IID_STUB) /dlldata $(WAMREG_DLL_DATA) /proxy $(WAMREG_PROXY_STUB) /tlb $(WAMREG_TLB)  ..\$(WAMREG_IDL_FILE_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\vptool\main.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: main.cpp

Owner: leijin

Note:
===================================================================*/

#include <stdio.h>


#include "module.h"
#include "util.h"


int _cdecl main (int argc, char **argv)
{
    HRESULT hr = NOERROR;
    
    
    if (!ParseCommandLine(argc, argv))
    {
        return -1;
    }
    
    //
    // Do not do CoInitialize() in case of INSTALL or UNINSTALL
    //
    ModuleInitialize();
    
    switch(g_Command.eCmd)
    {
#ifdef _WAMREG_LINK_DIRECT
    case eCommand_INSTALL:
        hr = CreateIISPackage();
        if (SUCCEEDED(hr))	
        {
            printf("The default IIS Package has been installed on your machine.\n");
        }
        else
        {
            printf("Failed to create default IIS package, hr = %08x\n", hr);
        }
        
        break;
    case eCommand_UNINSTALL:
        hr = DeleteIISPackage();
        if (SUCCEEDED(hr))	
        {
            printf("The default IIS Package has been Uninstalled from your machine.\n");
        }
        else
        {
            printf("Failed to uninstall default IIS package, hr = %08x\n", hr);
        }
        break;
        
    case eCommand_UPGRADE:
        hr = UpgradePackages(VS_K2Beta2, VS_K2Beta3);
        if (SUCCEEDED(hr))
        {
            printf("The packages has been upgraded on your machine.\n");
        }
        else
        {
            printf("Fail to upgrade the packages. hr = %08x\n",hr);
        }
        break;
#endif
        
    case eCommand_CREATEINPROC:
        CreateInPool(g_Command.szMetabasePath, TRUE);
        break;
        
    case eCommand_CREATEINPOOL:
        CreateInPool(g_Command.szMetabasePath, FALSE);
        break;
        
    case eCommand_DELETE:
        Delete(g_Command.szMetabasePath);
        break;
        
    case eCommand_HELP:
        break;
        
    case eCommand_CREATEOUTPROC:
        CreateOutProc(g_Command.szMetabasePath);
        break;
        
    case eCommand_GETSTATUS:
        GetStatus(g_Command.szMetabasePath);
        break;
        
    case eCommand_UNLOAD:
        UnLoad(g_Command.szMetabasePath);
        break;
        
    case eCommand_DELETEREC:
        DeleteRecoverable(g_Command.szMetabasePath);
        break;
        
    case eCommand_RECOVER:
        Recover(g_Command.szMetabasePath);
        break;
        
    case eCommand_GETSIGNATURE:
        GetSignature();
        break;
        
    case eCommand_SERIALIZE:
        Serialize();
        break;
        
    case eCommand_2CREATE:
        CREATE2();
        break;
    case eCommand_2DELETE:
        DELETE2();
        break;
    case eCommand_2CREATEPOOL:
        CREATEPOOL2();
        break;
    case eCommand_2DELETEPOOL:
        DELETEPOOL2();
        break;
    case eCommand_2ENUMPOOL:
        ENUMPOOL2();
        break;
    case eCommand_2RECYCLEPOOL:
        RECYCLEPOOL();
        break;
    case eCommand_2GETMODE:
        GETMODE();
        break;
    case eCommand_2TestConn:
	TestConn();
        break;
    default:
        printf("This feature has not been implemented.\n");
        break;
    }
    
    ModuleUnInitialize();
    
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\wamadm.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: WamAdm.h 

	Declaration of the CWamAdmin

Owner: LeiJin

Note:

WamAdm header file
===================================================================*/	


#ifndef __WAMADM_H_
#define __WAMADM_H_

#include "admex.h"
#include "common.h"

/////////////////////////////////////////////////////////////////////////////
// CWamAdmin
class CWamAdmin : 
    public IWamAdmin2,
    public IMSAdminReplication
#ifdef _IIS_6_0
    , public IIISApplicationAdmin
#endif // _IIS_6_0
{
public:
    CWamAdmin();
    ~CWamAdmin();
	

public:
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    //
    // IWamAdmin
    //
    
    STDMETHOD(AppRecover)
        (
        /*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppDeleteRecoverable)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppGetStatus)
        (/*[in, unique, string]*/ LPCWSTR szMDPath,
        /*[out]*/ DWORD *pdwAppStatus
        );
    
    STDMETHOD(AppUnLoad)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppDelete)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fRecursive
        );
    
    STDMETHOD(AppCreate)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ BOOL fInProc
        );
    
    //
    // IWamAdmin2
    //
    STDMETHOD(AppCreate2)
        (/*[in, unique, string]*/ LPCWSTR szMDPath, 
        /*[in]*/ DWORD dwAppMode
        );
    
    
    //
    //IMSAdminReplication
    //These interfaces are defined in admex.h, as part of Admin Extension.
    //
    STDMETHOD(GetSignature)
        (
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
        );
    
    STDMETHOD(Propagate)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer
        );
    
    STDMETHOD(Propagate2)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
        /* [in] */ DWORD dwSignatureMismatch
        );
    
    STDMETHOD(Serialize)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
        );
    
    STDMETHOD(DeSerialize)
        ( 
        /* [in] */ DWORD dwBufferSize,
        /* [size_is][in] */ unsigned char __RPC_FAR *pbBuffer
        );

#ifdef _IIS_6_0
    //
    // IIISApplicationAdmin interface
    //
    STDMETHOD(CreateApplication)
        (
        LPCWSTR szMDPath,
        DWORD dwAppMode,
        LPCWSTR szAppPoolId,
        BOOL fCreatePool
        );
    
    STDMETHOD(DeleteApplication)
        (
        LPCWSTR szMDPath,
        BOOL fRecursive
        );
    
    STDMETHOD(CreateApplicationPool)
        (
        LPCWSTR szMDPath
        );
    
    STDMETHOD(DeleteApplicationPool)
        (
        LPCWSTR szMDPath
        );
        
    STDMETHOD(EnumerateApplicationsInPool)
        (
        LPCWSTR szMDPath,
        BSTR*   pbstrBuffer
        );

    STDMETHOD(RecycleApplicationPool)
        (
        LPCWSTR szMDPath
        );
    
    STDMETHOD(GetProcessMode)
        (
        DWORD * pdwMode
        );

private:
    HRESULT RecycleAppPoolContainingApp(LPCWSTR szPath);

public:

#endif // _IIS_6_0

private:
    HRESULT PrivateDeleteApplication
        (
        LPCWSTR szMDPath,
        BOOL fRecursive,
        BOOL fRecoverable,
        BOOL fRemoveAppPool
        );

    STDMETHOD(FormatMetabasePath)
        (
        /* [in] */ LPCWSTR pwszMetabasePathIn,
        /* [out] */ LPWSTR *ppwszMetabasePathOut
        );

    long    m_cRef;
};

class CWamAdminFactory: 
	public IClassFactory 
{
public:
	CWamAdminFactory();
	~CWamAdminFactory();

	STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(CreateInstance)(IUnknown * pUnknownOuter, REFIID riid, void ** ppv);
	STDMETHOD(LockServer)(BOOL bLock);

private:
	long		m_cRef;
};


#endif //__WAMADM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\vptool\module.h ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: module.h

Owner: leijin

Note:
===================================================================*/

#ifndef _VPTOOL_MODULE_H_
#define _VPTOOL_MODULE_H_


#include <objbase.h>

#define SIZE_STRING_BUFFER	1024
#define uSizeCLSID			39

HRESULT	ModuleInitialize();
HRESULT ModuleUnInitialize();
void CreateInPool(CHAR* szPath, BOOL fInProc);
void CreateOutProc(CHAR* szPath);
void Delete(CHAR* szPath);
void UnLoad(CHAR* szPath);
void GetStatus(CHAR* szPath);
void DeleteRecoverable(CHAR* szPath);
void Recover(CHAR* szPath);
void GetSignature();
void Serialize();
void CREATE2();
void DELETE2();
void CREATEPOOL2();
void DELETEPOOL2();
void ENUMPOOL2();
void RECYCLEPOOL();
void GETMODE();
void TestConn();

extern	const BOOL	fLinkWithWamReg;

#endif //_VPTOOL_MODULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\wamreg.cpp ===
// wamreg.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for wamreg.idl by adding the following 
//		files to the Outputs.
//			wamreg_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f wamregps.mk in the project directory.

#include "common.h"

#include "objbase.h"
#include "initguid.h"
#include "iwamreg.h"
#include "iadmext.h"
#include "dlldatax.h"
#include "auxfunc.h"
#include "wmrgsv.h"

#include "WamAdm.h"
#include "comobj.h"

#include "dbgutil.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#define IIS_DEFAULT_PACKAGE	0

#ifdef _IIS_6_0
#include "w3ctrlps.h"
#endif // _IIS_6_0

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

const CHAR 		g_pszModuleName[] = "WAMREG";

HINSTANCE g_hModule = NULL;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    
    BOOL fReturn = FALSE;
    
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        
        g_hModule = hInstance;
        
        INITIALIZE_PLATFORM_TYPE();
#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS(DEBUG_ERROR);
        CREATE_DEBUG_PRINT_OBJECT( g_pszModuleName);
#else
//        CREATE_DEBUG_PRINT_OBJECT( g_pszModuleName);
#endif
/*
        if ( !VALID_DEBUG_PRINT_OBJECT()) 
        {
            fReturn = FALSE;
        }
        else
        {
*/
            g_pWmRgSrvFactory = new CWmRgSrvFactory();
            fReturn = g_WamRegGlobal.Init();
        //}
       	
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        g_WamRegGlobal.UnInit();
        delete g_pWmRgSrvFactory;
        DELETE_DEBUG_PRINT_OBJECT();	
    }
    
    fReturn = TRUE;    // ok
    return fReturn;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	if (g_dwRefCount == 0)
		{
		return S_OK;
		}
	else
		{
		return S_FALSE;
		}
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	HRESULT hrReturn = E_FAIL;
	
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif

	if (rclsid == CLSID_WmRgSrv) 
		{
		if (FAILED(g_pWmRgSrvFactory->QueryInterface(riid, ppv))) 
			{
	    	*ppv = NULL;
	   		hrReturn = E_INVALIDARG;
	   		}
	   	else
	   		{
	   		hrReturn = NOERROR;
	   		}
		}
	else
		{
		hrReturn = S_OK;
		}

	return hrReturn;
}


HRESULT WamReg_RegisterServer()
{
	HKEY 	hKeyCLSID, hKeyInproc32;
    HKEY 	hKeyIF, hKeyStub32;
    HKEY 	hKeyAppID, hKeyTemp;
    DWORD 	dwDisposition;
	char 	pszName[MAX_PATH+1 + sizeof("inetinfo.exe -e iisadmin")];

    HRESULT hr;

    //
    //register AppID
    //CLSID_WamAdmin, 0x61738644, 0xF196, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1)
    //

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
				                       TEXT("AppID\\{61738644-F196-11D0-9953-00C04FD919C1}"),
				                       NULL, 
				                       TEXT(""), 
				                       REG_OPTION_NON_VOLATILE, 
				                       KEY_ALL_ACCESS, 
				                       NULL,
				                       &hKeyAppID, 
				                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
    else
    	{
	    if (ERROR_SUCCESS != RegSetValueEx(hKeyAppID, 
	    								TEXT(""), 
	    								NULL, 
	    								REG_SZ, 
	    								(BYTE*) TEXT("IIS WAMREG admin Service"), 
	    								sizeof(TEXT("IIS WAMREG Admin Service")))) 
	    			{
	                RegCloseKey(hKeyAppID);
	                return E_UNEXPECTED;
	                }

	    if (ERROR_SUCCESS != RegSetValueEx(hKeyAppID, 
	        							TEXT("LocalService"), 
	        							NULL, 
	        							REG_SZ, 
	        							(BYTE *) TEXT("IISADMIN"), 
	        							sizeof(TEXT("IISADMIN")))) 
	        {
	        RegCloseKey(hKeyAppID);
	        return E_UNEXPECTED;
	        }
	        
    	RegCloseKey(hKeyAppID);
    	}
    	
    //
    // register CLSID
    //WamAdmin_CLSID

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
			                       TEXT("CLSID\\{61738644-F196-11D0-9953-00C04FD919C1}"),
			                       NULL, 
			                       TEXT(""), 
			                       REG_OPTION_NON_VOLATILE, 
			                       KEY_ALL_ACCESS, 
			                       NULL,
			                       &hKeyCLSID, 
			                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
     else
     	{

	    if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
	    								TEXT(""), 
	    								NULL, 
	    								REG_SZ, 
	    								(BYTE*) TEXT("IIS WAMREG Admin"), 
	    								sizeof(TEXT("IIS WAMREG Admin"))))
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
            
	    if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
	    								TEXT("AppID"), 
	    								NULL, 
	    								REG_SZ, 
	    								(BYTE*) TEXT("{61738644-F196-11D0-9953-00C04FD919C1}"), 
	    								sizeof(TEXT("{61738644-F196-11D0-9953-00C04FD919C1}"))))
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
          

	    if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
	        							TEXT("LocalService"), 
	        							NULL, 
	        							REG_SZ, 
	        							(BYTE*) TEXT("IISADMIN"), 
	        							sizeof(TEXT("IISADMIN")))) 
	        {
	        RegCloseKey(hKeyCLSID);
	        return E_UNEXPECTED;
	        }
	   	RegCloseKey(hKeyCLSID);
    	}

    //
    // Main Interfaces
    //

    //
    // WAMREG Admin Interface
    //IID_IWamAdmin, 0x29822AB7, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{29822AB7-F302-11D0-9953-00C04FD919C1}"),
                       NULL, 
                       TEXT(""), 
                       REG_OPTION_NON_VOLATILE, 
                       KEY_ALL_ACCESS, 
                       NULL,
                       &hKeyCLSID, 
                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
    else
    	{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("PSFactoryBuffer"), 
										sizeof(TEXT("PSFactoryBuffer")))) 
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    	if (ERROR_SUCCESS != RegCreateKeyEx(hKeyCLSID,
                       						"InprocServer32",
                       						NULL, 
                       						TEXT(""), 
                       						REG_OPTION_NON_VOLATILE, 
                       						KEY_ALL_ACCESS, 
                       						NULL,
                        					&hKeyInproc32, 
                        					&dwDisposition)) 
            {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
		else
			{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
											TEXT(""), 
											NULL, 
											REG_SZ, 
											(BYTE*) "WAMREGPS.DLL", 
											sizeof(TEXT("WAMREGPS.DLL")))) 
				{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

	        if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
	        								TEXT("ThreadingModel"), 
	        								NULL, 
	        								REG_SZ, 
	        								(BYTE*) "Both", 
	        								sizeof("Both")-1 )) 
	        	{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

    		RegCloseKey(hKeyInproc32);
    		}
    	RegCloseKey(hKeyCLSID);
    	}


    //
    // WAMREG Admin Interface
    //IID_IWamAdmin2, 0x29822AB8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{29822AB8-F302-11D0-9953-00C04FD919C1}"),
                       NULL, 
                       TEXT(""), 
                       REG_OPTION_NON_VOLATILE, 
                       KEY_ALL_ACCESS, 
                       NULL,
                       &hKeyCLSID, 
                       &dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
    else
    	{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyCLSID, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("PSFactoryBuffer"), 
										sizeof(TEXT("PSFactoryBuffer")))) 
			{
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    	if (ERROR_SUCCESS != RegCreateKeyEx(hKeyCLSID,
                       						"InprocServer32",
                       						NULL, 
                       						TEXT(""), 
                       						REG_OPTION_NON_VOLATILE, 
                       						KEY_ALL_ACCESS, 
                       						NULL,
                        					&hKeyInproc32, 
                        					&dwDisposition)) 
            {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
		else
			{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
											TEXT(""), 
											NULL, 
											REG_SZ, 
											(BYTE*) "WAMREGPS.DLL", 
											sizeof(TEXT("WAMREGPS.DLL")))) 
				{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

	        if (ERROR_SUCCESS != RegSetValueEx(hKeyInproc32, 
	        								TEXT("ThreadingModel"), 
	        								NULL, 
	        								REG_SZ, 
	        								(BYTE*) "Both", 
	        								sizeof("Both")-1 )) 
	        	{
	            RegCloseKey(hKeyInproc32);
	            RegCloseKey(hKeyCLSID);
	            return E_UNEXPECTED;
	            }

    		RegCloseKey(hKeyInproc32);
    		}
    	RegCloseKey(hKeyCLSID);
    	}

    //
    
   	//
    // register Interfaces
    //

    //
    // ANSI Main Interface
    // WamReg Admin Interface

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    			TEXT("Interface\\{29822AB7-F302-11D0-9953-00C04FD919C1}"),
                    			NULL, 
                    			TEXT(""), 
                    			REG_OPTION_NON_VOLATILE, 
                    			KEY_ALL_ACCESS, 
                    			NULL,
                    			&hKeyIF, 
                    			&dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
	else
		{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyIF, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("IWamAdmin"), 
										sizeof(TEXT("IWamAdmin")))) 
			{
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

        if (ERROR_SUCCESS != RegCreateKeyEx(hKeyIF,
					                    "ProxyStubClsid32",
					                    NULL, 
					                    TEXT(""), 
					                    REG_OPTION_NON_VOLATILE, 
					                    KEY_ALL_ACCESS, 
					                    NULL,
					                    &hKeyStub32, 
					                    &dwDisposition)) 
	        {
	        RegCloseKey(hKeyIF);
	        return E_UNEXPECTED;
	        }
	    else
	    	{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyStub32, 
												TEXT(""), 
												NULL, 
												REG_SZ, 
												(BYTE*)"{29822AB7-F302-11D0-9953-00C04FD919C1}", 
												sizeof("{29822AB7-F302-11D0-9953-00C04FD919C1}"))) 
				{
	            RegCloseKey(hKeyStub32);
	            RegCloseKey(hKeyIF);
	            return E_UNEXPECTED;
            	}

            RegCloseKey(hKeyStub32);
            }
    	RegCloseKey(hKeyIF);
    	}

    // WamReg Admin Interface
    // IID_IWamAdmin2
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    			TEXT("Interface\\{29822AB8-F302-11D0-9953-00C04FD919C1}"),
                    			NULL, 
                    			TEXT(""), 
                    			REG_OPTION_NON_VOLATILE, 
                    			KEY_ALL_ACCESS, 
                    			NULL,
                    			&hKeyIF, 
                    			&dwDisposition)) 
        {
        return E_UNEXPECTED;
        }
	else
		{
		if (ERROR_SUCCESS != RegSetValueEx(hKeyIF, 
										TEXT(""), 
										NULL, 
										REG_SZ, 
										(BYTE*) TEXT("IWamAdmin2"), 
										sizeof(TEXT("IWamAdmin2")))) 
			{
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

        if (ERROR_SUCCESS != RegCreateKeyEx(hKeyIF,
					                    "ProxyStubClsid32",
					                    NULL, 
					                    TEXT(""), 
					                    REG_OPTION_NON_VOLATILE, 
					                    KEY_ALL_ACCESS, 
					                    NULL,
					                    &hKeyStub32, 
					                    &dwDisposition)) 
	        {
	        RegCloseKey(hKeyIF);
	        return E_UNEXPECTED;
	        }
	    else
	    	{
			if (ERROR_SUCCESS != RegSetValueEx(hKeyStub32, 
												TEXT(""), 
												NULL, 
												REG_SZ, 
												(BYTE*)"{29822AB8-F302-11D0-9953-00C04FD919C1}", 
												sizeof("{29822AB8-F302-11D0-9953-00C04FD919C1}"))) 
				{
	            RegCloseKey(hKeyStub32);
	            RegCloseKey(hKeyIF);
	            return E_UNEXPECTED;
            	}

            RegCloseKey(hKeyStub32);
            }
    	RegCloseKey(hKeyIF);
    	}

    return NOERROR;
}

STDAPI WamReg_UnRegisterServer(void) {

    //
    // register AppID
    //
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{61738644-F196-11D0-9953-00C04FD919C1}"));

    //RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{61738646-F196-11D0-9953-00C04FD919C1}"));

    //
    // register CLSID
    //


    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{61738644-F196-11D0-9953-00C04FD919C1}"));

	/*
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{61738646-F196-11D0-9953-00C04FD919C1}"));
	*/

    //
    // WAMREG Interfaces
    //

    //
    // Admin Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB7-F302-11D0-9953-00C04FD919C1}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB7-F302-11D0-9953-00C04FD919C1}"));

    //
    // Replication Interface
    //
	/*
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB8-F302-11D0-9953-00C04FD919C1}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{29822AB8-F302-11D0-9953-00C04FD919C1}"));
	*/

    //
    // deregister Interfaces
    //

    //
    // Admin Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB7-F302-11D0-9953-00C04FD919C1}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB7-F302-11D0-9953-00C04FD919C1}"));


	/*
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB8-F302-11D0-9953-00C04FD919C1}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{29822AB8-F302-11D0-9953-00C04FD919C1}"));
	*/
	
	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
                              
    if (dwReturn == ERROR_SUCCESS) 
    	{
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("WAM REG COM LAYER"),
                                 sizeof(TEXT("WAM REG COM LAYER")));
                                 
        if (dwReturn == ERROR_SUCCESS) 
        	{
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                					  	"InprocServer32",
                						NULL,
                						TEXT(""),
                						REG_OPTION_NON_VOLATILE,
                						KEY_ALL_ACCESS, 
                						NULL,
                						&hKeyInproc32, 
                						&dwDisposition);

            if (dwReturn == ERROR_SUCCESS) 
            	{
                hModule=GetModuleHandle(TEXT("WAMREG.DLL"));
                if (!hModule) 
                	{
                    dwReturn = GetLastError();
                	}
                else 
                	{
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) 
						{
                        dwReturn = GetLastError();
                    	}
                    else 
                    	{
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                                                 
                        if (dwReturn == ERROR_SUCCESS) 
                        	{
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        	}
                    	}
                	}
                RegCloseKey(hKeyInproc32);
            	}
        	}
        RegCloseKey(hKeyCLSID);
    	}

	//
	// Register the COM object's CLSID under IISADMIN_EXTENSIONS_REG_KEY
	//
	if (dwReturn == ERROR_SUCCESS)
		{
		dwReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
								IISADMIN_EXTENSIONS_REG_KEY
									TEXT("\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"),
								NULL,
								TEXT(""),
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKeyCLSID,
								&dwDisposition);
		if (dwReturn == ERROR_SUCCESS)
			{
			RegCloseKey(hKeyCLSID);
			}
		}

    if (dwReturn == ERROR_SUCCESS)	
    	{
    	HRESULT hr;
    	// registers object, typelib and all interfaces in typelib
    	hr = WamReg_RegisterServer();
		return hr;
		}
	else
		{
    	return RETURNCODETOHRESULT(dwReturn);
    	}
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwTemp;

#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{763A6C86-F30F-11D0-9953-00C04FD919C1}\\InprocServer32"));
	if (dwTemp != ERROR_SUCCESS)
		{
		dwReturn = dwTemp;
		}
		
	dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"));
    if (dwTemp != ERROR_SUCCESS)
		{
		dwReturn = dwTemp;
		}

	dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
					IISADMIN_EXTENSIONS_REG_KEY
                    	TEXT("\\{763A6C86-F30F-11D0-9953-00C04FD919C1}"));
    if (dwTemp != ERROR_SUCCESS)
		{
		dwReturn = dwTemp;
		}

	if (SUCCEEDED(HRESULT_FROM_WIN32(dwReturn)))
		{
		HRESULT hr;

		hr = WamReg_UnRegisterServer();
		return hr;
		}
	else
		{
		return HRESULT_FROM_WIN32(dwReturn);
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\vptool\module.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: module.cpp

Owner: leijin

Note:
===================================================================*/

#include <stdio.h>
#include <objbase.h>
#include <initguid.h>
#include "admex.h"
#include "iwamreg.h"

//
//#include "mtxadmin.h"

#include "module.h"
#include "util.h"


#ifdef _WAMREG_LINK_DIRECT
    #include "wmrgexp.h"
    const BOOL  fLinkWithWamReg = TRUE;
#else
    const BOOL  fLinkWithWamReg = FALSE;
#endif

HRESULT ModuleInitialize(VOID)
{
    HRESULT hr = NOERROR;
    if (!fLinkWithWamReg)
    {
        // do the call to CoInitialize()
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
    
    return hr;
}

HRESULT ModuleUnInitialize(VOID)
{
    HRESULT hr = NOERROR;
    
    if (!fLinkWithWamReg)
    {    	
        CoUninitialize();
    }
    
    return hr;    	
}

void CreateInPool(CHAR* szPath, BOOL fInProc)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin2*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    DWORD       dwAppMode;
    
    dwAppMode = (fInProc) ? eAppRunInProc : eAppRunOutProcInDefaultPool;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppCreate2(wszMetabasePath, dwAppMode);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("%s : Create %s application on path %s failed, error = %08x.\n",
                    (fInProc) ? "CREATEINPROC" : "CREATEINPOOL",
                    (fInProc) ? "in-proc" : "out-proc pooled",
                    szPath,
                    hr);
            }
            else
            {
                printf("%s: Create %s, pooled application on path %s successfully.\n",
                    (fInProc) ? "CREATEINPROC" : "CREATEINPOOL",
                    (fInProc) ? "in-proc" : "out-proc pooled",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
            
        }
        else
        {
            printf("CREATEINPROC: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void CreateOutProc(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppCreate(wszMetabasePath, FALSE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("CREATEOUTPROC: Create out-proc application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("CREATEOUTPROC: Create an out proc application on path %s successfully.\n",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("CREATEOUTPROC: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void Delete(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {		
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppDelete(wszMetabasePath, FALSE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("DELETE: Delete application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }	
            else
            {
                printf("DELETE: Delete application on path %s successfully.\n",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("DELETE: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void UnLoad(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            Timer.Start();
            hr = pIWamAdmin->AppUnLoad(wszMetabasePath, FALSE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("UNLOAD: Unload application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("UNLOAD: Unload application on path %s successfully.\n",
                    szPath);
            }
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("UNLOAD: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void GetStatus(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            DWORD dwStatus;
            
            Timer.Start();
            hr = pIWamAdmin->AppGetStatus(wszMetabasePath, &dwStatus);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("GETSTATUS: GetStatus of application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                if (dwStatus == APPSTATUS_NOTDEFINED)
                {
                    printf("Application on path %s is not defined. \n", szPath);
                }
                else if (dwStatus == APPSTATUS_STOPPED)
                {
                    printf("Application on path %s is stopped. \n", szPath);
                }
                else if (dwStatus == APPSTATUS_RUNNING)
                {
                    printf("Application on path %s is running. \n", szPath);
                }
                else
                {
                    printf("Application on path %s is in unknown state. \n", szPath);
                }
                
                Report_Time(Timer.GetElapsedSec());
            }	
        }
        else
        {
            printf("GETSTATUS: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void DeleteRecoverable(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            DWORD dwStatus;
            
            Timer.Start();
            hr = pIWamAdmin->AppDeleteRecoverable(wszMetabasePath, TRUE);
            Timer.Stop();
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("DELETEREC: AppDeleteRecoverable of application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("DeleteRecoverable call on path %s succeeded.\n", szPath, hr);
            }			
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("DELETEREC: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}


void Recover(CHAR* szPath)
{
    WCHAR		wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT		hr = NOERROR;
    IWamAdmin*	pIWamAdmin = NULL;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        CStopWatch  Timer;
        
        Timer.Reset();
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IWamAdmin2,
            (void **)&pIWamAdmin);
        if (SUCCEEDED(hr))
        {
            DWORD dwStatus;
            
            Timer.Start();
            hr = pIWamAdmin->AppRecover(wszMetabasePath, TRUE);
            Timer.Stop();
            
            pIWamAdmin->Release();
            if (FAILED(hr))
            {
                printf("Recover: Recover application on path %s failed, error = %08x.\n",
                    szPath,
                    hr);
            }
            else
            {
                printf("Recover call on path %s succeeded.\n", szPath, hr);
            }					
            
            Report_Time(Timer.GetElapsedSec());
        }
        else
        {
            printf("Recover: Failed to CoCreateInstance of WamAdmin object. error = %8x.\n",
                hr);
        }
    }
    return;
}

void GetSignature()
{
    HRESULT		hr = NOERROR;
    IMSAdminReplication*	pIWamRep = NULL;
    DWORD		dwRequiredSize = 0;
    DWORD		dwBufferSize = sizeof(DWORD);
    DWORD		dwBuffer;
    
    CStopWatch  Timer;
    
    Timer.Reset();
    hr = CoCreateInstance(CLSID_WamAdmin,
        NULL,
        CLSCTX_SERVER,
        IID_IMSAdminReplication,
        (void **)&pIWamRep);
    if (SUCCEEDED(hr))
    {
        DWORD dwStatus;
        
        Timer.Start();
        hr = pIWamRep->GetSignature(dwBufferSize, (BYTE *)&dwBuffer, &dwRequiredSize);
        Timer.Stop();
        
        Report_Time(Timer.GetElapsedSec());
        
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            BYTE *pbBuffer = NULL;
            
            pbBuffer = new BYTE [dwRequiredSize];
            if (pbBuffer)
            {
                Timer.Reset();
                Timer.Start();
                hr = pIWamRep->GetSignature(dwRequiredSize, pbBuffer, &dwRequiredSize);
                Timer.Stop();
                
                Report_Time(Timer.GetElapsedSec());
                if (SUCCEEDED(hr))
                {
                    BYTE  *pbTemp = pbBuffer;
                    DWORD cTotalSize = 0;
                    
                    for (INT iSignature = 0; cTotalSize < dwRequiredSize; iSignature++)
                    {
                        printf("Signature buffer[%d]: Signature = %08x\n",
                            iSignature,
                            *(DWORD*)pbTemp);
                        
                        pbTemp += sizeof(DWORD);
                        cTotalSize += sizeof(DWORD);
                    }
                    
                    printf("TotalSize = %d, RequiredSize = %d \n", 
                        cTotalSize,
                        dwRequiredSize);
                }
                else
                {
                    printf("GetSignature failed, step 2, hr = %s\n",
                        hr);
                }
            }
            else
            {
                printf("GetSignature Out of memory.\n");
            }
        }
        
        pIWamRep->Release();
        if (FAILED(hr))
        {
            printf("GetSignature failed, hr = %08x\n",
                hr);
        }
        else
        {
            printf("GetSignature succeeded, signature is %08x\n", dwBuffer);
        }					
    }
    return;
}

void Serialize()
{
    HRESULT		hr = NOERROR;
    IMSAdminReplication*	pIWamRep = NULL;
    BYTE		bBufferTemp[4];
    DWORD		dwRequiredSize = 0;
    DWORD		dwBufferSize = 0;
    BYTE*		pbBuffer = NULL;
    CStopWatch  Timer;
    
    Timer.Reset();
    hr = CoCreateInstance(CLSID_WamAdmin,
        NULL,
        CLSCTX_SERVER,
        IID_IMSAdminReplication,
        (void **)&pIWamRep);
    if (SUCCEEDED(hr))
    {
        DWORD dwStatus;
        
        Timer.Start();
        
        hr = pIWamRep->Serialize(dwBufferSize, bBufferTemp, &dwRequiredSize);
        
        Timer.Stop();
        Report_Time(Timer.GetElapsedSec());
        
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            pbBuffer = new BYTE [dwRequiredSize];
            if (pbBuffer)
            {
                BYTE  *pbTemp = pbBuffer;
                DWORD cTotalBytes = 0;
                DWORD cRecBytes = 0;
                WCHAR *szProgID = NULL;
                WCHAR *szWAMCLSID = NULL;
                WCHAR *szPath = NULL;
                
                Timer.Start();
                hr = pIWamRep->Serialize(dwRequiredSize, pbBuffer, &dwRequiredSize);
                
                
                Timer.Stop();
                Report_Time(Timer.GetElapsedSec());
                
                if (SUCCEEDED(hr))
                {
                    pbTemp = pbBuffer;
                    
                    while (*(DWORD*)pbTemp != 0x0 && SUCCEEDED(hr))
                    {
                        cRecBytes = *(DWORD*)pbTemp;
                        pbTemp += sizeof(DWORD);
                        
                        szWAMCLSID = (WCHAR *)pbTemp;
                        pbTemp += uSizeCLSID*sizeof(WCHAR);
                        
                        szPath = (WCHAR *)pbTemp;
                        pbTemp += cRecBytes - uSizeCLSID*sizeof(WCHAR) - sizeof(DWORD);
                        
                        printf("Serialize: Path = %S, WAMCLSID = %S, \n",
                            szPath,
                            szWAMCLSID);
                    }
                }
                else
                {
                    printf("Serialize failed, step 2, hr = %s\n",
                        hr);
                }
                
                delete [] pbBuffer;
                pbBuffer = NULL;
            }
            else
            {
                printf("Serialize failed, out of memory.\n");
            }
            
        }
        pIWamRep->Release();				
    }
    return;
}

void HELPER2(IIISApplicationAdmin ** ppIAdmin, WCHAR * pwszMetabasePath)
{
    HRESULT		hr = NOERROR;
    INT			cSize = 0;
    INT			cch = 0;
    
    cSize = MultiByteToWideChar(0, 0, g_Command.szMetabasePath, -1, pwszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        DWORD err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Error: The Metabase path exceeds 1024 chars.\n");
        }
    }
    else
    {
        
        hr = CoCreateInstance(CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            IID_IIISApplicationAdmin,
            (void **)ppIAdmin);
        if (FAILED(hr))
        {
            printf("CoCreateFailed, in HELPER2, hr = %08x\n", hr);
        }

    }
}

void CREATE2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;

    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->CreateApplication(wszMetabasePath, eAppRunOutProcIsolated, L"TestAppPool", TRUE);
    if (FAILED(hr))
    {
        printf("CreateApplication Failed, in CREATE2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}


void DELETE2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->DeleteApplication(wszMetabasePath, FALSE);
    if (FAILED(hr))
    {
        printf("DeleteApplication Failed, in DELETE2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void CREATEPOOL2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->CreateApplicationPool(wszMetabasePath);
    if (FAILED(hr))
    {
        printf("CreateApplicationPool Failed, in CREATEPOOL2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void DELETEPOOL2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->DeleteApplicationPool(wszMetabasePath);
    if (FAILED(hr))
    {
        printf("DeleteApplicationPool Failed, in DELETEPOOL2, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void ENUMPOOL2()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);
    
    BSTR bstr;
    hr = pIAdmin->EnumerateApplicationsInPool(wszMetabasePath, &bstr);
    if (FAILED(hr))
    {
        printf("EnumerateApplicationsInPool Failed, in second call, hr = %08x\n", hr);
    }

    pIAdmin->Release();

    const WCHAR * pTestBuf = bstr;
    
    while (pTestBuf[0])
    {
        printf("%S\nnext\n", pTestBuf);
        
        // move pTestBuf beyond end of this string, including NULL terminator.
        pTestBuf += wcslen(pTestBuf) + 1;
    }

    SysFreeString(bstr);

    Report_Time(Timer.GetElapsedSec());
    return;
}

void RECYCLEPOOL()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);


    hr = pIAdmin->RecycleApplicationPool(wszMetabasePath);
    if (FAILED(hr))
    {
        printf("RecycleApplicationPool Failed, in RECYCLEPOOL, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    Report_Time(Timer.GetElapsedSec());
    return;
}

void GETMODE()
{
    CStopWatch  Timer;
    IIISApplicationAdmin*   pIAdmin = NULL;
    WCHAR                   wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT hr;
    Timer.Reset();

    HELPER2(&pIAdmin, wszMetabasePath);

    DWORD dwMode = 0;

    hr = pIAdmin->GetProcessMode(&dwMode);
    if (FAILED(hr))
    {
        printf("GetProcessMode Failed, in GETMODE, hr = %08x\n", hr);
    }
    pIAdmin->Release();

    printf("Mode is: %08x\n", dwMode);

    Report_Time(Timer.GetElapsedSec());
    return;
}

#include <iadmw.h>

void TestConn()
{
    HRESULT hr = S_OK;
    IMSAdminBase * pAdminBase = NULL;
    IConnectionPointContainer * pConnPointContainer = NULL;
    IConnectionPoint * pConnPoint = NULL;
    DWORD dwSinkNotifyCookie;

    hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
        IID_IMSAdminBase, (void**) &pAdminBase);
    if (FAILED(hr))
    {
        printf("couldn't cocreate\n");
        return;
    }
    
    hr = pAdminBase->QueryInterface(IID_IConnectionPointContainer,
        (void**) &pConnPointContainer);
    if (FAILED(hr))
    {
        printf("couldn't QI\n");
        return;
    }
    
    hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink,
        &pConnPoint);
    if (FAILED(hr))
    {
        printf("couldn't findconnpoint\n");
        return;
    }
    
    hr = pConnPoint->Advise(NULL, &dwSinkNotifyCookie);
    if (FAILED(hr))
    {
        printf("couldn't advise\n");
        return;
    }
    
    printf("advised ok\n");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\vptool\util.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: util.cpp

Owner: leijin

Description:
Contains utility functions used by vptool.
    Including Debugging, timing, helping functions.

Note:
===================================================================*/

#include "util.h"
//
//  
//

//
//  Local Data Structures.
//

const CommandParam rgCommand[] =
{
    {eCommand_INSTALL, 		"-INSTALL", 		NULL,   FALSE},
    {eCommand_UNINSTALL, 	"-UNINSTALL", 		NULL,   FALSE},
    {eCommand_UPGRADE,		"-UPGRADE", 		NULL,   TRUE},
    {eCommand_CREATEINPROC,	"-CREATEINPROC", 	NULL,   TRUE},
    {eCommand_CREATEOUTPROC,"-CREATEOUTPROC", 	NULL,   TRUE},
    {eCommand_CREATEINPOOL, "-CREATEINPOOL",    NULL,   TRUE},
    {eCommand_DELETE,		"-DELETE", 			NULL,   TRUE},
    {eCommand_GETSTATUS,	"-GETSTATUS",	 	NULL,   TRUE},
    {eCommand_UNLOAD,		"-UNLOAD",	 		NULL,   TRUE},
    {eCommand_GETSIGNATURE,	"-GETSIGNATURE",	NULL,   FALSE},
    {eCommand_SERIALIZE,	"-SERIALIZE", 		NULL,   FALSE},
    {eCommand_DESERIALIZE,	"-GETSERIALIZE",	NULL,   FALSE},
    {eCommand_DELETEREC,	"-DELETEREC", 		NULL,   TRUE},
    {eCommand_RECOVER,		"-RECOVER",			NULL,   TRUE},

    {eCommand_2CREATE,          "-2CREATE",             NULL,   TRUE},
    {eCommand_2DELETE,          "-2DELETE",             NULL,   TRUE},
    {eCommand_2CREATEPOOL,      "-2CREATEPOOL",         NULL,   TRUE},
    {eCommand_2DELETEPOOL,      "-2DELETEPOOL",         NULL,   TRUE},
    {eCommand_2ENUMPOOL,        "-2ENUMPOOL",           NULL,   TRUE},
    {eCommand_2RECYCLEPOOL,     "-RECYCLEPOOL",         NULL,   TRUE},
    {eCommand_2GETMODE,         "-GETMODE",             NULL,   TRUE},
    {eCommand_2TestConn,        "-TESTCONN",            NULL,   TRUE}
};

const char* ppszHelpFile[] = 
{
	{"\n\n\t\t vptool (a simple WAMREG command line tool). \n\n"},
	{"Usage: vptool -Options -Command MetabasePath\n"},
	{"Command = CREATEINPROC | CREATEOUTPROC | DELETE | UNLOAD | GETSTATUS \n"},
	{"\n"},
	{"MetabasePath is required for all the commands \n\n"},
	{"CREATEINPROC\t - Create an in-proc application on the metabase path\n"},
	{"CREATEOUTPROC\t - Create an out-proc application on the metabase path\n"},
	{"CREATEINPOOL\t - Create an application in the out proc application pool on the metabase path\n"},
	{"DELETE\t\t - Delete the application on the metabase path if there is one\n"},
	{"UNLOAD\t\t - Unload an application on the metabase path from w3svc runtime lookup table.\n"},
	{"GETSTATUS\t - Get status of the application on the metabase path\n"},
	{"DELETEREC\t - Delete Recoverable on the metabase path\n"},
	{"RECOVER\t\t - Recover on the metabase path\n"},
	{"\n\nReplication testing only\n"},
	{"SERIALIZE\t -t Serialize application definitions\n"},
	{"DESERIALIZE\t -t DeSerialize application definitions\n"},
	{"GETSIGNATURE\t -t Get Signature of application definitions\n"}
};

const char* ppszAdvancedHelpFile[] =
{
	{"\t\t\tvptool (a simple WAMREG command line tool). \n"},
	{"Advanced features\n"},
	{"The follow commands are used for testing purpose of other functions\n"},
	{"supported by WAMREG.DLL\n"},
	{"Usage: vptool -Command\n"},
	{"Command = INSTALL | UNINSTALL | GETSIGNATURE | SERIALIZE | DESERIALIZE\n"},
	{"INSTALL : INSTALL IIS default package.  Test install function called by Setup\n"},
	{"CAUTION: This command will remove your old IIS default package first.\n"},
	{"\n"},
	{"UNINSTALL: Remove all user defined packages, including IIS default package\n"},
	{"\n"},
	{"GETSIGNATURE: UNDONE\n"},
	{"SERIALIZE: UNDONE\n"},
	{"DESERIALIZE: UNDONE\n"},
	{"\n"},
	{"\n"}
};



CommandParam    g_Command;
VP_Options      g_Options;
const UINT      rgComMax = sizeof(rgCommand) / sizeof(CommandParam);

//
//  Utility Functions
//
BOOL ParseCommandLine(int argc, char **argv)
{
    BOOL    fFound = FALSE;
    INT     iCurrentArg = 1;
    
    if (argc < 2)
    {
        g_Command.eCmd = eCommand_HELP;
        PrintHelp();
        return FALSE;
    }
    
    if ((0 == _strnicmp(argv[iCurrentArg], "-?", sizeof("-?"))) ||
        (0 == _strnicmp(argv[iCurrentArg], "/?", sizeof("/?"))))
    {
        g_Command.eCmd = eCommand_HELP;
        PrintHelp();
        return FALSE;
    }
    
    if ((0 == _strnicmp(argv[iCurrentArg], "-?a", sizeof("-?a"))) ||
        (0 == _strnicmp(argv[iCurrentArg], "/?a", sizeof("/?a"))))
    {
        g_Command.eCmd = eCommand_HELP;
        PrintHelp(TRUE);
        return FALSE;
    }
    
    // Options specifed.
    if (argc == 4 || argc == 3)
    {
        BOOL fHasOptions = FALSE;
        
        CHAR *pChar = argv[iCurrentArg];
        
        if (*pChar == '-')
        {
            pChar++;
        }
        else
        {
            PrintHelp();
            return FALSE;
        }
        
        while(*pChar != '\0')
        {
            if (*pChar == 't')
            {
                g_Options.fEnableTimer = TRUE;
                fHasOptions = TRUE;
            }
            pChar++;
        }
        
        if (fHasOptions)
        {
            iCurrentArg++;
        }
    }
    
    //
    // 1. Try to match with supported commands.
    //
    //
    BOOL fRequiredMDPath = TRUE;
    
    for (UINT iArg = 0; iArg < rgComMax; iArg++)
    {
        if (0 == _strnicmp(argv[iCurrentArg], rgCommand[iArg].szCommandLineSwitch, (strlen(rgCommand[iArg].szCommandLineSwitch) + 1)))
        {
            g_Command = rgCommand[iArg];
            fFound = TRUE;
            break;
        }
    }
    
    if (fFound == TRUE && g_Command.fRequireMDPath == TRUE)
    {
        iCurrentArg++;
        g_Command.szMetabasePath = argv[iCurrentArg];
        if (!g_Command.szMetabasePath)
        {
            fFound = FALSE;
        }
    }
    
    if (fFound != TRUE)
    {
        PrintHelp();
        return FALSE;
    }
    
    return TRUE;
}

VOID	Report_Time(double dElaspedSec)
{
    if  (g_Options.fEnableTimer)
    {
        printf("PERF[VP]:%f\n", dElaspedSec);
    }
    return;
}

void PrintHelp(BOOL fAdvanced)
{
    UINT	cLine = 0;
    UINT	i = 0;
    if (fAdvanced)
    {
        cLine = sizeof(ppszAdvancedHelpFile) / sizeof(char *);
        for (i = 0; i < cLine; i++)
        {
            printf("%s", ppszAdvancedHelpFile[i]);
        }
    }
    else
    {
        cLine = sizeof(ppszHelpFile) / sizeof(char *);
        for (i = 0; i < cLine; i++)
        {
            printf("%s", ppszHelpFile[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamregps\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamregps\wamreg_i_stub.c ===
#include "wamreg_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamregps\wamreg_p_stub.c ===
#include "wamreg_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wam\wamreg\vptool\util.h ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: VPTOOL   a WAMREG unit testing tool

File: util.cpp

Owner: leijin

Description:
Contains utility functions used by vptool.
    Including Debugging, timing, helping functions.

Note:
===================================================================*/

#ifndef _VPTOOL_UTIL_H_
#define _VPTOOL_UTIL_H_

#include <stdio.h>
#include <wtypes.h>

enum eCommand 
{ 
	eCommand_INSTALL = 1,
	eCommand_UNINSTALL,
	eCommand_UPGRADE,
	eCommand_CREATEINPROC,
	eCommand_CREATEOUTPROC,
	eCommand_CREATEINPOOL,
	eCommand_DELETE,
	eCommand_GETSTATUS,
	eCommand_UNLOAD,
	eCommand_DELETEREC,
	eCommand_RECOVER,
	eCommand_GETSIGNATURE,
	eCommand_SERIALIZE,
	eCommand_DESERIALIZE,
	eCommand_HELP,
        eCommand_2CREATE,
        eCommand_2DELETE,
        eCommand_2CREATEPOOL,
        eCommand_2DELETEPOOL,
        eCommand_2ENUMPOOL,
        eCommand_2RECYCLEPOOL,
        eCommand_2GETMODE,
        eCommand_2TestConn
};
		
struct CommandParam
{
	eCommand	eCmd;
	char		*szCommandLineSwitch;	
	char		*szMetabasePath;
	bool		fRequireMDPath;
};
typedef struct CommandParam CommandParam;

BOOL 	ParseCommandLine(int argc, char **argv);
void 	PrintHelp(BOOL fAdvanced = FALSE);

DWORD	Timer();
VOID	Report_Time(double ElaspedSec);

extern	const UINT rgComMax;
extern	CommandParam g_Command;

//
//
struct VP_Options
{
	BOOL	fEnableTimer;
};

extern	VP_Options	g_Options;


//-----------------------------------------------------------------------------
// CStopWatch
//-----------------------------------------------------------------------------

// This class implements a simple stopwatch timer.

class CStopWatch
{
public:
	CStopWatch()
	{
		Reset();
	}

	//~CStopWatch()
	//{ }

	void Start()
	{
		QueryPerformanceCounter( (LARGE_INTEGER *) &m_liBeg );
	}

	void Stop()
	{
		//LARGE_INTEGER liTmp;
		__int64 liEnd;
		QueryPerformanceCounter( (LARGE_INTEGER *) &liEnd );
		m_liTotal += liEnd - m_liBeg;
	}

	void Reset()
	{
		m_liBeg = m_liTotal = 0;
	}
	
	// Return time in seconds.
	double GetElapsedSec()
	{
		//LARGE_INTEGER liFreq;
		__int64 liFreq;
		QueryPerformanceFrequency( (LARGE_INTEGER *) &liFreq );	// Counts/sec
		if (liFreq == 0)
		{
			// Who knows?  Hardware does not support.
			// Maybe millisec?
			// This is rare; modern PC's return liFreq.
			liFreq = 1000;
		}
		return (double) m_liTotal / (double) liFreq;
	}

private:
	//LARGE_INTEGER m_liBeg;
	//LARGE_INTEGER m_liTotal;
	__int64 m_liBeg;
	__int64 m_liTotal;
};

#endif	// _VPTOOL_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      BasePage.h
//
//  Abstract:
//      Definition of the CBasePropertyPage class.  This class provides base
//      functionality for extension DLL property pages.
//
//  Implementation File:
//      BasePage.cpp
//      BasePage.inl
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"    // for CDialogHelp
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
    CBasePropertyPage(void);
    CBasePropertyPage(
        IN const CMapCtrlToHelpID * pmap
        );
    CBasePropertyPage(
        IN const CMapCtrlToHelpID * pmap,
        IN UINT                     nIDTemplate,
        IN UINT                     nIDCaption = 0
        );
    virtual ~CBasePropertyPage(void) { }

    // Second phase construction.
    virtual BOOL        BInit(IN OUT CExtObject * peo);

protected:
    void                CommonConstruct(void);

// Attributes
protected:
    CExtObject *        m_peo;
    HPROPSHEETPAGE      m_hpage;

    IDD                 m_iddPropertyPage;
    IDD                 m_iddWizardPage;
    IDC                 m_idcPPTitle;
    IDS                 m_idsCaption;

    CExtObject *        Peo(void) const                 { return m_peo; }
    HPROPSHEETPAGE      Hpage(void) const               { return m_hpage; }

    IDD                 IddPropertyPage(void) const     { return m_iddPropertyPage; }
    IDD                 IddWizardPage(void) const       { return m_iddWizardPage; }
    IDS                 IdsCaption(void) const          { return m_idsCaption; }

public:
    void                SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }

// Dialog Data
    //{{AFX_DATA(CBasePropertyPage)
    enum { IDD = 0 };
    //}}AFX_DATA
    CStatic m_staticIcon;
    CStatic m_staticTitle;
    CString m_strTitle;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CBasePropertyPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual DWORD           DwParseUnknownProperty(
                                IN LPCWSTR                          pwszName,
                                IN const CLUSPROP_BUFFER_HELPER &   rvalue
                                )       { return ERROR_SUCCESS; }
    virtual BOOL            BApplyChanges(void);
    virtual void            BuildPropList(IN OUT CClusPropList & rcpl);

    virtual const CObjectProperty * Pprops(void) const  { return NULL; }
    virtual DWORD                   Cprops(void) const  { return 0; }

// Implementation
protected:
    BOOL                    m_bBackPressed;
    BOOL					m_bDoDetach;

    BOOL                    BBackPressed(void) const        { return m_bBackPressed; }
    IWCWizardCallback *     PiWizardCallback(void) const;
    BOOL                    BWizard(void) const;
    HCLUSTER                Hcluster(void) const;
    void                    EnableNext(IN BOOL bEnable = TRUE);

    DWORD                   DwParseProperties(IN const CClusPropList & rcpl);
    DWORD                   DwSetPrivateProps(IN const CClusPropList & rcpl);

    DWORD                   DwReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT CString &       rstrValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT DWORD *         pdwValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT LPBYTE *        ppbValue,
                                IN HKEY             hkey
                                );

    DWORD                   DwWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const CString &  rstrValue,
                                IN OUT CString &    rstrPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN DWORD            dwValue,
                                IN OUT DWORD *      pdwPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   DwWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue,
                                IN HKEY             hkey
                                );

    void                    SetHelpMask(IN DWORD dwMask)    { m_dlghelp.SetHelpMask(dwMask); }
    CDialogHelp             m_dlghelp;

    // Generated message map functions
    //{{AFX_MSG(CBasePropertyPage)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnChangeCtrl();
    DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\constdef.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      ConstDef.h
//
//  Abstract:
//      Definitions of constants used in the IIS Cluster Administrator
//      extension.
//
//  Author:
//      David Potter (davidp)   March 7, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CONSTDEF_H_
#define _CONSTDEF_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_IIS_SERVICE_NAME               _T("ServiceName")
#define REGPARAM_IIS_DIRECTORY                  _T("Directory")
#define REGPARAM_IIS_INSTANCEID                 _T("InstanceId")
#define REGPARAM_IIS_ACCOUNTNAME                _T("AccountName")
#define REGPARAM_IIS_PASSWORD                   _T("Password")
#define REGPARAM_IIS_ACCESSMASK                 _T("AccessMask")

#define RESTYPE_NAME_IIS_VIRTUAL_ROOT           _T("IIS Server Instance")
#define RESTYPE_NAME_SMTP_VIRTUAL_ROOT          _T("SMTP Server Instance")
#define RESTYPE_NAME_NNTP_VIRTUAL_ROOT          _T("NNTP Server Instance")

#define IIS_SVC_NAME_FTP                        _T("MSFTPSVC")
#define IIS_SVC_NAME_WWW                        _T("W3SVC")
#define IIS_SVC_NAME_SMTP                       _T("SMTPSVC")
#define IIS_SVC_NAME_NNTP                       _T("NNTPSVC")

#define MD_SERVICE_ROOT_FTP                     _T("LM/MSFTPSVC")
#define MD_SERVICE_ROOT_WWW                     _T("LM/W3SVC")
#define MD_SERVICE_ROOT_SMTP                    _T("LM/SMTPSVC")
#define MD_SERVICE_ROOT_NNTP                    _T("LM/NNTPSVC")

/////////////////////////////////////////////////////////////////////////////

#endif // _CONSTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Abstract:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	October 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

IWCWizardCallback * CBasePropertyPage::PiWizardCallback(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->PiWizardCallback();
}

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.cpp
//
//	Abstract:
//		Implementation of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_Number
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		dwValue		[IN OUT] Value to set or get.
//		dwMin		[IN] Minimum value.
//		dwMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned
	)
{
	HWND	hwndCtrl;
	DWORD	dwValue;

	ASSERT(pDX != NULL);
	ASSERT(dwMin < dwMax);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the control window handle.
	hwndCtrl = pDX->PrepareEditCtrl(nIDC);

	if (pDX->m_bSaveAndValidate)
	{
		BOOL	bTranslated;

		dwValue = GetDlgItemInt(pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned);
		if (!bTranslated
				|| (dwValue < dwMin)
				|| (dwValue > dwMax)
				)
		{
			TCHAR szMin[32];
			TCHAR szMax[32];
			CString strPrompt;

			wsprintf(szMin, _T("%lu%"), dwMin);
			wsprintf(szMax, _T("%lu%"), dwMax);
			AfxFormatString2(strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
			strPrompt.Empty(); // exception prep
			pDX->Fail();
		}  // if:  invalid string
		else
			rdwValue = dwValue;
	}  // if:  saving data
	else
	{
		CString		strMaxValue;

		// Set the maximum number of characters that can be entered.
		if (bSigned)
			strMaxValue.Format(_T("%ld"), dwMax);
		else
			strMaxValue.Format(_T("%lu"), dwMax);
		SendMessage(hwndCtrl, EM_LIMITTEXT, strMaxValue.GetLength(), 0);

		// Set the value into the control.
		DDX_Text(pDX, nIDC, rdwValue);
	}  // else:  setting data onto the dialog

}  //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT(pDX != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pDX->m_bSaveAndValidate)
	{
		if (rstrValue.GetLength() == 0)
		{
			HWND		hwndLabel;
			TCHAR		szLabel[1024];
			TCHAR		szStrippedLabel[1024];
			int			iSrc;
			int			iDst;
			TCHAR		ch;
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

			// Get the text of the label.
			GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

			// Remove ampersands (&) and colons (:).
			for (iSrc = 0, iDst = 0 ; szLabel[iSrc] != _T('\0') ; iSrc++)
			{
				ch = szLabel[iSrc];
				if ((ch != _T('&')) && (ch != _T(':')))
					szStrippedLabel[iDst++] = ch;
			}  // for:  each character in the label
			szStrippedLabel[iDst] = _T('\0');

			// Format and display a message.
			strPrompt.FormatMessage(IDS_REQUIRED_FIELD_EMPTY, szStrippedLabel);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl(nIDC);

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		}  // if:  field not specified
	}  // if:  saving data

}  //*** DDV_RequiredText()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      BasePage.cpp
//
//  Abstract:
//      Implementation of the CBasePropertyPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "IISClEx4.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"
#include "PropList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBasePropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CBasePropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pmap            [IN] Control to help ID map.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const CMapCtrlToHelpID * pmap
    )
    : m_dlghelp(pmap, 0)
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pmap            [IN] Control to help ID map.
//      nIDTemplate     [IN] Dialog template resource ID.
//      nIDCaption      [IN] Caption string resource ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const CMapCtrlToHelpID * pmap,
    IN UINT                     nIDTemplate,
    IN UINT                     nIDCaption
    )
    : CPropertyPage(nIDTemplate, nIDCaption)
    , m_dlghelp(pmap, nIDTemplate)
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct(void)
{
    //{{AFX_DATA_INIT(CBasePropertyPage)
    //}}AFX_DATA_INIT

    m_peo = NULL;
    m_hpage = NULL;
    m_bBackPressed = FALSE;
	m_bDoDetach = FALSE;

    m_iddPropertyPage = NULL;
    m_iddWizardPage = NULL;
    m_idcPPTitle = NULL;
    m_idsCaption = NULL;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BInit(IN OUT CExtObject * peo)
{
    ASSERT(peo != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_peo = peo;

    // Don't display a help button.
    m_psp.dwFlags &= ~PSP_HASHELP;

    // Construct the property page.
    if (Peo()->BWizard())
    {
        ASSERT(IddWizardPage() != NULL);
        Construct(IddWizardPage(), IdsCaption());
        m_dlghelp.SetHelpMask(IddWizardPage());
    }  // if:  adding page to wizard
    else
    {
        ASSERT(IddPropertyPage() != NULL);
        Construct(IddPropertyPage(), IdsCaption());
        m_dlghelp.SetHelpMask(IddPropertyPage());
    }  // else:  adding page to property sheet

    // Read the properties private to this resource and parse them.
    {
        DWORD           dwStatus;
        CClusPropList   cpl;

        ASSERT(Peo() != NULL);
        ASSERT(Peo()->PrdResData() != NULL);
        ASSERT(Peo()->PrdResData()->m_hresource != NULL);

        // Read the properties.
        dwStatus = cpl.DwGetResourceProperties(
                                Peo()->PrdResData()->m_hresource,
                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                                );

        // Parse the properties.
        if (dwStatus == ERROR_SUCCESS)
        {
            // Parse the properties.
            try
            {
                dwStatus = DwParseProperties(cpl);
            }  // try
            catch (CMemoryException * pme)
            {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  properties read successfully

        if (dwStatus != ERROR_SUCCESS)
        {
            return FALSE;
        }  // if:  error parsing getting or parsing properties
    }  // Read the properties private to this resource and parse them

    return TRUE;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwParseProperties
//
//  Routine Description:
//      Parse the properties of the resource.  This is in a separate function
//      from BInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwParseProperties(IN const CClusPropList & rcpl)
{
    DWORD                           cProps;
    DWORD                           cprop;
    const CObjectProperty *         pprop;
    CLUSPROP_BUFFER_HELPER          props;
    CLUSPROP_PROPERTY_NAME const *  pName;

    ASSERT(rcpl.PbProplist() != NULL);

    props.pb = rcpl.PbProplist();

    // Loop through each property.
    for (cProps = *(props.pdw++) ; cProps > 0 ; cProps--)
    {
        pName = props.pName;
        ASSERT(pName->Syntax.dw == CLUSPROP_SYNTAX_NAME);
        props.pb += sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

        // Parse known properties.
        for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
        {
            if (lstrcmpiW(pName->sz, pprop->m_pwszName) == 0)
            {
                ASSERT(props.pSyntax->wFormat == pprop->m_propFormat);
                switch (pprop->m_propFormat)
                {
                    case CLUSPROP_FORMAT_SZ:
                        *pprop->m_value.pstr = props.pStringValue->sz;
                        *pprop->m_valuePrev.pstr = props.pStringValue->sz;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                        *pprop->m_value.pdw = props.pDwordValue->dw;
                        *pprop->m_valuePrev.pdw = props.pDwordValue->dw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        *pprop->m_value.ppb = props.pBinaryValue->rgb;
                        *pprop->m_value.pcb = props.pBinaryValue->cbLength;
                        *pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
                        *pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
                        break;
                    default:
                        ASSERT(0);  // don't know how to deal with this type
                }  // switch:  property format

                // Exit the loop since we found the parameter.
                break;
            }  // if:  found a match
        }  // for:  each property

        // If the property wasn't known, ask the derived class to parse it.
        if (cprop == 0)
        {
            DWORD       dwStatus;

            dwStatus = DwParseUnknownProperty(pName->sz, props);
            if (dwStatus != ERROR_SUCCESS)
                return dwStatus;
        }  // if:  property not parsed

        // Advance the pointer.
        if ((props.pSyntax->wFormat == CLUSPROP_FORMAT_BINARY)
                || (props.pSyntax->wFormat == CLUSPROP_FORMAT_SZ)
                || (props.pSyntax->wFormat == CLUSPROP_FORMAT_MULTI_SZ))
            props.pb += sizeof(*props.pBinaryValue)
                        + ALIGN_CLUSPROP(props.pBinaryValue->cbLength)
                        + sizeof(*props.pSyntax); // endmark
        else if (props.pSyntax->wFormat == CLUSPROP_FORMAT_DWORD)
            props.pb += sizeof(*props.pDwordValue) + sizeof(*props.pSyntax);
        else
        {
            ASSERT(0); // Unknown property syntax
            break;
        }  // else:  unknown property format
    }  // for:  each property

    return ERROR_SUCCESS;

}  //*** CBasePropertyPage::DwParseProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCreate
//
//	Routine Description:
//		Handler for the WM_CREATE message.
//
//	Arguments:
//		lpCreateStruct	[IN OUT] Window create structure.
//
//	Return Value:
//		-1		Error.
//		0		Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Attach the window to the property page structure.
	// This has been done once already in the main application, since the
	// main application owns the property sheet.  It needs to be done here
	// so that the window handle can be found in the DLL's handle map.
	if (FromHandlePermanent(m_hWnd) == NULL) // is the window handle already in the handle map
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach(hWnd);
		m_bDoDetach = TRUE;
	} // if: is the window handle in the handle map

	return CPropertyPage::OnCreate(lpCreateStruct);

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnDestroy
//
//	Routine Description:
//		Handler for the WM_DESTROY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Detach the window from the property page structure.
	// This will be done again by the main application, since it owns the
	// property sheet.  It needs to be done here so that the window handle
	// can be removed from the DLL's handle map.
	if (m_bDoDetach)
	{
		if (m_hWnd != NULL)
		{
			HWND hWnd = m_hWnd;

			Detach();
			m_hWnd = hWnd;
		} // if: do we have a window handle?
	} // if: do we need to balance the attach we did with a detach?

	CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange(CDataExchange * pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBasePropertyPage)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
    DDX_Control(pDX, m_idcPPTitle, m_staticTitle);

    if (!pDX->m_bSaveAndValidate)
    {
        // Set the title.
        DDX_Text(pDX, m_idcPPTitle, m_strTitle);
    }  // if:  not saving data

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog(void)
{
    ASSERT(Peo() != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    // Call the base class method.
    CPropertyPage::OnInitDialog();

    // Display an icon for the object.
    if (Peo()->Hicon() != NULL)
        m_staticIcon.SetIcon(Peo()->Hicon());

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive(void)
{
    HRESULT     hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Reread the data.
    hr = Peo()->HrGetObjectInfo();
    if (hr != NOERROR)
        return FALSE;

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    m_bBackPressed = FALSE;
    return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnApply
//
//  Routine Description:
//      Handler for the PSM_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply(void)
{
    ASSERT(!BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Update the data in the class from the page.
    UpdateData(/*bSaveAndValidate*/);

    if (!BApplyChanges())
        return FALSE;

    return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardBack
//
//  Routine Description:
//      Handler for the PSN_WIZBACK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack(void)
{
    LRESULT     lResult;

    ASSERT(BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    lResult = CPropertyPage::OnWizardBack();
    if (lResult != -1)
        m_bBackPressed = TRUE;

    return lResult;

}  //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardNext
//
//  Routine Description:
//      Handler for the PSN_WIZNEXT message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext(void)
{
    ASSERT(BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Update the data in the class from the page.
    UpdateData(/*bSaveAndValidate*/);

    // Save the data in the sheet.
    if (!BApplyChanges())
        return -1;

    // Create the object.

    return CPropertyPage::OnWizardNext();

}  //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardFinish
//
//  Routine Description:
//      Handler for the PSN_WIZFINISH message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      FALSE   Don't change the page.
//      TRUE    Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish(void)
{
    ASSERT(BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Update the data in the class from the page.
    UpdateData(/*bSaveAndValidate*/);

    // Save the data in the sheet.
    if (!BApplyChanges())
        return FALSE;

    return CPropertyPage::OnWizardFinish();

}  //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnChangeCtrl
//
//  Routine Description:
//      Handler for the messages sent when a control is changed.  This
//      method can be specified in a message map if all that needs to be
//      done is enable the Apply button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetModified(TRUE);

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::EnableNext
//
//  Routine Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext(IN BOOL bEnable /*TRUE*/)
{
    ASSERT(BWizard());
    ASSERT(PiWizardCallback());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PiWizardCallback()->EnableNext((LONG *) Hpage(), bEnable);

}  //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD           dwStatus    = ERROR_SUCCESS;
    CClusPropList   cpl(BWizard() /*bAlwaysAddProp*/);

    // Save data.
    {
        // Build the property list.
        try
        {
            BuildPropList(cpl);
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }  // catch:  CMemoryException

        // Set the data.
        if (dwStatus == ERROR_SUCCESS)
            dwStatus = DwSetPrivateProps(cpl);

        // Handle errors.
        if (dwStatus != ERROR_SUCCESS)
        {
            CString     strError;
            CString     strMsg;

            AFX_MANAGE_STATE(AfxGetStaticModuleState());

            FormatError(strError, dwStatus);
            if (dwStatus == ERROR_RESOURCE_PROPERTIES_STORED)
            {
                AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
                dwStatus = ERROR_SUCCESS;
            }  // if:  properties were stored
            else
            {
                strMsg.FormatMessage(IDS_APPLY_PARAM_CHANGES_ERROR, strError);
                AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
            }  // else:  error setting properties.
        }  // if:  error setting properties

        if (dwStatus == ERROR_SUCCESS)
        {
            // Save new values as previous values.
            try
            {
                DWORD                   cprop;
                const CObjectProperty * pprop;

                for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
                {
                    switch (pprop->m_propFormat)
                    {
                        case CLUSPROP_FORMAT_SZ:
                            ASSERT(pprop->m_value.pstr != NULL);
                            ASSERT(pprop->m_valuePrev.pstr != NULL);
                            *pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
                            break;
                        case CLUSPROP_FORMAT_DWORD:
                            ASSERT(pprop->m_value.pdw != NULL);
                            ASSERT(pprop->m_valuePrev.pdw != NULL);
                            *pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
                            break;
                        case CLUSPROP_FORMAT_BINARY:
                        case CLUSPROP_FORMAT_MULTI_SZ:
                            ASSERT(pprop->m_value.ppb != NULL);
                            ASSERT(*pprop->m_value.ppb != NULL);
                            ASSERT(pprop->m_value.pcb != NULL);
                            ASSERT(pprop->m_valuePrev.ppb != NULL);
                            ASSERT(*pprop->m_valuePrev.ppb != NULL);
                            ASSERT(pprop->m_valuePrev.pcb != NULL);
                            delete [] *pprop->m_valuePrev.ppb;
                            *pprop->m_valuePrev.ppb = new BYTE[*pprop->m_value.pcb];
                            CopyMemory(*pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb);
                            *pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
                            break;
                        default:
                            ASSERT(0);  // don't know how to deal with this type
                    }  // switch:  property format
                }  // for:  each property
            }  // try
            catch (CMemoryException * pme)
            {
                pme->ReportError();
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  properties set successfully
    }  // Save data

    return TRUE;

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::BuildPropList(
    IN OUT CClusPropList & rcpl
    )
{
    DWORD                   cprop;
    const CObjectProperty * pprop;

    for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
    {
        switch (pprop->m_propFormat)
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.AddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.AddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pdw,
                        *pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.AddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.ppb,
                        *pprop->m_value.pcb,
                        *pprop->m_valuePrev.ppb,
                        *pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT(0);  // don't know how to deal with this type
                return;
        }  // switch:  property format
    }  // for:  each property

}  //*** CBasePropertyPage::BuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwSetPrivateProps
//
//  Routine Description:
//      Set the private properties for this object.
//
//  Arguments:
//      rcpl        [IN] Property list to set on the object.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was completed successfully.
//      !0              Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwSetPrivateProps(
    IN const CClusPropList &    rcpl
    )
{
    DWORD       dwStatus;
    DWORD       cbProps;

    ASSERT(Peo() != NULL);
    ASSERT(Peo()->PrdResData());
    ASSERT(Peo()->PrdResData()->m_hresource);

    if ((rcpl.PbProplist() != NULL) && (rcpl.CbProplist() > 0))
    {
        // Set private properties.
        dwStatus = ClusterResourceControl(
                        Peo()->PrdResData()->m_hresource,
                        NULL,   // hNode
                        CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                        rcpl.PbProplist(),
                        rcpl.CbProplist(),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

}  //*** CBasePropertyPage::DwSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwReadValue
//
//  Routine Description:
//      Read a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      rstrValue       [OUT] String in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwReadValue(
    IN LPCTSTR      pszValueName,
    OUT CString &   rstrValue,
    IN HKEY         hkey
    )
{
    DWORD       dwStatus;
    LPWSTR      pwszValue   = NULL;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(hkey != NULL);

    rstrValue.Empty();

    try
    {
        // Get the size of the value.
        dwValueLen = 0;
        dwStatus = ::ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ((dwStatus == ERROR_SUCCESS) || (dwStatus == ERROR_MORE_DATA))
        {
            ASSERT(dwValueType == REG_SZ);

            // Allocate enough space for the data.
            pwszValue = rstrValue.GetBuffer(dwValueLen / sizeof(WCHAR));
            ASSERT(pwszValue != NULL);
            dwValueLen += 1 * sizeof(WCHAR);    // Don't forget the final null-terminator.

            // Read the value.
            dwStatus = ::ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE) pwszValue,
                            &dwValueLen
                            );
            if (dwStatus == ERROR_SUCCESS)
            {
                ASSERT(dwValueType == REG_SZ);
            }  // if:  value read successfully
            rstrValue.ReleaseBuffer();
        }  // if:  got the size successfully
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    return dwStatus;

}  //*** CBasePropertyPage::DwReadValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pdwValue        [OUT] DWORD in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwReadValue(
    IN LPCTSTR      pszValueName,
    OUT DWORD *     pdwValue,
    IN HKEY         hkey
    )
{
    DWORD       dwStatus;
    DWORD       dwValue;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwValue != NULL);
    ASSERT(hkey != NULL);

    *pdwValue = 0;

    // Read the value.
    dwValueLen = sizeof(dwValue);
    dwStatus = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    (LPBYTE) &dwValue,
                    &dwValueLen
                    );
    if (dwStatus == ERROR_SUCCESS)
    {
        ASSERT(dwValueType == REG_DWORD);
        ASSERT(dwValueLen == sizeof(dwValue));
        *pdwValue = dwValue;
    }  // if:  value read successfully

    return dwStatus;

}  //*** CBasePropertyPage::DwReadValue(LPCTSTR, DWORD*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwReadValue
//
//  Routine Description:
//      Read a REG_BINARY value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      ppbValue        [OUT] Pointer in which to return the data.  Caller
//                          is responsible for deallocating the data.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwReadValue(
    IN LPCTSTR      pszValueName,
    OUT LPBYTE *    ppbValue,
    IN HKEY         hkey
    )
{
    DWORD       dwStatus;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(ppbValue != NULL);
    ASSERT(hkey != NULL);

    *ppbValue = NULL;

    // Get the length of the value.
    dwValueLen = 0;
    dwStatus = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    NULL,
                    &dwValueLen
                    );
    if (dwStatus != ERROR_MORE_DATA)
        return dwStatus;

    ASSERT(dwValueType == REG_BINARY);

    // Allocate a buffer,
    try
    {
        *ppbValue = new BYTE[dwValueLen];
    }  // try
    catch (CMemoryException *)
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        return dwStatus;
    }  // catch:  CMemoryException

    // Read the value.
    dwStatus = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    *ppbValue,
                    &dwValueLen
                    );
    if (dwStatus != ERROR_SUCCESS)
    {
        delete [] *ppbValue;
        *ppbValue = NULL;
    }  // if:  value read successfully

    return dwStatus;

}  //*** CBasePropertyPage::DwReadValue(LPCTSTR, LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwWriteValue
//
//  Routine Description:
//      Write a REG_SZ value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      rstrValue       [IN] Value data.
//      rstrPrevValue   [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      dwStatus
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwWriteValue(
    IN LPCTSTR          pszValueName,
    IN const CString &  rstrValue,
    IN OUT CString &    rstrPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       dwStatus;

    ASSERT(pszValueName != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (rstrValue != rstrPrevValue)
    {
        dwStatus = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_SZ,
                        (CONST BYTE *) (LPCTSTR) rstrValue,
                        (rstrValue.GetLength() + 1) * sizeof(TCHAR)
                        );
        if (dwStatus == ERROR_SUCCESS)
            rstrPrevValue = rstrValue;
    }  // if:  value changed
    else
        dwStatus = ERROR_SUCCESS;
    return dwStatus;

}  //*** CBasePropertyPage::DwWriteValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwWriteValue
//
//  Routine Description:
//      Write a REG_DWORD value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      dwValue         [IN] Value data.
//      pdwPrevValue    [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      dwStatus
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwWriteValue(
    IN LPCTSTR          pszValueName,
    IN DWORD            dwValue,
    IN OUT DWORD *      pdwPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       dwStatus;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwPrevValue != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (dwValue != *pdwPrevValue)
    {
        dwStatus = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_DWORD,
                        (CONST BYTE *) &dwValue,
                        sizeof(dwValue)
                        );
        if (dwStatus == ERROR_SUCCESS)
            *pdwPrevValue = dwValue;
    }  // if:  value changed
    else
        dwStatus = ERROR_SUCCESS;
    return dwStatus;

}  //*** CBasePropertyPage::DwWriteValue(LPCTSTR, DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwWriteValue
//
//  Routine Description:
//      Write a REG_BINARY value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pbValue         [IN] Value data.
//      cbValue         [IN] Size of value data.
//      ppbPrevValue    [IN OUT] Previous value.
//      cbPrevValue     [IN] Size of the previous data.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      dwStatus
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwWriteValue(
    IN LPCTSTR          pszValueName,
    IN const LPBYTE     pbValue,
    IN DWORD            cbValue,
    IN OUT LPBYTE *     ppbPrevValue,
    IN DWORD            cbPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       dwStatus;
    LPBYTE      pbPrevValue = NULL;

    ASSERT(pszValueName != NULL);
    ASSERT(pbValue != NULL);
    ASSERT(ppbPrevValue != NULL);
    ASSERT(cbValue > 0);
    ASSERT(hkey != NULL);

    // See if the data has changed.
    if (cbValue == cbPrevValue)
    {
        if (memcmp(pbValue, *ppbPrevValue, cbValue) == 0)
            return ERROR_SUCCESS;
    }  // if:  lengths are the same

    // Allocate a new buffer for the previous data pointer.
    try
    {
        pbPrevValue = new BYTE[cbValue];
    }
    catch (CMemoryException *)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException
    ::CopyMemory(pbPrevValue, pbValue, cbValue);

    // Write the value if it hasn't changed.
    dwStatus = ::ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_BINARY,
                    pbValue,
                    cbValue
                    );
    if (dwStatus == ERROR_SUCCESS)
    {
        delete [] *ppbPrevValue;
        *ppbPrevValue = pbPrevValue;
    }  // if:  set was successful
    else
        delete [] pbPrevValue;

    return dwStatus;

}  //*** CBasePropertyPage::DwWriteValue(LPCTSTR, const LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE        Help processed.
//      FALSE       Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
    BOOL    bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
    if (!bProcessed)
        bProcessed = CDialog::OnHelpInfo(pHelpInfo);
    return bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      wParam      [IN] WPARAM.
//      lParam      [IN] LPARAM.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    BOOL    bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    bProcessed = (BOOL)m_dlghelp.OnCommandHelp(wParam, lParam);
    if (!bProcessed)
        bProcessed = (BOOL)CDialog::OnCommandHelp(wParam, lParam);

    return bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Abstract:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DDXDDV_H_
#define _DDXDDV_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _DDXDDV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\excoper.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOper.h
//
//	Abstract:
//		Definition of the exception classes.
//
//	Author:
//		David Potter (davidp)	May 20, 1996
//
//	Implementation File:
//		ExcOper.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXCOPER_H_
#define _EXCOPER_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExceptionWithOper;
class CNTException;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef DWORD SC;

#define EXCEPT_MAX_OPER_ARG_LENGTH	260

/////////////////////////////////////////////////////////////////////////////
// CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

class CExceptionWithOper : public CException
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CExceptionWithOper)

public:
// Constructors
	CExceptionWithOper(
		IN IDS		idsOperation,
		IN LPCTSTR	pszOperArg1		= NULL,
		IN LPCTSTR	pszOperArg2		= NULL
		);
	CExceptionWithOper(
		IN IDS		idsOperation,
		IN LPCTSTR	pszOperArg1,
		IN LPCTSTR	pszOperArg2,
		IN BOOL		bAutoDelete
		);

// Operations
public:
	virtual BOOL	GetErrorMessage(
						LPTSTR	lpszError,
						UINT	nMaxError,
						PUINT	pnHelpContext = NULL
						);
	virtual int		ReportError(
						UINT	nType	= MB_OK,
						UINT	nError	= 0
						);
	void			SetOperation(
						IN IDS		idsOperation,
						IN LPCTSTR	pszOperArg1,
						IN LPCTSTR	pszOperArg2
						);
	void			FormatWithOperation(
						OUT LPTSTR	lpszError,
						IN UINT		nMaxError,
						IN LPCTSTR	pszMsg
						);

// Implementation
public:
	virtual ~CExceptionWithOper(void);

protected:
	IDS				m_idsOperation;
	TCHAR			m_szOperArg1[EXCEPT_MAX_OPER_ARG_LENGTH];
	TCHAR			m_szOperArg2[EXCEPT_MAX_OPER_ARG_LENGTH];

public:
	IDS				IdsOperation(void)		{ return m_idsOperation; }
	LPTSTR			PszOperArg1(void)		{ return m_szOperArg1; }
	LPTSTR			PszOperArg2(void)		{ return m_szOperArg2; }

};  //*** class CExceptionWithOper

/////////////////////////////////////////////////////////////////////////////
// CNTException
/////////////////////////////////////////////////////////////////////////////

class CNTException : public CExceptionWithOper
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CNTException)

public:
// Constructors
	CNTException(
		IN SC		sc,
		IN IDS		idsOperation	= NULL,
		IN LPCTSTR	pszOperArg1		= NULL,
		IN LPCTSTR	pszOperArg2		= NULL
		);
	CNTException(
		IN SC		sc,
		IN IDS		idsOperation,
		IN LPCTSTR	pszOperArg1,
		IN LPCTSTR	pszOperArg2,
		IN BOOL		bAutoDelete
		);

// Operations
public:
	virtual BOOL	GetErrorMessage(
						LPTSTR	lpszError,
						UINT	nMaxError,
						PUINT	pnHelpContext = NULL
						);
	void			SetOperation(
						IN SC		sc,
						IN IDS		idsOperation,
						IN LPCTSTR	pszOperArg1,
						IN LPCTSTR	pszOperArg2
						)
					{
						m_sc = sc;
						CExceptionWithOper::SetOperation(idsOperation, pszOperArg1, pszOperArg2);
					}

// Implementation
public:
	virtual ~CNTException(void);

protected:
	SC				m_sc;

public:
	SC				Sc(void)		{ return m_sc; }

};  //*** class CNTException

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void ThrowStaticException(
	IN IDS			idsOperation	= NULL,
	IN LPCTSTR		pszOperArg1		= NULL,
	IN LPCTSTR		pszOperArg2		= NULL
	);
void ThrowStaticException(
	IN SC			sc,
	IN IDS			idsOperation	= NULL,
	IN LPCTSTR		pszOperArg1		= NULL,
	IN LPCTSTR		pszOperArg2		= NULL
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _CAEXCEPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\excoper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOper.cpp
//
//	Abstract:
//		Implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	May 20, 1996
//
//	Revision History:
//
//	Notes:
//		stdafx.h, TraceTag.h, and resource.h are all pulled from the project
//		directory.
//
//		stdafx.h must have an IDS typedef and disable some W4 warnings.
//
//		TraceTag.h must define TraceError.
//
//		resource.h must define IDS_UNKNOWN_ERROR, and the string must be
//		defined something like "Error %d (0x%08.8x)." in the resource file.
//
/////////////////////////////////////////////////////////////////////////////

#include <string.h>
#include "ExcOper.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CExceptionWithOper, CException)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::CExceptionWithOper
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExceptionWithOper::CExceptionWithOper(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	SetOperation(idsOperation, pszOperArg1, pszOperArg2);

}  //*** CExceptionWithOper::CExceptionWithOper()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::CExceptionWithOper
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//		bAutoDelete		[IN] Auto-delete the exception in Delete().
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExceptionWithOper::CExceptionWithOper(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2,
	IN BOOL			bAutoDelete
	) : CException(bAutoDelete)
{
	SetOperation(idsOperation, pszOperArg1, pszOperArg2);

}  //*** CExceptionWithOper::CExceptionWithOper()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::~CExceptionWithOper
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExceptionWithOper::~CExceptionWithOper(void)
{
}  //*** CExceptionWithOper::~CExceptionWithOper()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::GetErrorMessage
//
//	Routine Description:
//		Get the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pnHelpContext	[OUT] Help context for the error message.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExceptionWithOper::GetErrorMessage(
	LPTSTR	lpszError,
	UINT	nMaxError,
	PUINT	pnHelpContext
	)
{
	// Format the operation string.
	FormatWithOperation(lpszError, nMaxError, NULL);

	return TRUE;

}  //*** CExceptionWithOper::GetErrorMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::ReportError
//
//	Routine Description:
//		Report an error from the exception.  Overriding to get a bigger
//		error message buffer.
//
//	Arguments:
//		nType		[IN] Type of message box.
//		nError		[IN] ID of a mesage to display if exception has no message.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
	UINT nType /* = MB_OK */,
	UINT nError /* = 0 */
	)
{
	TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
	int     nDisposition;
	UINT    nHelpContext;

	if (GetErrorMessage(szErrorMessage, sizeof(szErrorMessage) / sizeof(TCHAR), &nHelpContext))
		nDisposition = AfxMessageBox(szErrorMessage, nType, nHelpContext);
	else
	{
		if (nError == 0)
			nError = AFX_IDP_NO_ERROR_AVAILABLE;
		nDisposition = AfxMessageBox(nError, nType, nHelpContext);
	}
	return nDisposition;

}  //*** CExceptionWithOper::ReportError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::SetOperation
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::SetOperation(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	m_idsOperation = idsOperation;

	if (pszOperArg1 == NULL)
		m_szOperArg1[0] = _T('\0');
	else
	{
		::_tcsncpy(m_szOperArg1, pszOperArg1, (sizeof(m_szOperArg1) / sizeof(TCHAR)) - 1);
		m_szOperArg1[(sizeof(m_szOperArg1) / sizeof(TCHAR))- 1] = _T('\0');
	}  // else:  first argument specified

	if (pszOperArg2 == NULL)
		m_szOperArg2[0] = _T('\0');
	else
	{
		::_tcsncpy(m_szOperArg2, pszOperArg2, (sizeof(m_szOperArg2) / sizeof(TCHAR)) - 1);
		m_szOperArg2[(sizeof(m_szOperArg2) / sizeof(TCHAR)) - 1] = _T('\0');
	}  // else:  second argument specified

}  //*** CExceptionWithOper::SetOperation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::FormatWithOperation
//
//	Routine Description:
//		Get the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pszMsg			[IN] Message to format with the operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::FormatWithOperation(
	OUT LPTSTR	lpszError,
	IN UINT		nMaxError,
	IN LPCTSTR	pszMsg
	)
{
	DWORD		dwResult;
	TCHAR		szOperation[EXCEPT_MAX_OPER_ARG_LENGTH];
	TCHAR		szFmtOperation[EXCEPT_MAX_OPER_ARG_LENGTH * 3];

	ASSERT(lpszError != NULL);
	ASSERT(nMaxError > 0);

	// Format the operation string.
	if (m_idsOperation)
	{
		void *		rgpvArgs[2]	= { m_szOperArg1, m_szOperArg2 };

		// Load the operation string.
		dwResult = ::LoadString(AfxGetApp()->m_hInstance, m_idsOperation, szOperation, (sizeof(szOperation) / sizeof(TCHAR)));
		ASSERT(dwResult != 0);

		// Format the operation string.
		::FormatMessage(
					FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
					szOperation,
					0,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					szFmtOperation,
					sizeof(szFmtOperation) / sizeof(TCHAR),
					(va_list *) rgpvArgs
					);
//		::_sntprintf(szFmtOperation, (sizeof(szFmtOperation) / sizeof(TCHAR)) - 1, szOperation, m_szOperArg1, m_szOperArg2);
		szFmtOperation[(sizeof(szFmtOperation) / sizeof(TCHAR)) - 1] = _T('\0');

		// Format the final error message.
		if (pszMsg != NULL)
			::_sntprintf(lpszError, nMaxError - 1, _T("%s\n\n%s"), szFmtOperation, pszMsg);
		else
			::_tcsncpy(lpszError, szFmtOperation, nMaxError - 1);
		lpszError[nMaxError - 1] = _T('\0');
	}  // if:  operation string specified
	else
	{
		if (pszMsg != NULL)
		{
			::_tcsncpy(lpszError, pszMsg, nMaxError - 1);
			lpszError[nMaxError - 1] = _T('\0');
		}  // if:  additional message specified
		else
			lpszError[0] = _T('\0');
	}  // else:  no operation string specified

}  //*** CExceptionWithOper::FormatWithOperation()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CException
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNTException, CExceptionWithOper)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::CNTException
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		sc				[IN] NT status code.
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNTException::CNTException(
	IN SC			sc,
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	) : CExceptionWithOper(idsOperation, pszOperArg1, pszOperArg2)
{
	m_sc = sc;

}  //*** CNTException::CNTException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::CNTException
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		sc				[IN] NT status code.
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//		bAutoDelete		[IN] Auto-delete the exception in Delete().
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNTException::CNTException(
	IN SC			sc,
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2,
	IN BOOL			bAutoDelete
	) : CExceptionWithOper(idsOperation, pszOperArg1, pszOperArg2, bAutoDelete)
{
	m_sc = sc;

}  //*** CNTException::CNTException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::~CNTException
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNTException::~CNTException(void)
{
}  //*** CNTException::~CNTException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::GetErrorMessage
//
//	Routine Description:
//		Get the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pnHelpContext	[OUT] Help context for the error message.
//
//	Return Value:
//		TRUE		Message available.
//		FALSE		No message available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNTException::GetErrorMessage(
	LPTSTR	lpszError,
	UINT	nMaxError,
	PUINT	pnHelpContext
	)
{
	DWORD		dwResult;
	TCHAR		szNtMsg[128];


	// Format the NT status code from the system.
	dwResult = ::FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
					NULL,
					m_sc,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					szNtMsg,
					sizeof(szNtMsg) / sizeof(TCHAR),
					0
					);
	if (dwResult == 0)
	{
		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		dwResult = ::FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						::GetModuleHandle(_T("NTDLL.DLL")),
						m_sc,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
						szNtMsg,
						sizeof(szNtMsg) / sizeof(TCHAR),
						0
						);
		if (dwResult == 0)
		{
			TCHAR		szErrorFmt[EXCEPT_MAX_OPER_ARG_LENGTH];

			dwResult = ::LoadString(AfxGetApp()->m_hInstance, IDS_UNKNOWN_ERROR, szErrorFmt, (sizeof(szErrorFmt) / sizeof(TCHAR)));
			ASSERT(dwResult != 0);
			::_sntprintf(szNtMsg, sizeof(szNtMsg) / sizeof(TCHAR), szErrorFmt, m_sc, m_sc);
		}  // if:  error formatting status code from NTDLL
	}  // if:  error formatting status code from system

	// Format the message with the operation string.
	FormatWithOperation(lpszError, nMaxError, szNtMsg);

	return TRUE;

}  //*** CNTException::GetErrorMessage()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

static CNTException			gs_nte(ERROR_SUCCESS, NULL, NULL, NULL, FALSE);
static CExceptionWithOper	gs_ewo(NULL, NULL, NULL, FALSE);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ThrowStaticException
//
//	Purpose:
//		Throw the static NT Exception.
//
//	Arguments:
//		sc				[IN] NT status code.
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Returns:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
	IN SC			sc,
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	gs_nte.SetOperation(sc, idsOperation, pszOperArg1, pszOperArg2);
	TraceError(gs_nte);
	throw &gs_nte;

}  //*** ThrowStaticException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ThrowStaticException
//
//	Purpose:
//		Throw the static Cluster Administrator Exception.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Returns:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
	IN IDS			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	gs_ewo.SetOperation(idsOperation, pszOperArg1, pszOperArg2);
	TraceError(gs_ewo);
	throw &gs_ewo;

}  //*** ThrowStaticException()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\dlghelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      DlgHelp.cpp
//
//  Abstract:
//      Implementation of the CDialogHelp class.
//
//  Author:
//      David Potter (davidp)   February 6, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagDlgHelp(_T("Help"), _T("DLG HELP"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDialogHelp, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::CDialogHelp
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pmap        [IN] Map array mapping control IDs to help IDs.
//      dwMask      [IN] Mask to use for the low word of the help ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDialogHelp::CDialogHelp(IN const CMapCtrlToHelpID * pmap, IN DWORD dwMask)
{
    ASSERT(pmap != NULL);

    CommonConstruct();
    m_pmap = pmap;
    m_dwMask = dwMask;

}  //*** CDialogHelp::CDialogHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::CommonConstruct
//
//  Routine Description:
//      Do common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::CommonConstruct(void)
{
    m_pmap = NULL;

}  //*** CDialogHelp::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::NHelpFromCtrlID
//
//  Routine Description:
//      Return the help ID from a control ID.
//
//  Arguments:
//      nCtrlID     [IN] ID of control to search for.
//
//  Return Value:
//      nHelpID     Help ID associated with the control.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDialogHelp::NHelpFromCtrlID(IN DWORD nCtrlID) const
{
    DWORD                       nHelpID = 0;
    const CMapCtrlToHelpID *    pmap = Pmap();

    ASSERT(pmap != NULL);
    ASSERT(nCtrlID != 0);

    for ( ; pmap->m_nCtrlID != 0 ; pmap++)
    {
        if (pmap->m_nCtrlID == nCtrlID)
        {
            if (pmap->m_nHelpCtrlID == -1)
                nHelpID = (DWORD) -1;
            else
                //nHelpID = (pmap->m_nHelpCtrlID << 16) | (DwMask() & 0xFFFF);
                nHelpID = pmap->m_nHelpCtrlID;
            break;
        }  // if:  found a match
    }  // for:  each control

    Trace(g_tagDlgHelp, _T("NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x"), nCtrlID, nHelpID);

    return nHelpID;

}  //*** CDialogHelp::NHelpFromCtrlID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::OnContextMenu(CWnd * pWnd, CPoint point)
{
    CWnd *  pwndChild;
    CPoint  ptDialog;
    DWORD   nHelpID = 0;

    ASSERT(pWnd != NULL);

    m_nHelpID = 0;

    // Convert the point into dialog coordinates.
    ptDialog = point;
    pWnd->ScreenToClient(&ptDialog);

    // Find the control the cursor is over.
    {
        DWORD   nCtrlID;

        pwndChild = pWnd->ChildWindowFromPoint(ptDialog);
        if (pwndChild != NULL && pwndChild->m_hWnd != NULL)
        {
            nCtrlID = pwndChild->GetDlgCtrlID();
            if (nCtrlID != 0)
                nHelpID = NHelpFromCtrlID(nCtrlID);
        }  // if:  over a child window
    }  // Find the control the cursor is over

    // Display a popup menu.
    if ((nHelpID != 0) && (nHelpID != -1))
    {
        CString strMenu;
        CMenu   menu;

        try
        {
            strMenu.LoadString(IDS_MENU_WHATS_THIS);
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            return;
        }  // catch:  CMemoryException

        if (menu.CreatePopupMenu())
        {
            if (menu.AppendMenu(MF_STRING | MF_ENABLED, ID_HELP, strMenu))
            {
                m_nHelpID = nHelpID;
                menu.TrackPopupMenu(
                    TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                    point.x,
                    point.y,
                    AfxGetMainWnd()
                    );
            }  // if:  menu item added successfully
            menu.DestroyMenu();
        }  // if:  popup menu created successfully
    }  // if:  over a child window of this dialog with a tabstop

}  //*** CDialogHelp::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDialogHelp::OnHelpInfo(HELPINFO * pHelpInfo)
{
    // If this is for a control, display control-specific help.
    if ((pHelpInfo->iContextType == HELPINFO_WINDOW)
            && (pHelpInfo->iCtrlId != 0))
    {
        DWORD   nHelpID = NHelpFromCtrlID(pHelpInfo->iCtrlId);
        if (nHelpID != 0)
        {
            if (nHelpID != -1)
                AfxGetApp()->WinHelp(nHelpID, HELP_CONTEXTPOPUP);
            return TRUE;
        }  // if:  found the control in the list
    }  // if:  need help on a specific control

    // Display dialog help.
    return FALSE;

}  //*** CDialogHelp::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDialogHelp::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      WPARAM      [IN] Passed on to base class method.
//      lParam      [IN] Help ID.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CDialogHelp::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    if (m_nHelpID != 0)
        lParam = m_nHelpID;
    AfxGetApp()->WinHelp((DWORD)lParam, HELP_CONTEXTPOPUP);
    return TRUE;
//  return CDialog::OnCommandHelp(wParam, lParam);

}  //*** CDialogHelp::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\dlghelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.h
//
//	Abstract:
//		Definition of the CDialogHelp class.
//
//	Implementation File:
//		DlgHelp.cpp
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#define _DLGHELP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
	DWORD	m_nCtrlID;
	DWORD	m_nHelpCtrlID;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp dialog
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp : public CObject
{
	DECLARE_DYNAMIC(CDialogHelp)

// Construction
public:
	CDialogHelp(void) { CommonConstruct(); }
	CDialogHelp(const CMapCtrlToHelpID * pmap, DWORD dwMask);

	void CommonConstruct(void);

// Attributes
protected:
	const CMapCtrlToHelpID *	m_pmap;
	DWORD						m_dwMask;
	DWORD						m_nHelpID;

public:
	const CMapCtrlToHelpID *	Pmap(void) const	{ return m_pmap; }
	DWORD						DwMask(void) const	{ return m_dwMask; }
	DWORD						NHelpID(void) const	{ return m_nHelpID; }

	DWORD						NHelpFromCtrlID(IN DWORD nCtrlID) const;

// Operations
public:
	void		SetHelpMask(IN DWORD dwMask)	{ ASSERT(dwMask != 0); m_dwMask = dwMask; }

	void		OnContextMenu(CWnd * pWnd, CPoint point);
	BOOL		OnHelpInfo(HELPINFO * pHelpInfo);
	LRESULT		OnCommandHelp(WPARAM wParam, LPARAM lParam);

// Overrides

// Implementation

};  //*** class CDialogHelp

/////////////////////////////////////////////////////////////////////////////

#endif // _DLGHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Implementation of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Author:
//		David Potter (davidp)	August 29, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "IISClEx4.h"
#include "ExtObj.h"

#include "Iis.h"
#include "smtpprop.h"
#include "nntpprop.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
		RESTYPE_NAME_IIS_VIRTUAL_ROOT L"\0"
		RESTYPE_NAME_SMTP_VIRTUAL_ROOT L"\0"
		RESTYPE_NAME_NNTP_VIRTUAL_ROOT L"\0"
		L"\0"
		;
const DWORD g_cchResourceTypeNames	= sizeof(g_wszResourceTypeNames) / sizeof(WCHAR);

static CRuntimeClass * g_rgprtcPSIISPages[]	= {
	RUNTIME_CLASS(CIISVirtualRootParamsPage),
	NULL
	};

static CRuntimeClass * g_rgprtcPSSMTPPages[] = {
	RUNTIME_CLASS(CSMTPVirtualRootParamsPage),
	NULL
	};

static CRuntimeClass * g_rgprtcPSNNTPPages[] = {
	RUNTIME_CLASS(CNNTPVirtualRootParamsPage),
	NULL
	};

static CRuntimeClass ** g_rgpprtcPSPages[]	= {
	g_rgprtcPSIISPages,
	g_rgprtcPSSMTPPages,
	g_rgprtcPSNNTPPages
	};

// Wizard pages and property sheet pages are the same.
static CRuntimeClass ** g_rgpprtcWizPages[]	= {
	g_rgprtcPSIISPages,
	g_rgprtcPSSMTPPages,
	g_rgprtcPSNNTPPages
	};

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CExtObject
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
	m_piData = NULL;
	m_piWizardCallback = NULL;
	m_bWizard = FALSE;
	m_istrResTypeName = 0;

	m_hcluster = NULL;
	m_lcid = NULL;
	m_hfont = NULL;
	m_hicon = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::~CExtObject
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
	// Release the data interface.
	if (PiData() != NULL)
	{
		PiData()->Release();
		m_piData = NULL;
	}  // if:  we have a data interface pointer

	// Release the wizard callback interface.
	if (PiWizardCallback() != NULL)
	{
		PiWizardCallback()->Release();
		m_piWizardCallback = NULL;
	}  // if:  we have a wizard callback interface pointer

	// Delete the pages.
	{
		POSITION	pos;

		pos = Lpg().GetHeadPosition();
		while (pos != NULL)
			delete Lpg().GetNext(pos);
	}  // Delete the pages
    
}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//	Routine Description:
//		Indicates whether an interface suportes the IErrorInfo interface.
//		This interface is provided by ATL.
//
//	Arguments:
//		riid		Interface ID.
//
//	Return Value:
//		S_OK		Interface supports IErrorInfo.
//		S_FALSE		Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID * rgiid[] = 
	{
		&IID_IWEExtendPropertySheet,
		&IID_IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
		&IID_IWEExtendContextMenu,
#endif
	};
	int		iiid;

	for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
	{
		if (InlineIsEqualGUID(*rgiid[iiid], riid))
			return S_OK;
	}
	return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//	Routine Description:
//		Create property sheet pages and add them to the sheet.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the sheet is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
	IN IUnknown *					piData,
	IN IWCPropertySheetCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try 
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		// Add each page for this type of resource.
		for (irtc = 0 ; g_rgpprtcPSPages[IstrResTypeName()][irtc] != NULL ; irtc++)
		{
			// Create the property pages.
			ppage = (CBasePropertyPage *) g_rgpprtcPSPages[IstrResTypeName()][irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(g_rgpprtcPSPages[IstrResTypeName()][irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddPropertySheetPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page for the type of resource
	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add property page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add property page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreateWizardPages (IWEExtendWizard)
//
//	Routine Description:
//		Create property sheet pages and add them to the wizard.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the wizard is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
	IN IUnknown *			piData,
	IN IWCWizardCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try 
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		m_piWizardCallback = piCallback;
		m_bWizard = TRUE;

		// Add each page for this type of resource.
		for (irtc = 0 ; g_rgpprtcWizPages[IstrResTypeName()][irtc] != NULL ; irtc++)
		{
			// Create the property pages.
			ppage = (CBasePropertyPage *) g_rgpprtcWizPages[IstrResTypeName()][irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(g_rgpprtcWizPages[IstrResTypeName()][irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddWizardPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page for the type of resource
	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add wizard page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add wizard page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piCallback->Release();
		// see description of bug #298124
        if (m_piWizardCallback == piCallback)
        {
            m_piWizardCallback = NULL;
        }
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	return hr;

}  //*** CExtObject::CreateWizardPages()

#ifdef _DEMO_CTX_MENUS
/////////////////////////////////////////////////////////////////////////////
// IWEExtendContextMenu Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::AddContextMenuItems (IWEExtendContextMenu)
//
//	Routine Description:
//		Add items to a context menu.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the context menu is being displayed.
//		piCallback		Pointer to an IWCContextMenuCallback interface
//							for adding menu items to the context menu.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_FAIL			Error adding context menu item.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes returned by HrSaveData() or IWCContextMenuCallback::
//		AddExtensionMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::AddContextMenuItems(
	IN IUnknown *				piData,
	IN IWCContextMenuCallback *	piCallback
	)
{
	HRESULT			hr		= NOERROR;
	CException		exc(FALSE /*bAutoDelete*/);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try 
	{
		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Add menu items specific to this resource type.
		{
			ULONG		iCommandID;
			LPWSTR		pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
			LPWSTR		pwszName;
			LPWSTR		pwszStatusBarText;

			for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
			{
				pwszName = pwsz;
				pwszStatusBarText = pwszName + (::wcslen(pwszName) + 1);
				hr = piCallback->AddExtensionMenuItem(
									pwszName,			// lpszName
									pwszStatusBarText,	// lpszStatusBarText
									iCommandID,			// lCommandID
									0,					// lSubCommandID
									0					// uFlags
									);
				if (hr != NOERROR)
					throw &exc;
				pwsz = pwszStatusBarText + (::wcslen(pwszStatusBarText) + 1);
			}  // while:  more menu items to add
		}  // Add menu items specific to this resource type
	}  // try
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add context menu item\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
// IWEInvokeCommand Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InvokeCommand (IWEInvokeCommand)
//
//	Routine Description:
//		Invoke a command offered by a context menu.
//
//	Arguments:
//		lCommandID		ID of the menu item to execute.  This is the same
//							ID passed to the IWCContextMenuCallback
//							::AddExtensionMenuItem() method.
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the command is to be invoked.
//
//	Return Value:
//		NOERROR			Command invoked successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::InvokeCommand(
	IN ULONG		nCommandID,
	IN IUnknown *	piData
	)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Find the item that was executed in our table.
	hr = HrSaveData(piData);
	if (hr == NOERROR)
	{
		ULONG		iCommandID;
		LPWSTR		pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
		LPWSTR		pwszName;
		LPWSTR		pwszStatusBarText;

		for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
		{
			pwszName = pwsz;
			pwszStatusBarText = pwszName + (::wcslen(pwszName) + 1);
			if (iCommandID == nCommandID)
				break;
			pwsz = pwszStatusBarText + (::wcslen(pwszStatusBarText) + 1);
		}  // while:  more menu items to add
		if (iCommandID == nCommandID)
		{
			CString		strMsg;
			CString		strName;

			try
			{
				strName = pwszName;
				strMsg.Format(_T("Item %s was executed"), strName);
				AfxMessageBox(strMsg);
			}  // try
			catch (CException * pe)
			{
				pe->Delete();
			}  // catch:  CException
		}  // if:  command ID found
	}  // if:  no errors saving the data

	piData->Release();
	m_piData = NULL;
	return NOERROR;

}  //*** CExtObject::InvokeCommand()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetUIInfo
//
//	Routine Description:
//		Get info about displaying UI.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	// Save info about all types of objects.
	{
		IGetClusterUIInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_lcid = pi->GetLocale();
		m_hfont = pi->GetFont();
		m_hicon = pi->GetIcon();

		pi->Release();
	}  // Save info about all types of objects

	return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrSaveData
//
//	Routine Description:
//		Save data from the object so that it can be used for the life
//		of the object.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	if (piData != m_piData)
	{
		if (m_piData != NULL)
			m_piData->Release();
		m_piData = piData;
	}  // if:  different data interface pointer

	// Save info about all types of objects.
	{
		IGetClusterDataInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_hcluster = pi->GetClusterHandle();
		m_cobj = pi->GetObjectCount();
		if (Cobj() != 1)
			hr = E_NOTIMPL;
		else
			hr = HrGetClusterName(pi);

		pi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Save info about all types of objects

	// Save info about this object.
	hr = HrGetObjectInfo();
	if (hr != NOERROR)
		return hr;

    //
    // Get the handle of the node we are running on.
    //

    WCHAR   wcsNodeName[MAX_COMPUTERNAME_LENGTH+1] = L"";
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH+1;
    
    if ( ClusterResourceStateUnknown != 
        GetClusterResourceState(m_rdResData.m_hresource, wcsNodeName, &dwLength, NULL, 0))
    {
        m_strNodeName = wcsNodeName;
    }

	return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectInfo
//
//	Routine Description:
//		Get information about the object.
//
//	Arguments:
//		None.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
	HRESULT						hr	= NOERROR;
	IGetClusterObjectInfo *		piGcoi;
	IGetClusterResourceInfo *	piGcri;
	CException					exc(FALSE /*bAutoDelete*/);

	ASSERT(PiData() != NULL);

	// Get an IGetClusterObjectInfo interface pointer.
	hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
	if (hr != NOERROR)
		return hr;

	// Read the object data.
	try
	{
		// Get the type of the object.
		m_rdResData.m_cot = piGcoi->GetObjectType(0);
		if (m_rdResData.m_cot != CLUADMEX_OT_RESOURCE)
		{
			hr = E_NOTIMPL;
			throw &exc;
		}  // if:  not a resource

		hr = HrGetObjectName(piGcoi);
	}  // try
	catch (CException * pe)
	{
		pe->Delete();
	}  // catch:  CException

	piGcoi->Release();
	if (hr != NOERROR)
		return hr;

	// Get an IGetClusterResourceInfo interface pointer.
	hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
	if (hr != NOERROR)
		return hr;

	m_rdResData.m_hresource = piGcri->GetResourceHandle(0);
	hr = HrGetResourceTypeName(piGcri);

	// See if we know about this resource type.
	if (hr == NOERROR)
	{
		LPCWSTR	pwszResTypeName;

		// Find the resource type name in our list.
		// Save the index for use in other arrays.
		for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames
				; *pwszResTypeName != L'\0'
				; m_istrResTypeName++, pwszResTypeName += ::wcslen(pwszResTypeName) + 1
				)
		{
			if (RrdResData().m_strResTypeName.CompareNoCase(pwszResTypeName) == 0 )
				break;
		}  // for:  each resource type in the list
		if (*pwszResTypeName == L'\0')
			hr = E_NOTIMPL;
	}  // See if we know about this resource type

	piGcoi->Release();
	return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetClusterName
//
//	Routine Description:
//		Get the name of the cluster.
//
//	Arguments:
//		piData			IGetClusterDataInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetClusterName(
	IN OUT IGetClusterDataInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetClusterName(NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetClusterName(pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting cluster name

		m_strClusterName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetClusterName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectName
//
//	Routine Description:
//		Get the name of the object.
//
//	Arguments:
//		piData			IGetClusterObjectInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
	IN OUT IGetClusterObjectInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetObjectName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetObjectName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting object name

		m_rdResData.m_strName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetResourceTypeName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		piData			IGetClusterResourceInfo interface pointer for getting
//							the resource type name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
	IN OUT IGetClusterResourceInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetResourceTypeName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetResourceTypeName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting resource type name

		m_rdResData.m_strResTypeName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetResourceTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::BGetResourceNetworkName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		lpszNetName		[OUT] String in which to return the network name resource name.
//		pcchNetName		[IN OUT] Points to a variable that specifies the
//							maximum size, in characters, of the buffer.  This
//							value shold be large enough to contain
//							MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//							return it contains the actual number of characters
//							copied.
//
//	Return Value:
//		TRUE		Resource is dependent on a network name resource.
//		FALSE		Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BGetResourceNetworkName(
	OUT WCHAR *		lpszNetName,
	IN OUT DWORD *	pcchNetName
	)
{
	BOOL						bSuccess;
	IGetClusterResourceInfo *	piGcri;

	ASSERT(PiData() != NULL);

	// Get an IGetClusterResourceInfo interface pointer.
	{
		HRESULT		hr;

		hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
		if (hr != NOERROR)
		{
			SetLastError(hr);
			return FALSE;
		}  // if:  error getting the interface
	}  // Get an IGetClusterResourceInfo interface pointer

	// Get the resource network name.
	bSuccess = piGcri->GetResourceNetworkName(0, lpszNetName, pcchNetName);

	piGcri->Release();

	return bSuccess;

}  //*** CExtObject::BGetResourceNetworkName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      HelpData.cpp
//
//  Abstract:
//      Data required for implementing help.
//
//  Author:
//      David Potter (davidp)   February 19, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "HelpData.h"

/////////////////////////////////////////////////////////////////////////////
// Help ID Map for CIISVirtualRootParamsPage
/////////////////////////////////////////////////////////////////////////////

const CMapCtrlToHelpID g_rghelpmapIISParameters[] =
{
    // IIS HelpID
    { IDC_PP_ICON,                  (DWORD) -1 },
    { IDC_PP_TITLE,                 IDC_PP_TITLE },
    { IDC_PP_IIS_FTP,               IDC_PP_IIS_FTP },
    { IDC_PP_IIS_WWW,               IDC_PP_IIS_WWW },
    { IDC_PP_IIS_INSTANCEID,        IDC_PP_IIS_INSTANCEID },
    { IDC_PP_IIS_INSTANCEID_LABEL,  IDC_PP_IIS_INSTANCEID },
    { IDC_PP_REFRESH,               IDC_PP_REFRESH },

    // SMTP HelpID
    { IDC_PP_SMTP_TITLE,            IDC_PP_SMTP_TITLE },
    { IDC_PP_SMTP_INSTANCEID,       IDC_PP_SMTP_INSTANCEID },
    { IDC_PP_SMTP_INSTANCEID_LABEL, IDC_PP_SMTP_INSTANCEID },
    { IDC_PP_SMTP_REFRESH,          IDC_PP_SMTP_REFRESH },

    // NNTP HelpID
    { IDC_PP_NNTP_TITLE,            IDC_PP_NNTP_TITLE },
    { IDC_PP_NNTP_INSTANCEID,       IDC_PP_NNTP_INSTANCEID },
    { IDC_PP_NNTP_INSTANCEID_LABEL, IDC_PP_NNTP_INSTANCEID },
    { IDC_PP_NNTP_REFRESH,          IDC_PP_NNTP_REFRESH },

    { 0,                            0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_DATA and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage and CPageList
#endif

//#define _DEMO_CTX_MENUS

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject : 
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
	public IWEExtendContextMenu,
	public IWEInvokeCommand,
#endif
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoIISClEx4>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
#ifdef _DEMO_CTX_MENUS
	COM_INTERFACE_ENTRY(IWEExtendContextMenu)
	COM_INTERFACE_ENTRY(IWEInvokeCommand)
#endif
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.IIS5"), _T("CLUADMEX.IIS"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

#ifdef _DEMO_CTX_MENUS
// IWEExtendContextMenu
public:
	STDMETHOD(AddContextMenuItems)(
					IN IUnknown *				piData,
					IN IWCContextMenuCallback *	piCallback
					);

// IWEInvokeCommand
	STDMETHOD(InvokeCommand)(
					IN ULONG					nCommandID,
					IN IUnknown *				piData
					);
#endif

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterDataInfo data
	CString						m_strClusterName;
	CString                     m_strNodeName;
	HCLUSTER					m_hcluster;
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;
	LONG						m_cobj;

	CResData					m_rdResData;

	CObjData *					PodObjDataRW(void) const		{ return (CObjData *) &m_rdResData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) &m_rdResData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterDataInfo data
	const CString &				StrClusterName(void) const		{ return m_strClusterName; }
	const CString &				StrNodeName(void) const		    { return m_strNodeName; }
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CResData &			RrdResData(void) const			{ return m_rdResData; }
	const CObjData *			PodObjData(void) const			{ return &m_rdResData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) &m_rdResData; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetClusterName(IN OUT IGetClusterDataInfo * pi);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);
	BOOL						BGetResourceNetworkName(OUT WCHAR * lpszNetName, IN OUT DWORD * pcchNetName);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\iis.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Iis.cpp
//
//	Abstract:
//		Implementation of the CIISVirtualRootParamsPage class.
//
//	Author:
//		Pete Benoit (v-pbenoi)	October 16, 1996
//		David Potter (davidp)	October 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <inetinfo.h>
#include "IISClEx4.h"
#include "Iis.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"	// for g_rghelpmap*

#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <iadm.h>
#include <iiscnfgp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CIISVirtualRootParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CIISVirtualRootParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CIISVirtualRootParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CIISVirtualRootParamsPage)
	ON_CBN_SELCHANGE(IDC_PP_IIS_INSTANCEID, OnChangeRequiredField)
	ON_BN_CLICKED(IDC_PP_IIS_FTP, OnChangeServiceType)
	ON_BN_CLICKED(IDC_PP_IIS_WWW, OnChangeServiceType)
	ON_BN_CLICKED(IDC_PP_REFRESH, OnRefresh)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::CIISVirtualRootParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CIISVirtualRootParamsPage::CIISVirtualRootParamsPage(void)
	: CBasePropertyPage(g_rghelpmapIISParameters)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CIISVirtualRootParamsPage)
	m_strInstanceId = _T("");
	m_nServerType = SERVER_TYPE_WWW;
	//}}AFX_DATA_INIT


    m_fReadList = FALSE;
    
	try
	{
		m_strServiceName = IIS_SVC_NAME_WWW;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->ReportError();
		pme->Delete();
	}  // catch:  CMemoryException

	// Setup the property array.
	{
		m_rgProps[epropServiceName].Set(REGPARAM_IIS_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
		m_rgProps[epropInstanceId].Set(REGPARAM_IIS_INSTANCEID, m_strInstanceId, m_strPrevInstanceId);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_IIS_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_IIS_PARAMETERS;
	m_idcPPTitle = IDC_PP_TITLE;

}  //*** CIISVirtualRootParamsPage::CIISVirtualRootParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::DoDataExchange(CDataExchange * pDX)
{
    CString     strInstanceId;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (!pDX->m_bSaveAndValidate)
	{
		// Set the service type.
		if (m_strServiceName.CompareNoCase(IIS_SVC_NAME_FTP) == 0)
			m_nServerType = SERVER_TYPE_FTP;
		else if (m_strServiceName.CompareNoCase(IIS_SVC_NAME_WWW) == 0)
			m_nServerType = SERVER_TYPE_WWW;
		else
			m_nServerType = SERVER_TYPE_WWW;

	}  // if:  setting data to dialog

	CBasePropertyPage::DoDataExchange(pDX);
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CIISVirtualRootParamsPage)
	DDX_Control(pDX, IDC_PP_IIS_INSTANCEID, m_cInstanceId);
	DDX_Text(pDX, IDC_PP_IIS_INSTANCEID, m_strInstanceName);
	DDX_Control(pDX, IDC_PP_IIS_WWW, m_rbWWW);
	DDX_Control(pDX, IDC_PP_IIS_FTP, m_rbFTP);
	DDX_Radio(pDX, IDC_PP_IIS_FTP, m_nServerType);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (!BBackPressed())
		{
			DDV_RequiredText(pDX, IDC_PP_IIS_INSTANCEID, IDC_PP_IIS_INSTANCEID_LABEL, m_strInstanceName);
		}  // if:  Back button not pressed

        m_strInstanceId = NameToMetabaseId( m_nServerType == SERVER_TYPE_WWW, m_strInstanceName );

		// Save the type.
		if (m_nServerType == SERVER_TYPE_FTP)
			m_strServiceName = IIS_SVC_NAME_FTP;
		else if (m_nServerType == SERVER_TYPE_WWW)
			m_strServiceName = IIS_SVC_NAME_WWW;
		else
		{
			CString		strMsg;
			strMsg.LoadString(IDS_INVALID_IIS_SERVICE_TYPE);
			AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
			strMsg.Empty();
			pDX->PrepareCtrl(IDC_PP_IIS_FTP);	// do this just to set the control for Fail().
			pDX->Fail();
		}  // else:  no service type set

	}  // if:  saving data from dialog

}  //*** CIISVirtualRootParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIISVirtualRootParamsPage::OnInitDialog(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CBasePropertyPage::OnInitDialog();

	m_cInstanceId.EnableWindow( TRUE );

	//
	// Save the inital server type so it will be possible to determine if it changes (# 265510)
	//
	m_nInitialServerType = m_rbWWW.GetCheck() == BST_CHECKED ? SERVER_TYPE_WWW : SERVER_TYPE_FTP;

	OnChangeServiceType();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CIISVirtualRootParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIISVirtualRootParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		SetEnableNext();
	}  // if:  in the wizard

	return CBasePropertyPage::OnSetActive();

}  //*** CIISVirtualRootParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnChangeServiceType
//
//	Routine Description:
//		Handler for the BN_CLICKED message on one of the service type radio
//		buttons.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::OnChangeServiceType(void)
{
#if 0
	int		nCmdShowAccess;
	IDS		idsWriteLabel	= 0;

	OnChangeCtrl();

	if (m_rbFTP.GetCheck() == BST_CHECKED)
	{
		nCmdShowAccess = SW_SHOW;
		idsWriteLabel = IDS_WRITE;
	}  // if:  FTP service
	else if (m_rbWWW.GetCheck() == BST_CHECKED)
	{
		nCmdShowAccess = SW_SHOW;
		idsWriteLabel = IDS_EXECUTE;
	}  // else if:  WWW service
	else
	{
		nCmdShowAccess = SW_HIDE;
	}  // else:  unknown service

	// Set the access checkbox labels.
	if (idsWriteLabel != 0)
	{
		CString		strWriteLabel;

//		AFX_MANAGE_STATE(AfxGetStaticModuleState());
//		strWriteLabel.LoadString(idsWriteLabel);
//		m_ckbWrite.SetWindowText(strWriteLabel);
	}  // if:  write label needs to be set

#endif
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();
    m_nServerType = m_rbWWW.GetCheck() == BST_CHECKED ? SERVER_TYPE_WWW : SERVER_TYPE_FTP; 

    FillServerList();
}  //*** CIISVirtualRootParamsPage::OnChangeServiceType()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnChangeRequiredField
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::OnChangeRequiredField(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		SetEnableNext();
	}  // if:  in a wizard

}  //*** CIISVirtualRootParamsPage::OnChangeRequiredField()

////


void 
CIISVirtualRootParamsPage::FillServerList(
    )
/*++

Routine Description:

    Populate server combo box with server list relevant to current service type,
    set current selection based on server instance ID
    enable Finish button if list non empty

Arguments:

    None

Returns:

    Nothing

--*/
{

    int nIndex;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
    // build array if not already done
    //
    
    if ( !m_fReadList )
    {
        HRESULT hr1, hr2, hr;
        
        hr1 = ReadList( &m_W3Array, MD_SERVICE_ROOT_WWW, LPCTSTR(Peo()->StrNodeName()), SERVER_TYPE_WWW );
        hr2 = ReadList( &m_FTPArray, MD_SERVICE_ROOT_FTP, LPCTSTR(Peo()->StrNodeName()), SERVER_TYPE_FTP );
        
        if (FAILED(hr1) || FAILED(hr2))
        {
            CString err;

            hr = FAILED(hr1) ? hr1 : hr2;

            // 
            // (# 309917) Path not found is not a "reportable" error since it only implies there no servers of the given server type,  which is a case that is dealt with below
            //
            if( (HRESULT_FACILITY(hr) == FACILITY_WIN32) && 
                (HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND) )
            {
				OutputDebugStringW( L"[FillServerList] ReadList() returned : ERROR_PATH_NOT_FOUND\n" );
            } 
            else if ( REGDB_E_IIDNOTREG == hr)
            {
                err.Format(IDS_IIS_PROXY_MISCONFIGURED, Peo()->StrNodeName());
                AfxMessageBox(err);
            }
            else
            {
                CString fmtError;
                DWORD   dwError;

                if ( (HRESULT_FACILITY(hr) == FACILITY_WIN32) ||
                     (HRESULT_FACILITY(hr) == FACILITY_NT_BIT))
                {
                    dwError = (DWORD) HRESULT_CODE(hr);
                }
                else
                {
                    dwError = (DWORD) hr;
                }
                
                FormatError(fmtError, dwError);
                
                err.Format(IDS_ENUMERATE_FAILED, Peo()->StrNodeName(), fmtError);
                AfxMessageBox(err);
            }

            m_cInstanceId.EnableWindow(FALSE);
        }
        else
        {
            m_cInstanceId.EnableWindow(TRUE);
        }
        
        m_fReadList = TRUE;
    }

    m_strInstanceName = MetabaseIdToName( m_nServerType == SERVER_TYPE_WWW, m_strInstanceId );

    // add to combo from array

    CArray <IISMapper, IISMapper>* pArray = m_nServerType == SERVER_TYPE_WWW ? &m_W3Array : &m_FTPArray;
    DWORD  nAddCount = 0;

    m_cInstanceId.ResetContent();

    for ( nIndex = 0 ; nIndex < pArray->GetSize() ; ++nIndex )
    {
        //
        // Only add sites that are not cluster enabled or have the same ID and service type as the resource opened
        //
    
        if ( (!pArray->ElementAt(nIndex).IsClusterEnabled()) || 
             ((!lstrcmp( pArray->ElementAt( nIndex ).GetId(), m_strInstanceId)) &&
             (pArray->ElementAt( nIndex ).GetServerType() == m_nInitialServerType))
           )
        {
            if ( m_cInstanceId.AddString( pArray->ElementAt( nIndex ).GetName() ) < 0 )
            {
                OutputDebugStringW( L"Error add\n" );
            }
            else
            {
                nAddCount++;
            }
        }
    }

    if (0 == nAddCount)
    {
        m_cInstanceId.EnableWindow(FALSE);
        
        if (BWizard())
        {
            //
            // If we're here than there are no more un-clustered sites of server type (m_nServerType)
            //
            BOOL fAllClusterEnabled = TRUE;
            
            //
            // (# 265689) Before reporting that ALL instances are cluster enabled we have to check the other server type for un-clustered sites
            //
            CArray <IISMapper, IISMapper>* pOhterArray = m_nServerType == SERVER_TYPE_WWW ? &m_FTPArray : &m_W3Array ;
            
            for ( nIndex = 0 ; nIndex < pOhterArray->GetSize() ; ++nIndex )
            {
                if( !pOhterArray->ElementAt(nIndex).IsClusterEnabled() )
                {
                    fAllClusterEnabled = FALSE;
                    break;
                }
            }
            
            if( fAllClusterEnabled )
            {
                CString err;
                err.Format(IDS_ALL_INSTANCES_CLUSTER_ENABLED, Peo()->StrNodeName());
                AfxMessageBox(err);
                
            }
            EnableNext(FALSE);
        }
        
        
    }
    else
    {
        m_cInstanceId.EnableWindow(TRUE);   // # 237376

        if (BWizard())
        {
            SetEnableNext();
            m_cInstanceId.SetCurSel(0);
        }
        else
        {
            nIndex = m_cInstanceId.FindStringExact(-1, m_strInstanceName);

            if ( nIndex != CB_ERR )
            {
                m_cInstanceId.SetCurSel(nIndex);
            }
        }
    }
}


HRESULT
CIISVirtualRootParamsPage::ReadList(
    CArray <IISMapper, IISMapper>* pMapperArray,
    LPWSTR                         pszPath,
    LPCWSTR                        wcsMachineName,
    int                            nServerType
    )
/*++

Routine Description:

    Read a server list from metabase based on metabase path

Arguments:

    pMapperArray - array where to add list of ( ServerComment, InstanceId ) pairs
    pszPath - metabase path, e.g. LM/W3SVC

Returns:

    Error code, S_OK if success

--*/
{
    IMSAdminBaseW *     pcAdmCom = NULL;
    METADATA_HANDLE     hmd;
    DWORD               i;
    WCHAR               aId[METADATA_MAX_NAME_LEN+1]  = L"";
    WCHAR               aName[METADATA_MAX_NAME_LEN+1] = L"";
    INT                 cName = METADATA_MAX_NAME_LEN+1;
    HRESULT             hRes = S_OK;
    COSERVERINFO        csiMachine;
    MULTI_QI            QI = {&IID_IMSAdminBase, NULL, 0};
  
    ZeroMemory( &csiMachine, sizeof(COSERVERINFO) );
    csiMachine.pwszName = (LPWSTR)wcsMachineName;

    hRes = CoCreateInstanceEx(  GETAdminBaseCLSID(TRUE), 
                                NULL, 
                                CLSCTX_SERVER, 
                                &csiMachine,
                                1,
                                &QI
                              );

    if ( SUCCEEDED(hRes) && SUCCEEDED(QI.hr))
    {
        pcAdmCom = (IMSAdminBaseW *)QI.pItf;
        
        if( SUCCEEDED( hRes = pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                 pszPath,
                                                 METADATA_PERMISSION_READ,
                                                 5000,
                                                 &hmd)) )
        {
            for ( i = 0 ;
                  SUCCEEDED(pcAdmCom->EnumKeys( hmd, L"", aId, i )) ;
                  ++i )
            {
                METADATA_RECORD md;
                DWORD           dwReq = sizeof(aName);

                memset( &md, 0, sizeof(md) );
                
                md.dwMDDataType     = STRING_METADATA;
                md.dwMDUserType     = IIS_MD_UT_SERVER;
                md.dwMDIdentifier   = MD_SERVER_COMMENT;
                md.dwMDDataLen      = sizeof(aName);
                md.pbMDData         = (LPBYTE)aName;

                if ( SUCCEEDED( pcAdmCom->GetData( hmd, aId, &md, &dwReq) ) )
                {
                    DWORD   dwClusterEnabled = 0;

                    memset( &md, 0, sizeof(md) );
                    
                    md.dwMDDataType     = DWORD_METADATA;
                    md.dwMDUserType     = IIS_MD_UT_SERVER;
                    md.dwMDIdentifier   = MD_CLUSTER_ENABLED;
                    md.dwMDDataLen      = sizeof(dwClusterEnabled);
                    md.pbMDData         = (LPBYTE)&dwClusterEnabled;

                    pcAdmCom->GetData( hmd, aId, &md, &dwReq);
                    
                    //
                    // (# 296798) Use a default name if there is no server comment
                    //
		            if( aId && aName && (0 == lstrlen(aName)) )
                    {
					        if( !LoadString(AfxGetResourceHandle( ), IDS_DEFAULT_SITE_NAME, aName, cName) )
					        {
                   			       OutputDebugStringW( L"Error Loading IDS_DEFAULT_SITE_NAME\n" );
					        }
					
			                lstrcat(aName, aId);
                    }

                    IISMapper*  pMap = new IISMapper( aName, aId, dwClusterEnabled, nServerType );
                    
                    if ( pMap )
                    {
                        pMapperArray->Add( *pMap );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                        break;
                    }
                }
            }

            pcAdmCom->CloseKey( hmd );
        }

        pcAdmCom->Release();
    }

    return hRes;
}


LPWSTR
CIISVirtualRootParamsPage::NameToMetabaseId(
    BOOL        fIsW3,
    CString&    strName
    )
/*++

Routine Description:

    Convert ServerComment to InstanceId

Arguments:

    fIsW3 - TRUE for WWW, FALSE for FTP
    strName - ServerComment

Returns:

    InstanceId if strName found in array, otherwise NULL

--*/
{
    CArray <IISMapper, IISMapper>* pArray = fIsW3 ? &m_W3Array : &m_FTPArray;
    DWORD   i;

    for ( i = 0 ; i < (DWORD)pArray->GetSize() ; ++i )
    {
        if ( !pArray->ElementAt( i ).GetName().Compare( strName ) )
        {
            return (LPWSTR)(LPCTSTR)(pArray->ElementAt( i ).GetId());
        }
    }

    return NULL;
}


LPWSTR
CIISVirtualRootParamsPage::MetabaseIdToName(
    BOOL        fIsW3,
    CString&    strId
    )
/*++

Routine Description:

    Convert InstanceId to ServerComment

Arguments:

    fIsW3 - TRUE for WWW, FALSE for FTP
    strId - InstanceID

Returns:

    InstanceId if strName found in array. 
    If not found return 1st array element if array not empty, otherwise NULL

--*/
{
    CArray <IISMapper, IISMapper>* pArray = fIsW3 ? &m_W3Array : &m_FTPArray;
    DWORD   i;

    for ( i = 0 ; i < (DWORD)pArray->GetSize() ; ++i )
    {
        if ( !pArray->ElementAt( i ).GetId().Compare( strId ) )
        {
            return (LPWSTR)(LPCTSTR)(pArray->ElementAt( i ).GetName());
        }
    }

    return pArray->GetSize() == 0 ? NULL : (LPWSTR)(LPCTSTR)(pArray->ElementAt( 0 ).GetName());
}


VOID
CIISVirtualRootParamsPage::SetEnableNext(
    VOID
    )
/*++

Routine Description:

    Set enable state of Finish button

Arguments:

    None

Returns:

    Nothing

--*/
{
    BOOL fAllClusterEnabled = TRUE;
    CArray <IISMapper, IISMapper>* pArray = m_nServerType == SERVER_TYPE_WWW ? &m_W3Array : &m_FTPArray;
    
    for (int nIndex = 0 ; nIndex < pArray->GetSize() ; ++nIndex )
    {
        if( !pArray->ElementAt(nIndex).IsClusterEnabled() )
        {
            fAllClusterEnabled = FALSE;
            break;
        }
    }
   
    
    fAllClusterEnabled = !fAllClusterEnabled;
    
    EnableNext( fAllClusterEnabled );
}

void CIISVirtualRootParamsPage::OnRefresh() 
{
	m_fReadList = FALSE;

	m_W3Array.RemoveAll();
	m_FTPArray.RemoveAll();
	
	FillServerList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\iis.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Iis.h
//
//	Abstract:
//		Definition of the CIISVirtualRootParamsPage class, which implements the
//		Parameters page for IIS resources.
//
//	Implementation File:
//		Iis.cpp
//
//	Author:
//		Pete Benoit (v-pbenoi)	October 16, 1996
//		David Potter (davidp)	October 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IIS_H_
#define _IIS_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#include "ConstDef.h"   // for IIS_SVC_NAME_WWW/IIS_SVC_NAME_FTP

#define SERVER_TYPE_FTP     0
#define SERVER_TYPE_WWW     1
#define SERVER_TYPE_UNKNOWN    -1

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CIISVirtualRootParamsPage;
class IISMapper;

//
// Private prototypes
//

class IISMapper {
public:
    IISMapper() {}
    
    IISMapper( LPWSTR pszName, LPWSTR pszId, BOOL fClusterEnabled, int nServerType = SERVER_TYPE_UNKNOWN)
        :   m_strName           ( pszName ), 
            m_strId             ( pszId ),
            m_fClusterEnabled   ( fClusterEnabled),
            m_nServerType       ( nServerType )
    {
    }
    
    CString& GetName()  { return m_strName; }
    CString& GetId()    { return m_strId; }
    int      GetServerType() { return m_nServerType; }
    BOOL     IsClusterEnabled() { return m_fClusterEnabled; }
    

private:
    CString     m_strName;
    CString     m_strId;
    BOOL        m_fClusterEnabled;
    int         m_nServerType;
} ;

/////////////////////////////////////////////////////////////////////////////
//
//	CIISVirtualRootParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CIISVirtualRootParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CIISVirtualRootParamsPage)

// Construction
public:
	CIISVirtualRootParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CIISVirtualRootParamsPage)
	enum { IDD = IDD_PP_IIS_PARAMETERS };
	CButton	m_ckbWrite;
	CButton	m_ckbRead;
	CButton	m_groupAccess;
	CEdit	m_editPassword;
	CStatic	m_staticPassword;
	CEdit	m_editAccountName;
	CStatic	m_staticAccountName;
	CButton	m_groupAccountInfo;
	CEdit	m_editDirectory;
	CButton	m_rbWWW;
	CButton	m_rbFTP;
	int		m_nServerType;
	int     m_nInitialServerType;
	CString	m_strDirectory;
    CString	m_strAccountName;
	CString	m_strPassword;
	CEdit	m_editInstanceId;
        CComboBox m_cInstanceId;
    CString m_strInstanceName;
    CString m_strInstanceId;
	BOOL	m_bRead;
	BOOL	m_bWrite;
	//}}AFX_DATA
	CString m_strServiceName;
	CString m_strPrevServiceName;
	CString	m_strPrevDirectory;
    CString	m_strPrevAccountName;
	CString	m_strPrevPassword;
	CString	m_strPrevInstanceId;
    DWORD   m_dwAccessMask;
    DWORD   m_dwPrevAccessMask;

protected:
	enum
	{
		epropServiceName,
		epropInstanceId,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIISVirtualRootParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    void FillServerList();
    void SetEnableNext();


private:
    BOOL   m_fReadList;
    CArray <IISMapper, IISMapper>  m_W3Array, m_FTPArray;

    LPWSTR  NameToMetabaseId( BOOL  fIsW3, CString&  strName);
    LPWSTR  MetabaseIdToName( BOOL  fIsW3, CString&  strId);
    HRESULT ReadList(CArray <IISMapper, IISMapper>* pMapperArray, LPWSTR pszPath, LPCWSTR wcsServerName, int nServerType);


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIISVirtualRootParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	afx_msg void OnChangeServiceType();
	afx_msg void OnRefresh();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CIISVirtualRootParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _IIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\iisclex4.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		IISClEx3.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		IISClEx3.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IISCLEX3_H_
#define _IISCLEX3_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"

#ifndef _CONSTDEF_H_
#include "ConstDef.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // _IISCLEX3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\iisclex4.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//      Copyright (c) 1996-1997 Microsoft Corporation
//
//      Module Name:
//              IISClEx4.cpp
//
//      Abstract:
//              Implementation of the CIISCluExApp class and DLL initialization
//              routines.
//
//      Author:
//              David Potter (davidp)   June 28, 1996
//
//      Revision History:
//
//      Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "IISClEx4.h"
#include "ExtObj.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#include <atlimpl.cpp>

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_CoIISClEx4, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
STDAPI DllCanUnloadNow(void);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
HRESULT HrDeleteKey(IN const CString & rstrKey);
STDAPI DllGetCluAdminExtensionCaps(
        OUT DWORD *             pdwCaps,
        OUT CLSID *             pclsid,
        OUT LPWSTR              pwszResTypeNames,
        IN OUT DWORD *  pcchResTypeNames
        );

/////////////////////////////////////////////////////////////////////////////
// class CIISCluExApp
/////////////////////////////////////////////////////////////////////////////

class CIISCluExApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();

private:
    TCHAR   szHelpPath[MAX_PATH+1];
};

CIISCluExApp theApp;

BOOL CIISCluExApp::InitInstance()
{
        _Module.Init(ObjectMap, m_hInstance);

        //
        // Setup the help file
        //

        if (GetWindowsDirectory(szHelpPath, MAX_PATH))
        {
            lstrcat(szHelpPath,_T("\\help\\iishelp\\iis\\winhelp\\iisclex4.hlp"));
            m_pszHelpFilePath = szHelpPath;
        }
                
        return CWinApp::InitInstance();
}

int CIISCluExApp::ExitInstance()
{
        m_pszHelpFilePath = NULL;
        _Module.Term();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        HRESULT hRes = S_OK;
        // registers object, typelib and all interfaces in typelib
        hRes = _Module.RegisterServer(FALSE /*bRegTypeLib*/);
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
        HRESULT hRes = S_OK;
        _Module.UnregisterServer();
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      FormatError
//
//      Routine Description:
//              Format an error.
//
//      Arguments:
//              rstrError       [OUT] String in which to return the error message.
//              dwError         [IN] Error code to format.
//
//      Return Value:
//              None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
        DWORD           dwResult;
        TCHAR           szError[256];

        dwResult = ::FormatMessage(
                                        FORMAT_MESSAGE_FROM_SYSTEM,
                                        NULL,
                                        dwError,
                                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                        szError,
                                        sizeof(szError) / sizeof(TCHAR),
                                        0
                                        );
        if (dwResult == 0)
        {
                // Format the NT status code from NTDLL since this hasn't been
                // integrated into the system yet.
                dwResult = ::FormatMessage(
                                                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                                                ::GetModuleHandle(_T("NTDLL.DLL")),
                                                dwError,
                                                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                                szError,
                                                sizeof(szError) / sizeof(TCHAR),
                                                0
                                                );
                if (dwResult == 0)
                {
                        // Format the NT status code from CLUSAPI.  This is necessary
                        // for the cases where cluster messages haven't been added to
                        // the system message file yet.
                        dwResult = ::FormatMessage(
                                                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                                                        ::GetModuleHandle(_T("CLUSAPI.DLL")),
                                                        dwError,
                                                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                                        szError,
                                                        sizeof(szError) / sizeof(TCHAR),
                                                        0
                                                        );
                }  // if:  error formatting status code from NTDLL
        }  // if:  error formatting status code from system

        if (dwResult != 0)
                rstrError = szError;
        else
        {
                TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), dwResult, dwError);
                rstrError.Format(_T("Error 0x%08.8x"));
        }  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//      DllGetCluAdminExtensionCaps
//
//      Routine Description:
//              Returns the CLSID supported by this extension.
//
//      Arguments:
//              pdwCaps                         [OUT] DWORD in which to return extension capabilities.
//              pclsid                          [OUT] Place in which to return the CLSID.
//              pwszResTypeNames        [OUT] Buffer in which to return the resource type
//                                                        names supported by this extension.  Each name is
//                                                        null-terminated.  Two nulls follow the last name.
//              pcchResTypeNames        [IN OUT] On input, contains the number of characters
//                                                        available in the output buffer, including the
//                                                        null-terminators.  On output, contains the
//                                                        total number of characters written, not
//                                                        including the null-terminator.
//
//      Return Value:
//              S_OK                    Capabilities returned successfully.
//              E_INVALIDARG    Invalid argument specified.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetCluAdminExtensionCaps(
        OUT DWORD *             pdwCaps,
        OUT CLSID *             pclsid,
        OUT LPWSTR              pwszResTypeNames,
        IN OUT DWORD *  pcchResTypeNames
        )
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // Validate arguments.
        if ((pdwCaps == NULL)
                        || (pclsid == NULL)
                        || (pwszResTypeNames == NULL)
                        || (pcchResTypeNames == NULL)
                        || (*pcchResTypeNames < 1)
                        )
                return E_INVALIDARG;

        // Set capabilities flags.
        *pdwCaps = 0
                        //| CLUADMEX_CAPS_RESOURCE_PAGES
                        ;

        // Copy the CLSID to the caller's buffer.
        CopyMemory(pclsid, &CLSID_CoIISClEx4, sizeof(CLSID));

        // Return the resource type names we support.
        {
                DWORD   cchCopy = min(g_cchResourceTypeNames, *pcchResTypeNames);
                CopyMemory(pwszResTypeNames, g_wszResourceTypeNames, cchCopy * sizeof(WCHAR));
                *pcchResTypeNames = cchCopy;
        }  // Return he resource type names we support

        return S_OK;

}  //*** DllGetCluAdminExtensionCaps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//      DllRegisterCluAdminExtension
//
//      Routine Description:
//              Register the extension with the cluster database.
//
//      Arguments:
//              hCluster                [IN] Handle to the cluster to modify.
//
//      Return Value:
//              S_OK                    Extension registered successfully.
//              Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
        HRESULT         hr = S_OK;
        LPCWSTR         pwszResTypes = g_wszResourceTypeNames;

        while (*pwszResTypes != L'\0')
        {
                hr = RegisterCluAdminResourceTypeExtension(
                                        hCluster,
                                        pwszResTypes,
                                        &CLSID_CoIISClEx4
                                        );
                if (hr != S_OK)
                        break;

                wprintf(L"  %s\n", pwszResTypes);
                pwszResTypes += lstrlenW(pwszResTypes) + 1;
        }  // while:  more resource types

        return hr;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//      DllUnregisterCluAdminExtension
//
//      Routine Description:
//              Unregister the extension with the cluster database.
//
//      Arguments:
//              hCluster                [IN] Handle to the cluster to modify.
//
//      Return Value:
//              S_OK                    Extension unregistered successfully.
//              Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
        HRESULT         hr = S_OK;
        LPCWSTR         pwszResTypes = g_wszResourceTypeNames;

        while (*pwszResTypes != L'\0')
        {
                wprintf(L"  %s\n", pwszResTypes);
                hr = UnregisterCluAdminResourceTypeExtension(
                                        hCluster,
                                        pwszResTypes,
                                        &CLSID_CoIISClEx4
                                        );
                if (hr != S_OK)
                        break;
                pwszResTypes += lstrlenW(pwszResTypes) + 1;
        }  // while:  more resource types

        return hr;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CMapCtrlToHelpID
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

extern const CMapCtrlToHelpID g_rghelpmapIISParameters[];

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\nntpprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      Iis.cpp
//
//  Abstract:
//      Implementation of the CNNTPVirtualRootParamsPage class.
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <inetinfo.h>
#include "IISClEx4.h"
#include "nntpprop.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#include <iadm.h>
#include <iiscnfgp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CNNTPVirtualRootParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNNTPVirtualRootParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNNTPVirtualRootParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CNNTPVirtualRootParamsPage)
    ON_CBN_SELCHANGE(IDC_PP_NNTP_INSTANCEID, OnChangeRequiredField)
    ON_BN_CLICKED(IDC_PP_NNTP_REFRESH, OnRefresh)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::CNNTPVirtualRootParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNNTPVirtualRootParamsPage::CNNTPVirtualRootParamsPage(void)
    : CBasePropertyPage(g_rghelpmapIISParameters)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CNNTPVirtualRootParamsPage)
    m_strInstanceId = _T("");
    //}}AFX_DATA_INIT

    m_fReadList = FALSE;
    
    try
    {
        m_strServiceName = IIS_SVC_NAME_NNTP;
    }  // try
    catch (CMemoryException * pme)
    {
        pme->ReportError();
        pme->Delete();
    }  // catch:  CMemoryException

    // Setup the property array.
    {
        m_rgProps[epropServiceName].Set(REGPARAM_IIS_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
        m_rgProps[epropInstanceId].Set(REGPARAM_IIS_INSTANCEID, m_strInstanceId, m_strPrevInstanceId);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_NNTP_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_NNTP_PARAMETERS;
    m_idcPPTitle = IDC_PP_NNTP_TITLE;

}  //*** CNNTPVirtualRootParamsPage::CNNTPVirtualRootParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNNTPVirtualRootParamsPage::DoDataExchange(CDataExchange * pDX)
{
    CString     strInstanceId;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::DoDataExchange(pDX);
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_MAP(CNNTPVirtualRootParamsPage)
    DDX_Control(pDX, IDC_PP_NNTP_INSTANCEID, m_cInstanceId);
    DDX_Text(pDX, IDC_PP_NNTP_INSTANCEID, m_strInstanceName);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BBackPressed())
        {
            DDV_RequiredText(pDX, IDC_PP_NNTP_INSTANCEID, IDC_PP_NNTP_INSTANCEID_LABEL, m_strInstanceName);
        }  // if:  Back button not pressed

        m_strInstanceId = NameToMetabaseId( m_strInstanceName );

        m_strServiceName = IIS_SVC_NAME_NNTP;
    }  // if:  saving data from dialog

}  //*** CNNTPVirtualRootParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNNTPVirtualRootParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    m_cInstanceId.EnableWindow( TRUE );

    OnChangeCtrl();

    if (!BWizard())
    {
        FillServerList();
    }

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNNTPVirtualRootParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNNTPVirtualRootParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        FillServerList();
    }  // if:  in the wizard

    return CBasePropertyPage::OnSetActive();

}  //*** CNNTPVirtualRootParamsPage::OnSetActive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNNTPVirtualRootParamsPage::OnChangeRequiredField
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNNTPVirtualRootParamsPage::OnChangeRequiredField(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        SetEnableNext();
    }  // if:  in a wizard

}  //*** CNNTPVirtualRootParamsPage::OnChangeRequiredField()

////


void 
CNNTPVirtualRootParamsPage::FillServerList(
    )
/*++

Routine Description:

    Populate server combo box with server list relevant to current service type,
    set current selection based on server instance ID
    enable Finish button if list non empty

Arguments:

    None

Returns:

    Nothing

--*/
{

    int nIndex;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // build array if not already done
    //
    
    if ( !m_fReadList )
    {
        HRESULT hr;
        
        hr = ReadList( &m_ServiceArray, MD_SERVICE_ROOT_NNTP, LPCTSTR(Peo()->StrNodeName()) );
        
        if (FAILED(hr))
        {
            CString err;

            if ( REGDB_E_IIDNOTREG == hr)
            {
                err.Format(IDS_IIS_PROXY_MISCONFIGURED, Peo()->StrNodeName());
                AfxMessageBox(err);
            }
            else
            {
                CString fmtError;
                DWORD   dwError;

                if ( (HRESULT_FACILITY(hr) == FACILITY_WIN32) ||
                     (HRESULT_FACILITY(hr) == FACILITY_NT_BIT))
                {
                    dwError = (DWORD) HRESULT_CODE(hr);
                }
                else
                {
                    dwError = (DWORD) hr;
                }
                
                FormatError(fmtError, dwError);
                
                err.Format(IDS_ENUMERATE_FAILED, Peo()->StrNodeName(), fmtError);
                AfxMessageBox(err);
            }

            m_cInstanceId.EnableWindow(FALSE);
        }
        else
        {
            m_cInstanceId.EnableWindow(TRUE);
        }
        
        m_fReadList = TRUE;
    }

    m_strInstanceName = MetabaseIdToName( m_strInstanceId );

    // add to combo from array

    DWORD  nAddCount = 0;

    m_cInstanceId.ResetContent();

    for ( nIndex = 0 ; nIndex < m_ServiceArray.GetSize() ; ++nIndex )
    {
        //
        // Only add sites that are not cluster enabled or have the same ID as the resource
        //
    
        if ( (!m_ServiceArray.ElementAt(nIndex).IsClusterEnabled()) || 
             (!lstrcmp( m_ServiceArray.ElementAt( nIndex ).GetId(), m_strInstanceId))
           )
        {
            if ( m_cInstanceId.AddString( m_ServiceArray.ElementAt( nIndex ).GetName() ) < 0 )
            {
                OutputDebugStringW( L"Error add\n" );
            }
            else
            {
                nAddCount++;
            }
        }
    }

    if (0 == nAddCount)
    {
        m_cInstanceId.EnableWindow(FALSE);

        if (BWizard())
        {
            CString err;

            EnableNext(FALSE);

            err.Format(IDS_ALL_INSTANCES_CLUSTER_ENABLED, Peo()->StrNodeName());
            AfxMessageBox(err);
        }
    }
    else
    {
        if (BWizard())
        {
            SetEnableNext();
            m_cInstanceId.SetCurSel(0);
        }
        else
        {
            nIndex = m_cInstanceId.FindStringExact(-1, m_strInstanceName);

            if ( nIndex != CB_ERR )
            {
                m_cInstanceId.SetCurSel(nIndex);
            }
        }
    }
}


HRESULT
CNNTPVirtualRootParamsPage::ReadList(
    CArray <IISMapper, IISMapper>* pMapperArray,
    LPWSTR          pszPath,
    LPCWSTR          wcsMachineName
    )
/*++

Routine Description:

    Read a server list from metabase based on metabase path

Arguments:

    pMapperArray - array where to add list of ( ServerComment, InstanceId ) pairs
    pszPath - metabase path, e.g. LM/NNTPSVC

Returns:

    Error code, S_OK if success

--*/
{
    IMSAdminBaseW *     pcAdmCom = NULL;
    METADATA_HANDLE     hmd;
    DWORD               i;
    WCHAR               aId[METADATA_MAX_NAME_LEN];
    WCHAR               aName[512];
    HRESULT             hRes = S_OK;
    COSERVERINFO        csiMachine;
    MULTI_QI            QI = {&IID_IMSAdminBase, NULL, 0};
  
    ZeroMemory( &csiMachine, sizeof(COSERVERINFO) );
    csiMachine.pwszName = (LPWSTR)wcsMachineName;

    hRes = CoCreateInstanceEx(  GETAdminBaseCLSID(TRUE), 
                                NULL, 
                                CLSCTX_SERVER, 
                                &csiMachine,
                                1,
                                &QI
                              );

    if ( SUCCEEDED(hRes) && SUCCEEDED(QI.hr))
    {
        pcAdmCom = (IMSAdminBaseW *)QI.pItf;
        
        if( SUCCEEDED( hRes = pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                 pszPath,
                                                 METADATA_PERMISSION_READ,
                                                 5000,
                                                 &hmd)) )
        {
            for ( i = 0 ;
                  SUCCEEDED(pcAdmCom->EnumKeys( hmd, L"", aId, i )) ;
                  ++i )
            {
                METADATA_RECORD md;
                DWORD           dwReq = sizeof(aName);

                memset( &md, 0, sizeof(md) );
                
                md.dwMDDataType     = STRING_METADATA;
                md.dwMDUserType     = IIS_MD_UT_SERVER;
                md.dwMDIdentifier   = MD_SERVER_COMMENT;
                md.dwMDDataLen      = sizeof(aName);
                md.pbMDData         = (LPBYTE)aName;

                if ( SUCCEEDED( pcAdmCom->GetData( hmd, aId, &md, &dwReq) ) )
                {
                    DWORD   dwClusterEnabled = 0;

                    memset( &md, 0, sizeof(md) );
                    
                    md.dwMDDataType     = DWORD_METADATA;
                    md.dwMDUserType     = IIS_MD_UT_SERVER;
                    md.dwMDIdentifier   = MD_CLUSTER_ENABLED;
                    md.dwMDDataLen      = sizeof(dwClusterEnabled);
                    md.pbMDData         = (LPBYTE)&dwClusterEnabled;

                    pcAdmCom->GetData( hmd, aId, &md, &dwReq);
                
                    IISMapper*  pMap = new IISMapper( aName, aId, dwClusterEnabled );
                    
                    if ( pMap )
                    {
                        pMapperArray->Add( *pMap );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                        break;
                    }
                }
            }

            pcAdmCom->CloseKey( hmd );
        }

        pcAdmCom->Release();
    }

    return hRes;
}


LPWSTR
CNNTPVirtualRootParamsPage::NameToMetabaseId(
    CString&    strName
    )
/*++

Routine Description:

    Convert ServerComment to InstanceId

Arguments:

    strName - ServerComment

Returns:

    InstanceId if strName found in array, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetName().Compare( strName ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetId());
        }
    }

    return NULL;
}


LPWSTR
CNNTPVirtualRootParamsPage::MetabaseIdToName(
    CString&    strId
    )
/*++

Routine Description:

    Convert InstanceId to ServerComment

Arguments:

    strId - InstanceID

Returns:

    InstanceId if strName found in array. 
    If not found return 1st array element if array not empty, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetId().Compare( strId ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetName());
        }
    }

    return m_ServiceArray.GetSize() == 0 ? NULL : (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( 0 ).GetName());
}


VOID
CNNTPVirtualRootParamsPage::SetEnableNext(
    VOID
    )
/*++

Routine Description:

    Set enable state of Finish button

Arguments:

    None

Returns:

    Nothing

--*/
{
    EnableNext( m_ServiceArray.GetSize() ? TRUE : FALSE );
}

void CNNTPVirtualRootParamsPage::OnRefresh() 
{
    m_fReadList = FALSE;

    m_ServiceArray.RemoveAll();
    
    FillServerList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropList.h
//
//	Abstract:
//		Definition of the CClusPropList class.
//
//	Implementation File:
//		PropList.cpp
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PROPLIST_H_
#define _PROPLIST_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CObjectProperty;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CObjectProperty
/////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

class CObjectProperty
{
public:
	LPCWSTR					m_pwszName;
	CLUSTER_PROPERTY_FORMAT	m_propFormat;

	union CValue
	{
		CString *	pstr;
		DWORD *		pdw;
		BOOL *		pb;
		struct
		{
			PBYTE *	ppb;
			DWORD *	pcb;
		};
	};
	CValue					m_value;
	CValue					m_valuePrev;

	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN DWORD & rdwValue,
				IN DWORD & rdwPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pdw = &rdwValue;
		m_value.pcb = NULL;
		m_valuePrev.pdw = &rdwPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN BOOL & rbValue,
				IN BOOL & rbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pb = &rbValue;
		m_value.pcb = NULL;
		m_valuePrev.pb = &rbPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN PBYTE & rpbValue,
				IN DWORD & rcbValue,
				IN PBYTE & rpbPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_BINARY;
		m_value.ppb = &rpbValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = &rpbPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN LPWSTR & rpwszValue,
				IN DWORD & rcbValue,
				IN LPWSTR & rpwszPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
		m_value.ppb = (PBYTE *) &rpwszValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = (PBYTE *) &rpwszPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

};  //*** class CObjectProperty

/////////////////////////////////////////////////////////////////////////////
// CClusPropList dialog
/////////////////////////////////////////////////////////////////////////////

class CClusPropList : public CObject
{
	DECLARE_DYNAMIC(CClusPropList);

// Construction
public:
	CClusPropList(IN BOOL bAlwaysAddProp = FALSE);
	~CClusPropList(void);

// Attributes
protected:
	BOOL					m_bAlwaysAddProp;

	CLUSPROP_BUFFER_HELPER	m_proplist;
	CLUSPROP_BUFFER_HELPER	m_propCurrent;
	DWORD					m_cbBufferSize;
	DWORD					m_cbDataSize;

public:
	const CLUSPROP_BUFFER_HELPER const *	Proplist(void) const	{ return &m_proplist; }
	PBYTE					PbProplist(void) const	{ return m_proplist.pb; }
	DWORD					CbProplist(void) const	{ return m_cbDataSize + sizeof(CLUSPROP_SYNTAX); /*endmark*/ }
	DWORD					Cprops(void) const
	{
		if (m_proplist.pb == NULL)
			return 0;
		return m_proplist.pList->nPropertyCount;
	}

	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const CString &	rstrValue,
								IN const CString &	rstrPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN DWORD			dwValue,
								IN DWORD			dwPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const PBYTE		pbValue,
								IN DWORD			cbValue,
								IN const PBYTE		pbPrevValue,
								IN DWORD			cbPrevValue
								);

	void					AllocPropList(IN DWORD cbMinimum);

// Operations
public:
	DWORD					DwGetNodeProperties(
								IN HNODE		hNode,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetGroupProperties(
								IN HGROUP		hGroup,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceProperties(
								IN HRESOURCE	hResource,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceTypeProperties(
								IN HCLUSTER		hCluster,
								IN LPCWSTR		pwszResTypeName,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetworkProperties(
								IN HNETWORK		hNetwork,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetInterfaceProperties(
								IN HNETINTERFACE	hNetInterface,
								IN DWORD			dwControlCode,
								IN HNODE			hHostNode		= NULL,
								IN LPVOID			lpInBuffer		= NULL,
								IN DWORD			cbInBufferSize	= 0
								);

// Overrides

// Implementation
protected:
	void					CopyProp(
								IN PCLUSPROP_SZ				pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN LPCWSTR					pwsz,
								IN DWORD					cbsz = 0
								);
	void					CopyProp(
								IN PCLUSPROP_DWORD			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN DWORD					dw
								);
	void					CopyProp(
								IN PCLUSPROP_BINARY			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN const PBYTE				pb,
								IN DWORD					cb
								);

	DWORD					DwGetPrivateProps(
								OUT PBYTE *					ppbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);
	DWORD					DwSetPrivateProps(
								IN PBYTE					pbProps,
								IN DWORD					cbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);

};  //*** class CClusPropList

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // _PROPLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropList.cpp
//
//	Abstract:
//		Implementation of the CClusPropList class.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.h"
#include "BarfClus.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define BUFFER_GROWTH_FACTOR 256

/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CClusPropList, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CClusPropList
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::CClusPropList(IN BOOL bAlwaysAddProp)
{
	m_proplist.pList = NULL;
	m_propCurrent.pb = NULL;
	m_cbBufferSize = 0;
	m_cbDataSize = 0;

	m_bAlwaysAddProp = bAlwaysAddProp;

}  //*** CClusPropList::CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::~CClusPropList
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::~CClusPropList(void)
{
	delete [] m_proplist.pb;

}  //*** CClusPropList::~CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		rstrValue		[IN] Value of the property to set in the list.
//		rstrPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const CString &	rstrValue,
	IN const CString &	rstrPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_SZ			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (rstrValue != rstrPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_SZ)
						+ ALIGN_CLUSPROP((rstrValue.GetLength() + 1) * sizeof(WCHAR))
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pStringValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, rstrValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a DWORD property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		dwValue			[IN] Value of the property to set in the list.
//		dwPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR		pwszName,
	IN DWORD		dwValue,
	IN DWORD		dwPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_DWORD			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (dwValue != dwPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_DWORD)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pDwordValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, dwValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a binary property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pbValue			[IN] Value of the property to set in the list.
//		cbValue			[IN] Count of bytes in pbValue.
//		pbPrevValue		[IN] Previous value of the property.
//		cbPrevValue		[IN] Count of bytes in pbPrevValue.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const PBYTE		pbValue,
	IN DWORD			cbValue,
	IN const PBYTE		pbPrevValue,
	IN DWORD			cbPrevValue
	)
{
	BOOL					bChanged = FALSE;
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_BINARY		pValue;

	ASSERT(pwszName != NULL);
	ASSERT(((cbValue == 0) && (cbPrevValue == 0)) || (pbValue != pbPrevValue));

	// Determine if the buffer has changed.
	if (m_bAlwaysAddProp || (cbValue != cbPrevValue))
		bChanged = TRUE;
	else if (!((cbValue == 0) && (cbPrevValue == 0)))
		bChanged = memcmp(pbValue, pbPrevValue, cbValue) == 0;

	if (bChanged)
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_BINARY)
						+ ALIGN_CLUSPROP(cbValue)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pBinaryValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value changed

}  //*** CClusPropList::AddProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pwsz		[IN] String to copy.
//		cbsz		[IN] Count of bytes in pwsz string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN LPCWSTR					pwsz,
	IN DWORD					cbsz
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);
	ASSERT(pwsz != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
	pprop->Syntax.wType = (WORD) proptype;
	if (cbsz == 0)
		cbsz = (lstrlenW(pwsz) + 1) * sizeof(WCHAR);
	ASSERT(cbsz == (lstrlenW(pwsz) + 1) * sizeof(WCHAR));
	pprop->cbLength = cbsz;
	lstrcpyW(pprop->sz, pwsz);

	// Set an endmark.
	props.pStringValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cbsz);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a DWORD property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of DWORD.
//		dw			[IN] DWORD to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_DWORD			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN DWORD					dw
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = sizeof(DWORD);
	pprop->dw = dw;

	// Set an endmark.
	props.pDwordValue = pprop;
	props.pb += sizeof(*props.pDwordValue);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a binary property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pb			[IN] Block to copy.
//		cbsz		[IN] Count of bytes in pb buffer.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_BINARY		pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN const PBYTE				pb,
	IN DWORD					cb
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = cb;
	if (cb > 0)
		CopyMemory(pprop->rgb, pb, cb);

	// Set an endmark.
	props.pBinaryValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cb);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AllocPropList
//
//	Routine Description:
//		Allocate a property list buffer that's big enough to hold the next
//		property.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by BYTE::operator new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AllocPropList(
	IN DWORD	cbMinimum
	)
{
	DWORD		cbTotal;

	ASSERT(cbMinimum > 0);

	// Add the size of the item count and final endmark.
	cbMinimum += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
	cbTotal = m_cbDataSize + cbMinimum;

	if (m_cbBufferSize < cbTotal)
	{
		PBYTE	pbNewProplist;

		cbMinimum = max(BUFFER_GROWTH_FACTOR, cbMinimum);
		cbTotal = m_cbDataSize + cbMinimum;

		// Allocate and zero a new buffer.
		pbNewProplist = new BYTE[cbTotal];
		ZeroMemory(pbNewProplist, cbTotal);

		// If there was a previous buffer, copy it and the delete it.
		if (m_proplist.pb != NULL)
		{
			if (m_cbDataSize != 0)
				CopyMemory(pbNewProplist, m_proplist.pb, m_cbDataSize);
			delete [] m_proplist.pb;
			m_propCurrent.pb = pbNewProplist + (m_propCurrent.pb - m_proplist.pb);
		}  // if:  there was a previous buffer
		else
			m_propCurrent.pb = pbNewProplist + sizeof(DWORD); // move past prop count

		// Save the new buffer.
		m_proplist.pb = pbNewProplist;
		m_cbBufferSize = cbTotal;
	}  // if:  buffer isn't big enough

}  //*** CClusPropList::AllocPropList(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNodeProperties
//
//	Routine Description:
//		Get properties on a node.
//
//	Arguments:
//		hNode			[IN] Handle for the node to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNodeProperties(
	IN HNODE		hNode,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hNode != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetGroupProperties
//
//	Routine Description:
//		Get properties on a group.
//
//	Arguments:
//		hGroup			[IN] Handle for the group to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetGroupProperties(
	IN HGROUP		hGroup,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hGroup != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceProperties
//
//	Routine Description:
//		Get properties on a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceProperties(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hResource != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceTypeProperties
//
//	Routine Description:
//		Get properties on a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceTypeProperties(
	IN HCLUSTER		hCluster,
	IN LPCWSTR		pwszResTypeName,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hCluster != NULL);
	ASSERT(pwszResTypeName != NULL);
	ASSERT(*pwszResTypeName != L'\0');
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetworkProperties
//
//	Routine Description:
//		Get properties on a network.
//
//	Arguments:
//		hNetwork		[IN] Handle for the network to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetworkProperties(
	IN HNETWORK		hNetwork,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hNetwork != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetInterfaceProperties
//
//	Routine Description:
//		Get properties on a network interface.
//
//	Arguments:
//		hNetInterface	[IN] Handle for the network interface to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetInterfaceProperties(
	IN HNETINTERFACE	hNetInterface,
	IN DWORD			dwControlCode,
	IN HNODE			hHostNode,
	IN LPVOID			lpInBuffer,
	IN DWORD			cbInBufferSize
	)
{
	DWORD		dwStatus;
	DWORD		cbProps			= 256;

	ASSERT(hNetInterface != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT));

	ASSERT(m_proplist.pb == NULL);
	ASSERT(m_propCurrent.pb == NULL);
	ASSERT(m_cbBufferSize == 0);
	ASSERT(m_cbDataSize == 0);

	do
	{
		// Allocate a default-sized buffer.
		try
		{
			AllocPropList(cbProps);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Get properties.
		dwStatus = ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
	} while (dwStatus == ERROR_MORE_DATA);

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetInterfaceProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisclex4.rc
//
#define IDD_PP_IIS_PARAMETERS           136
#define IDD_WIZ_IIS_PARAMETERS          145
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_IIS_FTP                  1080
#define IDC_PP_IIS_GOPHER               1081
#define IDC_PP_IIS_WWW                  1082
#define IDC_PP_IIS_INSTANCEID_LABEL     1083
#define IDC_PP_IIS_INSTANCEID           1084
#define IDC_PP_IIS_DIRECTORY_LABEL      1085
#define IDC_PP_IIS_DIRECTORY            1086
#define IDC_PP_IIS_BROWSE               1087
#define IDC_PP_IIS_ACCOUNTNAME_LABEL    1088
#define IDC_PP_IIS_ACCOUNTNAME          1089
#define IDC_PP_IIS_PASSWORD_LABEL       1090
#define IDC_PP_IIS_PASSWORD             1091
#define IDC_PP_IIS_ACCT_INFO_GROUP      1092
#define IDC_PP_IIS_ACCESS_GROUP         1093
#define IDC_PP_IIS_READ_ACCESS          1094
#define IDC_PP_IIS_WRITE_ACCESS         1095
#define IDC_PP_REFRESH                  1178
#define IDS_CLUADMEX_COMOBJ_DESC        30500
#define IDS_WRITE                       30501
#define IDS_EXECUTE                     30502
#define IDS_MENU_WHATS_THIS             30503
#define IDS_UNKNOWN_ERROR               31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101
#define IDS_REQUIRED_FIELD_EMPTY        31102
#define IDS_INVALID_IIS_SERVICE_TYPE    31103
#define IDS_ENUMERATE_FAILED            31104
#define IDS_ACCESS_DENIED               31105
#define IDS_IIS_PROXY_MISCONFIGURED     31106
#define IDS_ALL_INSTANCES_CLUSTER_ENABLED 31107
#define IDS_DEFAULT_SITE_NAME           31108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        152
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1179
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

// SMTP specific resource IDs
#define IDD_PP_SMTP_PARAMETERS          200
#define IDD_WIZ_SMTP_PARAMETERS         201
#define IDC_PP_SMTP_TITLE               202
#define IDC_PP_SMTP_INSTANCEID_LABEL    1200
#define IDC_PP_SMTP_INSTANCEID          1201
#define IDC_PP_SMTP_REFRESH             1202

// NNTP specific resource IDs
#define IDD_PP_NNTP_PARAMETERS          300
#define IDD_WIZ_NNTP_PARAMETERS         301
#define IDC_PP_NNTP_TITLE               302
#define IDC_PP_NNTP_INSTANCEID_LABEL    1300
#define IDC_PP_NNTP_INSTANCEID          1301
#define IDC_PP_NNTP_REFRESH             1302
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExt.h
//
//	Abstract:
//		Definitions of routines for extension registration.
//
//	Implementation File:
//		RegExt.cpp
//
//	Author:
//		David Potter (davidp)	April 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGEXT_H_
#define _REGEXT_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _REGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExt.cpp
//
//	Abstract:
//		Implementation of routines for extension registration.
//
//	Author:
//		David Potter (davidp)	April 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <stdafx.h>
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminClusterExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminClusterExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Register the extension.
			hr = RegisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyRegistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been registered yet.
			if (pwszValue == NULL)
				bAlreadyRegistered = FALSE;
			else
			{
				LPCWSTR	pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyRegistered = (*pwszValue != L'\0');
			}  // else:  extension value exists

			// Register the extension.
			if (!bAlreadyRegistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize + (cbSize ? 0 : sizeof(WCHAR)) + (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	cch;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if (pwszValue != NULL)
					{
						while (*pwszValueBuf != L'\0')
						{
							lstrcpyW(pwszNewValueBuf, pwszValueBuf);
							cch = lstrlenW(pwszValueBuf);
							pwszValueBuf += cch + 1;
							pwszNewValueBuf += cch + 1;
						}  // while:  more strings in the extension list
					}  // if:  previous value buffer existed

					// Add the new CLSID to the list.
					lstrcpyW(pwszNewValueBuf, pwszClsid);
					pwszNewValueBuf += lstrlenW(pwszClsid) + 1;
					*pwszNewValueBuf = L'\0';

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not registered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Unregister the extension.
			hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyUnregistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been unregistered yet.
			if (pwszValue == NULL)
				bAlreadyUnregistered = TRUE;
			else
			{
				LPCWSTR pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyUnregistered = (*pwszValue != L'\0');
			}  // else:  extension value exists

			// Unregister the extension.
			if (!bAlreadyUnregistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize - (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if (pwszValue != NULL)
					{
						while (*pwszValueBuf != L'\0')
						{
							if (lstrcmpW(pwszClsid, pwszValueBuf) != 0)
							{
								lstrcpyW(pwszNewValueBuf, pwszValueBuf);
								pwszNewValueBuf += lstrlen(pwszNewValueBuf) + 1;
							}  // if:  not CLSID being removed
							pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
						}  // while:  more strings in the extension list
					}  // if:  previous value buffer existed

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not unregistered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReadValue
//
//	Routine Description:
//		Reads a value from the cluster database.
//
//	Arguments:
//		hkey			[IN] Handle for the key to read from.
//		pwszValueName	[IN] Name of value to read.
//		ppwszValue		[OUT] Address of pointer in which to return data.
//							The string is allocated using LocalAlloc and must
//							be deallocated by the calling LocalFree.
//		pcbSize			[OUT] Size in bytes of the allocated value buffer.
//
//	Return Value:
//		Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	)
{
	DWORD		dwStatus;
	DWORD		cbSize;
	DWORD		dwType;
	LPWSTR		pwszValue;

	*ppwszValue = NULL;
	*pcbSize = 0;

	// Get the length of the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					NULL,
					&cbSize
					);
	if (   (dwStatus != ERROR_SUCCESS)
		&& (dwStatus != ERROR_MORE_DATA))
	{
		if (dwStatus  == ERROR_FILE_NOT_FOUND)
			dwStatus = ERROR_SUCCESS;
		return dwStatus;
	}  // if:  error occurred

	// Allocate a value string.
	pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbSize);
	if (pwszValue == NULL)
	{
		dwStatus = GetLastError();
		return dwStatus;
	}  // if:  error allocating memory

	// Read the the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					(LPBYTE) pwszValue,
					&cbSize
					);
	if (dwStatus != ERROR_SUCCESS)
	{
		LocalFree(pwszValue);
		pwszValue = NULL;
		cbSize = 0;
	}  // if:  error occurred

	*ppwszValue = pwszValue;
	*pcbSize = cbSize;
	return dwStatus;

}  //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\nntpprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      nntpprop.h
//
//  Abstract:
//      Definition of the CNNTPVirtualRootParamsPage class, which implements the
//      Parameters page for IIS resources.
//
//  Implementation File:
//      Iis.cpp
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NNTPPROP_H_
#define _NNTPPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

#include "ConstDef.h"   // for IIS_SVC_NAME_NNTP
#include "Iis.h"		// for IISMapper

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNNTPVirtualRootParamsPage;
class IISMapper;

/////////////////////////////////////////////////////////////////////////////
//
//  CNNTPVirtualRootParamsPage
//
//  Purpose:
//      Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CNNTPVirtualRootParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CNNTPVirtualRootParamsPage)

// Construction
public:
    CNNTPVirtualRootParamsPage(void);

// Dialog Data
    //{{AFX_DATA(CNNTPVirtualRootParamsPage)
    enum { IDD = IDD_PP_NNTP_PARAMETERS };
    CButton m_ckbWrite;
    CButton m_ckbRead;
    CButton m_groupAccess;
    CEdit   m_editPassword;
    CStatic m_staticPassword;
    CEdit   m_editAccountName;
    CStatic m_staticAccountName;
    CButton m_groupAccountInfo;
    CEdit   m_editDirectory;
    CString m_strDirectory;
    CString m_strAccountName;
    CString m_strPassword;
    CEdit   m_editInstanceId;
    CComboBox m_cInstanceId;
    CString m_strInstanceName;
    CString m_strInstanceId;
    BOOL    m_bRead;
    BOOL    m_bWrite;
    //}}AFX_DATA
    CString m_strServiceName;
    CString m_strPrevServiceName;
    CString m_strPrevDirectory;
    CString m_strPrevAccountName;
    CString m_strPrevPassword;
    CString m_strPrevInstanceId;
    DWORD   m_dwAccessMask;
    DWORD   m_dwPrevAccessMask;

protected:
    enum
    {
        epropServiceName,
        epropInstanceId,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CNNTPVirtualRootParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    void FillServerList();
    void SetEnableNext();


private:
    BOOL   m_fReadList;
    CArray <IISMapper, IISMapper>  m_ServiceArray;

    LPWSTR  NameToMetabaseId( CString&  strName);
    LPWSTR  MetabaseIdToName( CString&  strId);
    HRESULT ReadList(CArray <IISMapper, IISMapper>* pMapperArray, LPWSTR pszPath, LPCWSTR wcsServerName);


// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNNTPVirtualRootParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeRequiredField();
    afx_msg void OnRefresh();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CNNTPVirtualRootParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _NNTPPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\smtpprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      Iis.cpp
//
//  Abstract:
//      Implementation of the CSMTPVirtualRootParamsPage class.
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <inetinfo.h>
#include "IISClEx4.h"
#include "smtpprop.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#include <iadm.h>
#include <iiscnfgp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSMTPVirtualRootParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CSMTPVirtualRootParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CSMTPVirtualRootParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CSMTPVirtualRootParamsPage)
    ON_CBN_SELCHANGE(IDC_PP_SMTP_INSTANCEID, OnChangeRequiredField)
    ON_BN_CLICKED(IDC_PP_SMTP_REFRESH, OnRefresh)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::CSMTPVirtualRootParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSMTPVirtualRootParamsPage::CSMTPVirtualRootParamsPage(void)
    : CBasePropertyPage(g_rghelpmapIISParameters)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CSMTPVirtualRootParamsPage)
    m_strInstanceId = _T("");
    //}}AFX_DATA_INIT

    m_fReadList = FALSE;
    
    try
    {
        m_strServiceName = IIS_SVC_NAME_SMTP;
    }  // try
    catch (CMemoryException * pme)
    {
        pme->ReportError();
        pme->Delete();
    }  // catch:  CMemoryException

    // Setup the property array.
    {
        m_rgProps[epropServiceName].Set(REGPARAM_IIS_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
        m_rgProps[epropInstanceId].Set(REGPARAM_IIS_INSTANCEID, m_strInstanceId, m_strPrevInstanceId);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_SMTP_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_SMTP_PARAMETERS;
    m_idcPPTitle = IDC_PP_SMTP_TITLE;

}  //*** CSMTPVirtualRootParamsPage::CSMTPVirtualRootParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSMTPVirtualRootParamsPage::DoDataExchange(CDataExchange * pDX)
{
    CString     strInstanceId;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::DoDataExchange(pDX);
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_MAP(CSMTPVirtualRootParamsPage)
    DDX_Control(pDX, IDC_PP_SMTP_INSTANCEID, m_cInstanceId);
    DDX_Text(pDX, IDC_PP_SMTP_INSTANCEID, m_strInstanceName);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BBackPressed())
        {
            DDV_RequiredText(pDX, IDC_PP_SMTP_INSTANCEID, IDC_PP_SMTP_INSTANCEID_LABEL, m_strInstanceName);
        }  // if:  Back button not pressed

        m_strInstanceId = NameToMetabaseId( m_strInstanceName );

        m_strServiceName = IIS_SVC_NAME_SMTP;
    }  // if:  saving data from dialog

}  //*** CSMTPVirtualRootParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSMTPVirtualRootParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    m_cInstanceId.EnableWindow( TRUE );

    OnChangeCtrl();

    if (!BWizard())
    {
        FillServerList();
    }

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CSMTPVirtualRootParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSMTPVirtualRootParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        FillServerList();
    }  // if:  in the wizard

    return CBasePropertyPage::OnSetActive();

}  //*** CSMTPVirtualRootParamsPage::OnSetActive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSMTPVirtualRootParamsPage::OnChangeRequiredField
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSMTPVirtualRootParamsPage::OnChangeRequiredField(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        SetEnableNext();
    }  // if:  in a wizard

}  //*** CSMTPVirtualRootParamsPage::OnChangeRequiredField()

////


void 
CSMTPVirtualRootParamsPage::FillServerList(
    )
/*++

Routine Description:

    Populate server combo box with server list relevant to current service type,
    set current selection based on server instance ID
    enable Finish button if list non empty

Arguments:

    None

Returns:

    Nothing

--*/
{

    int nIndex;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // build array if not already done
    //
    
    if ( !m_fReadList )
    {
        HRESULT hr;
        
        hr = ReadList( &m_ServiceArray, MD_SERVICE_ROOT_SMTP, LPCTSTR(Peo()->StrNodeName()) );
        
        if (FAILED(hr))
        {
            CString err;

            if ( REGDB_E_IIDNOTREG == hr)
            {
                err.Format(IDS_IIS_PROXY_MISCONFIGURED, Peo()->StrNodeName());
                AfxMessageBox(err);
            }
            else
            {
                CString fmtError;
                DWORD   dwError;

                if ( (HRESULT_FACILITY(hr) == FACILITY_WIN32) ||
                     (HRESULT_FACILITY(hr) == FACILITY_NT_BIT))
                {
                    dwError = (DWORD) HRESULT_CODE(hr);
                }
                else
                {
                    dwError = (DWORD) hr;
                }
                
                FormatError(fmtError, dwError);
                
                err.Format(IDS_ENUMERATE_FAILED, Peo()->StrNodeName(), fmtError);
                AfxMessageBox(err);
            }

            m_cInstanceId.EnableWindow(FALSE);
        }
        else
        {
            m_cInstanceId.EnableWindow(TRUE);
        }
        
        m_fReadList = TRUE;
    }

    m_strInstanceName = MetabaseIdToName( m_strInstanceId );

    // add to combo from array

    DWORD  nAddCount = 0;

    m_cInstanceId.ResetContent();

    for ( nIndex = 0 ; nIndex < m_ServiceArray.GetSize() ; ++nIndex )
    {
        //
        // Only add sites that are not cluster enabled or have the same ID as the resource
        //
    
        if ( (!m_ServiceArray.ElementAt(nIndex).IsClusterEnabled()) || 
             (!lstrcmp( m_ServiceArray.ElementAt( nIndex ).GetId(), m_strInstanceId))
           )
        {
            if ( m_cInstanceId.AddString( m_ServiceArray.ElementAt( nIndex ).GetName() ) < 0 )
            {
                OutputDebugStringW( L"Error add\n" );
            }
            else
            {
                nAddCount++;
            }
        }
    }

    if (0 == nAddCount)
    {
        m_cInstanceId.EnableWindow(FALSE);

        if (BWizard())
        {
            CString err;

            EnableNext(FALSE);

            err.Format(IDS_ALL_INSTANCES_CLUSTER_ENABLED, Peo()->StrNodeName());
            AfxMessageBox(err);
        }
    }
    else
    {
        if (BWizard())
        {
            SetEnableNext();
            m_cInstanceId.SetCurSel(0);
        }
        else
        {
            nIndex = m_cInstanceId.FindStringExact(-1, m_strInstanceName);

            if ( nIndex != CB_ERR )
            {
                m_cInstanceId.SetCurSel(nIndex);
            }
        }
    }
}


HRESULT
CSMTPVirtualRootParamsPage::ReadList(
    CArray <IISMapper, IISMapper>* pMapperArray,
    LPWSTR          pszPath,
    LPCWSTR          wcsMachineName
    )
/*++

Routine Description:

    Read a server list from metabase based on metabase path

Arguments:

    pMapperArray - array where to add list of ( ServerComment, InstanceId ) pairs
    pszPath - metabase path, e.g. LM/SMTPSVC

Returns:

    Error code, S_OK if success

--*/
{
    IMSAdminBaseW *     pcAdmCom = NULL;
    METADATA_HANDLE     hmd;
    DWORD               i;
    WCHAR               aId[METADATA_MAX_NAME_LEN];
    WCHAR               aName[512];
    HRESULT             hRes = S_OK;
    COSERVERINFO        csiMachine;
    MULTI_QI            QI = {&IID_IMSAdminBase, NULL, 0};
  
    ZeroMemory( &csiMachine, sizeof(COSERVERINFO) );
    csiMachine.pwszName = (LPWSTR)wcsMachineName;

    hRes = CoCreateInstanceEx(  GETAdminBaseCLSID(TRUE), 
                                NULL, 
                                CLSCTX_SERVER, 
                                &csiMachine,
                                1,
                                &QI
                              );

    if ( SUCCEEDED(hRes) && SUCCEEDED(QI.hr))
    {
        pcAdmCom = (IMSAdminBaseW *)QI.pItf;
        
        if( SUCCEEDED( hRes = pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                                 pszPath,
                                                 METADATA_PERMISSION_READ,
                                                 5000,
                                                 &hmd)) )
        {
            for ( i = 0 ;
                  SUCCEEDED(pcAdmCom->EnumKeys( hmd, L"", aId, i )) ;
                  ++i )
            {
                METADATA_RECORD md;
                DWORD           dwReq = sizeof(aName);

                memset( &md, 0, sizeof(md) );
                
                md.dwMDDataType     = STRING_METADATA;
                md.dwMDUserType     = IIS_MD_UT_SERVER;
                md.dwMDIdentifier   = MD_SERVER_COMMENT;
                md.dwMDDataLen      = sizeof(aName);
                md.pbMDData         = (LPBYTE)aName;

                if ( SUCCEEDED( pcAdmCom->GetData( hmd, aId, &md, &dwReq) ) )
                {
                    DWORD   dwClusterEnabled = 0;

                    memset( &md, 0, sizeof(md) );
                    
                    md.dwMDDataType     = DWORD_METADATA;
                    md.dwMDUserType     = IIS_MD_UT_SERVER;
                    md.dwMDIdentifier   = MD_CLUSTER_ENABLED;
                    md.dwMDDataLen      = sizeof(dwClusterEnabled);
                    md.pbMDData         = (LPBYTE)&dwClusterEnabled;

                    pcAdmCom->GetData( hmd, aId, &md, &dwReq);
                
                    IISMapper*  pMap = new IISMapper( aName, aId, dwClusterEnabled );
                    
                    if ( pMap )
                    {
                        pMapperArray->Add( *pMap );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                        break;
                    }
                }
            }

            pcAdmCom->CloseKey( hmd );
        }

        pcAdmCom->Release();
    }

    return hRes;
}


LPWSTR
CSMTPVirtualRootParamsPage::NameToMetabaseId(
    CString&    strName
    )
/*++

Routine Description:

    Convert ServerComment to InstanceId

Arguments:

    strName - ServerComment

Returns:

    InstanceId if strName found in array, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetName().Compare( strName ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetId());
        }
    }

    return NULL;
}


LPWSTR
CSMTPVirtualRootParamsPage::MetabaseIdToName(
    CString&    strId
    )
/*++

Routine Description:

    Convert InstanceId to ServerComment

Arguments:

    strId - InstanceID

Returns:

    InstanceId if strName found in array. 
    If not found return 1st array element if array not empty, otherwise NULL

--*/
{
    DWORD   i;

    for ( i = 0 ; i < (DWORD)m_ServiceArray.GetSize() ; ++i )
    {
        if ( !m_ServiceArray.ElementAt( i ).GetId().Compare( strId ) )
        {
            return (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( i ).GetName());
        }
    }

    return m_ServiceArray.GetSize() == 0 ? NULL : (LPWSTR)(LPCTSTR)(m_ServiceArray.ElementAt( 0 ).GetName());
}


VOID
CSMTPVirtualRootParamsPage::SetEnableNext(
    VOID
    )
/*++

Routine Description:

    Set enable state of Finish button

Arguments:

    None

Returns:

    Nothing

--*/
{
    EnableNext( m_ServiceArray.GetSize() ? TRUE : FALSE );
}

void CSMTPVirtualRootParamsPage::OnRefresh() 
{
    m_fReadList = FALSE;

    m_ServiceArray.RemoveAll();
    
    FillServerList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
//#include <afxpriv.h>		// used for OLE2T T2OLE conversions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifndef _CLUSTER_API_
#include <clusapi.h>	// for cluster definitions
#endif

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
typedef UINT    IDC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CluAdmEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Dummy header file because we don't support trace tags in DLLs.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

class CTraceTag
{
public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL) {}

};  //*** class CTraceTag

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
 #define	TraceError				;/##/
 #define	InitAllTraceTags		;/##/

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\cmdsync\iissync.cxx ===
#define INITGUID
#include    <windows.h>
#include    <stdio.h>
#include    <ole2.h>
#include    "mdsync.h"

//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


BOOL        g_fDone = FALSE;
DWORD       g_dwTarget = 0;
SYNC_STAT*  g_pStat = NULL;
CHAR        g_achMsg1[128];
CHAR        g_achMsg2[128];
CHAR        g_achMsg3[128];
CHAR        g_achMsg4[128];
CHAR        g_achMsg5[128];
CHAR        g_achMsg6[128];
CHAR        g_achMsg7[128];
CHAR        g_achMsg8[128];
CHAR        g_achMsg9[128];


DWORD
WINAPI
Monitor(
    LPVOID  pV
    )
{
    for ( ;; )
    {
        printf( g_achMsg1, 
                g_pStat->m_dwSourceScan, 
                g_pStat->m_fSourceComplete ? g_achMsg2 : g_achMsg3 );
        for ( UINT i = 0 ; i < g_dwTarget ; ++i )
        {
            printf( "(%d,%d), ", g_pStat->m_adwTargets[i*2], g_pStat->m_adwTargets[i*2+1] );
        }
        printf( "\r" );

        if ( g_fDone )
        {
            break;
        }

        Sleep( 1000 );
    }

    return 0;
}


/* INTRINSA ignore = all */
VOID
DisplayErrorMessage(
    DWORD   dwErr
    )
{
    LPSTR   pErr;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPSTR)&pErr,
            0,
            NULL ) )
    {
        LPSTR   p;

        if ( p = strchr( pErr, '\r' ) )
        {
            *p = '\0';
        }
        fputs( pErr, stdout );

        LocalFree( pErr );
    }
    else
    {
        fputs( g_achMsg9, stdout );
    }
}


int __cdecl main( int argc, char*argv[] )
{
    IMdSync*    pIf;
    LPDWORD     pdwErr;
    HANDLE      hThread;
    DWORD       dwThreadId;
    LPSTR       pTargets;
    int         iA;
    UINT        cT;
    int         Status = 0;
    HRESULT     hRes;
    DWORD       dwFlags = 0;
    DWORD       iT;
    BOOL        fAtLeastOnError = FALSE;

    if ( argc < 2 )
    {
        CHAR    achMsg[2048];

        if ( LoadString( NULL, 100, achMsg, sizeof(achMsg) ) )
        {
            printf( achMsg );
        }
        return 3;
    }

    if ( !LoadString( NULL, 101, g_achMsg1, sizeof(g_achMsg1) ) ||
         !LoadString( NULL, 102, g_achMsg2, sizeof(g_achMsg2) ) ||
         !LoadString( NULL, 103, g_achMsg3, sizeof(g_achMsg3) ) ||
         !LoadString( NULL, 105, g_achMsg5, sizeof(g_achMsg5) ) ||
         !LoadString( NULL, 106, g_achMsg6, sizeof(g_achMsg6) ) ||
         !LoadString( NULL, 107, g_achMsg7, sizeof(g_achMsg7) ) ||
         !LoadString( NULL, 108, g_achMsg8, sizeof(g_achMsg8) ) ||
         !LoadString( NULL, 109, g_achMsg9, sizeof(g_achMsg9) ) ||
         !LoadString( NULL, 104, g_achMsg4, sizeof(g_achMsg4) ) )
    {
        DisplayErrorMessage( GetLastError() );
        return 1;
    }

    //
    // Count targets, get target name length
    //

    for ( cT = 1, g_dwTarget=0, iA = 1 ; iA < argc ; ++iA )
    {
        if ( argv[iA][0] == '-' )
        {
            switch ( argv[iA][1] )
            {
                case 'c':
                    dwFlags |= MD_SYNC_FLAG_CHECK_ADMINEX_SIGNATURE;
                    break;        
            }
        }
        else
        {
            cT += strlen( argv[iA] ) + 1;
            ++g_dwTarget;
        }
    }

    if ( !(g_pStat = (SYNC_STAT*)LocalAlloc( LMEM_FIXED, 
                sizeof(SYNC_STAT)+sizeof(DWORD)*2*g_dwTarget )) ||
         !(pTargets = (LPSTR)LocalAlloc( LMEM_FIXED, cT )) ||
         !(pdwErr = (LPDWORD)LocalAlloc( LMEM_FIXED, sizeof(DWORD)*g_dwTarget)) )
    {
        DisplayErrorMessage( GetLastError() );
        return 1;
    }

    memset ( g_pStat, '\0', sizeof(SYNC_STAT)+sizeof(DWORD)*2*g_dwTarget  );

    //
    // Create target string
    //

    for ( cT = 0, iA = 1 ; iA < argc ; ++iA )
    {
        if ( argv[iA][0] != '-' )
        {
            strcpy( pTargets + cT, argv[iA] );
            cT += strlen( argv[iA] ) + 1;
        }
    }
    pTargets[cT] = '\0';

    //
    // call synchronize method
    //

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( SUCCEEDED( hRes = CoCreateInstance( CLSID_MDSync, NULL, CLSCTX_INPROC_SERVER,  IID_IMDSync, (LPVOID*)&pIf ) ) )
    {
        hThread = CreateThread( NULL, 0, ::Monitor, NULL, 0, &dwThreadId );

        hRes = pIf->Synchronize( pTargets, pdwErr, dwFlags, (LPDWORD)g_pStat );

        g_fDone = TRUE;

        if ( hThread )
        {
            WaitForSingleObject( hThread, INFINITE );
        }
        printf( "\n" );

        pIf->Release();

        if ( FAILED( hRes ) && hRes != E_FAIL )
        {
            DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
            Status = 2;
        }
        else
        {
            for ( cT = 0, iA = 1, iT = 0 ; iA < argc ; ++iA )
            {
                if ( argv[iA][0] != '-' )
                {
                    if ( pdwErr[iT] )
                    {
                        printf( g_achMsg5, argv[iA] );
                        DisplayErrorMessage( pdwErr[iT] );
                        printf( g_achMsg6, pdwErr[iT], pdwErr[iT] );
                        fAtLeastOnError = TRUE;
                    }
                    else
                    {
                        printf( g_achMsg4, argv[iA] );
                    }
                    ++iT;
                }
            }

            if ( fAtLeastOnError )
            {
                Status = 2;
            }
        }
    }
    else
    {
        DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
        Status = 2;
    }

    CoUninitialize();

    LocalFree( g_pStat );
    LocalFree( pTargets );
    LocalFree( pdwErr );

    if ( Status )
    {
        printf( g_achMsg8 );
    }
    else
    {
        printf( g_achMsg7 );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\admex\smtpprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      smtpprop.h
//
//  Abstract:
//      Definition of the CSMTPVirtualRootParamsPage class, which implements the
//      Parameters page for IIS resources.
//
//  Implementation File:
//      Iis.cpp
//
//  Author:
//      Pete Benoit (v-pbenoi)  October 16, 1996
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMTPPROP_H_
#define _SMTPPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

#include "ConstDef.h"   // for IIS_SVC_NAME_SMTP
#include "Iis.h"		// for IISMapper

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CSMTPVirtualRootParamsPage;
class IISMapper;

/////////////////////////////////////////////////////////////////////////////
//
//  CSMTPVirtualRootParamsPage
//
//  Purpose:
//      Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CSMTPVirtualRootParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CSMTPVirtualRootParamsPage)

// Construction
public:
    CSMTPVirtualRootParamsPage(void);

// Dialog Data
    //{{AFX_DATA(CSMTPVirtualRootParamsPage)
    enum { IDD = IDD_PP_SMTP_PARAMETERS };
    CButton m_ckbWrite;
    CButton m_ckbRead;
    CButton m_groupAccess;
    CEdit   m_editPassword;
    CStatic m_staticPassword;
    CEdit   m_editAccountName;
    CStatic m_staticAccountName;
    CButton m_groupAccountInfo;
    CEdit   m_editDirectory;
    CString m_strDirectory;
    CString m_strAccountName;
    CString m_strPassword;
    CEdit   m_editInstanceId;
    CComboBox m_cInstanceId;
    CString m_strInstanceName;
    CString m_strInstanceId;
    BOOL    m_bRead;
    BOOL    m_bWrite;
    //}}AFX_DATA
    CString m_strServiceName;
    CString m_strPrevServiceName;
    CString m_strPrevDirectory;
    CString m_strPrevAccountName;
    CString m_strPrevPassword;
    CString m_strPrevInstanceId;
    DWORD   m_dwAccessMask;
    DWORD   m_dwPrevAccessMask;

protected:
    enum
    {
        epropServiceName,
        epropInstanceId,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSMTPVirtualRootParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    void FillServerList();
    void SetEnableNext();


private:
    BOOL   m_fReadList;
    CArray <IISMapper, IISMapper>  m_ServiceArray;

    LPWSTR  NameToMetabaseId( CString&  strName);
    LPWSTR  MetabaseIdToName( CString&  strId);
    HRESULT ReadList(CArray <IISMapper, IISMapper>* pMapperArray, LPWSTR pszPath, LPCWSTR wcsServerName);


// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSMTPVirtualRootParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeRequiredField();
    afx_msg void OnRefresh();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CSMTPVirtualRootParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _SMTPPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\inc\clusres.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusres.h

Abstract:

    Common Resource DLL Header

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusudef.h"
#include "clusapi.h"
#include "resapi.h"
#include "clusvmsg.h"


#define LOCAL_SERVICES  L"System\\CurrentControlSet\\Services"

extern PLOG_EVENT_ROUTINE ClusResLogEvent;
extern PSET_RESOURCE_STATUS_ROUTINE ClusResSetResourceStatus;

//
// Cluster Resource Specific routines
//

DWORD
ClusResOpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    );

NTSTATUS
ClusResDoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );


//
// Helpful macros for logging cluster service events
//
VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusResLogEventWithName1(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

#define ClusResLogEventByKey(_hKey_, _level_, _msgid_)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL)

#define ClusResLogEventByKey1(_hKey_, _level_, _msgid_, _arg1_)       \
    ClusResLogEventWithName1(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_)

#define ClusResLogEventByKeyData(_hKey_, _level_, _msgid_, dwBytes, pData)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL)

#define ClusResLogEvent(_level_, _msgid_)           \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL)

#define ClusResLogEvent1(_level_, _msgid_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define ClusResLogEvent2(_level_, _msgid_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogEvent3(_level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

#define ClusResLogEventData(_level_, _msgid_, _dwBytes_, _pData_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_))

#define ClusResLogEventData1(_level_, _msgid_, _dwBytes_, _pData_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_))

#define ClusResLogEventData2(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogEventData3(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

//
// Define interfaces exposed by each specified resource DLL and
// referenced by the common CLUSRES wrapper.
//
#define LOG_MODULE_GENAPP    0x801
#define LOG_MODULE_GENSVC    0x802
#define LOG_MODULE_FTSET     0x803
#define LOG_MODULE_DISK      0x804
#define LOG_MODULE_NETNAME   0x805
#define LOG_MODULE_IPADDR    0x806
#define LOG_MODULE_SMB       0x807
#define LOG_MODULE_TIME      0x808
#define LOG_MODULE_SPOOL     0x809
#define LOG_MODULE_LKQRM     0x80A
#define LOG_MODULE_DHCP      0x80B
#define LOG_MODULE_MSMQ      0x80C
#define LOG_MODULE_MSDTC     0x80D

//
// interfaces for GENAPP
//
extern CLRES_FUNCTION_TABLE GenAppFunctionTable;

BOOLEAN
WINAPI
GenAppDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for GENSVC
//
extern CLRES_FUNCTION_TABLE GenSvcFunctionTable;

BOOLEAN
WINAPI
GenSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for DISKS and FTSET
//
extern CLRES_FUNCTION_TABLE DisksFunctionTable;
extern CLRES_FUNCTION_TABLE FtSetFunctionTable;

BOOLEAN
WINAPI
DisksDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

BOOLEAN
WINAPI
FtSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for NETNAME
//
extern CLRES_FUNCTION_TABLE NetNameFunctionTable;

BOOLEAN
WINAPI
NetNameDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for IPADDR
//
extern CLRES_FUNCTION_TABLE IpAddrFunctionTable;

BOOLEAN
WINAPI
IpAddrDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for File Shares
//
extern CLRES_FUNCTION_TABLE SmbShareFunctionTable;

BOOLEAN
WINAPI
SmbShareDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Spool Service
//
extern CLRES_FUNCTION_TABLE SplSvcFunctionTable;

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for Local Quorum
//
extern CLRES_FUNCTION_TABLE LkQuorumFunctionTable;

BOOLEAN
WINAPI
LkQuorumDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE DhcpFunctionTable;

BOOLEAN
WINAPI
DhcpDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE MsMQFunctionTable;

BOOLEAN
WINAPI
MsMQDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE MsDTCFunctionTable;

BOOLEAN
WINAPI
MsDTCDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE TimeSvcFunctionTable;

BOOLEAN
WINAPI
TimeSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\inc\clusudef.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clusudef.h

Abstract:

    This module contains definitions of constants used across
    multiple user-mode targets in the cluster project.

Revision History:


Environment:

    User-mode only.

--*/

#ifndef _CLUSUDEF_H_
#define _CLUSUDEF_H_

//
// Default group property definitions
//
#define CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD    10
#define CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD       6
#define CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE    ClusterGroupPreventFailback
#define CLUSTER_GROUP_FAILBACK_WINDOW_NONE          ((DWORD) -1)
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END   CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_LOADBAL_STATE         1

//
// Default resource property definitions
//
#define CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL  ((DWORD) -1)
#define CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE        CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_IS_ALIVE           CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION     ClusterResourceRestartNotify
#define CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD  3
#define CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD     (900 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT    (3 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_STARTUP    (5 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_SAMPLE     (    10 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_ANALYSIS   (5 * 60 * 1000)

//
// Default resource type property definitions
//
#define CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE     (5 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_IS_ALIVE        (60 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_QUORUM_CAPABLE  FALSE

//
// Default quorum definitions
//
#define CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE     64 * 1024  // 64K
#define CLUSTER_QUORUM_MIN_LOG_SIZE             32 * 1024 //32 K

//
// Key, value, and property names
//
#define CLUSREG_KEYNAME_GROUPS              L"Groups"
#define CLUSREG_KEYNAME_NETWORKS            L"Networks"
#define CLUSREG_KEYNAME_NETINTERFACES       L"NetworkInterfaces"
#define CLUSREG_KEYNAME_NODES               L"Nodes"
#define CLUSREG_KEYNAME_QUORUM              L"Quorum"
#define CLUSREG_KEYNAME_RESOURCES           L"Resources"
#define CLUSREG_KEYNAME_RESOURCE_TYPES      L"ResourceTypes"
#define CLUSREG_KEYNAME_PARAMETERS          L"Parameters"

#define CLUSREG_NAME_CHARACTERISTICS        L"Characteristics"
#define CLUSREG_NAME_FLAGS                  L"Flags"
#define CLUSREG_NAME_ADMIN_EXT              L"AdminExtensions"

#define CLUSREG_NAME_CLUS_NAME              L"ClusterName"
#define CLUSREG_NAME_CLUS_DESC              L"Description"
#define CLUSREG_NAME_CLUS_SECURITY          L"Security"
#define CLUSREG_NAME_CLUS_CLUSTER_NAME_RES  L"ClusterNameResource"
#define CLUSREG_NAME_CLUS_REG_SEQUENCE      L"RegistrySequence"

#define CLUSREG_NAME_NODE_NAME              L"NodeName"
#define CLUSREG_NAME_NODE_DESC              L"Description"
#define CLUSREG_NAME_NODE_PAUSED            L"Paused"

#define CLUSREG_NAME_GRP_NAME               L"Name"
#define CLUSREG_NAME_GRP_DESC               L"Description"
#define CLUSREG_NAME_GRP_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_GRP_FAILBACK_TYPE      L"AutoFailbackType"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_START L"FailbackWindowStart"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_END   L"FailbackWindowEnd"
#define CLUSREG_NAME_GRP_FAILOVER_THRESHOLD L"FailoverThreshold"
#define CLUSREG_NAME_GRP_FAILOVER_PERIOD    L"FailoverPeriod"
#define CLUSREG_NAME_GRP_PREFERRED_OWNERS   L"PreferredOwners"
#define CLUSREG_NAME_GRP_CONTAINS           L"Contains"
#define CLUSREG_NAME_GRP_LOADBAL_STATE      L"LoadBalState"

#define CLUSREG_NAME_RES_NAME               L"Name"
#define CLUSREG_NAME_RES_TYPE               L"Type"
#define CLUSREG_NAME_RES_DESC               L"Description"
#define CLUSREG_NAME_RES_DEBUG_PREFIX       L"DebugPrefix"
#define CLUSREG_NAME_RES_SEPARATE_MONITOR   L"SeparateMonitor"
#define CLUSREG_NAME_RES_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_RES_LOOKS_ALIVE        L"LooksAlivePollInterval"
#define CLUSREG_NAME_RES_IS_ALIVE           L"IsAlivePollInterval"
#define CLUSREG_NAME_RES_RESTART_ACTION     L"RestartAction"
#define CLUSREG_NAME_RES_RESTART_THRESHOLD  L"RestartThreshold"
#define CLUSREG_NAME_RES_RESTART_PERIOD     L"RestartPeriod"
#define CLUSREG_NAME_RES_PENDING_TIMEOUT    L"PendingTimeout"
#define CLUSREG_NAME_RES_POSSIBLE_OWNERS    L"PossibleOwners"
#define CLUSREG_NAME_RES_DEPENDS_ON         L"DependsOn"
#define CLUSREG_NAME_RES_LOADBAL_STARTUP    L"LoadBalStartupInterval"
#define CLUSREG_NAME_RES_LOADBAL_SAMPLE     L"LoadBalSampleInterval"
#define CLUSREG_NAME_RES_LOADBAL_ANALYSIS   L"LoadBalAnalysisInterval"
#define CLUSREG_NAME_RES_LOADBAL_PROCESSOR  L"LoadBalMinProcessorUnits"
#define CLUSREG_NAME_RES_LOADBAL_MEMORY     L"LoadBalMinMemoryUnits"

#define CLUSREG_NAME_RESTYPE_NAME           L"Name"
#define CLUSREG_NAME_RESTYPE_DESC           L"Description"
#define CLUSREG_NAME_RESTYPE_LOOKS_ALIVE    L"LooksAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_IS_ALIVE       L"IsAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_DLL_NAME       L"DllName"
#define CLUSREG_NAME_RESTYPE_DEBUG_PREFIX   L"DebugPrefix"

#define CLUSREG_NAME_NET_NAME               L"Name"
#define CLUSREG_NAME_NET_DESC               L"Description"
#define CLUSREG_NAME_NET_ROLE               L"Role"
#define CLUSREG_NAME_NET_PRIORITY           L"Priority"
#define CLUSREG_NAME_NET_TRANSPORT          L"Transport"
#define CLUSREG_NAME_NET_ADDRESS            L"Address"
#define CLUSREG_NAME_NET_ADDRESS_MASK       L"AddressMask"

#define CLUSREG_NAME_NETIFACE_NAME          L"Name"
#define CLUSREG_NAME_NETIFACE_DESC          L"Description"
#define CLUSREG_NAME_NETIFACE_NODE          L"Node"
#define CLUSREG_NAME_NETIFACE_NETWORK       L"Network"
#define CLUSREG_NAME_NETIFACE_ADAPTER       L"Adapter"
#define CLUSREG_NAME_NETIFACE_ADDRESS       L"Address"
#define CLUSREG_NAME_NETIFACE_ENDPOINT      L"ClusnetEndpoint"

#define CLUSREG_NAME_QUORUM_RESOURCE        L"Resource"
#define CLUSREG_NAME_QUORUM_PATH            L"Path"
#define CLUSREG_NAME_QUORUM_MAX_LOG_SIZE    L"MaxQuorumLogSize"

#define CLUSREG_NAME_PROXY_RETRY_COUNT      L"RetryCount"
#define CLUSREG_NAME_PROXY_RETRY_INTERVAL   L"RetryInterval"

//
// Standard Resource Type Names
//
#define CLUS_RESTYPE_NAME_GENAPP    L"Generic Application"
#define CLUS_RESTYPE_NAME_GENSVC    L"Generic Service"
#define CLUS_RESTYPE_NAME_FTSET     L"Fault Tolerant Disk Set"
#define CLUS_RESTYPE_NAME_PHYS_DISK L"Physical Disk"
#define CLUS_RESTYPE_NAME_IPADDR    L"IP Address"
#define CLUS_RESTYPE_NAME_NETNAME   L"Network Name"
#define CLUS_RESTYPE_NAME_FILESHR   L"File Share"
#define CLUS_RESTYPE_NAME_PRTSPLR   L"Print Spooler"
#define CLUS_RESTYPE_NAME_TIMESVC   L"Time Service"
#define CLUS_RESTYPE_NAME_LKQUORUM  L"Local Quorum"
#define CLUS_RESTYPE_NAME_DHCP      L"DHCP Server"
#define CLUS_RESTYPE_NAME_MSMQ      L"Microsoft Message Queue Server"
#define CLUS_RESTYPE_NAME_MSDTC     L"Distributed Transaction Coordinator"


#define CLUS_NAME_DEFAULT_FILESPATH L"MSCS\\"

#endif // _CLUSUDEF_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\regc.cpp ===
// regc.cpp : Implementation of Cregc
#include "stdafx.h"
#include "mdsync.h"
#include "regc.h"

/////////////////////////////////////////////////////////////////////////////
// Cregc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\inc\clusvmsg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    clusmsg.h

Abstract:

    This file contains the message definitions for the cluster manager.

Author:

    Mike Massa (mikemas) 2-Jan-1996

Revision History:

Notes:

    This file is generated from clusmsg.mc

--*/

#ifndef _CLUS_MSG_
#define _CLUS_MSG_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: UNEXPECTED_FATAL_ERROR
//
// MessageText:
//
//  The Cluster Service suffered an unexpected fatal error
//  at line %1 of file %2. The error code was %3.
//
#define UNEXPECTED_FATAL_ERROR           0x000003E8L

//
// MessageId: ASSERTION_FAILURE
//
// MessageText:
//
//  The Cluster Service failed a validity check on line
//  %1 of file %2.
//  "%3"
//
#define ASSERTION_FAILURE                0x000003E9L

//
// MessageId: LOG_FAILURE
//
// MessageText:
//
//  The Cluster Service handled an unexpected error
//  at line %1 of file %2. The error code was %3.
//
#define LOG_FAILURE                      0x000003EAL

//
// MessageId: INVALID_RESOURCETYPE_DLLNAME
//
// MessageText:
//
//  The DllName value for the %1!ws! resource type key does not exist.
//  Resources of this type will not be monitored. The error was %2!d!.
//
#define INVALID_RESOURCETYPE_DLLNAME     0x000003EBL

//
// MessageId: INVALID_RESOURCETYPE_LOOKSALIVE
//
// MessageText:
//
//  The LooksAlive poll interval for the %1!ws! resource type key does not exist.
//  Resources of this type will not be monitored. The error was %2!d!.
//
#define INVALID_RESOURCETYPE_LOOKSALIVE  0x000003ECL

//
// MessageId: INVALID_RESOURCETYPE_ISALIVE
//
// MessageText:
//
//  The IsAlive poll interval for the %1!ws! resource type key does not exist.
//  Resources of this type will not be monitored. The error was %2!d!.
//
#define INVALID_RESOURCETYPE_ISALIVE     0x000003EDL

//
// MessageId: NM_EVENT_HALT
//
// MessageText:
//
//  The Windows NT Cluster Service was halted due to a regroup error or poison
//  packet.
//
#define NM_EVENT_HALT                    0x000003EEL

//
// MessageId: NM_EVENT_NEW_NODE
//
// MessageText:
//
//  A new node, %1, has been added to the cluster.
//
#define NM_EVENT_NEW_NODE                0x000003EFL

//
// MessageId: RMON_INVALID_COMMAND_LINE
//
// MessageText:
//
//  The Cluster Resource Monitor was started with the invalid
//  command line %1.
//
#define RMON_INVALID_COMMAND_LINE        0x000003F0L

//
// MessageId: SERVICE_FAILED_JOIN_OR_FORM
//
// MessageText:
//
//  The Cluster Service could not join an existing cluster and could not form
//  a new cluster. The Cluster Service has terminated.
//
#define SERVICE_FAILED_JOIN_OR_FORM      0x000003F1L

//
// MessageId: SERVICE_FAILED_NOT_MEMBER
//
// MessageText:
//
//  The Cluster Service is shutting down because the current node is not a
//  member of any cluster. Windows NT Clusters must be reinstalled to make
//  this node a member of a cluster.
//
#define SERVICE_FAILED_NOT_MEMBER        0x000003F2L

//
// MessageId: NM_NODE_EVICTED
//
// MessageText:
//
//  Cluster Node %1 has been evicted from the cluster.
//
#define NM_NODE_EVICTED                  0x000003F3L

//
// MessageId: SERVICE_FAILED_INVALID_OS
//
// MessageText:
//
//  The Cluster Service did not start because the current version of Windows
//  NT is not correct. This beta only runs on Windows NT Server 4.0 (build 1381)
//  with SP2 RC1.3
//
#define SERVICE_FAILED_INVALID_OS        0x000003F4L

//
// MessageId: ERROR_LOG_QUORUM_ONLINEFAILED
//
// MessageText:
//
//  The quorum resource failed to come online.
//
#define ERROR_LOG_QUORUM_ONLINEFAILED    0x000003F5L

//
// MessageId: ERROR_LOG_FILE_OPENFAILED
//
// MessageText:
//
//  The quorum log file couldnt be opened.
//
#define ERROR_LOG_FILE_OPENFAILED        0x000003F6L

//
// MessageId: ERROR_LOG_CHKPOINT_UPLOADFAILED
//
// MessageText:
//
//  The checkpoint could not be uploaded.
//
#define ERROR_LOG_CHKPOINT_UPLOADFAILED  0x000003F7L

//
// MessageId: ERROR_QUORUM_RESOURCE_NOTFOUND
//
// MessageText:
//
//  The quorum resource was not found.
//
#define ERROR_QUORUM_RESOURCE_NOTFOUND   0x000003F8L

//
// MessageId: ERROR_LOG_NOCHKPOINT
//
// MessageText:
//
//  No checkpoint record was found in the log file.
//
#define ERROR_LOG_NOCHKPOINT             0x000003F9L

//
// MessageId: ERROR_LOG_CHKPOINT_GETFAILED
//
// MessageText:
//
//  Failed to obtain a checkpoint.
//
#define ERROR_LOG_CHKPOINT_GETFAILED     0x000003FAL

//
// MessageId: ERROR_LOG_EXCEEDS_MAXSIZE
//
// MessageText:
//
//  The log file exceeds its maximum size,  will be reset.
//
#define ERROR_LOG_EXCEEDS_MAXSIZE        0x000003FBL

//
// MessageId: CS_COMMAND_LINE_HELP
//
// MessageText:
//
//  The Cluster Service can be started from the Services applet in the Control
//  Panel or by issuing the command "net start clussvc" at a command prompt.
//
#define CS_COMMAND_LINE_HELP             0x000003FCL

//
// MessageId: ERROR_LOG_CORRUPT
//
// MessageText:
//
//  The Quorum log file is corrupt.
//
#define ERROR_LOG_CORRUPT                0x000003FDL

//
// MessageId: ERROR_QUORUMOFFLINE_DENIED
//
// MessageText:
//
//  The Quorum resource cannot be brought offline.
//
#define ERROR_QUORUMOFFLINE_DENIED       0x000003FEL

//
// MessageId: ERROR_LOG_EXCEEDS_MAXRECORDSIZE
//
// MessageText:
//
//  A log record wasnt logged in the quorum log file since its size exceeded the 
//  permitted maximum size.
//
#define ERROR_LOG_EXCEEDS_MAXRECORDSIZE  0x000003FFL

#endif // _CLUS_MSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\cr.cxx ===
#define UNICODE
#define INITGUID
#include    <windows.h>
#include    <stdio.h>
#include    <clusapi.h>

typedef HCLUSTER
(WINAPI *PFN_OPENCLUSTER)(
    IN LPCWSTR lpszClusterName
    );

typedef BOOL
(WINAPI *PFN_CLOSECLUSTER)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_CREATECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszResourceTypeDll,
    IN DWORD dwLooksAlivePollInterval,
    IN DWORD dwIsAlivePollInterval
    );

typedef DWORD
(WINAPI *PFN_DELETECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName
    );

typedef HCLUSENUM
(WINAPI
*PFN_ClusterOpenEnum)(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    );

typedef DWORD
(WINAPI
*PFN_ClusterEnum)(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );

typedef DWORD
(WINAPI
*PFN_ClusterCloseEnum)(
    IN HCLUSENUM hEnum
    );

typedef HRESOURCE
(WINAPI
*PFN_OpenClusterResource)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    );

typedef BOOL
(WINAPI
*PFN_CloseClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_DeleteClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_OfflineClusterResource)(
    IN HRESOURCE hResource
    );

typedef HKEY
(WINAPI
*PFN_GetClusterResourceKey)(
    IN HRESOURCE hResource,
    IN REGSAM samDesired
    );

typedef LONG
(WINAPI
*PFN_ClusterRegCloseKey)(
    IN HKEY hKey
    );

typedef LONG
(WINAPI
*PFN_ClusterRegQueryValue)(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef CLUSTER_RESOURCE_STATE
(WINAPI
*PFN_GetClusterResourceState)(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcbNodeName,
    OUT OPTIONAL LPWSTR lpszGroupName,
    IN OUT LPDWORD lpcbGroupName
    );

typedef DWORD
(WINAPI *PFN_DLLREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_DLLUNREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );

BOOL
RegisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszResTypeDisplayName,
    LPWSTR pszPath,
    LPWSTR pszAdminPath
    )
{
    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_CREATECLUSTERRESOURCETYPE   pfnCreateClusterResourceType;
    HRESULT                         hres;

    if ( hClusapi = LoadLibrary( L"clusapi.dll" ) )
    {
        pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
        pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
        pfnCreateClusterResourceType = (PFN_CREATECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "CreateClusterResourceType" );

        if ( pfnOpenCluster &&
             pfnCloseCluster &&
             pfnCreateClusterResourceType )
        {
            if ( hC = pfnOpenCluster( NULL ) )
            {
                hres = pfnCreateClusterResourceType(
                    hC,
                    pszResType,
                    pszResType,
                    pszPath,
                    5000,
                    60000 );
       

                if ( SUCCEEDED( hres ) )
                {
                    HINSTANCE                           hAdmin;
                    PFN_DLLREGISTERCLUADMINEXTENSION    pfnDllRegisterCluAdminExtension;

                    if ( hAdmin = LoadLibrary( pszAdminPath ) )
                    {
                        pfnDllRegisterCluAdminExtension = 
                            (PFN_DLLREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllRegisterCluAdminExtension" );
                        if ( pfnDllRegisterCluAdminExtension )
                        {
                            if ( FAILED(hres = pfnDllRegisterCluAdminExtension( hC )) )
                            {
                                dwErr = hres;
                            }
                        }
                        else
                        {
                            dwErr = GetLastError();
                        }
                        FreeLibrary( hAdmin );
                    }
                    else
                    {
                        dwErr = GetLastError();
                    }
                }
                else
                {
                    dwErr = hres;
                }

                pfnCloseCluster( hC );

                if ( dwErr )
                {
                    SetLastError( dwErr );
                }
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        FreeLibrary( hClusapi );
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


BOOL
UnregisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszAdminPath
    )
{
    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_DELETECLUSTERRESOURCETYPE   pfnDeleteClusterResourceType;
    PFN_ClusterOpenEnum             pfnClusterOpenEnum;
    PFN_ClusterEnum                 pfnClusterEnum;
    PFN_ClusterCloseEnum            pfnClusterCloseEnum;
    PFN_OpenClusterResource         pfnOpenClusterResource;
    PFN_CloseClusterResource        pfnCloseClusterResource;
    PFN_DeleteClusterResource       pfnDeleteClusterResource;
    PFN_OfflineClusterResource      pfnOfflineClusterResource;
    PFN_GetClusterResourceKey       pfnGetClusterResourceKey;
    PFN_ClusterRegCloseKey          pfnClusterRegCloseKey;
    PFN_ClusterRegQueryValue        pfnClusterRegQueryValue;
    PFN_GetClusterResourceState     pfnGetClusterResourceState;
    HRESULT                         hres;
    HCLUSENUM                       hClusEnum;
    WCHAR                           awchResName[256];
    WCHAR                           awchResType[256];
    DWORD                           dwEnum;
    DWORD                           dwType;
    DWORD                           dwStrLen;
    HRESOURCE                       hRes;
    HKEY                            hKey;
    BOOL                            fDel;
    DWORD                           dwRetry;


    if ( hClusapi = LoadLibrary( L"clusapi.dll" ) )
    {
        pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
        pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
        pfnDeleteClusterResourceType = (PFN_DELETECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "DeleteClusterResourceType" );
        pfnClusterOpenEnum = (PFN_ClusterOpenEnum)GetProcAddress( hClusapi, "ClusterOpenEnum" );
        pfnClusterEnum = (PFN_ClusterEnum)GetProcAddress( hClusapi, "ClusterEnum" );
        pfnClusterCloseEnum = (PFN_ClusterCloseEnum)GetProcAddress( hClusapi, "ClusterCloseEnum" );
        pfnOpenClusterResource = (PFN_OpenClusterResource)GetProcAddress( hClusapi, "OpenClusterResource" );
        pfnCloseClusterResource = (PFN_CloseClusterResource)GetProcAddress( hClusapi, "CloseClusterResource" );
        pfnDeleteClusterResource = (PFN_DeleteClusterResource)GetProcAddress( hClusapi, "DeleteClusterResource" );
        pfnOfflineClusterResource = (PFN_OfflineClusterResource)GetProcAddress( hClusapi, "OfflineClusterResource" );
        pfnGetClusterResourceKey = (PFN_GetClusterResourceKey)GetProcAddress( hClusapi, "GetClusterResourceKey" );
        pfnClusterRegCloseKey = (PFN_ClusterRegCloseKey)GetProcAddress( hClusapi, "ClusterRegCloseKey" );
        pfnClusterRegQueryValue = (PFN_ClusterRegQueryValue)GetProcAddress( hClusapi, "ClusterRegQueryValue" );
        pfnGetClusterResourceState = (PFN_GetClusterResourceState)GetProcAddress( hClusapi, "GetClusterResourceState" );

        if ( pfnOpenCluster &&
             pfnCloseCluster &&
             pfnDeleteClusterResourceType &&
             pfnClusterOpenEnum &&
             pfnClusterEnum &&
             pfnClusterCloseEnum &&
             pfnOpenClusterResource &&
             pfnCloseClusterResource &&
             pfnDeleteClusterResource &&
             pfnOfflineClusterResource &&
             pfnGetClusterResourceKey &&
             pfnClusterRegCloseKey &&
             pfnClusterRegQueryValue &&
             pfnGetClusterResourceState )
        {
            if ( hC = pfnOpenCluster( NULL ) )
            {
                //
                // Delete all resources of type pszResType
                //

                if ( (hClusEnum = pfnClusterOpenEnum( hC, CLUSTER_ENUM_RESOURCE )) != NULL )
                {
                    for ( dwEnum = 0 ;
                          pfnClusterEnum( hClusEnum, 
                                          dwEnum, 
                                          &dwType, 
                                          awchResName, 
                                          &(dwStrLen=sizeof(awchResName)/sizeof(WCHAR)) ) 
                                  == ERROR_SUCCESS ;
                          ++dwEnum )
                    {
                        if ( hRes = pfnOpenClusterResource( hC, awchResName ) )
                        {
                            if ( hKey = pfnGetClusterResourceKey( hRes, KEY_READ ) )
                            {
                                dwStrLen = sizeof(awchResType)/sizeof(WCHAR);

                                fDel = pfnClusterRegQueryValue( hKey, 
                                                                L"Type", 
                                                                &dwType, 
                                                                (LPBYTE)awchResType, 
                                                                &dwStrLen )
                                            == ERROR_SUCCESS &&
                                       !wcscmp( awchResType, pszResType );

                                pfnClusterRegCloseKey( hKey );

                                if ( fDel )
                                {
                                    pfnOfflineClusterResource( hRes );
                                    for ( dwRetry = 0 ;
                                          dwRetry < 30 &&
                                              pfnGetClusterResourceState( hRes,
                                                                          NULL,
                                                                          &dwStrLen,
                                                                          NULL,
                                                                          &dwStrLen )
                                              != ClusterResourceOffline ;
                                          ++dwRetry )
                                    {
                                        Sleep( 1000 );
                                    }
                                    pfnDeleteClusterResource( hRes );
                                }
                            }

                            pfnCloseClusterResource( hRes );
                        }
                    }

                    pfnClusterCloseEnum( hClusEnum );
                }

                dwErr = pfnDeleteClusterResourceType(
                    hC,
                    pszResType );
       
                    HINSTANCE                           hAdmin;
                    PFN_DLLUNREGISTERCLUADMINEXTENSION  pfnDllUnregisterCluAdminExtension;

                if ( hAdmin = LoadLibrary( pszAdminPath ) )
                {
                    pfnDllUnregisterCluAdminExtension = 
                        (PFN_DLLUNREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllUnregisterCluAdminExtension" );
                    if ( pfnDllUnregisterCluAdminExtension )
                    {
                        if ( FAILED(hres = pfnDllUnregisterCluAdminExtension( hC )) )
                        {
                            dwErr = hres;
                        }
                    }
                    else
                    {
                        dwErr = GetLastError();
                    }
                    FreeLibrary( hAdmin );
                }
                else
                {
                    dwErr = GetLastError();
                }

                pfnCloseCluster( hC );

                if ( dwErr )
                {
                    SetLastError( dwErr );
                }
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        FreeLibrary( hClusapi );
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


int __cdecl main( int argc, char*argv[] )
{
    BOOL fSt;

    if ( !strcmp(argv[1],"install" ) )
    {
        fSt = RegisterIisServerInstanceResourceType(
            L"IIS Server Instance",                          // do not touch
            L"IIS Server Instance",                          // do not touch
            L"c:\\winnt\\system32\\inetsrv\\clusiis4.dll",   // path to clusiis4.dll
	    L"c:\\winnt\\system32\\inetsrv\\iisclex4.dll" ); // path to admin ext
    }
    else
    {
        fSt = UnregisterIisServerInstanceResourceType(
            L"IIS Server Instance",                          // do not touch
	    L"c:\\winnt\\system32\\inetsrv\\iisclex4.dll" ); // path to admin ext
    }

    if ( !fSt )
    {
        printf( "Error %d\n", GetLastError() );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\inc\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 <company name>
//
//	Module Name:
//		ExtObj.h
//
//	Abstract:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoSmbSmpEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;
	HKEY					m_hkey;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

	virtual ~CResData(void) { }

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoSmbSmpEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.SmbSmpEx"), _T("CLUADMEX.SmbSmpEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	HKEY						m_hkeyCluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	HKEY						HkeyCluster(void) const			{ return m_hkeyCluster; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) m_podObjData; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sync.rc
//
#define IDS_PROJNAME                    100
#define IDS_MDSYNC_DESC                 101
#define IDR_MdSync                      102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\mdsync.cpp ===
// MdSync.cpp : Implementation of CSyncApp and DLL registration.


extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
}   // extern "C"

#include <limits.h>
#include <ole2.h>
#include <wincrypt.h>

#include <dbgutil.h>
#include <buffer.hxx>

#include "mdsync.h"
#include "stdafx.h"
#include <iadmext.h>


#define ADMEX
#if defined(ADMEX)
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <admex.h>
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#endif
#include "mdsync.hxx"

//
#include "comrepl_i.c"
#include "comrepl.h"

//
// Global Functions
//

HRESULT
MTS_Propagate2
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
/* [in] */ DWORD dwSignatureMismatch
);


//
// Globals
//

DWORD g_dwFalse = FALSE;

const INT COMPUTER_CHARACTER_SIZE = 64;

/////////////////////////////////////////////////////////////////////////////
//

CProps::CProps(
    )
/*++

Routine Description:

    Property list constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_Props = NULL;
    m_dwProps = m_dwLenProps = 0;
    m_lRefCount = 0;
}


CProps::~CProps(
    )
/*++

Routine Description:

    Property list destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_Props )
    {
        LocalFree( m_Props );
    }
}


CNodeDesc::CNodeDesc(
    CSync* pSync
    )
/*++

Routine Description:

    Metabase node descriptor constructor

Arguments:

    pSync - ptr to synchronizer object

Returns:

    Nothing

--*/
{
    InitializeListHead(&m_ChildHead);
    m_pszPath = NULL;
    m_pSync = pSync;
    m_fHasProps = FALSE;
    m_fHasObjs = FALSE;
}


CNodeDesc::~CNodeDesc(
    )
/*++

Routine Description:

    Metabase node descriptor destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    LIST_ENTRY*     pChild;
    CNodeDesc*      pNode;

    if ( m_pszPath )
    {
        LocalFree( m_pszPath );
    }

    while ( !IsListEmpty( &m_ChildHead ))
    {
        pNode = CONTAINING_RECORD( m_ChildHead.Flink,
                                   CNodeDesc,
                                   m_ChildList );

        RemoveEntryList( &pNode->m_ChildList );

        delete pNode;
    }
}


BOOL
CNodeDesc::BuildChildObjectsList(
    CMdIf*  pMd,
    LPWSTR  pszPath
)
/*++

Routine Description:

    Build list of child object of this node

Arguments:

    pMd - metabase admin interface
    pszPath - path of current node

Returns:

    Nothing

--*/
{
    CNodeDesc*  pChild;
    WCHAR       achPath[METADATA_MAX_NAME_LEN*2];
    WCHAR       achSrcPath[METADATA_MAX_NAME_LEN];
    DWORD       dwP = wcslen( pszPath );
    UINT        i;
    DWORD       dwRequired;

    //
    // Ugly path trick : metabase will remove trailing '/',
    // so to specify an empty directory at the end of path
    // must add an additional trailing '/'
    //

    memcpy( achSrcPath, pszPath, (dwP + 1) * sizeof(WCHAR) );
    if ( dwP && pszPath[dwP-1] == L'/' )
    {
        achSrcPath[dwP] = L'/';
        achSrcPath[dwP+1] = L'\0';
    }

    memcpy( achPath, pszPath, dwP * sizeof(WCHAR) );
    achPath[dwP++] = L'/';

    //
    // enumerate child
    //

    for ( i = 0 ; ; ++i )
    {
        if ( pMd->Enum( achSrcPath, i, achPath+dwP ) )
        {
            if ( pChild = new CNodeDesc( m_pSync ) )
            {
                pChild->SetPath( achPath );
                InsertHeadList( &m_ChildHead, &pChild->m_ChildList );
            }
            else
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return FALSE;
            }
        }
        else if ( GetLastError() != ERROR_NO_MORE_ITEMS )
        {
            return FALSE;
        }
        else
        {
            break;
        }
    }

    return TRUE;
}


BOOL
CProps::GetAll(
    CMdIf*  pMd,
    LPWSTR  pszPath
    )
/*++

Routine Description:

    Get all properties for this node

Arguments:

    pMd - metabase admin interface
    pszPath - path of current node

Returns:

    Nothing

--*/
{
    DWORD   dwRec;
    DWORD   dwDataSet;
    BYTE    abBuff[4096];
    DWORD   dwRequired;

    if ( pMd->GetAllData( pszPath, &dwRec, &dwDataSet, abBuff, sizeof(abBuff), &dwRequired ) )
    {
        //
        // MetaBase does not update dwRequired supplied buffer is big enough
        // we must assume the whole buffer was used.
        //

        dwRequired = sizeof(abBuff);

        m_Props = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired );
        if ( !m_Props )
        {
            return FALSE;
        }
        m_dwProps = dwRec;
        m_dwLenProps = dwRequired;
        memcpy( m_Props, abBuff, dwRequired );
        return TRUE;
    }
    else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        m_Props = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired );
        if ( !m_Props )
        {
            return FALSE;
        }
        if ( pMd->GetAllData( pszPath, &dwRec, &dwDataSet, m_Props, dwRequired, &dwRequired ) )
        {
            m_dwLenProps = dwRequired;
            m_dwProps = dwRec;
            return TRUE;
        }
        LocalFree( m_Props );
        m_Props = NULL;
    }

    return FALSE;
}


BOOL
CSync::GetProp(
    LPWSTR  pszPath,
    DWORD   dwPropId,
    DWORD   dwUserType,
    DWORD   dwDataType,
    LPBYTE* ppBuf,
    LPDWORD pdwLen
    )
/*++

Routine Description:

    Get property for path

Arguments:

    pszPath - path of current node
    dwPropId - metadata property ID
    dwUserType - metadata user type
    dwDataType - metadata data type
    ppBuf - update with ptr to LocalAlloc'ed buffer or NULL if error
    pdwLen - updated with length

Returns:

    Nothing

--*/
{
    DWORD               dwRec;
    DWORD               dwDataSet;
    DWORD               dwRequired;
    METADATA_RECORD     md;

    memset( &md, '\0', sizeof(md) );

    md.dwMDDataType = dwDataType;
    md.dwMDUserType = dwUserType;
    md.dwMDIdentifier = dwPropId;

    md.dwMDDataLen = 0;

    if ( !wcsncmp( pszPath, L"LM/", 3 ) )
    {
        pszPath += 3;
    }

    if ( !m_Source.GetData( pszPath, &md, NULL, &dwRequired ) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        *ppBuf = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired );
        if ( !*ppBuf )
        {
            return FALSE;
        }

        *pdwLen = md.dwMDDataLen = dwRequired;

        if ( m_Source.GetData( pszPath, &md, *ppBuf, &dwRequired ) )
        {
            return TRUE;
        }
        LocalFree( *ppBuf );
    }

    *ppBuf = NULL;

    return FALSE;
}


CSync::CSync(
    )
/*++

Routine Description:

    Synchronizer constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pRoot = NULL;
    m_pTargets = NULL;
    m_dwTargets = 0;
    m_fCancel = FALSE;
    InitializeListHead( &m_QueuedRequestsHead );
    INITIALIZE_CRITICAL_SECTION( &m_csQueuedRequestsList );
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    m_fInScan = FALSE;
    m_cbSeed = SEED_MD_DATA_SIZE;
    memset( m_rgbSeed, 0, m_cbSeed );
}


CSync::~CSync(
    )
/*++

Routine Description:

    Synchronizer destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    UINT    i;

    if ( m_pTargets )
    {
        for ( i = 0 ; i < m_dwTargets ; ++i )
        {
            if ( m_pTargets[i] )
            {
                delete m_pTargets[i];
            }
        }

        LocalFree( m_pTargets );
    }

    LIST_ENTRY*     pChild;
    CNseRequest*    pReq;

    while ( !IsListEmpty( &m_QueuedRequestsHead ))
    {
        pReq = CONTAINING_RECORD( m_QueuedRequestsHead.Flink,
                                  CNseRequest,
                                  m_QueuedRequestsList );

        RemoveEntryList( &pReq->m_QueuedRequestsList );

        delete pReq;
    }

    DeleteCriticalSection( &m_csQueuedRequestsList );
    DeleteCriticalSection( &m_csLock );
}


VOID
CSync::SetTargetError(
    DWORD dwTarget,
    DWORD dwError
    )
/*++

Routine Description:

    Set error status for specified target

Arguments:

    dwTarget - target ID
    dwError - error code

Returns:

    Nothing

--*/
{
    m_TargetStatus.SetStatus( dwTarget, dwError );
}


DWORD
WINAPI
ScanThread(
    LPVOID pV
    )
/*++

Routine Description:

    thread scanning a target for synchronization

Arguments:

    pV - ptr to scan context

Returns:

    Error code, 0 if success

--*/
{
    HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if (FAILED(hr))
    {
        return HRESULTTOWIN32(hr);
    }

    THREAD_CONTEXT * pThreadContext = (THREAD_CONTEXT *)pV;
    CSync          * pSync          = (CSync *) pThreadContext->pvContext;

    if ( !( pSync->ScanTarget( pThreadContext->dwIndex)))
    {
        CoUninitialize();

        return GetLastError();
    }

    CoUninitialize();

    return 0;
}


BOOL
CSync::ScanTarget(
    DWORD   dwI
    )
/*++

Routine Description:

    Scan target for synchronization

Arguments:

    dwI - target ID

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL    fSt;

    fSt = m_pRoot->ScanTarget( dwI );

    InterlockedDecrement( &m_lThreads );

    return fSt;
}


BOOL
CSync::GenerateKeySeed( )
/*++

Routine Description:

    Generate the seed which will be used to derive the session key for encryption and
    write it to the metabase

Arguments:

Returns:

    TRUE if successful, FALSE if not

--*/
{
#ifdef NO_ENCRYPTION

    return TRUE;

#else

    HCRYPTPROV hProv = NULL;
    BOOL fOk = TRUE;
    ALG_ID aiAlg = CALG_MD5;
    DWORD i = 0;

    if ( !m_Source.Open( L"/LM/W3SVC", METADATA_PERMISSION_WRITE ) )
    {
        return FALSE;
    }

    //
    // Seed header with version information, hash algorithm used and size of
    // seed used to generate the session key
    //
    m_rgbSeed[i++] = IIS_SEED_MAJOR_VERSION;
    m_rgbSeed[i++] = IIS_SEED_MINOR_VERSION;
    memcpy( m_rgbSeed + i, &aiAlg, sizeof( ALG_ID ) );
    i += sizeof( ALG_ID );
    m_rgbSeed[i++] = RANDOM_SEED_SIZE;

    DBG_ASSERT( i == SEED_HEADER_SIZE );

    //
    // Generate the seed
    //
    if ( ( fOk = CryptAcquireContext( &hProv,
                                      NULL,
                                      NULL,
                                      PROV_RSA_FULL,
                                      CRYPT_VERIFYCONTEXT ) )  &&
         ( fOk = CryptGenRandom( hProv,
                                 RANDOM_SEED_SIZE,
                                 m_rgbSeed + SEED_HEADER_SIZE ) ) )
    {
        //
        // Write the seed to the metabase
        //
        METADATA_RECORD mdr;

        MD_SET_DATA_RECORD( &mdr,
                            MD_SSL_REPLICATION_INFO,
                            METADATA_SECURE,
                            IIS_MD_UT_SERVER,
                            BINARY_METADATA,
                            m_cbSeed,
                            m_rgbSeed );

        fOk = m_Source.SetData( MB_REPLICATION_PATH,
                                &mdr,
                                (LPVOID) m_rgbSeed );
    }


    if ( hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    m_Source.Close();

    return fOk;

#endif // NO_ENCRYPTION
}


BOOL CSync::PropagateKeySeed( VOID )
/*++

Routine Description:

    Propagate the session key seed to all the remote machines

Arguments:

    None

Returns:

    TRUE if successful, FALSE if not

--*/
{
#ifdef NO_ENCRYPTION

    return TRUE;

#else

    HRESULT hRes = S_OK;

    for ( DWORD dwIndex = 0; dwIndex < m_dwTargets; dwIndex++ )
    {
        if ( m_bmIsRemote.GetFlag( dwIndex ))
        {
            if ( !m_pTargets[dwIndex]->Open( L"/LM/W3SVC",
                                             METADATA_PERMISSION_WRITE ) )
            {
                if ( GetLastError() == ERROR_SUCCESS )
                {
                    SetLastError( RPC_S_SERVER_UNAVAILABLE );
                }
                m_TargetStatus.SetStatus( dwIndex, GetLastError() );
            }
            else
            {
                //
                // Write the seed to the remote metabase
                //
                METADATA_RECORD mdr;

                MD_SET_DATA_RECORD( &mdr,
                                    MD_SSL_REPLICATION_INFO,
                                    METADATA_SECURE,
                                    IIS_MD_UT_SERVER,
                                    BINARY_METADATA,
                                    m_cbSeed,
                                    m_rgbSeed );

                if ( !m_pTargets[dwIndex]->SetData( MB_REPLICATION_PATH,
                                                    &mdr,
                                                    (LPVOID) m_rgbSeed ) )
                {
                    m_TargetStatus.SetStatus( dwIndex, GetLastError() );
                }

                m_pTargets[dwIndex]->Close() ;
            }
        } // if ( m_bmIsRemote
    } // for ( DWORD dwIndex

    return TRUE;

#endif //NO_ENCRYPTION
} //::PropagateKeySeed


BOOL CSync::DeleteKeySeed( VOID )
/*++

Routine Description:

    Deletes the session key seed from the MB

Arguments:

    None

Returns:

    TRUE if successful, FALSE if not
--*/
{
#ifdef NO_ENCRYPTION

    return TRUE;

#else

    BOOL fOk = TRUE;

    if ( !m_Source.Open( L"/LM/W3SVC", METADATA_PERMISSION_WRITE ) )
    {
        return FALSE;
    }

    METADATA_RECORD mdr;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_REPLICATION_INFO,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        0,
                        NULL );

    fOk =  m_Source.DeleteProp( MB_REPLICATION_PATH,
                                &mdr );

    m_Source.Close();

    return fOk;

#endif //NO_ENCRYPTION
}


HRESULT
CSync::Sync(
    LPSTR       pszTargets,
    LPDWORD     pdwResults,
    DWORD       dwFlags,
    SYNC_STAT*  pStat
    )
/*++

Routine Description:

    Synchronize targets with source

Arguments:

    pszTargets - multisz of target computer names
            can include local computer, will be ignored during synchro
    pdwResults - updated with error code for each target
    dwFlags - flags, no flag defined for now. Should be 0.
    pStat - ptr to stat struct

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LPSTR       p;
    HRESULT     hRes = S_OK;
    CHAR        achLocalComputer[MAX_COMPUTERNAME_LENGTH+1];
    BOOL        fIsError;
    DWORD       dwSize;
    UINT        i;
    LPWSTR      pClsidList;
    BOOL        fGotSeed = FALSE;

    m_fInScan = FALSE;

    if ( m_pRoot )
    {
        return RETURNCODETOHRESULT(ERROR_IO_PENDING);
    }

    if ( !(m_pRoot = new CNodeDesc( this )) )
    {
        return RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Init MetaData COM I/F on local system
    //

    m_dwThreads = 0;
    dwSize = sizeof(achLocalComputer);

    if ( !m_Source.Init( NULL ) ||
         !GetComputerName( achLocalComputer, &dwSize ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }


    //
    // Generate seed for session key used during replication
    //
    if ( !GenerateKeySeed() )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "GenerateKeySeed() failed : 0x%x\n",
                   GetLastError() ));
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }
    else
    {
        fGotSeed = TRUE;
    }

    //
    // For the rest of the replication, we need an open read handle to the metabase; we open
    // the read handle -after- we've generated and written the seed for the session key to the
    // metabase so as not to cause lock
    //
    if ( !m_Source.Open( L"/LM/", METADATA_PERMISSION_READ ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }

    //
    // Get CLSIDs of extensions
    //

    if ( !GetProp( IISADMIN_EXTENSIONS_CLSID_MD_KEYW,
                   IISADMIN_EXTENSIONS_CLSID_MD_ID,
                   IIS_MD_UT_SERVER,
                   MULTISZ_METADATA,
                   (LPBYTE*)&pClsidList,
                   &dwSize ) )
    {
        pClsidList = NULL;
    }

    //
    // Allocate ptr to target systems
    //

    for ( m_dwTargets = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++m_dwTargets )
    {
    }

    if ( !(m_pTargets = (CMdIf**)LocalAlloc( LMEM_ZEROINIT|LMEM_FIXED,
                                             sizeof(CMdIf*)*m_dwTargets)) )
    {
        hRes = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }

    if ( !m_TargetStatus.Init( m_dwTargets ) ||
         !m_bmIsRemote.Init( m_dwTargets )   ||
         !m_ThreadHandle.Init( m_dwTargets ) ||
         !m_ThreadContext.Init( m_dwTargets ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto Exit;
    }

    //
    // Init MetaData COM I/F to targets system
    //

    for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
    {
        if ( !(m_pTargets[i] = new CMdIf()) )
        {
            hRes = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
            goto Exit;
        }

        //
        // set flag indicating whether it's a remote machine
        //
        if ( !_stricmp( p, achLocalComputer ) )
        {
            m_bmIsRemote.SetFlag( i, FALSE );
        }

        //
        // if it's a remote machine, actually get an interface pointer
        //
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            if ( !m_pTargets[i]->Init( p ) )
            {
                if ( GetLastError() == ERROR_SUCCESS )
                {
                    SetLastError( RPC_S_SERVER_UNAVAILABLE );
                }
                m_TargetStatus.SetStatus( i, GetLastError() );
            }
        }
    }

    m_dwFlags = dwFlags;


    //
    // Copy session key seed to remote machines
    //
    PropagateKeySeed();

    //
    // Process replication extensions ( phase 1 )
    //

    if ( pClsidList )
    {
        if ( !ProcessAdminExReplication( pClsidList, pszTargets, AER_PHASE1 ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }
    }

    //
    // Open MetaData on targets system
    //

    for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
    {
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            if ( !m_pTargets[i]->Open( L"/LM/",
                                       METADATA_PERMISSION_READ |
                                       METADATA_PERMISSION_WRITE ) )
            {
                if ( GetLastError() == ERROR_SUCCESS )
                {
                    SetLastError( RPC_S_SERVER_UNAVAILABLE );
                }
                m_TargetStatus.SetStatus( i, GetLastError() );
            }
        }
    }

    //
    // Create thread pool
    //
    m_lThreads = 0;

    for ( i = 0 ; i < m_dwTargets ; ++i )
    {
        THREAD_CONTEXT threadContext;
        DWORD dwId;
        HANDLE hSem;
#if IIS_NAMED_WIN32_OBJECTS
        CHAR objName[sizeof("CSync::m_ThreadContext( 1234567890*3+2 )")];
#else
        LPSTR objName = NULL;
#endif
        threadContext.pvContext = this;
        threadContext.dwIndex = i;

#if IIS_NAMED_WIN32_OBJECTS
        wsprintfA(
            objName,
            "CSync::m_ThreadContext( %u*3+2 )",
            i
            );
#endif

        hSem = IIS_CREATE_SEMAPHORE(
                   objName,
                   this,
                   0,
                   INT_MAX
                   );

        threadContext.hSemaphore = hSem;

        m_ThreadContext.SetStatus( i, threadContext );

        if ( NULL == hSem )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            break;
        }

        m_ThreadHandle.SetStatus( i,
                                  CreateThread( NULL,
                                                0,
                                                (LPTHREAD_START_ROUTINE)::ScanThread,
                                                m_ThreadContext.GetPtr( i ),
                                                0,
                                                &dwId )
                                 );

        if ( m_ThreadHandle.GetStatus( i ) )
        {
            InterlockedIncrement( &m_lThreads );
            ++m_dwThreads;
        }
        else
        {
            CloseHandle( m_ThreadContext.GetPtr( i )->hSemaphore );
            hRes = RETURNCODETOHRESULT( GetLastError() );
            break;
        }
    }

    m_fInScan = TRUE;

    //
    // Launch scan
    //

    m_pStat = pStat;
    m_pStat->m_dwSourceScan = 0;
    m_pStat->m_fSourceComplete = FALSE;
    memset( m_pStat->m_adwTargets, '\0', sizeof(DWORD)*2*m_dwTargets );

    if ( hRes == S_OK )
    {
        if ( !m_pRoot->SetPath( L"" ) ||
             !m_pRoot->Scan( this ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            Cancel();
        }
        else
        {
            SetSourceComplete();
        }
    }
    else
    {
        Cancel();
    }

    //
    // wait for all threads to exit
    //

    for ( ;; )
    {
        if ( m_lThreads == 0 )
        {
            break;
        }
        Sleep( 1000 );
    }

    //
    // Wait for all threads to be terminated
    //

    WaitForMultipleObjects( m_dwThreads, m_ThreadHandle.GetPtr(0), TRUE, 5000 );

    m_fInScan = FALSE;

    for ( i = 0 ; i < m_dwThreads ; ++i )
    {
        DWORD   dwS;
        if ( !GetExitCodeThread( m_ThreadHandle.GetStatus(i), &dwS ) )
        {
            dwS = GetLastError();
        }
        if ( hRes == S_OK && dwS )
        {
            hRes = RETURNCODETOHRESULT( dwS );
        }
        CloseHandle( m_ThreadHandle.GetStatus(i) );
        CloseHandle( m_ThreadContext.GetPtr(i)->hSemaphore );
    }

    //
    // Process replication extensions ( phase 2 )
    //

    if ( pClsidList )
    {
        if ( !ProcessAdminExReplication( pClsidList, pszTargets, AER_PHASE2 ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }

        LocalFree( pClsidList );
    }

    //
    // Close metadata
    //

    m_Source.Close();
    for ( i = 0 ; i < m_dwTargets ; ++i )
    {
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            m_pTargets[i]->Close();
        }
    }

    //
    // Process queued update requests
    //

    if ( !ProcessQueuedRequest() )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Terminate target machine metadata objects
    //

    for ( i = 0 ; i < m_dwTargets ; ++i )
    {
        m_pTargets[i]->Terminate();
    }

    //
    // Scan for errors on targets
    //

    for ( fIsError = FALSE, i = 0 ; i < m_dwTargets ; ++i )
    {
        pdwResults[i] = m_TargetStatus.GetStatus( i );
        if ( pdwResults[i] )
        {
            fIsError = TRUE;
        }
    }

    if ( hRes == S_OK && m_fCancel )
    {
        hRes = RETURNCODETOHRESULT( ERROR_CANCELLED );
    }

    if ( hRes == S_OK &&
         fIsError )
    {
        hRes = E_FAIL;
    }

Exit:

    //
    // Clean up session key seed
    //
    if ( fGotSeed )
    {
        DeleteKeySeed();
    }

    //
    // Terminate source machine metadata object
    //
    m_Source.Terminate();


    delete m_pRoot;
    m_pRoot = NULL;
    m_fInScan = FALSE;

    return hRes;
}


BOOL
CMdIf::Init(
    LPSTR   pszComputer
    )
/*++

Routine Description:

    Initialize metabase admin interface :
        get interface pointer, call Initialize()

Arguments:

    pszComputer - computer name, NULL for local computer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    IClassFactory *     pcsfFactory;
    COSERVERINFO        csiMachineName;
    HRESULT             hresError;
    BOOL                fSt = FALSE;
    WCHAR               awchComputer[COMPUTER_CHARACTER_SIZE];
    WCHAR*              pwchComputer = NULL;

    m_fModified = FALSE;

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;

    if ( pszComputer )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszComputer,
                                   -1,
                                   awchComputer,
                                   COMPUTER_CHARACTER_SIZE ) )
        {
            return FALSE;
        }

        pwchComputer = awchComputer;
    }

    csiMachineName.pwszName =  pwchComputer;

    hresError = CoGetClassObject(
                        CLSID_MSAdminBase_W,
                        CLSCTX_SERVER,
                        &csiMachineName,
                        IID_IClassFactory,
                        (void**) &pcsfFactory );

    if ( SUCCEEDED(hresError) )
    {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase_W, (void **) &m_pcAdmCom);
        if (SUCCEEDED(hresError) )
        {
                fSt = TRUE;
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
            m_pcAdmCom = NULL;
        }

        pcsfFactory->Release();
    }
    else
    {
        if ( hresError == REGDB_E_CLASSNOTREG )
        {
            SetLastError( ERROR_SERVICE_DOES_NOT_EXIST );
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
        }
        m_pcAdmCom = NULL;
    }

    return fSt;
}


BOOL
CMdIf::Open(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
/*++

Routine Description:

    Open path in metabase

Arguments:

    pszOpenPath - path in metadata
    dwPermission - metadata permission

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    HRESULT hresError;

    if (NULL == m_pcAdmCom)
    {
        SetLastError(E_NOINTERFACE);
        return FALSE;
    }

    hresError = m_pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
        pszOpenPath, dwPermission, TIMEOUT_VALUE, &m_hmd );

    if ( FAILED(hresError) )
    {
        m_hmd = NULL;
        SetLastError( HRESULTTOWIN32(hresError) );
        return FALSE;
    }

    return TRUE;
}


BOOL
CMdIf::Close(
    )
/*++

Routine Description:

    Close path in metabase

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom && m_hmd )
    {
        m_pcAdmCom->CloseKey(m_hmd);
    }

    m_hmd = NULL;

    return TRUE;
}


BOOL
CMdIf::Terminate(
    )
/*++

Routine Description:

    Terminate metabase admin interface :
        call Terminate, release interface pointer

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom )
    {
        if ( m_fModified )
        {
            m_pcAdmCom->SaveData();
        }
        m_pcAdmCom->Release();
        m_hmd = NULL;
        m_pcAdmCom = NULL;
    }

    return TRUE;
}


#if defined(ADMEX)

BOOL
CRpIf::Init(
    LPSTR   pszComputer,
    CLSID*  pClsid
    )
/*++

Routine Description:

    Initialize metabase admin interface :
        get interface pointer, call Initialize()

Arguments:

    pszComputer - computer name, NULL for local computer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    IClassFactory *     pcsfFactory;
    COSERVERINFO        csiMachineName;
    HRESULT             hresError;
    BOOL                fSt = FALSE;
    WCHAR               awchComputer[COMPUTER_CHARACTER_SIZE];
    WCHAR*              pwchComputer = NULL;

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;

    if ( pszComputer )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszComputer,
                                   -1,
                                   awchComputer,
                                   COMPUTER_CHARACTER_SIZE ) )
        {
            return FALSE;
        }

        pwchComputer = awchComputer;
    }

    csiMachineName.pwszName =  pwchComputer;

    hresError = CoGetClassObject(
                        *pClsid,
                        CLSCTX_SERVER,
                        &csiMachineName,
                        IID_IClassFactory,
                        (void**) &pcsfFactory );

    if ( SUCCEEDED(hresError) )
    {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminReplication, (void **) &m_pcAdmCom);
        if (SUCCEEDED(hresError) )
        {
                fSt = TRUE;
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
            m_pcAdmCom = NULL;
        }

        pcsfFactory->Release();
    }
    else
    {
        if ( hresError == REGDB_E_CLASSNOTREG )
        {
            SetLastError( ERROR_SERVICE_DOES_NOT_EXIST );
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
        }
        m_pcAdmCom = NULL;
    }

    return fSt;
}


BOOL
CRpIf::Terminate(
    )
/*++

Routine Description:

    Terminate metabase admin interface :
        call Terminate, release interface pointer

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom )
    {
        m_pcAdmCom->Release();
        m_pcAdmCom = NULL;
    }

    return TRUE;
}

#endif


BOOL
CNodeDesc::Scan(
    CSync* pSync
    )
/*++

Routine Description:

    Scan subtree for nodes & properties
    Signal each node availability for target synchronization
    after scanning it.

Arguments:

    pSync - synchronizer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD       dwTarget;

    if ( m_pSync->IsCancelled() )
    {
        return FALSE;
    }

    // get local props

    if ( !m_Props.GetAll( m_pSync->GetSourceIf(), m_pszPath ) )
    {
        return FALSE;
    }

    m_pSync->IncrementSourceScan();

    if ( !BuildChildObjectsList( m_pSync->GetSourceIf(), m_pszPath ) )
    {
        return FALSE;
    }

    m_Props.SetRefCount( m_pSync->GetTargetCount() );  // when 0, free props

    for ( dwTarget = 0 ; dwTarget < m_pSync->GetTargetCount() ; ++dwTarget )
    {
        m_pSync->SignalWorkItem( dwTarget );
    }

    LIST_ENTRY*         pSourceEntry;
    CNodeDesc*          pSourceDir;

    //
    // recursively scan children
    //

    for ( pSourceEntry = m_ChildHead.Flink;
          pSourceEntry != &m_ChildHead ;
          pSourceEntry = pSourceEntry->Flink )
    {
        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                        CNodeDesc,
                                        m_ChildList );

        if ( !pSourceDir->Scan( pSync ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CNodeDesc::ScanTarget(
    DWORD   dwTarget
    )
/*++

Routine Description:

    Scan target subtree for nodes and properties,
    synchronizing with source. Wait for source scan
    to be complete before synchronizing.

Arguments:

    dwTarget - target ID

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    m_pSync->WaitForWorkItem( dwTarget );

    if ( m_pSync->IsCancelled() )
    {
        return FALSE;
    }

    if ( !DoWork( SCANMODE_SYNC_PROPS, dwTarget ) )
    {
        return FALSE;
    }

    LIST_ENTRY*         pSourceEntry;
    CNodeDesc*          pSourceDir;

    //
    // recursively scan children
    //

    for ( pSourceEntry = m_ChildHead.Flink;
          pSourceEntry != &m_ChildHead ;
          pSourceEntry = pSourceEntry->Flink )
    {
        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                        CNodeDesc,
                                        m_ChildList );

        if ( !pSourceDir->ScanTarget( dwTarget ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CNodeDesc::DoWork(
    SCANMODE    sm,
    DWORD       dwTarget
    )
/*++

Routine Description:

    synchronize target node with source node :
    add/delete/update properties as needed,
    add/delete nodes as needed.

Arguments:

    sm - scan operation to perform
         only SCANMODE_SYNC_PROPS is defined for now.
    dwTarget - target ID

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CProps              Props;
    CNodeDesc           TargetDir( m_pSync );
    LIST_ENTRY*         pSourceEntry;
    CNodeDesc*          pSourceDir;
    LIST_ENTRY*         pTargetEntry;
    CNodeDesc*          pTargetDir;
    BOOL                fMatch;
    PMETADATA_RECORD    pSourceProps;
    PMETADATA_RECORD    pTargetProps;
    PBYTE               pSourceData;
    PBYTE               pTargetData;
    DWORD               dwSourceProps;
    DWORD               dwTargetProps;
    LPBYTE              pbExists;
    DWORD               dwSourceObjs;
    FILETIME            ftSource;
    FILETIME            ftTarget;
    BOOL                fModified = FALSE;
    UINT                iS;
    UINT                iT;
    BOOL                fNeedUpdate;
    BOOL                fExists;
    BOOL                fDoNotSetTimeModif = FALSE;


    //
    // if target already in error, do not process request
    //

    if ( m_pSync->GetTargetError( dwTarget ) ||
         m_pSync->IsLocal( dwTarget ) )
    {
        return TRUE;
    }

    switch ( sm )
    {
        case SCANMODE_SYNC_PROPS:

            //
            // Check date/time last modification.
            // If identical on source & target, do not update
            //

            m_pSync->IncrementTargetScan( dwTarget );

            if ( !(m_pSync->GetSourceIf())->GetLastChangeTime( m_pszPath, &ftSource ) )
            {
                return FALSE;
            }
            if ( m_pSync->GetTargetIf( dwTarget )->GetLastChangeTime( m_pszPath, &ftTarget ) )
            {
                if ( !memcmp( &ftSource, &ftTarget, sizeof(FILETIME) ) )
                {
                    return TRUE;
                }
            }
            else
            {
                m_pSync->SetTargetError( dwTarget, GetLastError() );
                return TRUE;
            }

            // get props on target, set / delete as appropriate
            if ( Props.GetAll( m_pSync->GetTargetIf(dwTarget), m_pszPath ) )
            {
                pSourceProps = (PMETADATA_RECORD)m_Props.GetProps();
                dwSourceProps = m_Props.GetPropsCount();
                dwTargetProps = Props.GetPropsCount();

                if ( !(pbExists = (LPBYTE)LocalAlloc( LMEM_FIXED, dwTargetProps )) )
                {
                    return FALSE;
                }
                memset( pbExists, '\x0', dwTargetProps );

                for ( iS = 0 ; iS < dwSourceProps ; ++iS,++pSourceProps )
                {
                    pSourceData = (LPBYTE)m_Props.GetProps() + (UINT_PTR)pSourceProps->pbMDData;    
                    pTargetProps = (PMETADATA_RECORD)Props.GetProps();

                    fNeedUpdate = TRUE;
                    fExists = FALSE;

                    for ( iT = 0 ; iT < dwTargetProps ; ++iT,++pTargetProps )
                    {
                        if ( pSourceProps->dwMDIdentifier ==
                             pTargetProps->dwMDIdentifier )
                        {
                            pbExists[ iT ] = '\x1';

                            pTargetData = (LPBYTE)Props.GetProps() + (UINT_PTR)pTargetProps->pbMDData;  

                            if ( m_Props.IsNse( pSourceProps->dwMDIdentifier ) )
                            {
                                fNeedUpdate = m_Props.NseIsDifferent( pSourceProps->dwMDIdentifier, pSourceData, pSourceProps->dwMDDataLen, pTargetData, pTargetProps->dwMDDataLen, m_pszPath, dwTarget );
                            }
                            else if ( pSourceProps->dwMDDataType == pTargetProps->dwMDDataType &&
                                 pSourceProps->dwMDUserType == pTargetProps->dwMDUserType )
                            {
                                fExists = TRUE;

                                if( pSourceProps->dwMDDataLen == pTargetProps->dwMDDataLen &&
                                    !memcmp(pSourceData, pTargetData, pSourceProps->dwMDDataLen ) )
                                {
                                    fNeedUpdate = FALSE;
                                }
                                else if ( pSourceProps->dwMDIdentifier == MD_SERVER_STATE ||
                                          pSourceProps->dwMDIdentifier == MD_WIN32_ERROR ||
                                          pSourceProps->dwMDIdentifier == MD_SERVER_COMMAND ||
                                          pSourceProps->dwMDIdentifier == MD_CLUSTER_SERVER_COMMAND ||
                                          pSourceProps->dwMDIdentifier == MD_ANONYMOUS_USER_NAME ||
                                          pSourceProps->dwMDIdentifier == MD_ANONYMOUS_PWD ||
                                          pSourceProps->dwMDIdentifier == MD_WAM_USER_NAME ||
                                          pSourceProps->dwMDIdentifier == MD_WAM_PWD 
                                          )
                                {
                                    fNeedUpdate = FALSE;
                                }
#if defined(METADATA_LOCAL_MACHINE_ONLY)
                                else if ( pSourceProps->dwMDAttributes
                                          & METADATA_LOCAL_MACHINE_ONLY )
                                {
                                    fNeedUpdate = FALSE;
                                }
#endif
                            }
                        }
                    }

                    if ( fNeedUpdate )
                    {
                        if ( m_Props.IsNse( pSourceProps->dwMDIdentifier ) )
                        {
                            if ( !m_pSync->QueueRequest(
                                    pSourceProps->dwMDIdentifier,
                                    m_pszPath,
                                    dwTarget,
                                    &ftSource ) )
                            {
                                m_pSync->SetTargetError( dwTarget, GetLastError() );
                            }
                            else
                            {
                                //
                                // differ updating time last modif
                                // until NSE update processed
                                //

                                fDoNotSetTimeModif = TRUE;
                            }
                        }
                        else
                        {
                            METADATA_RECORD     md;

                            md = *pSourceProps;

                            if ( !(m_pSync->QueryFlags() & MD_SYNC_FLAG_REPLICATE_AUTOSTART) &&
                                 md.dwMDIdentifier == MD_SERVER_AUTOSTART )
                            {
                                if ( fExists )
                                {
                                    fNeedUpdate = FALSE;
                                }
                                else
                                {
                                    //
                                    // create as FALSE ( server won't autostart )
                                    //

                                    pSourceData = (LPBYTE)&g_dwFalse;
                                    md.dwMDDataLen = sizeof(DWORD);
                                    md.dwMDDataType = DWORD_METADATA;
                                }
                            }

                            if ( !(m_pSync->QueryFlags() & MD_SYNC_FLAG_DONT_PRESERVE_IP_BINDINGS) &&
                                 (md.dwMDIdentifier == MD_SERVER_BINDINGS ||
                                  md.dwMDIdentifier == MD_SECURE_BINDINGS) )
                            {
                                if ( fExists )
                                {
                                    fNeedUpdate = FALSE;
                                }
                            }

                            if ( fNeedUpdate )
                            {
                                if ( !m_pSync->GetTargetIf(dwTarget)->SetData( m_pszPath, &md, pSourceData ) )
                                {
                                    m_pSync->SetTargetError( dwTarget, GetLastError() );
                                }
                            }
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }

                // delete prop not in src
                pTargetProps = (PMETADATA_RECORD)Props.GetProps();
                for ( iT = 0 ; iT < dwTargetProps ; ++iT,++pTargetProps )
                {
                    if ( !pbExists[ iT ] )
                    {
                        if ( !m_pSync->GetTargetIf(dwTarget)->DeleteProp( m_pszPath, pTargetProps ) )
                        {
                            m_pSync->SetTargetError( dwTarget, GetLastError() );
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }
                LocalFree( pbExists );
            }

            // enum objects on target, delete sub-tree as appropriate
            if ( TargetDir.BuildChildObjectsList( m_pSync->GetTargetIf(dwTarget), m_pszPath ) )
            {
                for ( dwSourceObjs = 0, pSourceEntry = m_ChildHead.Flink;
                      pSourceEntry != &m_ChildHead ;
                      ++dwSourceObjs, pSourceEntry = pSourceEntry->Flink )
                {
                }

                if ( !(pbExists = (LPBYTE)LocalAlloc( LMEM_FIXED, dwSourceObjs )) )
                {
                    return FALSE;
                }
                memset( pbExists, '\x0', dwSourceObjs );

                for ( pTargetEntry = TargetDir.m_ChildHead.Flink;
                      pTargetEntry != &TargetDir.m_ChildHead ;
                      pTargetEntry = pTargetEntry->Flink )
                {
                    pTargetDir = CONTAINING_RECORD( pTargetEntry,
                                                    CNodeDesc,
                                                    m_ChildList );

                    fMatch = FALSE;

                    for ( iS = 0, pSourceEntry = m_ChildHead.Flink;
                          pSourceEntry != &m_ChildHead ;
                          ++iS, pSourceEntry = pSourceEntry->Flink )
                    {
                        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                                        CNodeDesc,
                                                        m_ChildList );

                        if ( !_wcsicmp( pTargetDir->GetPath(), pSourceDir->GetPath() ) )
                        {
                            pbExists[ iS ] = '\x1';
                            fMatch = TRUE;
                            break;
                        }
                    }

                    if ( !fMatch )
                    {
                        if ( !m_pSync->GetTargetIf(dwTarget)->DeleteSubTree( pTargetDir->GetPath() ) )
                        {
                            m_pSync->SetTargetError( dwTarget, GetLastError() );
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }

                //
                // Add node if does not exist on target
                //

                for ( iS = 0, pSourceEntry = m_ChildHead.Flink;
                      pSourceEntry != &m_ChildHead ;
                      ++iS, pSourceEntry = pSourceEntry->Flink )
                {
                    if ( !pbExists[iS] )
                    {
                        pSourceDir = CONTAINING_RECORD( pSourceEntry,
                                                        CNodeDesc,
                                                        m_ChildList );

                        if ( !m_pSync->GetTargetIf(dwTarget)->AddNode( pSourceDir->GetPath() ) )
                        {
                            m_pSync->SetTargetError( dwTarget, GetLastError() );
                        }
                        m_pSync->SetModified( dwTarget );
                        fModified = TRUE;
                    }
                }

                LocalFree( pbExists );
            }
            else
            {
                // not error if does not exist on target
            }

            if ( fModified &&
                 !fDoNotSetTimeModif &&
                 !m_pSync->GetTargetError( dwTarget ) &&
                 !m_pSync->GetTargetIf( dwTarget )->SetLastChangeTime( m_pszPath, &ftSource ) )
            {
                m_pSync->SetTargetError( dwTarget, GetLastError() );
            }

            if ( fModified )
            {
                m_pSync->IncrementTargetTouched( dwTarget );
            }

            m_Props.Dereference();
            break;
    }

    return TRUE;
}


BOOL
CProps::NseIsDifferent(
    DWORD   dwId,
    LPBYTE  pSourceData,
    DWORD   dwSourceLen,
    LPBYTE  pTargetData,
    DWORD   dwTargetLen,
    LPWSTR  pszPath,
    DWORD   dwTarget
    )
/*++

Routine Description:

    Check if two NSE properties are different

Arguments:

    dwId - property ID
    pSourceData - ptr to source data for this property
    dwSourceLen - # of bytes in pSourceData
    pTargetData - ptr to target data for this property
    dwTargetLen - # of bytes in pTargetData
    pszPath - path to property
    dwTarget - target ID

Returns:

    TRUE if properties different, FALSE if identical

--*/
{
    switch ( dwId )
    {
        case MD_SERIAL_CERT11:
        case MD_SERIAL_DIGEST:
            //
            // serialized format is (DWORD)len, string, then MD5 signature ( 16 bytes )
            //

            //
            // skip string
            //

            if ( *(LPDWORD)pSourceData < dwSourceLen )
            {
                pSourceData += sizeof(DWORD) + *(LPDWORD)pSourceData;
            }
            if ( *(LPDWORD)pTargetData < dwTargetLen )
            {
                pTargetData += sizeof(DWORD) + *(LPDWORD)pTargetData;
            }

            //
            // compare MD5 signature
            //

            return memcmp( pSourceData, pTargetData, 16 );
    }

    //
    // Don't know how to handle, do not replicate
    //

    return FALSE;
}


CNseRequest::CNseRequest(
    )
/*++

Routine Description:

    NSE request constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pszPath = NULL;
    m_pszModifPath = NULL;
    m_pbData = NULL;
}


CNseRequest::~CNseRequest(
    )
/*++

Routine Description:

    NSE request destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_pszPath )
    {
        LocalFree( m_pszPath );
    }

    if ( m_pszModifPath )
    {
        LocalFree( m_pszModifPath );
    }

    if ( m_pszCreatePath )
    {
        LocalFree( m_pszCreatePath );
    }

    if ( m_pszCreateObject )
    {
        LocalFree( m_pszCreateObject );
    }

    if ( m_pbData )
    {
        LocalFree( m_pbData );
    }
}


BOOL
CNseRequest::Init(
    LPWSTR              pszPath,
    LPWSTR              pszCreatePath,
    LPWSTR              pszCreateObject,
    DWORD               dwId,
    DWORD               dwTargetCount,
    LPWSTR              pszModifPath,
    FILETIME*           pftModif,
    METADATA_RECORD*    pMd
    )
/*++

Routine Description:

    Initialize NSE request

Arguments:

    pszPath - NSE path to property
    pszCreatePath - NSE path where to create object if open object fails
    pszCreateObject - name of object to create if open object fails
    dwId - property ID
    dwTargetCount - # of potential targets
    pszModifPath - path where to update last date/time modification
                   on success
    pftModif - last date/time modification to set on success
    pMD - metadata record to set on target

Returns:

    Nothing

--*/
{
    m_dwTargetCount = dwTargetCount;
    m_dwId = dwId;

    if ( !(m_pszPath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszPath)+1)*sizeof(WCHAR) )) )
    {
        return FALSE;
    }
    wcscpy( m_pszPath, pszPath );

    if ( !(m_pszModifPath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszModifPath)+1)*sizeof(WCHAR) )) )
    {
        LocalFree( m_pszPath );
        return FALSE;
    }
    wcscpy( m_pszModifPath, pszModifPath );

    if ( !(m_pszCreatePath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszCreatePath)+1)*sizeof(WCHAR) )) )
    {
        LocalFree( m_pszModifPath );
        LocalFree( m_pszPath );
        return FALSE;
    }
    wcscpy( m_pszCreatePath, pszCreatePath );

    if ( !(m_pszCreateObject = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszCreateObject)+1)*sizeof(WCHAR) )) )
    {
        LocalFree( m_pszCreatePath );
        LocalFree( m_pszModifPath );
        LocalFree( m_pszPath );
        return FALSE;
    }
    wcscpy( m_pszCreateObject, pszCreateObject );

    m_ftModif = *pftModif;
    m_md = *pMd;

    return m_bmTarget.Init( dwTargetCount, FALSE );
}


BOOL
CNseRequest::Process(
    CSync*  pSync
    )
/*++

Routine Description:

    Process a NSE request :
    replicate source property to designated targets

Arguments:

    pSync - synchronizer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CMdIf*  pSource = pSync->GetSourceIf();
    CMdIf*  pTarget;
    UINT    i;
    DWORD   dwRequired;
    int     retry;

    if ( !pSource )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( pSource->Open( m_pszPath, METADATA_PERMISSION_READ ) )
    {
        m_md.pbMDData = NULL;
        m_md.dwMDDataLen = 0;
        if ( !pSource->GetData( L"", &m_md, NULL, &dwRequired) )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                if ( !(m_pbData = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) )
                {
                    pSource->Close();
                    return FALSE;
                }
                m_md.pbMDData = m_pbData;
                m_md.dwMDDataLen = dwRequired;
                if ( !pSource->GetData( L"", &m_md, m_pbData, &dwRequired) )
                {
                    pSource->Close();
                    return FALSE;
                }
            }
            else
            {
                pSource->Close();
                return FALSE;
            }
        }

        for ( i = 0 ; i < m_dwTargetCount ; ++i )
        {
            if ( m_bmTarget.GetFlag(i) &&
                 !pSync->GetTargetError( i ) )
            {
                pTarget = pSync->GetTargetIf( i );

                //
                // Insure object exist by creating it
                // Open path w/o last component, Add last component
                //

                LPWSTR  pLast = m_pszPath + wcslen( m_pszPath ) - 1;
                while ( *pLast != L'/' )
                {
                    --pLast;
                }
                *pLast = L'\0';

                if ( pTarget->Open( m_pszPath, METADATA_PERMISSION_WRITE ) )
                {
                    pTarget->AddNode( pLast + 1 );
                    pTarget->Close();
                }

                *pLast = L'/';

                //
                // Set serialized data
                //

                if ( pTarget->Open( m_pszPath, METADATA_PERMISSION_WRITE ) )
                {
                    if ( !pTarget->SetData( L"", &m_md, m_pbData ) )
                    {
                        pSync->SetTargetError( i, GetLastError() );
                    }
                    pSync->SetModified( i );
                    pTarget->Close();


                    //
                    // set date/time last modif
                    //

                    if ( !pSync->GetTargetError( i ) &&
                         pTarget->Open( L"/LM", METADATA_PERMISSION_WRITE ) )
                    {
                        if ( !pTarget->SetLastChangeTime( m_pszModifPath, &m_ftModif ) )
                        {
                            pSync->SetTargetError( i, GetLastError() );
                        }
                        pTarget->Close();
                    }
                    break;
                }
                else
                {
                    pSync->SetTargetError( i, GetLastError() );
                    break;
                }
            }
        }
        pSource->Close();
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
CSync::ProcessQueuedRequest(
    )
/*++

Routine Description:

    Process all queued NSE requests

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY*     pChild;
    CNseRequest*    pReq;
    BOOL            fSt = TRUE;

    while ( !IsListEmpty( &m_QueuedRequestsHead ))
    {
        pReq = CONTAINING_RECORD( m_QueuedRequestsHead.Flink,
                                  CNseRequest,
                                  m_QueuedRequestsList );

        if ( IsCancelled() ||
             !pReq->Process( this ) )
        {
            fSt = FALSE;
        }

        RemoveEntryList( &pReq->m_QueuedRequestsList );

        delete pReq;
    }

    return fSt;
}


BOOL
CSync::QueueRequest(
    DWORD       dwId,
    LPWSTR      pszPath,
    DWORD       dwTarget,
    FILETIME*   pftModif
    )
/*++

Routine Description:

    Queue a NSE request
    We cannot process then inline as we need to open a different
    path to NSE, which will open a path in metabase space, which will
    conflict with the current open.
    So we queue requests to be processed after closing all opened
    metabase paths.

Arguments:

    dwId - property ID
    pszPath - NSE path
    dwTarget - target ID
    pftModif - date/time last modification to set on targets if success

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    WCHAR               achPath[MAX_PATH];
    WCHAR               achCreatePath[MAX_PATH];
    WCHAR               achCreateObject[MAX_PATH];
    DWORD               dwL = wcslen( pszPath );
    BOOL                fSt = TRUE;
    DWORD               dwSerialId;
    METADATA_RECORD     md;

    memcpy( achPath, L"/LM", sizeof(L"/LM") - 1*sizeof(WCHAR) );
    memcpy( (LPBYTE)achPath + sizeof(L"/LM") - 1*sizeof(WCHAR), pszPath, dwL*sizeof(WCHAR) );
    dwL += wcslen(L"/LM");

    memcpy( achCreatePath, achPath, dwL*sizeof(WCHAR) );

    memset( &md, '\0', sizeof(md) );

    md.dwMDAttributes = 0;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = BINARY_METADATA;
    md.dwMDDataTag = 0;

    switch ( dwId )
    {
        case MD_SERIAL_CERT11:
            wcscpy( achPath+dwL, L"/<nsepm>/Cert11" );
            wcscpy( achCreatePath+dwL, L"/<nsepm>" );
            wcscpy( achCreateObject, L"Cert11" );
            dwSerialId = MD_SERIAL_ALL_CERT11;
            md.dwMDIdentifier = dwSerialId;
            break;

        case MD_SERIAL_DIGEST:
            wcscpy( achPath+dwL, L"/<nsepm>/Digest" );
            wcscpy( achCreatePath+dwL, L"/<nsepm>" );
            wcscpy( achCreateObject, L"Digest" );
            dwSerialId = MD_SERIAL_ALL_DIGEST;
            md.dwMDIdentifier = dwSerialId;
            break;

        default:
            return FALSE;
    }

    EnterCriticalSection( &m_csQueuedRequestsList );

    // locate path in list, add entry if not exists
    // set target bit

    LIST_ENTRY*         pEntry;
    CNseRequest*        pReq;
    BOOL                fFound = FALSE;

    for ( pEntry = m_QueuedRequestsHead.Flink;
          pEntry != &m_QueuedRequestsHead ;
          pEntry = pEntry->Flink )
    {
        pReq = CONTAINING_RECORD( pEntry,
                                  CNseRequest,
                                  m_QueuedRequestsList );

        if ( pReq->Match( achPath, dwSerialId ) )
        {
            fFound = TRUE;
            break;
        }
    }

    if ( !fFound )
    {
        if ( !(pReq = new CNseRequest()) )
        {
            fSt = FALSE;
        }
        else if ( !pReq->Init( achPath,
                               achCreatePath,
                               achCreateObject,
                               dwSerialId,
                               GetTargetCount(),
                               pszPath,
                               pftModif,
                               &md ) )
        {
            delete pReq;
            fSt = FALSE;
        }
        else
        {
            InsertHeadList( &m_QueuedRequestsHead, &pReq->m_QueuedRequestsList );
        }
    }

    if ( fSt )
    {
        pReq->AddTarget( dwTarget );
    }

    LeaveCriticalSection( &m_csQueuedRequestsList );

    return fSt;
}


BOOL
CSync::ProcessAdminExReplication(
    LPWSTR  pszClsids,
    LPSTR   pszTargets,
    DWORD   dwPhase
    )
/*++

Routine Description:

    Process replication using admin extensions

Arguments:

    pszClsids - multi-sz of ClsIds for admin extensions
    pszTargets - multi-sz of target computers ( computer names )
    dwPhase - phase 1 or 2

Returns:

    TRUE if success, otherwise FALSE

--*/
{
#if defined(ADMEX)
    CRpIf   **pTargets;
    CRpIf   Source;
    UINT    i;
    LPWSTR  pw;
    LPSTR   p;
    BOOL    fSt = TRUE;
    BUFFER  buSourceSignature;
    BUFFER  buTargetSignature;
    BUFFER  buSerialize;
    DWORD   dwSourceSignature;
    DWORD   dwTargetSignature;
    DWORD   dwSerialize;
    BOOL    fHasSource;
    CLSID   clsid;
    DWORD   iC;
    BOOL    fFirstPhase2Clsid = TRUE;
    HRESULT hr;

    if ( !(pTargets = (CRpIf**)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT, sizeof(CRpIf*)*m_dwTargets)) )
    {
        return FALSE;
    }

    for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
    {
        if ( m_bmIsRemote.GetFlag( i ) )
        {
            if ( !(pTargets[i] = new CRpIf()) )
            {
                goto Exit;
            }
        }
    }

    // build TargetSignatureMismatch array if phase 1

    if ( dwPhase == AER_PHASE1 )
    {
        for (  pw = pszClsids, iC = 0 ; *pw ; pw += wcslen(pw)+1, ++iC )
        {
        }
        m_bmTargetSignatureMismatch.Init( m_dwTargets * iC, FALSE );
    }

    // enumerate all CLSID for extensions

    for (  pw = pszClsids, iC = 0 ; *pw ; pw += wcslen(pw)+1, ++iC )
    {
        // if Source.Init fails skip to next one : replication I/F not available for
        // this CLSID

        if ( SUCCEEDED( CLSIDFromString( pw, &clsid ) ) &&
             Source.Init( NULL, &clsid ) )
        {
            fHasSource = FALSE;

            // for each one, get source signature

            if ( !Source.GetSignature( &buSourceSignature, &dwSourceSignature ) )
            {
                fSt = FALSE;
                goto Exit;
            }

            // enumerate targets, get signature, if <> source Serialize if not already available
            // and propagate to target

            for ( i = 0, p = pszTargets ; *p ; p += strlen(p)+1, ++i )
            {
                if ( IsCancelled() )
                {
                    fSt = FALSE;
                    goto Exit;
                }

                if ( pTargets[i] &&
                     !GetTargetError( i ) &&
                     pTargets[i]->Init( p, &clsid ) )
                {
                    switch ( dwPhase )
                    {
                        case AER_PHASE1:
                            if ( !pTargets[i]->GetSignature( &buTargetSignature,
                                                             &dwTargetSignature ) )
                            {
                                SetTargetError( i, GetLastError() );
                            }
                            else if ( dwSourceSignature != dwTargetSignature ||
                                      memcmp( buSourceSignature.QueryPtr(),
                                              buTargetSignature.QueryPtr(),
                                              dwTargetSignature ) )
                            {
                                if ( !fHasSource &&
                                     !Source.Serialize( &buSerialize, &dwSerialize ) )
                                {
                                    fSt = FALSE;
                                    goto Exit;
                                }
                                fHasSource = TRUE;
                                SetTargetSignatureMismatch( i, iC, TRUE );

                                if ( !Source.Propagate( p, strlen(p)+1 ) )
                                {
                                    SetTargetError( i, GetLastError() );
                                }
                                else if( !pTargets[i]->DeSerialize( &buSerialize, dwSerialize ) )
                                {
                                    SetTargetError( i, GetLastError() );
                                }
                            }
                            break;

                        case AER_PHASE2:
                            if ( fFirstPhase2Clsid )
                            {
                                if ( FAILED( hr = MTS_Propagate2( strlen(p)+1, (PBYTE)p, TRUE ) ) )
                                {
                                    SetTargetError( i, HRESULTTOWIN32(hr) );
                                }
                            }

                            if ( !Source.Propagate2( p,
                                                     strlen(p)+1,
                                                     GetTargetSignatureMismatch( i, iC ) ) )
                            {
                                SetTargetError( i, GetLastError() );
                            }
                            if ( QueryFlags() & MD_SYNC_FLAG_CHECK_ADMINEX_SIGNATURE )
                            {
                                if ( !pTargets[i]->GetSignature( &buTargetSignature, &dwTargetSignature ) )
                                {
                                    SetTargetError( i, GetLastError() );
                                }
                                else if ( dwSourceSignature != dwTargetSignature ||
                                     memcmp( buSourceSignature.QueryPtr(), buTargetSignature.QueryPtr(), dwTargetSignature ) )
                                {
                                    SetTargetError( i, ERROR_REVISION_MISMATCH );
                                }
                            }
                            break;
                    }

                    pTargets[i]->Terminate();
                }
            }

            Source.Terminate();
        }

        fFirstPhase2Clsid = FALSE;
    }

Exit:
    Source.Terminate();

    if ( pTargets )
    {
        for ( i = 0 ; i < m_dwTargets ; ++i )
        {
            if ( pTargets[i] )
            {
                if ( m_bmIsRemote.GetFlag( i ) )
                {
                    pTargets[i]->Terminate();
                }

                delete pTargets[i];
            }
        }

        LocalFree( pTargets );
    }

    return fSt;

#else

    return TRUE;

#endif
}


HRESULT
MdSync::Synchronize(
    LPSTR       pszTargets,
    LPDWORD     pdwResults,
    DWORD       dwFlags,
    LPDWORD     pStat
    )
/*++

Routine Description:

    Entry point for synchronize COM method

Arguments:

    pszTargets - multisz of target computer names
            can include local computer, will be ignored during synchro
    pdwResults - updated with error code for each target
    dwFlags - flags, no flag defined for now. Should be 0.
    pStat - ptr to stat struct

Returns:

    status of request

--*/
{
    return m_Sync.Sync( pszTargets, pdwResults, dwFlags, (SYNC_STAT*)pStat );
}


HRESULT
MdSync::Cancel(
    )
/*++

Routine Description:

    Entry point for cancel COM method

Arguments:

    None

Returns:

    status of request

--*/
{
    return m_Sync.Cancel();
}


HRESULT
MTS_Propagate2
(
/* [in] */ DWORD dwBufferSize,
/* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
/* [in] */ DWORD dwSignatureMismatch
)
{
    HRESULT hr = NOERROR;
    BSTR    bstrSourceMachineName = NULL;
    BSTR    bstrTargetMachineName = NULL;
    CHAR    pszComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   cch = MAX_COMPUTERNAME_LENGTH+1;

    //pszBuffer Contains TargetMachineName(ANSI)
    DBG_ASSERT(pszBuffer);

    if ((BOOL)dwSignatureMismatch == FALSE)
        {
        DBGPRINTF((DBG_CONTEXT, "Signature is identical, MTS replication is not triggered.\n"));
        return hr;
        }

    if (GetComputerName(pszComputerName, &cch))
        {
        WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSuccess = 0;

        dwSuccess = MultiByteToWideChar(0, 0, pszComputerName, -1, wszMachineName, MAX_COMPUTERNAME_LENGTH+1);
        DBG_ASSERT(dwSuccess);

        bstrSourceMachineName = SysAllocString(wszMachineName);

        dwSuccess = MultiByteToWideChar(0, 0, (LPCSTR)pszBuffer, dwBufferSize, wszMachineName, MAX_COMPUTERNAME_LENGTH+1);
        DBG_ASSERT(dwSuccess);

        bstrTargetMachineName = SysAllocString(wszMachineName);
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "GetComputerName failed, hr = %08x\n",
            hr));
        }

    if (SUCCEEDED(hr))
        {
        ICOMReplicate* piReplCat = NULL;

        DBG_ASSERT(bstrSourceMachineName != NULL && bstrTargetMachineName != NULL);

        hr = CoCreateInstance(CLSID_ReplicateCatalog,
                              NULL,
                              CLSCTX_INPROC_SERVER, 
                              IID_ICOMReplicate,
                              (void**)&piReplCat);

        if (SUCCEEDED(hr))
            {
            DBG_ASSERT(piReplCat);

            //
            // For now, just call the replication methods in a row.
            //

            //
            // EBK 5/8/2000 Whistler #83172
			// Removed bug comment from this.  According to NT Bug 37371
			// the best solution we came up with is the solution that is implemented
			// here, so no more work or investigation is required.
            //
            // Replication of the iis com apps is not working. The problem
            // is that com will not replicate iis applciations unless we
            // tell it to (using the COMREPL_OPTION_REPLICATE_IIS_APPS flag).
            // But if we tell it to replicate our apps, then com requires
            // that the activation identity (IWAM_*) be the same on both 
            // machines. In order to do that we would need to replicate the
            // IWAM_ account. There are a number of problems with this, not
            // the least of which is encrypting the password during transfer.
            // So to get this working at least reasonably well, I'm going to
            // continue passing 0 here. And delete/recreate the isolated
            // apps on the target in wamreg during the first phase of
            // replication.
            //
            // See NT Bug 378371 for more details
            //
             
            hr = piReplCat->Initialize( bstrSourceMachineName, 0 );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Initialize() failed with hr = %08x\n",
                            hr ));
                piReplCat->Release();
                goto Finished;
            }

            hr = piReplCat->ExportSourceCatalogFiles();
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "ExportSourceCatalogFiles() failed with hr = %08x\n",
                            hr ));
                piReplCat->CleanupSourceShares();
                piReplCat->Release();
                goto Finished;
            }

            hr = piReplCat->CopyFilesToTarget( bstrTargetMachineName );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "CopyCatalogFilesToTarget() failed with hr = %08x\n",
                            hr ));
                piReplCat->CleanupSourceShares();
                piReplCat->Release();
                goto Finished;
            }

            hr = piReplCat->InstallTarget( bstrTargetMachineName );
            if (FAILED(hr))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "InstallCatalogOnTarget() failed with hr = %08x\n",
                            hr ));
                piReplCat->CleanupSourceShares();
                piReplCat->Release();
                goto Finished;
            }

            piReplCat->CleanupSourceShares();
            piReplCat->Release();
            
            }
        else
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to CoCreateInstance of CLSID_ReplicateCatalog, hr = %08x\n",
                hr));
            }
        }

Finished:

    if (bstrSourceMachineName)
        {
        SysFreeString(bstrSourceMachineName);
        bstrSourceMachineName = NULL;
        }

    if (bstrTargetMachineName)
        {
        SysFreeString(bstrTargetMachineName);
        bstrTargetMachineName = NULL;
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\regc.h ===
// regc.h : Declaration of the Cregc

#ifndef __REGC_H_
#define __REGC_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Cregc
class ATL_NO_VTABLE Cregc : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Cregc, &CLSID_regc>,
	public IDispatchImpl<IComponentRegistrar, &IID_IComponentRegistrar, &LIBID_MDSYNCLib>
{
public:
	Cregc()
	{
	}

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(Cregc)
	COM_INTERFACE_ENTRY(IComponentRegistrar)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IComponentRegistrar
public:
    STDMETHOD(Attach)(BSTR bstrPath)
	{
		return E_NOTIMPL;
	}
	STDMETHOD(RegisterAll)()
	{
		_ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;
		HRESULT hr = S_OK;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
			{
				hr = _Module.RegisterServer(TRUE, pEntry->pclsid);
				if (FAILED(hr))
					break;
			}
			pEntry++;
		}
		return hr;
	}
	STDMETHOD(UnregisterAll)()    
	{
		_ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pfnGetObjectDescription() != NULL)
				_Module.UnregisterServer(pEntry->pclsid);
			pEntry++;
		}
		return S_OK;
	}
	STDMETHOD(GetComponents)(SAFEARRAY **ppCLSIDs, SAFEARRAY **ppDescriptions)
	{
		_ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;
		int nComponents = 0;
		while (pEntry->pclsid != NULL)
		{
			LPCTSTR pszDescription = pEntry->pfnGetObjectDescription();
			if (pszDescription)
				nComponents++;
			pEntry++;
		}
		SAFEARRAYBOUND rgBound[1];
		rgBound[0].lLbound = 0;
		rgBound[0].cElements = nComponents;
		*ppCLSIDs = SafeArrayCreate(VT_BSTR, 1, rgBound);
		*ppDescriptions = SafeArrayCreate(VT_BSTR, 1, rgBound);
		pEntry = _Module.m_pObjMap;
		for (long i=0; pEntry->pclsid != NULL; pEntry++)
		{
			LPCTSTR pszDescription = pEntry->pfnGetObjectDescription();
			if (pszDescription)
			{
				LPOLESTR pszCLSID;
				StringFromCLSID(*pEntry->pclsid, &pszCLSID);
				SafeArrayPutElement(*ppCLSIDs, &i, OLE2BSTR(pszCLSID));
				CoTaskMemFree(pszCLSID);
				SafeArrayPutElement(*ppCLSIDs, &i, T2BSTR(pszDescription));
				i++;
			}
		}
		return S_OK;
	}
	STDMETHOD(RegisterComponent)(BSTR bstrCLSID)
	{
		CLSID clsid;
		CLSIDFromString(bstrCLSID, &clsid);
		_Module.RegisterServer(TRUE, &clsid);
		return S_OK;
	}
	STDMETHOD(UnregisterComponent)(BSTR bstrCLSID)
	{
		CLSID clsid;
		CLSIDFromString(bstrCLSID, &clsid);
		_Module.UnregisterServer(&clsid);
		return S_OK;
	}
};

#endif //__REGC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C97912D4_997E_11D0_A5F6_00A0C922E752__INCLUDED_)
#define AFX_STDAFX_H__C97912D4_997E_11D0_A5F6_00A0C922E752__INCLUDED_

#if _MSC_VER >= 1001
#pragma once
#endif // _MSC_VER >= 1001

#if !defined(STRICT)
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C97912D4_997E_11D0_A5F6_00A0C922E752__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\applyinf\makefile.inc ===
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\sync.cpp ===
// sync.cpp : Implementation of DLL Exports.



// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f syncps.mk in the project directory.

extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
}   // extern "C"

#include <wincrypt.h>

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "mdsync.h"

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "dbgutil.h"
#include "mdsync_i.c"
#include "MdSync.hxx"
#include "regc.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MdSync, MdSync)
	OBJECT_ENTRY(CLSID_regc, Cregc)
END_OBJECT_MAP()

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisWpSyncGuid, 
0x784d8920, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
const CHAR 	g_pszModuleName[] = "MDSYNC";
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
#ifdef _NO_TRACING_
		CREATE_DEBUG_PRINT_OBJECT(g_pszModuleName);
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
	    CREATE_DEBUG_PRINT_OBJECT(g_pszModuleName, IisWpSyncGuid);
#endif
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();
        DELETE_DEBUG_PRINT_OBJECT();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\applyinf\applyinf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    applyinf.cxx

Abstract:

    Merge HTML documents & localizable string .inf file

Author:

    Philippe Choquier ( Phillich ) 15-may-1996

--*/

#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>

#include    <iis64.h>

typedef struct _SUBST_NODE {
    LPSTR pszName;
    LPSTR pszValue;
} SUBST_NODE;

#define MAX_NODES       8192
#define MAX_SIZE_NAME   256
#define MAX_SIZE_VALUE  8192

#define INF_SEEK_FIRST_CHAR_NAME    0
#define INF_SEEK_NAME               1
#define INF_SEEK_END_NAME           2
#define INF_SEEK_STR                3
#define INF_SEEK_END_STR            4
#define INF_SEEK_EOL                5

#define HT_SEEK_NAME                0
#define HT_SEEK_END_NAME            1

SUBST_NODE aNodes[MAX_NODES];
int cNodes = 0;

char achName[MAX_SIZE_NAME];
char achValue[MAX_SIZE_VALUE];


extern "C" int __cdecl
QsortStrCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare two SUBST_NODE structures base on their pszName field

Arguments:

    pA - ptr to 1st struct
    pB - ptr to 2nd struct

Returns:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB
    based on strcmp of their pszName field

--*/
{
    return strcmp( ((SUBST_NODE*)pA)->pszName, ((SUBST_NODE*)pB)->pszName );
}



BOOL
ParseINF(
    LPSTR pszInf
    )
/*++

Routine Description:

    Parse the .inf file for localizable string substitutions

Arguments:

    pszInf - name of .inf file

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    int ch;
    FILE *inf;

    if ( ( inf = fopen(pszInf, "r") ) == NULL )
    {
        return FALSE;
    }

    int iName = 0;
    int iValue = 0;
    BOOL fEsc;

    int iState = INF_SEEK_FIRST_CHAR_NAME;

    for ( ; (ch = fgetc( inf )) != EOF ; )
    {
        if ( ch == '\\' )
        {
            if ( (ch = fgetc( inf )) == EOF )
            {
                break;
            }
            if ( ch == '\n' )
            {
                continue;
            }
            if ( ch == 'n' )
            {
                ch = '\n';
            }
            fEsc = TRUE;
        }
        else
        {
            fEsc = FALSE;
        }

        switch ( iState )
        {
            case INF_SEEK_FIRST_CHAR_NAME:
                if ( !fEsc && ch == '#' )
                {
                    iState = INF_SEEK_EOL;
                    break;
                }
                iState = INF_SEEK_NAME;
                // fall-through

            case INF_SEEK_NAME:
                if ( !fEsc && ch == '^' )
                {
                    iState = INF_SEEK_END_NAME;
                }
                break;

            case INF_SEEK_END_NAME:
                if ( !fEsc && ch == '^' )
                {
                    iState = INF_SEEK_STR;
                }
                else
                {
                    achName[ iName++ ] = (char)ch;
                }
                break;

            case INF_SEEK_STR:
                if ( !fEsc && ch == '"' )
                {
                    iState = INF_SEEK_END_STR;
                }
                break;

            case INF_SEEK_END_STR:

                // handle "" as a single quote

                if ( !fEsc && ch == '"' )
                {
                    if ( (ch = fgetc( inf )) == EOF )
                    {
                        break;
                    }
                    if ( ch == '"' )
                    {
                        fEsc = TRUE;
                    }
                    else
                    {
                        ungetc( ch, inf );
                        ch = '"';
                    }
                }

                // skip new lines char in stream

                if ( !fEsc && ch == '\n' )
                {
                    break;
                }

                if ( !fEsc && ch == '"' )
                {
                    achName[ iName ] = '\0';
                    achValue[ iValue ] = '\0';
                    aNodes[ cNodes ].pszName = _strdup( achName );
                    aNodes[ cNodes ].pszValue = _strdup( achValue );
                    ++cNodes;
                    iState = INF_SEEK_FIRST_CHAR_NAME;
                    iName = 0;
                    iValue = 0;
                }
                else
                {
                    achValue[ iValue++ ] = (char)ch;
                }
                break;

            case INF_SEEK_EOL:
                if ( !fEsc && ch == '\n' )
                {
                    iState = INF_SEEK_FIRST_CHAR_NAME;
                }
                break;
        }
    }

    qsort( aNodes, cNodes, sizeof(SUBST_NODE), QsortStrCmp );

    fclose( inf );

    return fSt;
}


BOOL
ParseHTML(
    LPSTR pszIn,
    LPSTR pszOut
    )
/*++

Routine Description:

    Parse a HTML document and generate an output document
    based on a previously parsed .inf susbtitution file

Arguments:

    pszIn - name of input HTML document
    pszOut - name of created localized HTML document

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    int ch;
    FILE *in;
    FILE *out;

    if ( ( in = fopen(pszIn, "r") ) == NULL )
    {
        return FALSE;
    }
    if ( ( out = fopen(pszOut, "w") ) == NULL )
    {
        fclose( in );
        return FALSE;
    }

    int iName = 0;
    BOOL fEsc;

    int iState = HT_SEEK_NAME;

    for ( ; (ch = fgetc( in )) != EOF ; )
    {
        if ( ch == '\\' )
        {
            if ( (ch = fgetc( in )) == EOF )
            {
                break;
            }
            if ( ch == '\n' )
            {
                continue;
            }
            fEsc = TRUE;
        }
        else
        {
            fEsc = FALSE;
        }

        switch ( iState )
        {
            case HT_SEEK_NAME:
                if ( !fEsc && ch == '^' )
                {
                    iState = HT_SEEK_END_NAME;
                }
                else
                {
                    fputc( ch, out );
                }
                break;

            case HT_SEEK_END_NAME:
                if ( !fEsc && ch == '^' )
                {
                    SUBST_NODE snSeek;
                    SUBST_NODE *pN;
                    snSeek.pszName = achName;
                    achName[ iName ] = '\0';

                    if ( (pN = (SUBST_NODE*)bsearch( &snSeek,
                            aNodes,
                            cNodes,
                            sizeof(SUBST_NODE),
                            QsortStrCmp ))
                            != NULL )
                    {
                        fputs( pN->pszValue, out );
                    }
                    else
                    {
                        fprintf( stdout, "Can't find reference to %s in %s\n",
                            achName,
                            pszIn );
                        fflush( stdout );
                    }
                    iState = HT_SEEK_NAME;
                    iName = 0;
                }
                else
                {
                    achName[ iName++ ] = (char)ch;
                }
                break;
        }
    }

    fclose( in );
    fclose( out );

    return fSt;
}


BOOL
BreakPath(
    LPSTR pOut,
    LPSTR pExt,
    BOOL *pfIsExt
    )
/*++

Routine Description:

    Move a file extension from a file path to an extension buffer

Arguments:

    pOut - file path updated to remove file extension
    pExt - buffer for file extension
    pfIsExt - set to TRUE if file extension present

Returns:

    TRUE if success, FALSE if error

--*/
{
    // if ends with '\\' is directory
    // else extract extension

    LPSTR pL = pOut + strlen(pOut);
    LPSTR pE = NULL;

    if ( pL[-1] == '\\' )
    {
        *pfIsExt = FALSE;
        return TRUE;
    }

    while ( pL > pOut && pL[-1] != '\\' )
    {
        if ( pL[-1] == '.' && pE == NULL )
        {
            pE = pL;
        }
        --pL;
    }

    if ( pL == pOut )
    {
        return FALSE;
    }

    *pL = '\0';
    strcpy( pExt, pE );
    *pfIsExt = TRUE;

    return TRUE;
}


void
Usage(
    )
/*++

Routine Description:

    Display usage for this utility

Arguments:

    None

Returns:

    Nothing

--*/
{
    fprintf( stdout,
"\n"
"Usage: applyinf [source_file] [target_directory] [inf_file]\n"
"       source_file : can contains wild card characters\n"
"       target_directory : can contains a new extension to be\n"
"                          used, e.g. *.out\n"
"       inf_file : name of the .inf files containing replacement strings\n"
"\n" );
}


BOOL
Combine(
    LPSTR pOut,
    LPSTR pExt,
    BOOL fIsExt,
    LPSTR pFileName
    )
/*++

Routine Description:

    Combine file name & extension to a new file name

Arguments:

    pOut - output filename
    pExt - contains file extension if fIsExt is TRUE
    fIsExt - TRUE if pExt contains file extension
    pFileName - filename to be combined with extension to generare pOut

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPSTR pL = pFileName + strlen(pFileName);


    if ( fIsExt )
    {
        while ( pL > pFileName && pL[-1] != '.' )
            --pL;

        if ( pL == pFileName )
        {
            // no ext in filename
            memcpy( pOut, pFileName, strlen(pFileName) );
            pOut += strlen(pFileName );
        }
        else
        {
            memcpy( pOut, pFileName, DIFF(pL - pFileName) - 1 );
            pOut += pL - pFileName - 1;
        }
        *pOut ++ = '.';
        strcpy( pOut, pExt );
    }
    else
    {
        strcpy( pOut, pFileName );
    }

    return TRUE;
}


int __cdecl
main(
    int argc,
    char *argv[]
    )
/*++

Routine Description:

    Entry point of this utility, parse command line

Arguments:

    argc - nbr of command line parameters
    argv - ptr to command line parameters

Returns:

    0 if success, else error code

--*/
{
    char achIn[MAX_PATH]="";
    char achOut[MAX_PATH]="";
    char achInf[MAX_PATH]="";
    char achExt[MAX_PATH];
    BOOL fIsExt;
    WIN32_FIND_DATA fdIn;
    HANDLE hF;
    int arg;
    int iN = 0;
    LPSTR pLastS;
    LPSTR pOut;

    for ( arg = 1 ; arg < argc ; ++arg )
    {
        if ( argv[arg][0] == '-' )
        {
            switch( argv[arg][1] )
            {
                case 'z':
                default:
                    ;
            }
        }
        else
        {
            switch ( iN )
            {
                case 0:
                    strcpy( achIn, argv[arg] );
                    break;

                case 1:
                    strcpy( achOut, argv[arg] );
                    break;

                case 2:
                    strcpy( achInf, argv[arg] );
                    break;
            }
            ++iN;
        }
    }

    if ( achIn[0] == '\0' )
    {
        fprintf( stdout, "No source directory specified\n" );
        fflush( stdout );
        Usage();
        return 3;
    }

    if ( achOut[0] == '\0' )
    {
        fprintf( stdout, "No target directory specified\n" );
        fflush( stdout );
        Usage();
        return 3;
    }

    if ( achInf[0] == '\0' )
    {
        fprintf( stdout, "No INF file specified\n" );
        fflush( stdout );
        Usage();
        return 3;
    }

    for ( pLastS = achIn + strlen(achIn) ; pLastS > achIn ; --pLastS )
    {
        if ( pLastS[-1] == '\\' )
        {
            break;
        }
    }

    if ( pLastS == achIn )
    {
        fprintf( stdout, "Invalid source directory : %s\n", achIn );
        fflush( stdout );
        return 5;
    }

    if ( !BreakPath( achOut, achExt, &fIsExt ) )
    {
        fprintf( stdout, "Invalid target directory : %s\n", achOut );
        fflush( stdout );
        return 6;
    }
    pOut = achOut + strlen( achOut );

    if ( !ParseINF( achInf ) )
    {
        fprintf( stdout, "Can't parse INF file %s\n", achInf );
        fflush( stdout );
        return 1;
    }

    // applyinf srcdir trgdirandext inffile
    // e.g. applyinf c:\nt\*.htr c:\drop\*.htm html.inf

    if ( (hF = FindFirstFile( achIn, &fdIn )) != INVALID_HANDLE_VALUE )
    {
        do {
            strcpy( pLastS, fdIn.cFileName );
            Combine( pOut, achExt, fIsExt, fdIn.cFileName );

            if ( !ParseHTML( achIn, achOut) )
            {
                fprintf( stdout, "Can't generate %s from %s\n", achOut, achIn );
                fflush( stdout );
                return 2;
            }
            else
            {
                fprintf( stdout, "Parsed %s to %s\n", achIn, achOut );
                fflush( stdout );
            }
        } while ( FindNextFile( hF, &fdIn ) );

        FindClose( hF );
    }
    else
    {
        fprintf( stdout, "No file found in %s", achIn );
        fflush( stdout );
        return 4;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\wp\sync\test.cxx ===
#define INITGUID
#include    <windows.h>
#include    <stdio.h>
#include    <ole2.h>
#include    "sync.h"

BOOL        g_fDone = FALSE;
DWORD       g_dwTarget = 0;
SYNC_STAT*  g_pStat = NULL;


DWORD
WINAPI
Monitor(
    LPVOID  pV
    )
{
    for ( ;; )
    {
        printf( "Source : %d, %s, Targets : ", 
                g_pStat->m_dwSourceScan, 
                g_pStat->m_fSourceComplete ? "scanned" : "scanning" );
        for ( int i = 0 ; i < g_dwTarget ; ++i )
        {
            printf( "(%d,%d), ", g_pStat->m_adwTargets[i*2], g_pStat->m_adwTargets[i*2+1] );
        }
        printf( "\r" );

        if ( g_fDone )
        {
            break;
        }

        Sleep( 1000 );
    }

    return 0;
}


int __cdecl main( int argc, char*argv[] )
{
    IMdSync*    pIf;
    DWORD       adwErr[16];
    HANDLE      hThread;
    DWORD       dwThreadId;

    g_pStat = (SYNC_STAT*)LocalAlloc( LMEM_FIXED, sizeof(SYNC_STAT)+sizeof(DWORD)*2*16 );
    memset ( g_pStat, '\0', sizeof(SYNC_STAT)+sizeof(DWORD)*2*16  );

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( SUCCEEDED( CoCreateInstance( CLSID_MDSync, NULL, CLSCTX_INPROC_SERVER,  IID_IMDSync, (LPVOID*)&pIf ) ) )
    {
        g_dwTarget = 1;

        hThread = CreateThread( NULL, 0, ::Monitor, NULL, 0, &dwThreadId );

        pIf->Synchronize( "phillich01\x0", adwErr, 0, (LPDWORD)g_pStat );

        g_fDone = TRUE;

        WaitForSingleObject( hThread, INFINITE );

        pIf->Release();
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\caching.c ===
#include "convlog.h"

/*
This File implements caching of the mappings between ip addresses and machine names.


pHashTable:   An array of linked list headers which map directly to hash values, eg. the mapping for
an ipaddr is stored in the list with header pHashTable[GetHashVal(ipaddr)]

pHashEntries:   An array of HashEntry strucures. Each structure contains a mapping of ip address to machine name.

Algorithm:  A HashEntry structure is allocated each time an
entry is added to the cache. These are reused in circular fashion, eg. pHashEntries[0] is used first,
then pHashEntries[1], etc. When the ulNumHashEntries+1 entry is added to the cache, the entry currently
in pHashEntries[0] is discarded and pHashEntries[0] is reused. Hence the discard mechanism is
Least Recently Allocated. This is probably not as efficient  as Least Recently Used in terms of keeping
the most relevant entries in the cache. But it is more effiecient in terms of code speed, as there is no overhead
for keeping usage statistics or finding the least recently used entry.

All linked lists are kept in the reverse order of their allocation, that is, the most recently allocated is at the start
of the list. This allows for the most efficient allocation. It "should" also be efficient for lookup, but that could vary
on a per logfile basis.

All addressing of the pHashEntries array is currently done via array indices. At some point this should probably be
converted to use structure pointers, as that generates slightly more efficient code.
*/

#define HASHTABLELEN        2048

#define NOCACHEENTRY        0xFFFFFFFF

#define GetHashVal(p)       ((p) % HASHTABLELEN)

//This gets rid of the byte ordering dependency
#define BINARYIPTONUMERICIP(p1)   (ULONG) (((ULONG)p1[0] << 24) + ((ULONG)p1[1] << 16) + ((ULONG)p1[2] << 8) + ((ULONG)p1[3]))

ULONG   HashTable[HASHTABLELEN] = {0};

PHASHENTRY pHashEntries;

ULONG ulFreeListIndex = 0;

BOOL   bFreeElements = TRUE;

BOOL bCachingEnabled = FALSE;

ULONG ulCacheHits = 0;
ULONG ulCacheMisses = 0;

ULONG ulNumHashEntries;


VOID
InitHashTable(
    DWORD ulCacheSize
    )
{
    DWORD i;

    for (i = 0; i < HASHTABLELEN; i++) {
       HashTable[i] = NOCACHEENTRY;
    }

    ulNumHashEntries = ulCacheSize;
    while ((!bCachingEnabled) && (ulNumHashEntries >= 1000)) {

        pHashEntries = (PHASHENTRY)
            GlobalAlloc(GPTR, (sizeof(HASHENTRY) * ulNumHashEntries));

        if (NULL != pHashEntries) {
            bCachingEnabled = TRUE;
        } else {
            ulNumHashEntries /= 2;
        }
    }

    if (!bCachingEnabled) {
        printfids(IDS_CACHE_ERR);
    }

} // InitHashTable


ULONG
AllocHashEntry(
        VOID
        )
{
   ULONG i, ulCurHashVal;
   if (ulFreeListIndex == ulNumHashEntries) {
      ulFreeListIndex = 0;
      bFreeElements = FALSE;
   }
   if (!bFreeElements) {  // Use  this entry anyway, but free it first
      ulCurHashVal = GetHashVal(pHashEntries[ulFreeListIndex].uIPAddr);    //find hashtable entry
      if (HashTable[ulCurHashVal] == ulFreeListIndex) {
         HashTable[ulCurHashVal] = pHashEntries[ulFreeListIndex].NextPtr;       //Remove the entry from the table
      }
      else {
         for (i = HashTable[ulCurHashVal]; pHashEntries[i].NextPtr != ulFreeListIndex; i = pHashEntries[i].NextPtr)
            ;
         pHashEntries[i].NextPtr = pHashEntries[ulFreeListIndex].NextPtr;    //Remove the entry from the table
      }
   }

   return(ulFreeListIndex++);
}

ULONG GetElementFromCache(ULONG uIPAddr) {
   ULONG i = GetHashVal(uIPAddr);

   for (i =HashTable[i];(i != NOCACHEENTRY)&&(pHashEntries[i].uIPAddr != uIPAddr);i = pHashEntries[i].NextPtr)
      ;
   return(i);
}

VOID
AddEntryToCache(
        IN ULONG uIPAddr,
        IN PCHAR szMachineName
        )
{
   ULONG uHashEntry;
   ULONG uHashVal;
   char  *szTemp;

   uHashEntry=AllocHashEntry();
   uHashVal=GetHashVal(uIPAddr);

   pHashEntries[uHashEntry].uIPAddr = uIPAddr;
   if (strlen(szMachineName) < MAXMACHINELEN)
     szTemp = strcpy(pHashEntries[uHashEntry].szMachineName,szMachineName);
   else {
      szTemp = strncpy(pHashEntries[uHashEntry].szMachineName,szMachineName, (size_t)MAXMACHINELEN);
      pHashEntries[uHashEntry].szMachineName[MAXMACHINELEN - 1] = '\0';
   }
   pHashEntries[uHashEntry].NextPtr=HashTable[uHashVal];
   HashTable[uHashVal] = uHashEntry;
}

VOID
AddLocalMachineToCache(
    VOID
    )
{

    INT err;
    CHAR nameBuf[MAX_PATH+1];
    PHOSTENT    hostent;

    err = gethostname( nameBuf, sizeof(nameBuf));

    if ( err != 0 ) {
        return;
    }

    hostent = gethostbyname( nameBuf );
    if ( hostent == NULL ) {
        return;
    }

    AddEntryToCache(
            ((PIN_ADDR)hostent->h_addr_list[0])->s_addr,
            hostent->h_name
            );
    return;

} // AddLocalMachineToCache


PCHAR
GetMachineName(
    IN PCHAR szClientIP
    )
{
    IN_ADDR inaddr;
    PHOSTENT lpHostEnt;
    ULONG ulNumericIP;
    ULONG ulCurHashIndex;
    CHAR  tmpIP[64];
    PCHAR szReturnString = szClientIP;

    strcpy(tmpIP,szClientIP);
    FindChar(tmpIP,',');

    inaddr.s_addr = inet_addr(tmpIP);

    //
    // invalid IP
    //

    if ( inaddr.s_addr == INADDR_NONE ) {
        goto exit;
    }

    if (bCachingEnabled) {

        ulNumericIP = inaddr.s_addr;
        if ((ulCurHashIndex=GetElementFromCache(ulNumericIP)) == NOCACHEENTRY) {

            lpHostEnt = gethostbyaddr(
                                (char *)&inaddr, (int)4, (int)PF_INET);

            if (lpHostEnt != NULL) {
                szReturnString = lpHostEnt->h_name;
            }

            AddEntryToCache(ulNumericIP,szReturnString);
            ulCacheMisses++;
        } else {        //Entry is in cache
            szReturnString=pHashEntries[ulCurHashIndex].szMachineName;
            ulCacheHits++;
        }

    } else {     //Caching not enabled

        lpHostEnt = gethostbyaddr((char *)&inaddr, (int) 4, (int) PF_INET);
        if (lpHostEnt != NULL) {
            szReturnString = lpHostEnt->h_name;
        }
    }
exit:
    return(szReturnString);
}


#if DBG
VOID
PrintCacheTotals()
{
   if (bCachingEnabled) {

      DWORD dwTotal = ulCacheHits + ulCacheMisses;
      double dRatio;

      if ( ulCacheHits != 0 ) {
          dRatio = (double)ulCacheHits/(double)dwTotal;
      } else {
          dRatio = 0;
      }

      printfids(IDS_CACHE_HITS, ulCacheHits);
      printfids(IDS_CACHE_MISS, ulCacheMisses);
      printfids(IDS_CACHE_TOT, dRatio);
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\convlog.c ===
#include "convlog.h"
#include "inetcom.h"
#include "logtype.h"
#include <winnlsp.h>


//
// Current output file
//

OUTFILESTATUS       WebOutFile = {0};
OUTFILESTATUS       NoConvertOutFile = {0};

//
// Used for find first
//

WIN32_FIND_DATA     FindData = {0};

//
// struct for holding command line args
//

BOOL                DoDNSConversion = FALSE;
BOOL                SaveFTPEntries = FALSE;
BOOL                NoFormatConversion = FALSE;
CHAR                FTPSaveFile[MAX_PATH+1] = {0};
CHAR                NCSAGMTOffset[MAX_PATH+1] = {0};
DWORD               LogFileFormat = LOGFILE_INVALID;
CHAR                InputFileName[MAX_PATH+1] = {0};
CHAR                OutputDir[MAX_PATH+1] = {0};
CHAR                TempDir[MAX_PATH+1] = {0};
DWORD               nWebLineCount = 0;
DATEFORMAT          dwDateFormat = DateFormatUsa;
BOOL                bOnErrorContinue = FALSE;

//
// struct that holds log line items
//

INLOGLINE           InLogLine = {0};

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    FILE                *fpInFile;                  //log File to open

    HANDLE              hFile;                      //Handle for FindFirstFile

    //
    // Buffer to hold log line
    //

    CHAR                szInBuf[MAX_LOG_RECORD_LEN+1];

    //
    // File mask to search for
    //

    CHAR                szFileMask[MAX_PATH+1];
    CHAR                szInfileName[MAX_PATH+1];
    CHAR                szWorkingDir[MAX_PATH+1];

    int                 nTotalWebCount = 0;

    BOOL                bWebFound = FALSE;          //did we find a web line?
    BOOL                bNoConvertFound = FALSE;    //did we find any NoConvert lines?
    BOOL                bRet;                       //used for testing returns
    DWORD               dwErr;                      //used to hold error codes
    int                 nLineCount = 0;             //number of lines read from input file
    int                 nTotalCount = 0;

    //int               nCount = 0;                 Bug # 101690
    CHAR                *pCh;

    DWORD               dwFieldMask;
    BOOL                fGetHeader;
    DWORD               nLinesDumped = 0;
    DWORD               dwGetLogLineResult;
    BOOL                bContinue;
    DWORD               dwCurrentLine;

    //
    // initialize data structure
    //

    setlocale(LC_ALL, ".ACP" );
    SetThreadUILanguage(0);

    WebOutFile.fpOutFile = NULL;
    NoConvertOutFile.fpOutFile = NULL;

    ZeroMemory(szInBuf, sizeof(szInBuf));
    strcpy(OutputDir, ".\\");

    switch ( ParseArgs(argc, argv) ) {
        case ILLEGAL_COMMAND_LINE:
            Usage(argv[0]);
            return 0;

        case OUT_DIR_NOT_OK:
            printfids(IDS_BAD_DIR, OutputDir);
            return 0;

        case ERROR_BAD_NONE:
            printfids(IDS_BAD_NONE_ERR);
            return 0;

        case COMMAND_LINE_OK:
        break;
    }

    if ( DoDNSConversion ) {

        INT serr;
        WSADATA wsaData;

        if (serr = WSAStartup(MAKEWORD(2,0), &wsaData) != 0) {
            printfids(IDS_WINSOCK_ERR, serr);
            DoDNSConversion = FALSE;
        }
    }

    if ( (LogFileFormat == LOGFILE_NCSA) && !DoDNSConversion ) {
        printfids(IDS_NO_CONVERSION_NEEDED);
        return(0);
    }

    if ( !InitDateStrings() ) {
        printfids(IDS_BAD_DATESTRINGS);
    }

    if (DoDNSConversion) {

        InitHashTable(2000);
        AddLocalMachineToCache( );
    }

    strcpy (szWorkingDir, InputFileName);


    //  Bug # 101690
    //
    //  for (nCount = strlen(szWorkingDir) -1; nCount >= 0; nCount--) {
    //
    //      if ('\\' == szWorkingDir[nCount]) {
    //         szWorkingDir[nCount+1] = '\0';
    //            break;
    //      }
    //
    //  }

    //  if (nCount < 0) {
    //      strcpy (szWorkingDir, ".\\");
    //  }
    //

    pCh = _mbsrchr(szWorkingDir, '\\');

    if (pCh != NULL) {
        *(pCh+1) = '\0';
    } else {
        strcpy (szWorkingDir, ".\\");
    }


    strcpy(szFileMask, InputFileName);
    hFile = FindFirstFile (szFileMask, &FindData);

    if (INVALID_HANDLE_VALUE == hFile) {
        printfids(IDS_FILE_NONE, szFileMask);
        return(0);
    }

    do {

        if (!(FILE_ATTRIBUTE_DIRECTORY & FindData.dwFileAttributes)) {

            strcpy(szInfileName, szWorkingDir);
            strcat(szInfileName, FindData.cFileName);

            fpInFile = fopen(szInfileName, "r");
            printfids(IDS_FILE_OPEN, FindData.cFileName);

            nLineCount = 0;
            dwCurrentLine = 0;

            {
                //
                // Do file conversion
                //

                strcpy (WebOutFile.szLastDate, NEW_DATETIME);
                strcpy (WebOutFile.szLastTime, NEW_DATETIME);

                bWebFound = FALSE;
                nWebLineCount = 0;
                nLinesDumped = 0;

                ExtendedFieldsDefined = FALSE;
                szGlobalDate[0] = '\0';
            }

            fGetHeader = TRUE;
            bContinue = TRUE;

            while ((bContinue) && (!feof(fpInFile))) 
            {

                dwCurrentLine++;
                dwGetLogLineResult = GetLogLine( fpInFile, szInBuf, sizeof(szInBuf), &InLogLine);

                if (dwGetLogLineResult == GETLOG_SUCCESS) 
                {

                    nLineCount++;
                    if (DoDNSConversion) {

                        //
                        //Getting machine names could take days, so put out status messages
                        //

                        switch (nLineCount) {
                            case 25:
                            case 50:
                            case 100:
                            case 250:
                            case 500:
                                printfids(IDS_LINES_PROC, FindData.cFileName, nLineCount);
                                break;
                            default:
                                if ((nLineCount % 1000) == 0)
                                    printfids(IDS_LINES_PROC, FindData.cFileName, nLineCount);
                        }                               //end switch
                    }

                    //
                    // if NCSA and just DoDNS, do no convert
                    //

                    if ( NoFormatConversion ||

                          (_strnicmp(
                            InLogLine.szService,
                            "W3SVC",
                            strlen("W3SVC")) != 0) ) {

                        if ( NoFormatConversion || SaveFTPEntries ) {

                            ProcessNoConvertLine(
                                &InLogLine,
                                FindData.cFileName,
                                szInBuf,
                                &NoConvertOutFile,
                                &bNoConvertFound);
                        } else {
                            nLinesDumped++;
                        }

                    } else {
                        bWebFound = TRUE;
                        if (ProcessWebLine(
                                        &InLogLine,
                                        FindData.cFileName,
                                        &WebOutFile)) {

                            nWebLineCount++;
                        }
                    }
                }                                       //end if LogLineProcessed
                else
                {
                    if (dwGetLogLineResult != GETLOG_ERROR)
                    {
                        nLineCount++;
                    }

                    switch (dwGetLogLineResult) {
                        case GETLOG_ERROR_PARSE_NCSA:
                            printfids(IDS_FILE_NOT_NCSA,dwCurrentLine);
                            break;
                        case GETLOG_ERROR_PARSE_MSINET:
                            printfids(IDS_FILE_NOT_MSINET,dwCurrentLine);
                            break;
                        case GETLOG_ERROR_PARSE_EXTENDED:
                            printfids(IDS_BAD_EXTENDED_FORMAT,dwCurrentLine);
                            break;
                        default:
                            break;
                    }

                    if (!bOnErrorContinue)
                    {
                        bContinue = FALSE;
                    }
                }
            }                                           //end while !eof

            nTotalCount += nLineCount;

            if (fpInFile) {
                fclose(fpInFile);
            }

            if (bWebFound) {

                if (WebOutFile.fpOutFile != NULL ) {
                    fclose(WebOutFile.fpOutFile);
                    WebOutFile.fpOutFile = NULL;
                }

                bRet = MoveFileEx(
                            WebOutFile.szTmpFileName,
                            WebOutFile.szOutFileName,
                            MOVEFILE_COPY_ALLOWED);


                if (!bRet) {
                    dwErr = GetLastError();
                    switch (dwErr) {
                        case ERROR_FILE_EXISTS:
                        case ERROR_ALREADY_EXISTS:
                            CombineFiles(WebOutFile.szTmpFileName, WebOutFile.szOutFileName);
                            break;
                        case ERROR_PATH_NOT_FOUND:
                            break;
                        default:
                            printfids(IDS_FILE_ERR, dwErr);
                            return 1;
                    }
                }
            }

            if (bNoConvertFound) {

                bNoConvertFound = FALSE;

                if (NoConvertOutFile.fpOutFile != NULL) {
                    fclose(NoConvertOutFile.fpOutFile);
                    NoConvertOutFile.fpOutFile = NULL;
                }

                bRet = MoveFileEx(
                            NoConvertOutFile.szTmpFileName,
                            NoConvertOutFile.szOutFileName,
                            MOVEFILE_COPY_ALLOWED);

                if (!bRet) {
                    dwErr = GetLastError();
                    switch (dwErr) {

                        case ERROR_FILE_EXISTS:
                        case ERROR_ALREADY_EXISTS:
                            CombineFiles(NoConvertOutFile.szTmpFileName, NoConvertOutFile.szOutFileName);
                            break;
                        case ERROR_PATH_NOT_FOUND:
                            break;
                        default:
                            printfids(IDS_FILE_ERR, dwErr);
                            exit (1);
                            break;
                    }
                }
            }

            nTotalWebCount += nWebLineCount;
            printfids( IDS_LINES, FindData.cFileName, nLineCount);
            printfids (IDS_WEB_LINES, nWebLineCount);
            if ( nLinesDumped > 0 ) {
                printfids( IDS_DUMP_LINES, nLinesDumped );
                nLinesDumped = 0;
            }
        }

    } while (FindNextFile (hFile, &FindData));

    FindClose(hFile);

    printfids (IDS_TOTALS);
    printfids (IDS_TOT_LINES, nTotalCount);

    printfids (IDS_TOT_WEB_LINES, nTotalWebCount);

#if DBG
    PrintCacheTotals();
#endif

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\convlog.h ===
#if !defined CONVLOG_H
#define CONVLOG_H

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <winsock2.h>
#include <strings.h>
#include <mbstring.h>           // Bug # 101690
#include <locale.h>

#define CONVLOG_BASE            (120)
#define NUM_SERVICES            (4)

#define DAILY                   (CONVLOG_BASE + 0)
#define MONTHLY                 (CONVLOG_BASE + 1)
#define ONE_BIG_FILE            (CONVLOG_BASE + 2)

#define NCSA                    (CONVLOG_BASE + 3)
#define NOFORMAT                (CONVLOG_BASE + 4)

#define ILLEGAL_COMMAND_LINE    (CONVLOG_BASE + 5)
#define COMMAND_LINE_OK         (CONVLOG_BASE + 6)
#define OUT_DIR_NOT_OK          (CONVLOG_BASE + 7)
#define ERROR_BAD_NONE          (CONVLOG_BASE + 8)


#define MAXWINSOCKVERSION       2

#define MAXASCIIIPLEN           16

#define ISWHITE( ch )       ((ch) == ' ' || (ch) == '\t' || (ch) == '\r' || (ch) == '\n')

#define MAXMACHINELEN   260

#define GREATEROF(p1,p2)      ((p1)>(p2)) ? (p1) : (p2)


typedef enum _DATEFORMATS {
    DateFormatUsa = 0,          // MM/DD/YY
    DateFormatJapan = 1,        // YY/MM/DD
    DateFormatGermany = 2,      // MM.DD.YY
    DateFormatMax

} DATEFORMAT;

typedef struct _HASHENTRY {
   ULONG uIPAddr;
   ULONG NextPtr;
   char     szMachineName[MAXMACHINELEN];
}  HASHENTRY, *PHASHENTRY;


typedef struct  _INLOGLINE
{
        DWORD   dwFieldMask;
        LPSTR   szClientIP;            //client ip address
        LPSTR   szUserName;            //client user name (not put in https log)
        LPSTR   szDate;                //date string in format DD/MM/YY
        LPSTR   szTime;                //time string in format HH:MM:SS 24 hour format
        LPSTR   szService;             //Service name (not put in https log)
        LPSTR   szServerName;          //netbios name of Server
        LPSTR   szServerIP;            //Server ip address
        LPSTR   szProcTime;            //time taken to process request (not put in https log)
        LPSTR   szBytesRec;            //number of bytes received (not put in https log)
        LPSTR   szBytesSent;           //number of bytes sent (not put in https log)
        LPSTR   szServiceStatus;       //HTTP status code (not put in https log)
        LPSTR   szWin32Status;         //win32 status code (not put in https log)
        LPSTR   szOperation;           //one of GET, POST, or HEAD
        LPSTR   szTargetURL;           //URL as requested by the client
        LPSTR   szUserAgent;           //only logged (by W3SVC) if NewLog.dll installed
        LPSTR   szReferer;             //only logged (by W3SVC) if NewLog.dll installed
        LPSTR   szParameters;          //any parameters passed with the URL
        LPSTR   szVersion;             //protocol version
} *LPINLOGLINE, INLOGLINE;


typedef struct  _DOSDATE
{
        WORD    wDOSDate;                       //holds the DOS Date packed word
        WORD    wDOSTime;                       //holds teh DOS Time packed word
} *LPDOSDATE, DOSDATE;

typedef struct _OUTFILESTATUS {
        FILE            *fpOutFile;
        CHAR            szLastDate[10];
        CHAR            szLastTime[10];
        CHAR            szOutFileName[MAX_PATH];
        CHAR            szTmpFileName[MAX_PATH];
        SYSTEMTIME      SystemTime;
        FILETIME        FileTime;
        DOSDATE         DosDate;
        CHAR            szAscTime[25];

} OUTFILESTATUS, *LPOUTFILESTATUS;

enum {
  GETLOG_SUCCESS = 0,
  GETLOG_ERROR,
  GETLOG_ERROR_PARSE_NCSA,
  GETLOG_ERROR_PARSE_MSINET,
  GETLOG_ERROR_PARSE_EXTENDED
};

char    * FindComma (char *);
char    * SkipWhite (char *);

DWORD
GetLogLine (
    FILE *,
    PCHAR szBuf,
    DWORD cbBuf,
    LPINLOGLINE
    );

WORD    DateStringToDOSDate(char *);
WORD    TimeStringToDOSTime(char *, LPWORD);
char    * SystemTimeToAscTime(LPSYSTEMTIME, char *);
char    * AscDay (WORD, char *);
char    * AscMonth (WORD, char *);

void    CombineFiles(LPTSTR, LPTSTR);
void    Usage (char*);
int     ParseArgs (int, char **);
char * FindChar (char *, char);

VOID
ProcessNoConvertLine(
    IN LPINLOGLINE lpLogLine,
    IN LPCSTR szInFileName,
    IN LPTSTR pszBuf,
    IN LPOUTFILESTATUS lpOutFile,
    BOOL *lpbNCFileOpen
    );

BOOL
ProcessWebLine(
        LPINLOGLINE,
        LPCSTR,
        LPOUTFILESTATUS
        );

VOID
printfids(
    DWORD ids,
    ...
    );

VOID InitHashTable (ULONG);
ULONG GetHashEntry();
ULONG GetElementFromCache(ULONG uIPAddr);
VOID AddEntryToCache(ULONG uIPAddr, char *szMachineName);
char *GetMachineName(char *szClientIP);
VOID PrintCacheTotals();

BOOL
InitDateStrings(
    VOID
    );

VOID
AddLocalMachineToCache(
    VOID
    );

FILE *
StartNewOutputDumpLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR   pszInputFileName,
        IN LPCSTR   pszExt
        );

FILE *
StartNewOutputLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR           pszInputFileName,
        IN PCHAR szDate
        );

//
// defines
//

#define LOGFILE_INVALID      0
#define LOGFILE_NCSA         2
#define LOGFILE_MSINET       3
#define LOGFILE_CUSTOM       4

#define NEW_DATETIME        "New"

//
// Globals
//

extern BOOL                 DoDNSConversion;
extern BOOL                 SaveFTPEntries;
extern CHAR                 FTPSaveFile[];
extern CHAR                 NCSAGMTOffset[];
extern DWORD                LogFileFormat;
extern CHAR                 InputFileName[];
extern CHAR                 OutputDir[];
extern CHAR                 TempDir[];
extern DWORD                nWebLineCount;
extern BOOL                 NoFormatConversion;
extern BOOL                ExtendedFieldsDefined;
extern CHAR                 szGlobalDate[];
extern DATEFORMAT           dwDateFormat;
extern BOOL                 bOnErrorContinue;

#endif //CONVLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\nocnvlin.c ===
#include "convlog.h"

// Process a line with no Format Conversion.

VOID
ProcessNoConvertLine(
    IN LPINLOGLINE lpLogLine,
    IN LPCSTR szInFileName,
    IN LPTSTR pszBuf,
    IN LPOUTFILESTATUS lpOutFile,
    BOOL *lpbNCFileOpen
    )
{

    if (!(*lpbNCFileOpen)) {
       lpOutFile->fpOutFile = StartNewOutputDumpLog (
                                lpOutFile,
                                szInFileName,
                                NoFormatConversion ? ".dns" : ".dmp"
                                );

       *lpbNCFileOpen=TRUE;
    }

    //
    // Print all fields of line
    //

    if ( NoFormatConversion ) {

        fprintf(lpOutFile->fpOutFile,"%s",pszBuf);
        nWebLineCount++;

    } else {

        fprintf(lpOutFile->fpOutFile,"%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,\n",
            lpLogLine->szClientIP, lpLogLine->szUserName, lpLogLine->szDate, lpLogLine->szTime,
            lpLogLine->szService, lpLogLine->szServerName, lpLogLine->szServerIP, lpLogLine->szProcTime,
            lpLogLine->szBytesRec, lpLogLine->szBytesSent, lpLogLine->szServiceStatus, lpLogLine->szWin32Status,
            lpLogLine->szOperation, lpLogLine->szTargetURL, lpLogLine->szParameters);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\parsearg.c ===
#include "convlog.h"

INT
ParseArgs (
    IN INT argc,
    IN PCHAR argv[]
    )
{

    INT     nCount;
    UINT    nIndex;
    CHAR    szTemp[MAX_PATH];

    //
    // Parse the command line and set flags for requested information
    // elements.  If parameters are incorrect or nonexistant, show usage.
    //

    if (argc > 1) {

        //
        // Get command line switches
        //

        for (nCount = 1; nCount < argc; nCount++) {

            PCHAR p;
            CHAR c;

            p=argv[nCount];
            if ((*p == '-') || (*p == '/')) {

                p++;
                c = *p;
                if (c == '\0') {
                    continue;
                }

                p++;
                switch (tolower(c)) { // Process switches

                    //  They specified the -s switch, cancel default
                    //  services to be processed.
                    //

                case 'i':

                    //
                    // Get input logfile type
                    //

                    if ( *p != '\0' ) {

                        switch (tolower(*p)) {
                        case 'i':
                            LogFileFormat = LOGFILE_MSINET;
                            break;

                        case 'n':
                            LogFileFormat = LOGFILE_NCSA;
                            NoFormatConversion = TRUE;
                            break;

                        case 'e':
                            LogFileFormat = LOGFILE_CUSTOM;
                            break;

                        default:
                            LogFileFormat = LOGFILE_INVALID;
                        }

                    } else {
                        return (ILLEGAL_COMMAND_LINE);
                    }
                    break;

                case 'l':

                    //
                    // Get date format/valid for MS INET Log only
                    //

                    if ( *p != '\0' ) {

                        switch (*p) {
                        case '0':
                            dwDateFormat = DateFormatUsa;
                            break;

                        case '1':
                            dwDateFormat = DateFormatJapan;
                            break;

                        case '2':
                            dwDateFormat = DateFormatGermany;
                            break;

                        default:
                            return (ILLEGAL_COMMAND_LINE);
                        }

                    } else {
                        return (ILLEGAL_COMMAND_LINE);
                    }
                    break;

                case 't':

                    if ((nCount+1) < argc) {

                        if ((*argv[nCount+1] != '-') &&
                            (*argv[nCount+1] != '/')) {

                            PCHAR pTmp;

                            strcpy(szTemp, argv[++nCount]);
                            pTmp = strstr(_strlwr(szTemp), "ncsa");

                            if (pTmp != NULL ) {

                                pTmp = strstr(szTemp, ":" );
                                if (NULL != pTmp ) {

                                    strncpy(NCSAGMTOffset,pTmp+1,6);

                                    if (strlen(NCSAGMTOffset) != 5) {
                                        return (ILLEGAL_COMMAND_LINE);
                                    }

                                    if (('+' != NCSAGMTOffset[0]) &&
                                        ('-' != NCSAGMTOffset[0])) {
                                        return (ILLEGAL_COMMAND_LINE);
                                    }
                                }
                            } else if (0 == _stricmp(szTemp, "none")) {
                                NoFormatConversion = TRUE;
                                DoDNSConversion = TRUE;
                            } else {
                                return (ILLEGAL_COMMAND_LINE);

                            }

                        } else {
                            return (ILLEGAL_COMMAND_LINE);
                        }
                    }

                    break;

                case 's':
                case 'f':

                    //
                    // Do nothing. For compatibility with old convlog versions.
                    //
                    break;

                case 'n':
                case 'd':

                    //
                    // doing NCSA dns convertion
                    //

                    DoDNSConversion = TRUE;
                    break;

                case 'x':

                    //
                    // doing NCSA dns convertion
                    //

                    SaveFTPEntries = TRUE;
                    break;

                case 'o':

                    //
                    // output directory
                    //

                    if ((nCount+1) < argc) {
                        if ((*argv[nCount+1] != '-') &&
                            (*argv[nCount+1] != '/')) {

                            strcpy(OutputDir, argv[++nCount]);

                            if (-1 == _access(OutputDir, 6)) {
                                return (OUT_DIR_NOT_OK);
                            }

                            if ('\\' != *CharPrev(OutputDir, &OutputDir[strlen(OutputDir)])) {
                                strcat(OutputDir, "\\");
                            }
                        }
                    } else {
                        return (ILLEGAL_COMMAND_LINE);
                    }
                    break;

                case 'c':

                    //
                    // on error, continue processing file  // WinSE 9148
                    //

                    bOnErrorContinue = TRUE;
                    break;

                default:
                    return(ILLEGAL_COMMAND_LINE);
                } //end switch
            } else {
                strcpy(InputFileName, argv[nCount]);
            }
        } //end for

        if ('\0' == InputFileName[0]) {
            return (ILLEGAL_COMMAND_LINE);
        }
    } else {
        return (ILLEGAL_COMMAND_LINE);
    }

    if ( LogFileFormat == LOGFILE_INVALID ) {
        return (ILLEGAL_COMMAND_LINE);
    }

    if ( NoFormatConversion &&
         ((LogFileFormat != LOGFILE_MSINET) &&
          (LogFileFormat != LOGFILE_NCSA)) ) {
        return (ERROR_BAD_NONE);
    }

    if (('\0' == NCSAGMTOffset[0])) {

        DWORD                   dwRet;
        INT                     nMinOffset;
        TIME_ZONE_INFORMATION   tzTimeZone;
        DWORD                   minutes;
        DWORD                   hours;
        LONG                    bias;

        dwRet = GetTimeZoneInformation (&tzTimeZone);

        if ( dwRet == 0xffffffff ) {

            bias = 0;
        } else {

            bias = tzTimeZone.Bias;

            //
            // Use real bias to be compatible with how IIS writes its log
            // file (see bugs 29002 and 415318).
            //
            switch (dwRet) {

            case TIME_ZONE_ID_STANDARD:
                if ( tzTimeZone.StandardDate.wMonth != 0 ) {
                    bias += tzTimeZone.StandardBias;
                }
                break;

            case TIME_ZONE_ID_DAYLIGHT:
                if ( tzTimeZone.DaylightDate.wMonth != 0 ) {
                    bias += tzTimeZone.DaylightBias;
                }
                break;

            case TIME_ZONE_ID_UNKNOWN:
            default:
                break;
            }
        }

        if ( bias > 0 ) {
            strcat(NCSAGMTOffset, "-");
        } else {
            strcat(NCSAGMTOffset, "+");
            bias *= -1;
        }

        hours = bias/60;
        minutes = bias % 60;

        sprintf (szTemp, "%02lu", hours);
        strcat (NCSAGMTOffset, szTemp);

        sprintf (szTemp, "%02lu", minutes);
        strcat (NCSAGMTOffset, szTemp);

        if ( LogFileFormat == LOGFILE_CUSTOM ) {
            strcpy(NCSAGMTOffset,"+0000");
        }
    }
    return COMMAND_LINE_OK;

} //end of ParseArgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\htmla\makefile.inc ===
iCPU=$(PROCESSOR_ARCHITECTURE)
APPLYINF=.\$(iCPU)\applyinf
htmll: scriptsl6\aexp.asp
    @-mkdir root\$(O)
    @-mkdir scripts\$(O)
    @-mkdir scripts6\$(O)
    $(APPLYINF) rootl\*.htm root\$(O)\*.htm scriptsl\htmla.inf
    $(APPLYINF) scriptsl\*.htr scripts\$(O)\*.htr scriptsl\htmla.inf
    copy scriptsl6\*.asp scripts6\$(O)\*.asp

!if "$(_NTTREE)" != ""
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\aexp.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\aexp2.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\aexp2b.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\achg.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\anot.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\anot3.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\aexp3.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\aexp4.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\aexp4b.asp
    binplace -R $(_NTTREE) -:DEST inetsrv scripts6\$(O)\text.asp
!endif

#    copy scripts\$(O)\aexp.htr $(_NTTREE)\inetsrv\aexp.htr
#    copy scripts\$(O)\aexp2.htr $(_NTTREE)\inetsrv\aexp2.htr
#    copy scripts\$(O)\aexp2b.htr $(_NTTREE)\inetsrv\aexp2b.htr
#    copy scripts\$(O)\achg.htr $(_NTTREE)\inetsrv\achg.htr
#    copy scripts\$(O)\anot.htr $(_NTTREE)\inetsrv\anot.htr
#    copy scripts\$(O)\anot3.htr $(_NTTREE)\inetsrv\anot3.htr
#    copy scripts\$(O)\aexp3.htr $(_NTTREE)\inetsrv\aexp3.htr
#    copy scripts\$(O)\aexp4.htr $(_NTTREE)\inetsrv\aexp4.htr
#    copy scripts\$(O)\aexp4b.htr $(_NTTREE)\inetsrv\aexp4b.htr

!ifdef LINKONLY
htmll:
!else
htmll:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-06-95  michth    Created
//
//----------------------------------------------------------------------------







#define IDS_BASE                        4000

#define IDS_HEADER1                     (IDS_BASE+1)
#define IDS_HEADER2                     (IDS_BASE+2)
#define IDS_HEADER3                     (IDS_BASE+3)
#define IDS_HEADER4                     (IDS_BASE+4)

#define IDS_USAGE1                      (IDS_BASE+11)
#define IDS_USAGE2                      (IDS_BASE+12)
#define IDS_USAGE3                      (IDS_BASE+13)
#define IDS_USAGE4                      (IDS_BASE+14)
#define IDS_USAGE5                      (IDS_BASE+15)
#define IDS_USAGE7                      (IDS_BASE+17)
#define IDS_USAGE8                      (IDS_BASE+18)
#define IDS_USAGE9                      (IDS_BASE+19)
#define IDS_USAGE10                     (IDS_BASE+20)
#define IDS_USAGE11                     (IDS_BASE+21)
#define IDS_USAGE12                     (IDS_BASE+22)
#define IDS_USAGE13                     (IDS_BASE+23)
#define IDS_USAGE14                     (IDS_BASE+24)
#define IDS_USAGE15                     (IDS_BASE+25)
#define IDS_USAGE16                     (IDS_BASE+26)

#define IDS_SAMPLE0                     (IDS_BASE+30)
#define IDS_SAMPLE1                     (IDS_BASE+31)
#define IDS_SAMPLE2                     (IDS_BASE+32)
#define IDS_SAMPLE3                     (IDS_BASE+33)
#define IDS_SAMPLE4                     (IDS_BASE+34)
#define IDS_SAMPLE5                     (IDS_BASE+35)
#define IDS_SAMPLE6                     (IDS_BASE+36)

#define IDS_TIME_ZONE1                  (IDS_BASE+50)
#define IDS_TIME_ZONE2                  (IDS_BASE+51)
#define IDS_LINES                       (IDS_BASE+52)
#define IDS_DUMP_LINES                  (IDS_BASE+53)
#define IDS_WEB_LINES                   (IDS_BASE+54)

#define IDS_TOTALS                      (IDS_BASE+55)
#define IDS_TOT_LINES                   (IDS_BASE+56)
#define IDS_TOT_FTP_LINES               (IDS_BASE+57)
#define IDS_TOT_WEB_LINES               (IDS_BASE+58)

#define IDS_CACHE_ERR                   (IDS_BASE+60)
#define IDS_CACHE_HITS                  (IDS_BASE+61)
#define IDS_CACHE_MISS                  (IDS_BASE+62)
#define IDS_CACHE_TOT                   (IDS_BASE+63)
#define IDS_LINES_PROC                  (IDS_BASE+64)
#define IDS_PREPROC                     (IDS_BASE+65)

#define IDS_LASTDATE                    (IDS_BASE+70)
#define IDS_LASTTIME                    (IDS_BASE+71)
#define IDS_NO_CONVERSION_NEEDED        (IDS_BASE+72)

#define IDS_ERROR                       4100
#define IDS_BAD_DIR                     (IDS_ERROR)
#define IDS_FILE_ERR                    (IDS_ERROR+1)
#define IDS_FILE_CLOSE                  (IDS_ERROR+2)
#define IDS_FILE_OPEN                   (IDS_ERROR+3)
#define IDS_FILE_WRITE                  (IDS_ERROR+4)
#define IDS_FILE_EXIST                  (IDS_ERROR+5)
#define IDS_FILE_NONE                   (IDS_ERROR+6)
#define IDS_FILE_NOT_MSINET             (IDS_ERROR+7)
#define IDS_FILE_NOT_NCSA               (IDS_ERROR+8)
#define IDS_BAD_NONE_ERR                (IDS_ERROR+9)
#define IDS_BAD_DATESTRINGS             (IDS_ERROR+10)
#define IDS_BAD_EXTENDED_FORMAT         (IDS_ERROR+11)

#define IDS_STRING_ERR                  (IDS_ERROR+20)
#define IDS_WINSOCK_ERR                 (IDS_ERROR+21)

#define IDS_MONTHS                      4200
#define IDS_JAN                         (IDS_MONTHS)
#define IDS_FEB                         (IDS_MONTHS+1)
#define IDS_MAR                         (IDS_MONTHS+2)
#define IDS_APR                         (IDS_MONTHS+3)
#define IDS_MAY                         (IDS_MONTHS+4)
#define IDS_JUN                         (IDS_MONTHS+5)
#define IDS_JUL                         (IDS_MONTHS+6)
#define IDS_AUG                         (IDS_MONTHS+7)
#define IDS_SEP                         (IDS_MONTHS+8)
#define IDS_OCT                         (IDS_MONTHS+9)
#define IDS_NOV                         (IDS_MONTHS+10)
#define IDS_DEC                         (IDS_MONTHS+11)
#define IDS_MON                         (IDS_MONTHS+12)
#define IDS_TUE                         (IDS_MONTHS+13)
#define IDS_WED                         (IDS_MONTHS+14)
#define IDS_THU                         (IDS_MONTHS+15)
#define IDS_FRI                         (IDS_MONTHS+16)
#define IDS_SAT                         (IDS_MONTHS+17)
#define IDS_SUN                         (IDS_MONTHS+18)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\tools.c ===
#include "convlog.h"
#include <logconst.h>

#define MAX_MONTH_SIZE  16

char szJan[MAX_MONTH_SIZE];
char szFeb[MAX_MONTH_SIZE];
char szMar[MAX_MONTH_SIZE];
char szApr[MAX_MONTH_SIZE];
char szMay[MAX_MONTH_SIZE];
char szJun[MAX_MONTH_SIZE];
char szJul[MAX_MONTH_SIZE];
char szAug[MAX_MONTH_SIZE];
char szSep[MAX_MONTH_SIZE];
char szOct[MAX_MONTH_SIZE];
char szNov[MAX_MONTH_SIZE];
char szDec[MAX_MONTH_SIZE];

//
// extended logging
//

DWORD   dwHostNamePos = 0;
DWORD   dwUserNamePos = 0;
DWORD   dwDatePos = 0;
DWORD   dwTimePos = 0;
DWORD   dwMethodPos = 0;
DWORD   dwURIStemPos = 0;
DWORD   dwURIQueryPos = 0;
DWORD   dwHTTPStatusPos = 0;
DWORD   dwBytesSentPos = 0;
DWORD   dwBytesRecvPos = 0;
DWORD   dwServicePos = 0;
DWORD   dwVersionPos = 0;
CHAR    szGlobalDate[32] = {0};
CHAR    szGlobalTime[32] = {0};
BOOL    ExtendedFieldsDefined = FALSE;

BOOL
InitDateStrings(
    VOID
    )
{
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ( hInst == NULL ) {
        return(FALSE);
    }

    LoadString(hInst, IDS_JAN, szJan, sizeof(szJan));
    LoadString(hInst, IDS_FEB, szFeb, sizeof(szFeb));
    LoadString(hInst, IDS_MAR, szMar, sizeof(szMar));
    LoadString(hInst, IDS_APR, szApr, sizeof(szApr));
    LoadString(hInst, IDS_MAY, szMay, sizeof(szMay));
    LoadString(hInst, IDS_JUN, szJun, sizeof(szJun));
    LoadString(hInst, IDS_JUL, szJul, sizeof(szJul));
    LoadString(hInst, IDS_AUG, szAug, sizeof(szAug));
    LoadString(hInst, IDS_SEP, szSep, sizeof(szSep));
    LoadString(hInst, IDS_OCT, szOct, sizeof(szOct));
    LoadString(hInst, IDS_NOV, szNov, sizeof(szNov));
    LoadString(hInst, IDS_DEC, szDec, sizeof(szDec));

    return(TRUE);
}

PCHAR
FindChar(
    IN PCHAR    cp,
    IN CHAR     cTarget
    )

/*++
This procedure increments a character pointer until it finds a comma or the
NULL character.  if it finds a comma, it replaces it with a NULL and increments
the pointer.  if it finds a NULL, it merely returns without changing the character.
--*/
{
    while ((*cp != cTarget) && (*cp != '\0'))
        cp++;

    if (*cp == cTarget)
    {
        *cp = '\0';
        cp++;
        cp = SkipWhite(cp);
    }
    return (cp);
}


PCHAR
FindMSINETLogDelimChar( IN PCHAR cp )

/*++ 
This procedure increments a character pointer until it finds a comma+space or the
NULL character.  if it finds a comma+space, it replaces the comma with a NULL and increments
the pointer past the space.  if it finds a NULL, it merely returns without changing
the character.
--*/
    {
    while ( !(*cp == ',' && ISWHITE ( *(cp+1) ))  && (*cp != '\0') && (*cp != '\r') && (*cp != '\n'))
        {
        cp++;
        }
        
    if (*cp == ',')
        {
        *cp = '\0';
        cp++;
        cp = SkipWhite(cp);
        }
    else
        if ((*cp=='\r') || (*cp=='\n'))\
        {
            *cp = '\0';
        }
    
    return (cp);
    }

char * SkipWhite (char *cp)
{

    while (ISWHITE (*cp))
    {
        cp++;
    }
    return (cp);
}



#if 0
PCHAR
ConvertDate(
    IN LPTSTR pszDate
    )

/*++
Convert the date from "15/May/1995" to "5/15/95" format
--*/
{
    static char pszRetDate[100];
    char *cpCurrent = pszDate;

    int nMonth=1;
    int nDay=1;
    int nYear=90;

    nDay = atoi( cpCurrent );
    cpCurrent=FindChar(cpCurrent,'/');
    if ( strncmp(cpCurrent,szJan,3) == 0 )
    {
        nMonth = 1;
    } else if ( strncmp(cpCurrent,szFeb,3) == 0 )
    {
        nMonth = 2;
    } else if ( strncmp(cpCurrent,szMar,3) == 0 )
    {
        nMonth = 3;
    } else if ( strncmp(cpCurrent,szApr,3) == 0 )
    {
        nMonth = 4;
    } else if ( strncmp(cpCurrent,szMay,3) == 0 )
    {
        nMonth = 5;
    } else if ( strncmp(cpCurrent,szJun,3) == 0 )
    {
        nMonth = 6;
    } else if ( strncmp(cpCurrent,szJul,3) == 0 )
    {
        nMonth = 7;
    } else if ( strncmp(cpCurrent,szAug,3) == 0 )
    {
        nMonth = 8;
    } else if ( strncmp(cpCurrent,szSep,3) == 0 )
    {
        nMonth = 9;
    } else if ( strncmp(cpCurrent,szOct,3) == 0 )
    {
        nMonth = 10;
    } else if ( strncmp(cpCurrent,szNov,3) == 0 )
    {
        nMonth = 11;
    } else if ( strncmp(cpCurrent,szDec,3) == 0 )
    {
        nMonth = 12;
    }
    cpCurrent=FindChar(cpCurrent,'/');
    nYear = atoi( cpCurrent )%100;
    sprintf(pszRetDate,"%d/%d/%d",nMonth,nDay,nYear);
    return pszRetDate;
}
#endif

/* #pragma INTRINSA suppress=all */
DWORD
GetLogLine (
    IN FILE *fpInFile,
    IN PCHAR    szBuf,
    IN DWORD    cbBuf,
    IN LPINLOGLINE lpLogLine
    )
{
    BOOL    bRetCode = GETLOG_ERROR;
    CHAR    *cpCurrent;
    CHAR    buf[8*1024];

    static char szNULL[]="";
    static char szEmpty[]="-";
    static char szUnknownIP[] = "<UnknownIP>";
    static char szW3Svc[] = "W3Svc";
    static char szDefaultHTTPVersion[]="HTTP/1.0";

    lpLogLine->szClientIP = szNULL;
    lpLogLine->szUserName = szNULL;
    lpLogLine->szDate = szNULL;
    lpLogLine->szTime = szNULL;
    lpLogLine->szService = szNULL;
    lpLogLine->szServerName = szNULL;
    lpLogLine->szServerIP = szNULL;
    lpLogLine->szProcTime = szNULL;
    lpLogLine->szBytesRec = szNULL;
    lpLogLine->szBytesSent = szNULL;
    lpLogLine->szServiceStatus = szNULL;
    lpLogLine->szWin32Status = szNULL;
    lpLogLine->szOperation = szNULL;
    lpLogLine->szTargetURL = szNULL;
    lpLogLine->szUserAgent = szNULL;
    lpLogLine->szReferer = szNULL;
    lpLogLine->szParameters = szNULL;
    lpLogLine->szVersion = szDefaultHTTPVersion;

    if (NULL != fgets(szBuf, cbBuf, fpInFile)) {

        szBuf = SkipWhite(szBuf);
        
        if ((szBuf[0] != '\n') && ( szBuf[0] != '\0'))                             //is this an empty line? 
        {
            bRetCode = GETLOG_SUCCESS;

            //
            // set current char pointer to start of string
            //

            cpCurrent = szBuf;

            if ( LogFileFormat == LOGFILE_NCSA ) {
				              
                lpLogLine->szClientIP = szBuf;

                cpCurrent = FindChar(cpCurrent, ' ');
                
                lpLogLine->szClientIP = GetMachineName(lpLogLine->szClientIP);

                sprintf( buf,"%s %s",lpLogLine->szClientIP,cpCurrent);
                strcpy( szBuf, buf);

                // 
                // After the strcpy the pointers cpCurrent and lpLogLine->szClientIP have
                // the potential to be miss alligned if the dns name is shorter or longer than the IP 
                // address that it replaced. Simple fix reset the pointers to the beginning of the
                // string.
                //

               	lpLogLine->szClientIP = szBuf;
                cpCurrent = szBuf;
                             
        
                while ((*cpCurrent != '\0') && (*cpCurrent != '[') ) {
                    cpCurrent++;
                }

                if ( *cpCurrent == '\0' ) {
                    return(GETLOG_ERROR_PARSE_NCSA);
                }

            } else if (LogFileFormat == LOGFILE_MSINET ) {

                lpLogLine->szClientIP = szBuf;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                
                if (DoDNSConversion) {
                    lpLogLine->szClientIP = GetMachineName(
                                            lpLogLine->szClientIP
                                            );

                    if ( NoFormatConversion ) {
                        sprintf( buf,"%s, %s",lpLogLine->szClientIP,cpCurrent);
                        strcpy( szBuf, buf);
                        return(GETLOG_SUCCESS);
                    }
                }

                lpLogLine->szUserName = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szDate = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szTime = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szService = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szServerName = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szServerIP = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szProcTime = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szBytesRec = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szBytesSent = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szServiceStatus = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szWin32Status = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szOperation = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szTargetURL = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szParameters = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                if (lpLogLine->szClientIP[0] != '\0' &&
                   lpLogLine->szUserName[0] != '\0' &&
                   lpLogLine->szDate[0] != '\0' &&
                   lpLogLine->szTime[0] != '\0' &&
                   lpLogLine->szService[0] != '\0' &&
                   lpLogLine->szServerName[0] != '\0' &&
                   lpLogLine->szServerIP[0] != '\0' &&
                   lpLogLine->szProcTime[0] != '\0' &&
                   lpLogLine->szBytesRec[0] != '\0' &&
                   lpLogLine->szBytesSent[0] != '\0' &&
                   lpLogLine->szServiceStatus[0] != '\0' &&
                   lpLogLine->szWin32Status[0] != '\0' &&
                   lpLogLine->szOperation[0] != '\0' &&
                   lpLogLine->szTargetURL[0] != '\0' &&
                   lpLogLine->szParameters[0] != '\0'
                   ) {

                    bRetCode = GETLOG_SUCCESS;
                } else {
                    return(GETLOG_ERROR_PARSE_MSINET);
                }

            } else if ( LogFileFormat == LOGFILE_CUSTOM ) {

                //
                // W3C Extended Logging
                //

                if ( szBuf[0] == '#' ) {

                    PCHAR pszFields;
                    cpCurrent = FindChar(cpCurrent, '#');
                    bRetCode = GETLOG_SUCCESS;

                    if ( strncmp(cpCurrent, "Fields:", 7) == 0 ) {

                        DWORD pos;

                        //
                        // init positions
                        //

                        ExtendedFieldsDefined = TRUE;
                        dwHostNamePos = 0;
                        dwUserNamePos = 0;
                        dwDatePos = 0;
                        dwTimePos = 0;
                        dwMethodPos = 0;
                        dwURIStemPos = 0;
                        dwURIQueryPos = 0;
                        dwHTTPStatusPos = 0;
                        dwBytesSentPos = 0;
                        dwBytesRecvPos = 0;
                        dwServicePos = 0;
                        dwVersionPos = 0;

                        cpCurrent = FindChar(cpCurrent, ':');
                        (VOID)FindChar( cpCurrent, '\n' );

                        for (pos = 1; *cpCurrent != '\0'; pos++) {

                            PCHAR pszField = cpCurrent;
                            cpCurrent=FindChar(cpCurrent,' ');

                            if ( _stricmp( pszField, EXTLOG_CLIENT_IP_ID ) == 0 ) {
                                dwHostNamePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_USERNAME_ID ) == 0 ) {
                                dwUserNamePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_DATE_ID ) == 0 ) {
                                dwDatePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_TIME_ID ) == 0 ) {
                                dwTimePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_METHOD_ID ) == 0 ) {
                                dwMethodPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_URI_STEM_ID ) == 0 ) {
                                dwURIStemPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_URI_QUERY_ID ) == 0 ) {
                                dwURIQueryPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_HTTP_STATUS_ID ) == 0 ) {
                                dwHTTPStatusPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_BYTES_SENT_ID ) == 0 ) {
                                dwBytesSentPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_BYTES_RECV_ID ) == 0 ) {
                                dwBytesRecvPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_SITE_NAME_ID ) == 0 ) {
                                dwServicePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_PROTOCOL_VERSION_ID ) == 0 ) {
                                dwVersionPos = pos;
                            }
                        }
                    }

                    if ( strncmp(cpCurrent, "Date:", 5) == 0 ) {

                        //
                        // Grab the global date
                        //

                        cpCurrent = FindChar(cpCurrent, ':');

                        CopyMemory(szGlobalDate,cpCurrent, sizeof("2000-01-01") - 1);
                        szGlobalDate[10] = '\0';

                        //
                        // And the global time
                        //

                        cpCurrent = FindChar(cpCurrent, ' ');

                        CopyMemory(szGlobalTime,cpCurrent, sizeof("00:00:00") - 1);
                        szGlobalTime[8] = '\0';
                    }

                } else {

                    DWORD pos;
                    PCHAR pszValue;

                    if ( !ExtendedFieldsDefined ) {
                        return(GETLOG_ERROR_PARSE_EXTENDED);
                    }

                    //
                    // Need at least 1 valid entry in the log line other than date & time

                    if (    (dwHostNamePos  == 0)   &&
                            (dwUserNamePos  == 0)   &&
                            (dwMethodPos    == 0)   &&
                            (dwURIStemPos   == 0)   &&
                            (dwURIQueryPos  == 0)   &&
                            (dwHTTPStatusPos == 0)  &&
                            (dwBytesSentPos == 0)   && 
                            (dwBytesRecvPos == 0)   &&
                            (dwServicePos   == 0)   &&
                            (dwVersionPos   == 0)
                      )
                    {
                        return GETLOG_ERROR;
                    }

                    //
                    // loop through entries
                    //

                    lpLogLine->szClientIP = szEmpty;
                    lpLogLine->szUserName = szEmpty;
                    lpLogLine->szDate = szEmpty;
                    lpLogLine->szTime = szEmpty;
                    lpLogLine->szOperation = szEmpty;
                    lpLogLine->szTargetURL = szEmpty;
                    lpLogLine->szParameters = szEmpty;
                    lpLogLine->szServiceStatus = szEmpty;
                    lpLogLine->szBytesSent = szEmpty;
                    lpLogLine->szBytesRec = szEmpty;
                    lpLogLine->szService = szW3Svc;
                    lpLogLine->szVersion = szDefaultHTTPVersion;

                    (VOID)FindChar( cpCurrent, '\n' );
                    for (pos = 1;
                         *cpCurrent != '\0';
                         pos++) {

                        pszValue = cpCurrent;
                        cpCurrent = FindChar(cpCurrent,' ');

                        if ( pos == dwHostNamePos ) {
                            lpLogLine->szClientIP = pszValue;
                            if (DoDNSConversion) {
                                lpLogLine->szClientIP = GetMachineName(
                                                            lpLogLine->szClientIP
                                                            );
                            }
                        } else if (pos == dwUserNamePos) {

                            lpLogLine->szUserName = pszValue;
                        } else if (pos == dwDatePos) {

                            lpLogLine->szDate = pszValue;
                        } else if (pos == dwTimePos) {

                            lpLogLine->szTime = pszValue;
                        } else if (pos == dwMethodPos) {

                            lpLogLine->szOperation = pszValue;
                        } else if (pos == dwURIStemPos) {

                            lpLogLine->szTargetURL = pszValue;
                        } else if (pos == dwURIQueryPos) {

                            lpLogLine->szParameters = pszValue;
                        } else if (pos == dwHTTPStatusPos) {

                            lpLogLine->szServiceStatus = pszValue;
                        } else if (pos == dwBytesSentPos) {

                            lpLogLine->szBytesSent = pszValue;
                        } else if (pos == dwBytesRecvPos) {

                            lpLogLine->szBytesRec = pszValue;
                        } else if (pos == dwServicePos) {

                            lpLogLine->szService = pszValue;
                        } else if (pos == dwVersionPos) {

                            lpLogLine->szVersion = pszValue;
                        }
                    }

                    if ( lpLogLine->szDate == szEmpty ) {
                        lpLogLine->szDate = szGlobalDate;
                    }

                    if ( lpLogLine->szTime == szEmpty ) {
                        lpLogLine->szTime = szGlobalTime;
                    }

                    bRetCode = GETLOG_SUCCESS;
                }
            }
        }                                                   // end if first char = NewLine
    }                                                       // end if fgets != NULL

    return (bRetCode);
}


WORD
DateStringToDOSDate(
    IN PCHAR szDate
    )
{
    char    *szDay;
    char    *szMonth;
    char    *szYear;
    char    *cpCurrent;
    char    szTmpStr[20];
    int     iYear;

    if ( LogFileFormat == LOGFILE_CUSTOM ) {

        strcpy (szTmpStr, szDate);
        cpCurrent = szTmpStr;

        szYear = cpCurrent;
        cpCurrent = FindChar(cpCurrent,'-');

        szMonth = cpCurrent;
        cpCurrent = FindChar(cpCurrent,'-');

        szDay = cpCurrent;

        iYear=atoi(szYear);
        if ( iYear > 1980 ) {
            iYear -= 1980;
        }

    } else {

        strcpy (szTmpStr, szDate);
        cpCurrent = szTmpStr;

        if ( dwDateFormat == DateFormatJapan ) {
            // YY/MM/DD
            szYear = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szMonth = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szDay = cpCurrent;
        } else if (dwDateFormat == DateFormatGermany ) {

            // DD.MM.YY

            szDay = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '.');

            szMonth = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '.');

            szYear = cpCurrent;

        } else {
            // MM/DD/YY

            szMonth = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szDay = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szYear = cpCurrent;
        }

        iYear=atoi(szYear);

        if ( iYear < 80 ) {
            iYear += 2000;
        }

        if (iYear > 1980 ) {
            iYear = iYear - 1980;
        } else if (iYear >= 80 ) {
            iYear = iYear - 80;
        }
    }

    return ((iYear << 9) | (atoi(szMonth) << 5) | atoi(szDay));

} // DateStringToDOSDate



WORD
TimeStringToDOSTime(
    IN PCHAR szTime,
    IN LPWORD lpwSec
    )
{
    char    *cpCurrent;
    char    *szHour;
    char    *szMinute;
    char    *szSecond;
    char    szTmpStr[20];

    strcpy (szTmpStr, szTime);
    cpCurrent = szTmpStr;

    szHour = cpCurrent;
    cpCurrent = FindChar (cpCurrent, ':');

    szMinute = cpCurrent;
    cpCurrent = FindChar (cpCurrent, ':');

    szSecond = cpCurrent;
    *lpwSec = (WORD)atoi(szSecond);

    return ( (atoi(szHour) << 11) | (atoi(szMinute) << 5) | (atoi(szSecond) / 2));
}


char *
AscMonth (
    IN WORD wMonth,
    IN char *szMonth
    )
{
    switch (wMonth)
    {
        case 1:
            strncpy (szMonth, szJan, 3);
            break;
        case 2:
            strncpy (szMonth, szFeb, 3);
            break;
        case 3:
            strncpy (szMonth, szMar, 3);
            break;
        case 4:
            strncpy (szMonth, szApr, 3);
            break;
        case 5:
            strncpy (szMonth, szMay, 3);
            break;
        case 6:
            strncpy (szMonth, szJun, 3);
            break;
        case 7:
            strncpy (szMonth, szJul, 3);
            break;
        case 8:
            strncpy (szMonth, szAug, 3);
            break;
        case 9:
            strncpy (szMonth, szSep, 3);
            break;
        case 10:
            strncpy (szMonth, szOct, 3);
            break;
        case 11:
            strncpy (szMonth, szNov, 3);
            break;
        case 12:
            strncpy (szMonth, szDec, 3);
            break;
    }                                                       //end switch
    szMonth[3] = '\0';
    return (szMonth);
}                                                           //end AscMonth



FILE *
StartNewOutputLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR   pszInFileName,
        IN PCHAR szDate
        )
{
    BOOL    bRet;
    DWORD   dwErr;

    if (pOutFile->fpOutFile != NULL ) {

        fclose(pOutFile->fpOutFile);
        pOutFile->fpOutFile = NULL;

        bRet = MoveFileEx(
                    pOutFile->szTmpFileName,
                    pOutFile->szOutFileName,
                    MOVEFILE_COPY_ALLOWED);

        if (!bRet) {

            dwErr = GetLastError();
            switch (dwErr)
            {
                case ERROR_FILE_EXISTS:
                case ERROR_ALREADY_EXISTS:
                    CombineFiles(
                            pOutFile->szTmpFileName,
                            pOutFile->szOutFileName);
                    break;
                case ERROR_PATH_NOT_FOUND:
                    break;
                default:
                    printfids(IDS_FILE_ERR, dwErr);
                    exit (1);
                    break;
            }
        }
        printfids(IDS_FILE_CLOSE, pOutFile->szOutFileName);
    }

    dwErr = GetTempPath(MAX_PATH, TempDir);

    if (0 != dwErr) {
        GetTempFileName(TempDir, "mhi", 0, pOutFile->szTmpFileName);
    } else {
        GetTempFileName(".", "mhi", 0, pOutFile->szTmpFileName);
    }

    pOutFile->fpOutFile = fopen(pOutFile->szTmpFileName, "w");

    sprintf(pOutFile->szOutFileName,
        "%s%s%s",
        OutputDir,
        pszInFileName,
        DoDNSConversion? ".ncsa.dns" : ".ncsa"
        );

    printfids (IDS_FILE_WRITE, pOutFile->szOutFileName);

    return (pOutFile->fpOutFile);

} // StartNewOutputLog



FILE *
StartNewOutputDumpLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR   pszInputFileName,
        IN LPCSTR   pszExt
        )
{
    BOOL    bRet;
    DWORD   dwErr;

    dwErr = GetTempPath(MAX_PATH, TempDir);

    if (0 != dwErr) {
        GetTempFileName(TempDir, "mhi", 0, pOutFile->szTmpFileName);
    } else {
        GetTempFileName(".", "mhi", 0, pOutFile->szTmpFileName);
    }

    pOutFile->fpOutFile = fopen(pOutFile->szTmpFileName, "w");

    sprintf(pOutFile->szOutFileName,"%s%s%s",
                OutputDir, pszInputFileName,
                pszExt
                );

    printfids (IDS_FILE_WRITE, pOutFile->szOutFileName);
    return (pOutFile->fpOutFile);

} // StartNewOutputDumpLog


/* #pragma INTRINSA suppress=all */
VOID
CombineFiles(
    IN LPTSTR lpszNew,
    IN LPTSTR lpszExisting
    )
{
    FILE    *fpExisting;
    FILE    *fpNew;
    char    szLine[4096];

    printfids(IDS_FILE_EXIST, lpszExisting);
    fpNew = fopen(lpszNew, "r");
    fpExisting = fopen(lpszExisting, "a");

    fgets(szLine, sizeof(szLine), fpNew);
    // last line contains only EOF, but does not overwrite szLine.
    // It should not be written.
    while (!feof(fpNew))
    {
        fputs(szLine, fpExisting);
        fgets(szLine, sizeof(szLine), fpNew);
    }

    if (fpNew) {
        fclose(fpNew);
    }

    if (fpExisting) {
        fclose(fpExisting);
    }

    DeleteFile(lpszNew);
}


void
Usage(
    IN PCHAR szProg
    )
{
    CHAR    szTemp[MAX_PATH];

    GetTempPath(MAX_PATH, szTemp);

    printfids(IDS_HEADER1);
    printfids(IDS_HEADER2);
    printfids(IDS_HEADER3);
    printfids(IDS_HEADER4);

    printfids(IDS_USAGE1, szProg);
    printfids(IDS_USAGE2);
    printfids(IDS_USAGE3);
    printfids(IDS_USAGE4);
    printfids(IDS_USAGE5);
    printfids(IDS_USAGE7);
    printfids(IDS_USAGE8);
    printfids(IDS_USAGE9);
    printfids(IDS_USAGE10);
    printfids(IDS_USAGE11);
    printfids(IDS_USAGE12);
    printfids(IDS_USAGE13);
    printfids(IDS_USAGE14);
    printfids(IDS_USAGE15);
    printfids(IDS_USAGE16);

    printfids(IDS_SAMPLE0, szProg);
    printfids(IDS_SAMPLE1, szProg);
    printfids(IDS_SAMPLE2, szProg);
    printfids(IDS_SAMPLE3, szProg);
    return;
}


VOID
printfids(
    IN DWORD ids,
    ...
    )
{
    CHAR szBuff[2048];
    CHAR szString[2048];
    WCHAR szOutput[2048];
    va_list  argList;

    //
    //  Try and load the string
    //

    if ( !LoadString( GetModuleHandle( NULL ),
       ids,
       szString,
       sizeof( szString ) ))
    {
        printf( "Error loading string ID %d\n",
        ids );

        return;
    }

    va_start( argList, ids );
    vsprintf( szBuff, szString, argList );
    va_end( argList );

    MultiByteToWideChar( CP_ACP, 0, szBuff, -1, szOutput, sizeof(szOutput)/sizeof(WCHAR));
    
    WideCharToMultiByte( GetConsoleOutputCP(), 0, szOutput, wcslen(szOutput)+1,
        szBuff, sizeof(szBuff), NULL, NULL);

    printf(szBuff );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\convlog\webline.c ===
#include "convlog.h"

BOOL
ProcessWebLine(
    IN LPINLOGLINE lpLogLine,
    IN LPCSTR      pszInFileName,
    IN LPOUTFILESTATUS lpOutFile
    )
{

    BOOL                    bLineOK = FALSE;                //function return code
    BOOL                    bDateChanged = FALSE;
    BOOL                    bTimeChanged = FALSE;
    char                    szMonth[4];
    char                    szDate[MAX_PATH];
    char                    szTime[MAX_PATH];
    static WORD             wSecond;						// Bug # 110921

    PCHAR   szBytes;

    //
    // NCSA Only
    //

    {
        bDateChanged = FALSE;
        bTimeChanged = FALSE;
        bLineOK = TRUE;

        if ( 0 != strcmp(lpOutFile->szLastDate, lpLogLine->szDate) ) {

            if (0 == strcmp(lpOutFile->szLastDate, NEW_DATETIME)) {

                lpOutFile->fpOutFile = StartNewOutputLog (
                                                lpOutFile,
                                                pszInFileName,
                                                lpLogLine->szDate
                                                );
            }

            strcpy(lpOutFile->szLastDate, lpLogLine->szDate);
            lpOutFile->DosDate.wDOSDate = DateStringToDOSDate(lpLogLine->szDate);
            bDateChanged = TRUE;
        }

        if (0 != strcmp(lpOutFile->szLastTime, lpLogLine->szTime))
        {
            strcpy(lpOutFile->szLastTime, lpLogLine->szTime);
            lpOutFile->DosDate.wDOSTime = TimeStringToDOSTime(lpLogLine->szTime, &wSecond);
            bTimeChanged = TRUE;
        }

        if (bDateChanged || bTimeChanged)
        {
            DosDateTimeToFileTime(lpOutFile->DosDate.wDOSDate, lpOutFile->DosDate.wDOSTime, &(lpOutFile->FileTime));
            FileTimeToSystemTime(&(lpOutFile->FileTime), &(lpOutFile->SystemTime));
            lpOutFile->SystemTime.wSecond = wSecond;
        }

        AscMonth (lpOutFile->SystemTime.wMonth, szMonth);

        //
        // Get bytes
        //

        if ( (_stricmp(lpLogLine->szOperation,"PUT") == 0) ||
             (_stricmp(lpLogLine->szOperation,"POST") == 0) ) {

            szBytes = lpLogLine->szBytesRec;
        } else {
            szBytes = lpLogLine->szBytesSent;
        }

        if ((0 != strcmp(lpLogLine->szParameters, " - ")) &&
           (0 != strcmp(lpLogLine->szParameters, "-,")) &&
           (0 != strcmp(lpLogLine->szParameters, "-")) &&
           (0 != strcmp(lpLogLine->szParameters, "")))
        {

            fprintf(lpOutFile->fpOutFile,"%s - %s [%02d/%s/%d:%02d:%02d:%02d %s] \"%s %s?%s %s\" %s %s\n",
            lpLogLine->szClientIP, lpLogLine->szUserName, lpOutFile->SystemTime.wDay,
            szMonth, lpOutFile->SystemTime.wYear, lpOutFile->SystemTime.wHour,
            lpOutFile->SystemTime.wMinute, lpOutFile->SystemTime.wSecond,
            NCSAGMTOffset, lpLogLine->szOperation,
            lpLogLine->szTargetURL, lpLogLine->szParameters, lpLogLine->szVersion,
            lpLogLine->szServiceStatus, szBytes);

        } else {

            fprintf(lpOutFile->fpOutFile, "%s - %s [%02d/%s/%d:%02d:%02d:%02d %s] \"%s %s %s\" %s %s\n",
            lpLogLine->szClientIP, lpLogLine->szUserName, lpOutFile->SystemTime.wDay,
            szMonth, lpOutFile->SystemTime.wYear, lpOutFile->SystemTime.wHour,
            lpOutFile->SystemTime.wMinute, lpOutFile->SystemTime.wSecond,
            NCSAGMTOffset, lpLogLine->szOperation,
            lpLogLine->szTargetURL, lpLogLine->szVersion, lpLogLine->szServiceStatus, szBytes);
        }
        //} //only process 200s
    }


    return (bLineOK);
}                                                           //end ProcessWebLine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\addmime.cpp ===
// addmime.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "addmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddMime dialog


CAddMime::CAddMime(CWnd* pParent /*=NULL*/)
	: CDialog(CAddMime::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddMime)
	m_strFileExtension = _T("");
	m_strGopherType = _T("");
	m_strImageFile = _T("");
	m_strMimeType = _T("");
	//}}AFX_DATA_INIT
}

void CAddMime::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddMime)
	DDX_Text(pDX, IDC_ADDMIMEFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_ADDMIMEGOPHERTYPEDATA1, m_strGopherType);
	DDX_Text(pDX, IDC_ADDMIMEIMAGEFILEDATA1, m_strImageFile);
	DDX_Text(pDX, IDC_ADDMIMEMIMETYPEDATA1, m_strMimeType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddMime, CDialog)
	//{{AFX_MSG_MAP(CAddMime)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAddMime message handlers

void CAddMime::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}
///////////////////////////////////////////////////////////////////////////
// Other Public Functions

	LPCTSTR CAddMime::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CAddMime::GetGopherType()
	{
	return (m_strGopherType);
	}

	LPCTSTR CAddMime::GetImageFile()
	{
	return (m_strImageFile);
	}

	LPCTSTR CAddMime::GetMimeType()
	{
	return (m_strMimeType);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\addmime.h ===
// addmime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddMime dialog

class CAddMime : public CDialog
{
// Construction
public:
	CAddMime(CWnd* pParent = NULL);   // standard constructor
// Dialog Data
	//{{AFX_DATA(CAddMime)
	enum { IDD = IDD_ADDMIMEMAPDIALOG };
	CString	m_strFileExtension;
	CString	m_strGopherType;
	CString	m_strImageFile;
	CString	m_strMimeType;
	//}}AFX_DATA

	LPCTSTR GetFileExtension();
	LPCTSTR GetGopherType();
	LPCTSTR GetImageFile();
	LPCTSTR GetMimeType();


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddMime)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddMime)
	virtual void OnOK();
	//}}AFX_MSG

	

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\combut1.cpp ===
// combut1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "combut1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCOMBUT1

CCOMBUT1::CCOMBUT1()
{
}

CCOMBUT1::~CCOMBUT1()
{
}


BEGIN_MESSAGE_MAP(CCOMBUT1, CButton)
	//{{AFX_MSG_MAP(CCOMBUT1)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCOMBUT1 message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\addscrip.cpp ===
// addscrip.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "addscrip.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddScript dialog


CAddScript::CAddScript(CWnd* pParent /*=NULL*/)
	: CDialog(CAddScript::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddScript)
	m_strFileExtension = _T("");
	m_strScriptMap = _T("");
	//}}AFX_DATA_INIT
}


void CAddScript::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddScript)
	DDX_Text(pDX, IDC_ADDSCRIPTFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_ADDSCRIPTMAPPINGDATA1, m_strScriptMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddScript, CDialog)
	//{{AFX_MSG_MAP(CAddScript)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAddScript message handlers

	LPCTSTR CAddScript::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CAddScript::GetScriptMap()
	{
	return (m_strScriptMap);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\advcom1.cpp ===
// advcom1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "advcom1.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CADVCOM1 dialog

IMPLEMENT_DYNCREATE(CADVCOM1, CGenPage)

CADVCOM1::CADVCOM1(): CGenPage(CADVCOM1::IDD)
{
	//{{AFX_DATA_INIT(CADVCOM1)
	//}}AFX_DATA_INIT
}

CADVCOM1::~CADVCOM1()
{
}

void CADVCOM1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CADVCOM1)
	DDX_Control(pDX, IDC_LOGFILEFLUSHINTERVALSPIN1, m_spinLogFileFlushInterval);
	DDX_Control(pDX, IDC_LOGFILEFLUSHINTERVALDATA1, m_editLogFileFlushInterval);
	DDX_Control(pDX, IDC_USELOGFILEFLUSHINTERNVALDATA1, m_cboxUseLogFileFlushInterval);
	DDX_Control(pDX, IDC_USERTOKENTTLSPIN1, m_spinUserTokenTTL);
	DDX_Control(pDX, IDC_USEOBJECTCACHETTLDATA1, m_cboxUseObjCacheTTL);
	DDX_Control(pDX, IDC_OBJCACHEDATA1, m_editObjCacheTTL);
	DDX_Control(pDX, IDC_ACCEPTEXTODATA1, m_editAcceptExTO);
	DDX_Control(pDX, IDC_ACCEPTEXOUTDATA1, m_editAcceptExOut);
	DDX_Control(pDX, IDC_COMDBGFLAGSDATA1, m_editComDbgFlags);
	DDX_Control(pDX, IDC_USEACCEPTEXDATA1, m_cboxUseAcceptEx);
	DDX_Control(pDX, IDC_THREADTOSPIN1, m_spinThreadTO);
	DDX_Control(pDX, IDC_OBJCACHESPIN1, m_spinObjCache);
	DDX_Control(pDX, IDC_MAXPOOLSPIN1, m_spinMaxPool);
	DDX_Control(pDX, IDC_MAXCONCURSPIN1, m_spinMaxConcur);
	DDX_Control(pDX, IDC_ACCEPTEXTOSPIN1, m_spinAcceptExTO);
	DDX_Control(pDX, IDC_ACCEPTEXOUTSPIN1, m_spinAcceptExOut);
	DDX_TexttoHex(pDX, IDC_COMDBGFLAGSDATA1, m_ulComDbgFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CADVCOM1, CGenPage)
	//{{AFX_MSG_MAP(CADVCOM1)
	ON_EN_CHANGE(IDC_ACCEPTEXOUTDATA1, OnChangeAcceptexoutdata1)
	ON_EN_CHANGE(IDC_ACCEPTEXTODATA1, OnChangeAcceptextodata1)
	ON_EN_CHANGE(IDC_MAXCONCURDATA1, OnChangeMaxconcurdata1)
	ON_EN_CHANGE(IDC_MAXPOOLDATA1, OnChangeMaxpooldata1)
	ON_EN_CHANGE(IDC_OBJCACHEDATA1, OnChangeObjcachedata1)
	ON_EN_CHANGE(IDC_THREADTODATA1, OnChangeThreadtodata1)
	ON_BN_CLICKED(IDC_USEACCEPTEXDATA1, OnUseacceptexdata1)
	ON_EN_CHANGE(IDC_COMDBGFLAGSDATA1, OnChangeComdbgflagsdata1)
	ON_BN_CLICKED(IDC_USEOBJECTCACHETTLDATA1, OnUseobjectcachettldata1)
	ON_EN_CHANGE(IDC_USERTOKENTTLDATA1, OnChangeUsertokenttldata1)
	ON_BN_CLICKED(IDC_USELOGFILEFLUSHINTERNVALDATA1, OnUselogfileflushinternvaldata1)
	ON_EN_CHANGE(IDC_LOGFILEFLUSHINTERVALDATA1, OnChangeLogfileflushintervaldata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CADVCOM1 message handlers

BOOL CADVCOM1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();

	for (i = 0; i < AdvComPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].strFieldName = _T(MAXPOOLTHREADSNAME);	
	m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulDefaultValue = DEFAULTMAXPOOLTHREADS;

	m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].strFieldName = _T(MAXCONCURRENCYNAME);	
	m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulDefaultValue = DEFAULTMAXCONCURRENCY;

	m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].strFieldName = _T(THREADTIMEOUTNAME);	
	m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulDefaultValue = DEFAULTTHREADTIMEOUT;
	m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulMultipleFactor = 60;

	m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].strFieldName = _T(USEACCEPTEXNAME);	
	m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].ulDefaultValue = DEFAULTUSEACCEPTEX;

	m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].strFieldName = _T(OBJECTCACHETTLNAME);	
	m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulDefaultValue = DEFAULTOBJECTCACHETTL;
	m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor = 60;

	m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].strFieldName = _T(USERTOKENTTLNAME);	
	m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulDefaultValue = DEFAULTUSERTOKENTTL;
	m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulMultipleFactor = 60;


	m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].strFieldName = _T(ACCEPTEXOUTSTANDINGNAME);	
	m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulDefaultValue = DEFAULTACCEPTEXOUTSTANDING;

	m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].strFieldName = _T(ACCEPTEXTIMEOUTNAME);	
	m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulDefaultValue = DEFAULTACCEPTEXTIMEOUT;

	m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].strFieldName = _T(LOGFILEFLUSHINTERVALNAME);	
	m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulDefaultValue = DEFAULTLOGFILEFLUSHINTERVAL;
	m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor = 60;

	m_binNumericRegistryEntries[AdvComPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvComPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;


	for (i = 0; i < AdvComPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
   
	m_spinThreadTO.SetRange(MINTHREADTIMEOUT, MAXTHREADTIMEOUT);
	m_spinThreadTO.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulMultipleFactor),MAXTHREADTIMEOUT));
	
	m_spinObjCache.SetRange(MINOBJECTCACHETTL, MAXOBJECTCACHETTL);
	if (m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue != 0xffffffff) {
	   m_spinObjCache.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue / 
	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor),MAXOBJECTCACHETTL));
	   SetObjCacheTTLEnabledState(TRUE);
	}
	else {
	   m_spinObjCache.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulDefaultValue /
  	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor),MAXOBJECTCACHETTL));
	   SetObjCacheTTLEnabledState(FALSE);
	}

	m_spinUserTokenTTL.SetRange(MINUSERTOKENTTL, MAXUSERTOKENTTL);
	m_spinUserTokenTTL.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulMultipleFactor),MAXUSERTOKENTTL));

	m_spinMaxPool.SetRange(MINMAXPOOLTHREADS,MAXMAXPOOLTHREADS);
	m_spinMaxPool.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulMultipleFactor),MAXMAXPOOLTHREADS));
	
	m_spinMaxConcur.SetRange(MINMAXCONCURRENCY, MAXMAXCONCURRENCY);
	m_spinMaxConcur.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulMultipleFactor), MAXMAXCONCURRENCY));
	
	m_spinAcceptExTO.SetRange(MINACCEPTEXTIMEOUT,MAXACCEPTEXTIMEOUT);
	m_spinAcceptExTO.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulMultipleFactor),MAXACCEPTEXTIMEOUT));
	
	m_spinAcceptExOut.SetRange(MINACCEPTEXOUTSTANDING,MAXACCEPTEXOUTSTANDING);
	m_spinAcceptExOut.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulMultipleFactor),MAXACCEPTEXOUTSTANDING));

	m_cboxUseAcceptEx.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].ulFieldValue));
	SetAcceptExEnabledState();

	m_spinLogFileFlushInterval.SetRange(MINLOGFILEFLUSHINTERVAL, MAXLOGFILEFLUSHINTERVAL);
	if (m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue != 0xffffffff) {
	   m_spinLogFileFlushInterval.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue / 
	      m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor),MAXLOGFILEFLUSHINTERVAL));
	   SetLogFileFlushIntervalEnabledState(TRUE);
	}
	else {
	   m_spinObjCache.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulDefaultValue /
  	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor),MAXOBJECTCACHETTL));
	   SetObjCacheTTLEnabledState(FALSE);
	}



	m_editComDbgFlags.LimitText(8);
	m_ulComDbgFlags = m_binNumericRegistryEntries[AdvComPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CADVCOM1::OnChangeAcceptexoutdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulFieldValue = m_spinAcceptExOut.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnChangeAcceptextodata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulFieldValue = m_spinAcceptExTO.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnChangeMaxconcurdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulFieldValue = m_spinMaxConcur.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnChangeMaxpooldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulFieldValue = m_spinMaxPool.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CADVCOM1::OnChangeObjcachedata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue = m_spinObjCache.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnUseobjectcachettldata1() 
{
	// TODO: Add your control notification handler code here
SetObjCacheTTLEnabledState(m_cboxUseObjCacheTTL.GetCheck());
if (m_bSetChanged) {
   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].bIsChanged = TRUE;	

   m_bIsDirty = TRUE;
   SetModified(TRUE);
   }

}


void CADVCOM1::OnChangeThreadtodata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulFieldValue = m_spinThreadTO.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnUseacceptexdata1() 
{
	// TODO: Add your control notification handler code here
	SetAcceptExEnabledState();

	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxUseAcceptEx.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CADVCOM1::OnChangeComdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CADVCOM1::OnChangeUsertokenttldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulFieldValue = m_spinUserTokenTTL.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}


void CADVCOM1::OnUselogfileflushinternvaldata1() 
{
	// TODO: Add your control notification handler code here
SetLogFileFlushIntervalEnabledState(m_cboxUseLogFileFlushInterval.GetCheck());
if (m_bSetChanged) {
   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].bIsChanged = TRUE;	

   m_bIsDirty = TRUE;
   SetModified(TRUE);
   }

}

void CADVCOM1::OnChangeLogfileflushintervaldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue = m_spinLogFileFlushInterval.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}




//////////////////////////////////////////////////////////////////
// Other routines

void CADVCOM1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvComPage_DebugFlags].ulFieldValue = m_ulComDbgFlags;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvComPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}



void CADVCOM1::SetAcceptExEnabledState()
{
if (m_cboxUseAcceptEx.GetCheck() != 0) {
   m_spinAcceptExTO.EnableWindow(TRUE);
   m_editAcceptExTO.EnableWindow(TRUE);
   m_spinAcceptExOut.EnableWindow(TRUE);
   m_editAcceptExOut.EnableWindow(TRUE);
   if (m_bSetChanged) {		//if user enabled this, make sure there's a value there
	  m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].bIsChanged = TRUE;	
	  m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].bIsChanged = TRUE;	
   }

}
else {
   m_spinAcceptExTO.EnableWindow(FALSE);
   m_editAcceptExTO.EnableWindow(FALSE);
   m_spinAcceptExOut.EnableWindow(FALSE);
   m_editAcceptExOut.EnableWindow(FALSE);
}
}

void CADVCOM1::SetObjCacheTTLEnabledState(BOOL bEnabled)
{
	if (bEnabled) {
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue = 
	      m_spinObjCache.GetPos() * 
	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor;
	   m_cboxUseObjCacheTTL.SetCheck(CHECKEDVALUE);
	   m_spinObjCache.EnableWindow(TRUE);
	   m_editObjCacheTTL.EnableWindow(TRUE);
	}
	else {
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue = 0xffffffff;
	   m_cboxUseObjCacheTTL.SetCheck(UNCHECKEDVALUE);
	   m_spinObjCache.EnableWindow(FALSE);
	   m_editObjCacheTTL.EnableWindow(FALSE);
	}
}	

void CADVCOM1::SetLogFileFlushIntervalEnabledState(BOOL bEnabled)
{
	if (bEnabled) {
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue = 
	      m_spinLogFileFlushInterval.GetPos() * 
	      m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor;
	   m_cboxUseLogFileFlushInterval.SetCheck(CHECKEDVALUE);
	   m_spinLogFileFlushInterval.EnableWindow(TRUE);
	   m_editLogFileFlushInterval.EnableWindow(TRUE);
	}
	else {
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue = 0xffffffff;
	   m_cboxUseLogFileFlushInterval.SetCheck(UNCHECKEDVALUE);
	   m_spinLogFileFlushInterval.EnableWindow(FALSE);
	   m_editLogFileFlushInterval.EnableWindow(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\addscrip.h ===
// addscrip.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddScript dialog

class CAddScript : public CDialog
{
// Construction
public:
	CAddScript(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddScript)
	enum { IDD = IDD_ADDSCRIPTDIALOG };
	CString	m_strFileExtension;
	CString	m_strScriptMap;
	//}}AFX_DATA

	LPCTSTR GetFileExtension();
	LPCTSTR GetScriptMap();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddScript)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddScript)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\advcom1.h ===
// advcom1.h : header file
//

// Advanced Common Page

#define MAXPOOLTHREADSNAME	"MaxPoolThreads"
#define MINMAXPOOLTHREADS	0
#define	MAXMAXPOOLTHREADS	1000
#define DEFAULTMAXPOOLTHREADS	10

#define MAXCONCURRENCYNAME	"MaxConcurrency"
#define MINMAXCONCURRENCY	0
#define MAXMAXCONCURRENCY	32
#define DEFAULTMAXCONCURRENCY	0

#define THREADTIMEOUTNAME	"ThreadTimeout"
#define MINTHREADTIMEOUT	0
#define MAXTHREADTIMEOUT	0x7FFF						// Specify in minutes
#define DEFAULTTHREADTIMEOUT	(24 * 60 * 60)			// 24 hours

#define USEACCEPTEXNAME		"UseAcceptEX"
#define DEFAULTUSEACCEPTEX	TRUEVALUE

#define OBJECTCACHETTLNAME	"ObjectCacheTTL"
#define MINOBJECTCACHETTL	0
#define MAXOBJECTCACHETTL	0x7FFF 						//Specify in Minutes
#define DEFAULTOBJECTCACHETTL	(10 * 60)

#define USERTOKENTTLNAME	"UserTokenTTL"
#define MINUSERTOKENTTL	0
#define MAXUSERTOKENTTL	0x7FFF 						//Specify in Minutes
#define DEFAULTUSERTOKENTTL	(15 * 60)

#define ACCEPTEXOUTSTANDINGNAME	"AcceptExOutstanding"
#define MINACCEPTEXOUTSTANDING	0
#define MAXACCEPTEXOUTSTANDING	1000
#define	DEFAULTACCEPTEXOUTSTANDING	40

#define ACCEPTEXTIMEOUTNAME		"AcceptExTimeout"
#define MINACCEPTEXTIMEOUT	0
#define MAXACCEPTEXTIMEOUT	(60 * 60)					// 1 hour
#define DEFAULTACCEPTEXTIMEOUT	120

#define LOGFILEFLUSHINTERVALNAME	"LogFileFlushInterval"
#define MINLOGFILEFLUSHINTERVAL	1
#define MAXLOGFILEFLUSHINTERVAL	0x7FFF 						//Specify in Minutes
#define DEFAULTLOGFILEFLUSHINTERVAL	(5 * 60)

enum ADV_COMMON_NUM_REG_ENTRIES {
	 AdvComPage_MaxPoolThreads,
	 AdvComPage_MaxConcurrency,
	 AdvComPage_ThreadTimeout,
	 AdvComPage_UseAcceptEx,
	 AdvComPage_ObjectCacheTTL,
	 AdvComPage_UserTokenTTL,
	 AdvComPage_AcceptExOutstanding,
	 AdvComPage_AcceptExTimeout,
	 AdvComPage_LogFileFlushInterval,
	 AdvComPage_DebugFlags,
	 AdvComPage_TotalNumRegEntries
	 };

/////////////////////////////////////////////////////////////////////////////
// CADVCOM1 dialog

class CADVCOM1 : public CGenPage
{
	DECLARE_DYNCREATE(CADVCOM1)

// Construction
public:
	CADVCOM1();
	~CADVCOM1();

// Dialog Data
	//{{AFX_DATA(CADVCOM1)
	enum { IDD = IDD_ADVCOMSET1 };
	CSpinButtonCtrl	m_spinLogFileFlushInterval;
	CEdit	m_editLogFileFlushInterval;
	CButton	m_cboxUseLogFileFlushInterval;
	CSpinButtonCtrl	m_spinUserTokenTTL;
	CButton	m_cboxUseObjCacheTTL;
	CEdit	m_editObjCacheTTL;
	CEdit	m_editAcceptExTO;
	CEdit	m_editAcceptExOut;
	CEdit	m_editComDbgFlags;
	CButton	m_cboxUseAcceptEx;
	CSpinButtonCtrl	m_spinThreadTO;
	CSpinButtonCtrl	m_spinObjCache;
	CSpinButtonCtrl	m_spinMaxPool;
	CSpinButtonCtrl	m_spinMaxConcur;
	CSpinButtonCtrl	m_spinAcceptExTO;
	CSpinButtonCtrl	m_spinAcceptExOut;
	DWORD	m_ulComDbgFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CADVCOM1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CADVCOM1)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeAcceptexoutdata1();
	afx_msg void OnChangeAcceptextodata1();
	afx_msg void OnChangeMaxconcurdata1();
	afx_msg void OnChangeMaxpooldata1();
	afx_msg void OnChangeObjcachedata1();
	afx_msg void OnChangeThreadtodata1();
	afx_msg void OnUseacceptexdata1();
	afx_msg void OnChangeComdbgflagsdata1();
	afx_msg void OnUseobjectcachettldata1();
	afx_msg void OnChangeUsertokenttldata1();
	afx_msg void OnUselogfileflushinternvaldata1();
	afx_msg void OnChangeLogfileflushintervaldata1();
	//}}AFX_MSG

	void  SetAcceptExEnabledState(void);
	void SetObjCacheTTLEnabledState(BOOL bEnabled);
	void SetLogFileFlushIntervalEnabledState(BOOL bEnabled);


	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvComPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\afximpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct AUX_DATA
{
	// system metrics
	int cxVScroll, cyHScroll;
	int cxIcon, cyIcon;

	int cxBorder2, cyBorder2;

	// device metrics for screen
	int cxPixelsPerInch, cyPixelsPerInch;
	int cySysFont;

	// solid brushes with convenient gray colors and system colors
	HBRUSH hbrLtGray, hbrDkGray;
	HBRUSH hbrBtnHilite, hbrBtnFace, hbrBtnShadow;
	HBRUSH hbrWindowFrame;
	HPEN hpenBtnHilite, hpenBtnShadow, hpenBtnText;

	// color values of system colors used for CToolBar
	COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
	COLORREF clrBtnText, clrWindowFrame;

	// standard cursors
	HCURSOR hcurWait;
	HCURSOR hcurArrow;
	HCURSOR hcurHelp;       // cursor used in Shift+F1 help

	// special GDI objects allocated on demand
	HFONT   hStatusFont;
	HFONT   hToolTipsFont;
	HBITMAP hbmMenuDot;

	// other system information
	UINT    nWinVer;        // Major.Minor version numbers
	BOOL	bWin32s;		// TRUE if Win32s (or Windows 95)
	BOOL    bWin4;          // TRUE if Windows 4.0
	BOOL    bNotWin4;       // TRUE if not Windows 4.0
	BOOL    bSmCaption;     // TRUE if WS_EX_SMCAPTION is supported
	BOOL	bWin31; 		// TRUE if actually Win32s on Windows 3.1
	BOOL	bMarked4;		// TRUE if marked as 4.0

	// special Windows API entry points
	int (WINAPI* pfnSetScrollInfo)(HWND, int, LPCSCROLLINFO, BOOL);
	BOOL (WINAPI* pfnGetScrollInfo)(HWND, int, LPSCROLLINFO);

// Implementation
	AUX_DATA();
	~AUX_DATA();
	void UpdateSysColors();
	void UpdateSysMetrics();
};

extern AFX_DATA AUX_DATA afxData;

////////////////////////////////////////////////////////////////////////////
// other global state

#ifdef _WINDLL
	extern DWORD _afxAppTlsIndex;
	extern AFX_APP_STATE* _afxAppState;
#endif
extern DWORD _afxThreadTlsIndex;

// Note: afxData.cxBorder and afxData.cyBorder aren't used anymore
#define CX_BORDER   1
#define CY_BORDER   1

// states for Shift+F1 hep mode
#define HELP_INACTIVE   0   // not in Shift+F1 help mode (must be 0)
#define HELP_ACTIVE     1   // in Shift+F1 help mode (non-zero)
#define HELP_ENTERING   2   // entering Shift+F1 help mode (non-zero)

/////////////////////////////////////////////////////////////////////////////
// Window class names and other window creation support

// from wincore.cpp
extern const TCHAR _afxWnd[];           // simple child windows/controls
extern const TCHAR _afxWndControlBar[]; // controls with grey backgrounds
extern const TCHAR _afxWndMDIFrame[];
extern const TCHAR _afxWndFrameOrView[];

INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);
UINT_PTR CALLBACK _AfxCommDlgProc(HWND hWnd, UINT, WPARAM, LPARAM);

// Support for standard dialogs
extern const UINT _afxNMsgSETRGB;
typedef UINT_PTR (CALLBACK* COMMDLGPROC)(HWND, UINT, WPARAM, LPARAM);

/////////////////////////////////////////////////////////////////////////////
// Special helpers

HWND AFXAPI AfxGetSafeOwner(CWnd* pParent, HWND* phTopLevel = NULL);
void AFXAPI AfxCancelModes(HWND hWndRcvr);
HWND AFXAPI AfxGetParentOwner(HWND hWnd);
BOOL AFXAPI AfxIsDescendant(HWND hWndParent, HWND hWndChild);
BOOL AFXAPI AfxHelpEnabled();  // determine if ID_HELP handler exists
void AFXAPI AfxDeleteObject(HGDIOBJ* pObject);
BOOL AFXAPI AfxCustomLogFont(UINT nIDS, LOGFONT* pLogFont);

BOOL AFXAPI _AfxIsComboBoxControl(HWND hWnd, UINT nStyle);
BOOL AFXAPI _AfxCheckCenterDialog(LPCTSTR lpszResource);

#ifdef _MAC
BOOL AFXAPI _AfxIdenticalRect(LPCRECT lpRectOne, LPCRECT lpRectTwo);
#else
#define _AfxIdenticalRect EqualRect
#endif

// UNICODE/MBCS abstractions
#ifdef _MBCS
	extern const BOOL _afxDBCS;
#else
	#define _afxDBCS FALSE
#endif

// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))

//#define UNUSED  // usage: UNUSED formal_arg

/////////////////////////////////////////////////////////////////////////////
// useful message ranges

#define WM_SYSKEYFIRST  WM_SYSKEYDOWN
#define WM_SYSKEYLAST   WM_SYSDEADCHAR

#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
#define WM_NCMOUSELAST  WM_NCMBUTTONDBLCLK

/////////////////////////////////////////////////////////////////////////////
// AFX_CRITICAL_SECTION

#pragma warning(disable: 4097)

class AFX_CRITICAL_SECTION : public CRITICAL_SECTION
{
// Constructors & Operations
public:
	AFX_CRITICAL_SECTION();

// Attributes
	operator CRITICAL_SECTION*();

// Implementation
public:
	~AFX_CRITICAL_SECTION();

private:
	// no implementation (CRITICAL_SECTION objects cannot be copied)
	AFX_CRITICAL_SECTION(const AFX_CRITICAL_SECTION&);
	void operator=(const AFX_CRITICAL_SECTION&);
};

inline AFX_CRITICAL_SECTION::AFX_CRITICAL_SECTION()
	{ ::InitializeCriticalSection(this); }
inline AFX_CRITICAL_SECTION::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*)this; }
inline AFX_CRITICAL_SECTION::~AFX_CRITICAL_SECTION()
	{ ::DeleteCriticalSection(this); }

#pragma warning(default: 4097)

// global critical section for general thread safe access
extern AFX_DATA AFX_CRITICAL_SECTION _afxCriticalSection;

/////////////////////////////////////////////////////////////////////////////
// Portability abstractions

#define _AfxSetDlgCtrlID(hWnd, nID)     SetWindowLong(hWnd, GWL_ID, nID)
#define _AfxGetDlgCtrlID(hWnd)          ((UINT)(WORD)::GetDlgCtrlID(hWnd))

// misc helpers
BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
BOOL AFXAPI AfxComparePath(LPCTSTR lpszPath1, LPCTSTR lpszPath2);
UINT AFXAPI AfxGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);
UINT AFXAPI AfxGetFileName(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);
#ifdef _MAC
#define AfxGetFileName AfxGetFileTitle
#endif

const AFX_MSGMAP_ENTRY* AFXAPI
AfxFindMessageEntry(const AFX_MSGMAP_ENTRY* lpEntry,
	UINT nMsg, UINT nCode, UINT nID);

#define NULL_TLS ((DWORD)-1)

/////////////////////////////////////////////////////////////////////////////
// Debugging/Tracing helpers

#ifdef _DEBUG
	void AFXAPI _AfxTraceMsg(LPCTSTR lpszPrefix, const MSG* pMsg);
	BOOL AFXAPI _AfxCheckDialogTemplate(LPCTSTR lpszResource,
		BOOL bInvisibleChild);
#endif

/////////////////////////////////////////////////////////////////////////////
// Win4 specific defines

#if (WINVER < 0x400)

// new window styles
#define WS_EX_SMCAPTION         0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L

// new dialog styles
#define DS_3DLOOK               0x00000004L

// new scroll bar styles
#define SBS_SIZEGRIP            0x00000010L

// new common dialog flags
#define OFN_EXPLORER            0x00080000L

// new color metrics
#define COLOR_INFOTEXT			23
#define COLOR_INFOBK			24

#endif //(WINVER < 0x400)

#ifndef WS_EX_SMCAPTION
#define WS_EX_SMCAPTION WS_EX_TOOLWINDOW
#endif

#ifndef WM_DISPLAYCHANGE
#define WM_DISPLAYCHANGE		0x007E
#endif

/////////////////////////////////////////////////////////////////////////////
// Macintosh-specific declarations

#ifdef _MAC
#include <macname1.h>
#include <Types.h>
#include <QuickDraw.h>
#include <AppleEvents.h>
#include <macname2.h>

extern AEEventHandlerUPP _afxPfnOpenApp;
extern AEEventHandlerUPP _afxPfnOpenDoc;
extern AEEventHandlerUPP _afxPfnPrintDoc;
extern AEEventHandlerUPP _afxPfnQuit;

OSErr PASCAL _AfxOpenAppHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);
OSErr PASCAL _AfxOpenDocHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);
OSErr PASCAL _AfxPrintDocHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);
OSErr PASCAL _AfxQuitHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);

void AFXAPI _AfxStripDialogCaption(HINSTANCE hInst, LPCTSTR lpszResource);

GDHandle AFXAPI _AfxFindDevice(int x, int y);
BOOL AFXAPI AfxCheckMonochrome(const RECT* pRect);
HFONT AFXAPI _AfxGetHelpFont();

#endif //_MAC

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\compage1.cpp ===
// compage1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "compage1.h"
#include "registry.h"
#include "genpage.h"
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCOMPAGE1 property page				  

IMPLEMENT_DYNCREATE(CCOMPAGE1, CGenPage)

CCOMPAGE1::CCOMPAGE1() : CGenPage(CCOMPAGE1::IDD)
{


	//{{AFX_DATA_INIT(CCOMPAGE1)
	//}}AFX_DATA_INIT

}

CCOMPAGE1::~CCOMPAGE1()
{
}

void CCOMPAGE1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCOMPAGE1)
	DDX_Control(pDX, IDC_LISTENBACKLOGSPIN1, m_spinListenBacklog);
	DDX_Control(pDX, IDC_LOGBATSPIN1, m_spinLogBatSpin1);
	DDX_Control(pDX, IDC_CACHESPIN1, m_spinCacheSpin1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCOMPAGE1, CGenPage)
	//{{AFX_MSG_MAP(CCOMPAGE1)
	ON_EN_CHANGE(IDC_CACHEDATA1, OnChangeCachedata1)
	ON_EN_CHANGE(IDC_LOGBATDATA1, OnChangeLogbatdata1)
	ON_EN_CHANGE(IDC_LISTENBACKLOGDATA1, OnChangeListenbacklogdata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCOMPAGE1 message handlers



BOOL CCOMPAGE1::OnInitDialog() 
{
	int i;

	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here

	
	for (i = 0; i < ComPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }

	m_binNumericRegistryEntries[ComPage_LogBat].strFieldName = _T(LOGBATNAME);	
	m_binNumericRegistryEntries[ComPage_LogBat].ulMultipleFactor = 1024;
	m_binNumericRegistryEntries[ComPage_LogBat].ulDefaultValue = DEFAULTLOGFILEBATCHSIZE;

	m_binNumericRegistryEntries[ComPage_MemCache].strFieldName = _T(MEMORYCACHENAME);
	m_binNumericRegistryEntries[ComPage_MemCache].ulMultipleFactor = 1024 * 1024;
	m_binNumericRegistryEntries[ComPage_MemCache].ulDefaultValue = DEFAULTMEMORYCACHESIZE;

	m_binNumericRegistryEntries[ComPage_ListenBacklog].strFieldName = _T(LISTENBACKLOGNAME);
	m_binNumericRegistryEntries[ComPage_ListenBacklog].ulDefaultValue = DEFAULTLISTENBACKLOG;

	for (i = 0; i < ComPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
  
	m_spinLogBatSpin1.SetRange(MINLOGFILEBATCHSIZE, MAXLOGFILEBATCHSIZE);
	m_spinLogBatSpin1.SetPos(LESSOROF((m_binNumericRegistryEntries[ComPage_LogBat].ulFieldValue / 
	   m_binNumericRegistryEntries[ComPage_LogBat].ulMultipleFactor), MAXLOGFILEBATCHSIZE));
	m_spinCacheSpin1.SetRange(MINMEMORYCACHESIZE, MAXMEMORYCACHESIZE);
	m_spinCacheSpin1.SetPos(LESSOROF((m_binNumericRegistryEntries[ComPage_MemCache].ulFieldValue / 
	   m_binNumericRegistryEntries[ComPage_MemCache].ulMultipleFactor), MAXMEMORYCACHESIZE));
	m_spinListenBacklog.SetRange(MINLISTENBACKLOG, MAXLISTENBACKLOG);
	m_spinListenBacklog.SetPos(LESSOROF((m_binNumericRegistryEntries[ComPage_ListenBacklog].ulFieldValue / 
	   m_binNumericRegistryEntries[ComPage_ListenBacklog].ulMultipleFactor), MAXLISTENBACKLOG));
  
	m_bSetChanged = TRUE;	// Any more changes come from the user

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CCOMPAGE1::OnChangeCachedata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[ComPage_MemCache].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[ComPage_MemCache].ulFieldValue = m_spinCacheSpin1.GetPos() 
	      * m_binNumericRegistryEntries[ComPage_MemCache].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CCOMPAGE1::OnChangeLogbatdata1() 
{				
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[ComPage_LogBat].bIsChanged = TRUE;
	   m_binNumericRegistryEntries[ComPage_LogBat].ulFieldValue = m_spinLogBatSpin1.GetPos() * 
	      m_binNumericRegistryEntries[ComPage_LogBat].ulMultipleFactor;		
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CCOMPAGE1::OnChangeListenbacklogdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[ComPage_ListenBacklog].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[ComPage_ListenBacklog].ulFieldValue = m_spinListenBacklog.GetPos() 
	      * m_binNumericRegistryEntries[ComPage_ListenBacklog].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CCOMPAGE1::SaveInfo()
{

if (m_bIsDirty) {
SaveNumericInfo(m_binNumericRegistryEntries, ComPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\combut1.h ===
// combut1.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCOMBUT1 window

class CCOMBUT1 : public CButton
{
// Construction
public:
	CCOMBUT1();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCOMBUT1)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCOMBUT1();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCOMBUT1)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\compsdef.h ===
// Common Per Service Entry Defines

#ifndef		_Common_Per_Service_Defines
#define		_Common_Per_Service_Defines

#define ENABLESVCLOCNAME		"EnableSvcLoc"
#define DEFAULTENABLESVCLOC		TRUEVALUE

#define LOGANONYMOUSNAME		"LogAnonymous"
#define DEFAULTLOGANONYMOUS		TRUEVALUE

#define LOGNONANONYMOUSNAME		"LogNonAnonymous"
#define DEFAULTLOGNONANONYMOUS	TRUEVALUE

#define CHECKFORWAISDBNAME		"CheckForWAISDB"
#define DEFAULTCHECKFORWAISDB	TRUEVALUE

#define DEBUGFLAGSNAME	"DebugFlags"
#define DEFAULTDEBUGFLAGS	0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\compage1.h ===
// compage1.h : header file
//

//Common Page

#define LOGBATNAME	"LogFileBatchSize"
#define MINLOGFILEBATCHSIZE	0
#define MAXLOGFILEBATCHSIZE	0x7FFF							//Specify in KB
#define DEFAULTLOGFILEBATCHSIZE	(64 * 1024)

#define MEMORYCACHENAME	"MemoryCacheSize"
#define MINMEMORYCACHESIZE	0
#define MAXMEMORYCACHESIZE	(0xFFFFFFFF / (1024 * 1024))	//Specify in MB
#define DEFAULTMEMORYCACHESIZE	(3 * 1024 * 1024)

#define LISTENBACKLOGNAME	"ListenBacklog"
#define MINLISTENBACKLOG	0
#define MAXLISTENBACKLOG	0x7fff
#define DEFAULTLISTENBACKLOG	15

enum  COMMON_NUM_REG_ENTRIES {
     ComPage_LogBat,
	 ComPage_MemCache,
	 ComPage_ListenBacklog,
	 ComPage_TotalNumRegEntries
	 };

/////////////////////////////////////////////////////////////////////////////
// CCOMPAGE1 dialog

class CCOMPAGE1 : public CGenPage
{
	DECLARE_DYNCREATE(CCOMPAGE1)

// Construction
public:
	CCOMPAGE1();
	~CCOMPAGE1();

// Dialog Data
	//{{AFX_DATA(CCOMPAGE1)
	enum { IDD = IDD_COMPAGE1 };
	CSpinButtonCtrl	m_spinListenBacklog;
	CSpinButtonCtrl	m_spinLogBatSpin1;
	CSpinButtonCtrl	m_spinCacheSpin1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCOMPAGE1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);

	//}}AFX_VIRTUAL


// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCOMPAGE1)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeCachedata1();
	afx_msg void OnChangeLogbatdata1();
	afx_msg void OnChangeListenbacklogdata1();
	//}}AFX_MSG
	
	NUM_REG_ENTRY m_binNumericRegistryEntries[ComPage_TotalNumRegEntries];


	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\delscrip.cpp ===
// delscrip.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "delscrip.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDelScript dialog


CDelScript::CDelScript(CWnd* pParent /*=NULL*/)
	: CDialog(CDelScript::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDelScript)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDelScript::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDelScript)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDelScript, CDialog)
	//{{AFX_MSG_MAP(CDelScript)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDelScript message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\delmime.cpp ===
// delmime.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "delmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDelMime dialog


CDelMime::CDelMime(CWnd* pParent /*=NULL*/)
	: CDialog(CDelMime::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDelMime)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDelMime::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDelMime)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDelMime, CDialog)
	//{{AFX_MSG_MAP(CDelMime)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDelMime message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\editscri.cpp ===
// editscri.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "editscri.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditScript dialog

CEditScript::CEditScript(CWnd* pParent, LPCTSTR pchFileExtension, LPCTSTR pchScriptMap)
	: CDialog(CEditScript::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditScript)
	m_strFileExtension = pchFileExtension;
	m_strScriptMap = pchScriptMap;
	//}}AFX_DATA_INIT
}


void CEditScript::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditScript)
	DDX_Text(pDX, IDC_EDITSCRIPTFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_EDITSCRIPTMAPPINGDATA1, m_strScriptMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditScript, CDialog)
	//{{AFX_MSG_MAP(CEditScript)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditScript message handlers
	LPCTSTR CEditScript::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CEditScript::GetScriptMap()
	{
	return (m_strScriptMap);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\dlgdata.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afximpl.h"
#include "afxpriv.h"
#ifdef AFX_CORE3_SEG
#pragma code_seg(AFX_CORE3_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDataExchange member functions (contructor is in wincore.cpp for swap tuning)

HWND CDataExchange::PrepareEditCtrl(int nIDC)
{
	HWND hWndCtrl = PrepareCtrl(nIDC);
	ASSERT(hWndCtrl != NULL);
	m_bEditLastControl = TRUE;
	return hWndCtrl;
}

HWND CDataExchange::PrepareCtrl(int nIDC)
{
	ASSERT(nIDC != 0);
	ASSERT(nIDC != -1); // not allowed
	HWND hWndCtrl = ::GetDlgItem(m_pDlgWnd->m_hWnd, nIDC);
	if (hWndCtrl == NULL)
	{
		TRACE1("Error: no data exchange control with ID 0x%04X.\n", nIDC);
		ASSERT(FALSE);
		AfxThrowNotSupportedException();
	}
	m_hWndLastControl = hWndCtrl;
	m_bEditLastControl = FALSE; // not an edit item by default
	ASSERT(hWndCtrl != NULL);   // never return NULL handle
	return hWndCtrl;
}

void CDataExchange::Fail()
{
	if (!m_bSaveAndValidate)
	{
		TRACE0("Warning: CDataExchange::Fail called when not validating.\n");
		// throw the exception anyway
	}
	else if (m_hWndLastControl != NULL)
	{
		// restore focus and selection to offending field
		::SetFocus(m_hWndLastControl);
		if (m_bEditLastControl) // select edit item
			::SendMessage(m_hWndLastControl, EM_SETSEL, 0, -1);
	}
	else
	{
		TRACE0("Error: fail validation with no control to restore focus to.\n");
		// do nothing more
	}

	AfxThrowUserException();
}

/////////////////////////////////////////////////////////////////////////////
// Notes for implementing dialog data exchange and validation procs:
//  * always start with PrepareCtrl or PrepareEditCtrl
//  * always start with 'pDX->m_bSaveAndValidate' check
//  * pDX->Fail() will throw an exception - so be prepared
//  * avoid creating temporary HWNDs for dialog controls - i.e.
//      use HWNDs for child elements
//  * validation procs should only act if 'm_bSaveAndValidate'
//  * use the suffices:
//      DDX_ = exchange proc
//      DDV_ = validation proc
//
/////////////////////////////////////////////////////////////////////////////

// only supports '%d', '%u', '%ld' and '%lu'
static BOOL AFXAPI AfxSimpleScanf(LPCTSTR lpszText,
	LPCTSTR lpszFormat, va_list pData)
{
	ASSERT(lpszText != NULL);
	ASSERT(lpszFormat != NULL);

	ASSERT(*lpszFormat == '%');
	lpszFormat++;        // skip '%'

	BOOL bLong = FALSE;
	if (*lpszFormat == 'l')
	{
		bLong = TRUE;
		lpszFormat++;
	}

	ASSERT(*lpszFormat == 'd' || *lpszFormat == 'u' || *lpszFormat == 'x');
	ASSERT(lpszFormat[1] == '\0');

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;
	TCHAR chFirst = lpszText[0];
	long l, l2;
	if (*lpszFormat == 'd')
	{
		// signed
		l = _tcstol(lpszText, (LPTSTR*)&lpszText, 10);
		l2 = (int)l;
	}
	else
	if (*lpszFormat == 'u')
	{
		// unsigned
		l = (long)_tcstoul(lpszText, (LPTSTR*)&lpszText, 10);
		l2 = (unsigned int)l;
	}
	else
	{
		// hex
		l = (long)_tcstoul(lpszText, (LPTSTR*)&lpszText, 16);
		l2 = (unsigned int)l;
	}
	if (l == 0 && chFirst != '0')
		return FALSE;   // could not convert

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;
	if (*lpszText != '\0')
		return FALSE;   // not terminated properly

	if (bLong)
		*va_arg(pData, long*) = l;
	else if (l == l2)
		*va_arg(pData, int*) = (int)l;
	else
		return FALSE;       // too big for int

	// all ok
	return TRUE;
}

static void DDX_TextWithFormat(CDataExchange* pDX, int nIDC,
	LPCTSTR lpszFormat, UINT nIDPrompt, ...)

	// only supports windows output formats - no floating point
{
	va_list pData;
	va_start(pData, nIDPrompt);

	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	TCHAR szT[32];
	if (pDX->m_bSaveAndValidate)
	{
		// the following works for %d, %u, %ld, %lu
		::GetWindowText(hWndCtrl, szT, _countof(szT));
		if (!AfxSimpleScanf(szT, lpszFormat, pData))
		{
			AfxMessageBox(nIDPrompt);
			pDX->Fail();        // throws exception
		}
	}
	else
	{
		wvsprintf(szT, lpszFormat, pData);
			// does not support floating point numbers - see dlgfloat.cpp
		AfxSetWindowText(hWndCtrl, szT);
	}

	va_end(pData);
}
/////////////////////////////////////////////////////////////////////////////
// Simple formatting to text item
/*
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, BYTE& value)
{
	int n = (int)value;
	if (pDX->m_bSaveAndValidate)
	{
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, &n);
		if (n > 255)
		{
			AfxMessageBox(AFX_IDP_PARSE_BYTE);
			pDX->Fail();        // throws exception
		}
		value = (BYTE)n;
	}
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, n);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, int& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, UINT& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, long& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DWORD& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		::GetWindowText(hWndCtrl, value.GetBufferSetLength(nLen), nLen+1);
		value.ReleaseBuffer();
	}
	else
	{
		AfxSetWindowText(hWndCtrl, value);
	}
}
*/
void AFXAPI DDX_TexttoHex(CDataExchange* pDX, int nIDC, DWORD& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%lx"), AFX_IDP_PARSE_INT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%lx"), AFX_IDP_PARSE_INT, value);
}



/////////////////////////////////////////////////////////////////////////////
// Data exchange for special control

void AFXAPI DDX_Check(CDataExchange* pDX, int nIDC, int& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		value = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
		ASSERT(value >= 0 && value <= 2);
	}
	else
	{
		if (value < 0 || value > 2)
		{
			value = 0;  // default to off
			TRACE1("Warning: dialog data checkbox value (%d) out of range.\n",
				 value);
		}
		::SendMessage(hWndCtrl, BM_SETCHECK, (WPARAM)value, 0L);
	}
}

void AFXAPI DDX_Radio(CDataExchange* pDX, int nIDC, int& value)
	// must be first in a group of auto radio buttons
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);

	ASSERT(::GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP);
	ASSERT(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON);

	if (pDX->m_bSaveAndValidate)
		value = -1;     // value if none found

	// walk all children in group
	int iButton = 0;
	do
	{
		if (::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON)
		{
			// control in group is a radio button
			if (pDX->m_bSaveAndValidate)
			{
				if (::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L) != 0)
				{
					ASSERT(value == -1);    // only set once
					value = iButton;
				}
			}
			else
			{
				// select button
				::SendMessage(hWndCtrl, BM_SETCHECK, (iButton == value), 0L);
			}
			iButton++;
		}
		else
		{
			TRACE0("Warning: skipping non-radio button in group.\n");
		}
		hWndCtrl = ::GetWindow(hWndCtrl, GW_HWNDNEXT);

	} while (hWndCtrl != NULL &&
		!(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP));
}

/////////////////////////////////////////////////////////////////////////////
// Listboxes, comboboxes

void AFXAPI DDX_LBString(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nIndex = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
		if (nIndex != -1)
		{
			int nLen = (int)::SendMessage(hWndCtrl, LB_GETTEXTLEN, nIndex, 0L);
			::SendMessage(hWndCtrl, LB_GETTEXT, nIndex,
					(LPARAM)(LPVOID)value.GetBufferSetLength(nLen));
		}
		else
		{
			// no selection
			value.Empty();
		}
		value.ReleaseBuffer();
	}
	else
	{
		// set current selection based on data string
		if (::SendMessage(hWndCtrl, LB_SELECTSTRING, (WPARAM)-1,
		  (LPARAM)(LPCTSTR)value) == LB_ERR)
		{
			// no selection match
			TRACE0("Warning: no listbox item selected.\n");
		}
	}
}

void AFXAPI DDX_LBStringExact(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_LBString(pDX, nIDC, value);
	}
	else
	{
		// set current selection based on data string
		int i = (int)::SendMessage(hWndCtrl, LB_FINDSTRINGEXACT, (WPARAM)-1,
		  (LPARAM)(LPCTSTR)value);
		if (i < 0)
		{
			// no selection match
			TRACE0("Warning: no listbox item selected.\n");
		}
		else
		{
			// select it
			SendMessage(hWndCtrl, LB_SETCURSEL, i, 0L);
		}
	}
}

void AFXAPI DDX_CBString(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		// just get current edit item text (or drop list static)
		int nLen = ::GetWindowTextLength(hWndCtrl);
		if (nLen != -1)
		{
			// get known length
			::GetWindowText(hWndCtrl, value.GetBufferSetLength(nLen), nLen+1);
		}
		else
		{
			// for drop lists GetWindowTextLength does not work - assume
			//  max of 255 characters
			::GetWindowText(hWndCtrl, value.GetBuffer(255), 255+1);
		}
		value.ReleaseBuffer();
	}
	else
	{
		// set current selection based on model string
		if (::SendMessage(hWndCtrl, CB_SELECTSTRING, (WPARAM)-1,
			(LPARAM)(LPCTSTR)value) == CB_ERR)
		{
			// just set the edit text (will be ignored if DROPDOWNLIST)
			AfxSetWindowText(hWndCtrl, value);
		}
	}
}

void AFXAPI DDX_CBStringExact(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_CBString(pDX, nIDC, value);
	}
	else
	{
		// set current selection based on data string
		int i = (int)::SendMessage(hWndCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1,
		  (LPARAM)(LPCTSTR)value);
		if (i < 0)
		{
			// no selection match
			TRACE0("Warning: no combobox item selected.\n");
		}
		else
		{
			// select it
			SendMessage(hWndCtrl, CB_SETCURSEL, i, 0L);
		}
	}
}

void AFXAPI DDX_LBIndex(CDataExchange* pDX, int nIDC, int& index)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
		index = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
	else
		::SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM)index, 0L);
}

void AFXAPI DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
		index = (int)::SendMessage(hWndCtrl, CB_GETCURSEL, 0, 0L);
	else
		::SendMessage(hWndCtrl, CB_SETCURSEL, (WPARAM)index, 0L);
}

void AFXAPI DDX_Scroll(CDataExchange* pDX, int nIDC, int& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
		value = GetScrollPos(hWndCtrl, SB_CTL);
	else
		SetScrollPos(hWndCtrl, SB_CTL, value, TRUE);
}
/////////////////////////////////////////////////////////////////////////////
// Range Dialog Data Validation

static void AFXAPI FailMinMaxWithFormat(CDataExchange* pDX,
	 long minVal, long maxVal, LPCTSTR lpszFormat, UINT nIDPrompt)
	// error string must have '%1' and '%2' strings for min and max values
	// wsprintf formatting uses long values (format should be '%ld' or '%lu')
{
	ASSERT(lpszFormat != NULL);

	if (!pDX->m_bSaveAndValidate)
	{
		TRACE0("Warning: initial dialog data is out of range.\n");
		return;     // don't stop now
	}
	TCHAR szMin[32];
	TCHAR szMax[32];
	wsprintf(szMin, lpszFormat, minVal);
	wsprintf(szMax, lpszFormat, maxVal);
	CString prompt;
	AfxFormatString2(prompt, nIDPrompt, szMin, szMax);
	AfxMessageBox(prompt, MB_ICONEXCLAMATION, nIDPrompt);
	prompt.Empty(); // exception prep
	pDX->Fail();
}

//NOTE: don't use overloaded function names to avoid type ambiguities
void AFXAPI DDV_MinMaxByte(CDataExchange* pDX, BYTE value, BYTE minVal, BYTE maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%u"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxInt(CDataExchange* pDX, int value, int minVal, int maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%ld"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxLong(CDataExchange* pDX, long value, long minVal, long maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%ld"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxUInt(CDataExchange* pDX, UINT value, UINT minVal, UINT maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%lu"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxDWord(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%lu"),
			AFX_IDP_PARSE_INT_RANGE);
}

/////////////////////////////////////////////////////////////////////////////
// Max Chars Dialog Data Validation

void AFXAPI DDV_MaxChars(CDataExchange* pDX, CString const& value, int nChars)
{
	ASSERT(nChars >= 1);        // allow them something
	if (pDX->m_bSaveAndValidate && value.GetLength() > nChars)
	{
		TCHAR szT[32];
		wsprintf(szT, _T("%d"), nChars);
		CString prompt;
		AfxFormatString1(prompt, AFX_IDP_PARSE_STRING_SIZE, szT);
		AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_STRING_SIZE);
		prompt.Empty(); // exception prep
		pDX->Fail();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special DDX_ proc for subclassing controls

void AFXAPI DDX_Control(CDataExchange* pDX, int nIDC, CWnd& rControl)
{
	if (rControl.m_hWnd == NULL)    // not subclassed yet
	{
		ASSERT(!pDX->m_bSaveAndValidate);
		HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
		if (!rControl.SubclassWindow(hWndCtrl))
		{
			ASSERT(FALSE);      // possibly trying to subclass twice?
			AfxThrowNotSupportedException();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\delmime.h ===
// delmime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDelMime dialog

class CDelMime : public CDialog
{
// Construction
public:
	CDelMime(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDelMime)
	enum { IDD = IDD_DELMIMEDIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDelMime)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDelMime)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\delscrip.h ===
// delscrip.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDelScript dialog

class CDelScript : public CDialog
{
// Construction
public:
	CDelScript(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDelScript)
	enum { IDD = IDD_DELSCRIPTDIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDelScript)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDelScript)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\editmime.cpp ===
// editmime.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "editmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditMime dialog


CEditMime::CEditMime(CWnd* pParent, /*=NULL*/
      LPCTSTR pchFileExtension,
      LPCTSTR pchMimeType,
      LPCTSTR pchImageFile,
      LPCTSTR pchGopherType
	  )
	: CDialog(CEditMime::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditMime)
	m_strFileExtension = pchFileExtension;
	m_strMimeType = pchMimeType;
	m_strImageFile = pchImageFile;
	m_strGopherType = pchGopherType;
	//}}AFX_DATA_INIT
}


void CEditMime::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditMime)
	DDX_Text(pDX, IDC_EDITMIMEFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_EDITMIMEGOPHERTYPEDATA1, m_strGopherType);
	DDX_Text(pDX, IDC_EDITMIMEIMAGEFILEDATA1, m_strImageFile);
	DDX_Text(pDX, IDC_EDITMIMEMIMETYPEDATA1, m_strMimeType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditMime, CDialog)
	//{{AFX_MSG_MAP(CEditMime)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditMime message handlers

void CEditMime::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////
// Other Public Functions

	LPCTSTR CEditMime::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CEditMime::GetGopherType()
	{
	return (m_strGopherType);
	}

	LPCTSTR CEditMime::GetImageFile()
	{
	return (m_strImageFile);
	}

	LPCTSTR CEditMime::GetMimeType()
	{
	return (m_strMimeType);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\editscri.h ===
// editscri.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditScript dialog

class CEditScript : public CDialog
{
// Construction
public:
	CEditScript(CWnd* pParent, LPCTSTR pchFileExtension, LPCTSTR pchScriptMap);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditScript)
	enum { IDD = IDD_EDITSCRIPTDIALOG };
	CString	m_strFileExtension;
	CString	m_strScriptMap;
	//}}AFX_DATA
  	LPCTSTR GetFileExtension();
	LPCTSTR GetScriptMap();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditScript)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditScript)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\formvw1.cpp ===
// formvw1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "formvw1.h"
#include "mimemap1.h"
#include "scrmap1.h"
#include "ssl1.h"

#include "gensheet.h"
#include "compage1.h"
#include "advcom1.h"
#include "ftpgenp1.h"
#include "ftpadvp1.h"
#include "gopgenp1.h"
#include "gopadvp1.h"
#include "webgenp1.h"
#include "webadvp1.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFormVw1

IMPLEMENT_DYNCREATE(CFormVw1, CFormView)

CFormVw1::CFormVw1()
	: CFormView(CFormVw1::IDD)
{
	TCHAR	strTempComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD   ulTempComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
	if (GetComputerName(strTempComputerName, &ulTempComputerNameLen))
	  m_strMachineNameData1 = strTempComputerName;
	else
	  m_strMachineNameData1 = (TCHAR *) NULL;
	
	m_buttonFTPSettings.LoadBitmaps(IDB_FTPUPBITMAP, IDB_FTPDOWNBITMAP);
	m_buttonGopherSettings.LoadBitmaps(IDB_GOPHERUPBITMAP,IDB_GOPHERDOWNBITMAP);
	m_buttonWebSettings.LoadBitmaps(IDB_WEBUPBITMAP,IDB_WEBDOWNBITMAP);

#if 0
	//{{AFX_DATA_INIT(CFormVw1)
	m_strMachineNameData1 = _T("");
	//}}AFX_DATA_INIT
#endif
}

CFormVw1::~CFormVw1()
{
}

void CFormVw1::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormVw1)
	DDX_Control(pDX, IDC_WWWSET4, m_buttonWebSettings);
	DDX_Control(pDX, IDC_GOPHSET1, m_buttonGopherSettings);
	DDX_Control(pDX, IDC_FTPSET1, m_buttonFTPSettings);
	DDX_Text(pDX, IDC_MACHINENAMEDATA1, m_strMachineNameData1);
	DDV_MaxChars(pDX, m_strMachineNameData1, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFormVw1, CFormView)
	//{{AFX_MSG_MAP(CFormVw1)
	ON_BN_CLICKED(IDC_WWWSET4, OnWwwset4)
	ON_BN_CLICKED(IDC_COMSET1, OnComset1)
	ON_BN_CLICKED(IDC_FTPSET1, OnFtpset1)
	ON_BN_CLICKED(IDC_GOPHSET1, OnGophset1)
	ON_WM_CTLCOLOR()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFormVw1 diagnostics

#ifdef _DEBUG
void CFormVw1::AssertValid() const
{
	CFormView::AssertValid();
}

void CFormVw1::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFormVw1 message handlers


void CFormVw1::OnWwwset4()
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	CRegKey rkWebSet(HKEY_LOCAL_MACHINE, _T(WEB_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkWebSet != NULL) {


       CGENSHEET s(_T("Web Settings"));

	   CWEBGENP1 WebPage;

	   WebPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&WebPage);

	   ScrMap1 ScriptPage;

	   ScriptPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&ScriptPage);

	   SSL1 SSLPage;

	   SSLPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&SSLPage);
		
	   CWEBADVP1 WebAdvPage;

	   WebAdvPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&WebAdvPage);


	   if (s.DoModal() == IDOK)
	      s.SavePageData();

	}
	else {
	   CString strWebErrMsg(_T(""));
	   AfxFormatString1(strWebErrMsg, IDS_WEBOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strWebErrMsg);
	}
	
}

void CFormVw1::OnComset1()
{
	// TODO: Add your control notification handler code here

	UpdateData(TRUE);
	CRegKey rkComSet(HKEY_LOCAL_MACHINE, _T(COMMON_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkComSet != NULL) {

       CGENSHEET s(_T("Common Settings"));

	   CCOMPAGE1 ComPage;

	   ComPage.m_rkMainKey = &rkComSet;

	   s.AddPage(&ComPage);
	
//	   CRegKey rkMimeKey(rkComSet,_T("MimeMap"),REGISTRY_ACCESS_RIGHTS);

//	   if (rkMimeKey != NULL) {

	      MIMEMAP1 MimePage;
	
//	      MimePage.m_rkMimeKey = &rkMimeKey;
	
	      MimePage.m_rkMainKey = &rkComSet;

	      s.AddPage(&MimePage);

//	   }
	
	   CADVCOM1 ComAdvPage;

	   ComAdvPage.m_rkMainKey = &rkComSet;

	   s.AddPage(&ComAdvPage);

	   if (s.DoModal() == IDOK)
	      s.SavePageData();
	}
	else {
	   CString strComErrMsg(_T(""));
	   AfxFormatString1(strComErrMsg, IDS_COMOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strComErrMsg);
	}
	
}

void CFormVw1::OnFtpset1()
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	CRegKey rkFtpSet(HKEY_LOCAL_MACHINE, _T(FTP_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkFtpSet != NULL) {

	
       CGENSHEET s(_T("FTP Settings"));

	   CFTPGENP1 FTPPage;
	
	   FTPPage.m_rkMainKey = &rkFtpSet;

	   s.AddPage(&FTPPage);

	   CFTPADVP1 FTPAdvPage;

	   FTPAdvPage.m_rkMainKey = &rkFtpSet;

	   s.AddPage(&FTPAdvPage);

	   if (s.DoModal() == IDOK)
	      s.SavePageData();

	}
	else {
	   CString strWebErrMsg(_T(""));
	   AfxFormatString1(strWebErrMsg, IDS_FTPOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strWebErrMsg);
	}

}

void CFormVw1::OnGophset1()
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	CRegKey rkGopSet(HKEY_LOCAL_MACHINE, _T(GOPHER_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkGopSet != NULL) {


       CGENSHEET s(_T("Gopher Settings"));

	   CGOPGENP1 GopherPage;

	   GopherPage.m_rkMainKey = &rkGopSet;

	   s.AddPage(&GopherPage);	

	   CGOPADVP1 GopherAdvPage;

	   GopherAdvPage.m_rkMainKey = &rkGopSet;

	   s.AddPage(&GopherAdvPage);

	   if (s.DoModal() == IDOK)
	      s.SavePageData();

	}
	else {
	   CString strGopErrMsg(_T(""));
	   AfxFormatString1(strGopErrMsg, IDS_GOPOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strGopErrMsg);
	}
	
}


HBRUSH CFormVw1::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
/*	if (pWnd->GetDlgCtrlID() == IDC_FTPSET1) {
		  pDC->SetBkColor(RGB(255,255,255));
          return((HBRUSH)::GetStockObject(WHITE_BRUSH));
	   }
*/	
	if (nCtlColor == CTLCOLOR_STATIC) {
	   if (pWnd->GetDlgCtrlID() == IDC_MAINGROUP) {
		  pDC->SetBkColor(RGB(255,255,255));
          return((HBRUSH)::GetStockObject(WHITE_BRUSH));
	   }
	}
	else if (nCtlColor == CTLCOLOR_BTN) {
	   int iTempDlgCtrlID = pWnd->GetDlgCtrlID();
	   if ((iTempDlgCtrlID == IDC_FTPSET1) || (iTempDlgCtrlID == IDC_GOPHSET1)
	      || (iTempDlgCtrlID == IDC_WWWSET4)) {
		  pDC->SetBkColor(RGB(255,255,255));
          return((HBRUSH)::GetStockObject(WHITE_BRUSH));
	   }
	}

	HBRUSH hbr = CFormView::OnCtlColor(pDC, pWnd, nCtlColor);
	
	// TODO: Change any attributes of the DC here
	
	// TODO: Return a different brush if the default is not desired
	return hbr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\editmime.h ===
// editmime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditMime dialog

class CEditMime : public CDialog
{
// Construction
public:
	CEditMime(CWnd* pParent,
      LPCTSTR pchFileExtension,
      LPCTSTR pchMimeType,
      LPCTSTR pchImageFile,
      LPCTSTR pchGopherType
      );   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditMime)
	enum { IDD = IDD_EDITMIMEMAPDIALOG };
	CString	m_strFileExtension;
	CString	m_strGopherType;
	CString	m_strImageFile;
	CString	m_strMimeType;
	//}}AFX_DATA

  	LPCTSTR GetFileExtension();
	LPCTSTR GetGopherType();
	LPCTSTR GetImageFile();
	LPCTSTR GetMimeType();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditMime)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditMime)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\formvw1.h ===
// formvw1.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFormVw1 form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFormVw1 : public CFormView
{
protected:
	CFormVw1();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFormVw1)

// Form Data
public:
	//{{AFX_DATA(CFormVw1)
	enum { IDD = IDD_FORMVIEW1 };
	CBitmapButton	m_buttonWebSettings;
	CBitmapButton	m_buttonGopherSettings;
	CBitmapButton	m_buttonFTPSettings;
	CString	m_strMachineNameData1;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFormVw1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFormVw1();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	// Generated message map functions
	//{{AFX_MSG(CFormVw1)
	afx_msg void OnWwwset4();
	afx_msg void OnComset1();
	afx_msg void OnFtpset1();
	afx_msg void OnGophset1();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\ftpadvp1.cpp ===
// ftpadvp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "ftpadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFTPADVP1 dialog

IMPLEMENT_DYNCREATE(CFTPADVP1, CGenPage)


CFTPADVP1::CFTPADVP1()	: CGenPage(CFTPADVP1::IDD)
{
	//{{AFX_DATA_INIT(CFTPADVP1)
	//}}AFX_DATA_INIT
}

CFTPADVP1::~CFTPADVP1()
{
}

void CFTPADVP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFTPADVP1)
	DDX_Control(pDX, IDC_FTPDBGFLAGSDATA1, m_editFTPDbgFlags);
	DDX_TexttoHex(pDX, IDC_FTPDBGFLAGSDATA1, m_ulFTPDbgFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFTPADVP1, CGenPage)
	//{{AFX_MSG_MAP(CFTPADVP1)
	ON_EN_CHANGE(IDC_FTPDBGFLAGSDATA1, OnChangeFtpdbgflagsdata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFTPADVP1 message handlers

BOOL CFTPADVP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	for (i = 0; i < AdvFTPPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
 	m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;

	for (i = 0; i < AdvFTPPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
   	m_editFTPDbgFlags.LimitText(8);
	m_ulFTPDbgFlags = m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFTPADVP1::OnChangeFtpdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CFTPADVP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].ulFieldValue = m_ulFTPDbgFlags;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvFTPPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\genpage.cpp ===
// genpage.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "genpage.h"

#include "afximpl.h"
#include "afxpriv.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenPage property page

IMPLEMENT_DYNAMIC(CGenPage, CPropertyPage)

//CGenPage::CGenPage() : CPropertyPage(CGenPage::IDD)
CGenPage::CGenPage(UINT nIDTemplate, UINT nIDCaption):CPropertyPage( nIDTemplate, nIDCaption )
{
	m_bSetChanged = FALSE;	//Do not mark vaues as changed during initialization
	m_bIsDirty = FALSE;
};
CGenPage::CGenPage(LPCTSTR lpszTemplateName, UINT nIDCaption): CPropertyPage(lpszTemplateName, nIDCaption)
{ 	
m_bSetChanged = FALSE;	//Do not mark vaues as changed during initialization
m_bIsDirty = FALSE;
};


CGenPage::~CGenPage()
{
}

void CGenPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGenPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGenPage, CPropertyPage)
	//{{AFX_MSG_MAP(CGenPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGenPage message handlers

void CGenPage::SaveInfo()
{
if (m_bIsDirty) {
   m_bIsDirty = FALSE;
   SetModified(FALSE);
}
}

void CGenPage::SaveNumericInfo(PNUM_REG_ENTRY lpbinNumEntries, int iNumEntries)
{
int i;
for (i = 0; i < iNumEntries; i++) {
   if (lpbinNumEntries[i].bIsChanged) {
      lpbinNumEntries[i].bIsChanged = FALSE;
      m_rkMainKey->SetValue(lpbinNumEntries[i].strFieldName, lpbinNumEntries[i].ulFieldValue);
   }
}
}

void CGenPage::SaveStringInfo(PSTRING_REG_ENTRY lpbinStringEntries, int iStringEntries)
{
int i;
for (i = 0; i < iStringEntries; i++) {
   if (lpbinStringEntries[i].bIsChanged) {
      lpbinStringEntries[i].bIsChanged = FALSE;
      m_rkMainKey->SetValue(lpbinStringEntries[i].strFieldName, lpbinStringEntries[i].strFieldValue);
   }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\ftpgenp1.h ===
// ftpgenp1.h : header file
//

#define ENABLEPORTATTACKNAME	"EnablePortAttack"
#define DEFAULTENABLEPORTATTACK	FALSEVALUE

#define ALLOWGUESTACCESSNAME	"AllowGuestAccess"
#define DEFAULTALLOWGUESTACCESS	TRUEVALUE

#define ANNOTATEDIRECTORIESNAME	"AnnotateDirectories"
#define DEFAULTANNOTATEDIRECTORIES	FALSEVALUE

#define MSDOSDIROUTPUTNAME	"MsdosDirOutput"
#define DEFAULTMSDOSDIROUTPUT	TRUEVALUE

#define LOWERCASEFILESNAME	"LowercaseFiles"
#define DEFAULTLOWERCASEFILES	FALSEVALUE



enum  FTP_NUM_REG_ENTRIES {
     FTPPage_EnableSvcLoc,
	 FTPPage_LogAnonymous,
	 FTPPage_LogNonAnonymous,
	 FTPPage_EnablePortAttack,
	 FTPPage_AllowGuestAccess,
	 FTPPage_AnnotateDirectories,
	 FTPPage_MsdosDirOutput,
	 FTPPage_LowercaseFiles,
	 FTPPage_TotalNumRegEntries
	 };



/////////////////////////////////////////////////////////////////////////////
// CFTPGENP1 dialog

class CFTPGENP1 : public CGenPage
{
	DECLARE_DYNCREATE(CFTPGENP1)

// Construction
public:
	CFTPGENP1();
	~CFTPGENP1();

// Dialog Data
	//{{AFX_DATA(CFTPGENP1)
	enum { IDD = IDD_FTPPAGE1 };
	CButton	m_cboxLowercaseFiles;
	CButton	m_cboxMsdosDirOutput;
	CButton	m_cboxEnPortAttack;
	CButton	m_cboxAnnotateDirectories;
	CButton	m_cboxAllowGuestAccess;
	CButton	m_cboxLogNonAnon;
	CButton	m_cboxLogAnon;
	CButton	m_cboxEnSvcLoc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFTPGENP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFTPGENP1)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnportattackdata1();
	afx_msg void OnEnsvclocdata1();
	afx_msg void OnLoganondata1();
	afx_msg void OnLognonanondata1();
	afx_msg void OnAllowguestaccessdata1();
	afx_msg void OnAnnotatedirectoriesdata1();
	afx_msg void OnLowercasefilesdata1();
	afx_msg void OnMsdosdiroutput();
	//}}AFX_MSG

	NUM_REG_ENTRY m_binNumericRegistryEntries[FTPPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\genpage.h ===
// genpage.h : header file
//

#ifndef _GEN_PAGE_
#define _GEN_PAGE_

#include "compsdef.h"

enum YES_NO_ENTRIES {
YESNO_NO,
YESNO_YES
};

// These are checkbox states
#define	CHECKEDVALUE	1
#define UNCHECKEDVALUE	0

// These are our true/false values for the registry
#define TRUEVALUE		1
#define FALSEVALUE		0

// Since TRUEVALUE = CHECKEDVALUE and FALSEVALUE = UNCHECKEDVALUE, we don't really need this.
// This avoids dependency on that correlation
#define GETREGVALUEFROMCHECKBOX(p)	((p) == UNCHECKEDVALUE) ? FALSEVALUE : TRUEVALUE
	
#define GETCHECKBOXVALUEFROMREG(p)	((p) == FALSEVALUE) ? UNCHECKEDVALUE : CHECKEDVALUE
	

// Data Structure for numeric registry entries, all pages

typedef struct _NUM_REG_ENTRY {
   LPTSTR	strFieldName;
   DWORD	ulFieldValue;
   DWORD	ulMultipleFactor; 		//for entries where the use specifies MB, KB, minutes, etc.
   DWORD	ulDefaultValue;
   BOOL		bIsChanged;
   } NUM_REG_ENTRY, *PNUM_REG_ENTRY;

typedef struct _STRING_REG_ENTRY {
   LPTSTR	strFieldName;
   CString	strFieldValue;		
   CString	strDefaultValue;		
   BOOL		bIsChanged;
   } STRING_REG_ENTRY, *PSTRING_REG_ENTRY;

void AFXAPI DDX_TexttoHex(CDataExchange* pDX, int nIDC, DWORD& value);

/////////////////////////////////////////////////////////////////////////////
// CGenPage dialog

class CGenPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CGenPage)

// Construction
public:
	CGenPage(UINT nIDTemplate, UINT nIDCaption = 0);
	CGenPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);
	~CGenPage();
// Dialog Data
	//{{AFX_DATA(CGenPage)
//	enum { IDD = _UNKNOWN_RESOURCE_ID_ };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

    /* PURE */ virtual void SaveInfo(void);

	CRegKey *m_rkMainKey;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGenPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	
	BOOL m_bIsDirty;
	BOOL m_bSetChanged;

	void SaveNumericInfo(PNUM_REG_ENTRY lpbinNumEntries, int iNumEntries);
	void SaveStringInfo(PSTRING_REG_ENTRY lpbinStringEntries, int iStringEntries);

	DECLARE_MESSAGE_MAP()

};

#endif  //_GEN_PAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\ftpgenp1.cpp ===
// ftpgenp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "compsdef.h"
#include "ftpgenp1.h"
#include "ftpadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFTPGENP1 property page

IMPLEMENT_DYNCREATE(CFTPGENP1, CGenPage)

CFTPGENP1::CFTPGENP1() : CGenPage(CFTPGENP1::IDD)
{
	//{{AFX_DATA_INIT(CFTPGENP1)
	//}}AFX_DATA_INIT
}

CFTPGENP1::~CFTPGENP1()
{
}

void CFTPGENP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFTPGENP1)
	DDX_Control(pDX, IDC_LOWERCASEFILESDATA1, m_cboxLowercaseFiles);
	DDX_Control(pDX, IDC_MSDOSDIROUTPUT, m_cboxMsdosDirOutput);
	DDX_Control(pDX, IDC_ENPORTATTACKDATA1, m_cboxEnPortAttack);
	DDX_Control(pDX, IDC_ANNOTATEDIRECTORIESDATA1, m_cboxAnnotateDirectories);
	DDX_Control(pDX, IDC_ALLOWGUESTACCESSDATA1, m_cboxAllowGuestAccess);
	DDX_Control(pDX, IDC_LOGNONANONDATA1, m_cboxLogNonAnon);
	DDX_Control(pDX, IDC_LOGANONDATA1, m_cboxLogAnon);
	DDX_Control(pDX, IDC_ENSVCLOCDATA1, m_cboxEnSvcLoc);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFTPGENP1, CGenPage)
	//{{AFX_MSG_MAP(CFTPGENP1)
	ON_BN_CLICKED(IDC_ENPORTATTACKDATA1, OnEnportattackdata1)
	ON_BN_CLICKED(IDC_ENSVCLOCDATA1, OnEnsvclocdata1)
	ON_BN_CLICKED(IDC_LOGANONDATA1, OnLoganondata1)
	ON_BN_CLICKED(IDC_LOGNONANONDATA1, OnLognonanondata1)
	ON_BN_CLICKED(IDC_ALLOWGUESTACCESSDATA1, OnAllowguestaccessdata1)
	ON_BN_CLICKED(IDC_ANNOTATEDIRECTORIESDATA1, OnAnnotatedirectoriesdata1)
	ON_BN_CLICKED(IDC_LOWERCASEFILESDATA1, OnLowercasefilesdata1)
	ON_BN_CLICKED(IDC_MSDOSDIROUTPUT, OnMsdosdiroutput)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFTPGENP1 message handlers

BOOL CFTPGENP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here

	for (i = 0; i < FTPPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].strFieldName = _T(ENABLESVCLOCNAME);	
	m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].ulDefaultValue = DEFAULTENABLESVCLOC;

	m_binNumericRegistryEntries[FTPPage_LogAnonymous].strFieldName = _T(LOGANONYMOUSNAME);	
	m_binNumericRegistryEntries[FTPPage_LogAnonymous].ulDefaultValue = DEFAULTLOGANONYMOUS;

	m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].strFieldName = _T(LOGNONANONYMOUSNAME);	
	m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].ulDefaultValue = DEFAULTLOGNONANONYMOUS;

	m_binNumericRegistryEntries[FTPPage_EnablePortAttack].strFieldName = _T(ENABLEPORTATTACKNAME);	
	m_binNumericRegistryEntries[FTPPage_EnablePortAttack].ulDefaultValue = DEFAULTENABLEPORTATTACK;

	m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].strFieldName = _T(ALLOWGUESTACCESSNAME);	
	m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].ulDefaultValue = DEFAULTALLOWGUESTACCESS;

	m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].strFieldName = _T(ANNOTATEDIRECTORIESNAME);	
	m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].ulDefaultValue = DEFAULTANNOTATEDIRECTORIES;

	m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].strFieldName = _T(MSDOSDIROUTPUTNAME);	
	m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].ulDefaultValue = DEFAULTMSDOSDIROUTPUT;

	m_binNumericRegistryEntries[FTPPage_LowercaseFiles].strFieldName = _T(LOWERCASEFILESNAME);	
	m_binNumericRegistryEntries[FTPPage_LowercaseFiles].ulDefaultValue = DEFAULTLOWERCASEFILES;

	for (i = 0; i < FTPPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}

	m_cboxEnSvcLoc.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].ulFieldValue));

	m_cboxLogAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_LogAnonymous].ulFieldValue));

	m_cboxLogNonAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].ulFieldValue));

	m_cboxEnPortAttack.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_EnablePortAttack].ulFieldValue));

	m_cboxAllowGuestAccess.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].ulFieldValue));

	m_cboxAnnotateDirectories.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].ulFieldValue));

	m_cboxMsdosDirOutput.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].ulFieldValue));

	m_cboxLowercaseFiles.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_LowercaseFiles].ulFieldValue));

   	m_bSetChanged = TRUE;	// Any more changes come from the user
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CFTPGENP1::OnEnportattackdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_EnablePortAttack].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_EnablePortAttack].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnPortAttack.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnEnsvclocdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnSvcLoc.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnLoganondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_LogAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_LogAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CFTPGENP1::OnLognonanondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogNonAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnAllowguestaccessdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxAllowGuestAccess.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnAnnotatedirectoriesdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxAnnotateDirectories.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnMsdosdiroutput() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxMsdosDirOutput.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CFTPGENP1::OnLowercasefilesdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_LowercaseFiles].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_LowercaseFiles].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLowercaseFiles.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::SaveInfo()
{

if (m_bIsDirty) {
SaveNumericInfo(m_binNumericRegistryEntries, FTPPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\gopadvp1.cpp ===
// gopadvp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "gopadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGOPADVP1 dialog

IMPLEMENT_DYNCREATE(CGOPADVP1, CGenPage)

CGOPADVP1::CGOPADVP1(): CGenPage(CGOPADVP1::IDD)
{
	//{{AFX_DATA_INIT(CGOPADVP1)
	m_ulGopDbgFlags = 0;
	//}}AFX_DATA_INIT
}

CGOPADVP1::~CGOPADVP1()
{
}

void CGOPADVP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGOPADVP1)
	DDX_Control(pDX, IDC_GOPDBGFLAGSDATA1, m_editGopDbgFlags);
	DDX_TexttoHex(pDX, IDC_GOPDBGFLAGSDATA1, m_ulGopDbgFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGOPADVP1, CGenPage)
	//{{AFX_MSG_MAP(CGOPADVP1)
	ON_EN_CHANGE(IDC_GOPDBGFLAGSDATA1, OnChangeGopdbgflagsdata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGOPADVP1 message handlers

BOOL CGOPADVP1::OnInitDialog() 
{
	CGenPage::OnInitDialog();

	int i;
	// TODO: Add extra initialization here
	for (i = 0; i < AdvGopPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
 	m_binNumericRegistryEntries[AdvGopPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvGopPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;

	for (i = 0; i < AdvGopPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
   	m_editGopDbgFlags.LimitText(8);
	m_ulGopDbgFlags = m_binNumericRegistryEntries[AdvGopPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGOPADVP1::OnChangeGopdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvGopPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CGOPADVP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvGopPage_DebugFlags].ulFieldValue = m_ulGopDbgFlags;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvGopPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\ftpadvp1.h ===
// ftpadvp1.h : header file
//

enum ADV_FTP_NUM_REG_ENTRIES {
	 AdvFTPPage_DebugFlags,
	 AdvFTPPage_TotalNumRegEntries
	 };



/////////////////////////////////////////////////////////////////////////////
// CFTPADVP1 dialog

class CFTPADVP1 : public CGenPage
{
    DECLARE_DYNCREATE(CFTPADVP1)
// Construction
public:
	CFTPADVP1();
	~CFTPADVP1();

// Dialog Data
	//{{AFX_DATA(CFTPADVP1)
	enum { IDD = IDD_FTPADVPAGE1 };
	CEdit	m_editFTPDbgFlags;
	DWORD	m_ulFTPDbgFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFTPADVP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFTPADVP1)
	afx_msg void OnChangeFtpdbgflagsdata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvFTPPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\gensheet.h ===
// gensheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGENSHEET

#ifndef _GEN_SHEET_
#define _GEN_SHEET_


class CGENSHEET : public CPropertySheet
{
	DECLARE_DYNAMIC(CGENSHEET)

// Construction
public:
	CGENSHEET(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CGENSHEET(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGENSHEET) 
	//}}AFX_VIRTUAL

afx_msg void CGENSHEET::OnApplyNow ();
void SavePageData(void);
// Implementation
public:
	virtual ~CGENSHEET();

	// Generated message map functions
protected:
	//{{AFX_MSG(CGENSHEET)
	afx_msg void OnHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\gensheet.cpp ===
// gensheet.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "gensheet.h"
#include "genpage.h"

#include "compage1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGENSHEET

IMPLEMENT_DYNAMIC(CGENSHEET, CPropertySheet)

CGENSHEET::CGENSHEET(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CGENSHEET::CGENSHEET(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CGENSHEET::~CGENSHEET()
{
}


BEGIN_MESSAGE_MAP(CGENSHEET, CPropertySheet)
	//{{AFX_MSG_MAP(CGENSHEET)
	ON_BN_CLICKED (ID_APPLY_NOW, OnApplyNow)
	ON_COMMAND(ID_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGENSHEET message handlers

  void CGENSHEET::OnApplyNow ()
  {	
    if (GetActivePage ()->UpdateData (TRUE))
	   SavePageData();
  }


void CGENSHEET::SavePageData ()
  {	
    CGenPage * pPage = NULL;

    for (int i = 0; i < GetPageCount(); ++i)
    {
        pPage = (CGenPage *)GetPage(i);
        ASSERT(pPage != NULL);
        //
        // Update the data in each page and save
        //
        pPage->SaveInfo();
	}
  }




void CGENSHEET::OnHelp() 
{
	// TODO: Add your command handler code here
AfxGetApp()->WinHelp(0x20080);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\gopgenp1.cpp ===
// gopgenp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "compsdef.h"
#include "gopgenp1.h"
#include "gopadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGOPGENP1 property page

IMPLEMENT_DYNCREATE(CGOPGENP1, CGenPage)

CGOPGENP1::CGOPGENP1() : CGenPage(CGOPGENP1::IDD)
{
	//{{AFX_DATA_INIT(CGOPGENP1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CGOPGENP1::~CGOPGENP1()
{
}

void CGOPGENP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGOPGENP1)
	DDX_Control(pDX, IDC_LOGANONDATA1, m_cboxLogAnon);
	DDX_Control(pDX, IDC_ENWAISDATA1, m_cboxEnWais);
	DDX_Control(pDX, IDC_ENSVCLOCDATA1, m_cboxEnSvcLoc);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGOPGENP1, CGenPage)
	//{{AFX_MSG_MAP(CGOPGENP1)
	ON_BN_CLICKED(IDC_ENSVCLOCDATA1, OnEnsvclocdata1)
	ON_BN_CLICKED(IDC_ENWAISDATA1, OnEnwaisdata1)
	ON_BN_CLICKED(IDC_LOGANONDATA1, OnLoganondata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGOPGENP1 message handlers

BOOL CGOPGENP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here

	for (i = 0; i < GopPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	m_binNumericRegistryEntries[GopPage_EnableSvcLoc].strFieldName = _T(ENABLESVCLOCNAME);	
	m_binNumericRegistryEntries[GopPage_EnableSvcLoc].ulDefaultValue = DEFAULTENABLESVCLOC;

	m_binNumericRegistryEntries[GopPage_LogAnonymous].strFieldName = _T(LOGANONYMOUSNAME);	
	m_binNumericRegistryEntries[GopPage_LogAnonymous].ulDefaultValue = DEFAULTLOGANONYMOUS;

	m_binNumericRegistryEntries[GopPage_CheckForWAISDB].strFieldName = _T(CHECKFORWAISDBNAME);	
	m_binNumericRegistryEntries[GopPage_CheckForWAISDB].ulDefaultValue = DEFAULTCHECKFORWAISDB;

	for (i = 0; i < GopPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}

	m_cboxEnSvcLoc.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[GopPage_EnableSvcLoc].ulFieldValue));

	m_cboxLogAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[GopPage_LogAnonymous].ulFieldValue));
	
	m_cboxEnWais.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[GopPage_CheckForWAISDB].ulFieldValue));
	
   	m_bSetChanged = TRUE;	// Any more changes come from the user
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGOPGENP1::OnEnsvclocdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[GopPage_EnableSvcLoc].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[GopPage_EnableSvcLoc].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnSvcLoc.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CGOPGENP1::OnEnwaisdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[GopPage_CheckForWAISDB].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[GopPage_CheckForWAISDB].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnWais.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CGOPGENP1::OnLoganondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[GopPage_LogAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[GopPage_LogAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CGOPGENP1::SaveInfo()
{

if (m_bIsDirty) {
SaveNumericInfo(m_binNumericRegistryEntries, GopPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\gopgenp1.h ===
// gopgenp1.h : header file
//

enum  Gop_NUM_REG_ENTRIES {
     GopPage_EnableSvcLoc,
	 GopPage_LogAnonymous,
	 GopPage_CheckForWAISDB,
	 GopPage_TotalNumRegEntries
	 };




/////////////////////////////////////////////////////////////////////////////
// CGOPGENP1 dialog

class CGOPGENP1 : public CGenPage
{
	DECLARE_DYNCREATE(CGOPGENP1)

// Construction
public:
	CGOPGENP1();
	~CGOPGENP1();

// Dialog Data
	//{{AFX_DATA(CGOPGENP1)
	enum { IDD = IDD_GOPHERGENPAGE1 };
	CButton	m_cboxLogAnon;
	CButton	m_cboxEnWais;
	CButton	m_cboxEnSvcLoc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGOPGENP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGOPGENP1)
	afx_msg void OnEnsvclocdata1();
	afx_msg void OnEnwaisdata1();
	afx_msg void OnLoganondata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	NUM_REG_ENTRY m_binNumericRegistryEntries[GopPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\gopadvp1.h ===
// gopadvp1.h : header file
//

enum ADV_GOP_NUM_REG_ENTRIES {
	 AdvGopPage_DebugFlags,
	 AdvGopPage_TotalNumRegEntries
	 };

/////////////////////////////////////////////////////////////////////////////
// CGOPADVP1 dialog

class CGOPADVP1 : public CGenPage
{ 	
DECLARE_DYNCREATE(CGOPADVP1)

// Construction
public:
	CGOPADVP1();
	~CGOPADVP1();

// Dialog Data
	//{{AFX_DATA(CGOPADVP1)
	enum { IDD = IDD_GOPADVPAGE1 };
	CEdit	m_editGopDbgFlags;
	DWORD	m_ulGopDbgFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGOPADVP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGOPADVP1)
	afx_msg void OnChangeGopdbgflagsdata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvGopPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\isadmdoc.cpp ===
// ISAdmdoc.cpp : implementation of the CISAdminDoc class
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "ISAdmdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc

IMPLEMENT_DYNCREATE(CISAdminDoc, CDocument)

BEGIN_MESSAGE_MAP(CISAdminDoc, CDocument)
	//{{AFX_MSG_MAP(CISAdminDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc construction/destruction

CISAdminDoc::CISAdminDoc()
{
	// TODO: add one-time construction code here

}

CISAdminDoc::~CISAdminDoc()
{
}

BOOL CISAdminDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc serialization

void CISAdminDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc diagnostics

#ifdef _DEBUG
void CISAdminDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CISAdminDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\isadmin.h ===
// ISAdmin.h : main header file for the ISADMIN application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "afxcmn.h"
#include "registry.h"
#include "gensheet.h"
#include "genpage.h"
#include <inetinfo.h>


// Registry defines

#define REGISTRY_ACCESS_RIGHTS STANDARD_RIGHTS_REQUIRED	| GENERIC_ALL
#define COMMON_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define FTP_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"
#define GOPHER_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\GOPHERSVC\\Parameters"
#define WEB_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\W3SVC\\Parameters"

// Useful macros

#define LESSOROF(p1,p2) ((p1) < (p2)) ? (p1) : (p2)


/////////////////////////////////////////////////////////////////////////////
// CISAdminApp:
// See ISAdmin.cpp for the implementation of this class
//

class CISAdminApp : public CWinApp
{
public:
	CISAdminApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISAdminApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CISAdminApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\isadmin.cpp ===
// ISAdmin.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "mainfrm.h"
#include "ISAdmdoc.h"
#include "ISAdmvw.h"
#include "formvw1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp

BEGIN_MESSAGE_MAP(CISAdminApp, CWinApp)
	//{{AFX_MSG_MAP(CISAdminApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp construction

CISAdminApp::CISAdminApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CISAdminApp object

CISAdminApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp initialization

BOOL CISAdminApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CISAdminDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
	//	RUNTIME_CLASS(CISAdminView));
		RUNTIME_CLASS(CFormVw1));
	AddDocTemplate(pDocTemplate);

	// create a new (empty) document
	OnFileNew();

	if (m_lpCmdLine[0] != '\0')
	{
		// TODO: add command line processing here
	}



	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CISAdminApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();

}

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\isadmdoc.h ===
// ISAdmdoc.h : interface of the CISAdminDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CISAdminDoc : public CDocument
{
protected: // create from serialization only
	CISAdminDoc();
	DECLARE_DYNCREATE(CISAdminDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISAdminDoc)
	public:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CISAdminDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CISAdminDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\isadmvw.h ===
// ISAdmvw.h : interface of the CISAdminView class
//
/////////////////////////////////////////////////////////////////////////////

class CISAdminView : public CView
{
protected: // create from serialization only
	CISAdminView();
	DECLARE_DYNCREATE(CISAdminView)

// Attributes
public:
	CISAdminDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISAdminView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CISAdminView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CISAdminView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ISAdmvw.cpp
inline CISAdminDoc* CISAdminView::GetDocument()
   { return (CISAdminDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\isadmvw.cpp ===
// ISAdmvw.cpp : implementation of the CISAdminView class
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "ISAdmdoc.h"
#include "ISAdmvw.h"
#include "mimemap1.h"
#include "scrmap1.h"
#include "ssl1.h"
//#include "combut1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CISAdminView

IMPLEMENT_DYNCREATE(CISAdminView, CView)

BEGIN_MESSAGE_MAP(CISAdminView, CView)
	//{{AFX_MSG_MAP(CISAdminView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISAdminView construction/destruction

CISAdminView::CISAdminView()
{
	// TODO: add construction code here

}

CISAdminView::~CISAdminView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminView drawing

void CISAdminView::OnDraw(CDC* pDC)
{
	CISAdminDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
/*					  
    CPropertySheet s(_T("Web Settings"));
	MIMEMAP1 MimePage;

	s.AddPage(&MimePage);

	ScrMap1 ScriptPage;

	s.AddPage(&ScriptPage);

	SSL1 SSLPage;

	s.AddPage(&SSLPage);

	s.DoModal();

*/

/*
CButton *pComButton;
DWORD dwBtnStyle = WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON;
const RECT rect = {20, 20, 100, 100};

pComButton->Create("Common", dwBtnStyle, rect, , 12345);
*/

	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminView printing

BOOL CISAdminView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CISAdminView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CISAdminView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminView diagnostics

#ifdef _DEBUG
void CISAdminView::AssertValid() const
{
	CView::AssertValid();
}

void CISAdminView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CISAdminDoc* CISAdminView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CISAdminDoc)));
	return (CISAdminDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CISAdminView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_INDEX, CFrameWnd::OnHelpIndex)
	ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
	ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpIndex)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars
	
// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
	// same order as in the bitmap 'toolbar.bmp'
//	ID_FILE_NEW,
//	ID_FILE_OPEN,
//	ID_FILE_SAVE,
//		ID_SEPARATOR,
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,
		ID_SEPARATOR,
//	ID_FILE_PRINT,
	ID_APP_ABOUT,
	ID_HELP,
};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
		!m_wndToolBar.SetButtons(buttons,
		  sizeof(buttons)/sizeof(UINT)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
    cs.style &= ~((LONG)FWS_ADDTOTITLE);
	
	return CFrameWnd::PreCreateWindow(cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\maindoc.cpp ===
// maindoc.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "maindoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// MAINDOC

IMPLEMENT_DYNCREATE(MAINDOC, CView)

MAINDOC::MAINDOC()
{
}

MAINDOC::~MAINDOC()
{
}


BEGIN_MESSAGE_MAP(MAINDOC, CView)
	//{{AFX_MSG_MAP(MAINDOC)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// MAINDOC drawing

void MAINDOC::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// MAINDOC diagnostics

#ifdef _DEBUG
void MAINDOC::AssertValid() const
{
	CView::AssertValid();
}

void MAINDOC::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// MAINDOC message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\maindoc.h ===
// maindoc.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// MAINDOC view

class MAINDOC : public CView
{
protected:
	MAINDOC();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(MAINDOC)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(MAINDOC)
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~MAINDOC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(MAINDOC)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\mimemap1.cpp ===
// mimemap1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "mimemap1.h"
#include "addmime.h"
#include "delmime.h"
#include "editmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// MIMEMAP1 property page

IMPLEMENT_DYNCREATE(MIMEMAP1, CGenPage)

MIMEMAP1::MIMEMAP1() : CGenPage(MIMEMAP1::IDD)
{
	//{{AFX_DATA_INIT(MIMEMAP1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_rkMimeKey = NULL;
	m_pmeMimeMapList = NULL;
}

MIMEMAP1::~MIMEMAP1()
{
	if (m_rkMimeKey != NULL)
	   delete(m_rkMimeKey);
	DeleteMimeList();
}

void MIMEMAP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(MIMEMAP1)
	DDX_Control(pDX, IDC_MIMEMAPLIST1, m_lboxMimeMapList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(MIMEMAP1, CGenPage)
	//{{AFX_MSG_MAP(MIMEMAP1)
	ON_BN_CLICKED(IDC_MIMEMAPADDBUTTON, OnMimemapaddbutton)
	ON_BN_CLICKED(IDC_MIMEMAPREMOVEBUTTON, OnMimemapremovebutton)
	ON_BN_CLICKED(IDC_MIMEMAPEDITBUTTON, OnMimemapeditbutton)
	ON_LBN_DBLCLK(IDC_MIMEMAPLIST1, OnDblclkMimemaplist1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// MIMEMAP1 message handlers

BOOL MIMEMAP1::OnInitDialog() 
{
	CGenPage::OnInitDialog();
/*
CMimeMap mimeTestMime(_T("mimetype,fileextension,imagefile,g"));
CMimeMap *pmimeTestMimePtr;
*/
CString strNextValue;
BOOL bAllocationError = FALSE;
int	lpiTabStops[2];

	CRegValueIter *rviMimeKeys;
	DWORD err, ulRegType;

lpiTabStops[0] = 58;
lpiTabStops[1] = 191;

m_ulMimeIndex = 0;

m_lboxMimeMapList.SetTabStops(2,lpiTabStops);

m_bMimeEntriesExist = FALSE;

m_rkMimeKey = new CRegKey(*m_rkMainKey,_T("MimeMap"),REGISTRY_ACCESS_RIGHTS);

// Anything under this key should be a mime mapping. 
// No way to verify that, but non-string entries are invalid
// so ignore them

if (m_rkMimeKey != NULL) {
   if (*m_rkMimeKey != NULL) {
      if (rviMimeKeys = new CRegValueIter(*m_rkMimeKey)) {
         while ((err = rviMimeKeys->Next(&strNextValue, &ulRegType)) == ERROR_SUCCESS) {
		    if (ulRegType == REG_SZ) {
		       if (!AddMimeEntry(strNextValue))
			      bAllocationError = TRUE;
			}
   		 }
		 delete (rviMimeKeys);
	  }	
	  m_bMimeEntriesExist = TRUE;
   }
}


if (!m_bMimeEntriesExist) {				//Can't open registry key
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}

if (bAllocationError) {				//Error adding one or more entries
   CString strAllocFailMsg;
   strAllocFailMsg.LoadString(IDS_MIMEENTRIESALLOCFAILMSG);
   AfxMessageBox(strAllocFailMsg);
}


/*
strTestString = _T("mimetype,fileextension,,g");

pmimeTestMimePtr = new CMimeMap(strTestString);

strTestString = mimeTestMime;
*/
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void MIMEMAP1::OnMimemapaddbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bMimeEntriesExist) {
   CAddMime addmimeGetInfo(this);	

   if (addmimeGetInfo.DoModal() == IDOK) {
      if (AddMimeEntry(addmimeGetInfo.GetFileExtension(), addmimeGetInfo.GetMimeType(), addmimeGetInfo.GetImageFile(),
         addmimeGetInfo.GetGopherType())) {
         m_bIsDirty = TRUE;
         SetModified(TRUE);
	  }
	  else {
         CString strAllocFailMsg;
         strAllocFailMsg.LoadString(IDS_MIMEENTRYALLOCFAILMSG);
         AfxMessageBox(strAllocFailMsg);
	  }
   }
}
else {
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}
}


void MIMEMAP1::OnMimemapremovebutton() 
{
	// TODO: Add your control notification handler code here
if (m_bMimeEntriesExist) {
   int iCurSel;
   CDelMime delmimeGetInfo(this);

   if ((iCurSel = m_lboxMimeMapList.GetCurSel())	!= LB_ERR) {
      if (delmimeGetInfo.DoModal() == IDOK) {
         DeleteMimeMapping(iCurSel);
	     m_bIsDirty = TRUE;
	     SetModified(TRUE);
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}
}

void MIMEMAP1::OnMimemapeditbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bMimeEntriesExist) {
   int iCurSel;
   PMIME_ENTRY pmeEditEntry;


   if ((iCurSel = m_lboxMimeMapList.GetCurSel())	!= LB_ERR) {
      for (pmeEditEntry = m_pmeMimeMapList;(pmeEditEntry != NULL) && 
         (m_lboxMimeMapList.GetItemData(iCurSel) != pmeEditEntry->iListIndex);
         pmeEditEntry = pmeEditEntry->NextPtr)
         ;
   
      ASSERT (pmeEditEntry != NULL);

      CEditMime editmimeGetInfo(this, 
         pmeEditEntry->mimeData->GetFileExtension(),
         pmeEditEntry->mimeData->GetMimeType(),
         pmeEditEntry->mimeData->GetImageFile(),
         pmeEditEntry->mimeData->GetGopherType());

      if (editmimeGetInfo.DoModal() == IDOK) {
         if (EditMimeMapping(iCurSel, 
   	          pmeEditEntry,
              editmimeGetInfo.GetFileExtension(), 
              editmimeGetInfo.GetMimeType(), 
              editmimeGetInfo.GetImageFile(),
              editmimeGetInfo.GetGopherType() )) {
            m_bIsDirty = TRUE;
	        SetModified(TRUE);
		 }
		 else {
            CString strEditErrorMsg;
            strEditErrorMsg.LoadString(IDS_MIMEEDITERRORMSG);
            AfxMessageBox(strEditErrorMsg);
		 }
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}
}

void MIMEMAP1::OnDblclkMimemaplist1() 
{
	// TODO: Add your control notification handler code here
OnMimemapeditbutton();	
}

////////////////////////////////////////////////////////////////////////////////
// Other Functions


void MIMEMAP1::SaveInfo()
{
PMIME_ENTRY pmeSaveEntry;
CString strDummyValue(_T(""));
if (m_bIsDirty) {
   for (pmeSaveEntry = m_pmeMimeMapList;(pmeSaveEntry != NULL); pmeSaveEntry = pmeSaveEntry->NextPtr) {
      if (pmeSaveEntry->DeleteCurrent) {
	  	 m_rkMimeKey->DeleteValue(pmeSaveEntry->mimeData->GetPrevMimeMap());
		 pmeSaveEntry->DeleteCurrent = FALSE;
 	  }
      
      if (pmeSaveEntry->WriteNew) {
         m_rkMimeKey->SetValue(*(pmeSaveEntry->mimeData), strDummyValue);
		 pmeSaveEntry->mimeData->SetPrevMimeMap();
		 pmeSaveEntry->WriteNew = FALSE;
	  }
   }

}

CGenPage::SaveInfo();

}


//This version is called for existing entries
BOOL MIMEMAP1::AddMimeEntry(CString &strNewMimeMap)
{
PMIME_ENTRY pmeNewEntry;
int iCurSel;
BOOL bretcode = FALSE;

if ((pmeNewEntry = new MIME_ENTRY) != NULL) {

   if ((pmeNewEntry->mimeData = new CMimeMap(strNewMimeMap)) != NULL) {
      iCurSel = m_lboxMimeMapList.AddString(pmeNewEntry->mimeData->GetDisplayString()); 
	  if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
         pmeNewEntry->DeleteCurrent = FALSE;
         pmeNewEntry->WriteNew = FALSE;
         m_lboxMimeMapList.SetItemData(iCurSel,m_ulMimeIndex);
         pmeNewEntry->iListIndex = m_ulMimeIndex++;
         pmeNewEntry->NextPtr = m_pmeMimeMapList;
         m_pmeMimeMapList = pmeNewEntry;
	     bretcode = TRUE;
	  }
	  else {
	     delete (pmeNewEntry->mimeData);
		 delete (pmeNewEntry);
	  }
   }
   else
      delete (pmeNewEntry);
}
return (bretcode);
}


// This version is called for new entries so set the write flag.
BOOL MIMEMAP1::AddMimeEntry(LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGoperType)
{
PMIME_ENTRY pmeNewEntry;
int iCurSel;
BOOL bretcode = FALSE;

if ((pmeNewEntry = new MIME_ENTRY) != NULL) {

   if ((pmeNewEntry->mimeData = new CMimeMap(pchFileExtension, pchMimeType, pchImageFile, pchGoperType)) != NULL) {
      iCurSel = m_lboxMimeMapList.AddString(pmeNewEntry->mimeData->GetDisplayString()); 
	  if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
         pmeNewEntry->DeleteCurrent = FALSE;
         pmeNewEntry->WriteNew = TRUE;
         m_lboxMimeMapList.SetItemData(iCurSel,m_ulMimeIndex);
	     m_lboxMimeMapList.SetCurSel(iCurSel);
         pmeNewEntry->iListIndex = m_ulMimeIndex++;
         pmeNewEntry->NextPtr = m_pmeMimeMapList;
         m_pmeMimeMapList = pmeNewEntry;
	     bretcode = TRUE;
	  }
	  else {
	     delete (pmeNewEntry->mimeData);
		 delete (pmeNewEntry);
	  }
   }
   else
      delete (pmeNewEntry);
}
return (bretcode);
}

void MIMEMAP1::DeleteMimeList()
{
PMIME_ENTRY pmeCurEntry;

while (m_pmeMimeMapList != NULL) {
   delete (m_pmeMimeMapList->mimeData);
   pmeCurEntry = m_pmeMimeMapList;
   m_pmeMimeMapList = m_pmeMimeMapList->NextPtr;
   delete (pmeCurEntry);
}
}

void MIMEMAP1::DeleteMimeMapping(int iCurSel)
{
PMIME_ENTRY pmeDelEntry;
for (pmeDelEntry = m_pmeMimeMapList;(pmeDelEntry != NULL) && 
   (m_lboxMimeMapList.GetItemData(iCurSel) != pmeDelEntry->iListIndex);
   pmeDelEntry = pmeDelEntry->NextPtr)
   ;
ASSERT (pmeDelEntry != NULL);

if (pmeDelEntry->mimeData->PrevMimeMapExists())
   pmeDelEntry->DeleteCurrent = TRUE;
pmeDelEntry->WriteNew = FALSE;			
m_lboxMimeMapList.DeleteString(iCurSel);
}
    

BOOL MIMEMAP1::EditMimeMapping(int iCurSel, 
   PMIME_ENTRY pmeEditEntry, 
   LPCTSTR pchFileExtension, 
   LPCTSTR pchMimeType, 
   LPCTSTR pchImageFile, 
   LPCTSTR pchGopherType)
{
BOOL bretcode = FALSE;

pmeEditEntry->mimeData->SetFileExtension(pchFileExtension);
pmeEditEntry->mimeData->SetMimeType(pchMimeType);
pmeEditEntry->mimeData->SetImageFile(pchImageFile);
pmeEditEntry->mimeData->SetGopherType(pchGopherType);

m_lboxMimeMapList.DeleteString(iCurSel); 		// Delete first so memory is freed
iCurSel = m_lboxMimeMapList.AddString(pmeEditEntry->mimeData->GetDisplayString()); 

// There error case on this is incredibly rare, so don't bother saving and restoring the above fields
// Just don't set flags so registry is not updated.

if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
   m_lboxMimeMapList.SetItemData(iCurSel,pmeEditEntry->iListIndex);
   if (pmeEditEntry->mimeData->PrevMimeMapExists())
      pmeEditEntry->DeleteCurrent = TRUE;
   
   pmeEditEntry->WriteNew = TRUE;
   bretcode = TRUE;
} 

return (bretcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\mimemapc.cpp ===
#include "stdafx.h"
#include "mimemapc.h"


CMimeMap::CMimeMap ( LPCTSTR pchOriginalMimeMap) 
{
	CString strOriginalMimeMap = pchOriginalMimeMap;
	int iCharIndex;

//Save this away and never change it.
	m_strPrevMimeMap = pchOriginalMimeMap;

	if ((iCharIndex = strOriginalMimeMap.Find(',')) != -1) {
	   m_strMimeType = strOriginalMimeMap.Left(iCharIndex);
	   strOriginalMimeMap = strOriginalMimeMap.Mid(iCharIndex + 1);
	}
	else {
	   m_strMimeType = strOriginalMimeMap;
	   strOriginalMimeMap = _T("");
	}

	if ((iCharIndex = strOriginalMimeMap.Find(',')) != -1) {
	   m_strFileExtension = strOriginalMimeMap.Left(iCharIndex);
	   strOriginalMimeMap = strOriginalMimeMap.Mid(iCharIndex + 1);
	}
	else {
	   m_strFileExtension = strOriginalMimeMap;
	   strOriginalMimeMap = _T("");
	}

	if ((iCharIndex = strOriginalMimeMap.Find(',')) != -1) {
	   m_strImageFile = strOriginalMimeMap.Left(iCharIndex);
	   strOriginalMimeMap = strOriginalMimeMap.Mid(iCharIndex + 1);
	}
	else {
	   m_strImageFile = strOriginalMimeMap;
	   strOriginalMimeMap = _T("");
	}

	m_strGopherType = strOriginalMimeMap;
}

CMimeMap::CMimeMap ( LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGopherType) 
{

	m_strPrevMimeMap = _T("");

	m_strMimeType = pchMimeType;
	SetFileExtension(pchFileExtension);
	m_strImageFile = pchImageFile;
	m_strGopherType = pchGopherType;
}


	

	


CMimeMap::~CMimeMap()
{
}

void CMimeMap::SetMimeType(LPCTSTR pchMimeType)
{
	m_strMimeType = pchMimeType;
}
 
LPCTSTR CMimeMap::GetMimeType()
{
	return (m_strMimeType);
}

void CMimeMap::SetGopherType(LPCTSTR pchGopherType)
{
	m_strGopherType = pchGopherType;
}


LPCTSTR CMimeMap::GetGopherType()
{
	return (m_strGopherType);
}

void CMimeMap::SetImageFile(LPCTSTR pchImageFile)
{
	m_strImageFile = pchImageFile;
}


LPCTSTR CMimeMap::GetImageFile()
{
	return(m_strImageFile);
}


void CMimeMap::SetFileExtension(LPCTSTR pchFileExtension)
{
	CString strTempFileExtension = pchFileExtension;
	CheckDot(strTempFileExtension);
	m_strFileExtension = strTempFileExtension;
}

LPCTSTR CMimeMap::GetFileExtension()
{
	return(m_strFileExtension);
}

LPCTSTR CMimeMap::GetPrevMimeMap()
{
	return(m_strPrevMimeMap);
}

void CMimeMap::SetPrevMimeMap()
{
	m_strPrevMimeMap = GetMimeMapping();
}

BOOL CMimeMap::PrevMimeMapExists()
{
return (m_strPrevMimeMap != _T(""));
}


////////////////////////////////////////////////////////////////////////////////
// Private functions

LPCTSTR CMimeMap::GetMimeMapping()
{
m_strCurrentMimeMap = m_strMimeType;
m_strCurrentMimeMap += _T(",");
m_strCurrentMimeMap += m_strFileExtension;
m_strCurrentMimeMap += _T(",");
m_strCurrentMimeMap += m_strImageFile;
m_strCurrentMimeMap += _T(",");
m_strCurrentMimeMap += m_strGopherType;
return (m_strCurrentMimeMap);
}

LPCTSTR CMimeMap::GetDisplayString()
{
m_strDisplayString = m_strFileExtension;
m_strDisplayString += _T("\t");
m_strDisplayString += m_strMimeType;
m_strDisplayString += _T("\t");
m_strDisplayString += m_strGopherType;
return (m_strDisplayString);
}

void CMimeMap::CheckDot(CString &strFileExtension)
{
if (strFileExtension.Left(1) == _T(".")) {
   CString strTemp = strFileExtension.Mid(1);
   strFileExtension = strTemp;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\mimemapc.h ===
/****************************************************************************
MIMEMAPC.H	
Mime Map Class Definition
****************************************************************************/
#ifndef _mimemapc_h 

#define _mimemapc_h


//  Forward declarations
class CMimeMap ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CMimeMap : public CObject
{
protected:

	CString m_strPrevMimeMap;
	CString m_strCurrentMimeMap;
	CString m_strDisplayString;
	CString	m_strMimeType;
	CString m_strGopherType;
	CString m_strImageFile;
	CString m_strFileExtension;

	LPCTSTR GetMimeMapping();
	void CheckDot(CString &pchFileExtension);

public:
    //  Standard constructor
    CMimeMap ( LPCTSTR pchOriginalMimeMap) ;
	CMimeMap ( LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGopherType);
	~CMimeMap();
    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator LPCTSTR ()
        { return GetMimeMapping(); }

	void SetMimeType(LPCTSTR);
	LPCTSTR GetMimeType();
	void SetGopherType(LPCTSTR);
	LPCTSTR GetGopherType();
	void SetImageFile(LPCTSTR);
	LPCTSTR GetImageFile();
	void SetFileExtension(LPCTSTR);
	LPCTSTR GetFileExtension();
	void SetPrevMimeMap();
	LPCTSTR GetPrevMimeMap();
	BOOL PrevMimeMapExists();
	LPCTSTR GetDisplayString();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\mimemap1.h ===
// mimemap1.h : header file
//
#include "mimemapc.h"

typedef struct _MIME_ENTRY {
   struct _MIME_ENTRY	*NextPtr;
   CMimeMap				*mimeData;
   DWORD				iListIndex;
   BOOL					DeleteCurrent;
   BOOL					WriteNew;
   } MIME_ENTRY, *PMIME_ENTRY;


/////////////////////////////////////////////////////////////////////////////
// MIMEMAP1 dialog

class MIMEMAP1 : public CGenPage
{
	DECLARE_DYNCREATE(MIMEMAP1)

// Construction
public:
	MIMEMAP1();
	~MIMEMAP1();

// Dialog Data
	//{{AFX_DATA(MIMEMAP1)
	enum { IDD = IDD_MIMEMAP1 };
	CListBox	m_lboxMimeMapList;
	//}}AFX_DATA

	CRegKey *m_rkMimeKey;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(MIMEMAP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(MIMEMAP1)
	virtual BOOL OnInitDialog();
	afx_msg void OnMimemapaddbutton();
	afx_msg void OnMimemapremovebutton();
	afx_msg void OnMimemapeditbutton();
	afx_msg void OnDblclkMimemaplist1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL AddMimeEntry(CString &);
	BOOL AddMimeEntry(LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGoperType);
	void DeleteMimeList();
	void DeleteMimeMapping(int iCurSel);
	BOOL EditMimeMapping(int iCurSel, PMIME_ENTRY pmeEditEntry, LPCTSTR pchFileExtension, LPCTSTR pchMimeType, 
	   LPCTSTR pchImageFile, LPCTSTR pchGopherType);

	DWORD	m_ulMimeIndex;
	BOOL	m_bMimeEntriesExist;
	PMIME_ENTRY m_pmeMimeMapList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\scripmap.cpp ===
#include "stdafx.h"
#include "scripmap.h"

CScriptMap::CScriptMap ( LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry)
{

	m_strScriptMap = pchScriptMap;

    if (bExistingEntry) {
	   m_strPrevFileExtension = pchFileExtension;
	   m_strFileExtension = pchFileExtension;
       }
    else {
	   m_strPrevFileExtension= _T("");
	   SetFileExtension(pchFileExtension);
	   }

}

CScriptMap::~CScriptMap()
{
}

void CScriptMap::SetScriptMap(LPCTSTR pchScriptMap)
{
	m_strScriptMap = pchScriptMap;
}

LPCTSTR CScriptMap::GetScriptMap()
{
	return (m_strScriptMap);
}

void CScriptMap::SetFileExtension(LPCTSTR pchFileExtension)
{
	CString strTempFileExtension = pchFileExtension;
	CheckDot(strTempFileExtension);
	m_strFileExtension = strTempFileExtension;
}

LPCTSTR CScriptMap::GetFileExtension()
{
	return(m_strFileExtension);
}

LPCTSTR CScriptMap::GetPrevFileExtension()
{
	return(m_strPrevFileExtension);
}

void CScriptMap::SetPrevFileExtension()
{
	m_strPrevFileExtension = m_strFileExtension;
}

BOOL CScriptMap::PrevScriptMapExists()
{
return (m_strPrevFileExtension != _T(""));
}

LPCTSTR CScriptMap::GetDisplayString()
{
m_strDisplayString = m_strFileExtension;
m_strDisplayString += _T("\t");
m_strDisplayString += m_strScriptMap;
return (m_strDisplayString);
}


////////////////////////////////////////////////////////////////////////////////
// Private functions

void CScriptMap::CheckDot(CString &strFileExtension)
{
if (strFileExtension.Left(1) != _T(".")) {
   CString strTemp = _T(".") + strFileExtension;
   strFileExtension = strTemp;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\registry.cpp ===
#include "stdafx.h"
#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include "registry.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CRegKey::CRegKey (
    HKEY hKeyBase,
    LPCTSTR pchSubKey,
    REGSAM regSam,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    LONG err = ERROR_SUCCESS;

    if ( pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, &hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL ;
        }

        // hkBase == NULL ;
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        if ( pchSubKey )
        {
            err = ::RegOpenKeyEx( hkBase, pchSubKey, 0, regSam, & m_hKey ) ;
        }
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;
        }

        if ( hkBase && hkBase != hKeyBase )
        {
            ::RegCloseKey( hkBase ) ;
        }
    }

    if ( err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
}

//
//  Constructor creating a new key.
//
CRegKey::CRegKey (
    LPCTSTR pchSubKey,
    HKEY hKeyBase,
    DWORD dwOptions,
    REGSAM regSam,
    LPSECURITY_ATTRIBUTES pSecAttr,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    LONG err = 0;

    if (pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, & hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL;
        }

        // hkBase == NULL;
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        LPCTSTR szEmpty = _T("") ;

        err = ::RegCreateKeyEx( hkBase, pchSubKey, 0, (TCHAR *) szEmpty,
            dwOptions, regSam, pSecAttr, &m_hKey, &m_dwDisposition );
    }
    if (err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
}

CRegKey::~CRegKey()
{
    if (m_hKey != NULL)
    {
        ::RegCloseKey( m_hKey ) ;
    }
}

//
//  Prepare to read a value by finding the value's size.
//
LONG
CRegKey :: PrepareValue (
    LPCTSTR pchValueName,
    DWORD * pdwType,
    DWORD * pcbSize,
    BYTE ** ppbData
    )
{
    LONG err = 0 ;

    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //
        //  Set the resulting buffer size to 0.
        //
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
            0, pdwType, chDummy, &cbData);

        //
        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        //
        if (err == ERROR_SUCCESS)
        {
            cbData = sizeof(LONG);  //  Just a fudgy number
        }
        else
        {
            if ( err != ERROR_MORE_DATA )
            {
                break;
            }
        }

        //
        //  Allocate a buffer large enough for the data.
        //
        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //
        //  Now that have a buffer, re-fetch the value.
        //
        err = ::RegQueryValueEx( *this, (LPTSTR)pchValueName,
            0, pdwType, *ppbData, pcbSize );

    } while (FALSE);

    if (err != ERROR_SUCCESS)
    {
        delete [] *ppbData;
    }

    return err;
}

//
//  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
//  if data exists but not in correct form to deliver into result object.
//
LONG
CRegKey::QueryValue (
    const TCHAR * pchValueName,
    CString &strResult
    )
{
    LONG err = 0;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break;
        }

        if ( dwType != REG_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //
        //  Guarantee that the data looks like a string
        //
        pabData[cbData] = 0 ;

        //
        //  Catch exceptions trying to assign to the caller's string
        //
        TRY
        {
            strResult = (TCHAR *) pabData ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while (FALSE);

    delete [] pabData ;

    return err ;
}

LONG
CRegKey::QueryValue (
    LPCTSTR pchValueName,
    CStringList &strList
    )
{
    LONG err = 0;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;
    LPTSTR pbTemp, pbTempLimit;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ))
        {
            break;
        }

        if ( dwType != REG_MULTI_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //
        //  Guarantee that the trailing data looks like a string
        //
        pabData[cbData] = 0 ;
        pbTemp = (TCHAR *) pabData ;
        pbTempLimit = & pbTemp[cbData] ;

        //
        //  Catch exceptions trying to build the list
        //
        TRY
        {
            for ( /**/ ; pbTemp < pbTempLimit ; /**/ )
            {
                strList.AddTail( pbTemp ) ;
                pbTemp += ::_tcslen( pbTemp ) + sizeof(TCHAR) ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while ( FALSE );

    delete [] pabData ;

    return err;
}

LONG
CRegKey :: QueryValue (
    LPCTSTR pchValueName,
    DWORD &dwResult
    )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break ;
        }

        if ( dwType != REG_DWORD || cbData != sizeof dwResult )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        dwResult = *((DWORD *) pabData) ;
    }
    while ( FALSE ) ;

    delete [] pabData ;

    return err ;
}

LONG
CRegKey :: QueryValue (
    LPCTSTR pchValueName,
    CByteArray &abResult
    )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break ;
        }

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //
        //  Catch exceptions trying to grow the result array
        //
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( err != ERROR_SUCCESS)
        {
            break ;
        }

        //
        //  Move the data to the result array.
        //
        for ( DWORD i = 0 ; i < cbData ; ++i )
        {
            abResult[i] = pabData[i] ;
        }
    }
    while ( FALSE ) ;

    delete [] pabData ;

    return err ;
}

LONG
CRegKey::QueryValue (
    LPCTSTR pchValueName,
    void * pvResult,
    DWORD cbSize
    )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break;
        }

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    }
    while ( FALSE ) ;

    delete [] pabData ;

    return err ;
}

//
//  Overloaded value setting members.
//
LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    CString & strResult
    )
{
    return ::RegSetValueEx( *this, pchValueName, 0, REG_SZ,
        (const BYTE *) (const TCHAR *) strResult, strResult.GetLength() + 1 );
}

LONG
CRegKey :: SetValue (
    LPCTSTR pchValueName,
    CStringList & strList
    )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( strList, & cbSize, & pbData ) ;

    if ( err == ERROR_SUCCESS )
    {
        err = ::RegSetValueEx(*this, pchValueName, 0, REG_MULTI_SZ, pbData, cbSize);
    }

    delete pbData ;

    return err ;
}

LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    DWORD &dwResult
    )
{
    return ::RegSetValueEx(*this, pchValueName, 0, REG_DWORD,
        (const BYTE *) & dwResult, sizeof dwResult);
}

LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    CByteArray & abResult
    )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue(abResult, &cbSize, &pbData);

    if (err == ERROR_SUCCESS)
    {
        err = ::RegSetValueEx(*this, pchValueName,
            0,REG_BINARY, pbData, cbSize);
    }

    delete pbData;

    return err;
}

LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    void * pvResult,
    DWORD cbSize
    )
{
    return ::RegSetValueEx( *this, pchValueName,
        0, REG_BINARY, (const BYTE *)pvResult, cbSize );
}

LONG
CRegKey::DeleteValue (
    LPCTSTR pchValueName
    )
{
    return ::RegDeleteValue( *this, (LPTSTR) pchValueName);
}





LONG
CRegKey::FlattenValue (
    CStringList & strList,
    DWORD * pcbSize,
    BYTE ** ppbData
    )
{
    LONG err = 0 ;

    POSITION pos ;
    CString * pstr ;
    int cbTotal = 0 ;

    //
    //  Walk the list accumulating sizes
    //
    for (pos = strList.GetHeadPosition();
         pos != NULL && (pstr = & strList.GetNext( pos )) ; /**/ )
    {
        cbTotal += pstr->GetLength() + 1;
    }

    //
    //  Allocate and fill a temporary buffer
    //
    if (*pcbSize = cbTotal)
    {
        TRY
        {
            *ppbData = new BYTE[ *pcbSize ] ;

            BYTE * pbData = *ppbData ;

            //
            //  Populate the buffer with the strings.
            //
            for (pos = strList.GetHeadPosition();
                 pos != NULL && (pstr = & strList.GetNext( pos )) ; /**/ )
            {
                int cb = pstr->GetLength() + 1 ;
                ::memcpy( pbData, (LPCTSTR) *pstr, cb );
                pbData += cb ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return err ;
}

LONG
CRegKey::FlattenValue(
    CByteArray & abData,
    DWORD * pcbSize,
    BYTE ** ppbData
    )
{
    LONG err = 0 ;

    DWORD i ;

    //
    //  Allocate and fill a temporary buffer
    //
    if (*pcbSize = (DWORD)abData.GetSize())
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;

            for ( i = 0 ; i < *pcbSize ; i++ )
            {
                (*ppbData)[i] = abData[i] ;
            }

        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return err;
}


LONG
CRegKey::QueryKeyInfo (
    CREGKEY_KEY_INFO * pRegKeyInfo
    )
{
    LONG err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKey(*this,
        pRegKeyInfo->chBuff,
        &pRegKeyInfo->dwClassNameSize,
        NULL,
        &pRegKeyInfo->dwNumSubKeys,
        &pRegKeyInfo->dwMaxSubKey,
        &pRegKeyInfo->dwMaxClass,
        &pRegKeyInfo->dwMaxValues,
        &pRegKeyInfo->dwMaxValueName,
        &pRegKeyInfo->dwMaxValueData,
        &pRegKeyInfo->dwSecDesc,
        &pRegKeyInfo->ftKey
        );

    return err ;
}

//
// Iteration class
//
CRegKeyIter::CRegKeyIter (
    CRegKey & regKey
    )
    : m_rk_iter( regKey ),
      m_p_buffer( NULL ),
      m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
}

CRegKeyIter :: ~ CRegKeyIter ()
{
    delete [] m_p_buffer ;
}

//
// Get the name (and optional last write time) of the next key.
//
LONG CRegKeyIter::Next(
    CString * pstrName,
    CTime * pTime
    )
{
    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter, m_dw_index, m_p_buffer, & dwNameSize,
        NULL, NULL, NULL, & ftDummy ) ;

    if (err == ERROR_SUCCESS)
    {
        ++m_dw_index;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        TRY
        {
            *pstrName = m_p_buffer ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    return err;
}

CRegValueIter::CRegValueIter (
    CRegKey &regKey
    )
    : m_rk_iter(regKey),
      m_p_buffer(NULL),
      m_cb_buffer(0)
{
    LONG err = 0;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if (err == ERROR_SUCCESS)
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD);
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
}

CRegValueIter::~ CRegValueIter()
{
    delete [] m_p_buffer;
}

LONG
CRegValueIter::Next (
    CString * pstrName,
    DWORD * pdwType
    )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue(m_rk_iter, m_dw_index, m_p_buffer,
        &dwNameLength, NULL, pdwType, NULL, NULL );

    if ( err == ERROR_SUCCESS )
    {
        ++m_dw_index;

        TRY
        {
            *pstrName = m_p_buffer;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\scripmap.h ===
/****************************************************************************
MIMEMAPC.H	
Mime Map Class Definition
****************************************************************************/
#ifndef _scriptmapc_h

#define _scriptmapc_h


//  Forward declarations
class CScriptMap ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CScriptMap : public CObject
{
protected:

	CString m_strPrevFileExtension;
	CString m_strScriptMap;
 	CString m_strFileExtension;
	CString m_strDisplayString;

	void CheckDot(CString &strFileExtension);
public:
    //  Standard constructor
	CScriptMap ( LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry);
	~CScriptMap();
    //  Allow a CRegKey to be used anywhere an HKEY is required.
	void SetScriptMap(LPCTSTR);
	LPCTSTR GetScriptMap();
	void SetFileExtension(LPCTSTR);
	LPCTSTR GetFileExtension();
	void SetPrevFileExtension();
	LPCTSTR GetPrevFileExtension();
	BOOL PrevScriptMapExists();
	LPCTSTR GetDisplayString();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\scrmap1.h ===
// scrmap1.h : header file
//
#include "scripmap.h"

typedef struct _SCRIPT_ENTRY {
   struct _SCRIPT_ENTRY	*NextPtr;
   CScriptMap			*scriptData;
   DWORD				iListIndex;
   BOOL					DeleteCurrent;
   BOOL					WriteNew;
   } SCRIPT_ENTRY, *PSCRIPT_ENTRY;

////////////////////////////////////////////////////////////////////////////////////
// ScrMap1 dialog

class ScrMap1 : public CGenPage
{
	DECLARE_DYNCREATE(ScrMap1)

// Construction
public:
	ScrMap1();
	~ScrMap1();

// Dialog Data
	//{{AFX_DATA(ScrMap1)
	enum { IDD = IDD_SCRIPTMAP1 };
	CListBox	m_lboxScriptMap;
	//}}AFX_DATA

	CRegKey *m_rkScriptKey;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(ScrMap1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(ScrMap1)
	afx_msg void OnScriptmapaddbutton();
	afx_msg void OnScriptmapeditbutton();
	afx_msg void OnScriptmapremovebutton();
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkScriptmaplistbox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL AddScriptEntry(LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry);
	void DeleteScriptList();
	void DeleteScriptMapping(int iCurSel);
	BOOL EditScriptMapping(int iCurSel, PSCRIPT_ENTRY pseEditEntry, LPCTSTR pchFileExtension, LPCTSTR pchScriptMap);



	DWORD	m_ulScriptIndex;
 	BOOL	m_bScriptEntriesExist;
	PSCRIPT_ENTRY m_pseScriptMapList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ISAdmin.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_ISADMITYPE                  129
#define IDD_MIMEMAP1                    131
#define IDD_SCRIPTMAP1                  132
#define IDD_SSL                         133
#define IDI_COMICON1                    134
#define IDD_FORMVIEW1                   135
#define IDD_COMPAGE1                    136
#define IDD_ADVCOMSET1                  138
#define IDD_FTPPAGE1                    139
#define IDD_FTPADVPAGE1                 140
#define IDD_GOPHERGENPAGE1              141
#define IDD_WEBGENPAGE1                 142
#define IDD_DIALOG1                     143
#define IDD_GOPADVPAGE1                 144
#define IDD_WEBADVPAGE1                 145
#define IDD_ADDMIMEMAPDIALOG            148
#define IDD_DELMIMEDIALOG               149
#define IDD_EDITMIMEMAPDIALOG           150
#define IDB_BITMAP1                     151
#define IDB_GOPHERUPBITMAP              154
#define IDB_GOPHERDOWNBITMAP            155
#define IDB_FTPUPBITMAP                 157
#define IDB_FTPDOWNBITMAP               158
#define IDB_WEBUPBITMAP                 159
#define IDB_WEBDOWNBITMAP               160
#define IDD_ADDSCRIPTDIALOG             161
#define IDD_EDITSCRIPTDIALOG            162
#define IDD_DELSCRIPTDIALOG             163
#define IDI_ICON1                       164
#define IDC_LIST1                       1000
#define IDC_SCRIPTMAPLISTBOX            1000
#define IDC_BUTTON1                     1001
#define IDC_SCRIPTMAPADDBUTTON          1001
#define IDC_BUTTON2                     1002
#define IDC_SCRIPTMAPEDITBUTTON         1002
#define IDC_BUTTON3                     1003
#define IDC_SCRIPTMAPREMOVEBUTTON       1003
#define IDC_COMSET1                     1004
#define IDC_WWWSET4                     1005
#define IDC_FTPSET1                     1006
#define IDC_GOPHSET1                    1007
#define IDC_CACHETEXT1                  1008
#define IDC_CACHEDATA1                  1009
#define IDC_LOGBATCHTEXT1               1010
#define IDC_LOGBATDATA1                 1011
#define IDC_COMADVBUT1                  1013
#define IDC_LOGBATTEXT2                 1014
#define IDC_CACHETEXT2                  1015
#define IDC_MAXPOOLTEXT1                1016
#define IDC_MAXPOOLDATA1                1017
#define IDC_MAXPOOLTEXT2                1018
#define IDC_MAXCONCUR1                  1019
#define IDC_MAXCONCURDATA1              1020
#define IDC_MAXCONCURTEXT2              1022
#define IDC_THREADTOTEXT1               1023
#define IDC_THREADTODATA1               1024
#define IDC_THREADTOTEXT2               1025
#define IDC_USEACCEPTEXTEXT1            1026
#define IDC_USEACCEPTEXTEXT2            1028
#define IDC_USEACCEPTEXDATA1            1029
#define IDC_OBJCACHETEXT1               1030
#define IDC_OBJCACHEDATA1               1031
#define IDC_OBJCACHETEXT2               1032
#define IDC_ACCEPTEXOUTTEXT1            1033
#define IDC_ACCEPTEXOUTDATA1            1034
#define IDC_ACCEPTEXOUTTEXT2            1035
#define IDC_ACCEPTEXTOTEXT1             1036
#define IDC_ACCEPTEXTODATA1             1037
#define IDC_ACCEPTEXTOTEXT2             1038
#define IDC_COMDBGFLAGSTEXT1            1039
#define IDC_COMDBGFLAGSDATA1            1040
#define IDC_COMDBGFLAGSTEXT2            1041
#define IDC_ENSVCLOCTEXT1               1042
#define IDC_ENSVCLOCDATA1               1043
#define IDC_ENSVCLOCTEXT2               1044
#define IDC_LOGANONTEXT1                1045
#define IDC_LOGANONDATA1                1046
#define IDC_LOGANONTEXT2                1047
#define IDC_LOGNONANONTEXT1             1048
#define IDC_LOGNONANONDATA1             1049
#define IDC_LOGNONANONTEXT2             1050
#define IDC_ENPORTATTACKTEXT1           1051
#define IDC_ENPORTATTACKDATA1           1052
#define IDC_ENPORTATTACKTEXT2           1053
#define IDC_FTPADVBUT1                  1054
#define IDC_FTPDBGFLAGSTEXT1            1055
#define IDC_FTPDBGFLAGSDATA1            1056
#define IDC_FTPDBGFLAGSTEXT2            1057
#define IDC_CENWAISTEXT1                1058
#define IDC_ENWAISDATA1                 1060
#define IDC_ENWAISTEXT2                 1061
#define IDC_GOPADVBUT1                  1062
#define IDC_WEBADVBUT1                  1063
#define IDC_GOPDBGFLAGSTEXT1            1064
#define IDC_GOPDBGFLAGSDATA1            1065
#define IDC_GOPDBFFLAGSTEXT2            1066
#define IDC_WEBDBGFLAGSTEXT1            1067
#define IDC_WEBDBGFLAGSDATA1            1068
#define IDC_WEBDBGFLAGSTEXT2            1069
#define IDC_MACHINENAMEDATA1            1071
#define IDC_MACHINENAMETEXT1            1072
#define IDC_CACHESPIN1                  1073
#define IDC_LOGBATSPIN1                 1074
#define IDC_MAXPOOLSPIN1                1075
#define IDC_MAXCONCURSPIN1              1076
#define IDC_THREADTOSPIN1               1077
#define IDC_USEACCEPTEXSPIN1            1078
#define IDC_ACCEPTEXOUTSPIN1            1079
#define IDC_ACCEPTEXTOSPIN1             1080
#define IDC_OBJCACHESPIN1               1081
#define IDC_COMDBGFLAGSSPIN1            1082
#define IDC_ENPORTATTACK                1090
#define IDC_ACCEPTEXGROUP               1098
#define IDC_USEOBJECTCACHETTLDATA1      1099
#define IDC_OBJCECTCACHETTLGROUP        1100
#define IDC_OBJECTCACHETTLGROUP         1100
#define IDC_USERTOKENTTLTEXT1           1101
#define IDC_USERTOKENTTLDATA1           1102
#define IDC_USERTOKENTTLSPIN1           1103
#define IDC_USERTOKENTTLTEXT2           1104
#define IDC_ALLOWGUESTACCESSDATA1       1105
#define IDC_ANNOTATEDIRECTORIESDATA1    1106
#define IDC_MSDOSDIROUTPUT              1107
#define IDC_LOWERCASEFILESDATA1         1108
#define IDC_LISTENBACKLOGTEXT1          1109
#define IDC_LISTENBACKLOGDATA1          1110
#define IDC_LISTENBACKLOGSPIN1          1111
#define IDC_LISTENBACKLOGTEXT2          1112
#define IDC_NTAUTHENTICATIONPROVIDERSTEXT1 1114
#define IDC_NTAUTHENTICATIONPROVIDERSDATA1 1115
#define IDC_NTAUTHENTICATIONPROVIDERSTEXT2 1116
#define IDC_DIRBROWSECONTROLTEXT1       1117
#define IDC_DIRBROWSECONTROLDATA1       1119
#define IDC_DIRBROWSECONTROLTEXT2       1120
#define IDC_MAXCONNECTIONSTEXT1         1121
#define IDC_MAXCONNECTIONSDATA1         1122
#define IDC_MAXCONNECTIONSSPIN1         1123
#define IDC_MAXCONNECTIONSTEXT2         1124
#define IDC_SCRIPTTIMEOUTTEXT1          1126
#define IDC_SCRIPTTIMEOUTDATA1          1127
#define IDC_SCRIPTTIMEOUTSPIN1          1128
#define IDC_SCRIPTTIMEOUTTEXT2          1129
#define IDC_CACHEEXTENSIONSDATA1        1130
#define IDC_SERVERSIDEINCLUDESGROUP     1131
#define IDC_SERVERSIDEINCLUDESENABLEDDATA1 1132
#define IDC_SERVERSIDEINCLUDESEXTENSIONTEXT1 1133
#define IDC_SERVERSIDEINCLUDESEXTENSIONDATA1 1134
#define IDC_GLOBALEXPIREGROUP           1135
#define IDC_ENABLEGLOBALEXPIREDATA1     1136
#define IDC_GLOBALEXPIRETEXT1           1137
#define IDC_GLOBALEXPIREDATA1           1138
#define IDC_GLOBALEXPIRESPIN1           1139
#define IDC_GLOBALEXPIRETEXT2           1140
#define IDC_LOGFILEFLUSHINTERVAL        1141
#define IDC_USELOGFILEFLUSHINTERNVALDATA1 1142
#define IDC_LOGFILEFLUSHINTERVALTEXT1   1143
#define IDC_LOGFILEFLUSHINTERVALDATA1   1144
#define IDC_LOGFILEFLUSHINTERVALSPIN1   1145
#define IDC_LOGFILEFLUSHINTERVALTEXT2   1146
#define IDC_MIMEMAPLIST1                1148
#define IDC_ADDMIMEFILEEXTTEXT1         1149
#define IDC_ADDMIMEMIMETYPETEXT1        1150
#define IDC_ADDMIMEGOPHERTYPETEXT1      1151
#define IDC_ADDMIMEIMAGEFILETEXT1       1152
#define IDC_ADDMIMEFILEEXTENSIONDATA1   1153
#define IDC_ADDMIMEMIMETYPEDATA1        1154
#define IDC_ADDMIMEGOPHERTYPEDATA1      1155
#define IDC_ADDMIMEIMAGEFILEDATA1       1156
#define IDC_MIMEMAPADDBUTTON            1157
#define IDC_MIMEMAPEDITBUTTON           1158
#define IDC_MIMEMAPREMOVEBUTTON         1159
#define IDC_DELMIMETEXT1                1160
#define IDC_EDITMIMEFILEXTENSIONTEXT1   1161
#define IDC_EDITMIMEMIMETYPETEXT1       1162
#define IDC_EDITMIMEIMAGEFILETEXT1      1163
#define IDC_EDITMIMEGOPHERTYPETEXT1     1164
#define IDC_EDITMIMEFILEEXTENSIONDATA1  1165
#define IDC_EDITMIMEMIMETYPEDATA1       1166
#define IDC_EDITMIMEGOPHERTYPEDATA1     1167
#define IDC_EDITMIMEIMAGEFILEDATA1      1168
#define IDC_ADDIMAGEFILETEXT2           1169
#define IDC_EDITMIMEIMAGEFILETEXT2      1170
#define IDC_MAINGROUP                   1173
#define IDC_ADDSCRIPTFILEEXTENSIONTEXT1 1178
#define IDC_ADDSCRIPTFILEEXTENSIONDATA1 1179
#define IDC_ADDSCRIPTMAPPINGTEXT1       1180
#define IDC_ADDSCRIPTMAPPINGDATA1       1181
#define IDC_EDITSCRIPTFILEEXTENSIONTEXT1 1182
#define IDC_EDITSCRIPTFILEEXTENSIONDATA1 1183
#define IDC_EDITSCRIPTMAPPINGTEXT1      1184
#define IDC_EDITSCRIPTMAPPINGDATA1      1185
#define IDC_DELSCRIPTTEXT1              1186
#define IDC_WEBACCESSDENIEDMESSAGETEXT1 1187
#define IDC_WEBACCESSDENIEDMESSAGEDATA1 1188
#define IDC_SSLSECUREPORTTEXT1          1189
#define IDC_SSLSECUREPORTDATA1          1190
#define IDC_SSLENABLESSLDATA1           1191
#define IDC_SSLENABLEPCTDATA1           1192
#define IDC_SSLCREATEPROCESSASUSERDATA1 1193
#define IDS_COMOPENREGERRMSG1           60446
#define IDS_FTPOPENREGERRMSG1           60447
#define IDS_WEBOPENREGERRMSG1           60448
#define IDS_GOPOPENREGERRMSG1           60449
#define IDS_MIMENOHIGHLIGHTMSG          60450
#define IDS_NOHIGHLIGHTMSG              60450
#define IDS_MIMENOMIMEENTRIESMSG        60451
#define IDS_MIMEENTRYALLOCFAILMSG       60452
#define IDS_MIMEENTRIESALLOCFAILMSG     60453
#define IDS_MIMEEDITERRORMSG            60454
#define IDS_SCRIPTNOSCRIPTENTRIESMSG    60455
#define IDS_SCRIPTENTRIESALLOCFAILMSG   60456
#define IDS_SCRIPTENTRYALLOCFAILMSG     60457
#define IDS_SCRIPTEDITERRORMSG          60458
#define IDS_SCRIPTREADERRORMSG          60459

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        165
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1194
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\scrmap1.cpp ===
// scrmap1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "scrmap1.h"
#include "scripmap.h"
#include "addscrip.h"
#include "editscri.h"
#include "delscrip.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ScrMap1 property page

IMPLEMENT_DYNCREATE(ScrMap1, CGenPage)

ScrMap1::ScrMap1() : CGenPage(ScrMap1::IDD)
{
	//{{AFX_DATA_INIT(ScrMap1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_rkScriptKey = NULL;
	m_pseScriptMapList = NULL;

}

ScrMap1::~ScrMap1()
{
	if (m_rkScriptKey != NULL)
	   delete(m_rkScriptKey);
	DeleteScriptList();

}

void ScrMap1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ScrMap1)
	DDX_Control(pDX, IDC_SCRIPTMAPLISTBOX, m_lboxScriptMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ScrMap1, CGenPage)
	//{{AFX_MSG_MAP(ScrMap1)
	ON_BN_CLICKED(IDC_SCRIPTMAPADDBUTTON, OnScriptmapaddbutton)
	ON_BN_CLICKED(IDC_SCRIPTMAPEDITBUTTON, OnScriptmapeditbutton)
	ON_BN_CLICKED(IDC_SCRIPTMAPREMOVEBUTTON, OnScriptmapremovebutton)
	ON_LBN_DBLCLK(IDC_SCRIPTMAPLISTBOX, OnDblclkScriptmaplistbox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// ScrMap1 message handlers

BOOL ScrMap1::OnInitDialog() 
{
	CGenPage::OnInitDialog();
CString strNextValueName, strNextValue;
BOOL bAllocationError = FALSE;
CRegValueIter *rviScriptKeys;
DWORD err, ulRegType;
m_ulScriptIndex = 0;
BOOL bReadError = FALSE;
int	iTabSpacing = 58;

m_lboxScriptMap.SetTabStops(iTabSpacing);

m_bScriptEntriesExist = FALSE;

m_rkScriptKey = new CRegKey(*m_rkMainKey,_T("Script Map"),REGISTRY_ACCESS_RIGHTS);

// Anything under this key should be a mime mapping. 
// No way to verify that, but non-string entries are invalid
// so ignore them.

if (m_rkScriptKey != NULL) {
   if (*m_rkScriptKey != NULL) {
      if (rviScriptKeys = new CRegValueIter(*m_rkScriptKey)) {
         while ((err = rviScriptKeys->Next(&strNextValueName, &ulRegType)) == ERROR_SUCCESS) {
		    if (ulRegType == REG_SZ) {
		       if (m_rkScriptKey->QueryValue(strNextValueName, strNextValue) == 0) {
		          if (!AddScriptEntry(strNextValueName, strNextValue, TRUE))
			         bAllocationError = TRUE;
			   }
			   else {
			      bReadError = TRUE;
			   }
			}
   		 }
		 delete (rviScriptKeys);
	  }	
	  m_bScriptEntriesExist = TRUE;
   }
}

if (!m_bScriptEntriesExist) {				//Can't open registry key
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}

if (bAllocationError) {				//Error adding one or more entries
   CString strAllocFailMsg;
   strAllocFailMsg.LoadString(IDS_SCRIPTENTRIESALLOCFAILMSG);
   AfxMessageBox(strAllocFailMsg);
}

if (bReadError) {				//Error reading one or more entries
   CString strReadErrorMsg;
   strReadErrorMsg.LoadString(IDS_SCRIPTREADERRORMSG);
   AfxMessageBox(strReadErrorMsg);
}

	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void ScrMap1::OnScriptmapaddbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bScriptEntriesExist) {
   CAddScript addscriptGetInfo(this);	

   if (addscriptGetInfo.DoModal() == IDOK) {
      if (AddScriptEntry(addscriptGetInfo.GetFileExtension(), addscriptGetInfo.GetScriptMap(),FALSE)) {
         m_bIsDirty = TRUE;
         SetModified(TRUE);
	  }
	  else {
         CString strAllocFailMsg;
         strAllocFailMsg.LoadString(IDS_SCRIPTENTRYALLOCFAILMSG);
         AfxMessageBox(strAllocFailMsg);
	  }
   }
}
else {
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}
}

void ScrMap1::OnScriptmapeditbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bScriptEntriesExist) {
   int iCurSel;
   PSCRIPT_ENTRY pseEditEntry;


   if ((iCurSel = m_lboxScriptMap.GetCurSel())	!= LB_ERR) {
      for (pseEditEntry = m_pseScriptMapList;(pseEditEntry != NULL) && 
         (m_lboxScriptMap.GetItemData(iCurSel) != pseEditEntry->iListIndex);
         pseEditEntry = pseEditEntry->NextPtr)
         ;
   
      ASSERT (pseEditEntry != NULL);

      CEditScript editscriptGetInfo(this, 
         pseEditEntry->scriptData->GetFileExtension(),
         pseEditEntry->scriptData->GetScriptMap());

      if (editscriptGetInfo.DoModal() == IDOK) {
         if (EditScriptMapping(iCurSel, 
   	          pseEditEntry,
              editscriptGetInfo.GetFileExtension(), 
              editscriptGetInfo.GetScriptMap())) {
            m_bIsDirty = TRUE;
	        SetModified(TRUE);
		 }
		 else {
            CString strEditErrorMsg;
            strEditErrorMsg.LoadString(IDS_SCRIPTEDITERRORMSG);
            AfxMessageBox(strEditErrorMsg);
		 }
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}
}


void ScrMap1::OnScriptmapremovebutton() 
{
	// TODO: Add your control notification handler code here
if (m_bScriptEntriesExist) {
   int iCurSel;
   CDelScript delscriptGetInfo(this);

   if ((iCurSel = m_lboxScriptMap.GetCurSel())	!= LB_ERR) {
      if (delscriptGetInfo.DoModal() == IDOK) {
         DeleteScriptMapping(iCurSel);
	     m_bIsDirty = TRUE;
	     SetModified(TRUE);
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}
}

void ScrMap1::OnDblclkScriptmaplistbox() 
{
	// TODO: Add your control notification handler code here
OnScriptmapeditbutton();	
}

////////////////////////////////////////////////////////////////////////
// Other Functions

void ScrMap1::SaveInfo()
{
PSCRIPT_ENTRY pseSaveEntry;
CString strTempValue;
if (m_bIsDirty) {
   for (pseSaveEntry = m_pseScriptMapList;(pseSaveEntry != NULL); pseSaveEntry = pseSaveEntry->NextPtr) {
      if (pseSaveEntry->DeleteCurrent) {
	  	 m_rkScriptKey->DeleteValue(pseSaveEntry->scriptData->GetPrevFileExtension());
		 pseSaveEntry->DeleteCurrent = FALSE;
 	  }
      
      if (pseSaveEntry->WriteNew) {
	     strTempValue = pseSaveEntry->scriptData->GetScriptMap();
         m_rkScriptKey->SetValue(pseSaveEntry->scriptData->GetFileExtension(), strTempValue);
		 pseSaveEntry->scriptData->SetPrevFileExtension();
		 pseSaveEntry->WriteNew = FALSE;
	  }
   }

}

CGenPage::SaveInfo();

}

BOOL ScrMap1::AddScriptEntry(LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry)
{
PSCRIPT_ENTRY pseNewEntry;
int iCurSel;
BOOL bretcode = FALSE;

if ((pseNewEntry = new SCRIPT_ENTRY) != NULL) {

   if ((pseNewEntry->scriptData = new CScriptMap(pchFileExtension, pchScriptMap, bExistingEntry)) != NULL) {
      iCurSel = m_lboxScriptMap.AddString(pseNewEntry->scriptData->GetDisplayString()); 
	  if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
         pseNewEntry->DeleteCurrent = FALSE;
         pseNewEntry->WriteNew = TRUE;
         m_lboxScriptMap.SetItemData(iCurSel,m_ulScriptIndex);
	     m_lboxScriptMap.SetCurSel(iCurSel);
         pseNewEntry->iListIndex = m_ulScriptIndex++;
         pseNewEntry->NextPtr = m_pseScriptMapList;
         m_pseScriptMapList = pseNewEntry;
	     bretcode = TRUE;
	  }
	  else {
	     delete (pseNewEntry->scriptData);
		 delete (pseNewEntry);
	  }
   }
   else
      delete (pseNewEntry);
}
return (bretcode);
}

void ScrMap1::DeleteScriptList()
{
PSCRIPT_ENTRY pseCurEntry;

while (m_pseScriptMapList != NULL) {
   delete (m_pseScriptMapList->scriptData);
   pseCurEntry = m_pseScriptMapList;
   m_pseScriptMapList = m_pseScriptMapList->NextPtr;
   delete (pseCurEntry);
}
}

void ScrMap1::DeleteScriptMapping(int iCurSel)
{
PSCRIPT_ENTRY pseDelEntry;
for (pseDelEntry = m_pseScriptMapList;(pseDelEntry != NULL) && 
   (m_lboxScriptMap.GetItemData(iCurSel) != pseDelEntry->iListIndex);
   pseDelEntry = pseDelEntry->NextPtr)
   ;
ASSERT (pseDelEntry != NULL);

if (pseDelEntry->scriptData->PrevScriptMapExists())
   pseDelEntry->DeleteCurrent = TRUE;
pseDelEntry->WriteNew = FALSE;			
m_lboxScriptMap.DeleteString(iCurSel);
}
    

BOOL ScrMap1::EditScriptMapping(int iCurSel, 
   PSCRIPT_ENTRY pseEditEntry, 
   LPCTSTR pchFileExtension, 
   LPCTSTR pchScriptMap)
{
BOOL bretcode = FALSE;

pseEditEntry->scriptData->SetFileExtension(pchFileExtension);
pseEditEntry->scriptData->SetScriptMap(pchScriptMap);

m_lboxScriptMap.DeleteString(iCurSel); 		// Delete first so memory is freed
iCurSel = m_lboxScriptMap.AddString(pseEditEntry->scriptData->GetDisplayString()); 

// There error case on this is incredibly rare, so don't bother saving and restoring the above fields
// Just don't set flags so registry is not updated.

if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
   m_lboxScriptMap.SetItemData(iCurSel,pseEditEntry->iListIndex);
   if (pseEditEntry->scriptData->PrevScriptMapExists())
      pseEditEntry->DeleteCurrent = TRUE;
   
   pseEditEntry->WriteNew = TRUE;
   bretcode = TRUE;
} 

return (bretcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\ssl1.cpp ===
// ssl1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "ssl1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// SSL1 property page

IMPLEMENT_DYNCREATE(SSL1, CGenPage)

SSL1::SSL1() : CGenPage(SSL1::IDD)
{
	//{{AFX_DATA_INIT(SSL1)
	m_ulSecurePort = 0;
	//}}AFX_DATA_INIT
}

SSL1::~SSL1()
{
}

void SSL1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SSL1)
	DDX_Control(pDX, IDC_SSLENABLESSLDATA1, m_cboxEnableSSL);
	DDX_Control(pDX, IDC_SSLENABLEPCTDATA1, m_cboxEnablePCT);
	DDX_Control(pDX, IDC_SSLCREATEPROCESSASUSERDATA1, m_cboxCreateProcessAsUser);
	DDX_Text(pDX, IDC_SSLSECUREPORTDATA1, m_ulSecurePort);
	DDV_MinMaxDWord(pDX, m_ulSecurePort, 0, 4294967295);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(SSL1, CGenPage)
	//{{AFX_MSG_MAP(SSL1)
	ON_EN_CHANGE(IDC_SSLSECUREPORTDATA1, OnChangeSslsecureportdata1)
	ON_BN_CLICKED(IDC_SSLCREATEPROCESSASUSERDATA1, OnSslcreateprocessasuserdata1)
	ON_BN_CLICKED(IDC_SSLENABLEPCTDATA1, OnSslenablepctdata1)
	ON_BN_CLICKED(IDC_SSLENABLESSLDATA1, OnSslenablessldata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// SSL1 message handlers

BOOL SSL1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	for (i = 0; i < SSLPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }

 	m_binNumericRegistryEntries[SSLPage_SecurePort].strFieldName = _T(SECUREPORTNAME);	
	m_binNumericRegistryEntries[SSLPage_SecurePort].ulDefaultValue = DEFAULTSECUREPORT;

 	m_binNumericRegistryEntries[SSLPage_EncryptionFlags].strFieldName = _T(ENCRYPTIONFLAGSNAME);	
	m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulDefaultValue = DEFAULTENCRYPTIONFLAGS;

 	m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].strFieldName = _T(CREATEPROCESSASUSERNAME);	
	m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].ulDefaultValue = DEFAULTCREATEPROCESSASUSER;

	for (i = 0; i < SSLPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
 
	m_ulSecurePort =  m_binNumericRegistryEntries[SSLPage_SecurePort].ulFieldValue;

   	m_cboxEnableSSL.SetCheck(GETCHECKBOXVALUEFROMREG(
   	   (m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue & ENC_CAPS_SSL)
	   ? TRUEVALUE : FALSEVALUE));

   	m_cboxEnablePCT.SetCheck(GETCHECKBOXVALUEFROMREG(
   	   (m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue & ENC_CAPS_PCT)
	   ? TRUEVALUE : FALSEVALUE));

	m_cboxCreateProcessAsUser.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].ulFieldValue));


	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

   	m_bSetChanged = TRUE;	// Any more changes come from the user

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void SSL1::OnChangeSslsecureportdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_SecurePort].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}

}

void SSL1::OnSslcreateprocessasuserdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxCreateProcessAsUser.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void SSL1::OnSslenablepctdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_EncryptionFlags].bIsChanged = TRUE;
	   
	   if (GETREGVALUEFROMCHECKBOX(m_cboxEnablePCT.GetCheck()) == TRUEVALUE)
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue |= ENC_CAPS_PCT;
	   else
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue &= ~ENC_CAPS_PCT;

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void SSL1::OnSslenablessldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_EncryptionFlags].bIsChanged = TRUE;
	   
	   if (GETREGVALUEFROMCHECKBOX(m_cboxEnableSSL.GetCheck()) == TRUEVALUE)
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue |= ENC_CAPS_SSL;
	   else
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue &= ~ENC_CAPS_SSL;
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void SSL1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[SSLPage_SecurePort].ulFieldValue = m_ulSecurePort;

   SaveNumericInfo(m_binNumericRegistryEntries, SSLPage_TotalNumRegEntries);

}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\registry.h ===
/****************************************************************************
REGISTRY.H
****************************************************************************/
#ifndef _registry_h 

#define _registry_h


//  Forward declarations
class CRegKey ;
class CRegValueIter ;
class CRegKeyIter ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CRegKey : public CObject
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue ( const TCHAR * pchValueName,
                        DWORD * pdwType,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CStringList to the REG_MULTI_SZ format
    static LONG FlattenValue ( CStringList & strList,
                            DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CByteArray to a REG_BINARY block
    static LONG FlattenValue ( CByteArray & abData,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

public:
    //  Key information return structure
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

    //  Standard constructor for an existing key
    CRegKey ( HKEY hKeyBase,
              const TCHAR * pchSubKey = NULL,
              REGSAM regSam = KEY_ALL_ACCESS,
              const TCHAR * pchServerName = NULL ) ;

    //  Constructor creating a new key.
    CRegKey ( const TCHAR * pchSubKey,
              HKEY hKeyBase,
              DWORD dwOptions = 0,
              REGSAM regSam = KEY_ALL_ACCESS,
              LPSECURITY_ATTRIBUTES pSecAttr = NULL,
              const TCHAR * pchServerName = NULL ) ;

    ~ CRegKey () ;

    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator HKEY ()
        { return m_hKey ; }

    //  Fill a key information structure
    LONG QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
        //  if data exists but not in correct form to deliver into result object.
    LONG QueryValue ( const TCHAR * pchValueName, CString & strResult ) ;
    LONG QueryValue ( const TCHAR * pchValueName, CStringList & strList ) ;
    LONG QueryValue ( const TCHAR * pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( const TCHAR * pchValueName, CByteArray & abResult ) ;
    LONG QueryValue ( const TCHAR * pchValueName, void * pvResult, DWORD cbSize );

    //  Overloaded value setting members.
    LONG SetValue ( const TCHAR * pchValueName, CString & strResult ) ;
    LONG SetValue ( const TCHAR * pchValueName, CStringList & strList ) ;
    LONG SetValue ( const TCHAR * pchValueName, DWORD & dwResult ) ;
    LONG SetValue ( const TCHAR * pchValueName, CByteArray & abResult ) ;
    LONG SetValue ( const TCHAR * pchValueName, void * pvResult, DWORD cbSize );
    LONG DeleteValue ( const TCHAR * pchValueName);
};


    //  Iterate the values of a key, return the name and type
    //  of each.
class CRegValueIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegValueIter ( CRegKey & regKey ) ;
    ~ CRegValueIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, DWORD * pdwType ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

    //  Iterate the sub-key names of a key.
class CRegKeyIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegKeyIter ( CRegKey & regKey ) ;
    ~ CRegKeyIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, CTime * pTime = NULL ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ISAdmin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\ssl1.h ===
// ssl1.h : header file
//

#define SECUREPORTNAME			"SecurePort"
#define DEFAULTSECUREPORT		443

#define ENCRYPTIONFLAGSNAME			"EncryptionFlags"
#define DEFAULTENCRYPTIONFLAGS		ENC_CAPS_SSL | ENC_CAPS_PCT

#define CREATEPROCESSASUSERNAME			"CreateProcessAsUser"
#define DEFAULTCREATEPROCESSASUSER		TRUEVALUE

enum SSL_NUM_REG_ENTRIES {
	 SSLPage_SecurePort,
	 SSLPage_EncryptionFlags,
	 SSLPage_CreateProcessAsUser,
	 SSLPage_TotalNumRegEntries
	 };


/////////////////////////////////////////////////////////////////////////////
// SSL1 dialog

class SSL1 : public CGenPage
{
	DECLARE_DYNCREATE(SSL1)

// Construction
public:
	SSL1();
	~SSL1();

// Dialog Data
	//{{AFX_DATA(SSL1)
	enum { IDD = IDD_SSL };
	CButton	m_cboxEnableSSL;
	CButton	m_cboxEnablePCT;
	CButton	m_cboxCreateProcessAsUser;
	DWORD	m_ulSecurePort;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(SSL1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(SSL1)
	afx_msg void OnChangeSslsecureportdata1();
	afx_msg void OnSslcreateprocessasuserdata1();
	afx_msg void OnSslenablepctdata1();
	afx_msg void OnSslenablessldata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	NUM_REG_ENTRY m_binNumericRegistryEntries[SSLPage_TotalNumRegEntries];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\webgenp1.cpp ===
// webgenp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "compsdef.h"
#include "webgenp1.h"
#include "webadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWEBGENP1 property page

IMPLEMENT_DYNCREATE(CWEBGENP1, CGenPage)

CWEBGENP1::CWEBGENP1() : CGenPage(CWEBGENP1::IDD)
{
	//{{AFX_DATA_INIT(CWEBGENP1)
	m_strWebAccessDeniedMessage = _T("");
	//}}AFX_DATA_INIT
}

CWEBGENP1::~CWEBGENP1()
{
}

void CWEBGENP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWEBGENP1)
	DDX_Control(pDX, IDC_DIRBROWSECONTROLDATA1, m_editDirBrowseControl);
	DDX_Control(pDX, IDC_MAXCONNECTIONSSPIN1, m_spinMaxConnections);
	DDX_Control(pDX, IDC_LOGNONANONDATA1, m_cboxLogNonAnon);
	DDX_Control(pDX, IDC_LOGANONDATA1, m_cboxLogAnon);
	DDX_Control(pDX, IDC_ENWAISDATA1, m_cboxEnWais);
	DDX_Control(pDX, IDC_ENSVCLOCDATA1, m_cboxEnSvcLoc);
	DDX_TexttoHex(pDX, IDC_DIRBROWSECONTROLDATA1, m_ulDirBrowseControl);
	DDX_Text(pDX, IDC_NTAUTHENTICATIONPROVIDERSDATA1, m_strNTAuthenticationProviders);
	DDV_MaxChars(pDX, m_strNTAuthenticationProviders, 512);
	DDX_Text(pDX, IDC_WEBACCESSDENIEDMESSAGEDATA1, m_strWebAccessDeniedMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWEBGENP1, CGenPage)
	//{{AFX_MSG_MAP(CWEBGENP1)
	ON_BN_CLICKED(IDC_ENSVCLOCDATA1, OnEnsvclocdata1)
	ON_BN_CLICKED(IDC_ENWAISDATA1, OnEnwaisdata1)
	ON_BN_CLICKED(IDC_LOGANONDATA1, OnLoganondata1)
	ON_BN_CLICKED(IDC_LOGNONANONDATA1, OnLognonanondata1)
	ON_EN_CHANGE(IDC_MAXCONNECTIONSDATA1, OnChangeMaxconnectionsdata1)
	ON_EN_CHANGE(IDC_DIRBROWSECONTROLDATA1, OnChangeDirbrowsecontroldata1)
	ON_EN_CHANGE(IDC_NTAUTHENTICATIONPROVIDERSDATA1, OnChangeNtauthenticationprovidersdata1)
	ON_EN_CHANGE(IDC_WEBACCESSDENIEDMESSAGEDATA1, OnChangeWebaccessdeniedmessagedata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWEBGENP1 message handlers

BOOL CWEBGENP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	for (i = 0; i < WebPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	for (i = 0; i < WebPage_TotalStringRegEntries; i++) {
	   m_binStringRegistryEntries[i].bIsChanged = FALSE;
	   }
	
	m_binNumericRegistryEntries[WebPage_EnableSvcLoc].strFieldName = _T(ENABLESVCLOCNAME);	
	m_binNumericRegistryEntries[WebPage_EnableSvcLoc].ulDefaultValue = DEFAULTENABLESVCLOC;

	m_binNumericRegistryEntries[WebPage_LogAnonymous].strFieldName = _T(LOGANONYMOUSNAME);	
	m_binNumericRegistryEntries[WebPage_LogAnonymous].ulDefaultValue = DEFAULTLOGANONYMOUS;

	m_binNumericRegistryEntries[WebPage_LogNonAnonymous].strFieldName = _T(LOGNONANONYMOUSNAME);	
	m_binNumericRegistryEntries[WebPage_LogNonAnonymous].ulDefaultValue = DEFAULTLOGNONANONYMOUS;

	m_binNumericRegistryEntries[WebPage_CheckForWAISDB].strFieldName = _T(CHECKFORWAISDBNAME);	
	m_binNumericRegistryEntries[WebPage_CheckForWAISDB].ulDefaultValue = DEFAULTCHECKFORWAISDB;

	m_binNumericRegistryEntries[WebPage_MaxConnections].strFieldName = _T(MAXCONNECTIONSNAME);	
	m_binNumericRegistryEntries[WebPage_MaxConnections].ulMultipleFactor = 100;
	m_binNumericRegistryEntries[WebPage_MaxConnections].ulDefaultValue = DEFAULTMAXCONNECTIONS;
	
	m_binNumericRegistryEntries[WebPage_DirBrowseControl].strFieldName = _T(DIRBROWSECONTROLNAME);	
	m_binNumericRegistryEntries[WebPage_DirBrowseControl].ulDefaultValue = DEFAULTDIRBROWSECONTROL;
	
	m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldName = _T(NTAUTHENTICATIONPROVIDERSNAME);	
	m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldValue = _T(DEFAULTNTAUTHENTICATIONPROVIDERS);
	
	m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldName = _T(ACCESSDENIEDMESSAGENAME);	
	m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldValue = _T(DEFAULTACCESSDENIEDMESSAGE);
	
	for (i = 0; i < WebPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }

	}

	for (i = 0; i < WebPage_TotalStringRegEntries; i++) {
	   m_rkMainKey->QueryValue(m_binStringRegistryEntries[i].strFieldName, 
	      m_binStringRegistryEntries[i].strFieldValue);
	}

	m_cboxEnSvcLoc.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_EnableSvcLoc].ulFieldValue));

	m_cboxLogAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_LogAnonymous].ulFieldValue));
	
	m_cboxLogNonAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_LogNonAnonymous].ulFieldValue));
	
	m_cboxEnWais.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_CheckForWAISDB].ulFieldValue));
	
	m_spinMaxConnections.SetRange(MINMAXCONNECTIONS, MAXMAXCONNECTIONS);
	m_spinMaxConnections.SetPos(LESSOROF((m_binNumericRegistryEntries[WebPage_MaxConnections].ulFieldValue / 
	   m_binNumericRegistryEntries[WebPage_MaxConnections].ulMultipleFactor), MAXMAXCONNECTIONS));
  
   	m_editDirBrowseControl.LimitText(8);
	m_ulDirBrowseControl = m_binNumericRegistryEntries[WebPage_DirBrowseControl].ulFieldValue;

	m_strNTAuthenticationProviders =  m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldValue;
	m_strWebAccessDeniedMessage =  m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldValue;

	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)



   	m_bSetChanged = TRUE;	// Any more changes come from the user
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWEBGENP1::OnEnsvclocdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_EnableSvcLoc].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_EnableSvcLoc].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnSvcLoc.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnEnwaisdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_CheckForWAISDB].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_CheckForWAISDB].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnWais.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnLoganondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_LogAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_LogAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnLognonanondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_LogNonAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_LogNonAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogNonAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}


void CWEBGENP1::OnChangeMaxconnectionsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_MaxConnections].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[WebPage_MaxConnections].ulFieldValue = m_spinMaxConnections.GetPos() 
	      * m_binNumericRegistryEntries[WebPage_MaxConnections].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnChangeDirbrowsecontroldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_DirBrowseControl].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnChangeNtauthenticationprovidersdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}


void CWEBGENP1::OnChangeWebaccessdeniedmessagedata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binStringRegistryEntries[WebPage_AccessDeniedMessage].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CWEBGENP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[WebPage_DirBrowseControl].ulFieldValue = m_ulDirBrowseControl;

   m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldValue = m_strNTAuthenticationProviders;
   m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldValue = m_strWebAccessDeniedMessage;

   SaveNumericInfo(m_binNumericRegistryEntries, WebPage_TotalNumRegEntries);
   SaveStringInfo(m_binStringRegistryEntries, WebPage_TotalStringRegEntries);


}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\webadvp1.cpp ===
// webadvp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "webadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWEBADVP1 dialog

IMPLEMENT_DYNCREATE(CWEBADVP1, CGenPage)

CWEBADVP1::CWEBADVP1()	: CGenPage(CWEBADVP1::IDD)
{
	//{{AFX_DATA_INIT(CWEBADVP1)
	m_strServerSideIncludesExtension = _T("");
	//}}AFX_DATA_INIT
}

CWEBADVP1::~CWEBADVP1()
{
}


void CWEBADVP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWEBADVP1)
	DDX_Control(pDX, IDC_SERVERSIDEINCLUDESEXTENSIONDATA1, m_editServerSideIncludesExtension);
	DDX_Control(pDX, IDC_SERVERSIDEINCLUDESENABLEDDATA1, m_cboxServerSideIncludesEnabled);
	DDX_Control(pDX, IDC_ENABLEGLOBALEXPIREDATA1, m_cboxEnableGlobalExpire);
	DDX_Control(pDX, IDC_GLOBALEXPIREDATA1, m_editGlobalExpire);
	DDX_Control(pDX, IDC_GLOBALEXPIRESPIN1, m_spinGlobalExpire);
	DDX_Control(pDX, IDC_CACHEEXTENSIONSDATA1, m_cboxCacheExtensions);
	DDX_Control(pDX, IDC_SCRIPTTIMEOUTSPIN1, m_spinScriptTimeout);
	DDX_Control(pDX, IDC_WEBDBGFLAGSDATA1, m_editWebDbgFlags);
	DDX_TexttoHex(pDX, IDC_WEBDBGFLAGSDATA1, m_ulWebDbgFlags);
	DDX_Text(pDX, IDC_SERVERSIDEINCLUDESEXTENSIONDATA1, m_strServerSideIncludesExtension);
	DDV_MaxChars(pDX, m_strServerSideIncludesExtension, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWEBADVP1, CGenPage)
	//{{AFX_MSG_MAP(CWEBADVP1)
	ON_EN_CHANGE(IDC_WEBDBGFLAGSDATA1, OnChangeWebdbgflagsdata1)
	ON_EN_CHANGE(IDC_SCRIPTTIMEOUTDATA1, OnChangeScripttimeoutdata1)
	ON_BN_CLICKED(IDC_CACHEEXTENSIONSDATA1, OnCacheextensionsdata1)
	ON_EN_CHANGE(IDC_GLOBALEXPIREDATA1, OnChangeGlobalexpiredata1)
	ON_BN_CLICKED(IDC_ENABLEGLOBALEXPIREDATA1, OnEnableglobalexpiredata1)
	ON_EN_CHANGE(IDC_SERVERSIDEINCLUDESEXTENSIONDATA1, OnChangeServersideincludesextensiondata1)
	ON_BN_CLICKED(IDC_SERVERSIDEINCLUDESENABLEDDATA1, OnServersideincludesenableddata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWEBADVP1 message handlers

BOOL CWEBADVP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	for (i = 0; i < AdvWebPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	for (i = 0; i < AdvWebPage_TotalStringRegEntries; i++) {
	   m_binStringRegistryEntries[i].bIsChanged = FALSE;
	   }
	

 	m_binNumericRegistryEntries[AdvWebPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvWebPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;

 	m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].strFieldName = _T(SCRIPTTIMEOUTNAME);	
 	m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulMultipleFactor = 60;
	m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulDefaultValue = DEFAULTSCRIPTTIMEOUT;

 	m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].strFieldName = _T(CACHEEXTENSIONSNAME);	
	m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].ulDefaultValue = DEFAULTCACHEEXTENSIONS;

	m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].strFieldName = _T(SERVERSIDEINCLUDESENABLEDNAME);	
	m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].ulDefaultValue = DEFAULTSERVERSIDEINCLUDESENABLED;

	m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].strFieldName = _T(GLOBALEXPIRENAME);	
	m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulDefaultValue = DEFAULTGLOBALEXPIRE;
	m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor = 60;

	m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldName = _T(SERVERSIDEINCLUDESEXTENSIONNAME);	
	m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldValue = _T(DEFAULTSERVERSIDEINCLUDESEXTENSION);
	
	for (i = 0; i < AdvWebPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
 
 	for (i = 0; i < AdvWebPage_TotalStringRegEntries; i++) {
	   m_rkMainKey->QueryValue(m_binStringRegistryEntries[i].strFieldName, 
	      m_binStringRegistryEntries[i].strFieldValue);
	}
   	
	m_spinScriptTimeout.SetRange(MINSCRIPTTIMEOUT, MAXSCRIPTTIMEOUT);
	m_spinScriptTimeout.SetPos(LESSOROF((m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulMultipleFactor), MAXSCRIPTTIMEOUT));
   	
	m_cboxCacheExtensions.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].ulFieldValue));

 	m_strServerSideIncludesExtension =  m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldValue;

	m_cboxServerSideIncludesEnabled.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].ulFieldValue));
	SetServerSideIncludesEnabledState();
	

	m_spinGlobalExpire.SetRange(MINGLOBALEXPIRE, MAXGLOBALEXPIRE);
	if (m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue != 0xffffffff) {
	   m_spinGlobalExpire.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue / 
	      m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor),MAXGLOBALEXPIRE));
	   SetGlobalExpireEnabledState(TRUE);
	}
	else {
	   m_spinGlobalExpire.SetPos(LESSOROF((m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulDefaultValue /
  	      m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor),MAXGLOBALEXPIRE));
	   SetGlobalExpireEnabledState(FALSE);
	}


	m_editWebDbgFlags.LimitText(8);
	m_ulWebDbgFlags = m_binNumericRegistryEntries[AdvWebPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWEBADVP1::OnChangeWebdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}

}


void CWEBADVP1::OnChangeScripttimeoutdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].bIsChanged = TRUE;
	   m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulFieldValue = m_spinScriptTimeout.GetPos() * 
	      m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulMultipleFactor;		
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CWEBADVP1::OnCacheextensionsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxCacheExtensions.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBADVP1::OnServersideincludesenableddata1() 
{
	// TODO: Add your control notification handler code here
	SetServerSideIncludesEnabledState();

	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxServerSideIncludesEnabled.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CWEBADVP1::OnChangeServersideincludesextensiondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}

}


void CWEBADVP1::OnEnableglobalexpiredata1() 
{
	// TODO: Add your control notification handler code here
SetGlobalExpireEnabledState(m_cboxEnableGlobalExpire.GetCheck());
if (m_bSetChanged) {
   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].bIsChanged = TRUE;	

   m_bIsDirty = TRUE;
   SetModified(TRUE);
   }


}
void CWEBADVP1::OnChangeGlobalexpiredata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue = m_spinGlobalExpire.GetPos() 
	      * m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBADVP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvWebPage_DebugFlags].ulFieldValue = m_ulWebDbgFlags;
   m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldValue = m_strServerSideIncludesExtension;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvWebPage_TotalNumRegEntries);
   SaveStringInfo(m_binStringRegistryEntries, AdvWebPage_TotalStringRegEntries);

}

CGenPage::SaveInfo();

}


void CWEBADVP1::SetGlobalExpireEnabledState(BOOL bEnabled)
{
	if (bEnabled) {
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue = 
	      m_spinGlobalExpire.GetPos() * 
	      m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor;
	   m_cboxEnableGlobalExpire.SetCheck(CHECKEDVALUE);
	   m_spinGlobalExpire.EnableWindow(TRUE);
	   m_editGlobalExpire.EnableWindow(TRUE);
	}
	else {
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue = 0xffffffff;
	   m_cboxEnableGlobalExpire.SetCheck(UNCHECKEDVALUE);
	   m_spinGlobalExpire.EnableWindow(FALSE);
	   m_editGlobalExpire.EnableWindow(FALSE);
	}
}	


void CWEBADVP1::SetServerSideIncludesEnabledState()
{
if (m_cboxServerSideIncludesEnabled.GetCheck() != 0) {
   m_editServerSideIncludesExtension.EnableWindow(TRUE);
   if (m_bSetChanged) {		//if user enabled this, make sure there's a value there
	  m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].bIsChanged = TRUE;	
   }  // Don't need to set bIsDirty, as get's set anyway
}
else {
   m_editServerSideIncludesExtension.EnableWindow(FALSE);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\webadvp1.h ===
// webadvp1.h : header file
//

#define CACHEEXTENSIONSNAME	"CacheExtensions"
#define DEFAULTCACHEEXTENSIONS	TRUEVALUE

#define SCRIPTTIMEOUTNAME	"ScriptTimeout"
#define MINSCRIPTTIMEOUT	0
#define MAXSCRIPTTIMEOUT	0x7FFF							//Specify in minutes
#define DEFAULTSCRIPTTIMEOUT	(60 * 15)

#define SERVERSIDEINCLUDESENABLEDNAME		"ServerSideIncludesEnabled"
#define DEFAULTSERVERSIDEINCLUDESENABLED	TRUEVALUE

#define SERVERSIDEINCLUDESEXTENSIONNAME		"ServerSideIncludesExtension"
#define	DEFAULTSERVERSIDEINCLUDESEXTENSION	".stm"


#define GLOBALEXPIRENAME	"GlobalExpire"
#define MINGLOBALEXPIRE	0
#define MAXGLOBALEXPIRE	0x7FFF 						//Specify in Minutes
#define DEFAULTGLOBALEXPIRE	0xffffffff


enum ADV_WEB_NUM_REG_ENTRIES {
	 AdvWebPage_ScriptTimeout,
	 AdvWebPage_CacheExtensions,
	 AdvWebPage_ServerSideIncludesEnabled,
	 AdvWebPage_GlobalExpire,
	 AdvWebPage_DebugFlags,
	 AdvWebPage_TotalNumRegEntries
	 };

enum ADV_WEB_STRING_REG_ENTRIES {
	 AdvWebPage_ServerSideIncludesExtension,
	 AdvWebPage_TotalStringRegEntries
	 };


/////////////////////////////////////////////////////////////////////////////
// CWEBADVP1 dialog

class CWEBADVP1 : public CGenPage
{	 	
	DECLARE_DYNCREATE(CWEBADVP1)
// Construction
public:
	CWEBADVP1(); 
	~CWEBADVP1();

	// Dialog Data
	//{{AFX_DATA(CWEBADVP1)
	enum { IDD = IDD_WEBADVPAGE1 };
	CEdit	m_editServerSideIncludesExtension;
	CButton	m_cboxServerSideIncludesEnabled;
	CButton	m_cboxEnableGlobalExpire;
	CEdit	m_editGlobalExpire;
	CSpinButtonCtrl	m_spinGlobalExpire;
	CButton	m_cboxCacheExtensions;
	CSpinButtonCtrl	m_spinScriptTimeout;
	CEdit	m_editWebDbgFlags;
	DWORD	m_ulWebDbgFlags;
	CString	m_strServerSideIncludesExtension;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWEBADVP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWEBADVP1)
	afx_msg void OnChangeWebdbgflagsdata1();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeScripttimeoutdata1();
	afx_msg void OnCacheextensionsdata1();
	afx_msg void OnChangeGlobalexpiredata1();
	afx_msg void OnEnableglobalexpiredata1();
	afx_msg void OnChangeServersideincludesextensiondata1();
	afx_msg void OnServersideincludesenableddata1();
	//}}AFX_MSG

	void SetGlobalExpireEnabledState(BOOL bEnabled);
	void SetServerSideIncludesEnabledState();

	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvWebPage_TotalNumRegEntries];
	STRING_REG_ENTRY m_binStringRegistryEntries[AdvWebPage_TotalStringRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\isadmin\webgenp1.h ===
// webgenp1.h : header file
//

#define MAXCONNECTIONSNAME	"MaxConnections"
#define MINMAXCONNECTIONS	0
#define MAXMAXCONNECTIONS	0x7fff
#define DEFAULTMAXCONNECTIONS	20 * 100

#define DIRBROWSECONTROLNAME	"Dir Browse Control"
#define DEFAULTDIRBROWSECONTROL	0xc000001e

#define NTAUTHENTICATIONPROVIDERSNAME	"NTAuthenticationProviders"
#define DEFAULTNTAUTHENTICATIONPROVIDERS  "NTLM"

#define ACCESSDENIEDMESSAGENAME	"AccessDeniedMessage"
#define DEFAULTACCESSDENIEDMESSAGE  ""

enum  WEB_NUM_REG_ENTRIES {
     WebPage_EnableSvcLoc,
	 WebPage_LogAnonymous,
	 WebPage_LogNonAnonymous,
	 WebPage_CheckForWAISDB,
	 WebPage_MaxConnections,
	 WebPage_DirBrowseControl,
	 WebPage_TotalNumRegEntries
	 };

enum  WEB_STRING_REG_ENTRIES {
	WebPage_NTAuthenticationProviders,
	WebPage_AccessDeniedMessage,
	WebPage_TotalStringRegEntries
	};

/////////////////////////////////////////////////////////////////////////////
// CWEBGENP1 dialog

class CWEBGENP1 : public CGenPage
{
	DECLARE_DYNCREATE(CWEBGENP1)

// Construction
public:
	CWEBGENP1();
	~CWEBGENP1();

// Dialog Data
	//{{AFX_DATA(CWEBGENP1)
	enum { IDD = IDD_WEBGENPAGE1 };
	CEdit	m_editDirBrowseControl;
	CSpinButtonCtrl	m_spinMaxConnections;
	CButton	m_cboxLogNonAnon;
	CButton	m_cboxLogAnon;
	CButton	m_cboxEnWais;
	CButton	m_cboxEnSvcLoc;
	DWORD	m_ulDirBrowseControl;
	CString	m_strNTAuthenticationProviders;
	CString	m_strWebAccessDeniedMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWEBGENP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWEBGENP1)
	afx_msg void OnEnsvclocdata1();
	afx_msg void OnEnwaisdata1();
	afx_msg void OnLoganondata1();
	afx_msg void OnLognonanondata1();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeMaxconnectionsdata1();
	afx_msg void OnChangeDirbrowsecontroldata1();
	afx_msg void OnChangeNtauthenticatoinprovidersdata1();
	afx_msg void OnChangeNtauthenticationprovidersdata1();
	afx_msg void OnChangeWebaccessdeniedmessagedata1();
	//}}AFX_MSG
	NUM_REG_ENTRY m_binNumericRegistryEntries[WebPage_TotalNumRegEntries];
	STRING_REG_ENTRY m_binStringRegistryEntries[WebPage_TotalStringRegEntries];

	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\keyring\setup\dll\main.cpp ===
// main routine for the dll


void main ( void )
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\keyring\setup\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by setup.rc
//
#define IDB_ALL_BTN                     101
#define IDB_CUST_BTN                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\appdlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        appdlg.h

   Abstract:

        CAppDialog dialog class declaration. This is the base clas for 
        the main dialog. This class resposible for adding "about.." to
        system menu and application icon.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _APPDLG_H_
#define _APPDLG_H_

//---------------------------------------------------------------------------
// This is the base clas for the main dialog. This class resposible for 
// adding "about.." to system menu and application icon.
//
class CAppDialog : public CDialog
{

// Construction
public:
	CAppDialog(UINT nIDTemplate, CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAppDialog)
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAppDialog)
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CAppDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _APPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\appdlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        appdlg.cpp

   Abstract:

        CAppDialog dialog class implementation. This is the base clas for 
        the main dialog. This class resposible for adding "about.." to
        system menu and application icon.

        CAboutDialog dialog class declaration/implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include "appdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------------------------
// CAboutDlg dialog
//

// About dialog class
class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CAboutDlg


CAboutDlg::CAboutDlg(
    ) : 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - Pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void 
CAboutDlg::DoDataExchange(
    CDataExchange* pDX
    )
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_ABOUT_OK, CDialog::OnOK)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
// CAppDialog dialog
//

CAppDialog::CAppDialog(
    UINT nIDTemplate, 
    CWnd* pParent /*=NULL*/
    ) : 
/*++

Routine Description:

    Constructor.

Arguments:

    nIDTemplate - dialog template resource ID
    pParent - pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(nIDTemplate, pParent)
{
	//{{AFX_DATA_INIT(CAppDialog)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}


BEGIN_MESSAGE_MAP(CAppDialog, CDialog)
	//{{AFX_MSG_MAP(CAppDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
// CAppDialog message handlers
//

BOOL 
CAppDialog::OnInitDialog(
)
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control

} // CAppDialog::OnInitDialog


void 
CAppDialog::OnSysCommand(
    UINT nID, 
    LPARAM lParam
    )
/*++

Routine Description:

    WM_SYSCOMMAND message handler

Arguments:

    nID - 
    lParam -

Return Value:

    N/A

--*/
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}

} // CAppDialog::OnSysCommand


void 
CAppDialog::OnPaint(
    ) 
/*++

Routine Description:

    WM_PAINT message handler.
    If you add a minimize button to your dialog, you will need the code below
    to draw the icon.  For MFC applications using the document/view model,
    this is automatically done for you by the framework.


Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}

}  // CAppDialog::OnPaint


HCURSOR CAppDialog::OnQueryDragIcon()
/*++

Routine Description:

    The system calls this to obtain the cursor to display while the user drags
    the minimized window.


Arguments:

    N/A

Return Value:

    HCURSOR - 

--*/
{
	return (HCURSOR) m_hIcon;

} // CAppDialog::OnQueryDragIcon
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\athendlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        athendlg.h

   Abstract:

        CAthenicationDialog dialog declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _ATHENDLG_H_
#define _ATHENDLG_H_

//---------------------------------------------------------------------------
// Athenication dialog class
//
class CAthenicationDialog : public CDialog
{

// Construction
public:
	CAthenicationDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAthenicationDialog)
	enum { IDD = IDD_ATHENICATION };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAthenicationDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAthenicationDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _ATHENDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\athendlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        athendlg.cpp

   Abstract:

        CAthenicationDialog dialog implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "athendlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CAthenicationDialog::CAthenicationDialog(
    CWnd* pParent /*=NULL*/
    ): 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - Pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(CAthenicationDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAthenicationDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

} // CAthenicationDialog::CAthenicationDialog


void 
CAthenicationDialog::DoDataExchange(
    CDataExchange* pDX
    )
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAthenicationDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

} // CAthenicationDialog::DoDataExchange


BEGIN_MESSAGE_MAP(CAthenicationDialog, CDialog)
	//{{AFX_MSG_MAP(CAthenicationDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_ATHENICATION_OK, CDialog::OnOK)
	ON_BN_CLICKED(IDC_ATHENICATION_CANCEL, CDialog::OnCancel)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\browser.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        browser.h

   Abstract:

         Hard coded available browser & language emulation. This
         should be read from browser.ini file.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _BROWSER_H_
#define _BROWSER_H_

#include "useropt.h"

//------------------------------------------------------------------
// Browsers Available
//
const CBrowserInfo BrowsersAvailable_c[] = 
{
	CBrowserInfo(_T("Microsoft Internet Explorer 1.5"),
		_T("Mozilla/1.22 (compatible; MSIE 1.5; Windows NT)"), FALSE),

	CBrowserInfo(_T("Microsoft Internet Explorer 2.0"),
		_T("Mozilla/1.22 (compatible; MSIE 2.0; Windows NT)"), FALSE),

	CBrowserInfo(_T("Microsoft Internet Explorer 3.0"),
		_T("Mozilla/2.0 (compatible; MSIE 3.0; Windows NT)"), TRUE),
	
	CBrowserInfo(_T("Netscape 2.0"),
		_T("Mozilla/2.0 (WinNT; I)"), FALSE),

	CBrowserInfo(_T("Netscape 3.0"),
		_T("Mozilla/3.0Gold (WinNT; I)"), FALSE),

	CBrowserInfo(_T("Oracle 1.5"), 
		_T("Mozilla/2.01 (Compatible) Oracle(tm) PowerBrowser(tm)/1.0a"), FALSE)
};
const int iNumBrowsersAvailable_c = sizeof(BrowsersAvailable_c) / sizeof(CBrowserInfo);

//------------------------------------------------------------------
// Languages Available
//
const CLanguageInfo LanguagesAvailable_c[] = 
{
	CLanguageInfo(_T("English"), _T("en"), TRUE)
};
const int iNumLanguagesAvailable_c = sizeof(LanguagesAvailable_c) / sizeof(CLanguageInfo);

#endif // _BROWSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\cmdline.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        cmdline.cpp

   Abstract:

        Command line class implementation. This class takes care of command line
		parsing and validation. And, it will add the user options to global
		CUserOptions object.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "cmdline.h"

#include "resource.h"
#include "lcmgr.h"
#include "iisinfo.h"
#include "afxpriv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CCmdLine::CCmdLine(
	)
/*++

Routine Description:

    Constructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    m_iInstance = -1;
	m_fInvalidParam = FALSE;

} // CCmdLine::CCmdLine


BOOL 
CCmdLine::CheckAndAddToUserOptions(
	)
/*++

Routine Description:

    Validate the command line paramters and add them to global CUserOptions object

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise

--*/
{
    // Do we have any invalid parameters so far?
	if(m_fInvalidParam)
	{
        ::MessageBeep(MB_ICONEXCLAMATION);

		CDialog dlg(IDD_USAGE);
		dlg.DoModal();

		return FALSE;
	}

    // Is the user options valid ?
	BOOL fURL = !m_strURL.IsEmpty();
	BOOL fDirectories = !m_strAlias.IsEmpty() && !m_strPath.IsEmpty() && !m_strHostName.IsEmpty();
	BOOL fInstance = !m_strHostName.IsEmpty() && m_iInstance != -1;

    //  Command line: linkchk -u URL
	if(fURL && !fDirectories && !fInstance)
	{
		GetLinkCheckerMgr().GetUserOptions().AddURL(m_strURL);
		return TRUE;
	}
    //  Command line: linkchk -s ServerName -a VirtualDirectoryAlias -p VirtualDirectoryPath
	else if(!fURL && fDirectories && !fInstance)
	{
		GetLinkCheckerMgr().GetUserOptions().AddDirectory(CVirtualDirInfo(m_strAlias, m_strPath));
		GetLinkCheckerMgr().GetUserOptions().SetHostName(m_strHostName);
		return TRUE;
	}
    //  Command line: linkchk -s ServerName -i InstanceNumber
	else if(!fURL && !fDirectories && fInstance)
	{
		GetLinkCheckerMgr().GetUserOptions().SetHostName(m_strHostName);
		return QueryAndAddDirectories();
	}
    else
    {
        ::MessageBeep(MB_ICONEXCLAMATION);

		CDialog dlg(IDD_USAGE);
		dlg.DoModal();

		return FALSE;
    }

} // CCmdLine::CheckAndAddToUserOptions


void 
CCmdLine::ParseParam(
	TCHAR chFlag, 
	LPCTSTR lpszParam
	)
/*++

Routine Description:

    Called by CLinkCheckApp for each parameters.

Arguments:

    chFlag - parameter flag
    lpszParam - value

Return Value:

    N/A

--*/
{
	// It is invalid to have a flag without any parameters
	if(lpszParam == NULL)
	{
		m_fInvalidParam = TRUE;
		return;
	}

	switch(chFlag)
	{
	case _TCHAR('a'):
		m_strAlias = lpszParam;
		break;

	case _TCHAR('h'):
		m_strHostName = lpszParam;
		break;

	case _TCHAR('i'):
		m_iInstance = _ttoi(lpszParam);
		break;

	case _TCHAR('u'):
		m_strURL = lpszParam;
		break;

	case _TCHAR('p'):
		m_strPath = lpszParam;

	default: // unknown flag
		m_fInvalidParam = FALSE;
	}

} // CCmdLine::ParseParam


BOOL
CCmdLine::QueryAndAddDirectories(
	)
/*++

Routine Description:

    Query the metabase for server/instance directories and 
    add them to the global CUserOptions object

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise

--*/
{

	USES_CONVERSION; // for A2W

    // Get the server info
	LPIIS_INSTANCE_INFO_1 lpInfo = NULL;
    NET_API_STATUS err = IISGetAdminInformation(
                                A2W((LPCSTR)m_strHostName),
                                1,
                                INET_HTTP_SVC_ID,
                                m_iInstance,
                                (LPBYTE*)&lpInfo
                                );

	if(err != ERROR_SUCCESS)
	{
		AfxMessageBox(IDS_IISGETADMININFORMATION_ERROR);
		return FALSE;
	}
	
    // Do we have any virtual directories ?
    if(lpInfo->VirtualRoots == NULL)
    {
        AfxMessageBox(IDS_IIS_VIRTUALROOT_NOT_EXIST);
        return FALSE;
    }

    // Get the virutal directory info
	_INET_INFO_VIRTUAL_ROOT_ENTRY_1* pVRoot = NULL;

	for(DWORD i=0; i<lpInfo->VirtualRoots->cEntries; i++)
    {
		pVRoot = &(lpInfo->VirtualRoots->aVirtRootEntry[i]);
		GetLinkCheckerMgr().GetUserOptions().
			AddDirectory(CVirtualDirInfo(pVRoot->pszRoot, pVRoot->pszDirectory));
	}

	return TRUE;

} // CCmdLine::QueryAndAddDirectories
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\errlog.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        errlog.h

   Abstract:

        Error logging object declarations. This object will log the link
        checking error according to the user options (CUserOptions)

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _ERRLOG_H_
#define _ERRLOG_H_

//---------------------------------------------------------------------------
// Forward declaration
//
class CLink;

//---------------------------------------------------------------------------
// Error logging class
//
class CErrorLog
{

// Public interfaces
public:

    // Destructor
	~CErrorLog();

    // Create object
	BOOL Create();

    // Write to log
	void Write(
        const CLink& link
        );

    // Set the current browser name
	void SetBrowser(
        const CString& strBrowser
        )
	{
		m_strBrowser = strBrowser;
	}

    // Set the current language name
	void SetLanguage(
        const CString& strLanguage
        )
	{
		m_strLanguage = strLanguage;
	}

    // Write the log header & footer
	void WriteHeader();
	void WriteFooter();

// Protected members
protected:

	CFile m_LogFile; // log file object

	CString m_strBrowser;   // current browser name
	CString m_strLanguage;  // current language name

}; // class CErrorLog

#endif // _ERRLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\cmdline.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        cmdline.h

   Abstract:

        Command line class declarations. This class takes care of command line
		parsing and validation. And, it will add the user options to global
		CUserOptions object.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _CMDINFO_H_
#define _CMDINFO_H_

#include "lcmgr.h"

//---------------------------------------------------------------------------
// Command line class. It accepts 3 valid set of parameters
//  1. linkchk -s ServerName -i InstanceNumber
//  2. linkchk -s ServerName -a VirtualDirectoryAlias -p VirtualDirectoryPath
//  3. linkchk -u URL
//
class CCmdLine
{

// Public interfaces
public:

	// Constructor
	CCmdLine();

	// Validate the command line paramters and add them to global CUserOptions object
	BOOL CheckAndAddToUserOptions();

    // Called by CLinkCheckApp for each parameters
	void ParseParam(
		TCHAR chFlag,       // parameter flag
		LPCTSTR lpszParam   // value
		);

// Protected funtions
protected:

    // Query the metabase for server/instance directories and 
    // add them to the global CUserOptions object
	BOOL QueryAndAddDirectories();

// Protected members
protected:

	CString m_strHostName;      // hostname (eg. localhost)
	CString m_strAlias;         // virtual directory alias
	CString m_strPath;          // virtual directory path
	
	int m_iInstance;            // server instance

	CString m_strURL;           // URL path

	BOOL m_fInvalidParam;       // Is parameters invalid?

}; // class CCmdLine

#endif // _CMDINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\errlog.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        errlog.cpp

   Abstract:

        Error logging object implementation. This object will log the link
        checking error according to the user options (CUserOptions)

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "errlog.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Constant string (TODO: put this in resource)
const CString strHeaderText_c(_T("Start Link Checker"));
const CString strFooterText_c(_T("End Link Checker"));
const CString strWininetError_c(_T("Internet Error"));

CErrorLog::~CErrorLog(
    )
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(m_LogFile.m_hFile != CFile::hFileNull)
	{
		try
		{
			m_LogFile.Close();
		}
		catch(CFileException* pEx)
		{
			ASSERT(FALSE);
			pEx->Delete();
		}
	}

} // CErrorLog::~CErrorLog


BOOL 
CErrorLog::Create(
	)
/*++

Routine Description:

    Create this object. You must call this before using CErrorLog

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise

--*/
{
    // Get the user input log filename
	const CString& strLogFilename = GetLinkCheckerMgr().GetUserOptions().GetLogFilename();

    // Create the file 
	if(GetLinkCheckerMgr().GetUserOptions().IsLogToFile() &&
        !strLogFilename.IsEmpty())
	{
		if(m_LogFile.Open(
			strLogFilename, 
			CFile::modeCreate | CFile::modeNoTruncate | 
            CFile::shareDenyWrite | CFile::modeWrite))
		{
			try
			{
				m_LogFile.SeekToEnd();
			}
			catch(CFileException* pEx)
			{
				ASSERT(FALSE);
				pEx->Delete();
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return FALSE;
		}

	}

	return TRUE;

} // CErrorLog::Create


void 
CErrorLog::Write(
	const CLink& link)
/*++

Routine Description:

    Write to log

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Make sure the link is invalid
	ASSERT(link.GetState() == CLink::eInvalidHTTP || 
		link.GetState() == CLink::eInvalidWininet);

	if(m_LogFile.m_hFile != CFile::hFileNull)
	{
		CString strDateTime = link.GetTime().Format("%x\t%X");

		CString strLog;
		
		if(link.GetState() == CLink::eInvalidHTTP)
		{
			strLog.Format(_T("%s\t%s\t%s\t%s\t%d\t%s\t%s\n"), 
				link.GetBase(), m_strBrowser,
				m_strLanguage, strDateTime, 
				link.GetStatusCode(), link.GetStatusText(), link.GetRelative());
		}
		else if(link.GetState() == CLink::eInvalidWininet)
		{
			strLog.Format(_T("%s\t%s\t%s\t%s\t%s\t%s\t%s\n"), 
				link.GetBase(), m_strBrowser,
				m_strLanguage, strDateTime, 
				strWininetError_c, link.GetStatusText(), link.GetRelative());
		}

		try
		{
			m_LogFile.Write(strLog, strLog.GetLength());
			m_LogFile.Flush();
		}
		catch(CFileException* pEx)
		{
			ASSERT(FALSE);
			pEx->Delete();
		}
	}

} // CErrorLog::Write


void
CErrorLog::WriteHeader(
	)
/*++

Routine Description:

    Write the log header

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if(m_LogFile.m_hFile != CFile::hFileNull)
	{
	    CString strLog;
	    strLog.Format(_T("*** %s *** %s\n"), strHeaderText_c,
		    CTime::GetCurrentTime().Format("%x\t%X"));

	    try
	    {
		    m_LogFile.Write(strLog, strLog.GetLength());
		    m_LogFile.Flush();
	    }
	    catch(CFileException* pEx)
	    {
		    ASSERT(FALSE);
		    pEx->Delete();
	    }
    }

} // CErrorLog::WriteHeader


void
CErrorLog::WriteFooter(
	)
/*++

Routine Description:

    Write the log footer

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if(m_LogFile.m_hFile != CFile::hFileNull)
	{
	    CString strLog;
	    strLog.Format(_T("*** %s *** %s\n"), strFooterText_c,
		    CTime::GetCurrentTime().Format(_T("%x\t%X")));

	    try
	    {
		    m_LogFile.Write(strLog, strLog.GetLength());
		    m_LogFile.Flush();
	    }
	    catch(CFileException* pEx)
	    {
		    ASSERT(FALSE);
		    pEx->Delete();
	    }
    }

} // CErrorLog::WriteFooter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\enumdir.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        enumdir.h

   Abstract:

        Directory enumerations object declarations. Caller instantiates a instance
        of this object with a root directory path. The object will return all the
        sibbling files as a URL.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _ENUMDIR_H_
#define _ENUMDIR_H_

#include "useropt.h"

//---------------------------------------------------------------------------
// Directory enumeration class
//
class CEnumerateDirTree
{

// Public funtions
public:

    // Constructor
	CEnumerateDirTree(
        CVirtualDirInfo DirInfo // root virtual directory to start with
        );

    // Desctructor
	~CEnumerateDirTree();

    // Get the next URL
	BOOL Next(
        CString& strURL
        );

// Protected members
protected:
	
	HANDLE m_hFind; // Win32 FindFile handle

	CVirtualDirInfo m_VirtualDirInfo;         // current virtual directory enumerating
	CVirtualDirInfoList m_VirtualDirInfoList; // child directoris left to enumerate

}; // class CEnumerateDirTree

#endif // _ENUMDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\inetapi.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        inetapi.cpp

   Abstract:

        wininet.dll wrapper class implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "inetapi.h"

// Diable the warning C4706: assignment within conditional expression
// for LOAD_ENTRY macro
#pragma warning( disable : 4706)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Initialize the static members

HMODULE CWininet::sm_hWininet = NULL;
int		CWininet::sm_iInstanceCount = 0;

pfnInternetOpenA              CWininet::InternetOpenA = NULL;
pfnInternetSetStatusCallback  CWininet::InternetSetStatusCallback = NULL;
pfnInternetConnectA           CWininet::InternetConnectA = NULL;
pfnHttpOpenRequestA           CWininet::HttpOpenRequestA = NULL;
pfnHttpAddRequestHeadersA     CWininet::HttpAddRequestHeadersA = NULL;
pfnHttpSendRequestA           CWininet::HttpSendRequestA = NULL;
pfnHttpQueryInfoA             CWininet::HttpQueryInfoA = NULL;
pfnInternetCloseHandle        CWininet::InternetCloseHandle = NULL;
pfnInternetReadFile           CWininet::InternetReadFile = NULL;
pfnInternetCrackUrlA		  CWininet::InternetCrackUrlA = NULL;
pfnInternetCombineUrlA        CWininet::InternetCombineUrlA = NULL;
pfnInternetOpenUrlA			  CWininet::InternetOpenUrlA = NULL;


CWininet::CWininet(
	)
/*++

Routine Description:

    Constructor. It increases the static instance count.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Increment the instance count
	++sm_iInstanceCount;

} // CWininet::CWininet


CWininet::~CWininet(
	)
/*++

Routine Description:

    Destructor. It decrease the static instance count and/or
	free wininet.dll from memory.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// If the instance count is zero, free wininet.dll
	// from memory
	if(--sm_iInstanceCount == 0 && sm_hWininet)
    {
        VERIFY(FreeLibrary(sm_hWininet));

		sm_hWininet = NULL;
		InternetOpenA = NULL;
		InternetSetStatusCallback = NULL;
		InternetConnectA = NULL;
		HttpOpenRequestA = NULL;
		HttpAddRequestHeadersA = NULL;
		HttpSendRequestA = NULL;
		HttpQueryInfoA = NULL;
		InternetCloseHandle = NULL;
		InternetReadFile = NULL;
		InternetCrackUrlA = NULL;
		InternetCombineUrlA = NULL;
		InternetOpenUrlA = NULL;
    }

} // CWininet::~CWininet


BOOL 
CWininet::Load(
	)
/*++

Routine Description:

    Load the wininet.dll onto memory Or increase the wininet.dll
	system reference count by one.

Arguments:

    N/A

Return Value:

    BOOL - TRUE if wininet.dll loaded. FALSE otherwise.

--*/
{
    if ( !(sm_hWininet = LoadLibrary( _T("wininet.dll") )) )
    {
        TRACE(_T("CWininet::Load() - Failed to load wininet.dll\n"));
        return FALSE;
    }

	

	if ( !LOAD_ENTRY( sm_hWininet, InternetOpenA ) ||
         !LOAD_ENTRY( sm_hWininet, InternetSetStatusCallback ) ||
         !LOAD_ENTRY( sm_hWininet, InternetConnectA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpOpenRequestA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpAddRequestHeadersA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpSendRequestA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpQueryInfoA ) ||
         !LOAD_ENTRY( sm_hWininet, InternetCloseHandle ) ||
         !LOAD_ENTRY( sm_hWininet, InternetReadFile )  ||
		 !LOAD_ENTRY( sm_hWininet, InternetCrackUrlA) ||
		 !LOAD_ENTRY( sm_hWininet, InternetCombineUrlA) ||
		 !LOAD_ENTRY( sm_hWininet, InternetOpenUrlA) )
    {
        return FALSE;
    }

    return TRUE;

} // CWininet::Load
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\enumdir.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        enumdir.cpp

   Abstract:

        Directory enumerations object implementation. Caller instantiates a instance
        of this object with a root directory path. The object will return all the
        sibbling files as a URL.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "enumdir.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CEnumerateDirTree::CEnumerateDirTree(
	CVirtualDirInfo DirInfo
	)
/*++

Routine Description:

    Constructor.

Arguments:

    DirInfo - // root virtual directory to start with

Return Value:

    N/A

--*/
{
	m_hFind = INVALID_HANDLE_VALUE;

	try
	{
		m_VirtualDirInfoList.AddTail(DirInfo);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CEnumerateDirTree::CEnumerateDirTree() - fail to add to VirtualDirInfoList\n"));
	}

} // CEnumerateDirTree::CEnumerateDirTree


CEnumerateDirTree::~CEnumerateDirTree(
	)
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(m_hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(m_hFind);
	}

} // CEnumerateDirTree::~CEnumerateDirTree


BOOL 
CEnumerateDirTree::Next(
	CString& strURL
	)
/*++

Routine Description:

    Get the next URL

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	WIN32_FIND_DATA FindData;

	// Loop if 1. the find handle is valid
	//		or 2. the directory stack is not empty
	while(m_hFind != INVALID_HANDLE_VALUE || m_VirtualDirInfoList.GetCount() > 0)
	{
		// If we do not have a valid handle
		if(m_hFind == INVALID_HANDLE_VALUE)
		{
			// get the dir from the stack
			m_VirtualDirInfo = m_VirtualDirInfoList.GetHead();
			m_VirtualDirInfoList.RemoveHead();

			if(SetCurrentDirectory(m_VirtualDirInfo.GetPath()))
			{
				// Find the first one from the new dir
				m_hFind = FindFirstFile(_T("*.*"), &FindData);
			}
		}
		else
		{
			if(!FindNextFile(m_hFind, &FindData))
			{
				FindClose(m_hFind);
				m_hFind = INVALID_HANDLE_VALUE;
			}
		}

		// If we find a valid file
		if(m_hFind != INVALID_HANDLE_VALUE)
		{
			// It is a directory
			if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				// It is a valid directory
				if(FindData.cFileName != _tcsstr(FindData.cFileName, _T("..\0")) &&
					FindData.cFileName != _tcsstr(FindData.cFileName, _T(".\0")) )

				{
					CVirtualDirInfo NewDirInfo;

					NewDirInfo.SetAlias( m_VirtualDirInfo.GetAlias() + FindData.cFileName + _TCHAR('/') );
					NewDirInfo.SetPath( m_VirtualDirInfo.GetPath() + FindData.cFileName + _TCHAR('\\') );
					
					m_VirtualDirInfoList.AddTail(NewDirInfo);
				}
			}
			// It is a file
			else
			{
				strURL = _T("http://") + GetLinkCheckerMgr().GetUserOptions().GetHostName() + m_VirtualDirInfo.GetAlias() + FindData.cFileName;

				return TRUE;
			}
		}
	}

	return FALSE;

} // CEnumerateDirTree::Next
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\inetapi.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        inetapi.h

   Abstract:

        wininet.dll wrapper class declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _INETAPI_H_
#define _INETAPI_H_

#include <windows.h>
#include <wininet.h>

//------------------------------------------------------------------
// wininet.dll entry points definitons
typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetOpenA)(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef
INTERNETAPI
INTERNET_STATUS_CALLBACK
(WINAPI *
pfnInternetSetStatusCallback)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetConnectA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnHttpOpenRequestA)(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpAddRequestHeadersA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpSendRequestA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpQueryInfoA)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCloseHandle)(
    IN HINTERNET hInternet
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetReadFile)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCrackUrlA)(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCombineUrlA)(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetOpenUrlA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

#define LOAD_ENTRY( hMod, Name )  \
(##Name = (pfn##Name) GetProcAddress( (hMod), #Name ))

//------------------------------------------------------------------
// wininet.dll wrapper class
class CWininet
{

// Public funtions
public:

	// Constructor
	~CWininet();
	
	// Destructor
	CWininet();

	// Load wininet.dll
	BOOL Load();

	// Is wininet.dll loaded in memory?
	static BOOL IsLoaded() 
	{
		return (sm_hWininet != NULL);
	}

	// Get the wininet.dll static HMODULE
	static HMODULE GetWininetModule()
	{
		return sm_hWininet;
	}

	// Static wininet.dll API
    static pfnInternetOpenA              InternetOpenA;
    static pfnInternetSetStatusCallback  InternetSetStatusCallback;
    static pfnInternetConnectA           InternetConnectA;
    static pfnHttpOpenRequestA           HttpOpenRequestA;
    static pfnHttpAddRequestHeadersA     HttpAddRequestHeadersA;
    static pfnHttpSendRequestA           HttpSendRequestA;
    static pfnHttpQueryInfoA             HttpQueryInfoA;
    static pfnInternetCloseHandle        InternetCloseHandle;
    static pfnInternetReadFile           InternetReadFile;
	static pfnInternetCrackUrlA			 InternetCrackUrlA;
	static pfnInternetCombineUrlA		 InternetCombineUrlA;
	static pfnInternetOpenUrlA			 InternetOpenUrlA;


// Protected members
protected:
	
	// Static wininet.dll HMODULE
	static HMODULE sm_hWininet;

	// Static instance count
	static int sm_iInstanceCount;

}; // class CWininet

#endif // _INETAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\lcmgr.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        lcmgr.cpp

   Abstract:

        Link checker manager class implementation. This class provides the
		interfaces for creating and customizing the worker thread (link 
		checking thread).

		NOTE: You should only have a aingle instance of CLinkCheckerMgr.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "lcmgr.h"

#include "enumdir.h"
#include "proglog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Constants (TODO: put this in resource)
const CString strParsing_c(_T("Parsing"));
const CString strLoading_c(_T("Loading"));

//------------------------------------------------------------------
// Global fucntion for retrieve the link checker manager
//

// Global link checker manager pointer
CLinkCheckerMgr* g_pLinkCheckerMgr = NULL;

CLinkCheckerMgr& 
GetLinkCheckerMgr(
	)
/*++

Routine Description:

    Global fucntion for retrieve the link checker manager

Arguments:

    N/A

Return Value:

    CLinkCheckMgr& - reference to the link checker manager

--*/
{
	ASSERT(g_pLinkCheckerMgr);
	return *g_pLinkCheckerMgr;
}

//------------------------------------------------------------------
// CLinkCheckerMgr implementation
//

CLinkCheckerMgr::CLinkCheckerMgr(
	)
/*++

Routine Description:

    Constructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	ASSERT(g_pLinkCheckerMgr == NULL);
	g_pLinkCheckerMgr = this;

	m_fWininetLoaded = FALSE;
	m_fInitialized = FALSE;

	m_lWorkerThreadRunning = -1;
	m_lTerminatingThread = -1;
	m_hWorkerThread = NULL;

	m_pProgressLog = NULL;

} // CLinkCheckerMgr::CLinkCheckerMgr


CLinkCheckerMgr::~CLinkCheckerMgr(
	)
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// The worker must be terminated
	ASSERT(!IsWorkerThreadRunning());

	// Nuke the global pointer
	ASSERT(g_pLinkCheckerMgr);
	g_pLinkCheckerMgr = NULL;

} // CLinkCheckerMgr::~CLinkCheckerMgr


BOOL 
CLinkCheckerMgr::LoadWininet(
	)
/*++

Routine Description:

    Load wininet.dll. This must be called before initialize()

Arguments:

    N/A

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure LoadWininet() only call once
	ASSERT(!m_fWininetLoaded);
	if(m_fWininetLoaded)
	{
		return FALSE;
	}
	m_fWininetLoaded = TRUE;

	return m_Wininet.Load();

} // CLinkCheckerMgr::LoadWininet
	

BOOL 
CLinkCheckerMgr::Initialize(
	CProgressLog* pProgressLog
	)
/*++

Routine Description:

    Initialize the link checker manager. The link checker manager
	will initialize the link loader, link parser, ...etc

Arguments:

    pProgressLog - pointer to an instance of progress logging object

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure Initialize() only call once
	ASSERT(!m_fInitialized);
	if(m_fInitialized)
	{
		return FALSE;
	}
	m_fInitialized = TRUE;

	// pProgressLog is ok to be NULL
	m_pProgressLog = pProgressLog;

	// Create the link loader
	if(!m_Loader.Create(_T(""), _T("")))
	{
		return FALSE;
	}

	// Create the error log
	if(!m_ErrLog.Create())
	{
		return FALSE;
	}

	// Set the local host name in the paser
	m_Parser.SetLocalHostName(GetUserOptions().GetHostName());

	return TRUE;

} // CLinkCheckerMgr::Initialize


BOOL 
CLinkCheckerMgr::BeginWorkerThread(
	)
/*++

Routine Description:

	Begin the link checking thread

Arguments:

    N/A

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Start 1 thread only
	if(IsWorkerThreadRunning())
	{
		return FALSE;
	}

	CWinThread* pWorkerThread = ::AfxBeginThread((AFX_THREADPROC)WorkerThreadForwarder, NULL);
	if(pWorkerThread == NULL)
	{
		return FALSE;
	}
	else
	{
		m_hWorkerThread = pWorkerThread->m_hThread;
		return TRUE;
	}

} // CLinkCheckerMgr::BeginWorkerThread


void 
CLinkCheckerMgr::SignalWorkerThreadToTerminate(
	)
/*++

Routine Description:

	Signal the worker thread to terminate

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(IsWorkerThreadRunning() && !IsThreadTerminating())
	{
		InterlockedIncrement(&m_lTerminatingThread);
	}

} // CLinkCheckerMgr::SignalWorkerThreadToTerminate


UINT 
CLinkCheckerMgr::WorkerThreadForwarder(
	LPVOID pParam
	)
/*++

Routine Description:

	Worker thread entry point

Arguments:

    pParam - unused 

Return Value:

    UINT - unsed

--*/
{
	// Now IsWorkerThreadRunnig() return TRUE
	InterlockedIncrement(&GetLinkCheckerMgr().m_lWorkerThreadRunning);

	UINT nRet = GetLinkCheckerMgr().WorkerThread(pParam);

	// Now IsWorkerThreadRunnig() return FLASE
	InterlockedDecrement(&GetLinkCheckerMgr().m_lWorkerThreadRunning);
	
	// Notify the progress log, the worker thread is completed
	if(GetLinkCheckerMgr().m_pProgressLog)
	{
		// Possible deadlock. Use message instead ?
		GetLinkCheckerMgr().m_pProgressLog->WorkerThreadComplete();
	}

	return nRet;

} // CLinkCheckerMgr::WorkerThreadForwarder


UINT 
CLinkCheckerMgr::WorkerThread(
	LPVOID pParam
	)
/*++

Routine Description:

	Actual worker thread function

Arguments:

    pParam - unused 

Return Value:

    UINT - unsed

--*/
{
	UNUSED_ALWAYS(pParam);

	// Write the error log header
	m_ErrLog.WriteHeader();
	
	// Go thru all the combination of browser & language
	POSITION PosBrowser;
	CBrowserInfo BrowserInfo;

	POSITION PosLanguage;
	CLanguageInfo LanguageInfo;

	PosBrowser = GetUserOptions().GetAvailableBrowsers().GetHeadSelectedPosition();
	do
	{
		// Get the next browser
		BrowserInfo = GetUserOptions().GetAvailableBrowsers().GetNextSelected(PosBrowser);
		m_ErrLog.SetBrowser(BrowserInfo.GetName());

		// Reset language position
		PosLanguage = GetUserOptions().GetAvailableLanguages().GetHeadSelectedPosition();
		do
		{
			// Get the language
			LanguageInfo = GetUserOptions().GetAvailableLanguages().GetNextSelected(PosLanguage);

			m_ErrLog.SetLanguage(LanguageInfo.GetName());

			// Change the loader properties
			CString strAdditionalHeaders;
			strAdditionalHeaders.Format(_T("Accept: */*\r\nAccept-Language: %s"), LanguageInfo.GetAcceptName());
			if(!m_Loader.ChangeProperties(BrowserInfo.GetUserAgent(), strAdditionalHeaders))
			{
				return 1;
			}

			// Remove everything in the look up table
			m_Lookup.RemoveAll();


			// *EITHER* We are checking for virtual directories
			const CVirtualDirInfoList& DirInfoList = GetUserOptions().GetDirectoryList();
			int iSize = DirInfoList.GetCount();

			if(DirInfoList.GetCount() > 0)
			{
				POSITION Pos = DirInfoList.GetHeadPosition();

				// For each user input directory
				for(int i=0; !IsThreadTerminating() && i<iSize; i++)
				{
					CEnumerateDirTree Eumerator(DirInfoList.GetNext(Pos));
					CString strURL;

					// For each file in this directory tree, create an empty
					// stack with one file in
					while(!IsThreadTerminating() && Eumerator.Next(strURL))
					{
						CheckThisURL(strURL);
					}
				}
			}

			// *OR* We are checking for URL path
			const CStringList& URLList = GetUserOptions().GetURLList();
			iSize = URLList.GetCount();

			if(iSize > 0)
			{
				POSITION Pos = URLList.GetHeadPosition();

				for(int i=0; !IsThreadTerminating() && i<iSize; i++)
				{
					CheckThisURL(URLList.GetNext(Pos));
				}
			}
			
		}while(!IsThreadTerminating() && PosLanguage != NULL);
	}while(!IsThreadTerminating() && PosBrowser != NULL);

	// Write the error log footer
	m_ErrLog.WriteFooter();

    return 1;

} // CLinkCheckerMgr::WorkerThread


void 
CLinkCheckerMgr::CheckThisURL(
	LPCTSTR lpszURL
	)
/*++

Routine Description:

	Check this URL. This is the core of link checking.

Arguments:

    lpszURL - URL to check

Return Value:

    N/A

--*/
{
	// Create a link object for the input
	CLink Link(lpszURL, _T("Link Checker"), lpszURL, TRUE);

	// If not found in the lookup table
	if(!m_Lookup.Get(Link.GetURL(), Link))
	{
		if(m_pProgressLog)
		{
			CString strLog;
			strLog.Format(_T("Loading %s"), Link.GetURL());
			m_pProgressLog->Log(strLog);
			TRACE(_T("%s\n"), strLog);
		}

		// Load it ( with ReadFile )
		int iRet = m_Loader.Load(Link, TRUE);

		// Set the load time in the object
		Link.SetTime(CTime::GetCurrentTime());

		// Update the lookup table with this link
		m_Lookup.Add(Link.GetURL(), Link);
	}

	ASSERT(Link.GetState() != CLink::eUnit);

	// If the link is invalid, write to error log & return
	if(Link.GetState() == CLink::eInvalidHTTP ||
		Link.GetState() == CLink::eInvalidWininet)
	{
		
		m_ErrLog.Write(Link);
		return;
	}

	// If the link is not a text file, nothing
	// to parse
	if(Link.GetContentType() != CLink::eText)
	{
		return;
	}

	if(m_pProgressLog)
	{
		CString strLog;
		strLog.Format(_T("%s %s"), strParsing_c, Link.GetURL());
		m_pProgressLog->Log(strLog);
		TRACE(_T("%s\n"), strLog);
	}

	// Add the links in this html to the stack
	CLinkPtrList List;
	m_Parser.Parse(Link.GetData(), Link.GetURL(), List);

	// While the link stack is not empty
	while(!IsThreadTerminating() && List.GetCount() > 0)
	{
		// Pop a new link
		CLink* pLink = List.GetHead();
		List.RemoveHead();

		// If not found in the lookup table
		if(!m_Lookup.Get(pLink->GetURL(), *pLink))
		{
			if(m_pProgressLog)
			{
				CString strLog;
				strLog.Format(_T("%s %s"), strLoading_c, pLink->GetURL());
				m_pProgressLog->Log(strLog);
				TRACE(_T("%s\n"), strLog);
			}

			// Load it
			m_Loader.Load(*pLink, FALSE);

			// Set the load time in the object
			pLink->SetTime(CTime::GetCurrentTime());

			// Update the lookup table with this link
			m_Lookup.Add(pLink->GetURL(), *pLink);
		}

		// Make sure all the links were initialized
		ASSERT(pLink->GetState() != CLink::eUnit);
		
		// If the link is invalid, write to error log & return
		if(pLink->GetState() == CLink::eInvalidHTTP ||
			pLink->GetState() == CLink::eInvalidWininet)
		{
			m_ErrLog.Write(*pLink);
		}

		delete pLink;
	}

} // CLinkCheckerMgr::CheckThisURL


void 
CLinkCheckerMgr::ChangeBackSlash(
	LPTSTR lpsz
	)
/*++

Routine Description:

	Static functions for changing '\' to '/' in string

Arguments:

    lpsz - input string pointer

Return Value:

    N/A

--*/
{
	lpsz = _tcschr(lpsz, _TUCHAR('\\'));
	while(lpsz != NULL)
	{
		lpsz[0] = _TCHAR('/');
		lpsz = _tcschr(lpsz, _TUCHAR('\\'));
	}

} // CLinkCheckerMgr::ChangeBackSlash


void 
CLinkCheckerMgr::ChangeBackSlash(
	CString& str
	)
/*++

Routine Description:

	Static functions for changing '\' to '/' in string

Arguments:

    str - input string

Return Value:

    N/A

--*/
{
	LPTSTR lpsz = str.GetBuffer(str.GetLength());
	ChangeBackSlash(lpsz);
	str.ReleaseBuffer();

} // CLinkCheckerMgr::ChangeBackSlash
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linkchk.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkchk.h

   Abstract:

         MFC CWinApp derived application class declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _LINKCHK_H_
#define _LINKCHK_H_

#include "resource.h"
#include "cmdline.h"

#include "lcmgr.h"

//---------------------------------------------------------------------------
// MFC CWinApp derived application class.
// 
class CLinkCheckerApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLinkCheckerApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Protected funtions
protected:

    // Parse command line
    void ParseCmdLine(
        CCmdLine& CmdLine
        );

// Protected members
protected:

    CCmdLine m_CmdLine;                 // command line object
	CLinkCheckerMgr m_LinkCheckerMgr;   // link checker manager

// Implementation

	//{{AFX_MSG(CLinkCheckerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CLinkCheckerApp 

#endif // _LINKCHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\lcmgr.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        lcmgr.h

   Abstract:

        Link checker manager class declaration. This class provides the
		interfaces for creating and customizing the worker thread (link 
		checking thread).

		NOTE: You should only have a aingle instance of CLinkCheckerMgr.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _LCMGR_H_
#define _LCMGR_H_

#include "link.h"
#include "linkload.h"
#include "linkpars.h"
#include "linklkup.h"
#include "errlog.h"
#include "useropt.h"
#include "inetapi.h"

//------------------------------------------------------------------
//	Forward declaration
//
class CLinkCheckerSingleton;
class CProgressLog;
class CLinkCheckerMgr;

//------------------------------------------------------------------
// Global fucntion for retrieve the link checker manager
//
CLinkCheckerMgr& GetLinkCheckerMgr();

//------------------------------------------------------------------
//	Link checker manager
//
class CLinkCheckerMgr
{

// Public interfaces
public:

	// Constructor
	CLinkCheckerMgr();

	// Destructor
	~CLinkCheckerMgr();

	// Load wininet.dll. This must be called before initialize()
	BOOL LoadWininet();

	// Initialize the link checker manager. The link checker manager
	// will initialize the link loader, link parser, ...etc
	BOOL Initialize(
		CProgressLog* pProgressLog
		);
	
	// Get the CUserOptions object
	CUserOptions& GetUserOptions()
	{
		return m_UserOptions;
	}

	// Begin the link checking thread
	BOOL BeginWorkerThread();

	// Signal the worker thread to terminate
	void SignalWorkerThreadToTerminate();

	// Is worker thread running ?
	BOOL IsWorkerThreadRunning()
	{
		return (m_lWorkerThreadRunning == 0);
	}

	// Static functions for changing '\' to '/' in string
	static void ChangeBackSlash(LPTSTR lpsz);
	static void ChangeBackSlash(CString& str);


// Protected interfaces
protected:

	// Worker thread entry point
	static UINT WorkerThreadForwarder(
		LPVOID pParam
		);

	// Actual worker thread function (non-static)
	UINT WorkerThread(
		LPVOID pParam
		);

	// Is thread terminating ?
	BOOL IsThreadTerminating()
	{
		return (m_lTerminatingThread == 0);
	}

	// Check this URL. This is the core of link checking.
	void CheckThisURL(LPCTSTR lpszURL);

// Protected members
protected:

	CWininet m_Wininet;		// wininet.dll wrapper
	BOOL m_fWininetLoaded;	// is wininet.dll loaded?

	BOOL m_fInitialized;	// is link checker manager initialized?

	long m_lWorkerThreadRunning; // is worker thread running? (TRUE = 0, FALSE = -1)
	long m_lTerminatingThread;	 // is worker thread terminating? (TRUE = 0, FALSE = -1)

	HANDLE m_hWorkerThread; // handle to the worker thread
	
	CLinkLoader m_Loader;		// link loader
	CLinkParser m_Parser;		// link parser
	CLinkLookUpTable m_Lookup;	// link look up table
	CErrorLog m_ErrLog;			// error log
	
	CUserOptions m_UserOptions;	  // user options
	CProgressLog* m_pProgressLog; // progress log pointer

}; // class CLinkCheckerMgr

#endif // _LCMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linklkup.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linklkup.cpp

Abstract:

    Link look up table class implementaions. The is a MFC CMap
	constains the previous visited web link. This is used
	as a look up table for visited link.

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#include "stdafx.h"
#include "linklkup.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void 
CLinkLookUpTable::Add(
	const CString& strKey, 
	const CLink& link
	)
/*++

Routine Description:

    Wrapper function for adding item to CMap

Arguments:

	strKey	- use URL string as map key
	link	- link object to add

Return Value:

    N/A

--*/
{
	LinkLookUpItem_t item;

	item.LinkState = link.GetState();
	item.nStatusCode = link.GetStatusCode();

	SetAt(strKey, item);

} // CLinkLookUpTable::Add


BOOL 
CLinkLookUpTable::Get(
	const CString& strKey, 
	CLink& link
	) const
/*++

Routine Description:

    Wrapper function for getting item from CMap

Arguments:

    strKey	- us URL string as map key
	link	- link object to fill in

Return Value:

    BOOL - TRUE if found. FALSE otherwise.

--*/
{
	LinkLookUpItem_t item;

	if(Lookup(strKey, item))
	{
		// Found the link
		link.SetState(item.LinkState);
		link.SetStatusCode(item.nStatusCode);

		return TRUE;
	}

	return FALSE;

} // CLinkLookUpTable::Get
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\link.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    link.h

Abstract:

    Link data class and link data class link list declarations. It 
    encapsulates all the informations about a web link.

Author:

    Michael Cheuk (mcheuk)

Project:

    Link Checker

Revision History:

--*/

#ifndef _LINK_H_
#define _LINK_H_

//------------------------------------------------------------------
// Link data object. Each instance represents a web link in a
// html document
//
class CLink
{
// Object specific enum
public:

    // The object's state
    enum LinkState 
    {
        eUnit,			// uninitialize
		eUnsupport,		// unsupport URL scheme
        eValidHTTP,		// a valid HTTP link
		eValidURL,		// a valid URL (except HTTP) link
        eInvalidHTTP,	// invalid link due to HTTP status code
		eInvalidWininet	// invalid link due to wininet API failure
    };

    // The content type of this web link
    enum ContentType
    {
        eBinary,
        eText
    };

// Public interfaces
public:

	// Constructor
    CLink(
		const CString& strURL,      // URL
		const CString& strBase,     // base URL used to generate the strURL
		const CString& strRelative, // relative URL used to generate the strURL
		BOOL fLocalLink
		);

	// Get the object's URL 
    const CString& GetURL() const
    {
        return m_strURL;
    }

    // Set the object's URL
	void SetURL(
        const CString& strURL
        );

	// Get the object's base URL
    CString GetBase() const
    {
        return m_strBase;
    }

    // Get the object's relative URL
	const CString& GetRelative() const 
	{
		return m_strRelative;
	}

	// Set the object state
    void SetState(
		LinkState state
		)
    {
        m_LinkState = state;
    }
    
    // Get the object state
	LinkState GetState() const
    {
        return m_LinkState;
    }

    // Get the current content type
    ContentType GetContentType() const
    {
        return m_ContentType;
    }

	// Set the current content type
    void SetContentType(
		ContentType type
		)
    {
        m_ContentType = type;
    }
    
    // Get the HTTP reponse status code or wininet last error code
    UINT GetStatusCode() const
    {
        return m_nStatusCode;
    }

	// Set the HTTP reponse status code or wininet last error code
    void SetStatusCode(
		UINT nStatusCode
		)
    {
        m_nStatusCode = nStatusCode;
    }

	// Get link data content
    CString GetData() const
    {
        return m_strData;
    }
    
    // Set link data content
    void SetData(
		CString strData
		)
    {
        m_strData = strData;
    }

    // Empty the link data content
    void EmptyData()
    {
        m_strData.Empty();
    }

    // Is this object represents a local link
	BOOL IsLocalLink() const
	{
		return m_fLocalLink;
	}

    // Get the object load time
	const CTime& GetTime() const
	{
		return m_Time;
	}
    
    // Set the object load time
    void SetTime(
        const CTime& Time
        )
	{
		m_Time = Time;
	}

    // Get the HTTP error status text of wininet error message
    const CString& GetStatusText() const
	{
		return m_strStatusText;
	}

    // Set the HTTP error status text of wininet error message
	void SetStatusText(
        LPCTSTR lpszStatusText
        )
	{
		m_strStatusText = lpszStatusText;
	}

// Protected interfaces
protected:

    // Preprocess the m_strURL to clean up "\r\n" and change '\' to '/'
    void PreprocessURL();

// Protected members
protected:

    CString m_strURL;       // URL
    CString m_strBase;      // base URL used to generate the strURL
	CString m_strRelative;  // relative URL used to generate the strURL

    // Link data. We only read & store text file which will
	// parse for addtional link.
    CString m_strData;

    CString m_strStatusText; // the HTTP error status text of wininet error message
    UINT m_nStatusCode;      // the HTTP reponse status code or wininet last error code

    LinkState m_LinkState;      // current state of this object
    ContentType m_ContentType;  // the link data content type

	BOOL m_fLocalLink;  // is this a local link ?

	CTime m_Time; // object load time
	
}; // class CLink


//------------------------------------------------------------------
// Link object pointer class
//
class CLinkPtrList : public CTypedPtrList<CPtrList, CLink*> 
{

// Public funtions
public:

    // Destructor
	~CLinkPtrList();

    // Add link object to list
	void AddLink(
        const CString& strURL, 
        const CString& strBase, 
	    const CString& strRelative,
        BOOL fLocalLink
        );

}; // class CLinkPtrList

#endif // _LINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linkchk.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkchk.cpp

   Abstract:

         MFC CWinApp derived application class implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "maindlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CLinkCheckerApp, CWinApp)
	//{{AFX_MSG_MAP(CLinkCheckerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

// The one and only CLinkCheckerApp object
CLinkCheckerApp theApp;

BOOL 
CLinkCheckerApp::InitInstance(
    )
/*++

Routine Description:

    CLinkCheckerApp initialization

Arguments:

    N/A

Return Value:

    BOOl - TRUE if success. FALSE otherwise.

--*/
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	ParseCmdLine(m_CmdLine);

	if(!m_CmdLine.CheckAndAddToUserOptions())
	{
		return FALSE;
	}

	CMainDialog dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;

}  // CLinkCheckerApp::InitInstance(

void 
CLinkCheckerApp::ParseCmdLine(
	CCmdLine& CmdLine
	)
/*++

Routine Description:

    Parse command line

Arguments:

    CmdLine - command line object to store the data

Return Value:

    N/A

--*/
{
	// Copy & modified from MFC
	for (int i=1; i<__argc; i++)
	{
		TCHAR chFlag = _TCHAR(' ');
		LPCTSTR lpszParam = __targv[i];

		// If this is a flag
		if (lpszParam[0] == _TCHAR('-'))
		{
			chFlag = lpszParam[1];
			
			if(i+1 < __argc)
			{
				lpszParam = __targv[++i];
			}
			else
			{
				lpszParam = NULL;
			}
		}

		// Parse the flag & the following parameter
		CmdLine.ParseParam(chFlag, lpszParam);
	}

} // CLinkCheckerApp::ParseCmdLine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\link.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    link.cpp

Abstract:

    Link data class and link data class link list implementation. It 
    encapsulates all the informations about a web link.

Author:

    Michael Cheuk (mcheuk)

Project:

    Link Checker

Revision History:

--*/

#include "stdafx.h"
#include "link.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CLink::CLink(
	const CString& strURL, 
	const CString& strBase, 
	const CString& strRelative, 
	BOOL fLocalLink
	):
/*++

Routine Description:

    Constructor. 

Arguments:

    strURL		- URL
	strBase	    - Base URL
	strRelative - Relative URL
	fLocalLink	- Is local link?

Return Value:

    N/A

--*/
m_strURL(strURL),
m_strBase(strBase),
m_strRelative(strRelative),
m_fLocalLink(fLocalLink)
{
	m_LinkState = eUnit;
    m_ContentType = eBinary;
    m_nStatusCode = 0;

	PreprocessURL();

} // CLink::CLink


void 
CLink::SetURL(
    const CString& strURL
    )
/*++

Routine Description:

    Set the URL. 

Arguments:

    strURL		- URL

Return Value:

    N/A

--*/
{
	m_strURL = strURL;
	PreprocessURL();

} // CLink::SetURL


void 
CLink::PreprocessURL(
    )
/*++

Routine Description:

    Preprocess the m_strURL to clean up "\r\n" and change '\' to '/'

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    // Change '\' to '\'
    CLinkCheckerMgr::ChangeBackSlash(m_strURL);

	// Remove all "\r\n" in the URL
	int iIndex = m_strURL.Find(_T("\r\n"));
	while(iIndex != -1)
	{
		m_strURL = m_strURL.Left(iIndex) + m_strURL.Mid(iIndex + _tcslen(_T("\r\n")));
		iIndex = m_strURL.Find(_T("\r\n"));
	}

} // CLink::PreprocessURL



CLinkPtrList::~CLinkPtrList(
    )
/*++

Routine Description:

    Destructor. Clean up all the object in link list.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(!IsEmpty())
	{
		POSITION Pos = GetHeadPosition();
		do
		{
			CLink* pLink = GetNext(Pos);
			delete pLink;
		}
		while(Pos != NULL);
	}

} // CLinkPtrList::~CLinkPtrList


void 
CLinkPtrList::AddLink(
    const CString& strURL, 
    const CString& strBase, 
	const CString& strRelative,
	BOOL fLocalLink)
/*++

Routine Description:

    Add link object to list

Arguments:

    strURL		- URL
	strBase	    - Base URL
	strRelative - Relative URL
	fLocalLink	- Is local link?

Return Value:

    N/A

--*/
{
    CLink* pLink = new CLink(strURL, strBase, strRelative, fLocalLink);
    if(pLink)
    {
        try
        {
            AddTail(pLink);
        }
        catch(CMemoryException* pEx)
        {
            pEx->Delete();
        }
    }

} // CLinkPtrList::AddLink
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linklkup.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linklkup.h

Abstract:

    Link look up table class definitions. The is a MFC CMap
	constains the previos visited web link. This is used
	as a look up table for visited link.

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#ifndef _LINKLKUP_H_
#define _LINKLKUP_H_

#include "link.h"

// Lookup table item
typedef struct 
{
	CLink::LinkState LinkState; // link state
    UINT    nStatusCode;		// http status code or wininet error code
}LinkLookUpItem_t;

//---------------------------------------------------------------------------
// Link look up table. The is a MFC CMap constains the previous visited web 
// link. This is used as a look up table for visited link.
//
class CLinkLookUpTable : public CMap<CString, LPCTSTR, LinkLookUpItem_t, LinkLookUpItem_t&>
{

// Public interfaces
public:

	// Wrapper function for adding item to CMap
	void Add(
		const CString& strKey, // use URL as key
		const CLink& link
		);

	// Wrapper function for getting item from CMap
	BOOL Get(
		const CString& strKey, // use URL as key
		CLink& link
		) const;

}; // class CLinkLookUpTable

#endif // _LINKLKUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linkpars.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkpars.cpp

   Abstract:

        Link parser class implementation. This class responsible for 
		parsing the html file for hyperlink.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "LinkPars.h"

#include "link.h"
#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Constants
const CString strLocalHost_c(_T("localhost"));

void 
CLinkParser::Parse(
	const CString& strData, 
	const CString& strBaseURL, 
	CLinkPtrList& rLinkPtrList
	)
/*++

Routine Description:

    Parse a page of html data

Arguments:

    strData - page of html
	strBaseURL - base URL
	rLinkPtrList - reference to links list. The new links will
				   will be added to this list.

Return Value:

    N/A

--*/
{
	// Look for the first '<'
	LPCTSTR lpszOpen = _tcschr(strData, _TUCHAR('<'));

	while(lpszOpen != NULL)
	{
		// Look for the '>'
		LPCTSTR lpszClose = _tcschr(lpszOpen, _TUCHAR('>'));
		if(lpszClose)
		{
			// The possible tag must be longer than 7 bytes (a href=)
			int iCount = (int)(lpszClose - lpszOpen) - 1; // skip the '<'
			if( iCount  > 7 )
			{
				int iIndex = lpszOpen - ((LPCTSTR)strData) + 1; // skip the '<'

				CString strPossibleURL(strData.Mid(iIndex, iCount));

				// Parse the possible tag
				if(ParsePossibleTag(strPossibleURL))
				{
					CString strURL;
					BOOL fLocalLink;

					// We found a valid tag. Time to create new link.
					if( CreateURL(strPossibleURL, strBaseURL, strURL, fLocalLink) )
					{
						rLinkPtrList.AddLink(strURL, strBaseURL, strPossibleURL, fLocalLink);
					}
				}
			}
		}

		// Look for the next '<'
		lpszOpen = _tcschr(++lpszOpen, _TUCHAR('<'));
	}

} // CLinkParser::Parse


BOOL 
CLinkParser::ParsePossibleTag(
	CString& strTag
	)
/*++

Routine Description:

    Parse a single "<.....>" for possible hyperlink

Arguments:

    strTag - value inside a "<.....>" excluding '<' & '>'
			 If this is a hyperlink tag, the hyperlink URL
			 will be put in strTag.

Return Value:

    BOOL - TRUE if hyperlink tag. FALSE otherwise.

--*/
{
	// Make a working copy
	CString strWorkCopy(strTag);

	// Let's work with lower case
	strWorkCopy.MakeLower();

	//
	// Check for,
	//
	// HyperLink:
	// <a href="url" ...>
	// <a href="url#anchor" ...>
	// <a href="#anchor" ...>
	//
	// CGI
	// <a href="url?parameters" ...>
	//
	// Style Sheet
	// <link rel="stylesheet" href="url" ...>
	//
	if( strWorkCopy[0] == _T('a') ||
		strWorkCopy.Find(_T("link")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("href")));
	}

	//
	// Check for,
	//
	// <body background="url" ...>
	//
	// Table:
	// <table background="url" ...>
	// <th background="url" ...>
	// <td background="url" ...>
	//
	else if( strWorkCopy.Find(_T("body")) == 0 ||
             strWorkCopy.Find(_T("table")) == 0 ||
			 strWorkCopy.Find(_T("th")) == 0 ||
			 strWorkCopy.Find(_T("td")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("background")));
	}

	//
	// Check for,
	//
	// Sound:
	// <bgsound src="url" ...>
	// <sound src="url" ...>
	//
	// Frame:
	// <frame src="url" ...>
	//
	// Netscape embeded:
	// <embed src="url" ...>
	//
	// JavaScript & VB Script
	// <script src="url" language="java or vbs" ...>
	//
	else if( strWorkCopy.Find(_T("bgsound")) == 0 ||
             strWorkCopy.Find(_T("sound")) == 0 ||
			 strWorkCopy.Find(_T("frame")) == 0 ||
			 strWorkCopy.Find(_T("embed")) == 0 ||
			 strWorkCopy.Find(_T("script")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("src")));
	}

	// Check for,
	//
	// Image:
	// <img src="url" ...>
	//
	// Video:
	// <img dynsrc="url">
	// 
	// VRML:
	// <img vrml="url">
	//
	else if( strWorkCopy.Find(_T("img")) == 0 )
	{
		if(GetTagValue(strTag, CString(_T("src"))))
		{
			return TRUE;
		}

		if(GetTagValue(strTag, CString(_T("dynsrc"))))
		{
			return TRUE;
		}

		return GetTagValue(strTag, CString(_T("vrml")));
	}

	// Java
	// <applet code="name.class" codebase="url" ...>
	else if( strWorkCopy.Find(_T("applet")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("codebase")));
	}

	// Form
	// <form action="url" ...>
	else if( strWorkCopy.Find(_T("form")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("action")));
	}

	return FALSE;

} // CLinkParser::ParsePossibleTag


BOOL 
CLinkParser::GetTagValue(
	CString& strTag, 
	const CString& strParam
	)
/*++

Routine Description:

    Get the hyperlink value from "<.....>"

Arguments:

    strTag - value inside a "<.....>" excluding '<' & '>'
			 If this is a hyperlink tag, the hyperlink URL
			 will be put in strTag.

	strParam - parameter to look for. For example, src or href

Return Value:

    BOOL - TRUE if hyperlink tag. FALSE otherwise.

--*/
{
	// Make a copy of original tag
	CString strWorkCopy(strTag);
	strWorkCopy.MakeLower();

	int iLength = strParam.GetLength();

	// Look for the parameter
	int iIndex = strWorkCopy.Find(strParam);
	if(iIndex == -1)
	{
		return FALSE;
	}

	// Remove the parameter from the tag
	CString strResult( strTag.Mid(iIndex + iLength) );
	
	// Look for '='
	iIndex = strResult.Find(_T("="));
	if(iIndex == -1)
	{
		return FALSE;
	}

	// Remove the '=' from the tag
	strResult = strResult.Mid(iIndex+1);

	// Look for the value
	int iStart = -1;
	int iEnd = -1;
	int fPara = FALSE; // is the tag start with "

	// Search for the value 
	for(int i=0; i<strResult.GetLength(); i++)
	{
		// If we found the starting index of value, look
		// for the end of the value
		if(iStart!=-1 && 
			( !fPara && strResult[i] == _TCHAR(' ') || 
			  ( fPara && strResult[i] == _TCHAR('\"') ) 
			) 
		   )
		{
			iEnd = i;
			break;
		}

		// Look for the starting index of value
		if(iStart==-1 && strResult[i] != _TCHAR(' ') && strResult[i] != _TCHAR('\"') )
		{
			iStart = i;
			if(i - 1 >= 0)
			{
				fPara = (strResult[i-1] == _TCHAR('\"')); // found a "
			}
		}
	}

	// Found the starting index
	if(iStart != -1)
	{
		// If we didn't find the end of value, use the
		// last character as end
		if(iEnd == -1)
		{
			iEnd = strResult.GetLength();
		}

		// Copy the value to the input
		strTag = strResult.Mid(iStart, (iEnd - iStart));
		
		// Change '\' to '/'
		CLinkCheckerMgr::ChangeBackSlash(strTag);

		return TRUE;
	}

	return FALSE;

} // CLinkParser::GetTagValue


BOOL 
CLinkParser::CreateURL(
	const CString& strRelativeURL,		
	const CString& strBaseURL, 
	CString& strURL, 
	BOOL& fLocalLink
	)
/*++

Routine Description:

    Create a URL from base URL & relative URL. It also check 
	the result for local or remote link

Arguments:

	strRelativeURL - relative URL
	strBaseURL - base URL
	strURL - result URL
	fLocalLink - will be set to TRUE if this is a local link

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	ASSERT(CWininet::IsLoaded());

	// Remove the anchor from the relative URL
	CString strNewRelativeURL(strRelativeURL);
	int i = strNewRelativeURL.ReverseFind(_TCHAR('#'));
	if(i != -1)
	{
		strNewRelativeURL = strNewRelativeURL.Left(i);
	}

	// Combine the URLs
	DWORD dwLength = INTERNET_MAX_URL_LENGTH;
	LPTSTR lpBuffer = strURL.GetBuffer(dwLength);

	CWininet::InternetCombineUrlA(
		strBaseURL,
		strNewRelativeURL,
		lpBuffer,
		&dwLength, 
		ICU_ENCODE_SPACES_ONLY);

	strURL.ReleaseBuffer();

	// Check for local or remote link
	URL_COMPONENTS urlcomp;

	memset(&urlcomp, 0, sizeof(urlcomp));
	urlcomp.dwStructSize = sizeof(urlcomp);
	urlcomp.dwHostNameLength = 1;

	VERIFY(CWininet::InternetCrackUrlA(strURL, strURL.GetLength(), NULL, &urlcomp));

	// Check for possible local link
	if((int)urlcomp.dwHostNameLength == m_strLocalHostName.GetLength() ||
       (int)urlcomp.dwHostNameLength == strLocalHost_c.GetLength()) // localhost
	{
		if( _tcsnccmp( urlcomp.lpszHostName, m_strLocalHostName, m_strLocalHostName.GetLength() ) == 0 || 
            _tcsnccmp( urlcomp.lpszHostName, strLocalHost_c, strLocalHost_c.GetLength() ) == 0)
		{
			fLocalLink = TRUE;

			// Local link
			if(GetLinkCheckerMgr().GetUserOptions().IsCheckLocalLinks())
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}
	
	// Remote link
	fLocalLink = FALSE;
	if(GetLinkCheckerMgr().GetUserOptions().IsCheckRemoteLinks())
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

} // CLinkParser::CreateURL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\maindlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        maindlg.cpp

   Abstract:

        CMainDialog dialog class declaration. This is link checker
        the main dialog. 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _MAINDLG_H_
#define _MAINDLG_H_

#include "appdlg.h"

//---------------------------------------------------------------------------
// CMainDialog dialog
//

class CMainDialog : public CAppDialog
{
// Construction
public:
	CMainDialog(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMainDialog)
	enum { IDD = IDD_MAIN };
	BOOL	m_fLogToFile;
	CString	m_strLogFilename;
	BOOL	m_fCheckLocalLinks;
	BOOL	m_fCheckRemoteLinks;
	BOOL	m_fLogToEventMgr;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMainDialog)
	afx_msg void OnMainRun();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnAthenication();
	afx_msg void OnProperties();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CMainDialog

#endif // _MAINDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\progdlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        progdlg.h

   Abstract:

        CProgressDialog dialog class implementation. This progress dialog 
		is shown 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "progdlg.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CProgressDialog::CProgressDialog(
	) : 
/*++

Routine Description:

    Constructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
CDialog(CProgressDialog::IDD, NULL)
{
	//{{AFX_DATA_INIT(CProgressDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

} // CProgressDialog::CProgressDialog


void 
CProgressDialog::DoDataExchange(
	CDataExchange* pDX
	)
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDialog)
	DDX_Control(pDX, IDC_PROGRESS_BUTTON, m_button);
	DDX_Control(pDX, IDC_PROGRESS_TEXT, m_staticProgressText);
	//}}AFX_DATA_MAP

} //CProgressDialog::DoDataExchange


BEGIN_MESSAGE_MAP(CProgressDialog, CDialog)
	//{{AFX_MSG_MAP(CProgressDialog)
	ON_BN_CLICKED(IDC_PROGRESS_BUTTON, OnProgressButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL 
CProgressDialog::OnInitDialog(
	) 
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CDialog::OnInitDialog();

	if(GetLinkCheckerMgr().Initialize((CProgressLog*)this))
	{
		if(GetLinkCheckerMgr().BeginWorkerThread())
		{
			return TRUE;
		}
	}

	CString str;

	str.LoadString(IDS_LC_FAIL);
	Log(str);

	str.LoadString(IDS_CLOSE);
	SetButtonText(str);

	return TRUE;

} // CProgressDialog::OnInitDialog


void 
CProgressDialog::OnProgressButton(
	) 
/*++

Routine Description:

    Progress button click handler. This functions will terminate the
	worker thread or close the dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(GetLinkCheckerMgr().IsWorkerThreadRunning())
	{
		CString str;
		str.LoadString(IDS_WORKER_THREAD_TERMINATE);
		Log(str);

		// signal the worker thread to terminate
		GetLinkCheckerMgr().SignalWorkerThreadToTerminate();
	}
	else
	{
		CDialog::OnOK();
	}

} // CProgressDialog::OnProgressButton


void 
CProgressDialog::WorkerThreadComplete(
	)
/*++

Routine Description:

    Worker thread notification.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	CString str;

	str.LoadString(IDS_PROGRESS_FINISH);
	Log(str);
	
	str.LoadString(IDS_CLOSE);
	SetButtonText(str);

} // CProgressDialog::WorkerThreadComplete
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linkload.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linkload.h

Abstract:

    Link loader class definitions. It uses wininet API
	to load the web page from the internet. 

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#ifndef _LINKLOAD_H_
#define _LINKLOAD_H_

#include "inetapi.h"

//------------------------------------------------------------------
//	Forward declaration
//
class CLink;

//------------------------------------------------------------------
// This is a wrapper class for HINTERNET. It takes care of internet 
// handle cleaning up.
//
class CAutoInternetHandle
{

// Public interfaces
public:

	// Constructor
	CAutoInternetHandle(
		HINTERNET hHandle = NULL
		)
    {
        m_hHandle = hHandle;
    }

    // Destructor
	~CAutoInternetHandle()
    {
        if(m_hHandle)
	    {
		    ASSERT(CWininet::IsLoaded());
		    VERIFY(CWininet::InternetCloseHandle(m_hHandle));
        }
	}

	// Operator overloads. These functions make 
	// CAutoInternetHandle instance behaves like a HINTERNET
	operator HINTERNET() const
    {
        return m_hHandle;
    }

	const HINTERNET& operator=(
		const HINTERNET& hHandle
		)
    {
        m_hHandle = hHandle;
	    return m_hHandle;
    }

// Protected member
protected:

	HINTERNET m_hHandle; // Actual HINTERNET

}; // class CAutoInternetHandle


//------------------------------------------------------------------
// Link loader class. It uses wininet API to load the web 
// page from the internet. 
//
class CLinkLoader
{

// Public interfaces
public:

	// One time link loader create funtion
    BOOL Create(
		const CString& strUserAgent,         // HTTP user agent name
		const CString& strAdditionalHeaders  // addtional HTTP headers
		);

	// Load a web link
    BOOL Load(
		CLink& link,
		BOOL fLocalLink
		);

	// Change the loader properties
	BOOL ChangeProperties(
		const CString& strUserAgent, 
		const CString& strAdditionalHeaders
		);

// Protected interfaces
protected:

    // Load a HTTP link
	BOOL LoadHTTP(
		CLink& link,
		BOOL fReadFile,
		LPCTSTR szHostName,
		LPCTSTR szUrlPath,
		int iRedirectCount = 0
		);

    // Load a URL (non-HTTP) link
	BOOL LoadURL(
		CLink& link
		);

	// Wininet failed clean up subroutine
	BOOL WininetFailed(
		CLink& link
		);

// Protected interfaces
protected:

    // Handle for internet session (one per instance)
    CAutoInternetHandle m_hInternetSession;

	// Additional http header string
	CString m_strAdditionalHeaders;

}; // class CLinkLoader

#endif // _LINKLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linkpars.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkpars.h

   Abstract:

        Link parser class declaration. This class responsible for 
		parsing the html file for hyperlink.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _LINKPARS_H_
#define _LINKPARS_H_

#include "link.h"

//---------------------------------------------------------------------------
// Link parser
//
class CLinkParser
{

// Public interfaces
public:

	// Constructor
	CLinkParser() : 
		m_strLocalHostName(_T("localhost")) {}

	// Parse a page of html data
    void Parse(
		const CString& strData, 
		const CString& strBaseUrl, 
		CLinkPtrList& rLinkPtrList
		);

	// Setup the local hostname. It will be uses for distinguishing
	// between local and remote link
	void SetLocalHostName(
		const CString& strLocalHostName
		)
	{
		m_strLocalHostName = strLocalHostName;
	}

// Protected interfaces
protected:

	// Parse a single "<.....>" for possible hyperlink
	BOOL ParsePossibleTag(
		CString& strTag
		);

	// Get the hyperlink value from "<.....>"
	BOOL GetTagValue(
		CString& strTag, 
		const CString& strParam);

	// Create a URL from base URL & relative URL. It also check the 
	// result for local & remote link
	BOOL CreateURL(
		const CString& strRelativeURL,		
		const CString& strBaseURL, 
		CString& strURL, 
		BOOL& fLocalLink);

// Protected members
protected:

	CString m_strLocalHostName; // local hostname

}; // class CLinkParser

#endif // _LINKPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\maindlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        maindlg.cpp

   Abstract:

        CMainDialog dialog class implementation. This is link checker
        the main dialog. 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "maindlg.h"

#include "browser.h"

#include "progdlg.h"
#include "athendlg.h"
#include "propsdlg.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CMainDialog::CMainDialog(
	CWnd* pParent /*=NULL*/
	): 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - pointer to parent CWnd

Return Value:

    N/A

--*/
CAppDialog(CMainDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMainDialog)
	m_fLogToFile = TRUE;
	m_strLogFilename = _T("c:\\LinkError.log");
	m_fCheckLocalLinks = TRUE;
	m_fCheckRemoteLinks = TRUE;
	m_fLogToEventMgr = FALSE;
	//}}AFX_DATA_INIT

}  // CMainDialog::CMainDialog


void 
CMainDialog::DoDataExchange(
	CDataExchange* pDX
	)
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CAppDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMainDialog)
	DDX_Check(pDX, IDC_LOG_TO_FILE, m_fLogToFile);
	DDX_Text(pDX, IDC_LOG_FILENAME, m_strLogFilename);
	DDX_Check(pDX, IDC_CHECK_LOCAL_LINK, m_fCheckLocalLinks);
	DDX_Check(pDX, IDC_CHECK_REMOTE_LINK, m_fCheckRemoteLinks);
	DDX_Check(pDX, IDC_LOG_TO_EVENT_MANAGER, m_fLogToEventMgr);
	//}}AFX_DATA_MAP

} // CMainDialog::DoDataExchange

BEGIN_MESSAGE_MAP(CMainDialog, CAppDialog)
	//{{AFX_MSG_MAP(CMainDialog)
	ON_BN_CLICKED(IDC_MAIN_RUN, OnMainRun)
	ON_BN_CLICKED(IDC_MAIN_CLOSE, CAppDialog::OnOK)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_ATHENICATION, OnAthenication)
	ON_BN_CLICKED(IDC_PROPERTIES, OnProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void 
CMainDialog::OnMainRun(
	) 
/*++

Routine Description:

    OK button click handler. This functions brings up the progress
	dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Retrieve the data from dialog
	UpdateData();

	// Make sure we have at least one type
	// of link checking checked
	if(!m_fCheckLocalLinks && !m_fCheckRemoteLinks)
	{
		AfxMessageBox(IDS_LINKS_NOT_CHECKED);
		return;
	}

	// Set the user options in global CUserOptions
	GetLinkCheckerMgr().GetUserOptions().SetOptions(
		m_fCheckLocalLinks, 
		m_fCheckRemoteLinks, 
		m_fLogToFile,
		m_strLogFilename,
		m_fLogToEventMgr);

	// Show the progress dialog
	CProgressDialog dlg;
	dlg.DoModal();

	CAppDialog::OnOK();

} // CMainDialog::OnMainRun

int 
CMainDialog::OnCreate(
	LPCREATESTRUCT lpCreateStruct
	) 
/*++

Routine Description:

    WM_CREATE message handler. Load the wininet.dll at this
	point.

Arguments:

    N/A

Return Value:

    int - -1 if wininet.dll fail. 0 otherwise.

--*/
{
	if (CAppDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Load the wininet.dll
	if (!GetLinkCheckerMgr().LoadWininet())
	{
		AfxMessageBox(IDS_WININET_LOAD_FAIL);
		return -1;
	}
	
	return 0;

} // CMainDialog::OnCreate

void 
CMainDialog::OnAthenication(
	) 
/*++

Routine Description:

    Athenication button click handler. This functions brings up the 
	athenication dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	CAthenicationDialog dlg;
	dlg.DoModal();

} // CMainDialog::OnAthenication


void 
CMainDialog::OnProperties(
	) 
/*++

Routine Description:

    Browser Properties button click handler. This functions brings up the browser
	properties dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	CPropertiesDialog dlg;
	dlg.DoModal();

} // CMainDialog::OnProperties


BOOL 
CMainDialog::OnInitDialog(
	) 
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CAppDialog::OnInitDialog();

    // Add the available browser to CUserOptions
	for(int i=0; i<iNumBrowsersAvailable_c; i++)
	{
		GetLinkCheckerMgr().GetUserOptions().AddAvailableBrowser(BrowsersAvailable_c[i]);
	}

    // Add the available language to CUserOptions
	for(i=0; i<iNumLanguagesAvailable_c; i++)
	{
		GetLinkCheckerMgr().GetUserOptions().AddAvailableLanguage(LanguagesAvailable_c[i]);
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE

} //CMainDialog::OnInitDialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\proglog.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        progdlg.h

   Abstract:

        CProgressLog abstract base class. This defines the 
		interface for progress logging.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _PROGLOG_H_
#define _PROGLOG_H_

//---------------------------------------------------------------------------
// CProgressLog abstract base class. It defines the interfaces for progress
// logging
//
class CProgressLog
{

// Public interfaces
public:

	// Destructor
	virtual ~CProgressLog() {}

	// Write to log
	virtual void Log(const CString& strProgress) = 0;

	// Worker thread notification
	virtual void WorkerThreadComplete() = 0;

}; // class CProgressLog

#endif // _PROGLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\linkload.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linkload.cpp

Abstract:

    Link loader class definitions. It uses wininet API
	to load the web page from the internet. 

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#include "stdafx.h"
#include "linkload.h"

#include "link.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Constants
const int iMaxRedirectCount_c = 3;
const UINT nReadFileBufferSize_c = 4096;
const UINT nQueryResultBufferSize_c = 1024;


BOOL 
CLinkLoader::Create(
	const CString& strUserAgent, 
	const CString& strAdditonalHeaders
	)
/*++

Routine Description:

    One time link loader create funtion

Arguments:

    strUserAgent - HTTP user agent name
	strAdditonalHeaders - addtional HTTP headers

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure wininet.dll is loaded
	ASSERT(CWininet::IsLoaded());
    if(!CWininet::IsLoaded())
    {
        return FALSE;
    }

    // Save the additional header
	m_strAdditionalHeaders = strAdditonalHeaders;

	// Open an internet session
    m_hInternetSession = CWininet::InternetOpenA(
							strUserAgent,
							PRE_CONFIG_INTERNET_ACCESS, 
							NULL,
							INTERNET_INVALID_PORT_NUMBER,
							0);

#ifdef _DEBUG
	if(!m_hInternetSession)
	{
		TRACE(_T("CLinkLoader::Create() - InternetOpen() failed. GetLastError() = %d\n"),
		GetLastError());
	}
#endif

    return (m_hInternetSession != NULL);

} // CLinkLoader::Create


BOOL 
CLinkLoader::ChangeProperties(
	const CString& strUserAgent, 
	const CString& strAdditionalHeaders
	)
/*++

Routine Description:

    Change the loader properties

Arguments:

    strUserAgent - HTTP user agent name
	strAdditonalHeaders - addtional HTTP headers

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	if(m_hInternetSession)
	{
		// Close the previous internet session and
		// call Create() again
		VERIFY(CWininet::InternetCloseHandle(m_hInternetSession));
		return Create(strUserAgent, strAdditionalHeaders);
	}

	return FALSE;

} // CLinkLoader::ChangeProperties


BOOL 
CLinkLoader::Load(
	CLink& link,
	BOOL fReadFile
	)
/*++

Routine Description:

    Load a web link

Arguments:

    link - reference to the result link object
	fReadFile - read the file and save it in the link object

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure we have a session avaiable
	ASSERT(m_hInternetSession);
    if(!m_hInternetSession)
	{
		return FALSE;
	}

	// Crack the URL 
	TCHAR szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
	TCHAR szUrlPath[INTERNET_MAX_URL_LENGTH];
	URL_COMPONENTS urlcomp;

	memset(&urlcomp, 0, sizeof(urlcomp));
	urlcomp.dwStructSize = sizeof(urlcomp);

	urlcomp.lpszHostName = (LPTSTR) &szHostName;
	urlcomp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

	urlcomp.lpszUrlPath = (LPTSTR) &szUrlPath;
	urlcomp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

	if(!CWininet::InternetCrackUrlA(link.GetURL(), link.GetURL().GetLength(), NULL, &urlcomp))
	{
		TRACE(_T("CLinkLoader::Load() - InternetCrackUrl() failed. GetLastError() = %d\n"), 
			GetLastError());
		return FALSE;
	}

	// Make sure we have a valid (non zero length) URL path
	if(_tcslen(szUrlPath) == 0)
	{
		_tprintf(szUrlPath, "%s", _TCHAR('/'));
	}

	// Call the appropriate load funtion for different URL schemes
	if(urlcomp.nScheme == INTERNET_SCHEME_HTTP)
	{
		return LoadHTTP(link, fReadFile, szHostName, szUrlPath);
	}
	else if(urlcomp.nScheme >= INTERNET_SCHEME_FTP && 
		urlcomp.nScheme <= INTERNET_SCHEME_HTTPS)
	{
		return LoadURL(link);
	}
	else
	{
		TRACE(_T("CLinkLoader::Load() - unsupport URL scheme(%d)\n"), urlcomp.nScheme); 
		link.SetState(CLink::eUnsupport);
		return FALSE;
	}

} // CLinkLoader::Load


BOOL 
CLinkLoader::LoadURL(
	CLink& link
	)
/*++

Routine Description:

    Load a URL (non-HTTP) link

Arguments:

    link - reference to the result link object
    
Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Use InternetOpenUrl for all URL scheme except HTTP
	CAutoInternetHandle hOpenURL;
	hOpenURL = CWininet::InternetOpenUrlA(
		m_hInternetSession,
		link.GetURL(),
		NULL,
		0,
		INTERNET_FLAG_DONT_CACHE,
		0);

	if(!hOpenURL)
	{
		TRACE(_T("CLinkLoader::LoadURL() - InternetOpenUrlA() failed."));
		return WininetFailed(link);
	}
	else
	{
		link.SetState(CLink::eValidURL);
		return TRUE;
	}

} // CLinkLoader::LoadURL


BOOL 
CLinkLoader::LoadHTTP(
	CLink& link,
	BOOL fReadFile,
	LPCTSTR lpszHostName,
	LPCTSTR lpszUrlPath,
	int iRedirectCount /* = 0 */
	)
/*++

Routine Description:

    Load a HTTP link

Arguments:

    link - reference to the result link object
    fReadFile - read the file and save it in the link object
    lpszHostName - hostname
	lpszUrlPath - URL path
	iRedirectCount - Looping count. It is used to keep track the
                     the number of redirection for current link.

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Open an http session
	CAutoInternetHandle hHttpSession;
	hHttpSession = CWininet::InternetConnectA(
						m_hInternetSession,				// hInternetSession
						lpszHostName,				// lpszServerName
						INTERNET_INVALID_PORT_NUMBER,	// nServerPort
						_T(""),								// lpszUsername
						_T(""),								// lpszPassword
						INTERNET_SERVICE_HTTP,			// dwService
						0,								// dwFlags
						0);								// dwContext
	
	if(!hHttpSession)
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - InternetConnect() failed."));
		return WininetFailed(link);
	}

	// Open an http request
	CAutoInternetHandle hHttpRequest;
	hHttpRequest = CWininet::HttpOpenRequestA(
						hHttpSession,				// hHttpSession
						_T("GET"),				// lpszVerb
                        lpszUrlPath,			// lpszObjectName
						HTTP_VERSION,				// lpszVersion
						link.GetBase(),			// lpszReferer
						NULL,						// lpszAcceptTypes
						INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_DONT_CACHE,	// dwFlags
						0);							// dwContext

	if(!hHttpRequest)
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpOpenRequest() failed."));
		return WininetFailed(link);
	}

	// Sent the http request
	if(!CWininet::HttpSendRequestA(
				hHttpRequest,	// hHttpRequest
				m_strAdditionalHeaders,	// lpszHeaders
				(DWORD)-1,		// dwHeadersLength
				0,				// lpOptional
				0))				// dwOptionalLength
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpSendRequest() failed."));
		return WininetFailed(link);
	}

	TCHAR szQueryResult[nQueryResultBufferSize_c];
	DWORD dwQueryLength = sizeof(szQueryResult);

	// Check the result status code
	if(!CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_STATUS_CODE,	// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpQueryInfo() failed."));
		return WininetFailed(link);
	}

	// Check for 301 Move Permanently or 302 Move Temporarily
	if(_ttoi(szQueryResult) == 301 || _ttoi(szQueryResult) == 302)
	{
		// We can only redirect iMaxRedirectCount_c times
		if(iRedirectCount > iMaxRedirectCount_c)
		{
			return FALSE;
		}

		// Get the new location
		dwQueryLength = sizeof(szQueryResult);

		if(!CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_LOCATION,	// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
		{
			TRACE(_T("CLinkLoader::LoadHTTP() - HttpQueryInfo() failed."));
			return WininetFailed(link);
		}

		// We only update the URL in link object if
		// we are redirecting from http://hostname/xyz to http://hostname/xyz/
		if(link.GetURL().GetLength() + 1 == (int)dwQueryLength &&
		   link.GetURL().GetAt(link.GetURL().GetLength() - 1) != _TCHAR('/') &&
		   szQueryResult[dwQueryLength - 1] == _TCHAR('/'))
		{
			link.SetURL(szQueryResult);
		}

		// Crack the URL & call LoadHTTP again
		TCHAR szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
		TCHAR szUrlPath[INTERNET_MAX_URL_LENGTH];

		// Crack the URL 
		URL_COMPONENTS urlcomp;

		memset(&urlcomp, 0, sizeof(urlcomp));
		urlcomp.dwStructSize = sizeof(urlcomp);

		urlcomp.lpszHostName = (LPTSTR) &szHostName;
		urlcomp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

		urlcomp.lpszUrlPath = (LPTSTR) &szUrlPath;
		urlcomp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

		VERIFY(CWininet::InternetCrackUrlA(szQueryResult, dwQueryLength, NULL, &urlcomp));

		return LoadHTTP(link, fReadFile, szHostName, szUrlPath, ++iRedirectCount);
	}


	// Update the HTTP status code
	link.SetStatusCode(_ttoi(szQueryResult));
	
	// If the status code is not 2xx. it is a invalid link
	if(szQueryResult[0] != '2')
	{
		link.SetState(CLink::eInvalidHTTP);

		// Get the new location
		dwQueryLength = sizeof(szQueryResult);

		if(CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_STATUS_TEXT,	// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
		{
			link.SetStatusText(szQueryResult);
		}

		return FALSE;
	}

	// Now we have a valid http link
	link.SetState(CLink::eValidHTTP);

	// If we are not reading the file, we can return now
	if(!fReadFile)
	{
		return TRUE;
	}

	// Check the result content-type
	dwQueryLength = sizeof(szQueryResult);
	if(!CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_CONTENT_TYPE,// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpQueryInfo() failed."));
		return WininetFailed(link);
	}
				
	// We only load the html text for parsing
	if(!_tcsstr(szQueryResult, _T("text/html")) )
	{
		return TRUE;
	}

	link.SetContentType(CLink::eText);

	CString strBuffer;
	TCHAR buf[nReadFileBufferSize_c];
	DWORD dwBytesRead;

	// Load the text html in a loop
	do
	{
		memset(buf, 0, sizeof(buf));

		if(CWininet::InternetReadFile(
						hHttpRequest,	// hFile
						buf,			// lpBuffer
						sizeof(buf),	// dwNumberOfBytesToRead
						&dwBytesRead))	// lpNumberOfBytesRead
		{
			strBuffer += buf;
		}
		else
		{
			TRACE(_T("CLinkLoader::LoadHTTP() - InternetReadFile() failed."));
			return WininetFailed(link);
		}
	}
	while(dwBytesRead);

	// Set the InternetReadFile result in the link object
	link.SetData(strBuffer);

	return TRUE;

} // CLinkLoader::LoadHTTP



BOOL 
CLinkLoader::WininetFailed(
	CLink& link
	)
/*++

Routine Description:

    Wininet failed clean up subroutine

Arguments:

    link - reference to the result link object

Return Value:

    BOOL - Alway return TRUE

--*/
{
	link.SetState(CLink::eInvalidWininet);
	link.SetStatusCode(GetLastError());
	TRACE(_T(" GetLastError() = %d\n"), link.GetStatusCode());

	LPTSTR lpMsgBuf;
 
	if(FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM,
		CWininet::GetWininetModule(),
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL) > 0)
	{
		link.SetStatusText(lpMsgBuf);
		LocalFree(lpMsgBuf);
	}

	return FALSE;

} // CLinkLoader::WininetFailed
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\propsdlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        propsdlg.h

   Abstract:

         Link checker properties dialog class declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _PROPSDLG_H_
#define _PROPSDLG_H_

//---------------------------------------------------------------------------
// CPropertiesDialog dialog
//
class CPropertiesDialog : public CDialog
{

// Public interfaces
public:

    // Construction
	CPropertiesDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPropertiesDialog)
	enum { IDD = IDD_PROPERTIES };
	CCheckListBox	m_LanguageCheckList;
	CCheckListBox	m_BrowserCheckList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertiesDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    // Get the number of items checked in a check listbox.
    int NumItemsChecked(CCheckListBox& ListBox);

	// Generated message map functions
	//{{AFX_MSG(CPropertiesDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnPropertiesOk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _PROPSDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\propsdlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        propsdlg.h

   Abstract:

         Link checker properties dialog class implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "propsdlg.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CPropertiesDialog::CPropertiesDialog(
    CWnd* pParent /*=NULL*/
    ) : 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(CPropertiesDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropertiesDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

} // CPropertiesDialog::CPropertiesDialog


void 
CPropertiesDialog::DoDataExchange(
    CDataExchange* pDX
    )
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropertiesDialog)
	DDX_Control(pDX, IDC_LANGUAGE_LIST, m_LanguageCheckList);
	DDX_Control(pDX, IDC_BROWSER_LIST, m_BrowserCheckList);
	//}}AFX_DATA_MAP

} // CPropertiesDialog::DoDataExchange


BEGIN_MESSAGE_MAP(CPropertiesDialog, CDialog)
	//{{AFX_MSG_MAP(CPropertiesDialog)
	ON_BN_CLICKED(IDC_PROPERTIES_OK, OnPropertiesOk)
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_PROPERTIES_CANCEL, CDialog::OnCancel)
END_MESSAGE_MAP()


BOOL 
CPropertiesDialog::OnInitDialog(
    ) 
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CDialog::OnInitDialog();
	
    // Add all the avaiable browsers to checked list box
    CUserOptions& UserOptions = GetLinkCheckerMgr().GetUserOptions();
    int iSize = UserOptions.GetAvailableBrowsers().GetCount();

    if(iSize > 0)
    {
        CBrowserInfo BrowserInfo;
        POSITION PosBrowser = UserOptions.GetAvailableBrowsers().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            BrowserInfo = UserOptions.GetAvailableBrowsers().GetNext(PosBrowser);

		    if(i != m_BrowserCheckList.AddString(BrowserInfo.GetName()))
		    {
			    ASSERT(FALSE);
			    return FALSE;
		    }
		    else
		    {
                // Make sure they all checked
                int iChecked = BrowserInfo.IsSelected() ? 1 : 0;
			    m_BrowserCheckList.SetCheck(i, iChecked);
		    }
	    }
    }
	
    // Add all the avaiable languages to checked list box
    iSize = UserOptions.GetAvailableLanguages().GetCount();

    if(iSize > 0)
    {
        CLanguageInfo LanguageInfo;
        POSITION PosLanguage = UserOptions.GetAvailableLanguages().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            LanguageInfo = UserOptions.GetAvailableLanguages().GetNext(PosLanguage);

		    if(i != m_LanguageCheckList.AddString(LanguageInfo.GetName()))
		    {
			    ASSERT(FALSE);
			    return FALSE;
		    }
		    else
		    {
                // Make sure they all checked
                int iChecked = LanguageInfo.IsSelected() ? 1 : 0;
			    m_LanguageCheckList.SetCheck(i, iChecked);
		    }
	    }
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE

} // CPropertiesDialog::OnInitDialog


void 
CPropertiesDialog::OnPropertiesOk(
    ) 
/*++

Routine Description:

    OK button click handler. This functions add all the user checked 
    item to CUserOptions.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    // Make sure we have at least one item checked
    if(NumItemsChecked(m_BrowserCheckList) == 0 || NumItemsChecked(m_LanguageCheckList) == 0)
    {
        AfxMessageBox(IDS_ITEM_NOT_CHECKED);
        return;
    }

    // Add the checked browsers to CUserOptions
    CUserOptions& UserOptions = GetLinkCheckerMgr().GetUserOptions();
    int iSize = UserOptions.GetAvailableBrowsers().GetCount();

    if(iSize)
    {
        POSITION PosBrowser = UserOptions.GetAvailableBrowsers().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            CBrowserInfo& BrowserInfo = UserOptions.GetAvailableBrowsers().GetNext(PosBrowser);
			BrowserInfo.SetSelect(m_BrowserCheckList.GetCheck(i) == 1);
	    }
    }

    // Add the checked languages to CUserOptions
    iSize = UserOptions.GetAvailableLanguages().GetCount();

    if(iSize)
    {
        POSITION PosLanguage = UserOptions.GetAvailableLanguages().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            CLanguageInfo& LanguageInfo = UserOptions.GetAvailableLanguages().GetNext(PosLanguage);
			LanguageInfo.SetSelect(m_LanguageCheckList.GetCheck(i) == 1);
	    }
    }

	CDialog::OnOK();

} // CPropertiesDialog::OnPropertiesOk


int 
CPropertiesDialog::NumItemsChecked(
    CCheckListBox& ListBox
    )
/*++

Routine Description:

    Get the number of items checked in a check listbox.

Arguments:

    N/A

Return Value:

    int - number of items checked.

--*/
{
    int iCheckedCount = 0;
    int iSize = ListBox.GetCount();

    for(int i=0; i<iSize; i++)
    {
        if(ListBox.GetCheck(i) == 1)
        {
            iCheckedCount++;
        }
    }

    return iCheckedCount;

} // CPropertiesDialog::NumItemsChecked
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\progdlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        progdlg.h

   Abstract:

        CProgressDialog dialog class declaration. This progress dialog 
		is shown 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _PROGDLG_H_
#define _PROGDLG_H_

#include "resource.h"
#include "proglog.h"

//---------------------------------------------------------------------------
// CProgressDialog dialog
//
class CProgressDialog : public CDialog, CProgressLog
{

// Construction
public:
	CProgressDialog();

// Dialog Data
	//{{AFX_DATA(CProgressDialog)
	enum { IDD = IDD_PROGRESS };
	CButton	m_button;
	CStatic m_staticProgressText;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Public interfaces
public:

	// Overwrite CProgressLog ABC virtual funtions

	// Write to log
	virtual void Log(
		const CString& strProgress
		)
	{
		m_staticProgressText.SetWindowText(strProgress);
	}

	// Worker thread notification
	virtual void WorkerThreadComplete();

// Protected interfaces
protected:

	// Set the button text
	void SetButtonText(
		const CString& strText
		)
	{
		m_button.SetWindowText(strText);
	}

	// Generated message map functions
	//{{AFX_MSG(CProgressDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnProgressButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CProgressDialog 

#endif // _PROGDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef _STDAFX_H_
#define _STDAFX_H_

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxtempl.h>


#endif //  _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by linkchk.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MAIN                        102
#define IDS_IISGETADMININFORMATION_ERROR 102
#define IDS_IIS_VIRTUALROOT_NOT_EXIST   103
#define IDS_ITEM_NOT_CHECKED            104
#define IDS_WININET_LOAD_FAIL           105
#define IDS_LINKS_NOT_CHECKED           106
#define IDS_LC_FAIL                     107
#define IDS_CLOSE                       108
#define IDS_PROGRESS_FINISH             109
#define IDS_WORKER_THREAD_TERMINATE     110
#define IDR_MAINFRAME                   128
#define IDD_PROGRESS                    129
#define IDD_PROPERTIES                  130
#define IDD_ATHENICATION                131
#define IDD_USAGE                       132
#define IDC_ABOUT_OK                    1000
#define IDC_MAIN_RUN                    1001
#define IDC_MAIN_CLOSE                  1002
#define IDC_CHECK_REMOTE_LINK           1003
#define IDC_CHECK_LOCAL_LINK            1004
#define IDC_PROPERTIES                  1005
#define IDC_LOG_TO_EVENT_MANAGER        1006
#define IDC_LOG_TO_FILE                 1007
#define IDC_LOG_FILENAME                1008
#define IDC_ATHENICATION                1009
#define IDC_PROGRESS_BUTTON             1010
#define IDC_PROGRESS_TEXT               1011
#define IDC_PROPERTIES_OK               1012
#define IDC_PROPERTIES_CANCEL           1013
#define IDC_BROWSER_LIST                1014
#define IDC_LANGUAGE_LIST               1015
#define IDC_ATHENICATION_OK             1016
#define IDC_ATHENICATION_CANCEL         1017
#define IDC_NT_USERNAME                 1018
#define IDC_NT_PASSWORD                 1019
#define IDC_BROWSE_NT_USERNAME          1020
#define IDC_BASIC_USERNAME              1021
#define IDC_BASIC_PASSWORD              1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	linkchk.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\useropt.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        useropt.h

   Abstract:

        Global user options class and help class implementations. This class 
		can only instantiate by CLinkCheckerMgr. Therefore, a single instance 
		of this class will live inside CLinkCheckerMgr. You can access
		the this instance by calling GetLinkCheckMgr().GetUserOptions().

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "useropt.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------
// CVirtualDirInfo
//

void 
CVirtualDirInfo::PreProcessAlias(
	)
/*++

Routine Description:

    Preprocess the current virtual directory alias. The alias will be in
	the form of / or /dir/

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Change everything to lower case
	m_strAlias.MakeLower();

	// Change '\' to '/'
	CLinkCheckerMgr::ChangeBackSlash(m_strAlias);

	// Make sure strAlias is in the form of / or /dir/
	if( m_strAlias.GetAt( m_strAlias.GetLength() - 1 ) != _TCHAR('/') )
	{
		m_strAlias += _TCHAR('/');
	}

} // CVirtualDirInfo::PreProcessAlias


void 
CVirtualDirInfo::PreProcessPath(
	)
/*++

Routine Description:

    Preprocess the current virtual directory path. The alias will be in
	the form of c:\ or c:\dir\

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Change everything to lower case
	m_strPath.MakeLower();

	// Make sure strPath is in the form of \ or \dir\
	if( m_strPath.GetAt( m_strPath.GetLength() - 1 ) != _TCHAR('\\') )
	{
		m_strPath += _TCHAR('\\');
	}

}  // CVirtualDirInfo::PreProcessPath

//------------------------------------------------------------------
// CBrowserInfoList
//

POSITION 
CBrowserInfoList::GetHeadSelectedPosition(
    ) const
/*++

Routine Description:

    Get the first selected browser. It works like GetHeadPosition()

Arguments:

    N/A
Return Value:

    POSITION - A POSITION value that can be used for iteration or 
               object pointer retrieval; NULL if the list is empty

--*/
{
    POSITION Pos = GetHeadPosition();

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            return PosCurrent;
            break;
        }
    }

    return NULL;

} // CBrowserInfoList::GetHeadSelectedPosition

CBrowserInfo& 
CBrowserInfoList::GetNextSelected(
    POSITION& Pos
    )
/*++

Routine Description:

    Get next selected browser. It works like GetNext()

Arguments:

    Pos - A reference to a POSITION value returned by 
          a previous GetHeadSelectedPosition, GetNextSelected

Return Value:

    CBrowserInfo& - returns a reference to an element of the list

--*/
{
    CBrowserInfo& Info = GetNext(Pos);

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            Pos = PosCurrent;
            break;
        }
    }

    return Info;

} // CBrowserInfoList::GetNextSelected

//------------------------------------------------------------------
// CLanguageInfoList
//

POSITION 
CLanguageInfoList::GetHeadSelectedPosition(
    ) const
/*++

Routine Description:

    Get the first selected browser. It works like GetHeadPosition()

Arguments:

    N/A
Return Value:

    POSITION - A POSITION value that can be used for iteration or 
               object pointer retrieval; NULL if the list is empty

--*/
{
    POSITION Pos = GetHeadPosition();

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            return PosCurrent;
            break;
        }
    }

    return NULL;

} // CLanguageInfo::GetHeadSelectedPosition

CLanguageInfo& 
CLanguageInfoList::GetNextSelected(
    POSITION& Pos
    )
/*++

Routine Description:

    Get next selected language. It works like GetNext()

Arguments:

    Pos - A reference to a POSITION value returned by 
          a previous GetNext, GetHeadPosition, GetNextSelected, 
          or other member function call

Return Value:

    CLanguageInfo& - returns a reference to an element of the list

--*/
{
    CLanguageInfo& Info = GetNext(Pos);

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            Pos = PosCurrent;
            break;
        }
    }

    return Info;

} // CLanguageInfoList::GetNextSelected

//------------------------------------------------------------------
// CUserOptions
//

void 
CUserOptions::AddDirectory(
	const CVirtualDirInfo& Info
	)
/*++

Routine Description:

    Add this virtual directory to the link list.

Arguments:

    Info - virtual directory infomation to add

Return Value:

    N/A

--*/
{
	// Finally, add it to the array
	try
	{
		m_VirtualDirInfoList.AddTail(Info);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddDirectory


void  
CUserOptions::AddURL(
	LPCTSTR lpszURL
	)
/*++

Routine Description:

    Add this URL to the link list.

Arguments:

    lpszURL - URL to add

Return Value:

    N/A

--*/
{
	CString strURL(lpszURL);

	// Change '\' to '/'
	CLinkCheckerMgr::ChangeBackSlash(strURL);

	try
	{
		m_strURLList.AddTail(strURL);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddURL


void 
CUserOptions::AddAvailableBrowser(
	const CBrowserInfo& Info
	)
/*++

Routine Description:

    Add this browser information to the available list.

Arguments:

    Info - Browser information to add

Return Value:

    N/A

--*/
{
	try
	{
		m_BrowserInfoList.AddTail(Info);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddAvailableBrowser


void 
CUserOptions::AddAvailableLanguage(
	const CLanguageInfo& Info
	)
/*++

Routine Description:

    Add this language information to the available list.

Arguments:

    Info - Language information to add

Return Value:

    N/A

--*/
{
	try
	{
		m_LanguageInfoList.AddTail(Info);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddAvailableLanguage


void 
CUserOptions::SetOptions(
	BOOL fCheckLocalLinks, 
	BOOL fCheckRemoteLinks, 
	BOOL fLogToFile,
	const CString& strLogFilename,
	BOOL fLogToEventMgr
	)
/*++

Routine Description:

    Set the user options in the main dialog

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	m_fCheckLocalLinks = fCheckLocalLinks;
	m_fCheckRemoteLinks = fCheckRemoteLinks;

	m_fLogToFile= fLogToFile;
	m_strLogFilename = strLogFilename;

	m_fLogToEventMgr = fLogToEventMgr;

} // CUserOptions::SetOptions


void 
CUserOptions::SetAthenication(
	const CString& strNTUsername,
	const CString& strNTPassword,
	const CString& strBasicUsername,
	const CString& strBasicPassword
	)
/*++

Routine Description:

    Set NTLM & HTTP basic athenications.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	m_strNTUsername = strNTUsername;
	m_strNTPassword = strNTPassword;

	m_strBasicUsername = strBasicUsername;
	m_strBasicPassword = strBasicPassword;

} // CUserOptions::SetAthenication


// Get the hostname
const CString& 
CUserOptions::GetHostName(
	)
/*++

Routine Description:

    Get the hostname.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// If the hostname does not exists, it means the user pass in
	// a list of URL to link checker. (Server nane is not required for 
	// this case.) Now, we can get the hostname from the URL
	if(m_strHostName.IsEmpty() && m_strURLList.GetCount() > 0)
	{
		// Set up the current hostname string
		LPTSTR lpszHostName = m_strHostName.GetBuffer(INTERNET_MAX_HOST_NAME_LENGTH);

		URL_COMPONENTS urlcomp;
		memset(&urlcomp, 0, sizeof(urlcomp));
		urlcomp.dwStructSize = sizeof(urlcomp);
		urlcomp.lpszHostName = lpszHostName;
		urlcomp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

		// Crack it
		VERIFY(CWininet::InternetCrackUrlA(
			m_strURLList.GetHead(), m_strURLList.GetHead().GetLength(), NULL, &urlcomp));

		m_strHostName.ReleaseBuffer();
	}

	return m_strHostName;

} // CUserOptions::GetHostName


void 
CUserOptions::PreProcessServerName(
	)
/*++

Routine Description:

    Preprocess the server name such that for server "\\hostname"
	- GetServerName() return \\hostname
	- GetHostName() return hostname

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Change everything to lower case
	m_strHostName.MakeLower();

	// Change '\' to '/'
	CLinkCheckerMgr::ChangeBackSlash(m_strHostName);

	// Make sure m_strHostName is not in front of localhost
	const CString strBackSlash(_T("//"));
	if( m_strHostName.Find(strBackSlash) == 0 )
	{
		m_strHostName = m_strHostName.Mid(strBackSlash.GetLength());
	}

} // CUserOptions::PreProcessServerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "mime.h"

#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mime.h ===
// mime.h : main header file for the MIME application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMimeApp:
// See mime.cpp for the implementation of this class
//

class CMimeApp : public CWinApp
{
public:
	CMimeApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMimeApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMimeApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mime.cpp ===
// mime.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mime.h"

#include "mainfrm.h"
#include "mimedoc.h"
#include "mimeview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMimeApp

BEGIN_MESSAGE_MAP(CMimeApp, CWinApp)
	//{{AFX_MSG_MAP(CMimeApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMimeApp construction

CMimeApp::CMimeApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMimeApp object

CMimeApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMimeApp initialization

BOOL CMimeApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();

	LoadStdProfileSettings(0);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CMimeDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CMimeView));
	AddDocTemplate(pDocTemplate);

	// create a new (empty) document
	OnFileNew();

	if (m_lpCmdLine[0] != '\0')
	{
		// TODO: add command line processing here
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMimeApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMimeApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mimedoc.cpp ===
// mimedoc.cpp : implementation of the CMimeDoc class
//

#include "stdafx.h"
#include "mime.h"

#include "mimedoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc

IMPLEMENT_DYNCREATE(CMimeDoc, CDocument)

BEGIN_MESSAGE_MAP(CMimeDoc, CDocument)
	//{{AFX_MSG_MAP(CMimeDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc construction/destruction

CMimeDoc::CMimeDoc()
{
	// TODO: add one-time construction code here

}

CMimeDoc::~CMimeDoc()
{
}

BOOL CMimeDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc serialization

void CMimeDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc diagnostics

#ifdef _DEBUG
void CMimeDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CMimeDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\linkchk\useropt.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        useropt.h

   Abstract:

        Global user options class and help classes declarations. This class 
		can only instantiate by CLinkCheckerMgr. Therefore, a single instance 
		of this class will live inside CLinkCheckerMgr. You can access
		the this instance by calling GetLinkCheckMgr().GetUserOptions().

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _USEROPT_H_
#define _USEROPT_H_

//------------------------------------------------------------------
// IIS Virtual directory information
//
class CVirtualDirInfo
{

// Public Funtions
public:

	// Constructor
	CVirtualDirInfo() {}

	// Constructor
	inline CVirtualDirInfo(
		const CString& strAlias,	// virtual directory alias
		const CString& strPath		// virtual directory path
		) :
	m_strAlias(strAlias), m_strPath(strPath)
	{
		PreProcessAlias();
		PreProcessPath();
	}

	// Get the virtual directory alias
	const CString& GetAlias() const
	{
		return m_strAlias;
	}

	// Set the virtual directory alias
	void SetAlias(
		const CString& strAlias
		)
	{
		m_strAlias = strAlias;
		PreProcessAlias();
	}

	// Get the virtual directory path
	const CString& GetPath() const
	{
		return m_strPath;
	}

	// Set the virtual directory path
	void SetPath(
		const CString& strPath
		)
	{
		m_strPath = strPath;
		PreProcessPath();
	}

// Protected funtions
protected:

	// Preprocess the current virtual directory alias
	void PreProcessAlias();

	// Preprocess the current virtual directory path
	void PreProcessPath();

// Protected members
protected:

	CString m_strAlias;		// virtual directory alias
    CString m_strPath;		// virtual directory path

}; // class CVirtualDirInfo


//------------------------------------------------------------------
// CVirtualDirInfo (IIS Virtual directory information) link list
//
typedef
class CList<CVirtualDirInfo, const CVirtualDirInfo&>
CVirtualDirInfoList;


//------------------------------------------------------------------
// Browser information. Link checker uses this class to store
// the avaiable browser emulation.
//
class CBrowserInfo
{

// Public Funtions
public:

	// Constructor
	CBrowserInfo() 
    {
        m_fSelected = FALSE;
    }

	// Constructor
	CBrowserInfo(
		LPCTSTR lpszName,		// user friendly name
		LPCTSTR lpszUserAgent,	// HTTP user agent name
        BOOL fSelect            // select this browser to emulate
		):
	m_strName(lpszName), 
	m_strUserAgent(lpszUserAgent)
    {
        m_fSelected = fSelect;
    }

	// Get the user friendly browser name
	const CString& GetName() const
	{
		return m_strName;
	}

	// Set the user friendly browser name
	void SetName(
		const CString& strName 
		)
	{
		m_strName = strName;
	}

	// Get the HTTP user agent name
	const CString& GetUserAgent() const
	{
		return m_strUserAgent;
	}

	// Set the HTTP user agent name
	void SetUserAgent(
		const CString& strUserAgent
		)
	{
		m_strUserAgent = strUserAgent;
	}

    // Select or unselect this browser
    void SetSelect(BOOL fSelect)
    {
        m_fSelected = fSelect;
    }

    // Select or unselect this browser
    BOOL IsSelected() const 
    {
        return m_fSelected;
    }

// Protected members
protected:

	CString m_strName;		// user friendly browser name (eg. Microsoft Internet Explorer 4.0)
    CString m_strUserAgent; // HTTP user agent name
    BOOL m_fSelected;       // is browser selected ?

}; // class CBrowserInfo


//------------------------------------------------------------------
// CBrowserInfo (browser informations) link list
//
class CBrowserInfoList : public CList<CBrowserInfo, const CBrowserInfo&>
{

// Public interfaces
public:

    // Get the first selected browser. It works like GetHeadPosition()
    POSITION GetHeadSelectedPosition() const;

    // Get next selected browser. It works like GetNext()
    CBrowserInfo& GetNextSelected(
        POSITION& Pos
        );
};


//------------------------------------------------------------------
// Language informations. Link checker uses this class to store
// the avaiable language emulation.
//
class CLanguageInfo
{

// Public funtions
public:

	// Constructor
	CLanguageInfo() 
    {
        m_fSelected = FALSE;
    }

	// Constructor
	CLanguageInfo(
		LPCTSTR lpszName,		// language name
		LPCTSTR lpszAcceptName,	// HTTP accept language name
        BOOL fSelect            // select this language to emulate
		) :
	m_strName(lpszName), 
	m_strAcceptName(lpszAcceptName),
    m_fSelected(fSelect) {}

	// Get the language name
	const CString& GetName() const
	{
		return m_strName;
	}

	// Set the language name
	void SetName(
		const CString& strName
		)
	{
		m_strName = strName;
	}

	// Get the HTTP accept language name
	const CString& GetAcceptName() const
	{
		return m_strAcceptName;
	}

	// Get the HTTP accept language name
	void SetAcceptName(
		const CString& strAcceptName
		)
	{
		m_strAcceptName = strAcceptName;
	}

    // Select or unselect this language
    void SetSelect(BOOL fSelect)
    {
        m_fSelected = fSelect;
    }

    // Select or unselect this language
    BOOL IsSelected() const 
    {
        return m_fSelected;
    }

// Protected members
protected:

	CString m_strName;			// Language name (eg. Western English)
    CString m_strAcceptName;	// HTTP accept language name (eg. en)
    BOOL m_fSelected;           // is language selected ?

}; // class CLanguageInfo


//------------------------------------------------------------------
// CLanguageInfo (Language informations) link list
//
class CLanguageInfoList : public CList<CLanguageInfo, const CLanguageInfo&>
{

// Public interfaces
public:

    // Get the first selected browser. It works like GetHeadPosition()
    POSITION GetHeadSelectedPosition() const;

    // Get next selected language. It works like GetNext()
    CLanguageInfo& GetNextSelected(
        POSITION& Pos
        );
};


//------------------------------------------------------------------
// Forward declaration
//
class CLinkCheckerMgr;

//------------------------------------------------------------------
// Global user options class
//
class CUserOptions
{

// Protected interfaces
protected:

	// This class can only instantiate by CLinkCheckerMgr
	friend CLinkCheckerMgr;
	
	// Protected constructor & destructor
	CUserOptions() {}
	~CUserOptions() {}

// Public interfaces
public:

	// Set the user options in the main dialog
	void SetOptions(
		BOOL fCheckLocalLinks,			// check local link?
		BOOL fCheckRemoteLinks,			// check remote link?
		BOOL fLogToFile,				// log to file
		const CString& strLogFilename,	// log filename
		BOOL fLogToEventMgr				// log to event manager
		);

	// Check local links
	BOOL IsCheckLocalLinks() const
	{
		return  m_fCheckLocalLinks;
	}

	// Check remote links
	BOOL IsCheckRemoteLinks() const
	{
		return m_fCheckRemoteLinks;
	}

    // Is log to file ?
    BOOL IsLogToFile() const
    {
        return m_fLogToFile;
    }

	// Get log filename
	const CString& GetLogFilename() const
	{
		return m_strLogFilename;
	}

	// The following link lists are used 
	// for transversing the server
	// 
	// User can only have 
	// a list of virtual directory or a list of URL

	// Add this virtual directory to the link list
	void AddDirectory(
		const CVirtualDirInfo& Info
		);

	// Get virtual directory link list
	const CVirtualDirInfoList& GetDirectoryList() const
	{
		return m_VirtualDirInfoList;
	}

	// Add this URL to the link list
	void AddURL(
		LPCTSTR lpszURL
		);
	
	// Get the URL link list
	const CStringList& GetURLList() const
	{
		return m_strURLList;
	}

	// The following link lists are used 
	// to store the available browswers and languages
    // for user selection
	// 

	// Add this browser to the available list
	void AddAvailableBrowser(
		const CBrowserInfo& Info
		);

	// Get the browser available list
	CBrowserInfoList& GetAvailableBrowsers()
	{
		return m_BrowserInfoList;
	}

	// Add this language information to available list
	void AddAvailableLanguage(
		const CLanguageInfo& Info
		);

	// Get the language available list
	CLanguageInfoList& GetAvailableLanguages()
	{
		return m_LanguageInfoList;
	}

	// Log to event manager?
	BOOL IsLogToEventMgr()
	{
		return m_fLogToEventMgr;
	}

	// Set NTLM & basic athenications
	void SetAthenication(
		const CString& strNTUsername,
		const CString& strNTPassword,
		const CString& strBasicUsername,
		const CString& strBasicPassword
		);

	// Get NTLM athenication password username
	const CString& GetNTUsername() const
	{
		return m_strNTUsername;
	}

	// Get NTLM athenication password
	const CString& GetNTPassword() const
	{
		return m_strNTPassword;
	}

	// Get HTTP basic athenication username
	const CString& GetBasicUsername() const
	{
		return m_strBasicUsername;
	}

	// Get HTTP basic athenication password
	const CString& GetBasicPassword() const
	{
		return m_strBasicPassword;
	}

	// Set the server name
	void SetServerName(
		const CString& strServerName
		)
	{
		m_strHostName = strServerName;
		PreProcessServerName();
	}

	// Get the server name
	const CString& GetServerName()
	{
		return CString(_T("\\\\")) + GetHostName();
	}

    // Set the hostname
	void SetHostName(
		const CString& strHostName
		)
	{
		m_strHostName = strHostName;
		PreProcessServerName();
	}

	// Get the hostname
	const CString& GetHostName();

// Protected funtions
protected:

	// Preprocess the server name such that for server "\\hostname"
	//  GetServerName() return \\hostname
	//  GetHostName() return hostname
	void PreProcessServerName();

// Protected members
protected:
	
	CString m_strLogFilename;	// log filename

	CVirtualDirInfoList m_VirtualDirInfoList;	// virtual link list
	CStringList	m_strURLList;					// URL link list
	CBrowserInfoList m_BrowserInfoList;			// browswer infomation link list
	CLanguageInfoList m_LanguageInfoList;		// language information link list

	CString m_strNTUsername;	// NTLM athenication username
	CString m_strNTPassword;	// NTLM athenication password

	CString m_strBasicUsername;	// HTTP basic athenication username
	CString m_strBasicPassword; // HTTP basic athenication password

	CString m_strHostName; // hostname

	BOOL m_fCheckLocalLinks;	// check local links?
	BOOL m_fCheckRemoteLinks;	// check remote links?
	BOOL m_fLogToFile;			// log to file
	BOOL m_fLogToEventMgr;		// log to event manager
};


#endif //  _USEROPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mimedoc.h ===
// mimedoc.h : interface of the CMimeDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CMimeDoc : public CDocument
{
protected: // create from serialization only
	CMimeDoc();
	DECLARE_DYNCREATE(CMimeDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMimeDoc)
	public:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMimeDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMimeDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mimeview.cpp ===
// mimeview.cpp : implementation of the CMimeView class
//

#include "stdafx.h"
#include "mime.h"

#include "mimedoc.h"
#include "mimeview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMimeView

IMPLEMENT_DYNCREATE(CMimeView, CFormView)

BEGIN_MESSAGE_MAP(CMimeView, CFormView)
	//{{AFX_MSG_MAP(CMimeView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMimeView construction/destruction

CMimeView::CMimeView()
	: CFormView(CMimeView::IDD)
{
	//{{AFX_DATA_INIT(CMimeView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// TODO: add construction code here

}

CMimeView::~CMimeView()
{
}

void CMimeView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMimeView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
// CMimeView diagnostics

#ifdef _DEBUG
void CMimeView::AssertValid() const
{
	CFormView::AssertValid();
}

void CMimeView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}

CMimeDoc* CMimeView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMimeDoc)));
	return (CMimeDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMimeView message handlers

void CMimeView::OnInitialUpdate() 
{
	ResizeParentToFit();
		
	CFormView::OnInitialUpdate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\mimeview.h ===
// mimeview.h : interface of the CMimeView class
//
/////////////////////////////////////////////////////////////////////////////

class CMimeView : public CFormView
{
protected: // create from serialization only
	CMimeView();
	DECLARE_DYNCREATE(CMimeView)

public:
	//{{AFX_DATA(CMimeView)
	enum{ IDD = IDD_MIME_FORM };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:
	CMimeDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMimeView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMimeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMimeView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in mimeview.cpp
inline CMimeDoc* CMimeView::GetDocument()
   { return (CMimeDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by mime.rc
//
#define IDD_ABOUTBOX                    100
#define IDD_MIME_FORM                   101
#define IDR_MAINFRAME                   128
#define IDC_LIST1                       1000
#define IDC_MIME_ICON                   1001
#define IDC_BUTTON2                     1003
#define IDC_BUTTON3                     1004
#define IDC_HELP                        1005
#define IDC_BUTTON5                     1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\certutil\fortezza\fortutil\fortutil.cxx ===
/*++


   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

         fortutil.cxx

   Abstract:

        Utility used to migrate Fortezza certificates from the card to CAPI stores,
        and set the appropriate metabase settings for an instance

   Author:

       Alex Mallet (amallet) 30-April-1998

--*/

#define INITGUID

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
#define USE_CAPI2
#if defined(USE_CAPI2)
#include <wincrypt.h>
#endif

extern "C" {
#define SECURITY_WIN32
#include <sspi.h>
}
#include <spseal.h>
#include <issperr.h>
#include <schnlsp.h>

#include <iadmw.h>
#include <admex.h>
#include <iiscnfgp.h>
#include <mdcommsg.h>

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

#define MY_STORE_NAME   "MY"
#define CA_STORE_NAME   "CA"
#define ROOT_STORE_NAME "ROOT"
#define SHA1_HASH_SIZE 20
#define TIMEOUT_VALUE 30000 //magic number ...

#define MB_ROOT_PATH L"/LM/W3SVC"

//
// Metabase properties for Fortezza certificates
//
static DWORD adwMetabaseFortCertProperties[] = { MD_SSL_CERT_HASH, 
                                                 BINARY_METADATA,
                                                 MD_SSL_CERT_STORE_NAME, 
                                                 STRING_METADATA,
                                                 MD_SSL_CERT_IS_FORTEZZA, 
                                                 DWORD_METADATA,
                                                 MD_SSL_CERT_FORTEZZA_PIN, 
                                                 STRING_METADATA,
                                                 MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER, 
                                                 STRING_METADATA,
                                                 MD_SSL_CERT_FORTEZZA_PERSONALITY, 
                                                 STRING_METADATA
};

#define cNumCertMetabaseProperties sizeof(adwMetabaseFortCertProperties)/sizeof(DWORD)

#define USAGE "Usage : %s -o:delete|create|check -i:<instance number #1> -n:PIN -s:<serial #> -p:<personality> [-?]"

#define REMOVE 1
#define CREATE 2
#define CHECK 4


//
// Internal declarations
//
HRESULT GetMetabasePointer( OUT IMSAdminBaseW **ppMetabase );

BOOL
CopyFortezzaChainToMachine( LPSTR pszSerialNumber,
                            LPSTR pszPersonality,
                            LPSTR pszPIN,
                            PCCERT_CONTEXT *ppServerCert,
                            HCRYPTPROV *phProv );


BOOL
WriteFortezzaMBProperties( IMSAdminBaseW *pMB,
                           METADATA_HANDLE hMDHandle,
                           PCCERT_CONTEXT pCertContext,
                           LPSTR pszSerialNumber,
                           LPSTR pszPIN,
                           LPSTR pszPersonality );

BOOL
RemoveFortezzaMBProperties( IMSAdminBaseW *pMB,
                            METADATA_HANDLE hMDHandle,
                            LPSTR pszPIN );


VOID
CheckFortezzaMBProperties( IMSAdminBaseW *pMB,
                           METADATA_HANDLE hMDHandle,
                           LPSTR pszPIN );

BOOL BuildFullPath( LPSTR pszSubPath,
                    LPWSTR *ppwszFullPath );

BOOL
IsCorrectPIN( IMSAdminBaseW *pMB,
              METADATA_HANDLE hMD,
              LPWSTR pszPIN,
              BOOL *pfCorrect );


BOOL
HasFortezzaCert( IMSAdminBaseW *pMB,
                 METADATA_HANDLE hMD,
                 BOOL *pfHasCert );


BOOL
IsCertRoot(PBYTE pbCert, DWORD cbCert);


BOOL ConstructCertChain( PCCERT_CONTEXT pcLeafCert,
                         LPSTR pszLeafCertStore,
                         PBOOL pfCompleteChain,
                         PBOOL pfTrustedChain );

BOOL ConvertToUnicode( IN LPSTR pszAsciiStr,
                       OUT LPWSTR *ppwszWideStr );

BOOL ConvertToAscii( IN LPWSTR pwszWideStr,
                     OUT LPSTR *ppszAsciiStr );

BOOL IsSelfSignedCert( IN PCCERT_CONTEXT pCertContext );

BOOL IsNumber( LPCSTR pszName );

int __cdecl main(int argc, char *argv[])
{
    HRESULT hRes = S_OK;
    IMSAdminBase *pMB = NULL;
    DWORD dwRet = 0;
    LPSTR pszInstance = NULL;
    LPSTR pszPIN = NULL;
    LPSTR pszPersonality = NULL;
    LPSTR pszSerialNumber = NULL;
    PCCERT_CONTEXT pServerCert = NULL;
    HCRYPTPROV hFortezzaCSP = NULL;
    DWORD dwAction = 0;
    INT i = 0;
    CHAR chOption = 0;
    LPSTR pszArg = NULL;
    LPWSTR pwszFullPath = NULL;
    METADATA_HANDLE hMDHandle = NULL;

    //
    // Parse argument list
    //

    for ( i = 1; i < argc; i++ )
    {
        //
        // Check for well-formed arguments; must all have a '-' or '/' as first
        // character and be at least 2 characters long
        //
        if ( (argv[i][0] != '-' && argv[i][0] != '/') ||
             ( strlen( argv[i] ) == 2 && argv[i][1] != '?' ) ||
             strlen( argv[i] ) < 3 )
        {
            printf( USAGE, argv[0] );
            exit(1);
        }

        //
        // Check for special case of "/?" and "-?" argument
        //
        if ( !strcmp( argv[i], "/?" ) ||
             !strcmp( argv[i], "-?" ) )
        {
            printf( USAGE, argv[0] );
            exit(0);
        }

        //
        // We know it's an argument of the form hyphen-letter-colon now
        //
        chOption = argv[i][1];
        pszArg = argv[i] + 3;

        switch ( chOption )
        {
        case 'o':
        case 'O':
            if ( !_stricmp( pszArg,"create") )
            {
                dwAction = CREATE;
            }
            else if ( !_stricmp( pszArg, "delete" ) )
            {
                dwAction = REMOVE;
            }
            else if ( !_stricmp( pszArg, "check" ) )
            {
                dwAction = CHECK;
            }
            else
            {
                printf( USAGE, argv[0] );
                goto cleanup;
            }
            break;

        case 'i':
        case 'I':
            pszInstance = pszArg;
            break;
           
        case 'n':
        case 'N':
            pszPIN = pszArg;
            break;
            
        case 's':
        case 'S':
            pszSerialNumber = pszArg;
            break;

        case 'p':
        case 'P':
            pszPersonality = pszArg;
            break;

        default:
            printf( USAGE, argv[0] );
            exit(1);
        }
           
    }

    //
    // Check to make sure we have all necessary data 
    //
    switch ( dwAction )
    {
    case CREATE:
        if ( !pszSerialNumber || !pszPersonality || !pszPIN )
        {
            printf("You must specify a PIN, Card Serial Number and Personality to attach a Fortezza certificate to the web server. \n");
            printf( USAGE, argv[0] );
            exit(1);
        }
        break;

    case REMOVE:
        if ( !pszPIN )
        {
            printf("You must specify the PIN for the Fortezza certificate you wish to remove. \n");
            printf( USAGE, argv[0] );
            exit(1);
        }
        break;

    case CHECK:
        if ( !pszPIN )
        {
            printf("You must specify the PIN for the Fortezza certificate you wish to examine. \n");
            printf( USAGE, argv[0] );
            exit(1);
        }
        break;
        
    default:
        printf( USAGE, argv[0] );
        exit(1);
    }

    hRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if( FAILED(hRes) )
    {
        printf( "Failed to initialize COM 0x%x\n", hRes );
        exit(1);
    }

    if ( SUCCEEDED( hRes = GetMetabasePointer( &pMB ) ) )
    {
        if ( BuildFullPath( pszInstance,
                            &pwszFullPath ) &&
             SUCCEEDED( hRes = pMB->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                             pwszFullPath,
                                             METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                             TIMEOUT_VALUE,
                                             &hMDHandle ) ) )
        {
            switch ( dwAction )
            {
            case CREATE:

                //
                // Copy the certificates from the card to the CAPI stores
                //
                if ( !CopyFortezzaChainToMachine( pszSerialNumber,
                                                  pszPersonality,
                                                  pszPIN,
                                                  &pServerCert,
                                                  &hFortezzaCSP ) )
                {
                    printf("Failed to copy certificates from the Fortezza card to the CAPI stores on the machine, error 0x%x\n", GetLastError());
                    
                    goto cleanup;
                }

                //
                // Write the necessary data to the metabase
                // 
                if ( !WriteFortezzaMBProperties( pMB,
                                                 hMDHandle,
                                                 pServerCert,
                                                 pszSerialNumber,
                                                 pszPIN,
                                                 pszPersonality ) )
                {
                    printf("Failed to write Fortezza metabase properties, error 0x%x\n",
                           GetLastError());
                    
                    goto cleanup;
                    
                }

                printf("Successfully installed Fortezza certificate.\n");
                
                break;
            
            case REMOVE:
                
                if ( !RemoveFortezzaMBProperties( pMB,
                                                  hMDHandle,
                                                  pszPIN ) )
                {
                    printf("Failed to remove Fortezza certificate.\n");
                    goto cleanup;
                }
                else
                {
                    printf("Successfully removed Fortezza certificate.\n");
                }

            break;

            case CHECK:

                CheckFortezzaMBProperties( pMB,
                                           hMDHandle,
                                           pszPIN );

                break;

            default:
                printf( USAGE, argv[0] );
            }
        }
        else
        {
            if ( FAILED( hRes ) )
            {
                printf("Failed to open metabase : 0x%x\n",
                       HRESULTTOWIN32( hRes ) );
            }
        }
    }
    else
    {
        printf("Failed to obtain metabase access : 0x%x\n", HRESULTTOWIN32( hRes ) );
    }


cleanup:

    if ( pwszFullPath )
    {
        delete [] pwszFullPath;
    }
    
    if ( hMDHandle )
    {
        pMB->CloseKey( hMDHandle );
    }

    if ( pServerCert )
    {
        CertFreeCertificateContext( pServerCert );
    }
    
    if ( hFortezzaCSP )
    {
        CryptReleaseContext( hFortezzaCSP,
                             0 );
    }
                             
         
    if ( pMB )
    {
        pMB->Release();
    }

    CoUninitialize();

    return 0;
}




HRESULT GetMetabasePointer( OUT IMSAdminBaseW **ppMetabase )
/*++

Routine Description:

    Get a metabase interface pointer

Arguments:

    ppMetabase - pointer to pointer to metabase object, updated on success

Returns:

    HRESULT indicating success/failure.

--*/

{
    HRESULT hRes = S_OK;
    COSERVERINFO *pcsiParam = NULL;
    IClassFactory * pcsfFactory = NULL;

    //
    // Retrieve class factory for metabase object
    //
    hRes = CoGetClassObject(CLSID_MSAdminBase_W, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, ( void ** ) &pcsfFactory );

    if ( FAILED(hRes) )
    {
        printf("CoGetClassObject failed : hRes : %x, Win32 : 0x%x\n",
               hRes, HRESULTTOWIN32(hRes));
        return hRes;
    }

    //
    // Retrieve the actual metabase object interface
    //
    hRes = pcsfFactory->CreateInstance( NULL,
                                        IID_IMSAdminBase,
                                        (void **) ppMetabase );

    if ( FAILED(hRes) )
    {
        printf("CreateInstance failed : hRes : %x, Win32 : 0x%x\n",
               hRes, HRESULTTOWIN32(hRes));
        return hRes;
    }
    pcsfFactory->Release();

    return hRes;
}



BOOL
CopyFortezzaChainToMachine( IN LPSTR pszSerialNumber,
                            IN LPSTR pszPersonality,
                            IN LPSTR pszPIN,
                            OUT PCCERT_CONTEXT *ppServerCert,
                            OUT HCRYPTPROV *phProv )
/*++

Routine Description:

    Copies the certificates from the card to the CAPI stores on the machine.
    Ripped off from JBanes.

Arguments:

    pszSerialNumber - serial # of card
    pszPersonality - personality [ie certificate] to use as server cert
    pszPIN - PIN for card
    ppServerCert - pointer to pointer to server cert, updated on success
    phProv - pointer to handle to Fortezza CSP, updated on success

Returns:

    BOOL indicating success/failure

--*/

{
    HCRYPTPROV  hProv = 0;
    HCERTSTORE  hMyStore = 0;
    HCERTSTORE  hCaStore = 0;
    HCERTSTORE  hRootStore = 0;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    PCCERT_CONTEXT pCertContext = NULL;
    PBYTE   pbChain = NULL;
    DWORD   cbChain;
    PBYTE   pbCert = NULL;
    DWORD   cbCert;
    PWSTR   pwszPersonality = NULL;
    PSTR    pszProvider = NULL;
    DWORD   cbProvider;
    PWSTR   pwszProvider = NULL;
    DWORD   cchProvider;
    BOOL    fLeafCert;
    BOOL    fSucceeded = FALSE;
    LPSTR pszCSPString = NULL;
    CERT_ENHKEY_USAGE KeyUsage; 
    DWORD cbPIN = strlen( pszPIN );
    DWORD cbSerialNumber = strlen( pszSerialNumber );
    DWORD cbPersonality = strlen( pszPersonality );
    DWORD cbLen = cbPIN + cbSerialNumber + cbPersonality + 10; //add some slop

    DWORD   dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;

    PSTR rgpszUsageIdentifier[] = { szOID_PKIX_KP_SERVER_AUTH,
                                    szOID_PKIX_KP_CLIENT_AUTH,
                                    szOID_PKIX_KP_EMAIL_PROTECTION
    };
    DWORD cUsageIdentifier = sizeof(rgpszUsageIdentifier)/sizeof(PSTR);


    //
    // Make sure the string with the PIN is allocated in non-pageable memory so the
    // PIN doesn't show up in the page file
    //
    pszCSPString = new CHAR[cbLen];

    if ( !pszCSPString )
    {
        printf("Failed to allocate memory\n");
        return E_FAIL;
    }

    //
    // Build the magic string that will unlock the Fortezza secret ...
    //
    strcpy( pszCSPString, pszSerialNumber );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPersonality );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPIN );
            

    //
    // Get handle to CSP
    //
    if( !CryptAcquireContext(&hProv, 
                             pszCSPString,
                             NULL, 
                             PROV_FORTEZZA, 
                             CRYPT_SILENT ) )
    {
        printf("**** Error 0x%x returned by CryptAcquireContext\n", 
               GetLastError());
        goto done;
    }

    //
    // Don't leave the info lying around
    //
    memset( pszCSPString, 0, strlen( pszCSPString ) );
    delete [] pszCSPString;
    pszCSPString = NULL;

    //
    // Open certificate stores
    //
    hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                              0,
                              (HCRYPTPROV) NULL,
                              dwStoreFlags,
                              MY_STORE_NAME );

    if(hMyStore == NULL)
    {
        printf("**** Error 0x%x opening MY store\n", GetLastError());
        goto done;
    }

    hCaStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                              0,
                              (HCRYPTPROV) NULL,
                              dwStoreFlags,
                              CA_STORE_NAME );
    if(hCaStore == NULL)
    {
        printf("**** Error 0x%x opening CA store\n", GetLastError());
        goto done;
    }

    hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                (HCRYPTPROV) NULL,
                                dwStoreFlags,
                                ROOT_STORE_NAME );

    if (hRootStore == NULL)
    {
        printf("**** Error 0x%x opening ROOT store\n", GetLastError());
        goto done;
    }


    //
    // Convert container name to unicode.
    //
    if ( !ConvertToUnicode( pszPersonality,
                            &pwszPersonality ) )
    {
        goto done;
    }

    //
    // Read provider name from CSP.
    //
    if( !CryptGetProvParam( hProv, 
                            PP_NAME,
                            NULL,
                            &cbProvider,
                            0 ) )
    {
        printf("**** Error 0x%x reading provider name from CSP\n",
            GetLastError());
        goto done;
    }

    pszProvider = new CHAR[cbProvider];

    if( pszProvider == NULL )
    {
        printf("**** Out of memory\n");
        goto done;
    }

    if( !CryptGetProvParam( hProv, 
                            PP_NAME,
                            (UCHAR *) pszProvider,
                            &cbProvider,
                            0 ) )
    {
        printf("**** Error 0x%x reading provider name from CSP\n",
            GetLastError());
        goto done;
    }

    //
    // Convert provider name to unicode.
    //
    if ( !ConvertToUnicode( pszProvider,
                            &pwszProvider ) )
    { 
        goto done;
    }
   
    //
    // Get length of cert chain.
    //
    if( !CryptGetProvParam( hProv, 
                            PP_CERTCHAIN, 
                            NULL, 
                            &cbChain, 
                            0 ) )
    {
        printf("**** Error 0x%x reading cert chain from CSP\n",
            GetLastError());
        goto done;
    }

    //
    // Allocate memory for chain.
    //
    pbChain = new BYTE[cbChain];
    if( pbChain == NULL )
    {
        printf("**** Out of memory\n");
        goto done;
    }

    //
    // Download certificate chain from CSP.
    //
    if( !CryptGetProvParam( hProv, 
                            PP_CERTCHAIN, 
                            pbChain, 
                            &cbChain, 
                            0 ) )
    {
        printf("**** Error 0x%x reading cert chain from CSP\n",
            GetLastError());
        goto done;
    }


    //
    // Add each certificate in chain to store.
    //
    fLeafCert = TRUE;
    pbCert = pbChain;
    while( pbCert < pbChain + cbChain )
    {
        cbCert = *(PDWORD)pbCert;
        pbCert += sizeof(DWORD);

        if( pbCert + cbCert > pbChain + cbChain )
        {
            // Invalid certificate chain format!
            printf("**** Invalid cert chain format\n");
            goto done;
        }

        if( IsCertRoot( pbCert, 
                        cbCert ) )
        {
            if ( !CertAddEncodedCertificateToStore(hRootStore,
                                                   X509_ASN_ENCODING,
                                                   pbCert,
                                                   cbCert,
                                                   CERT_STORE_ADD_REPLACE_EXISTING,
                                                   NULL ) )
            {
                printf("**** Error 0x%x adding certificate to ROOT store\n",
                    GetLastError());
                goto done;
            }
        }
        else if( fLeafCert )
        {
            //
            // This is the actual server certificate; add certificate to MY store.
            //
            if( !CertAddEncodedCertificateToStore( hMyStore, 
                                                   X509_ASN_ENCODING,
                                                   pbCert,
                                                   cbCert,
                                                   CERT_STORE_ADD_REPLACE_EXISTING,
                                                   ppServerCert ) )
            {
                printf("**** Error 0x%x adding certificate to MY store\n",
                    GetLastError());
                goto done;
            }

            // Set the key provider info property.
            ZeroMemory(&KeyProvInfo, sizeof(KeyProvInfo));
            KeyProvInfo.pwszContainerName = pwszPersonality;
            KeyProvInfo.pwszProvName      = pwszProvider;
            KeyProvInfo.dwProvType        = PROV_FORTEZZA;
            KeyProvInfo.dwFlags           = 0;
            KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;
           
            if( !CertSetCertificateContextProperty( *ppServerCert,
                                                    CERT_KEY_PROV_INFO_PROP_ID,
                                                    0,
                                                    &KeyProvInfo ) )
            {
                printf("**** Error 0x%x setting key provider info property\n",
                    GetLastError());
                goto done;
            }

            // Set the enhanced key usage property.
            KeyUsage.cUsageIdentifier = cUsageIdentifier;
            KeyUsage.rgpszUsageIdentifier = rgpszUsageIdentifier;

            if( !CertSetEnhancedKeyUsage( *ppServerCert,
                                          &KeyUsage ) )
            {
                printf("**** Error 0x%x setting enhanced key usage property\n",
                    GetLastError());
                goto done;
            }
        }
        else
        {
            //
            // Intermediate cert, add certificate to CA store.
            //
            if( !CertAddEncodedCertificateToStore( hCaStore, 
                                                   X509_ASN_ENCODING,
                                                   pbCert,
                                                   cbCert,
                                                   CERT_STORE_ADD_REPLACE_EXISTING,
                                                   NULL ) )
            {
                printf("**** Error 0x%x adding certificate to CA store\n",
                    GetLastError());
                goto done;
            }
        }
        
        fLeafCert = FALSE;
        pbCert += cbCert;
    }

    fSucceeded = TRUE;

done:

    if( hProv )
    {
        *phProv = hProv;
    }

    if ( pwszPersonality ) 
    {
        delete [] pwszPersonality; 
    }
       
    if ( pszProvider ) 
    {
        delete [] pszProvider;
    }

    if( pwszProvider ) 
    {
        delete [] pwszProvider;
    }

    if( pbChain ) 
    {
        delete [] pbChain;
    }

    if ( hMyStore ) 
    {
        CertCloseStore( hMyStore, 
                        0 );
    }

    if( hCaStore ) 
    {
        CertCloseStore( hCaStore, 
                        0 );
    }

    if( pCertContext ) 
    {
        CertFreeCertificateContext(pCertContext);
    }

    if ( pszCSPString )
    {
        delete [] pszCSPString;
    }

    return fSucceeded;
}

static 
BOOL
IsCertRoot(PBYTE pbCert, DWORD cbCert)
{
    PCCERT_CONTEXT pCertContext;

    // Decode certificate.
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                pbCert,
                                                cbCert);
    if(pCertContext == NULL)
    {
        printf("**** Error 0x%x decoding certificate\n", GetLastError());
        return FALSE;
    }

    // Compare subject and issuer.
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            CertFreeCertificateContext(pCertContext);
            return TRUE;
        }
    }

    CertFreeCertificateContext(pCertContext);
    return FALSE;
}


BOOL
WriteFortezzaMBProperties( IN IMSAdminBaseW *pMB,
                           IN METADATA_HANDLE hMDHandle,
                           IN PCCERT_CONTEXT pServerCert,
                           IN LPSTR pszSerialNumber,
                           IN LPSTR pszPIN,
                           IN LPSTR pszPersonality )
/*++

Routine Description:

    Writes the necessary metabase properties for a Fortezza certificate. 

Arguments:

    pszInstance - server instance with which cert is to be associated; if NULL,
    assumes /W3SVC.
    pMB - metabase pointer
    pCertContext - server certificate
    pszSerialNumber - serial # of Fortezza card
    pszPIN - PIN for card
    pszPersonality - Fortezza "personality" to be used


Returns:

    BOOL indicating success/failure

--*/
{
    HRESULT hRes = S_OK;
    LPWSTR pwszSerialNumber = NULL;
    LPWSTR pwszPIN = NULL;
    LPWSTR pwszPersonality = NULL;
    BOOL fOK = FALSE;
    METADATA_RECORD mdr;
    BYTE rgbHash[SHA1_HASH_SIZE];
    DWORD cbHash = SHA1_HASH_SIZE;
    DWORD dwFortezza = 0;

    //
    // Metabase interface is Unicode, so convert all the strings to Unicdoe
    //
    if ( !ConvertToUnicode( pszSerialNumber,
                            &pwszSerialNumber ) ||
         !ConvertToUnicode( pszPIN,
                            &pwszPIN ) || 
         !ConvertToUnicode( pszPersonality,
                            &pwszPersonality ) )
    {
        goto cleanup2;
    }

    //
    // Write cert hash to MB
    //
    if ( !CertGetCertificateContextProperty( pServerCert,
                                             CERT_SHA1_HASH_PROP_ID,
                                             rgbHash,
                                             &cbHash ) )
    {
        printf("Couldn't retrieve hash of server certificate, error 0x%x\n",
               GetLastError());
        goto cleanup2;
    }

    
    MD_SET_DATA_RECORD( &mdr, 
                        MD_SSL_CERT_HASH,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        cbHash,
                        rgbHash );
                        
                        
    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write certificate hash to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }

    //
    // Write store name to MB
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_STORE_NAME,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        ( wcslen(L"MY") + 1 ) * sizeof(WCHAR),
                        L"MY" );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write store name to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }

    //
    // Write flag indicating it's a Fortezza cert
    //
    dwFortezza  = 1;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_IS_FORTEZZA,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        DWORD_METADATA,
                        sizeof(DWORD),
                        &dwFortezza );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write Fortezza flag to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }


    //
    // Write PIN
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PIN,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        (wcslen( pwszPIN ) + sizeof(WCHAR))*sizeof(WCHAR),
                        pwszPIN );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write PIN to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }

    //
    // Write personality
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PERSONALITY,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        (wcslen( pwszPersonality ) + 1)*sizeof(WCHAR),
                        pwszPersonality );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write personality to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }


    //
    // Write serial number
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        (wcslen( pwszSerialNumber ) + 1)*sizeof(WCHAR),
                        pwszSerialNumber );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write serial number to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }


    //
    // Everything succeeded, we're happy
    //
    fOK = TRUE;

cleanup2:   

    if ( pwszSerialNumber )
    {
        delete [] pwszSerialNumber;
    }

    if ( pwszPIN )
    {
        delete [] pwszPIN;
    }

    if ( pwszPersonality )
    {
        delete [] pwszPersonality;
    }

    return fOK;
}


BOOL RemoveFortezzaMBProperties( IMSAdminBaseW *pMB,
                                 METADATA_HANDLE hMDHandle,
                                 LPSTR pszPIN )
/*++

Routine Description:

    Removes Fortezza metabase properties 

Arguments:

    pMB - metabase pointer
    pszInstance - server instance for which data is to be removed; if NULL,
    assumes /W3SVC.
    pszPIN - PIN for card

Returns:

    BOOL indicating success/failure

--*/
{
    METADATA_RECORD mdr;
    HRESULT hRes = S_OK;
    LPWSTR pwszPIN = NULL;
    BOOL fOK = FALSE;
    BOOL fHasCert = FALSE;
    BOOL fCorrectPIN = FALSE;
    DWORD cbRequired = 0;
    BYTE *pbMBPIN = NULL;
    DWORD i = 0;
    DWORD dwFortezza = 0;

    //
    // Metabase interface is Unicode, so convert all the strings to Unicdoe
    //
    if ( !ConvertToUnicode( pszPIN,
                            &pwszPIN ) )
    {
        goto cleanup3;
    }

    //
    // Check that there is a Fortezza cert on this instance
    //
    fHasCert = FALSE;

    if ( !HasFortezzaCert( pMB,
                           hMDHandle,
                           &fHasCert ) )
    {
        printf("Couldn't determine whether this instance has a Fortezza certificate associated with it.\n");
        goto cleanup3;
    }
    else
    {
        if ( !fHasCert )
        {
            printf("No Fortezza certificate associated with this instance.\n");
            goto cleanup3;
        }
    }


    //
    // Before removing anything, make sure the supplied PIN matches the one we have
    // stored, as sort of a poor-man's access check. Of course, this won't stop a
    // brute-force attack...
    //
    if ( !IsCorrectPIN( pMB,
                        hMDHandle,
                        pwszPIN,
                        &fCorrectPIN ) )
    {
        printf("Couldn't determine whether the PIN is correct.\n");
        goto cleanup3;
    }
    else
    {
        if ( !fCorrectPIN )
        {
            printf("The PIN entered does not match the stored PIN.\n");
            goto cleanup3;
        }
    }


    //
    // Run through all the properties and delete them
    //
    for ( i = 0; i < cNumCertMetabaseProperties; i+= 2 )
    {
        if ( FAILED(hRes = pMB->DeleteData( hMDHandle,
                                            L"",
                                            adwMetabaseFortCertProperties[i],
                                            adwMetabaseFortCertProperties[i + 1] ) ) )
        {
            printf("Failed to delete property %d, error 0x%x\n",
                   adwMetabaseFortCertProperties[i],
                   HRESULTTOWIN32( hRes ) );
        }
    }


    //
    // Everything succeeded, we're happy
    //
    fOK = TRUE;

cleanup3:

    if ( pwszPIN )
    {
        delete [] pwszPIN;
    }

    return fOK;
}

#define BUFFER_SIZE 2048

VOID CheckFortezzaMBProperties( IN IMSAdminBaseW *pMB,
                                IN METADATA_HANDLE hMDHandle,
                                IN LPSTR pszPIN )
{
    METADATA_RECORD mdr;
    HRESULT hRes = S_OK;
    LPWSTR pwszPIN = NULL;
    BOOL fOK = FALSE;
    BOOL fHasCert = FALSE;
    BOOL fCompleteChain = FALSE;
    BOOL fTrustedChain = FALSE;
    BOOL fCorrectPIN = FALSE;
    DWORD cbRequired = 0;
    DWORD i = 0;
    DWORD dwFortezza = 0;
    BYTE rgbBuffer[BUFFER_SIZE];
    LPSTR pszPersonality = NULL;
    LPSTR pszSerialNumber = NULL;
    LPSTR pszStoreName = NULL;
    LPSTR pszCSPString = NULL;
    HCRYPTPROV hProv = NULL;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pServerCert = NULL;
    BYTE rgbCertHash[SHA1_HASH_SIZE];
    
    //
    // Metabase interface is Unicode, so convert all the strings to Unicdoe
    //
    if ( !ConvertToUnicode( pszPIN,
                            &pwszPIN ) )
    {
        goto cleanup4;
    }

    //
    // Check that there is a Fortezza cert on this instance
    //
    fHasCert = FALSE;

    if ( !HasFortezzaCert( pMB,
                           hMDHandle,
                           &fHasCert ) )
    {
        printf("Couldn't determine whether this instance has a Fortezza certificate associated with it.\n");
        goto cleanup4;
    }
    else
    {
        if ( !fHasCert )
        {
            printf("No Fortezza certificate associated with this instance.\n");
            goto cleanup4;
        }
    }


    //
    // Before doing anything, make sure the supplied PIN matches the one we have
    // stored, as sort of a poor-man's access check. Of course, this won't stop a
    // brute-force attack...
    //
    if ( !IsCorrectPIN( pMB,
                        hMDHandle,
                        pwszPIN,
                        &fCorrectPIN ) )
    {
        printf("Couldn't determine whether the PIN is correct.\n");
        goto cleanup4;
    }
    else
    {
        if ( !fCorrectPIN )
        {
            printf("The PIN entered does not match the stored PIN.\n");
            goto cleanup4;
        }
    }

    //
    // Dump all the other Fortezza-specific properties : personality, card serial #
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PERSONALITY,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        BUFFER_SIZE,
                        rgbBuffer );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_FORTEZZA_PERSONALITY,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }
    
    if ( !ConvertToAscii( (LPWSTR) rgbBuffer,
                          &pszPersonality ) )
    {
        goto cleanup4;
    }

    printf("Fortezza personality associated with this instance : %s\n",
           pszPersonality);

    
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        BUFFER_SIZE,
                        rgbBuffer );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }
    
    if ( !ConvertToAscii( (LPWSTR) rgbBuffer,
                          &pszSerialNumber ) )
    {
        goto cleanup4;
    }

    printf("Serial number of Fortezza card associated with this instance : %s\n",
           pszSerialNumber);


    //
    // Get the store name and cert hash, so we can construct a certificate context
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_STORE_NAME,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        BUFFER_SIZE,
                        rgbBuffer );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_STORE_NAME,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }
    
    if ( !ConvertToAscii( (LPWSTR) rgbBuffer,
                          &pszStoreName ) )
    {
        goto cleanup4;
    }

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_HASH,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        SHA1_HASH_SIZE,
                        rgbCertHash );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_HASH,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }


    //
    // Check #1 : can we get a handle to the Fortezza CSP with the stored info ?
    //
    pszCSPString = new CHAR[ strlen(pszSerialNumber) + strlen(pszPersonality) +
                             strlen(pszPIN) + 10 ];

    if ( !pszCSPString )
    {
        printf("Out of memory !\n");
        goto cleanup4;
    }

    strcpy( pszCSPString, pszSerialNumber );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPersonality );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPIN );

    //
    // Get handle to CSP
    //
    if( !CryptAcquireContext(&hProv, 
                             pszCSPString,
                             NULL, 
                             PROV_FORTEZZA, 
                             CRYPT_SILENT ) )
    {
        printf("Couldn't get a handle to the Fortezza CSP\n", 
               GetLastError());
        goto cleanup4;
    }

    //
    // Don't leave the info lying around
    //
    memset( pszCSPString, 0, strlen( pszCSPString ) );
    delete [] pszCSPString;
    pszCSPString = NULL;


    //
    // Check #2 : is the cert hash correct ? 
    //
    if ( !( hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                    0,
                                    hProv,
                                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                    pszStoreName ) ) )
    {
        printf("Couldn't open certificate store %s, error 0x%x\n",
               pszStoreName, GetLastError());
        goto cleanup4;
    }
        

    CRYPT_HASH_BLOB HashBlob;
    HashBlob.cbData = SHA1_HASH_SIZE;
    HashBlob.pbData = rgbCertHash;
    
    pServerCert = CertFindCertificateInStore( hStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_SHA1_HASH,
                                              (VOID *) &HashBlob,
                                              NULL );
    
    if ( !pServerCert )
    {
        printf("Couldn't find Fortezza certificate in store %s, error 0x%x\n",
               pszStoreName, GetLastError());
        goto cleanup4;
    }
    else
    {
        printf("Found Fortezza certificate in store %s\n",
               pszStoreName);
    }

    //
    // Check #3 : Try to build a complete, trusted chain
    //
    if ( !ConstructCertChain( pServerCert,
                              pszStoreName,
                              &fCompleteChain,
                              &fTrustedChain ) )
    {
        printf("Couldn't build a certificate chain : error %d\n",
               GetLastError());
    }
    else
    {
        if ( fCompleteChain )
        {
            printf("Able to build a complete chain, ending in a self-signed certificate.\n");
        }
        if ( fTrustedChain )
        {
            printf("The chain ends in the trusted ROOT store.\n");
        }

        if ( fTrustedChain && !fCompleteChain )
        {
            printf("WARNING : the chain ends in the ROOT store, but not in a self-signed certificate.\n");
        }
        if ( !fTrustedChain && !fCompleteChain )
        {
            printf("Unable to build a chain that is either complete or trusted.\n");
        }
    }
    
cleanup4:
    
    if ( pServerCert )
    {
        CertFreeCertificateContext( pServerCert );
    }

    if ( hStore )
    {
        CertCloseStore( hStore,
                        0 );
    }

    if ( hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    if ( pszPersonality )
    {
        delete [] pszPersonality;
    }

    if ( pszSerialNumber )
    {
        delete [] pszSerialNumber;
    }

    if ( pszStoreName )
    {
        delete [] pszStoreName;
    }
}


BOOL ConvertToUnicode( IN LPSTR pszAsciiStr,
                       OUT LPWSTR *ppwszWideStr )
/*++

Routine Description:

    Converts an ASCII string to Unicode, allocating the necessary memory 

Arguments:

     pszAsciiStr - ASCII string to be converted
     ppwszWideStr - pointer to Unicode string, updated on success


Returns:

    BOOL indicating success/failure

--*/

{
    DWORD dwWideStr = MultiByteToWideChar( CP_ACP,
                                           0,
                                           pszAsciiStr,
                                           -1,
                                           NULL,
                                           0 );

    *ppwszWideStr = new WCHAR[dwWideStr];

    if ( !*ppwszWideStr )
    {
        printf("Out of memory !\n");
        return FALSE;
    }

    if ( !(dwWideStr = MultiByteToWideChar( CP_ACP,
                                            0,
                                            pszAsciiStr,
                                            -1,
                                            *ppwszWideStr,
                                            dwWideStr ) ) )
    {
        printf("Error 0x%x converting %s to unicode \n",
               GetLastError(), pszAsciiStr );
        delete [] *ppwszWideStr;
        *ppwszWideStr = NULL;
        return FALSE;
    }

    return TRUE;
}


BOOL ConvertToAscii( IN LPWSTR pwszWideStr,
                     OUT LPSTR *ppszAsciiStr )
/*++

Routine Description:

    Converts a Unicode strint to ASCII, allocating the necessary memory 

Arguments:

     ppwszWideStr - Unicode string to be converted
     ppszAsciiStr - pointer to ASCII string, updated on success

Returns:

    BOOL indicating success/failure

--*/
{
    DWORD dwAsciiStr = WideCharToMultiByte( CP_ACP,
                                            0,
                                            pwszWideStr,
                                            -1,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL );

    if ( !dwAsciiStr )
    {
        printf("Error converting string to ASCII : 0x%x\n",
               GetLastError());
        return FALSE;
    }

    *ppszAsciiStr = new CHAR[dwAsciiStr];

    if ( !*ppszAsciiStr )
    {
        printf("Out of memory !\n");
        return FALSE;
    }

    if ( !WideCharToMultiByte( CP_ACP,
                               0,
                               pwszWideStr,
                               -1,
                               *ppszAsciiStr,
                               dwAsciiStr,
                               NULL,
                               NULL ) )
    {
        printf("Error converting string to ASCII : 0x%x\n",
               GetLastError());
        delete [] *ppszAsciiStr;
        return FALSE;
    }

    return TRUE;
}



BOOL HasFortezzaCert( IMSAdminBaseW *pMB,
                      METADATA_HANDLE hMDHandle,
                      PBOOL pfHasCert )
/*++

Routine Description:

    Checks whether a given existence/value of Fortezza cert flag on a given metadata handle

Arguments:

    pMB - metabase pointer used for reading
    hMDHandle - metadata handle open for read
    pfHasCert - set to TRUE/FALSE if Fortezza cert flag is present and == 1, false otherwise

Returns:

    BOOL indicating success/failure of check 

--*/
{
    HRESULT hRes = S_OK;
    METADATA_RECORD mdr;
    DWORD cbRequired = 0;
    BOOL fOK = TRUE;
    DWORD dwFortezza = 0;

    *pfHasCert = FALSE;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_IS_FORTEZZA,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        DWORD_METADATA,
                        sizeof(DWORD),
                        &dwFortezza );

    hRes = pMB->GetData( hMDHandle,
                         L"",
                         &mdr,
                         &cbRequired );


    if ( SUCCEEDED( hRes ) )
    {
        if ( dwFortezza )
        {
            *pfHasCert = TRUE;
        }
    }
    //
    // The only "permissible" error is not finding the flag at all
    //
    else if ( HRESULTTOWIN32( hRes ) != MD_ERROR_DATA_NOT_FOUND )
    {
        fOK = FALSE;
    }

    return fOK;
}


BOOL IsCorrectPIN( IMSAdminBaseW *pMB,
                   METADATA_HANDLE hMDHandle,
                   LPWSTR pwszPIN,
                   PBOOL pfCorrectPIN )
/*++

Routine Description:

    Checks whether supplied PIN matches the PIN stored in the metabase 

Arguments:

    pMB - metabase pointer used for reading
    hMDHandle - metadata handle open for read
    pwszPIN - PIN to be checked against PIN in MB
    pfCorrectPIN - BOOL set to true if PINs match, FALSE otherwise

Returns:

    BOOL indicating success/failure of check 

--*/

{

    HRESULT hRes = S_OK;
    METADATA_RECORD mdr;
    DWORD cbRequired = 0;
    BYTE *pbMBPIN = NULL;
    LPWSTR pwszStoredPIN = NULL;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PIN,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        0,
                        NULL );

    hRes = pMB->GetData( hMDHandle,
                         L"",
                         &mdr,
                         &cbRequired );

    if ( HRESULTTOWIN32( hRes ) != ERROR_INSUFFICIENT_BUFFER )
    {
        printf("Failed trying to read data from metabase : 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        return FALSE;
    }
    else
    {
        pbMBPIN = new BYTE[cbRequired];
        
        if ( !pbMBPIN )
        {
            printf("Out of memory\n");
            return FALSE;
        }
        
        MD_SET_DATA_RECORD( &mdr,
                            MD_SSL_CERT_FORTEZZA_PIN,
                            METADATA_SECURE,
                            IIS_MD_UT_SERVER,
                            STRING_METADATA,
                            cbRequired,
                            pbMBPIN );

        if ( SUCCEEDED( hRes = pMB->GetData( hMDHandle,
                                             L"",
                                             &mdr,
                                             &cbRequired ) ) )
        {
            pwszStoredPIN = (LPWSTR) pbMBPIN;
        
            if ( wcscmp( pwszStoredPIN, pwszPIN ) )
            {
                *pfCorrectPIN = FALSE;
            }
            else
            {
                *pfCorrectPIN = TRUE;
            }
        }
        else
        {
            printf("Failed trying to read data from the metabase : 0x%x\n",
                   HRESULTTOWIN32( hRes ) );
            delete [] pbMBPIN;
            return FALSE;
        }
    }

    if ( pbMBPIN )
    {
        delete [] pbMBPIN;
    }

    return TRUE;
}


BOOL BuildFullPath( IN LPSTR pszSubPath,
                    OUT LPWSTR *ppwszFullPath )
/*++

Routine Description:

    Builds a full metabase path by appending the sub path to the root W3SVC path

Arguments:

    pszSubPath - subpath to be appended to W3SVC path
    ppwszFullPath - pointer to pointer to full path, updated on success

Returns:

    BOOL indicating success/failure of building the path

--*/
{
    LPWSTR pwszSubPath = NULL;

    if ( pszSubPath )
    {
        if ( !ConvertToUnicode( pszSubPath,
                                &pwszSubPath ) )
        {
            return FALSE;
        }

        *ppwszFullPath = new WCHAR[ wcslen( MB_ROOT_PATH ) + wcslen( pwszSubPath ) +
                                    3*sizeof( WCHAR ) ];

        if ( !*ppwszFullPath )
        {
            printf("Out of memory !\n");
            delete [] pwszSubPath;
            return FALSE;
        }

        wcscpy( *ppwszFullPath, MB_ROOT_PATH );
        wcscat( *ppwszFullPath, L"/" );
        wcscat( *ppwszFullPath, pwszSubPath );

    }
    else
    {
        *ppwszFullPath = new WCHAR[ wcslen( MB_ROOT_PATH ) + 1];

        if ( !*ppwszFullPath )
        {
            printf("Out of memory \n");
            return FALSE;
        }

        wcscpy( *ppwszFullPath, MB_ROOT_PATH );
    }

    if ( pwszSubPath )
    {
        delete [] pwszSubPath;
    }

    return TRUE;
}
    

BOOL ConstructCertChain( PCCERT_CONTEXT pcLeafCert,
                         LPSTR pszLeafCertStore,
                         PBOOL pfCompleteChain,
                         PBOOL pfTrustedChain )
/*++

Routine Description:

    Constructs the complete cert chain for the leaf cert passed in

Arguments:

    pcLeafCert - cert for which chain is to be constructed
    pszLeafCertStore - name of store from which pcLeafCert came
    list is pcLeafCert.
    pfCompleteChain - set to TRUE if we constructed a full cert chain ie the constructed chain
    ends with a self-signed cert
    pfTrustedChain - set to TRUE if top of chain is in the ROOT store [ie it's trusted]

Returns:

    BOOL indicating success/failure

--*/
{
    HCERTSTORE hMyStore = NULL;
    HCERTSTORE hCAStore = NULL;
    HCERTSTORE hRootStore = NULL;

    *pfTrustedChain = FALSE;
    *pfCompleteChain = FALSE;

    //
    // Open all the stores we'll search for issuers - MY, CA and ROOT
    //
    hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                              0,
                              NULL,
                              CERT_SYSTEM_STORE_LOCAL_MACHINE,
                              MY_STORE_NAME );

    if ( !hMyStore )
    {
        printf("Failed to open MY store, error 0x%x\n", GetLastError());
        return FALSE;
    }


   hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                             0,
                             NULL,
                             CERT_SYSTEM_STORE_LOCAL_MACHINE,
                             CA_STORE_NAME );

    if ( !hCAStore )
    {
        CertCloseStore( hMyStore,
                        0 );
        printf("Failed to open CA store, error 0x%x\n", GetLastError());
        return FALSE;
    }

   hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                               0,
                               NULL,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE,
                               ROOT_STORE_NAME );

    if ( !hRootStore )
    {
        CertCloseStore( hMyStore,
                        0 );

        CertCloseStore( hCAStore,
                        0 );

        printf("Failed to open ROOT store, error 0x%x\n", GetLastError());
        return FALSE;
    }


    //
    // To build the chain, look for issuers in 4 stores : the store the cert came from,
    // and the "MY", "CA" and "ROOT" stores, cycling through the stores as necessary
    //

    PCCERT_CONTEXT pcIssuer = NULL;
    PCCERT_CONTEXT pcPresentLeaf = pcLeafCert;
    DWORD dwFlags = 0;
    DWORD dwStoresTried = 0;
    *pfCompleteChain = FALSE;
    HCERTSTORE hPresentStore = pcPresentLeaf->hCertStore;
    LPSTR pszPresentStore = pszLeafCertStore;
    LPSTR pszCertStore = NULL;

    while ( 1 )
    {
        //
        // Bail when we get to the top of a chain
        //
        if ( IsSelfSignedCert( pcPresentLeaf ) )
        {
            break;
        }

        pcIssuer = CertGetIssuerCertificateFromStore( hPresentStore,
                                                      pcPresentLeaf,
                                                      NULL,
                                                      &dwFlags );

        //
        // Got an issuer in this store
        //
        if ( pcIssuer )
        {
            //
            // Set up for next round
            //
            dwStoresTried = 0;
            pcPresentLeaf = pcIssuer;
            pszCertStore = pszPresentStore;
        }
        //
        // No issuer in this store, switch to next store to look in
        //
        else
        {

            dwStoresTried++;

            if ( dwStoresTried == 4 ) //we've tried all the stores, time to bail
            {
                break;
            }

            if ( hPresentStore == hMyStore )
            {
                hPresentStore = hCAStore;
                pszPresentStore = CA_STORE_NAME;
            }
            else if ( hPresentStore == hCAStore )
            {
                hPresentStore = hRootStore;
                pszPresentStore = ROOT_STORE_NAME;
            }
            else if ( hPresentStore == hRootStore )
            {
                hPresentStore = pcPresentLeaf->hCertStore;
                pszPresentStore = pszLeafCertStore;
            }
            else
            {
                hPresentStore = hMyStore;
                pszPresentStore = MY_STORE_NAME;
            }
        }
    } //while ( 1 )


    //
    // Set flags indicating status of entire chain
    //
    if ( IsSelfSignedCert( pcPresentLeaf ) )
    {
        *pfCompleteChain = TRUE;
    }

    if ( pszCertStore && !strcmp( pszCertStore, ROOT_STORE_NAME ) )
    {
        *pfTrustedChain = TRUE;
    }

    //
    // Cleanup
    //
    CertCloseStore( hMyStore,
                    0 );
    CertCloseStore( hCAStore,
                    0 );
    CertCloseStore( hRootStore,
                    0 );


    return TRUE;
}

BOOL IsSelfSignedCert( IN PCCERT_CONTEXT pCertContext )
/*++

Routine Description:

    Determines whether a cert is self-signed ie the top of a hierarchy

Arguments:

    pCertContext - cert to be checked

Returns:

    TRUE if cert is self-signed, FALSE otherwise

--*/
{
    //
    // Compare subject and issuer.
    //
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL IsNumber( LPCSTR pszName )
{
    return ( atoi( pszName) > 0 ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\ui\itools\mime\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mime.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\cfgmntadmin.h ===
// CfgMntAdmin.h : Declaration of the CCfgMntAdmin

#ifndef __CFGMNTADMIN_H_
#define __CFGMNTADMIN_H_

#include "resource.h"       // main symbols
#include "VerEngine.h"
#include "CfgMntModule.h"

/////////////////////////////////////////////////////////////////////////////
// CCfgMntAdmin
class ATL_NO_VTABLE CCfgMntAdmin : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCfgMntAdmin, &CLSID_CfgMntAdmin>,
	public IDispatchImpl<ICfgMntAdmin, &IID_ICfgMntAdmin, &LIBID_CFGMNTLib>
{
public:
	CCfgMntAdmin()
	{
		_ASSERTE(g_pCfgMntModule);
		m_pVerEngine = &g_pCfgMntModule->m_VerEngine;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CFGMNTADMIN)

BEGIN_COM_MAP(CCfgMntAdmin)
	COM_INTERFACE_ENTRY(ICfgMntAdmin)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ICfgMntAdmin
public:
	STDMETHOD(ShutDown)();
	STDMETHOD(Rollback)(/*[in]*/BSTR bstrMDPath,/*[in]*/BSTR bstrDateTime);
	STDMETHOD(GetVersions)(/*[in]*/BSTR bstrMDPath, /*[out,retval]*/IUnknown **hICfgMntVersions);
	STDMETHOD(GetHistory)(/*[in]*/BSTR bstrMDPath);
private:
	CVerEngine * m_pVerEngine;
};

#endif //__CFGMNTADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\autoptr.h ===
// AutoPtr.h: interface for the CAutoPtr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_AUTOPTR_H__82D00BEB_039E_11D1_A436_00C04FB99B01__INCLUDED_)
#define AFX_AUTOPTR_H__82D00BEB_039E_11D1_A436_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

template <class T>
class CAutoPtr  
{
public:
	CAutoPtr() { m_p = NULL; };
	CAutoPtr(T* p) { m_p = p; };
	CAutoPtr(const CAutoPtr<T>& p) { m_p = p.m_p; };
	virtual ~CAutoPtr() 
		{
			if(m_p)
				delete m_p;
			m_p = NULL;
		};
	operator T*() { return (T*) m_p; };
	T& operator*() 
		{ 
			_ASSERTE(m_p != NULL);	
			return *p;				,
		};							
	// the assert on operator& usually indicates
	// a bug. If this is really what is needed, however
	// take the address of the member m_p explicitly.
	T** operator&() { _ASSERTE(m_p == NULL); return &m_p; };
	T* operator->() { _ASSERTE(m_p != NULL); return m_p; };
	T* operator=(T* p) { return m_p = p; };
	T* operator=(const CAutoPtr<T>& p) { return m_p = p.m_p; };
#if _MSC_VER>1020
	bool operator!(){return (m_p == NULL);}
#else
	BOOL operator!(){return (m_p == NULL) ? TRUE : FALSE;}
#endif
	T* m_p;
};

#endif // !defined(AFX_AUTOPTR_H__82D00BEB_039E_11D1_A436_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\cfgmnt.cpp ===
// CfgMnt.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CfgMntps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "CfgMnt.h"

#include "CfgMnt_i.c"
#include "CfgMntAdmin.h"
#include "CfgMntVersions.h"

#include "CfgMntModule.h"

LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
	return l;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CfgMntVersions, CCfgMntVersions)
	OBJECT_ENTRY(CLSID_CfgMntAdmin, CCfgMntAdmin)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
//	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	_ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap, hInstance);
	_Module.dwThreadID = GetCurrentThreadId();
	TCHAR szTokens[] = _T("-/");

	int nRet = 0;
	BOOL bRun = TRUE;
	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_CfgMnt, FALSE);
			nRet = _Module.UnregisterServer();
			bRun = FALSE;
			break;
		}
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_CfgMnt, TRUE);
			nRet = _Module.RegisterServer(TRUE);
			bRun = FALSE;
			break;
		}
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (bRun)
	{
		hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
			REGCLS_MULTIPLEUSE);
		_ASSERTE(SUCCEEDED(hRes));

////////////////////////////////////////////////////////////
		CCfgMntModule CfgMntModule;
////////////////////////////////////////////////////////////

		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
			DispatchMessage(&msg);

		_Module.RevokeClassObjects();
	}

	_Module.Term();
	CoUninitialize();
	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

	/* t-brianm (6-3-97) Added ASSERT_STRING macros */
#define ASSERT_STRING(s) \
    ASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    ASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\cfgmntmodule.h ===
// CfgMntModule.h: interface for the CCfgMntModule class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CFGMNTMODULE_H__7A5D77AB_1982_11D1_A44C_00C04FB99B01__INCLUDED_)
#define AFX_CFGMNTMODULE_H__7A5D77AB_1982_11D1_A44C_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "VerEngine.h"
#include "OperationQueue.h"
#include "DirWatch.h"
#include "SettingsWatch.h"

interface ICfgMntAdmin; // forward declaration

class CCfgMntModule  
{
public:
	CCfgMntModule();
	virtual ~CCfgMntModule();
	void ShutDown();

public:
	CVerEngine m_VerEngine;
	COpQueue m_OpQ;
	CWatchFileSys m_WatchFS;
	CWatchMD m_WatchMD;
	CComPtr<ICfgMntAdmin> m_pICfgMntAdmin;
};

extern CCfgMntModule *g_pCfgMntModule;

#endif // !defined(AFX_CFGMNTMODULE_H__7A5D77AB_1982_11D1_A44C_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


//#define ACTIVE_SERVER_PAGES 1


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\dirwatch.h ===
// DirWatch.h: interface for the CDirWatch class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIRWATCH_H__EC78FB5A_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
#define AFX_DIRWATCH_H__EC78FB5A_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "OperationQueue.h"
#define MAX_BUFFER 1024

class CWatchFileSys; // forward reference

class CWatchFileSys
{
public:
	// adding
	HRESULT Add(LPCTSTR szDir,LPCTSTR szPrj);
	// init/shutdown
	HRESULT NewInit(COpQueue *pOpQ);
	void ShutDown();
	// ctor/dtor
	CWatchFileSys();
	virtual ~CWatchFileSys();

private:
	class CDirInfo 
		{
		public:
			CDirInfo(LPCTSTR szDir,LPCTSTR szPrj) 
				: m_hDir(NULL),m_iBuffer(MAX_BUFFER),m_pNext(NULL)
				{
					_ASSERTE(szDir && szPrj);
					m_szDir = szDir;
					m_szPrj = szPrj;
					memset(&m_Overlapped,0,sizeof(m_Overlapped));
				};
			~CDirInfo() 
				{
					if(m_hDir)
						CloseHandle(m_hDir);
					m_hDir = NULL;
				};
			HANDLE m_hDir;
			wstring m_szDir;
			wstring m_szPrj;
			CHAR m_cBuffer[MAX_BUFFER];
			DWORD m_iBuffer;
			OVERLAPPED m_Overlapped;
			CDirInfo *m_pNext;
		};

	class CWatchInfo
		{
		public:
			CWatchInfo(CWatchFileSys *pWatchFS) 
				: m_pWatchFileSys(pWatchFS), m_hThread(NULL), m_iThreadID(0), 
				  m_hCompPort(NULL),m_pDirInfoHead(NULL),m_pDirInfoTail(NULL) 
				{;};
			~CWatchInfo() 
				{
					CDirInfo *ptmp = NULL;
					while(m_pDirInfoHead)
					{
						ptmp = m_pDirInfoHead->m_pNext;
						delete m_pDirInfoHead;
						m_pDirInfoHead = ptmp;
					}
					m_pDirInfoTail = NULL;
				}
			void AddDirInfo(CDirInfo *pDirInfo)
				{
					if(m_pDirInfoTail == NULL)
					{
						_ASSERT(m_pDirInfoHead == NULL);
						m_pDirInfoHead = pDirInfo;
						m_pDirInfoTail = pDirInfo;
					} else {
						m_pDirInfoTail->m_pNext = pDirInfo;
						m_pDirInfoTail = pDirInfo;
					}
				}

			CWatchFileSys *m_pWatchFileSys;
			CDirInfo *m_pDirInfoHead;
			CDirInfo *m_pDirInfoTail;
			HANDLE m_hThread;
			DWORD m_iThreadID;
			HANDLE m_hCompPort;
		};

	static DWORD WINAPI NotificationThreadProc(LPVOID lpParam);
	BOOL IssueWatch(CDirInfo *pDirInfo);
	bool AddHelper(CWatchInfo &rWatchInfo,CDirInfo *pDirInfo);
	void ShutDownHelper(CWatchInfo &rWatchInfo);

	COpQueue *m_pOpQ;
	CWatchInfo m_WatchInfo;
};

#endif // !defined(AFX_DIRWATCH_H__EC78FB5A_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\error.cpp ===
// Error.cpp: implementation of the CError class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Error.h"

#include "debug.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CError::CError()
{

}

CError::~CError()
{

}

void CError::ErrorMsgBox(HRESULT hr)
{
	LPTSTR lpMsgBuf;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		hr,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);

	// Display the string.
	MessageBox( NULL, lpMsgBuf, TEXT("Error"), MB_OK | MB_ICONINFORMATION );

	// Free the buffer.
	LocalFree( lpMsgBuf );
}

void CError::ErrorTrace(HRESULT hr,LPCSTR szStr,LPCSTR szFile,int iLine)
{
	CHAR tmp[2048];
	LPSTR lpMsgBuf;

	DWORD iMsgBuf = FormatMessageA( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		hr,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPSTR) &lpMsgBuf,
		0,
		NULL 
	);

	if(iMsgBuf == 0)
	{
		_ASSERTE(!lpMsgBuf);
		lpMsgBuf = "\n";
	}

	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if(hStdOut != INVALID_HANDLE_VALUE)
	{
		DWORD i = wsprintfA(tmp,"%s: Error [%x] %s",szStr,hr,lpMsgBuf);
		if(i)
		{
			Trace(tmp);
		}
		if(HRESULT_FACILITY(hr) == FACILITY_ITF)
		{
			USES_CONVERSION;
			HRESULT hres = S_OK;
			IErrorInfo *pIErrInfo = NULL;
			hres = GetErrorInfo(NULL,&pIErrInfo);
			if(hres == S_OK)
			{
				BSTR bstr = NULL;
				BSTR bstrHelpFile = NULL;
				hres = pIErrInfo->GetDescription(&bstr);

				hres = pIErrInfo->GetHelpFile(&bstrHelpFile);
				i = wsprintfA(tmp,"IErrInf: %s ",OLE2A(bstr));
				Trace(tmp);
				SysFreeString(bstr);
				SysFreeString(bstrHelpFile);
				pIErrInfo->Release();
			}
		}
		i = wsprintfA(tmp,"in %s line %d.",szFile,iLine);
		if(i)
		{
			Trace(tmp);
		}
		Trace(tmp);
	}

	// Free the buffer.
	if(iMsgBuf > 0)
		LocalFree( lpMsgBuf );
}

void CError::Trace(LPCTSTR szStr)
{
#ifdef TRACE
	::TRACE(szStr);
#else
	USES_CONVERSION;
	LPCSTR szStrA = T2A(szStr);

	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if(hStdOut != INVALID_HANDLE_VALUE)
	{
		DWORD i = strlen(szStrA);
		DWORD j;
		WriteFile(hStdOut,szStrA,i,&j,NULL);
	}
#endif
}

void CError::Trace(LPCSTR szStr)
{
#ifdef TRACE
	USES_CONVERSION;
	LPCTSTR szStrW = A2T(szStr);

	::TRACE(szStrW);
#else
	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if(hStdOut != INVALID_HANDLE_VALUE)
	{
		DWORD i = strlen(szStr);
		DWORD j;
		WriteFile(hStdOut,szStr,i,&j,NULL);
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\dirwatch.cpp ===
// DirWatch.cpp: implementation of the CWatchFileSys class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DirWatch.h"
#include "Error.h"
#include "MT.h"
#include "AutoPtr.h"
#include "Error.h"
#include "iadmw.h"		// COM Interface header
#include "iiscnfg.h"	// MD_ & IIS_MD_ #defines

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWatchFileSys::CWatchFileSys()
	: m_WatchInfo(this), m_pOpQ(NULL)
{

}

CWatchFileSys::~CWatchFileSys()
{
	// verify that thread terminated
	ShutDown();
}

HRESULT CWatchFileSys::NewInit(COpQueue *pOpQ)
{
	_ASSERTE(pOpQ && !m_pOpQ);
	m_pOpQ = pOpQ;
	HRESULT hr = S_OK;
	CComPtr<IMSAdminBase> pIAdminBase;

	// check if we already have a metabase instance
	// create adminbase instance
	hr = CoCreateInstance(CLSID_MSAdminBase,
							NULL, 
							CLSCTX_ALL, 
							IID_IMSAdminBase, 
							(void **) &pIAdminBase);
	IF_FAIL_RTN1(hr,"CoCreateInstance IID_IMSAdminBase");

	METADATA_HANDLE hMD = NULL;
	WCHAR szKeyName[3+6+ 2* METADATA_MAX_NAME_LEN]			// /LM/W3SVC/sitename/vir_dir
		= L"/LM/W3SVC/";
	LPTSTR szSiteKeyName = &szKeyName[wcslen(szKeyName)];	// point to the end of string so we can append it
	DWORD iSiteEnumIndex = 0;
	LPTSTR szVDirKeyName = NULL;
	DWORD iVDirEnumIndex = 0;

	hr = pIAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
								szKeyName,
								METADATA_PERMISSION_READ,
								20,
								&hMD);
	IF_FAIL_RTN1(hr,"IAdminBase::OpenKey");

	METADATA_RECORD MDRec;
	DWORD iBufLen = 1024;
	DWORD iReqBufLen = 0;
	PBYTE pbBuf = new BYTE[iBufLen];
	if(!pbBuf)
	{
		pIAdminBase->CloseKey(hMD);
		return E_OUTOFMEMORY;
	}
	DWORD iDataIndex = 0;

	while(SUCCEEDED(hr = pIAdminBase->EnumKeys(hMD,TEXT(""),szSiteKeyName,iSiteEnumIndex)))
	{
		// iterate through all virtual sites on this machine
		wcscat(szSiteKeyName,L"/ROOT/");
		szVDirKeyName = szSiteKeyName + wcslen(szSiteKeyName);
		
		iVDirEnumIndex = 0;
		while(SUCCEEDED(hr = pIAdminBase->EnumKeys(hMD,szSiteKeyName,szVDirKeyName,iVDirEnumIndex)))
		{
			// iterate through all virtual directories in each site
			MDRec.dwMDIdentifier = MD_VR_PATH;
			MDRec.dwMDAttributes = METADATA_INHERIT;
			MDRec.dwMDUserType = IIS_MD_UT_FILE;
			MDRec.dwMDDataType = ALL_METADATA;
			MDRec.dwMDDataLen = iBufLen;
			MDRec.pbMDData = pbBuf;
			hr = pIAdminBase->GetData(hMD,szSiteKeyName,&MDRec,&iReqBufLen);
			if(hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
			{
				delete [] pbBuf;
				pbBuf = new BYTE[iReqBufLen];
				if(!pbBuf)
				{
					pIAdminBase->CloseKey(hMD);
					return E_OUTOFMEMORY;
				}
				iBufLen = iReqBufLen;
				MDRec.dwMDDataLen = iBufLen;
				MDRec.pbMDData = pbBuf;
				hr = pIAdminBase->GetData(hMD,szSiteKeyName,&MDRec,&iReqBufLen);
			}

			// @todo: verify that this dir should be watched
			//        i.e. check if do-not-version flag is set

			if(SUCCEEDED(hr))
			{
				// add 
				wstring szPrj(L"/Files/");			//@todo: decide on prj
					szPrj.append(szSiteKeyName);
				hr = Add((LPCTSTR)MDRec.pbMDData,szPrj.c_str());
				IF_FAIL_RPT1(hr,"CWatchFileSys::Add");
			}
			else
			{
				CError::Trace("Can't get dir for ");
				CError::Trace(szVDirKeyName);
				CError::Trace("\n");
			}
			iVDirEnumIndex++;
		}
		iSiteEnumIndex++;	
	}
	pIAdminBase->CloseKey(hMD);
	delete [] pbBuf;

	return S_OK;
}

void CWatchFileSys::ShutDownHelper(CWatchInfo &rWatchInfo)
{
	if(rWatchInfo.m_hThread)
	{
		// end notification thread
		PostQueuedCompletionStatus(rWatchInfo.m_hCompPort,0,0,NULL);
		// wait for thread to finish
		WaitForSingleObject(rWatchInfo.m_hThread,INFINITE);
		CloseHandle(rWatchInfo.m_hThread);
		rWatchInfo.m_hThread = NULL;
		rWatchInfo.m_iThreadID = 0;
	}
	if(rWatchInfo.m_hCompPort)
	{
		// clean up
		CloseHandle(rWatchInfo.m_hCompPort);
		rWatchInfo.m_hCompPort = NULL;
	}
}

void CWatchFileSys::ShutDown()
{
	ShutDownHelper(m_WatchInfo);
	m_pOpQ = NULL;
}

DWORD WINAPI CWatchFileSys::NotificationThreadProc(LPVOID lpParam)
{
	_ASSERTE(lpParam);
	CWatchInfo *pWI = (CWatchInfo*) lpParam;
	CWatchFileSys *pWatchFileSys = pWI->m_pWatchFileSys;

	// vars for accessing the notification
	DWORD iBytes = 0;
	CDirInfo *pDirInfo = NULL;
	LPOVERLAPPED pOverlapped = NULL;
	PFILE_NOTIFY_INFORMATION pfni = NULL;
	DWORD cbOffset = 0;

	// vars for creating a file op
	HRESULT hr;
	COpFileSys *pOp = NULL;
	LPCTSTR szPrj = NULL;
	LPCTSTR szDir = NULL;
	wstring szFileName;
	wstring szOldFileName;

	do
	{
		_ASSERTE(pWI->m_hCompPort);
		GetQueuedCompletionStatus(pWI->m_hCompPort,
								  &iBytes,
								  (LPDWORD) &pDirInfo,
								  &pOverlapped,
								  INFINITE);
		if(pDirInfo)
		{
			// get ptr to first file_notify_info in buffer
			pfni = (PFILE_NOTIFY_INFORMATION) pDirInfo->m_cBuffer;

			// clean 
			szFileName.erase();			// empty to avoid compare wrong compares
			szOldFileName.erase();		// empty

			// remember dir and prj they are the same for all entries
			szPrj = pDirInfo->m_szPrj.c_str();
			szDir = pDirInfo->m_szDir.c_str();

			// process all file_notify_infos in buffer
			_ASSERTE(pWatchFileSys->m_pOpQ);
			do
			{
				cbOffset = pfni->NextEntryOffset;
				
				// sometime an errorous action #0 is send, let's ignore it
				switch(pfni->Action) {
					case FILE_ACTION_ADDED:
					case FILE_ACTION_REMOVED:
					case FILE_ACTION_MODIFIED:
					case FILE_ACTION_RENAMED_OLD_NAME:
					case FILE_ACTION_RENAMED_NEW_NAME:
						break;
					default:
						// unknown action, let's ignore it
						pfni = (PFILE_NOTIFY_INFORMATION) ((LPBYTE)pfni + cbOffset);// get next offset
						continue;
				}
				
				// on rename remember old filename
				szOldFileName.erase();
				if(pfni->Action == FILE_ACTION_RENAMED_OLD_NAME)
				{
					// make sure next entry exists and is new-name entry
					_ASSERTE(cbOffset);		// there is another entry
					PFILE_NOTIFY_INFORMATION pNextfni = (PFILE_NOTIFY_INFORMATION) ((LPBYTE)pfni + cbOffset);
					_ASSERTE(pNextfni->Action == FILE_ACTION_RENAMED_NEW_NAME); // the next entry contians the new name
					
					// assign old name
					szOldFileName.assign(pfni->FileName,pfni->FileNameLength/2);
					
					// skip to next (new-name) entry
					pfni = pNextfni;
					cbOffset = pNextfni->NextEntryOffset;

					// clear szFileName so it doesn't get skiped in next lines
					szFileName.erase();
				}

				// assign affected filename
				szFileName.assign(pfni->FileName,pfni->FileNameLength/2);

				// create new operation
				pOp = new COpFileSys(pfni->Action,szPrj,szDir,szFileName.c_str(),szOldFileName.c_str());
				if(!pOp)
				{
					// this is bad. no more mem? what to do? need to shutdown entire thread/process
					FAIL_RPT1(E_OUTOFMEMORY,"new COpFile()");

					// continue
					break;
				}

				// add operation
				hr = pWatchFileSys->m_pOpQ->Add(pOp);
				if(FAILED(hr))
				{
					// @todo log err
					FAIL_RPT1(E_FAIL,"COpQueue::Add failed");
					delete pOp;
				}
				if(hr == S_FALSE)	// op was a dupl
					delete pOp;		// so delete and ignore
				pOp = NULL;

				// get next offset
				pfni = (PFILE_NOTIFY_INFORMATION) ((LPBYTE)pfni + cbOffset);
			} while(cbOffset);
			
			// reissue the watch
			if(!pWatchFileSys->IssueWatch(pDirInfo))
			{
				// @todo: log error
			}
		}
	} while( pDirInfo );

	// end of thread
	return 0;
}

bool CWatchFileSys::AddHelper(CWatchInfo &rWatchInfo,CDirInfo *pDirInfo)
{
	// create completion port, or add to it
	rWatchInfo.m_hCompPort = CreateIoCompletionPort(pDirInfo->m_hDir,
													rWatchInfo.m_hCompPort,
													(DWORD)(CDirInfo*) pDirInfo,
													0);
	if(!rWatchInfo.m_hCompPort)
		return false;

	// watch directory
	if(!IssueWatch(pDirInfo))
		return false;

	// create notification thread (if not already exist)
	if(!rWatchInfo.m_hThread)
	{
		rWatchInfo.m_hThread = _beginthreadex(
									NULL,			// no security descriptor
									0,				// default stack size
									NotificationThreadProc,	//thread procedure
									&rWatchInfo,			// thread procedure argument
									0,				// run imideately
									&rWatchInfo.m_iThreadID);	// place to store id
		if(!rWatchInfo.m_hThread)
		return false;
	}
	
	// if everything was successfull, add dirinfo to list
	rWatchInfo.AddDirInfo(pDirInfo);
	return true;
}

HRESULT CWatchFileSys::Add(LPCTSTR szDir,LPCTSTR szRelPrj)
{
	CAutoPtr<CDirInfo> pDirInfo;
	_ASSERTE(szDir && szRelPrj);
	
	// @todo: check that dir is not already part of list (check in subtree as well)
	
	// @todo: convert szDir to Abstolute path
		
	// create dirinfo 
	pDirInfo = new CDirInfo(szDir,szRelPrj);
	if(!pDirInfo)
		FAIL_RTN1(E_OUTOFMEMORY,"new CDirInfo()");

	// get handle to dir
	pDirInfo->m_hDir = CreateFile(szDir,
								  FILE_LIST_DIRECTORY,
 								  FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
								  NULL,
								  OPEN_EXISTING,
								  FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED,
								  NULL);
	if(pDirInfo->m_hDir == INVALID_HANDLE_VALUE)
		goto _Error;

	if(!AddHelper(m_WatchInfo,pDirInfo))
		goto _Error;
	// @todo: call only if startup flag set. 
	// the following call is slow!!!
	// the following line should only be called if you want to bring the 
	// versioning store to the same state as the file system. I.e. all files
	// will be checked in, and unnecessary files in the version store will be
	// marked deleted.
	
//	pVerEngine->SyncPrj(szPrj.c_str,szDir); // @todo: should only be called when 
	pDirInfo = NULL;

	CError::Trace("Watching: ");
	CError::Trace(szDir);
	CError::Trace("\n");

	return S_OK;

_Error:
	CError::ErrorMsgBox(GetLastError());
	return E_FAIL;
}

BOOL CWatchFileSys::IssueWatch(CDirInfo * pDirInfo)
{
	_ASSERTE(pDirInfo);
	BOOL b;
	DWORD dwNotifyFilter =  FILE_NOTIFY_CHANGE_FILE_NAME	
							| FILE_NOTIFY_CHANGE_DIR_NAME
//							| FILE_NOTIFY_CHANGE_SIZE
//							| FILE_NOTIFY_CHANGE_CREATION
							| FILE_NOTIFY_CHANGE_LAST_WRITE;

	b = ReadDirectoryChangesW(pDirInfo->m_hDir,
								 pDirInfo->m_cBuffer,
								 MAX_BUFFER,
								 TRUE,
								 dwNotifyFilter,
								 & pDirInfo->m_iBuffer,
								 & pDirInfo->m_Overlapped,
								 NULL);
	if(!b)
	{
		CError::ErrorTrace(GetLastError(),"ReadDirectoryChangesW failed",__FILE__,__LINE__);
	}
	return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\error.h ===
// Error.h: interface for the CError class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ERROR_H__0E27E3A0_FD59_11D0_A435_00C04FB99B01__INCLUDED_)
#define AFX_ERROR_H__0E27E3A0_FD59_11D0_A435_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CError  
{
public:
	static void ErrorMsgBox(HRESULT hr);
	static void ErrorTrace(HRESULT hr,LPCSTR szStr,LPCSTR szFile,int iLine);
	static void Trace(LPCSTR szStr);
	static void Trace(LPCTSTR szStr);

	CError();
	virtual ~CError();
};


// @todo make these macros log the errors
#define FAIL_RPT1(hr,str) CError::ErrorTrace(hr,str,__FILE__,__LINE__)
#define FAIL_RTN1(hr,str) { FAIL_RPT1(hr,str); return hr;}
#define IF_FAIL_RTN(hr) if(FAILED(hr)) { FAIL_RTN1(hr,L""); return hr; }
#define IF_FAIL_RTN1(hr,str) if(FAILED(hr)) { FAIL_RTN1(hr,str); return hr; }
#define IF_FAIL_RPT1(hr,str) if(FAILED(hr)) { FAIL_RPT1(hr,str); };

#endif // !defined(AFX_ERROR_H__0E27E3A0_FD59_11D0_A435_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\iadmw.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0106 */
/* at Fri Aug 01 12:56:48 1997
 */
/* Compiler settings for .\iadmw.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iadmw_h__
#define __iadmw_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMSAdminBaseW_FWD_DEFINED__
#define __IMSAdminBaseW_FWD_DEFINED__
typedef interface IMSAdminBaseW IMSAdminBaseW;
#endif 	/* __IMSAdminBaseW_FWD_DEFINED__ */


#ifndef __IMSAdminBaseSinkW_FWD_DEFINED__
#define __IMSAdminBaseSinkW_FWD_DEFINED__
typedef interface IMSAdminBaseSinkW IMSAdminBaseSinkW;
#endif 	/* __IMSAdminBaseSinkW_FWD_DEFINED__ */


/* header files for imported files */
#include "mddefw.h"
#include "objidl.h"
#include "ocidl.h"


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_iadmw_0000
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [local] */ 


/*++
                                                                                
Copyright (c) 1997 Microsoft Corporation
                                                                                
Module Name: iadmw.h
                                                                                
    Admin Objects Interfaces
                                                                                
--*/
#ifndef _ADM_IADMW_
#define _ADM_IADMW_
#include <mdcommsg.h>
#include <mdmsg.h>
/*                                                                              
    Error Codes                                                                 
                                                                                
        Admin api's all return HRESULTS. Since internal results are either   
        winerrors or Metadata specific return codes (see mdmsg.h), they are     
        converted to HRESULTS using the RETURNCODETOHRESULT macro (see          
        commsg.h).                                                              
*/                                                                              
                                                                                
/*                                                                              
    Max Name Length                                                             
        The maximum number of characters in the length of a metaobject name,    
        including the terminating NULL. This refers to each node in the tree,   
        not the entire path.                                                    
        eg. strlen("Root") < ADMINDATA_MAX_NAME_LEN                           
*/                                                                              
#define ADMINDATA_MAX_NAME_LEN           256
                                                                                
#define CLSID_MSAdminBase       CLSID_MSAdminBase_W                             
#define CLSID_MSAdminBaseExe    CLSID_MSAdminBaseExe_W                          
#define IID_IMSAdminBase        IID_IMSAdminBase_W                              
#define IMSAdminBase            IMSAdminBaseW                                   
#define IMSAdminBaseSink        IMSAdminBaseSinkW                               
#define IID_IMSAdminBaseSink    IID_IMSAdminBaseSink_W                          
#define GETAdminBaseCLSID       GETAdminBaseCLSIDW                              
                                                                                
DEFINE_GUID(CLSID_MSAdminBase_W, 0xa9e69610, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
DEFINE_GUID(IID_IMSAdminBase_W, 0x70b51430, 0xb6ca, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
DEFINE_GUID(CLSID_MSAdminBaseExe_W, 0xa9e69611, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
DEFINE_GUID(IID_IMSAdminBaseSink_W, 0xa9e69612, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
#define GETAdminBaseCLSIDW(IsService) ((IsService) ? CLSID_MSAdminBase_W : CLSID_MSAdminBaseExe_W)
/*                                                                              
The Main Interface, UNICODE                                                     
*/                                                                              


extern RPC_IF_HANDLE __MIDL_itf_iadmw_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iadmw_0000_v0_0_s_ifspec;

#ifndef __IMSAdminBaseW_INTERFACE_DEFINED__
#define __IMSAdminBaseW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMSAdminBaseW
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IMSAdminBaseW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70B51430-B6CA-11d0-B9B9-00A0C922E750")
    IMSAdminBaseW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteChildKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [size_is][out] */ LPWSTR pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [string][in][unique] */ LPCWSTR pszMDNewName) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetAllData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAllData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataPaths( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ WCHAR __RPC_FAR *pszBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePermissions( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveData( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandleInfo( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemChangeNumber( 
            /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataSetNumber( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastChangeTime( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastChangeTime( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime) = 0;
        
        virtual /* [restricted][local] */ HRESULT STDMETHODCALLTYPE KeyExchangePhase1( void) = 0;
        
        virtual /* [restricted][local] */ HRESULT STDMETHODCALLTYPE KeyExchangePhase2( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBackups( 
            /* [size_is][out][in] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD __RPC_FAR *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteBackup( 
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalInterface( 
            /* [out] */ IMSAdminBaseW __RPC_FAR *__RPC_FAR *piadmbwInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSAdminBaseWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteChildKeys )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumKeys )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [size_is][out] */ LPWSTR pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenameKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [string][in][unique] */ LPCWSTR pszMDNewName);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataPaths )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ WCHAR __RPC_FAR *pszBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangePermissions )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveData )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHandleInfo )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemChangeNumber )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataSetNumber )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLastChangeTime )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastChangeTime )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime);
        
        /* [restricted][local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeyExchangePhase1 )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        /* [restricted][local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeyExchangePhase2 )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Backup )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Restore )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumBackups )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [size_is][out][in] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD __RPC_FAR *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBackup )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnmarshalInterface )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [out] */ IMSAdminBaseW __RPC_FAR *__RPC_FAR *piadmbwInterface);
        
        END_INTERFACE
    } IMSAdminBaseWVtbl;

    interface IMSAdminBaseW
    {
        CONST_VTBL struct IMSAdminBaseWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSAdminBaseW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSAdminBaseW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSAdminBaseW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSAdminBaseW_AddKey(This,hMDHandle,pszMDPath)	\
    (This)->lpVtbl -> AddKey(This,hMDHandle,pszMDPath)

#define IMSAdminBaseW_DeleteKey(This,hMDHandle,pszMDPath)	\
    (This)->lpVtbl -> DeleteKey(This,hMDHandle,pszMDPath)

#define IMSAdminBaseW_DeleteChildKeys(This,hMDHandle,pszMDPath)	\
    (This)->lpVtbl -> DeleteChildKeys(This,hMDHandle,pszMDPath)

#define IMSAdminBaseW_EnumKeys(This,hMDHandle,pszMDPath,pszMDName,dwMDEnumObjectIndex)	\
    (This)->lpVtbl -> EnumKeys(This,hMDHandle,pszMDPath,pszMDName,dwMDEnumObjectIndex)

#define IMSAdminBaseW_CopyKey(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,bMDOverwriteFlag,bMDCopyFlag)	\
    (This)->lpVtbl -> CopyKey(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,bMDOverwriteFlag,bMDCopyFlag)

#define IMSAdminBaseW_RenameKey(This,hMDHandle,pszMDPath,pszMDNewName)	\
    (This)->lpVtbl -> RenameKey(This,hMDHandle,pszMDPath,pszMDNewName)

#define IMSAdminBaseW_SetData(This,hMDHandle,pszMDPath,pmdrMDData)	\
    (This)->lpVtbl -> SetData(This,hMDHandle,pszMDPath,pmdrMDData)

#define IMSAdminBaseW_GetData(This,hMDHandle,pszMDPath,pmdrMDData,pdwMDRequiredDataLen)	\
    (This)->lpVtbl -> GetData(This,hMDHandle,pszMDPath,pmdrMDData,pdwMDRequiredDataLen)

#define IMSAdminBaseW_DeleteData(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType)	\
    (This)->lpVtbl -> DeleteData(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType)

#define IMSAdminBaseW_EnumData(This,hMDHandle,pszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen)	\
    (This)->lpVtbl -> EnumData(This,hMDHandle,pszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen)

#define IMSAdminBaseW_GetAllData(This,hMDHandle,pszMDPath,dwMDAttributes,dwMDUserType,dwMDDataType,pdwMDNumDataEntries,pdwMDDataSetNumber,dwMDBufferSize,pbMDBuffer,pdwMDRequiredBufferSize)	\
    (This)->lpVtbl -> GetAllData(This,hMDHandle,pszMDPath,dwMDAttributes,dwMDUserType,dwMDDataType,pdwMDNumDataEntries,pdwMDDataSetNumber,dwMDBufferSize,pbMDBuffer,pdwMDRequiredBufferSize)

#define IMSAdminBaseW_DeleteAllData(This,hMDHandle,pszMDPath,dwMDUserType,dwMDDataType)	\
    (This)->lpVtbl -> DeleteAllData(This,hMDHandle,pszMDPath,dwMDUserType,dwMDDataType)

#define IMSAdminBaseW_CopyData(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,dwMDAttributes,dwMDUserType,dwMDDataType,bMDCopyFlag)	\
    (This)->lpVtbl -> CopyData(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,dwMDAttributes,dwMDUserType,dwMDDataType,bMDCopyFlag)

#define IMSAdminBaseW_GetDataPaths(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType,dwMDBufferSize,pszBuffer,pdwMDRequiredBufferSize)	\
    (This)->lpVtbl -> GetDataPaths(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType,dwMDBufferSize,pszBuffer,pdwMDRequiredBufferSize)

#define IMSAdminBaseW_OpenKey(This,hMDHandle,pszMDPath,dwMDAccessRequested,dwMDTimeOut,phMDNewHandle)	\
    (This)->lpVtbl -> OpenKey(This,hMDHandle,pszMDPath,dwMDAccessRequested,dwMDTimeOut,phMDNewHandle)

#define IMSAdminBaseW_CloseKey(This,hMDHandle)	\
    (This)->lpVtbl -> CloseKey(This,hMDHandle)

#define IMSAdminBaseW_ChangePermissions(This,hMDHandle,dwMDTimeOut,dwMDAccessRequested)	\
    (This)->lpVtbl -> ChangePermissions(This,hMDHandle,dwMDTimeOut,dwMDAccessRequested)

#define IMSAdminBaseW_SaveData(This)	\
    (This)->lpVtbl -> SaveData(This)

#define IMSAdminBaseW_GetHandleInfo(This,hMDHandle,pmdhiInfo)	\
    (This)->lpVtbl -> GetHandleInfo(This,hMDHandle,pmdhiInfo)

#define IMSAdminBaseW_GetSystemChangeNumber(This,pdwSystemChangeNumber)	\
    (This)->lpVtbl -> GetSystemChangeNumber(This,pdwSystemChangeNumber)

#define IMSAdminBaseW_GetDataSetNumber(This,hMDHandle,pszMDPath,pdwMDDataSetNumber)	\
    (This)->lpVtbl -> GetDataSetNumber(This,hMDHandle,pszMDPath,pdwMDDataSetNumber)

#define IMSAdminBaseW_SetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)	\
    (This)->lpVtbl -> SetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)

#define IMSAdminBaseW_GetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)	\
    (This)->lpVtbl -> GetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)

#define IMSAdminBaseW_KeyExchangePhase1(This)	\
    (This)->lpVtbl -> KeyExchangePhase1(This)

#define IMSAdminBaseW_KeyExchangePhase2(This)	\
    (This)->lpVtbl -> KeyExchangePhase2(This)

#define IMSAdminBaseW_Backup(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)	\
    (This)->lpVtbl -> Backup(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)

#define IMSAdminBaseW_Restore(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)	\
    (This)->lpVtbl -> Restore(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)

#define IMSAdminBaseW_EnumBackups(This,pszMDBackupLocation,pdwMDVersion,pftMDBackupTime,dwMDEnumIndex)	\
    (This)->lpVtbl -> EnumBackups(This,pszMDBackupLocation,pdwMDVersion,pftMDBackupTime,dwMDEnumIndex)

#define IMSAdminBaseW_DeleteBackup(This,pszMDBackupLocation,dwMDVersion)	\
    (This)->lpVtbl -> DeleteBackup(This,pszMDBackupLocation,dwMDVersion)

#define IMSAdminBaseW_UnmarshalInterface(This,piadmbwInterface)	\
    (This)->lpVtbl -> UnmarshalInterface(This,piadmbwInterface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMSAdminBaseW_AddKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath);


void __RPC_STUB IMSAdminBaseW_AddKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath);


void __RPC_STUB IMSAdminBaseW_DeleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteChildKeys_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath);


void __RPC_STUB IMSAdminBaseW_DeleteChildKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumKeys_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex);


void __RPC_STUB IMSAdminBaseW_EnumKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_CopyKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag);


void __RPC_STUB IMSAdminBaseW_CopyKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_RenameKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName);


void __RPC_STUB IMSAdminBaseW_RenameKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_SetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData);


void __RPC_STUB IMSAdminBaseW_R_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_GetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);


void __RPC_STUB IMSAdminBaseW_R_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType);


void __RPC_STUB IMSAdminBaseW_DeleteData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_EnumData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);


void __RPC_STUB IMSAdminBaseW_R_EnumData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_GetAllData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);


void __RPC_STUB IMSAdminBaseW_R_GetAllData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteAllData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType);


void __RPC_STUB IMSAdminBaseW_DeleteAllData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_CopyData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag);


void __RPC_STUB IMSAdminBaseW_CopyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetDataPaths_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ WCHAR __RPC_FAR *pszBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);


void __RPC_STUB IMSAdminBaseW_GetDataPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_OpenKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle);


void __RPC_STUB IMSAdminBaseW_OpenKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_CloseKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle);


void __RPC_STUB IMSAdminBaseW_CloseKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_ChangePermissions_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [in] */ DWORD dwMDTimeOut,
    /* [in] */ DWORD dwMDAccessRequested);


void __RPC_STUB IMSAdminBaseW_ChangePermissions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SaveData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This);


void __RPC_STUB IMSAdminBaseW_SaveData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetHandleInfo_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo);


void __RPC_STUB IMSAdminBaseW_GetHandleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetSystemChangeNumber_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber);


void __RPC_STUB IMSAdminBaseW_GetSystemChangeNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetDataSetNumber_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber);


void __RPC_STUB IMSAdminBaseW_GetDataSetNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SetLastChangeTime_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime);


void __RPC_STUB IMSAdminBaseW_SetLastChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetLastChangeTime_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime);


void __RPC_STUB IMSAdminBaseW_GetLastChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_KeyExchangePhase1_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientKeyExchangeKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerKeyExchangeKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSessionKeyBlob);


void __RPC_STUB IMSAdminBaseW_R_KeyExchangePhase1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_KeyExchangePhase2_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSessionKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientHashBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerHashBlob);


void __RPC_STUB IMSAdminBaseW_R_KeyExchangePhase2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_Backup_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags);


void __RPC_STUB IMSAdminBaseW_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_Restore_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags);


void __RPC_STUB IMSAdminBaseW_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumBackups_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [size_is][out][in] */ LPWSTR pszMDBackupLocation,
    /* [out] */ DWORD __RPC_FAR *pdwMDVersion,
    /* [out] */ PFILETIME pftMDBackupTime,
    /* [in] */ DWORD dwMDEnumIndex);


void __RPC_STUB IMSAdminBaseW_EnumBackups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteBackup_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion);


void __RPC_STUB IMSAdminBaseW_DeleteBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_UnmarshalInterface_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [out] */ IMSAdminBaseW __RPC_FAR *__RPC_FAR *piadmbwInterface);


void __RPC_STUB IMSAdminBaseW_UnmarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSAdminBaseW_INTERFACE_DEFINED__ */


#ifndef __IMSAdminBaseSinkW_INTERFACE_DEFINED__
#define __IMSAdminBaseSinkW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMSAdminBaseSinkW
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IMSAdminBaseSinkW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9E69612-B80D-11d0-B9B9-00A0C922E750")
    IMSAdminBaseSinkW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SinkNotify( 
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShutdownNotify( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSAdminBaseSinkWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSAdminBaseSinkW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSAdminBaseSinkW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSAdminBaseSinkW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SinkNotify )( 
            IMSAdminBaseSinkW __RPC_FAR * This,
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownNotify )( 
            IMSAdminBaseSinkW __RPC_FAR * This);
        
        END_INTERFACE
    } IMSAdminBaseSinkWVtbl;

    interface IMSAdminBaseSinkW
    {
        CONST_VTBL struct IMSAdminBaseSinkWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSAdminBaseSinkW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSAdminBaseSinkW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSAdminBaseSinkW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSAdminBaseSinkW_SinkNotify(This,dwMDNumElements,pcoChangeList)	\
    (This)->lpVtbl -> SinkNotify(This,dwMDNumElements,pcoChangeList)

#define IMSAdminBaseSinkW_ShutdownNotify(This)	\
    (This)->lpVtbl -> ShutdownNotify(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMSAdminBaseSinkW_SinkNotify_Proxy( 
    IMSAdminBaseSinkW __RPC_FAR * This,
    /* [in] */ DWORD dwMDNumElements,
    /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]);


void __RPC_STUB IMSAdminBaseSinkW_SinkNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseSinkW_ShutdownNotify_Proxy( 
    IMSAdminBaseSinkW __RPC_FAR * This);


void __RPC_STUB IMSAdminBaseSinkW_ShutdownNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSAdminBaseSinkW_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_iadmw_0166
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_iadmw_0166_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iadmw_0166_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SetData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData);

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetAllData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetAllData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);

/* [restricted][local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase1_Proxy( 
    IMSAdminBaseW __RPC_FAR * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase1_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientKeyExchangeKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerKeyExchangeKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSessionKeyBlob);

/* [restricted][local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase2_Proxy( 
    IMSAdminBaseW __RPC_FAR * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase2_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSessionKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientHashBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerHashBlob);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\locks.h ===
//*****************************************************************************
// locks.h
//
// This class provides a number of locking primitives for multi-threaded
// programming.  The main class of interest are:
//	CCritLock			Critical section based lock wrapper class.
//	CExclLock			A Spin lock class for classic test & set behavior.
//  CSingleLock			A spin lock with no nesting capabilities.
//	CAutoLock			A helper class to lock/unlock in ctor/dtor.
//
//	CMReadSWrite		A highly efficient lock for multiple readers and
//							single writer behavior.
//	CAutoReadLock		A helper for read locking in ctor/dtor.
//	CAutoWriteLock		A helper for write locking in ctor/dtor.
//
// Copyright (c) 1996, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __LOCKS_H__
#define __LOCKS_H__


//*****************************************************************************
// This lock implements a spin lock that does not support nesting.  It is very
// lean because of this, but locks cannot be nested.
//*****************************************************************************
class CSingleLock
{
	long volatile	m_iLock;				// Test and set spin value.

public:
	inline CSingleLock() :
		m_iLock(0)
	{ }
	
	inline ~CSingleLock()
	{ 
		m_iLock = 0; 
	}
	
//*****************************************************************************
// This version spins forever until it wins.  Nested calls to Lock from the
// same thread are not supported.
//*****************************************************************************
	inline void Lock()
	{
		// Spin until we win.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
			;
	}
	
//*****************************************************************************
// This version spins until it wins or times out.  Nested calls to Lock from 
// the same thread are supported.
//*****************************************************************************
	HRESULT	 Lock(						// S_OK, or E_FAIL.
		DWORD	dwTimeout)				// Millisecond timeout value, 0 is forever.
	{
		DWORD		dwTime = 0;

		// Keep spinning until we get the lock.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
		{
			// Wait for 1/10 a second.
			Sleep(100);

			// See if we have gone over the timeout value.
			if (dwTimeout)
			{
				if ((dwTime += 100) >= dwTimeout)
					return (E_FAIL);
			}
		}
		return (S_OK);
	}
	
//*****************************************************************************
// Assigning to 0 is thread safe and yields much faster performance than
// an Interlocked* operation.
//*****************************************************************************
	inline void Unlock()
	{ 
		m_iLock = 0; 
	}
};



//*****************************************************************************
// This lock class is based on NT's critical sections and has all of their
// semantics.
//*****************************************************************************
class CCritLock
{
private:
	CRITICAL_SECTION m_sCrit;			// The critical section to block on.
	#ifdef _DEBUG
	BOOL			m_bInit;			// Track init status.
	int				m_iLocks;			// Count of locks.
	#endif

public:
	inline CCritLock()
	{ 
		#ifdef _DEBUG
		m_bInit = TRUE;
		m_iLocks = 0;
		#endif
		InitializeCriticalSection(&m_sCrit); 
	}
	
	inline ~CCritLock()
	{ 
		_ASSERTE(m_bInit);
		_ASSERTE(m_iLocks == 0);
		DeleteCriticalSection(&m_sCrit); 
	}
	
	inline void Lock()
	{ 
		_ASSERTE(m_bInit);
		EnterCriticalSection(&m_sCrit); 
		_ASSERTE(++m_iLocks > 0);
	}

	inline void Unlock()
	{
		_ASSERTE(m_bInit);
		_ASSERTE(--m_iLocks >= 0);
		LeaveCriticalSection(&m_sCrit);
	}

#ifdef _DEBUG
	inline int GetLockCnt()
		{ return (m_iLocks); }
	inline BOOL IsLocked()
		{ return (m_iLocks != 0); }
#endif
};



//*****************************************************************************
// Provides a mututal exclusion lock for a resource through a spin lock.  This
// type of lock does not keep a queue, so thread starvation is theoretically
// possible.  In addition, thread priority could cause a potential dead lock if
// a low priority thread got the lock but didn't get enough time to eventually
// free it.
// NOTE: There is a bug in the Pentium cache that InterlockedExchange will
//	force a cache flush of the value.  For this reason, doing an assignment
//	to free the lock is much, much faster than using an Interlocked instruction.
//*****************************************************************************
class CExclLock
{
	long volatile m_iLock;				// Test and set spin value.
	long		m_iNest;				// Nesting count.
	DWORD		m_iThreadId;			// The thread that owns the lock.

public:
	inline CExclLock() :
		m_iLock(0),
		m_iNest(0),
		m_iThreadId(0)
	{ }
	
	inline ~CExclLock()
	{ 
		m_iNest = 0;
		m_iThreadId = 0;
		m_iLock = 0; 
	}
	
//*****************************************************************************
// This version spins forever until it wins.  Nested calls to Lock from the
// same thread are supported.
//*****************************************************************************
	inline void Lock()
	{
		DWORD		iThread;			// Local thread ID.

		// Allow nested calls to lock in the same thread.
		if ((iThread = GetCurrentThreadId()) == m_iThreadId && m_iLock)
		{
			++m_iNest;
			return;
		}

		// Spin until we win.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
			;

		// Store our thread ID and nesting count now that we've won.
		m_iThreadId = iThread;
		m_iNest = 1;
	}
	
//*****************************************************************************
// This version spins until it wins or times out.  Nested calls to Lock from 
// the same thread are supported.
//*****************************************************************************
	HRESULT	 Lock(						// S_OK, or E_FAIL.
		DWORD	dwTimeout)				// Millisecond timeout value, 0 is forever.
	{
		DWORD		dwTime = 0;
		DWORD		iThread;			// Local thread ID.

		// Allow nested calls to lock in the same thread.
		if (m_iLock && (iThread = GetCurrentThreadId()) == m_iThreadId)
		{
			++m_iNest;
			return (S_OK);
		}

		// Keep spinning until we get the lock.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
		{
			// Wait for 1/10 a second.
			Sleep(100);

			// See if we have gone over the timeout value.
			if (dwTimeout)
			{
				if ((dwTime += 100) >= dwTimeout)
					return (E_FAIL);
			}
		}

		// Store our thread ID and nesting count now that we've won.
		m_iThreadId = iThread;
		m_iNest = 1;
		return (S_OK);
	}
	
//*****************************************************************************
// Assigning to 0 is thread safe and yields much faster performance than
// an Interlocked* operation.
//*****************************************************************************
	inline void Unlock()
	{ 
		_ASSERTE(m_iThreadId == GetCurrentThreadId() && m_iNest > 0);
		
		// Unlock outer nesting level.
		if (--m_iNest == 0)
		{
			m_iThreadId = 0;
			m_iLock = 0; 
		}
	}

#ifdef _DEBUG
	inline BOOL IsLocked()
		{ return (m_iLock); }
#endif
};



//*****************************************************************************
// This helper class automatically locks the given lock object in the ctor and
// frees it in the dtor.  This makes your code slightly cleaner by not 
// requiring an unlock in all failure conditions.
//*****************************************************************************
class CAutoLock
{
	CExclLock		*m_psLock;			// The lock object to free up.
	CCritLock		*m_psCrit;			// Crit lock.
	CSingleLock		*m_psSingle;		// Single non-nested lock.
	int				m_iNest;			// Nesting count for the item.

public:
//*****************************************************************************
// Use this ctor with the assignment operators to do deffered locking.
//*****************************************************************************
	CAutoLock() :
		m_psLock(NULL),
		m_psCrit(NULL),
		m_psSingle(NULL),
		m_iNest(0)
	{
	}

//*****************************************************************************
// This version handles a spin lock.
//*****************************************************************************
	CAutoLock(CExclLock *psLock) :
		m_psLock(psLock),
		m_psCrit(NULL),
		m_psSingle(NULL),
		m_iNest(1)
	{ 
		_ASSERTE(psLock != NULL);
		psLock->Lock();
	}
	
//*****************************************************************************
// This version handles a critical section lock.
//*****************************************************************************
	CAutoLock(CCritLock *psLock) :
		m_psLock(NULL),
		m_psCrit(psLock),
		m_psSingle(NULL),
		m_iNest(1)
	{ 
		_ASSERTE(psLock != NULL);
		psLock->Lock();
	}
	
//*****************************************************************************
// This version handles a critical section lock.
//*****************************************************************************
	CAutoLock(CSingleLock *psLock) :
		m_psLock(NULL),
		m_psCrit(NULL),
		m_psSingle(psLock),
		m_iNest(1)
	{ 
		_ASSERTE(psLock != NULL);
		psLock->Lock();
	}

//*****************************************************************************
// Free the lock we actually have.
//*****************************************************************************
	~CAutoLock()
	{
		// If we actually took a lock, unlock it.
		if (m_iNest != 0)
		{
			if (m_psLock)
			{
				while (m_iNest--)
					m_psLock->Unlock();
			}
			else if (m_psCrit)
			{
				while (m_iNest--)
					m_psCrit->Unlock();
			}
			else if (m_psSingle)
			{
				while (m_iNest--)
					m_psSingle->Unlock();
			}
		}
	}

//*****************************************************************************
// Lock after ctor runs with NULL.
//*****************************************************************************
	void Lock(
		CSingleLock *psLock)
	{
		m_psSingle = psLock;
		psLock->Lock();
		m_iNest = 1;
	}

//*****************************************************************************
// Assignment causes a lock to occur.  dtor will free the lock.  Nested
// assignments are allowed.
//*****************************************************************************
	CAutoLock & operator=(				// Reference to this class.
		CExclLock	*psLock)			// The lock.
	{
		_ASSERTE(m_psCrit == NULL && m_psSingle == NULL);
		++m_iNest;
		m_psLock = psLock;
		psLock->Lock();
		return (*this);
	}

//*****************************************************************************
// Assignment causes a lock to occur.  dtor will free the lock.  Nested
// assignments are allowed.
//*****************************************************************************
	CAutoLock & operator=(				// Reference to this class.
		CCritLock	*psLock)			// The lock.
	{
		_ASSERTE(m_psSingle == NULL && m_psLock == NULL);
		++m_iNest;
		m_psCrit = psLock;
		psLock->Lock();
		return (*this);
	}

//*****************************************************************************
// Assignment causes a lock to occur.  dtor will free the lock.  Nested
// assignments are allowed.
//*****************************************************************************
	CAutoLock & operator=(				// Reference to this class.
		CSingleLock	*psLock)			// The lock.
	{
		_ASSERTE(m_psCrit == NULL && m_psLock == NULL);
		++m_iNest;
		m_psSingle = psLock;
		psLock->Lock();
		return (*this);
	}
};

#endif //  __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CfgMnt.rc
//
#define IDS_PROJNAME                    100
#define IDR_CfgMnt                      100
#define IDR_CFGMNTADMIN                 101
#define IDR_CfgMntVersions              102
#define IDS_CFGMNTVERSIONS_DESC         103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\mt.cpp ===
// MT.cpp: implementation of the CMT class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MT.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMT::CMT()
{

}

CMT::~CMT()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\mt.h ===
// MT.h: interface for the CMT class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MT_H__1D7004F3_0458_11D1_A438_00C04FB99B01__INCLUDED_)
#define AFX_MT_H__1D7004F3_0458_11D1_A438_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <process.h>

class CMT  
{
public:
	CMT();
	virtual ~CMT();

};



// typedefs and inline func to handle buggy _beginthreadex prototype
typedef unsigned (WINAPI *P_BEGINTHREADEX_THREADPROC)(LPVOID lpThreadParameter);
typedef unsigned *P_BEGINTHREADEX_THREADID;

inline HANDLE _beginthreadex(
	LPSECURITY_ATTRIBUTES lpThreadAttributes,	// pointer to thread security attributes  
	DWORD dwStackSize,							// initial thread stack size, in bytes  
	LPTHREAD_START_ROUTINE lpStartAddress,		// pointer to thread function  
	LPVOID lpParameter,							// argument for new thread  
	DWORD dwCreationFlags,						// creation flags  
	LPDWORD lpThreadId							// pointer to returned thread identifier  
)
{
	return (HANDLE)::_beginthreadex(
		lpThreadAttributes,
		dwStackSize,
		(P_BEGINTHREADEX_THREADPROC)lpStartAddress,
		lpParameter,
		dwCreationFlags,
		(P_BEGINTHREADEX_THREADID)lpThreadId
		);
}


#endif // !defined(AFX_MT_H__1D7004F3_0458_11D1_A438_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\ssauto.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: SourceSafeTypeLib */

#ifndef _SourceSafeTypeLib_H_
#define _SourceSafeTypeLib_H_

DEFINE_GUID(LIBID_SourceSafeTypeLib,0x783CD4E0L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

typedef enum _VSSFlags {
    VSSFLAG_USERRONO = 1,
    VSSFLAG_USERROYES = 2,
    VSSFLAG_TIMENOW = 4,
    VSSFLAG_TIMEMOD = 8,
    VSSFLAG_TIMEUPD = 12,
    VSSFLAG_EOLCR = 16,
    VSSFLAG_EOLLF = 32,
    VSSFLAG_EOLCRLF = 48,
    VSSFLAG_REPASK = 64,
    VSSFLAG_REPREPLACE = 128,
    VSSFLAG_REPSKIP = 192,
    VSSFLAG_REPMERGE = 256,
    VSSFLAG_CMPFULL = 512,
    VSSFLAG_CMPTIME = 1024,
    VSSFLAG_CMPCHKSUM = 1536,
    VSSFLAG_CMPFAIL = 2048,
    VSSFLAG_RECURSNO = 4096,
    VSSFLAG_RECURSYES = 8192,
    VSSFLAG_FORCEDIRNO = 16384,
    VSSFLAG_FORCEDIRYES = 32768,
    VSSFLAG_KEEPNO = 65536,
    VSSFLAG_KEEPYES = 131072,
    VSSFLAG_DELNO = 262144,
    VSSFLAG_DELYES = 524288,
    VSSFLAG_DELNOREPLACE = 786432,
    VSSFLAG_BINTEST = 1048576,
    VSSFLAG_BINBINARY = 2097152,
    VSSFLAG_BINTEXT = 3145728,
    VSSFLAG_DELTAYES = 4194304,
    VSSFLAG_DELTANO = 8388608,
    VSSFLAG_UPDASK = 16777216,
    VSSFLAG_UPDUPDATE = 33554432,
    VSSFLAG_UPDUNCH = 50331648,
    VSSFLAG_GETYES = 67108864,
    VSSFLAG_GETNO = 134217728,
    VSSFLAG_CHKEXCLUSIVEYES = 268435456,
    VSSFLAG_CHKEXCLUSIVENO = 536870912,
    VSSFLAG_HISTIGNOREFILES = 1073741824
} VSSFlags;

typedef enum _VSSFileStatus {
    VSSFILE_NOTCHECKEDOUT = 0,
    VSSFILE_CHECKEDOUT = 1,
    VSSFILE_CHECKEDOUT_ME = 2
} VSSFileStatus;

typedef enum _VSSItemType {
    VSSITEM_PROJECT = 0,
    VSSITEM_FILE = 1
} VSSItemType;

interface IVSSItems;

interface IVSSVersions;

interface IVSSVersion;

interface IVSSCheckouts;

interface IVSSCheckout;

DEFINE_GUID(IID_IVSSItem,0x783CD4E1L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSItem */
#undef INTERFACE
#define INTERFACE IVSSItem

DECLARE_INTERFACE_(IVSSItem, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSItem methods */
    STDMETHOD(get_Spec)(THIS_ BSTR FAR* pSpec) PURE;
    STDMETHOD(get_Binary)(THIS_ VARIANT_BOOL FAR* pbBinary) PURE;
    STDMETHOD(put_Binary)(THIS_ VARIANT_BOOL bBinary) PURE;
    STDMETHOD(get_Deleted)(THIS_ VARIANT_BOOL FAR* pbDeleted) PURE;
    STDMETHOD(put_Deleted)(THIS_ VARIANT_BOOL bDeleted) PURE;
    STDMETHOD(get_Type)(THIS_ int FAR* piType) PURE;
    STDMETHOD(get_LocalSpec)(THIS_ BSTR FAR* pLocal) PURE;
    STDMETHOD(put_LocalSpec)(THIS_ BSTR Local) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pName) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_Parent)(THIS_ IVSSItem FAR* FAR* ppIParent) PURE;
    STDMETHOD(get_VersionNumber)(THIS_ long FAR* piVersion) PURE;
    STDMETHOD(get_Items)(THIS_ VARIANT_BOOL IncludeDeleted, IVSSItems FAR* FAR* ppIItems) PURE;
    STDMETHOD(Get)(THIS_ BSTR FAR* Local, long iFlags) PURE;
    STDMETHOD(Checkout)(THIS_ BSTR Comment, BSTR Local, long iFlags) PURE;
    STDMETHOD(Checkin)(THIS_ BSTR Comment, BSTR Local, long iFlags) PURE;
    STDMETHOD(UndoCheckout)(THIS_ BSTR Local, long iFlags) PURE;
    STDMETHOD(get_IsCheckedOut)(THIS_ long FAR* piStatus) PURE;
    STDMETHOD(get_Checkouts)(THIS_ IVSSCheckouts FAR* FAR* ppICheckouts) PURE;
    STDMETHOD(get_IsDifferent)(THIS_ BSTR Local, VARIANT_BOOL FAR* pbDifferent) PURE;
    STDMETHOD(Add)(THIS_ BSTR Local, BSTR Comment, long iFlags, IVSSItem FAR* FAR* ppIItem) PURE;
    STDMETHOD(NewSubproject)(THIS_ BSTR Name, BSTR Comment, IVSSItem FAR* FAR* ppIItem) PURE;
    STDMETHOD(Share)(THIS_ IVSSItem FAR* pIItem, BSTR Comment, long iFlags) PURE;
    STDMETHOD(Destroy)(THIS) PURE;
    STDMETHOD(Move)(THIS_ IVSSItem FAR* pINewParent) PURE;
    STDMETHOD(Label)(THIS_ BSTR Label, BSTR Comment) PURE;
    STDMETHOD(get_Versions)(THIS_ long iFlags, IVSSVersions FAR* FAR* pIVersions) PURE;
    STDMETHOD(get_Version)(THIS_ VARIANT Version, IVSSItem FAR* FAR* ppIItem) PURE;
};

DEFINE_GUID(IID_IVSSVersions,0x783CD4E7L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSVersions */
#undef INTERFACE
#define INTERFACE IVSSVersions

DECLARE_INTERFACE_(IVSSVersions, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSVersions methods */
    STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppIEnum) PURE;
};

DEFINE_GUID(IID_IVSSVersion,0x783CD4E8L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSVersion */
#undef INTERFACE
#define INTERFACE IVSSVersion

DECLARE_INTERFACE_(IVSSVersion, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSVersion methods */
    STDMETHOD(get_Username)(THIS_ BSTR FAR* pUsername) PURE;
    STDMETHOD(get_VersionNumber)(THIS_ long FAR* piVersion) PURE;
    STDMETHOD(get_Action)(THIS_ BSTR FAR* pAction) PURE;
    STDMETHOD(get_Date)(THIS_ DATE FAR* pDate) PURE;
    STDMETHOD(get_Comment)(THIS_ BSTR FAR* pComment) PURE;
    STDMETHOD(get_Label)(THIS_ BSTR FAR* pLabel) PURE;
    STDMETHOD(get_VSSItem)(THIS_ IVSSItem FAR* FAR* ppIItem) PURE;
};

DEFINE_GUID(IID_IVSSItems,0x783CD4E5L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSItems */
#undef INTERFACE
#define INTERFACE IVSSItems

DECLARE_INTERFACE_(IVSSItems, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSItems methods */
    STDMETHOD(get_Count)(THIS_ long FAR* piCount) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT sItem, IVSSItem FAR* FAR* ppIItem) PURE;
    STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppIEnum) PURE;
};

DEFINE_GUID(IID_IVSSCheckouts,0x8903A770L,0xF55F,0x11CF,0x92,0x27,0x00,0xAA,0x00,0xA1,0xEB,0x95);

/* Definition of interface: IVSSCheckouts */
#undef INTERFACE
#define INTERFACE IVSSCheckouts

DECLARE_INTERFACE_(IVSSCheckouts, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSCheckouts methods */
    STDMETHOD(get_Count)(THIS_ long FAR* piCount) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT sItem, IVSSCheckout FAR* FAR* ppICheckout) PURE;
    STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppIEnum) PURE;
};

DEFINE_GUID(IID_IVSSCheckout,0x783CD4E6L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSCheckout */
#undef INTERFACE
#define INTERFACE IVSSCheckout

DECLARE_INTERFACE_(IVSSCheckout, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSCheckout methods */
    STDMETHOD(get_Username)(THIS_ BSTR FAR* pUsername) PURE;
    STDMETHOD(get_Date)(THIS_ DATE FAR* pDate) PURE;
    STDMETHOD(get_LocalSpec)(THIS_ BSTR FAR* pLocal) PURE;
    STDMETHOD(get_Machine)(THIS_ BSTR FAR* pMachine) PURE;
    STDMETHOD(get_Project)(THIS_ BSTR FAR* pProject) PURE;
    STDMETHOD(get_Comment)(THIS_ BSTR FAR* pComment) PURE;
    STDMETHOD(get_VersionNumber)(THIS_ long FAR* piVersion) PURE;
};

DEFINE_GUID(IID_IVSSDatabase,0x783CD4E2L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSDatabase */
#undef INTERFACE
#define INTERFACE IVSSDatabase

DECLARE_INTERFACE_(IVSSDatabase, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSDatabase methods */
    STDMETHOD(Open)(THIS_ BSTR SrcSafeIni, BSTR Username, BSTR Password) PURE;
    STDMETHOD(get_SrcSafeIni)(THIS_ BSTR FAR* pSrcSafeIni) PURE;
    STDMETHOD(get_DatabaseName)(THIS_ BSTR FAR* pDatabaseName) PURE;
    STDMETHOD(get_UserName)(THIS_ BSTR FAR* pUsername) PURE;
    STDMETHOD(get_CurrentProject)(THIS_ BSTR FAR* pPrj) PURE;
    STDMETHOD(put_CurrentProject)(THIS_ BSTR Prj) PURE;
    STDMETHOD(get_VSSItem)(THIS_ BSTR Spec, VARIANT_BOOL Deleted, IVSSItem FAR* FAR* ppIVSSItem) PURE;
};

DEFINE_GUID(CLSID_VSSItem,0x783CD4E3L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

#ifdef __cplusplus
class VSSItem;
#endif

DEFINE_GUID(CLSID_VSSVersion,0x783CD4ECL,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

#ifdef __cplusplus
class VSSVersion;
#endif

DEFINE_GUID(CLSID_VSSCheckout,0x2A0DE0E0L,0x2E9F,0x11D0,0x92,0x36,0x00,0xAA,0x00,0xA1,0xEB,0x95);

#ifdef __cplusplus
class VSSCheckout;
#endif

DEFINE_GUID(CLSID_VSSDatabase,0x783CD4E4L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

#ifdef __cplusplus
class VSSDatabase;
#endif

DEFINE_GUID(IID_IVSSEvents,0x783CD4E9L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSEvents */
#undef INTERFACE
#define INTERFACE IVSSEvents

DECLARE_INTERFACE_(IVSSEvents, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IVSSEvents methods */
    STDMETHOD(BeforeAdd)(THIS_ IVSSItem FAR* pIPrj, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterAdd)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeCheckin)(THIS_ IVSSItem FAR* pIItem, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterCheckin)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeUndoCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterUndoCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeRename)(THIS_ IVSSItem FAR* pIItem, BSTR NewName, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterRename)(THIS_ IVSSItem FAR* pIItem, BSTR OldName) PURE;
    STDMETHOD(BeforeBranch)(THIS_ IVSSItem FAR* pIItem, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterBranch)(THIS_ IVSSItem FAR* pIItem) PURE;
    STDMETHOD(BeforeEvent)(THIS_ long iEvent, IVSSItem FAR* pIItem, BSTR Str, VARIANT var, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterEvent)(THIS_ long iEvent, IVSSItem FAR* pIItem, BSTR Str, VARIANT var) PURE;
};

DEFINE_GUID(IID_IVSS,0x783CD4EBL,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSS */
#undef INTERFACE
#define INTERFACE IVSS

DECLARE_INTERFACE_(IVSS, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSS methods */
    STDMETHOD(get_VSSDatabase)(THIS_ IVSSDatabase FAR* FAR* ppIVSSDatabase) PURE;
};

DEFINE_GUID(IID_IVSSEventHandler,0x783CD4EAL,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSEventHandler */
#undef INTERFACE
#define INTERFACE IVSSEventHandler

DECLARE_INTERFACE_(IVSSEventHandler, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IVSSEventHandler methods */
    STDMETHOD(Init)(THIS_ IVSS FAR* pIVSS) PURE;
};

DEFINE_GUID(CLSID_VSSApp,0x2A0DE0E1L,0x2E9F,0x11D0,0x92,0x36,0x00,0xAA,0x00,0xA1,0xEB,0x95);

#ifdef __cplusplus
class VSSApp;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0F219CB5_15C1_11D1_A449_00C04FB99B01__INCLUDED_)
#define AFX_STDAFX_H__0F219CB5_15C1_11D1_A449_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#define UNICODE
#ifndef _MT
#error "Use Multithreaded run-time library"
#endif
#include <crtdbg.h>
#include <string>
using namespace std;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0F219CB5_15C1_11D1_A449_00C04FB99B01__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\verengine.h ===
// VerEngine.h: interface for the CVerEngine class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VERENGINE_H__EC78FB59_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
#define AFX_VERENGINE_H__EC78FB59_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "ssauto.h"
#include <list>
using namespace std;

class CVerEngine  
{
public:
	// thee methods
	HRESULT SyncPrj(LPCTSTR szBasePrj,LPCTSTR szDir);
	
	// dir versioning methods
	HRESULT AddPrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	HRESULT RenamePrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld);

	// file versioning methods
	HRESULT Rename(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld);
	HRESULT CheckOut(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	HRESULT Delete(LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	HRESULT Sync(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szFileSpec = NULL);
	HRESULT Sync2(LPCTSTR szPrj,LPCTSTR szFileName,LPCTSTR szFileSpec);
	HRESULT GetLocalWritable(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	
	// init/shutdown
	HRESULT NewInit(LPCTSTR szVSSRootPrj);
	HRESULT ShutDown();
	
	// ctor/dtor
	CVerEngine();
	virtual ~CVerEngine();

private:
	// private methods
	HRESULT GetPrjEx(LPCTSTR szPrj,IVSSItem **hIPrj,bool bCreate);
	HRESULT GetItemEx(LPCTSTR szItem,IVSSItem **hIItem,bool bCreate);
	HRESULT Add(LPCTSTR szItem,LPCTSTR szFileSpec);
	HRESULT CheckIn(IVSSItem *pIItem,LPCTSTR szFileSpec);
	HRESULT CheckOutNoGet(IVSSItem *pIItem);
	HRESULT CheckOutGet(IVSSItem *pIItem);
	HRESULT CheckOutLocal(IVSSItem *pIItem,LPCTSTR szFileSpec);
	
	// helper
	void MakePrjSpec(wstring &szDest,LPCTSTR szSource);
	void EliminateCommon(list<wstring> &ListOne, list<wstring> &ListTwo);


	CComPtr<IVSSDatabase> m_pIDB;
	CComBSTR m_bstrSrcSafeIni;
	CComBSTR m_bstrUsername;
	CComBSTR m_bstrPassword;
	wstring m_szVSSRootPrj;
};

#endif // !defined(AFX_VERENGINE_H__EC78FB59_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\verengine.cpp ===
// VerEngine.cpp: implementation of the CVerEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VerEngine.h"
#include "ssauterr.h"
#include "Error.h"
#include <COMDEF.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVerEngine::CVerEngine()
{

}

CVerEngine::~CVerEngine()
{

}

HRESULT CVerEngine::NewInit(LPCTSTR szVSSRootPrj)
{
	// save the root prj
	m_szVSSRootPrj = szVSSRootPrj;

	HRESULT hr = E_FAIL;

	// check if we already have a db instance
	if(!m_pIDB)
	{
		// create db instance
		hr = CoCreateInstance(CLSID_VSSDatabase,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IVSSDatabase,
							  (void**)&m_pIDB);
		if(FAILED(hr))
			return hr;
	}

	// Open the database
	hr = m_pIDB->Open(m_bstrSrcSafeIni,m_bstrUsername,m_bstrPassword);
	if(FAILED(hr))
		return hr;

	return hr;
}

HRESULT CVerEngine::ShutDown()
{
	// release of interface ptr here and not during destructor,
	// since CVerEngine could live on stack in the same frame that CoUninitialize() is called,
	// i.e. CoUninitialize() would be called before the destructor calls release and gets 
	// an Access Violation.
	m_pIDB.Release();
	return S_OK;
}

HRESULT CVerEngine::AddPrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERT(szBasePrj && szRelSpec);
	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szPrj(szBasePrj);
	MakePrjSpec(szPrj,szRelSpec);

	// see if the item exists
	CError::Trace(szPrj.c_str()); CError::Trace(" Add ");
	hr = GetPrjEx(szPrj.c_str(),&pIItem,true);
	if( SUCCEEDED(hr) )
	{
		if(hr == S_FALSE)
			CError::Trace("created ");
	}
	else
		FAIL_RTN1(hr,"\nGetPrjEx");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::RenamePrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld)
{
	_ASSERTE(szBasePrj && szRelSpec && szRelSpecOld);
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj); 
	MakePrjSpec(szItem,szRelSpecOld);

	// see if the item exists
	CError::Trace(szRelSpecOld); CError::Trace(" Rename to "); CError::Trace(szRelSpec);
	hr = GetPrjEx(szItem.c_str(),&pIItem,true);
	if(SUCCEEDED(hr))
	{
		wstring szFileName(szRelSpec);
		int iFileNameIndex = szFileName.find_last_of(L"\\/");
		if(iFileNameIndex == wstring::npos)
			iFileNameIndex = 0;
		else iFileNameIndex++;
		hr = pIItem->put_Name(_bstr_t(szFileName.substr(iFileNameIndex).c_str()));
		IF_FAIL_RTN1(hr,"\nput_Name");
	}
	else
		FAIL_RTN1(hr,"\nGetPrjEx");

	CError::Trace("\n");
	return hr;
}
	
HRESULT CVerEngine::Rename(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld)
{
	_ASSERTE(szBasePrj && szRelSpec && szRelSpecOld);
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szOldItem(szBasePrj);
	MakePrjSpec(szOldItem,szRelSpecOld);

	// see if the item exists
	CError::Trace(szRelSpecOld); CError::Trace(" Rename to "); CError::Trace(szRelSpec);
	hr = GetItemEx(szOldItem.c_str(),&pIItem,true);
	if(SUCCEEDED(hr))
	{
		if(hr == S_FALSE) 
		{
			CError::Trace(" created ");
			// file was created, therefore let's checkin the old version
			_ASSERTE(szDir);
			wstring szFileSpec(szDir);
			szFileSpec.append(L"\\").append(szRelSpec);
			hr = Sync2(szBasePrj,szRelSpecOld,szFileSpec.c_str());
			IF_FAIL_RTN1(hr,"\nSync");
		}
		
		wstring szItem(szRelSpec);
		int iFileNameIndex = szItem.find_last_of(L"\\/");
		if(iFileNameIndex == wstring::npos)
			iFileNameIndex = 0;
		else
			iFileNameIndex++;
		CComBSTR bstrFileName(szItem.substr(iFileNameIndex).c_str());
		hr = pIItem->put_Name(bstrFileName);
		IF_FAIL_RTN1(hr,"\nput_Name");
	}
	else
		FAIL_RTN1(hr,"\nGetItemEx");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::Sync2(LPCTSTR szPrj,LPCTSTR szFileName,LPCTSTR szFileSpec)
{
//	return Sync(szPrj,NULL,szFileName,szFileSpec);

	// @todo: handle errors
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szPrj);
	MakePrjSpec(szItem,szFileName);

	// complete file/prj specs
	wstring szFSpec;
	szFSpec = szFileSpec;
	
	// see if the item exists
	CError::Trace(szItem.c_str()); CError::Trace(" Sync ");
	hr = GetItemEx(szItem.c_str(),&pIItem,true);
	if(SUCCEEDED(hr))
	{ 
		hr = CheckIn(pIItem,szFSpec.c_str());
		if(hr == ESS_FILE_SHARE)
		{
			// File %s is already open, meaning is held open by other process
			// Let's hope they close the file and we can try to add it agian,
			// so let's ignore it for now
			CError::Trace("not checked in(isopen)\n");
			return S_FALSE;
		} 
		else 
			IF_FAIL_RTN1(hr,"\nCheckin");

		CError::Trace("synced ");
	} 
	else
		FAIL_RTN1(hr,"\nget_VSSItem");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::Sync(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szFileSpec)
{
	// @todo: handle errors
	_ASSERT(m_pIDB && szBasePrj && szRelSpec);
	_ASSERTE(szDir||szFileSpec);
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);

	// complete file/prj specs
	wstring szFSpec;
	if(szDir)
	{
		szFSpec = szDir;
		szFSpec.append(L"\\").append(szRelSpec);
	}
	else 
	{
		_ASSERTE(szFileSpec);
		szFSpec = szFileSpec;
	}
	
	// see if the item exists
	CError::Trace(szRelSpec); CError::Trace(" Sync ");
	hr = GetItemEx(szItem.c_str(),&pIItem,false);
	if(SUCCEEDED(hr))
	{ 
		hr = CheckIn(pIItem,szFSpec.c_str());
		if(hr == ESS_FILE_SHARE)
		{
			// File %s is already open, meaning is held open by other process
			// Let's hope they close the file and we can try to add it agian,
			// so let's ignore it for now
			CError::Trace("not checked in(isopen)\n");
			return S_FALSE;
		} 
		else 
			IF_FAIL_RTN1(hr,"\nCheckin");

		CError::Trace("synced ");
	} 
	else if(hr == ESS_VS_NOT_FOUND)
	{
		hr = Add(szItem.c_str(),szFSpec.c_str());
		if(hr == ESS_FILE_SHARE)
		{
			// File %s is already open, meaning is held open by other process
			// Let's hope they close the file and we can try to add it agian,
			// so let's ignore it for now
			CError::Trace("not added(isopen)\n");
			return S_FALSE;
		} 
		else 
			IF_FAIL_RTN1(hr,"\nAdd");

		CError::Trace("added ");
	}
	else
		FAIL_RTN1(hr,"\nget_VSSItem");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::Delete(LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERT(m_pIDB && szBasePrj && szRelSpec);
	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);
	
	// see if the item exists
	CError::Trace(szItem.c_str()); CError::Trace(" Delete ");
	hr = GetItemEx(szItem.c_str(),&pIItem,false);
	if( SUCCEEDED(hr) )
	{ 
		CError::Trace("exists ");
		// delete the file
		hr = pIItem->put_Deleted(true);
		IF_FAIL_RTN1(hr,"\nput_Delete");
		CError::Trace("deleted ");
	} 
	else if( hr == ESS_VS_NOT_FOUND )
	{
		CError::Trace("not-exist ");
		// This is bad. The file should have been in version control.
		// We can't add the file and delete it from VSS since the file
		// might no longer exist. We could create an empty dummy file,
		// but that's more confusing than helpfull.
		// Let's just log this error
		
		// @todo: log condition that file doesn't exist in VSS
		hr = S_OK;
	} 
	else 
		// This is really bad. There is some other error. Maybe we should try and
		// shutdown the srcsafe db and start it up again (this is slooowww!!!)
		// or maybe just write the failure to the log
		FAIL_RTN1(hr,"\nGetItemEx");

	CError::Trace("\n");
	return hr;
}

void CVerEngine::MakePrjSpec(wstring &szDest,LPCTSTR szSource)
{
	// szDest = m_szVSSRootPrj + [/]
	if(m_szVSSRootPrj[m_szVSSRootPrj.length()-1] != L'/' && szDest[0] != L'/')
		szDest.insert(0,L"/");
	szDest.insert(0,m_szVSSRootPrj.c_str());
	
	// szDest = szDest + [/] + szSource
	if(szDest[szDest.length()-1] != L'/' && szSource[0] != L'/')
		szDest.append(L"/");
	szDest.append(szSource);
	
	// convert all backslashes with slashes
	int pos = 0;
	while((pos = szDest.find(L'\\',pos)) != wstring::npos)
	{
		szDest[pos] = L'/';
		pos++;
	}
}

HRESULT CVerEngine::Add(LPCTSTR szItem,LPCTSTR szFileSpec)
{
	_ASSERTE(szItem && szFileSpec);
	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIPrj;
	CComPtr<IVSSItem> pIItem;
	
	// get prj
	wstring szTmp = szItem;
	int iFileNameIndex = szTmp.find_last_of(L"/");
	if(iFileNameIndex == wstring::npos)
		return E_FAIL;
	hr = GetPrjEx(szTmp.substr(0,iFileNameIndex).c_str(),&pIPrj,true);
	IF_FAIL_RTN1(hr,"GetPrjEx");
	CComBSTR bstrFileSpec(szFileSpec);
	hr = pIPrj->Add(bstrFileSpec,NULL,VSSFLAG_USERRONO|VSSFLAG_GETNO,&pIItem);	// VSSFLAG_KEEPYES
	if(hr == 0x80040000)	// @todo tmp fix, since pIPrj->Add has a bug when called with VSSFLAG_KEEPYES
		hr = S_OK;
	IF_FAIL_RTN1(hr,"Add");
	return hr;
}

HRESULT CVerEngine::GetLocalWritable(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERTE(m_pIDB && szFileSpec && szBasePrj && szRelSpec);

	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);

	// see if the item exists
	CError::Trace(szBasePrj); CError::Trace(L"/"); CError::Trace(szRelSpec); CError::Trace(" Get ");
	hr = GetItemEx(szItem.c_str(),&pIItem,false);
	if(SUCCEEDED(hr))
	{ 
		CError::Trace("exists ");
		// checkout file
		CComBSTR bstrFileSpec(szFileSpec);
		hr = pIItem->Get(&bstrFileSpec,VSSFLAG_REPREPLACE|VSSFLAG_USERRONO);
		IF_FAIL_RTN1(hr,"\nGet");
		CError::Trace("gotten ");
	} 
	else if(hr == ESS_VS_NOT_FOUND)
	{
		HANDLE hFile = NULL;
		hFile = CreateFile(szFileSpec,
							 GENERIC_READ|GENERIC_WRITE,
							 0,
							 NULL,
							 CREATE_ALWAYS,
							 FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_SEQUENTIAL_SCAN,
							 NULL);
		if(hFile == INVALID_HANDLE_VALUE)
		{
			hFile = NULL;
			hr = GetLastError();
			FAIL_RTN1(hr,"\nCreateFile");
		}
		CloseHandle(hFile);
		hFile = NULL;
		hr = S_OK;
	}

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::CheckOut(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERTE(m_pIDB && szFileSpec && szBasePrj && szRelSpec);

	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);

	// see if the item exists
	CError::Trace(szBasePrj); CError::Trace(L"/"); CError::Trace(szRelSpec); CError::Trace(" Checkout ");
	hr = GetItemEx(szItem.c_str(),&pIItem,true);
	if( SUCCEEDED(hr) )
	{ 
		CError::Trace("exists ");
		// checkout file
		hr = CheckOutLocal(pIItem,szFileSpec);
		IF_FAIL_RTN1(hr,"\nCheckout");
		CError::Trace("gotten ");
	} 
	else 
		FAIL_RTN1(hr,"\nGetItemEx");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::CheckOutNoGet(IVSSItem *pIItem)
{
	_ASSERTE(pIItem);
	HRESULT hr = S_OK;
	long iStatus = 0;

	// is files checked out?
	hr = pIItem->get_IsCheckedOut(&iStatus);
	IF_FAIL_RTN1(hr,"\nget_IsCheckOut");

	// check it out to me
	if(iStatus != VSSFILE_CHECKEDOUT_ME)
	{ 
		hr = pIItem->Checkout(NULL,NULL,VSSFLAG_GETNO);
		IF_FAIL_RTN1(hr,"\nCheckout");
	}
	return hr;
}

HRESULT CVerEngine::CheckIn(IVSSItem *pIItem,LPCTSTR szFileSpec)
{
	_ASSERTE(pIItem && szFileSpec);
	HRESULT hr = S_OK;

	hr = CheckOutNoGet(pIItem);
	if(FAILED(hr))
		return hr;

	// checkin
	hr = pIItem->Checkin(NULL,_bstr_t(szFileSpec),VSSFLAG_KEEPYES);
	return hr;
}

HRESULT CVerEngine::CheckOutGet(IVSSItem *pIItem)
{
	_ASSERTE(pIItem);
	HRESULT hr = S_OK;
	long iStatus = 0;

	// is files checked out?
	hr = pIItem->get_IsCheckedOut(&iStatus);
	if(FAILED(hr))
		return hr;

	// check it out to me
	if(iStatus != VSSFILE_CHECKEDOUT_ME)
		hr = pIItem->Checkout(NULL,NULL,0);

	return hr;
}

HRESULT CVerEngine::CheckOutLocal(IVSSItem *pIItem,LPCTSTR szFileSpec)
{
	_ASSERTE(pIItem);
	HRESULT hr = S_OK;
	long iStatus = 0;

	// is files checked out?
	hr = pIItem->get_IsCheckedOut(&iStatus);
	if(FAILED(hr))
		return hr;

	// check it out to me
	if(iStatus != VSSFILE_CHECKEDOUT_ME)
	{
		hr = pIItem->Checkout(NULL,_bstr_t(szFileSpec),0);
	}
	else
	{
		CComBSTR bstrFileSpec(szFileSpec);
		hr = pIItem->Get(&bstrFileSpec,0);
	}
	return hr;
}

HRESULT CVerEngine::GetPrjEx(LPCTSTR szPrj,IVSSItem **hIPrj,bool bCreate)
{
	_ASSERTE(hIPrj && szPrj);
	HRESULT hr = S_OK;
	*hIPrj = NULL;
	_bstr_t bstrPrj(szPrj);
	
	hr = m_pIDB->get_VSSItem(bstrPrj,false,hIPrj);
	if( hr == ESS_VS_NOT_FOUND 
		&& bCreate )
	{
		// does it exist as delete
		hr = m_pIDB->get_VSSItem(bstrPrj,true,hIPrj);
		if(SUCCEEDED(hr))
		{
			hr = (*hIPrj)->put_Deleted(false);	// make sure it's not deleted
		} 
		else if(hr == ESS_VS_NOT_FOUND)
		{
			// find the top-most prj that exists
			CComPtr<IVSSItem> pItmp;
			wstring sztmp = szPrj;
			int iPos = wstring::npos;
			while( hr == ESS_VS_NOT_FOUND )
			{
				iPos = sztmp.find_last_of(L"/");
				if(iPos == wstring::npos)
					return E_FAIL;
				sztmp = sztmp.substr(0,iPos).c_str();
				if(sztmp.size() == 1)			// if we reached $/
					sztmp = L"$/";				// we need to have the / in $/
				hr = m_pIDB->get_VSSItem(_bstr_t(sztmp.c_str()),false,&pItmp);
			}
			IF_FAIL_RTN1(hr,"get_VSSItem");

			// add recursivly the remaining subprojects
			CComPtr<IVSSItem> pItmp2;
			int iPos2 = 0;
			sztmp = szPrj;
			_bstr_t bstrSubPrj;
			while( iPos2 != wstring::npos )
			{
				++iPos;
				iPos2 = sztmp.find_first_of(L"/",iPos);
				if(iPos2 == wstring::npos)
					bstrSubPrj = sztmp.substr(iPos,sztmp.length()-iPos).c_str();
				else
					bstrSubPrj = sztmp.substr(iPos,iPos2-iPos).c_str();
				hr = pItmp->NewSubproject(bstrSubPrj,NULL,&pItmp2);
				IF_FAIL_RTN1(hr,"NewSubproject");
				iPos = iPos2;
				pItmp.Release();
				pItmp = pItmp2;
				pItmp2.Release();
			}
			*hIPrj = pItmp;
			(*hIPrj)->AddRef();
			pItmp.Release();
			hr = S_FALSE; // signal that we created it
		}
	}
	IF_FAIL_RTN1(hr,"get_VSSItem");
	
	return hr;
}

HRESULT CVerEngine::GetItemEx(LPCTSTR szItem,IVSSItem **hIItem,bool bCreate)
{
	_ASSERTE(hIItem && szItem);
	HRESULT hr = S_OK;
	*hIItem = NULL;
	_bstr_t bstrItem(szItem);

	hr = m_pIDB->get_VSSItem(bstrItem,false,hIItem);
	if( hr == ESS_VS_NOT_FOUND 
		&& bCreate )
	{
		// does it exist as delete
		hr = m_pIDB->get_VSSItem(bstrItem,true,hIItem);
		if(SUCCEEDED(hr))
		{
			hr = (*hIItem)->put_Deleted(false);		// make sure it's not deleted
			IF_FAIL_RTN1(hr,"put_Deleted");
			hr = S_FALSE;
		}
		else if(hr == ESS_VS_NOT_FOUND)
		{
			CComPtr<IVSSItem> pIPrj;
			
			// get prj
			wstring szItem = szItem;
			int iFileNameIndex = szItem.find_last_of(L"/");
			if(iFileNameIndex == wstring::npos)
				return E_FAIL;
			hr = GetPrjEx(_bstr_t(szItem.substr(0,iFileNameIndex).c_str()),&pIPrj,bCreate);
			IF_FAIL_RTN1(hr,"GetPrjEx");

			// add the file to the prj
			HANDLE hFile = NULL;
			TCHAR szTmpSpec[MAX_PATH];
			BOOL b = FALSE;
			CComBSTR bstrFileSpec;
			
			// create an empty file szFileName in tmp dir
			GetTempPath(MAX_PATH,szTmpSpec);
			GetTempFileName(szTmpSpec,L"",0,szTmpSpec);		// creates tmp file
			b = DeleteFile(szTmpSpec);						// delete tmp file since we want tmp dir
			b = CreateDirectory(szTmpSpec,NULL);			// create tmp dir
			bstrFileSpec = szTmpSpec;
			bstrFileSpec.Append(L"\\");
			bstrFileSpec.Append(szItem.substr(iFileNameIndex+1).c_str());
			hFile = CreateFile(bstrFileSpec,				// create file in tmp dir
					   GENERIC_READ|GENERIC_WRITE,
					   0,
					   NULL,
					   CREATE_ALWAYS,
					   FILE_ATTRIBUTE_TEMPORARY,
					   NULL);
			CloseHandle(hFile);
			// add this file
			hr = pIPrj->Add(bstrFileSpec,NULL,VSSFLAG_KEEPYES,hIItem);
			b = DeleteFile(bstrFileSpec);
			b = RemoveDirectory(szTmpSpec);
			hr = S_FALSE;
		}
	}
	else if(hr == ESS_VS_NOT_FOUND)
		return hr;
	IF_FAIL_RTN1(hr,"get_VSSItem");

	return hr;
}

void CVerEngine::EliminateCommon(list<wstring> &ListOne, list<wstring> &ListTwo)
{
	int sizeOne = ListOne.size();
	int sizeTwo = ListTwo.size();

	if(sizeOne == 0 || sizeTwo == 0)
		return;

	list<wstring> &List1 = ListTwo;
	list<wstring> &List2 = ListOne;
	if(sizeOne >= sizeTwo)
	{
		List1 = ListOne;
		List2 = ListTwo;
	} 

	list<wstring>::iterator i;
	list<wstring>::iterator j;

	for(i = List1.begin(); i != List1.end(); ++i)
	{
		for(j = List2.begin(); j != List2.end(); ++j)
		{
			if((*i).compare(*j) == 0)
			{
				List1.erase(i);
				List2.erase(j);
				break;
			}
		}
	}
}

HRESULT CVerEngine::SyncPrj(LPCTSTR szBasePrj,LPCTSTR szDir)
{
	bool result = true;
	typedef list<wstring> wstringlist;
	wstringlist FileList;
	wstringlist DirList;

	WIN32_FIND_DATA finddata;
    HANDLE hFind = FindFirstFile( wstring(szDir).append(L"\\*.*").c_str(), &finddata);
	if(hFind == INVALID_HANDLE_VALUE && GetLastError() != ERROR_NO_MORE_FILES)
		return GetLastError();
	do
	{
		if(finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			DirList.insert(DirList.end(),finddata.cFileName);
		else
			FileList.insert(FileList.end(),finddata.cFileName);
	}
	while(FindNextFile(hFind,&finddata));
	FindClose(hFind);
	hFind = 0;

	HRESULT hr;
	wstringlist::iterator i;
	for(i = FileList.begin(); i != FileList.end(); ++i)
	{
		hr = Sync(szBasePrj,
					szDir,
					(*i).c_str());
		IF_FAIL_RTN1(hr,"Sync");
	}
		
	for(i = DirList.begin(); i != DirList.end(); ++i)
	{
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\cfgmnt\ssauterr.h ===
//*****************************************************************************
// ssauterr.h
//
//
// Copyright (c) 1995 by Microsoft Corporation, All Rights Reserved
//*****************************************************************************

#define MAKEHR(iStat) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, (USHORT) (iStat))

#define ESS_CORRUPT					MAKEHR(-10600)	// File %s may be corrupt
#define ESS_DT_BADDATESTR			MAKEHR(-10159)	// Invalid date string: "%s"
#define ESS_DT_INVALID				MAKEHR(-10161)	// Invalid time or date string
#define ESS_NOMORE_HANDLES			MAKEHR(-10164)	// Too many file handles open.
#define ESS_FILE_ACCESSDENIED		MAKEHR(-10165)	// Access to file "%s" denied
#define ESS_FILE_BADDRIVE			MAKEHR(-10166)	// Invalid drive: %s
#define ESS_FILE_BADHANDLE			MAKEHR(-10167)	// Invalid handle.
#define ESS_FILE_BADNAME			MAKEHR(-10168)	// Invalid filename: "%s"
#define ESS_FILE_BADPARAM			MAKEHR(-10170)	// Invalid access code (bad parameter)
#define ESS_FILE_BADPATH			MAKEHR(-10171)	// Invalid DOS path: %s
#define ESS_FILE_CURRENTDIR			MAKEHR(-10172)	// Folder %s is in use
#define ESS_FILE_DISKFULL			MAKEHR(-10173)	// Disk full
#define ESS_FILE_EXISTS				MAKEHR(-10175)	// File "%s" already exists
#define ESS_FILE_LOCKED				MAKEHR(-10176)	// File "%s" is locked
#define ESS_FILE_NOTFOUND			MAKEHR(-10178)	// File "%s" not found
#define ESS_FILE_READ				MAKEHR(-10180)	// Error reading from file
#define ESS_FILE_SHARE				MAKEHR(-10181)	// File %s is already open
#define ESS_FILE_TOOMANY			MAKEHR(-10182)	// Too many file handles open
#define ESS_FILE_VOLNOTSAME			MAKEHR(-10183)	// Cannot rename to another volume
#define ESS_FILE_WRITE				MAKEHR(-10184)	// Error writing to file
#define ESS_INI_BADBOOL				MAKEHR(-10200)	// Initialization variable "%s" must be set to "Yes" or "No"
#define ESS_INI_BADLINE				MAKEHR(-10201)	// Invalid syntax on line %d of file %s
#define ESS_INI_BADNUMBER			MAKEHR(-10202)	// Initialization variable ""%s"" set to invalid number
#define ESS_INI_BADPATH				MAKEHR(-10203)	// Initialization variable ""%s"" set to invalid path
#define ESS_INI_BADVALUE			MAKEHR(-10205)	// Initialization variable ""%s"" set to invalid value
#define ESS_INI_NOSUCHVAR			MAKEHR(-10206)	// Cannot find initialization variable "%s"
#define ESS_INI_NUMRANGE			MAKEHR(-10207)	// Initialization variable "%s" must be between %d and %d
#define ESS_INI_TOO_MANY_ENV		MAKEHR(-10208)	// Too many SS.INI environment strings
#define ESS_LOCK_TIMEOUT			MAKEHR(-10266)	// Timeout locking file: %s
#define ESS_MEM_NOMEMORY			MAKEHR(-10270)	// Out of memory
#define ESS_NO_TWEAK_CHKDOUT		MAKEHR(-10625)	// You cannot modify the properties of a file that is checked out.
#define ESS_NOMERGE_BIN_NODELTA		MAKEHR(-10279)	// You cannot perform a merge on a binary file, or a file that stores latest version only.
#define ESS_NOMULTI_BINARY			MAKEHR(-10280)	// Cannot check out %s. It is binary and is already checked out.
#define ESS_NOMULTI_NODELTA			MAKEHR(-10281)	// %s stores only the latest version and is already checked out.
#define ESS_OS_NOT_EXE				MAKEHR(-10285)	// Error executing: %s
#define ESS_SS_ADDPRJASSOCFILE		MAKEHR(-10626)	// %s is a SourceSafe configuration file and cannot be added.
#define ESS_SS_ADMIN_LOCKOUT		MAKEHR(-10456)	// The SourceSafe database has been locked by the Administrator.
#define ESS_SS_BADRENAME			MAKEHR(-10402)	// Unable to rename %s to %s.
#define ESS_SS_CANT_FIND_SSINI		MAKEHR(-10403)	// Cannot find SS.INI file for user %s
#define ESS_SS_CHECKED_OUT			MAKEHR(-10405)	// File %s is currently checked out by %s
#define ESS_SS_CHECKED_OUT_YOU		MAKEHR(-10406)	// You currently have file %s checked out
#define ESS_SS_CHECKOUT_OLD			MAKEHR(-10408)	// Cannot check out an old version of a file
#define ESS_SS_CHKOUT_USER			MAKEHR(-10413)	// File %s is currently checked out by %s
#define ESS_SS_CONFLICTS			MAKEHR(-10415)	// An automatic merge has occurred and there are conflicts.\nEdit %s to resolve them.
#define ESS_SS_DEL_ROOT				MAKEHR(-10418)	// Cannot delete the root project
#define ESS_SS_DEL_SHARED			MAKEHR(-10419)	// A deleted link to %s already exists
#define ESS_SS_FILE_NOTFOUND		MAKEHR(-10421)	// File ""%s"" not found
#define ESS_SS_HISTOPEN				MAKEHR(-10404)	// A history operation is already in progress
#define ESS_SS_INSUFRIGHTS			MAKEHR(-10423)	// You do not have access rights to %s
#define ESS_SS_LATERCHKEDOUT		MAKEHR(-10426)	// A more recent version is checked out
#define ESS_SS_LOCALRW				MAKEHR(-10427)	// A writable copy of %s already exists
#define ESS_SS_MOVE_CHANGENAME		MAKEHR(-10428)	// Move does not change the name of a project
#define ESS_SS_MOVE_NOPARENT		MAKEHR(-10429)	// Project %s does not exist
#define ESS_SS_MOVE_ROOT			MAKEHR(-10430)	// Cannot move the root project
#define ESS_SS_MUST_USE_VERS		MAKEHR(-10431)	// Cannot roll back to the most recent version of %s
#define ESS_SS_NOCOMMANCESTOR		MAKEHR(-10432)	// Files have no common ancestor
#define ESS_SS_NOCONFLICTS2			MAKEHR(-10434)	// %s has been merged with no conflicts.
#define ESS_SS_NODOLLAR				MAKEHR(-10435)	// File %s is invalid. Files may not begin with $.
#define ESS_SS_NOT_CHKEDOUT			MAKEHR(-10436)	// File %s is not checked out
#define ESS_SS_NOT_SHARED			MAKEHR(-10437)	// File %s is not shared by any other projects
#define ESS_SS_NOTSEPARATED			MAKEHR(-10438)	// Files are not branched
#define ESS_SS_OPEN_LOGGIN			MAKEHR(-10457)	// Unable to open user login file %s.
#define ESS_SS_PATHTOOLONG			MAKEHR(-10439)	// Path %s too long
#define ESS_SS_RENAME_MOVE			MAKEHR(-10442)	// Rename does not move an item to another project
#define ESS_SS_RENAME_ROOT			MAKEHR(-10443)	// Cannot Rename the root project
#define ESS_SS_ROLLBACK_NOTOLD		MAKEHR(-10447)	// Cannot Rollback to the most recent version of %s
#define ESS_SS_SHARE_ANCESTOR		MAKEHR(-10449)	// A project cannot be shared under a descendant.
#define ESS_SS_SHARED				MAKEHR(-10450)	// File %s is already shared by this project
#define ESS_SSPEC_SYNTAX			MAKEHR(-10515)	// Invalid SourceSafe syntax: "%s"
#define ESS_UM_BAD_CHAR				MAKEHR(-10550)	// Bad username syntax: "%s"
#define ESS_UM_BAD_PASSWORD			MAKEHR(-10551)	// Invalid password
#define ESS_UM_BADVERSION			MAKEHR(-10552)	// Incompatible database version
#define ESS_UM_DEL_ADMIN			MAKEHR(-10553)	// Cannot delete the Admin user
#define ESS_UM_PERM_DENIED			MAKEHR(-10554)	// Permission denied
#define ESS_UM_RENAME_ADMIN			MAKEHR(-10555)	// Can not rename the Admin user
#define ESS_UM_TOO_LONG				MAKEHR(-10556)	// Username too long
#define ESS_UM_USER_EXISTS			MAKEHR(-10557)	// User "%s" already exists
#define ESS_UM_USER_NOT_FOUND		MAKEHR(-10558)	// User "%s" not found
#define ESS_URL_BADPATH				MAKEHR(-10192)	// The URL for project %s was not set properly.
#define ESS_VS_CHECKED_OUT			MAKEHR(-10601)	// File %s checked out
#define ESS_VS_CHILD_NOT_FOUND		MAKEHR(-10602)	// Subproject or file not found
#define ESS_VS_COLLISION			MAKEHR(-10603)	// Collision accessing database, please try again.
#define ESS_VS_EXCLUSIVE_CHECKED_OUT MAKEHR(-10614)	// File %s is exclusively checked out.
#define ESS_VS_ITEMEXISTS			MAKEHR(-10604)	// An item with the name %s already exists
#define ESS_VS_LONGNAME				MAKEHR(-10605)	// %s is an invalid %s name
#define ESS_VS_MOVE_CYCLE			MAKEHR(-10606)	// You can not move a project under itself
#define ESS_VS_NO_DELTA				MAKEHR(-10607)	// File %s does not retain old versions of itself
#define ESS_VS_NOT_CHECKED_OUT		MAKEHR(-10608)	// File %s cannot be checked into this project
#define ESS_VS_NOT_FOUND			MAKEHR(-10609)	// File or project not found
#define ESS_VS_PARENT_NOT_FOUND		MAKEHR(-10610)	// Parent not found
#define ESS_VS_VERS_NOT_FOUND		MAKEHR(-10615)	// Version not found
#define ESS_VS_WANT_FILE			MAKEHR(-10616)	// This command only works on files.
#define ESS_VS_WANT_PRJ				MAKEHR(-10617)	// This command only works on projects.
#define ESS_URL_BUFOVERFLOW			MAKEHR(-10194)	// A link in %s was ignored because it was longer than SourceSafe can understand
#define ESS_URL_CANTCHECKHTML		MAKEHR(-10193)	// An error occurred while  trying to check hyperlinks for %s
#define ESS_SS_ADDINFAILED			MAKEHR(-10440)	// Error loading SourceSafe add-in: %s
#define ESS_CANCEL					MAKEHR(-32766)
#define ESS_LOADSTRING_FAILED		MAKEHR(-10999)	// Error loading resource string

// SourceSafe questions answered affirmatively.
//
// A deleted copy of this %s file already exists in this project.\nDo you want to recover the existing file?
// Folder %s not found, create?
// Have any conflicts in %s been properly resolved?
// File %s is currently checked out by %s.\nProceed anyway?
// File %s was checked out to folder %s.\nProceed in %s?
// File %s is checked out to project %s, and you are in %s.\nProceed anyway?
// File %s is currently checked out by %s.  Delete anyway?
// You currently have file %s checked out.  Delete anyway?
// An item named %s was already deleted from this project.\nPurge the old item and delete this one now?
// This version of %s already has a label: overwrite?
// The label %s is already used.  Remove the old label?
// %s has been merged with no conflicts.\nCheck in now?
// Redo the automatic merge?
// Delete local file: %s?
// %s is already checked out, continue?
// File %s has been destroyed, and cannot be rebuilt.\nContinue anyway?
// Project $%s has been destroyed, and cannot be rebuilt.\nContinue anyway?
// $%s was moved out of this project, and cannot be rebuilt.\nContinue anyway?
// %s has changed. Undo check out and lose changes?
//
// SourceSafe questions answered in the negative.
//
// A deleted file of the same name already exists in this SourceSafe project.\nDo you want to recover the deleted file instead of adding your local %s?
// %s is writable, replace?
// %s is checked out, replace?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\guid\guid.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    guid.cxx

Abstract:

    Defines global GUIDs.

Author:

    Keith Moore (keithmo)        31-Jan-1996

Revision History:

--*/

#include <windows.h>
#define INITGUID
#include <ole2.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\custerr\custerr.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    custerr.cxx

Abstract:

    Custom Error Utility

Author:

    Keith Moore (keithmo)        04-Sep-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api,hr,fatal)                                          \
            if( FAILED(hr) ) {                                              \
                                                                            \
                wprintf(                                                    \
                    L"%S:%lu failed, error %lx %S\n",                       \
                    (api),                                                  \
                    __LINE__,                                               \
                    (result),                                               \
                    (fatal)                                                 \
                        ? "ABORTING"                                        \
                        : "CONTINUING"                                      \
                    );                                                      \
                                                                            \
                if( fatal ) {                                               \
                                                                            \
                    goto cleanup;                                           \
                                                                            \
                }                                                           \
                                                                            \
            } else

#define ALLOC( cb ) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE( ptr ) (VOID)LocalFree( (HLOCAL)(ptr) )


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//

VOID
Usage(
    VOID
    );

VOID
SetCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath,
    LPWSTR FileName
    );

VOID
DumpCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath
    );


//
// Public functions.
//


INT
__cdecl
wmain(
    INT argc,
    LPWSTR argv[]
    )
{

    HRESULT result;
    IMSAdminBase * admCom;
    LPWSTR metaPath;
    LPWSTR fileName;
    LPWSTR arg;
    INT i;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    admCom = NULL;

    //
    // Establish defaults.
    //

    metaPath = L"w3svc";
    fileName = NULL;

    //
    // Validate the command line arguments.
    //

    for( i = 1 ; i < argc ; i++ ) {
        arg = argv[i];

        if( arg[0] != L'-' ||
            arg[1] == L'\0' ||
            arg[2] != L':' ||
            arg[3] == L'\0' ) {
            Usage();
            return 1;
        }

        switch( arg[1] ) {
        case L'h' :
        case L'H' :
        case L'?' :
            Usage();
            return 1;

        case L'p' :
        case L'P' :
            metaPath = arg + 3;
            break;

        case L'f' :
        case L'F' :
            fileName = arg + 3;
            break;

        default :
            Usage();
            return 1;
        }

    }

    //
    // Initialize COM.
    //

    result = CoInitializeEx(
                 NULL,
                 COINIT_MULTITHREADED
                 );

    TEST_HRESULT( "CoInitializeEx()", result, TRUE );

    //
    // Get the admin object.
    //

    result = MdGetAdminObject( &admCom );

    TEST_HRESULT( "MdGetAdminObject()", result, TRUE );

    //
    // Do it.
    //

    if( fileName == NULL ) {
        DumpCustomError( admCom, metaPath );
    } else {
        SetCustomError( admCom, metaPath, fileName );
    }

cleanup:

    //
    // Release the admin object.
    //

    if( admCom != NULL ) {

        result = MdReleaseAdminObject( admCom );
        TEST_HRESULT( "MdReleaseAdminObject()", result, FALSE );

    }

    //
    // Shutdown COM.
    //

    CoUninitialize();
    return 0;

}   // main


//
// Private functions.
//

VOID
Usage(
    VOID
    )
{

    wprintf(
        L"use: custerr [options]\n"
        L"\n"
        L"valid options are:\n"
        L"\n"
        L"    -p:meta_path\n"
        L"    -f:error_file\n"
        L"\n"
        );

}   // Usage

VOID
SetCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath,
    LPWSTR FileName
    )
{

    HANDLE fileHandle;
    DWORD length;
    DWORD lengthHigh;
    DWORD bytesRemaining;
    HANDLE mappingHandle;
    PCHAR view;
    PCHAR viewScan;
    PWCHAR multiSz;
    PWCHAR multiSzScan;
    HRESULT result;
    BOOL gotOne;
    METADATA_HANDLE metaHandle;
    METADATA_RECORD metaRecord;
    DWORD err;
    CHAR ansiFileName[MAX_PATH];
    WCHAR fullMetaPath[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    fileHandle = INVALID_HANDLE_VALUE;
    mappingHandle = NULL;
    view = NULL;
    multiSz = NULL;
    metaHandle = 0;

    //
    // Open the file, get its length.
    //

    sprintf(
        ansiFileName,
        "%S",
        FileName
        );

    fileHandle = CreateFileA(
                     ansiFileName,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     );

    if( fileHandle == INVALID_HANDLE_VALUE ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot open %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    length = GetFileSize( fileHandle, &lengthHigh );

    if( length == 0xFFFFFFFF || lengthHigh > 0 ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot read %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    //
    // Map it in.
    //

    mappingHandle = CreateFileMapping(
                        fileHandle,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if( mappingHandle == NULL ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot read %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    view = (PCHAR)MapViewOfFile(
                      mappingHandle,
                      FILE_MAP_READ,
                      0,
                      0,
                      0
                      );

    if( view == NULL ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot read %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    //
    // Allocate the multisz buffer. Assume it will be roughly the same
    // size as the file.
    //

    multiSz = (PWCHAR) ALLOC( length * sizeof(WCHAR) );

    if( multiSz == NULL ) {
        wprintf(
            L"custerr: not enough memory\n"
            );
        goto cleanup;
    }

    //
    // Build the multisz.
    //

    viewScan = view;
    multiSzScan = multiSz;
    bytesRemaining = length;

    while( bytesRemaining > 0 ) {

        //
        // Skip leading whitespace.
        //

        while( bytesRemaining > 0 &&
               ( *viewScan == ' ' || *viewScan == '\t' ||
                 *viewScan == '\r' || *viewScan == '\n' ) ) {
            bytesRemaining--;
            viewScan++;
        }

        //
        // Copy it over, collapse embedded whitespace, perform
        // cheesy ANSI-to-UNICODE conversion.
        //

        gotOne = FALSE;

        while( bytesRemaining > 0 &&
               ( *viewScan != '\r' && *viewScan != '\n' ) ) {
            bytesRemaining--;
            if( *viewScan != ' ' && *viewScan != '\t' ) {
                *multiSzScan++ = (WCHAR)*viewScan;
                gotOne = TRUE;
            }
            viewScan++;
        }

        if( gotOne ) {
            *multiSzScan++ = L'\0';
        }

    }

    *multiSzScan++ = L'\0';

    //
    // Open the metabase.
    //

    swprintf(
        fullMetaPath,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        MetaPath
        );

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 fullMetaPath,
                 METADATA_PERMISSION_WRITE,
                 METABASE_OPEN_TIMEOUT,
                 &metaHandle
                 );

    TEST_HRESULT( "AdmCom->OpenKey()", result, TRUE );

    //
    // Write the new custom error value.
    //

    length = ( multiSzScan - multiSz ) * sizeof(WCHAR);

    INITIALIZE_METADATA_RECORD(
        &metaRecord,
        MD_CUSTOM_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        MULTISZ_METADATA,
        length,
        multiSz
        );

    result = AdmCom->SetData(
                 metaHandle,
                 L"",
                 &metaRecord
                 );

    TEST_HRESULT( "AdmCom->SetData()", result, TRUE );

cleanup:

    if( metaHandle != 0 ) {
        AdmCom->CloseKey( metaHandle );
    }

    if( multiSz != NULL ) {
        FREE( multiSz );
    }

    if( view != NULL ) {
        UnmapViewOfFile( view );
    }

    if( mappingHandle != NULL ) {
        CloseHandle( mappingHandle );
    }

    if( fileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( fileHandle );
    }

}   // SetCustomError

VOID
DumpCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath
    )
{


    HRESULT result;
    METADATA_HANDLE metaHandle;
    METADATA_RECORD metaRecord;
    DWORD bytesRequired;
    PWCHAR buffer;
    PWCHAR bufferScan;
    WCHAR fullMetaPath[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    metaHandle = 0;
    buffer = NULL;

    //
    // Open the metabase.
    //

    swprintf(
        fullMetaPath,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        MetaPath
        );

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 fullMetaPath,
                 METADATA_PERMISSION_READ,
                 METABASE_OPEN_TIMEOUT,
                 &metaHandle
                 );

    TEST_HRESULT( "AdmCom->OpenKey()", result, TRUE );

    //
    // Get the data size.
    //

    INITIALIZE_METADATA_RECORD(
        &metaRecord,
        MD_CUSTOM_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        MULTISZ_METADATA,
        2,
        L""
        );

    result = AdmCom->GetData(
                 metaHandle,
                 L"",
                 &metaRecord,
                 &bytesRequired
                 );

    if( result != RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) ) {
        TEST_HRESULT( "AdmCom->GetData()", result, TRUE );
    }

    //
    // Allocate our data buffer.
    //

    buffer = (PWCHAR)ALLOC( bytesRequired );

    if( buffer == NULL ) {
        wprintf(
            L"custerr: not enough memory\n"
            );
        goto cleanup;
    }

    //
    // Now actually read it.
    //

    INITIALIZE_METADATA_RECORD(
        &metaRecord,
        MD_CUSTOM_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        MULTISZ_METADATA,
        bytesRequired,
        buffer
        );

    result = AdmCom->GetData(
                 metaHandle,
                 L"",
                 &metaRecord,
                 &bytesRequired
                 );

    TEST_HRESULT( "AdmCom->GetData()", result, TRUE );

    //
    // Print it.
    //

    bufferScan = buffer;

    while( *bufferScan != L'\0' ) {
        wprintf( L"%s\n", bufferScan );
        bufferScan += wcslen( bufferScan ) + 1;
    }

cleanup:

    if( buffer != NULL ) {
        FREE( buffer );
    }

    if( metaHandle != 0 ) {
        AdmCom->CloseKey( metaHandle );
    }

}   // DumpCustomError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\iisnet\sink.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    Implements the ADMIN_SINK object.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

ADMIN_SINK::ADMIN_SINK()
{

    //
    // Put everything into a known state.
    //

    m_StateChangeEvent = NULL;

}   // ADMIN_SINK::ADMIN_SINK

ADMIN_SINK::~ADMIN_SINK()
{

    //
    // Zap the state change event.
    //

    if( m_StateChangeEvent != NULL ) {

        CloseHandle( m_StateChangeEvent );
        m_StateChangeEvent = NULL;

    }

}   // ADMIN_SINK::~ADMIN_SINK

HRESULT
ADMIN_SINK::Initialize(
    IN IUnknown * Object
    )
{

    HRESULT result;

    result = BASE_ADMIN_SINK::Initialize( Object );

    if( SUCCEEDED(result) ) {

        m_StateChangeEvent = CreateEvent(
                                 NULL,          // lpEventAttributes
                                 FALSE,         // bManualReset
                                 FALSE,         // bInitialState
                                 NULL           // lpName
                                 );

        if( m_StateChangeEvent == NULL ) {
            DWORD err = GetLastError();
            result = HRESULT_FROM_WIN32( err );
        }

    }

    return result;

}   // ADMIN_SINK::Initialize

HRESULT
STDMETHODCALLTYPE
ADMIN_SINK::SinkNotify(
    IN DWORD NumElements,
    IN MD_CHANGE_OBJECT ChangeList[]
    )
{

    DWORD numIds;
    DWORD *idList;

    //
    // Scan the change list. If MD_SERVER_STATE has changed, set the
    // change event so the polling loop will exit.
    //

    for( ; NumElements > 0 ; NumElements--, ChangeList++ ) {

        numIds = ChangeList->dwMDNumDataIDs;
        idList = ChangeList->pdwMDDataIDs;

        for( ; numIds > 0 ; numIds--, idList++ ) {

            if( *idList == MD_SERVER_STATE ) {

                SetEvent( m_StateChangeEvent );
                break;

            }

        }

    }

    return NO_ERROR;

}   // ADMIN_SINK::SinkNotify

DWORD
ADMIN_SINK::WaitForStateChange(
    IN DWORD Timeout
    )
{

    return WaitForSingleObject(
               m_StateChangeEvent,
               Timeout
               );

}   // ADMIN_SINK::WaitForStateChange


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\lib\admin.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    admin.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetAdminObject(
    OUT IMSAdminBase ** AdmCom
    )
{

    HRESULT result;
    IClassFactory * classFactory;

    //
    // Get the admin class factory.
    //

    result = CoGetClassObject(
                 GETAdminBaseCLSID(TRUE),
                 CLSCTX_SERVER,
                 NULL,
                 IID_IClassFactory,
                 (VOID **)&classFactory
                 );

    if( SUCCEEDED(result) ) {

        //
        // Create the admin object.
        //

        result = classFactory->CreateInstance(
                     NULL,
                     IID_IMSAdminBase,
                     (VOID **)AdmCom
                     );

        classFactory->Release();

    }

    return result;

}   // MdGetAdminObject

HRESULT
MdReleaseAdminObject(
    IN IMSAdminBase * AdmCom
    )
{

    //
    // Terminate the admin object.
    //

    AdmCom->Release();

    return NO_ERROR;

}   // MdReleaseAdminObject


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\lib\data.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enum.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define INITIAL_BUFFER_SIZE 64


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetAllMetaData(
    IN IMSAdminBase * AdmCom,
    IN METADATA_HANDLE Handle,
    IN LPWSTR Path,
    IN DWORD Attributes,
    OUT METADATA_GETALL_RECORD ** Data,
    OUT DWORD * NumEntries
    )
{

    HRESULT result;
    DWORD dataSet;
    DWORD bytesRequired;
    DWORD bufferLength;
    LPVOID buffer;

    bufferLength = INITIAL_BUFFER_SIZE;
    buffer = NULL;

    while( TRUE ) {

        if( buffer != NULL ) {
            MdpFreeMem( buffer );
        }

        buffer = MdpAllocMem( bufferLength );

        if( buffer == NULL ) {
            result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            break;
        }

        result = AdmCom->GetAllData(
                     Handle,
                     Path,
                     Attributes,
                     ALL_METADATA,
                     ALL_METADATA,
                     NumEntries,
                     &dataSet,
                     bufferLength,
                     (BYTE *)buffer,
                     &bytesRequired
                     );

        if( SUCCEEDED(result) ) {
            break;
        }

        if( result != RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) ) {
            break;
        }

        bufferLength = bytesRequired;

    }

    if( SUCCEEDED(result) ) {
        *Data = (METADATA_GETALL_RECORD *)buffer;
    } else if( buffer != NULL ) {
        MdpFreeMem( buffer );
    }

    return result;

}   // MdGetAllMetaData

HRESULT
MdFreeMetaDataBuffer(
    IN VOID * Data
    )
{

    MdpFreeMem( Data );
    return NO_ERROR;

}   // MdFreeMetaDataBuffer

//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\iisnet\cmds.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cmds.cxx

Abstract:

    IISNET command handlers.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define WAIT_FOR_STATE_CHANGE_TIMEOUT   1000    // ms


//
// Private types.
//

typedef struct _ENUM_CONTEXT {

    BOOL ShowAll;
    LPWSTR Instance;
    WCHAR Service[MAX_PATH];

} ENUM_CONTEXT, *PENUM_CONTEXT;


//
// Private globals.
//


//
// Private prototypes.
//

VOID
PerformStateChange(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN LPWSTR InstanceName,
    IN DWORD Command,
    IN DWORD TransientState
    );

VOID
EnumInstances(
    IN IMSAdminBase * AdmCom,
    IN BOOL ShowAll
    );

BOOL
WINAPI
ServerLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    );

BOOL
WINAPI
InstanceLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    );


//
// Public functions.
//

VOID
WINAPI
StartCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc == 0 ) {

        EnumInstances(
            AdmCom,
            FALSE       // ShowAll
            );

    } else
    if( argc == 1 ) {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_START,
            MD_SERVER_STATE_STARTING
            );

    } else {

        wprintf(
            L"use: iisnet start [service/instance]\n"
            );

    }

}   // StartCommand

VOID
WINAPI
StopCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc != 1 ) {

        wprintf(
            L"use: iisnet stop service/instance\n"
            );

    } else {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_STOP,
            MD_SERVER_STATE_STOPPING
            );

    }

}   // StopCommand

VOID
WINAPI
PauseCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc != 1 ) {

        wprintf(
            L"use: iisnet pause service/instance\n"
            );

    } else {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_PAUSE,
            MD_SERVER_STATE_PAUSING
            );

    }

}   // PauseCommand

VOID
WINAPI
ContinueCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc != 1 ) {

        wprintf(
            L"use: iisnet continue service/instance\n"
            );

    } else {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_CONTINUE,
            MD_SERVER_STATE_CONTINUING
            );

    }

}   // ContinueCommand

VOID
WINAPI
QueryCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc == 0 ) {

        EnumInstances(
            AdmCom,
            TRUE        // ShowAll
            );

    } else
    if( argc == 1 ) {

        HRESULT result;

        result = MdDisplayInstanceState(
                     AdmCom,
                     *argv
                     );

        if( FAILED(result) ) {

            wprintf(
                L"iisnet: cannot get instance state, error %lx\n",
                result
                );

        }

    } else {

        wprintf(
            L"use: iisnet query [server/instance]\n"
            );

    }

}   // QueryCommand


//
// Private functions.
//

VOID
PerformStateChange(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN LPWSTR InstanceName,
    IN DWORD Command,
    IN DWORD TransientState
    )
{

    HRESULT result;
    DWORD status;
    DWORD currentState;
    DWORD currentWin32Status;

    result = MdDisplayInstanceState(
                 AdmCom,
                 InstanceName
                 );

    if( FAILED(result) ) {

        wprintf(
            L"Cannot query server state, error %lx\n",
            result
            );

        return;

    }

    result = MdControlInstance(
                 AdmCom,
                 InstanceName,
                 Command
                 );

    if( FAILED(result) ) {

        wprintf(
            L"Cannot set server state, error %lu\n",
            result
            );

        return;

    }

    wprintf(
        L"Waiting for state change..."
        );

    currentState = TransientState;

    do {

        status = Sink->WaitForStateChange( WAIT_FOR_STATE_CHANGE_TIMEOUT );

        if( status == WAIT_TIMEOUT ) {
            wprintf( L"." );
            continue;
        }

        result = MdGetInstanceState(
                     AdmCom,
                     InstanceName,
                     &currentState,
                     &currentWin32Status
                     );

        if( FAILED(result) ) {

            wprintf(
                L"Cannot query server state, error %lx\n",
                result
                );

            break;

        }

    } while( currentState == TransientState );

    wprintf( L"\n" );

    MdDisplayInstanceState(
        AdmCom,
        InstanceName
        );

}   // PerformStateChange

VOID
EnumInstances(
    IN IMSAdminBase * AdmCom,
    IN BOOL ShowAll
    )
{

    HRESULT result;
    ENUM_CONTEXT context;

    context.ShowAll = ShowAll;

    result = MdEnumMetaObjects(
                 AdmCom,
                 L"LM",
                 &ServerLevelCallback,
                 (VOID *)&context
                 );

    if( FAILED(result) ) {

        wprintf(
            L"iisnet: cannot enumerate servers, error %lx\n",
            result
            );

    }

}   // EnumRunningInstances

BOOL
WINAPI
ServerLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    )
{

    HRESULT result;
    PENUM_CONTEXT context = (PENUM_CONTEXT)Context;
    WCHAR path[MAX_PATH];

    swprintf(
        path,
        L"%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        ObjectName
        );

    wcscpy(
        context->Service,
        ObjectName
        );

    context->Instance = context->Service + wcslen( ObjectName );

    result = MdEnumMetaObjects(
                 AdmCom,
                 path,
                 &InstanceLevelCallback,
                 Context
                 );

    return TRUE;

}   // ServerLevelCallback

BOOL
WINAPI
InstanceLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    )
{

    HRESULT result;
    PENUM_CONTEXT context = (PENUM_CONTEXT)Context;
    DWORD currentState;
    DWORD currentWin32Status;

    swprintf(
        context->Instance,
        L"/%s",
        ObjectName
        );

    result = MdGetInstanceState(
                 AdmCom,
                 context->Service,
                 &currentState,
                 &currentWin32Status
                 );

    if( SUCCEEDED(result) ) {

        if( context->ShowAll || currentState == MD_SERVER_STATE_STARTED ) {

            wprintf(
                L"%s: state = %lu (%s), status = %lu\n",
                context->Service,
                currentState,
                MdInstanceStateToString( currentState ),
                currentWin32Status
                );

        }

    }

    return TRUE;

}   // InstanceLevelCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\iisnet\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Server Instance Controller.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api,hr,fatal)                                          \
            if( FAILED(hr) ) {                                              \
                                                                            \
                wprintf(                                                    \
                    L"%S:%lu failed, error %lx %S\n",                       \
                    (api),                                                  \
                    __LINE__,                                               \
                    (result),                                               \
                    (fatal)                                                 \
                        ? "ABORTING"                                        \
                        : "CONTINUING"                                      \
                    );                                                      \
                                                                            \
                if( fatal ) {                                               \
                                                                            \
                    goto cleanup;                                           \
                                                                            \
                }                                                           \
                                                                            \
            } else


//
// Private types.
//


//
// Private globals.
//

COMMAND_TABLE CommandTable[] =
    {
        { L"Start",     &StartCommand       },
        { L"Stop",      &StopCommand        },
        { L"Pause",     &PauseCommand       },
        { L"Continue",  &ContinueCommand    },
        { L"Query",     &QueryCommand       }
    };

#define NUM_COMMANDS ( sizeof(CommandTable) / sizeof(CommandTable[0]) )


//
// Private prototypes.
//

VOID
Usage(
    VOID
    );


//
// Public functions.
//


INT
__cdecl
wmain(
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    HRESULT result;
    ADMIN_SINK * sink;
    IMSAdminBase * admCom;
    DWORD i;
    PCOMMAND_TABLE command;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    admCom = NULL;
    sink = NULL;

    //
    // Validate the arguments.
    //

    if( argc == 1 ) {

        Usage();
        return 1;

    }

    for( i = 0, command = CommandTable ;
         i < NUM_COMMANDS ;
         i++, command++ ) {

        if( !_wcsicmp( argv[1], command->Name ) ) {

            break;

        }

    }

    if( i == NUM_COMMANDS ) {

        Usage();
        return 1;

    }

    argc -= 2;      // Skip the program name...
    argv += 2;      // ...and the command name.

    //
    // Initialize COM.
    //

    result = CoInitializeEx(
                 NULL,
                 COINIT_MULTITHREADED
                 );

    TEST_HRESULT( "CoInitializeEx()", result, TRUE );

    //
    // Get the admin object.
    //

    result = MdGetAdminObject( &admCom );

    TEST_HRESULT( "MdGetAdminObject()", result, TRUE );

    //
    // Setup the advise sink.
    //

    sink = new ADMIN_SINK();

    if( sink == NULL ) {

        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

    } else {

        sink->AddRef();
        result = sink->Initialize( (IUnknown *)admCom );

    }

    TEST_HRESULT( "sink->Initialize()", result, TRUE );

    //
    // Let the command handler do the dirty work.
    //

    command->Handler(
        admCom,
        sink,
        argc,
        argv
        );

cleanup:

    if( sink != NULL ) {
        sink->Unadvise();
        sink->Release();
    }

    //
    // Release the admin object.
    //

    if( admCom != NULL ) {
        result = MdReleaseAdminObject( admCom );
        TEST_HRESULT( "MdReleaseAdminObject()", result, FALSE );
    }

    //
    // Shutdown COM.
    //

    CoUninitialize();

    return 0;

}   // main


//
// Private functions.
//

VOID
Usage(
    VOID
    )
{

    wprintf(
        L"Use: iisnet operation service/instance\n"
        L"\n"
        L"Valid operations are:\n"
        L"\n"
        L"    start\n"
        L"    stop\n"
        L"    pause\n"
        L"    continue\n"
        L"    query\n"
        L"\n"
        L"For example:\n"
        L"\n"
        L"    iisnet pause w3svc/1\n"
        );

}   // Usage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\lib\enum.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enum.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdEnumMetaObjects(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR KeyName,
    IN PFN_ADMIN_ENUM_CALLBACK Callback,
    IN VOID * Context
    )
{

    HRESULT result;
    METADATA_HANDLE handle;
    DWORD index;
    WCHAR path[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    handle = 0;

    //
    // Open the metabase.
    //

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 KeyName,
                 METADATA_PERMISSION_READ,
                 METABASE_OPEN_TIMEOUT,
                 &handle
                 );

    if( FAILED(result) ) {
        goto Cleanup;
    }

    //
    // Enumerate the objects.
    //

    for( index = 0 ; ; index++ ) {

        result = AdmCom->EnumKeys(
                     handle,
                     L"",
                     path,
                     index
                     );

        if( FAILED(result) ) {
            break;
        }

        if( !(Callback)(
                AdmCom,
                path,
                Context
                ) ) {
            break;
        }

    }

    result = NO_ERROR;

Cleanup:

    if( handle != 0 ) {
        (VOID)AdmCom->CloseKey( handle );
    }

    return result;

}   // MdEnumMetaObjects


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\lib\instance.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    instance.cxx

Abstract:

    General server instance control utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetInstanceState(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR InstanceName,
    OUT DWORD * CurrentState,
    OUT DWORD * CurrentWin32Status
    )
{

    DWORD length;
    METADATA_HANDLE handle;
    HRESULT result;
    METADATA_RECORD record;
    WCHAR path[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    handle = 0;

    //
    // Build the instance path.
    //

    swprintf(
        path,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        InstanceName
        );

    //
    // Open the metabase.
    //

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 path,
                 METADATA_PERMISSION_READ,
                 METABASE_OPEN_TIMEOUT,
                 &handle
                 );

    if( FAILED(result) ) {
        goto Cleanup;
    }

    //
    // Read the server state.
    //

    length = sizeof(*CurrentState);

    INITIALIZE_METADATA_RECORD(
        &record,
        MD_SERVER_STATE,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        length,
        CurrentState
        );

    result = AdmCom->GetData(
                 handle,
                 L"",
                 &record,
                 &length
                 );

    if( FAILED(result) ) {
        goto Cleanup;
    }

    //
    // Read the win32 status.
    //

    length = sizeof(*CurrentWin32Status);

    INITIALIZE_METADATA_RECORD(
        &record,
        MD_WIN32_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        length,
        CurrentWin32Status
        );

    result = AdmCom->GetData(
                 handle,
                 L"",
                 &record,
                 &length
                 );

    if( FAILED(result) ) {

        if( result == MD_ERROR_DATA_NOT_FOUND ) {
            *CurrentWin32Status = NO_ERROR;
            result = NO_ERROR;
        } else {
            goto Cleanup;
        }

    }

Cleanup:

    if( handle != 0 ) {
        (VOID)AdmCom->CloseKey( handle );
    }

    return result;

}   // MdGetInstanceState

HRESULT
MdControlInstance(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR InstanceName,
    IN DWORD Command
    )
{

    METADATA_HANDLE handle;
    HRESULT result;
    METADATA_RECORD record;
    WCHAR path[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    handle = 0;
    result = NO_ERROR;

    //
    // Build the instance path.
    //

    swprintf(
        path,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        InstanceName
        );

    //
    // Open the metabase.
    //

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 path,
                 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                 METABASE_OPEN_TIMEOUT,
                 &handle
                 );

    if( SUCCEEDED(result) ) {

        //
        // Send the command.
        //

        INITIALIZE_METADATA_RECORD(
            &record,
            MD_SERVER_COMMAND,
            METADATA_INHERIT,
            IIS_MD_UT_SERVER,
            DWORD_METADATA,
            sizeof(Command),
            &Command
            );

        result = AdmCom->SetData(
                     handle,
                     L"",
                     &record
                     );

        //
        // Close the meta object handle.
        //

        (VOID)AdmCom->CloseKey( handle );

    }

    return result;

}   // MdControlInstance

HRESULT
MdDisplayInstanceState(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR InstanceName
    )
{

    DWORD currentState;
    DWORD currentWin32Status;
    HRESULT result;

    //
    // Get the current state.
    //

    result = MdGetInstanceState(
                 AdmCom,
                 InstanceName,
                 &currentState,
                 &currentWin32Status
                 );

    if( SUCCEEDED(result) ) {

        wprintf(
            L"%s: state = %lu (%s), status = %lu\n",
            InstanceName,
            currentState,
            MdInstanceStateToString( currentState ),
            currentWin32Status
            );

    }

    return result;

}   // MdDisplayInstanceState

LPWSTR
MdInstanceStateToString(
    IN DWORD State
    )
{

    static WCHAR invalidState[sizeof("INVALID STATE 4294967296")];

    switch( State ) {

    case MD_SERVER_STATE_STARTING :
        return L"Starting";

    case MD_SERVER_STATE_STARTED :
        return L"Started";

    case MD_SERVER_STATE_STOPPING :
        return L"Stopping";

    case MD_SERVER_STATE_STOPPED :
        return L"Stopped";

    case MD_SERVER_STATE_PAUSING :
        return L"Pausing";

    case MD_SERVER_STATE_PAUSED :
        return L"Paused";

    case MD_SERVER_STATE_CONTINUING :
        return L"Continuing";

    }

    swprintf(
        invalidState,
        L"INVALID STATE %lu",
        State
        );

    return invalidState;

}   // MdInstanceStateToString


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


//#define ACTIVE_SERVER_PAGES 1


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

	/* t-brianm (6-3-97) Added ASSERT_STRING macros */
#define ASSERT_STRING(s) \
    ASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    ASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\lib\sink.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    Implements the BASE_ADMIN_SINK object.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

BASE_ADMIN_SINK::BASE_ADMIN_SINK()
{

    //
    // Put everything into a known state.
    //

    m_ReferenceCount = 0;
    m_SinkCookie = 0;
    m_ConnectionPoint = NULL;

}   // BASE_ADMIN_SINK::BASE_ADMIN_SINK

BASE_ADMIN_SINK::~BASE_ADMIN_SINK()
{

    //
    // Unadvise if necessary.
    //

    Unadvise();

    //
    // Release the connection point.
    //

    RELEASE_INTERFACE( m_ConnectionPoint );

}   // BASE_ADMIN_SINK::~BASE_ADMIN_SINK

HRESULT
BASE_ADMIN_SINK::Initialize(
    IN IUnknown * Object
    )
{

    HRESULT result;
    IConnectionPointContainer * container;

    //
    // Get the connection point container from the given interface.
    //

    result = Object->QueryInterface(
                 IID_IConnectionPointContainer,
                 (VOID **)&container
                 );

    if( SUCCEEDED(result) ) {

        //
        // Find the necessary connection point.
        //

        result = container->FindConnectionPoint(
                     IID_IMSAdminBaseSink,
                     &m_ConnectionPoint
                     );

        if( SUCCEEDED(result) ) {

            //
            // Setup the advise association.
            //

            result = m_ConnectionPoint->Advise(
                         (IUnknown *)this,
                         &m_SinkCookie
                         );


        }

        container->Release();

    }

    return result;

}   // BASE_ADMIN_SINK::Initialize

HRESULT
BASE_ADMIN_SINK::Unadvise(
    VOID
    )
{

    HRESULT result = NO_ERROR;
    DWORD tmpCookie;

    //
    // Unadvise if necessary.
    //

    tmpCookie = (DWORD)InterlockedExchange(
                    (LPLONG)&m_SinkCookie,
                    0
                    );

    if( tmpCookie != 0 ) {
        result = m_ConnectionPoint->Unadvise( tmpCookie );
    }

    return result;

}   // BASE_ADMIN_SINK::Unadvise

HRESULT
STDMETHODCALLTYPE
BASE_ADMIN_SINK::QueryInterface(
    IN REFIID InterfaceId,
    OUT VOID ** Object
    )
{

    //
    // This class supports IUnknown and IADMCOMSINK. If it's one of these,
    // just return "this". Otherwise, fail it.
    //

    if( InterfaceId == IID_IUnknown ||
        InterfaceId == IID_IMSAdminBaseSink ) {

        *Object = (VOID *)this;
        AddRef();
        return NO_ERROR;

    }

    return E_NOINTERFACE;

}   // BASE_ADMIN_SINK::QueryInterface

ULONG
STDMETHODCALLTYPE
BASE_ADMIN_SINK::AddRef()
{

    ULONG newCount;

    //
    // Increment our ref count and return the updated value.
    //

    newCount = (ULONG)InterlockedIncrement( &m_ReferenceCount );
    return newCount;

}   // BASE_ADMIN_SINK::AddRef

ULONG
STDMETHODCALLTYPE
BASE_ADMIN_SINK::Release()
{

    ULONG newCount;

    //
    // Decrement our ref count. It it becomes zero, delete the current
    // object. In any case, return the updated value.
    //

    newCount = (ULONG)InterlockedDecrement( &m_ReferenceCount );

    if( newCount == 0 ) {
        delete this;
    }

    return newCount;

}   // BASE_ADMIN_SINK::Release


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\chkmeta.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkMeta.cpp

Owner: t-BrianM

This file contains the headers for the objects related to the
CheckSchema and CheckKey methods.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"

#define NAME_TABLE_HASH_SIZE	1559

class CNameTable;

class CNameTableEntry {

	friend CNameTable;

public:
	CNameTableEntry() : m_tszName(NULL),
						m_pCHashNext(NULL) { }

	HRESULT Init(LPCTSTR tszName);

	~CNameTableEntry() {
		if (m_tszName != NULL) {
			delete m_tszName;
		}
	}

private:
	LPTSTR m_tszName;
	CNameTableEntry *m_pCHashNext;
};


class CNameTable {

public:
	CNameTable();
	~CNameTable();

	BOOL IsCaseSenDup(LPCTSTR tszName);
	BOOL IsCaseInsenDup(LPCTSTR tszName);
	HRESULT Add(LPCTSTR tszName);

private:
	CNameTableEntry *m_rgpNameTable[NAME_TABLE_HASH_SIZE];

	int Hash(LPCTSTR tszName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\chkmeta.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkMeta.cpp

Owner: t-BrianM

This file contains implementations of the CheckSchema and CheckKey
methods of the main MetaUtil class.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "ChkMeta.h"

/*------------------------------------------------------------------
 * C M e t a U t i l  (check portion)
 */

/*===================================================================
CMetaUtil::CheckSchema

Check the schema of a given machine for errors.

Directly Generates:
	MUTIL_CHK_NO_SCHEMA
	MUTIL_CHK_NO_PROPERTIES
	MUTIL_CHK_NO_PROP_NAMES
	MUTIL_CHK_NO_PROP_TYPES
	MUTIL_CHK_NO_CLASSES

Parameters:
    bstrMachine	[in] Base key of the machine to check
	ppIReturn	[out, retval] interface for the output error collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CheckSchema(BSTR bstrMachine, 
									ICheckErrorCollection **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::CheckSchema\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, ICheckErrorCollection *);

	if ((ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	TCHAR tszMachine[ADMINDATA_MAX_NAME_LEN];

    if (bstrMachine) {
      	_tcscpy(tszMachine, OLE2T(bstrMachine));
	    CannonizeKey(tszMachine);
    }
    else {
        tszMachine[0] = _T('\0');
    }

	// Create the CheckErrorCollection
	CComObject<CCheckErrorCollection> *pCErrorCol = NULL;

	ATLTRY(pCErrorCol = new CComObject<CCheckErrorCollection>);
	if (pCErrorCol == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// Open the Machine Key
	METADATA_HANDLE hMDMachine = NULL;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   L"",
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDMachine);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Make sure "Schema" exists
	if (!KeyExists(hMDMachine, _T("Schema"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_SCHEMA,
				 MUTIL_CHK_NO_SCHEMA_S,
				 tszMachine,
				 NULL,
				 0);
		
		goto LDone; // Can't do anything else
	}

	// Make sure "Schema/Properties" exists
	if (!KeyExists(hMDMachine, _T("Schema/Properties"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_PROPERTIES,
				 MUTIL_CHK_NO_PROPERTIES_S,
				 tszMachine,
				 _T("Schema"),
				 0);
		
		goto LClasses; // Can't do anything else with properties
	}

	// Make sure "Schema/Properties/Names" exists
	if (!KeyExists(hMDMachine, _T("Schema/Properties/Names"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_PROP_NAMES,
				 MUTIL_CHK_NO_PROP_NAMES_S,
				 tszMachine,
				 _T("Schema/Properties"),
				 0);
		
		goto LPropTypes; // Can't do anything else with names
	}

	// Check property names
	hr = CheckPropertyNames(pCErrorCol, hMDMachine, tszMachine);
	if (FAILED(hr)) {
		goto LError;
	}

LPropTypes:

	// Make sure "Schema/Properties/Types" exists
	if (!KeyExists(hMDMachine, _T("Schema/Properties/Types"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_PROP_TYPES,
				 MUTIL_CHK_NO_PROP_TYPES_S,
				 tszMachine,
				 _T("Schema/Properties"),
				 0);
		
		goto LClasses; // Can't do anything else with types
	}

	// Check property types
	hr = CheckPropertyTypes(pCErrorCol, hMDMachine, tszMachine);
	if (FAILED(hr)) {
		goto LError;
	}

LClasses:

	// Make sure "Schema/Classes" exists
	if (!KeyExists(hMDMachine, _T("Schema/Classes"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_CLASSES,
				 MUTIL_CHK_NO_CLASSES_S,
				 tszMachine,
				 _T("Schema"),
				 0);
		
		goto LDone; // Can't do anything else
	}

	// Check classes
	hr = CheckClasses(pCErrorCol, hMDMachine, tszMachine);
	if (FAILED(hr)) {
		goto LError;
	}

LDone:

	// Close the Machine Key
	m_pIMeta->CloseKey(hMDMachine);

	// Set the interface to ICheckErrorCollection
	hr = pCErrorCol->QueryInterface(IID_ICheckErrorCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;

LError:

	if (pCErrorCol != NULL) {
		delete pCErrorCol;
	}
	if (hMDMachine != NULL) {
		m_pIMeta->CloseKey(hMDMachine);
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckPropertyNames

Private function to check the "Schema/Properties/Names" key of a 
given machine.
	o Make sure that each name entry is of type STRING_METADATA
	o Make sure that each name is unique

Directly Generates:
	MUTIL_CHK_PROP_NAME_BAD_TYPE
	MUTIL_CHK_PROP_NAME_NOT_UNIQUE
	MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDMachine	Open metabase handle for the machine key
	tszMachine	Name of the machine key

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckPropertyNames(CComObject<CCheckErrorCollection> *pCErrorCol, 
									  METADATA_HANDLE hMDMachine, 
									  LPTSTR tszMachine)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszMachine);

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;
	BYTE *lpDataBuf = NULL;
	LPTSTR tszName;
	CNameTable CPropNameTable;


	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return E_OUTOFMEMORY;
	}

	// For Each Data Item
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDMachine, 
			                L"Schema/Properties/Names", 
						    &mdr, 
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Datatype must be STRING_METADATA
		if (mdr.dwMDDataType != STRING_METADATA) {
			AddError(pCErrorCol,
					 MUTIL_CHK_PROP_NAME_BAD_TYPE,
					 MUTIL_CHK_PROP_NAME_BAD_TYPE_S,
					 tszMachine,
					 _T("Schema/Properties/Names"),
					 mdr.dwMDIdentifier);
		}
		else { // mdr.dwMDDataType == STRING_METADATA

			// Check uniqueness of the name
			tszName = W2T(reinterpret_cast<LPWSTR> (lpDataBuf));

			if (CPropNameTable.IsCaseSenDup(tszName)) { 
				// Not unique
				AddError(pCErrorCol,
					 MUTIL_CHK_PROP_NAME_NOT_UNIQUE,
					 MUTIL_CHK_PROP_NAME_NOT_UNIQUE_S,
					 tszMachine,
					 _T("Schema/Properties/Names"),
					 mdr.dwMDIdentifier);
			}
			else if (CPropNameTable.IsCaseInsenDup(tszName)) { 
				// Case sensitive unique
				AddError(pCErrorCol,
					 MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE,
					 MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE_S,
					 tszMachine,
					 _T("Schema/Properties/Names"),
					 mdr.dwMDIdentifier);
				// Add it to pick up case sensitive collisions
				hr = CPropNameTable.Add(tszName);
				if (FAILED(hr)) {
					goto LError;
				}
			}
			else { 
				// Unique
				hr = CPropNameTable.Add(tszName);
				if (FAILED(hr)) {
					goto LError;
				}
			}
		}

		// Next data item
		iDataIndex++;
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDMachine, 
								L"Schema/Properties/Names", 
							    &mdr, 
							    iDataIndex, 
							    &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	delete lpDataBuf;

	return S_OK;

LError:

	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckPropertyTypes

Private function to check the "Schema/Properties/Types" key of a 
given machine.
	o Make sure that each type entry is of type BINARY_METADATA
	o Make sure that the type data is valid
		o mdrDataRec.dwMDDataLen == sizeof(PropValue)
		o PropValue.dwMetaID != 0
		o PropValue.dwMetaType != ALL_METADATA
		o PropValue.dwUserGroup != ALL_METADATA
		o (PropValue.dwMetaFlags & METADATA_PARTIAL_PATH) != METADATA_PARTIAL_PATH
		o (PropValue.dwMetaFlags & METADATA_ISINHERITED) != METADATA_ISINHERITED

Directly Generates:
	MUTIL_CHK_PROP_TYPE_BAD_TYPE
	MUTIL_CHK_PROP_TYPE_BAD_DATA

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDMachine	Open metabase handle for the machine key
	tszMachine	Name of the machine key

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckPropertyTypes(CComObject<CCheckErrorCollection> *pCErrorCol, 
									  METADATA_HANDLE hMDMachine, 
									  LPTSTR tszMachine)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszMachine);

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;
	UCHAR *lpDataBuf = NULL;
	PropValue *pPropType;

	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new UCHAR[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return E_OUTOFMEMORY;
	}

	// For Each Data Item
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDMachine, 
			                L"Schema/Properties/Types", 
						    &mdr, 
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Datatype must be BINARY_METADATA
		if (mdr.dwMDDataType != BINARY_METADATA) {
			AddError(pCErrorCol,
					 MUTIL_CHK_PROP_TYPE_BAD_TYPE,
					 MUTIL_CHK_PROP_TYPE_BAD_TYPE_S,
					 tszMachine,
					 _T("Schema/Properties/Types"),
					 mdr.dwMDIdentifier);
		}
		else { // mdr.dwMDDataType == BINARY_METADATA

			// Validate the data
			pPropType = reinterpret_cast<PropValue *> (lpDataBuf);

			if ((mdr.dwMDDataLen != sizeof(PropValue)) || 
				(pPropType->dwMetaID == 0) ||
				(pPropType->dwMetaType == ALL_METADATA) ||
				(pPropType->dwUserGroup == ALL_METADATA) ||
				((pPropType->dwMetaFlags & METADATA_PARTIAL_PATH) == METADATA_PARTIAL_PATH) ||
				((pPropType->dwMetaFlags & METADATA_ISINHERITED) == METADATA_ISINHERITED)) {
				AddError(pCErrorCol,
					 MUTIL_CHK_PROP_TYPE_BAD_DATA,
					 MUTIL_CHK_PROP_TYPE_BAD_DATA_S,
					 tszMachine,
					 _T("Schema/Properties/Types"),
					 mdr.dwMDIdentifier);
			}

		}

		// Next data item
		iDataIndex++;
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDMachine, 
								L"Schema/Properties/Types", 
							    &mdr, 
							    iDataIndex, 
							    &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	delete lpDataBuf;

	return S_OK;

LError:
	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckClasses

Private method to check the "Schema/Classes" key of a given machine.
	o Make sure that each class name is unique
	o Make sure that each class has a MANDATORY subkey
	o Make sure that each class has a OPTIONAL subkey
	o Make sure that each default property value is valid

Directly Generates:
	MUTIL_CHK_CLASS_NOT_CASE_UNIQUE
	MUTIL_CHK_CLASS_NO_MANDATORY
	MUTIL_CHK_CLASS_NO_OPTIONAL

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDMachine	Open metabase handle for the machine key
	tszMachine	Name of the machine key

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckClasses(CComObject<CCheckErrorCollection> *pCErrorCol, 
								METADATA_HANDLE hMDMachine, 
								LPTSTR tszMachine)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszMachine);

	USES_CONVERSION;
	HRESULT hr;
	int iKeyIndex;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	LPTSTR tszSubKey;
	CNameTable CClassNameTable;

	// For each Class key
	iKeyIndex = 0;
	hr = m_pIMeta->EnumKeys(hMDMachine, 
			                L"Schema/Classes", 
						    wszSubKey, 
						    iKeyIndex);
	while (SUCCEEDED(hr)) {
		tszSubKey = W2T(wszSubKey);

		// Build the full key
		TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];
		_tcscpy(tszFullKey, _T("/Schema/Classes/"));
		_tcscat(tszFullKey, tszSubKey);

		// Class name is unique
		if (CClassNameTable.IsCaseInsenDup(tszSubKey)) { 
			// Case sensitive unique
			AddError(pCErrorCol,
					 MUTIL_CHK_CLASS_NOT_CASE_UNIQUE,
					 MUTIL_CHK_CLASS_NOT_CASE_UNIQUE_S,
					 tszFullKey,
					 NULL,
					 0);
		}
		else { 
			// Unique
			hr = CClassNameTable.Add(tszSubKey);
			if (FAILED(hr)) {
				goto LError;
			}
		}

		// Open the class key
		METADATA_HANDLE hMDClass = NULL;

		hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(tszFullKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDClass);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}

		// Mandatory key exists
		if (!KeyExists(hMDClass, _T("Mandatory"))) {
			AddError(pCErrorCol,
					 MUTIL_CHK_CLASS_NO_MANDATORY,
					 MUTIL_CHK_CLASS_NO_MANDATORY_S,
					 tszFullKey,
					 NULL,
					 0);
		}
		else {
			// Make sure default mandatory settings make sense
			CheckClassProperties(pCErrorCol,
								 hMDClass,
								 tszFullKey,
								 _T("Mandatory"));
		}

		// Optional key exits
		if (!KeyExists(hMDClass, _T("Optional"))) {
			AddError(pCErrorCol,
					 MUTIL_CHK_CLASS_NO_OPTIONAL,
					 MUTIL_CHK_CLASS_NO_OPTIONAL_S,
					 tszFullKey,
					 NULL,
					 0);
		}
		else {
			// Make sure default optional settings make sense
			CheckClassProperties(pCErrorCol,
								 hMDClass,
								 tszFullKey,
								 _T("Optional"));
		}

		// Close the class key
		m_pIMeta->CloseKey(hMDClass);

		// Next key
		iKeyIndex++;
		hr = m_pIMeta->EnumKeys(hMDMachine, 
								L"Schema/Classes", 
								wszSubKey, 
								iKeyIndex);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	return S_OK;

LError:

	return ::ReportError(hr);
}

/*===================================================================
CMetaUtil::CheckClassProperties

Private method to check the properties under 
"Schema/Classes/_Class_/Madatory" and "Schema/Classes/_Class_/Optional".

	o Make sure that the class property type is compatible with the
	  type under "Schema/Properties/Types"
		o DataType must match
		o UserType must match
		o Attributes must be a superset of the type attributes

Directly Generates:
	MUTIL_CHK_CLASS_PROP_BAD_TYPE

Parameters:
	pCErrorCol		Pointer to the error collection to put errors in
	hMDClassKey		Open metabase handle for the "Schema/Classes/_Class_" key
	tszClassKey		Full path of the "Schema/Classes/_Class_" key
	tszClassSubKey	Name of the specific class sub-key ("Mandatory"
					or "Optional")

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckClassProperties(CComObject<CCheckErrorCollection> *pCErrorCol, 
										METADATA_HANDLE hMDClassKey, 
										LPTSTR tszClassKey, 
										LPTSTR tszClassSubKey)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszClassKey);
	ASSERT_STRING(tszClassSubKey);

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;
	BYTE *lpDataBuf = NULL;

	// Setup the return buffer
	dwDataBufLen = 1024;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// For each property
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDClassKey,
			                T2W(tszClassSubKey), 
						    &mdr,
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr) || (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {

		if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
			delete lpDataBuf;
			dwDataBufLen = dwReqDataLen;
			lpDataBuf = new BYTE[dwDataBufLen];
			if (lpDataBuf == NULL) {
				return ::ReportError(E_OUTOFMEMORY);
			}
		
		}
		else {
			// Get the property information
			CPropInfo *pCPropInfo;
			PropValue *pTypeInfo;

			// Get the property info from the Schema Table
			pCPropInfo = m_pCSchemaTable->GetPropInfo(tszClassKey, mdr.dwMDIdentifier);

			if ((pCPropInfo == NULL) ||
				(pCPropInfo->GetTypeInfo() == NULL)) {

				// Error: no property type information for class property
				AddError(pCErrorCol,
						 MUTIL_CHK_CLASS_PROP_NO_TYPE,
						 MUTIL_CHK_CLASS_PROP_NO_TYPE_S,
						 tszClassKey,
						 tszClassSubKey,
						 mdr.dwMDIdentifier);
			}
			else {
				pTypeInfo = pCPropInfo->GetTypeInfo();

				// Validate the property defaults :
				//		DataType must match
				//		UserType must match
				//		Attributes must be a superset of the type attributes
				if (mdr.dwMDDataType != pTypeInfo->dwMetaType) {
					AddError(pCErrorCol,
							 MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE,
							 MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE_S,
							 tszClassKey,
							 tszClassSubKey,
							 mdr.dwMDIdentifier);
				}
				if (mdr.dwMDUserType != pTypeInfo->dwUserGroup) {
					AddError(pCErrorCol,
							 MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE,
							 MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE_S,
							 tszClassKey,
							 tszClassSubKey,
							 mdr.dwMDIdentifier);
				}
				if ((mdr.dwMDAttributes & pTypeInfo->dwMetaFlags) != pTypeInfo->dwMetaFlags) {
					AddError(pCErrorCol,
							 MUTIL_CHK_CLASS_PROP_BAD_ATTR,
							 MUTIL_CHK_CLASS_PROP_BAD_ATTR_S,
							 tszClassKey,
							 tszClassSubKey,
							 mdr.dwMDIdentifier);
				}		
			}

			// Next property
			iDataIndex++;
		}
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDClassKey, 
								T2W(tszClassSubKey), 
								&mdr, 
								iDataIndex, 
								&dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		delete lpDataBuf;
		return ::ReportError(hr);
	}

	delete lpDataBuf;
	return S_OK;
}

/*===================================================================
CMetaUtil::CheckKey

Check a given key for errors.

Directly Generates:
	MUTIL_CHK_DATA_TOO_BIG
	MUTIL_CHK_NO_NAME_ENTRY
	MUTIL_CHK_NO_TYPE_ENTRY
	MUTIL_CHK_BAD_TYPE
	MUTIL_CHK_CLSID_NOT_FOUND
	MUTIL_CHK_MTX_PACK_ID_NOT_FOUND
	MUTIL_CHK_KEY_TOO_BIG
	
Parameters:
    bstrKey		[in] Key to check
	ppIReturn	[out, retval] interface for the output error collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if bstrKey == NULL or ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CheckKey(BSTR bstrKey, 
								 ICheckErrorCollection **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::CheckKey\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, ICheckErrorCollection *);

	if ((bstrKey == NULL) || (ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
	METADATA_HANDLE hMDKey = NULL;
	BYTE *lpDataBuf = NULL;
	DWORD dwKeySize = 0;

	_tcscpy(tszKey, OLE2T(bstrKey));
	CannonizeKey(tszKey);

	// Create the CheckErrorCollection
	CComObject<CCheckErrorCollection> *pCErrorCol = NULL;

	ATLTRY(pCErrorCol = new CComObject<CCheckErrorCollection>);
	if (pCErrorCol == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// If it's in the schema or IISAdmin, don't check
	if (::KeyIsInSchema(tszKey) || ::KeyIsInIISAdmin(tszKey)) {
		goto LDone;
	}

	// Open the key
	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(tszKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}


	// TODO: Hard coded checks for expected subkeys

	int iDataIndex;
	METADATA_RECORD mdrDataRec;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;

	//Setup the return buffer
	dwDataBufLen = 1024;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// For each property
	iDataIndex = 0;
	mdrDataRec.dwMDIdentifier = 0;
	mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrDataRec.dwMDUserType = ALL_METADATA;
	mdrDataRec.dwMDDataType = ALL_METADATA;
	mdrDataRec.dwMDDataLen = dwDataBufLen;
	mdrDataRec.pbMDData = (PBYTE) lpDataBuf;
	mdrDataRec.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDKey,
			                NULL, 
						    &mdrDataRec, 
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr) || (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
		if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
			delete lpDataBuf;
			dwDataBufLen = dwReqDataLen;
			lpDataBuf = new BYTE[dwDataBufLen];
			if (lpDataBuf == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			hr = S_OK; // Loop again
		}
		else {
			// Check property data size
			if (mdrDataRec.dwMDDataLen > m_dwMaxPropSize) {
				AddError(pCErrorCol,
						 MUTIL_CHK_DATA_TOO_BIG,
						 MUTIL_CHK_DATA_TOO_BIG_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
			}

			// Add to the key size
			dwKeySize += mdrDataRec.dwMDDataLen;
	
			CPropInfo *pCPropInfo;
			PropValue *pTypeInfo;

			pCPropInfo = m_pCSchemaTable->GetPropInfo(tszKey, mdrDataRec.dwMDIdentifier);

			// Property should have a name entry
			if ((pCPropInfo == NULL) || (pCPropInfo->GetName() == NULL)) {
				AddError(pCErrorCol,
						 MUTIL_CHK_NO_NAME_ENTRY,
						 MUTIL_CHK_NO_NAME_ENTRY_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
			}

			// Property should have a type entry
			if ((pCPropInfo == NULL) || (pCPropInfo->GetTypeInfo() == NULL)) {
				AddError(pCErrorCol,
						 MUTIL_CHK_NO_TYPE_ENTRY,
						 MUTIL_CHK_NO_TYPE_ENTRY_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
			}
			else { 
				// Check property type
				//		DataType must match
				//		UserType must match
				//		Attributes must be a superset of the type attributes
				pTypeInfo = pCPropInfo->GetTypeInfo();

				if (mdrDataRec.dwMDDataType != pTypeInfo->dwMetaType) {
					AddError(pCErrorCol,
						 MUTIL_CHK_BAD_DATA_TYPE,
						 MUTIL_CHK_BAD_DATA_TYPE_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
				if (mdrDataRec.dwMDUserType != pTypeInfo->dwUserGroup) {
					AddError(pCErrorCol,
						 MUTIL_CHK_BAD_USER_TYPE,
						 MUTIL_CHK_BAD_USER_TYPE_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
				if ((mdrDataRec.dwMDAttributes & pTypeInfo->dwMetaFlags) != pTypeInfo->dwMetaFlags) {
					AddError(pCErrorCol,
						 MUTIL_CHK_BAD_ATTR,
						 MUTIL_CHK_BAD_ATTR_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}
			
			// Hard coded property checks (hard coded logic)
			if ((mdrDataRec.dwMDIdentifier == MD_APP_WAM_CLSID) ||
				(mdrDataRec.dwMDIdentifier == MD_LOG_PLUGIN_ORDER)) {

				// If property is a CLSID 
				if (!CheckCLSID(W2T(reinterpret_cast<LPWSTR> (lpDataBuf)))) {
					AddError(pCErrorCol,
						 MUTIL_CHK_CLSID_NOT_FOUND,
						 MUTIL_CHK_CLSID_NOT_FOUND_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}
			else if (mdrDataRec.dwMDIdentifier == MD_APP_PACKAGE_ID) {

				// Property is a Transaction Server package
				if (!CheckMTXPackage(W2T(reinterpret_cast<LPWSTR> (lpDataBuf)))) {
					AddError(pCErrorCol,
						 MUTIL_CHK_MTX_PACK_ID_NOT_FOUND,
						 MUTIL_CHK_MTX_PACK_ID_NOT_FOUND_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}
			else if ((mdrDataRec.dwMDIdentifier == MD_VR_PATH) ||
					 (mdrDataRec.dwMDIdentifier == MD_FILTER_IMAGE_PATH))  {

				// Property is a path
				BOOL fResult;
				hr = CheckIfFileExists(W2T(reinterpret_cast<LPWSTR> (lpDataBuf)), &fResult);
				if (SUCCEEDED(hr) && !fResult) {
					AddError(pCErrorCol,
						 MUTIL_CHK_PATH_NOT_FOUND,
						 MUTIL_CHK_PATH_NOT_FOUND_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}

			// Next property
			iDataIndex++;
		}
		mdrDataRec.dwMDIdentifier = 0;
		mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrDataRec.dwMDUserType = ALL_METADATA;
		mdrDataRec.dwMDDataType = ALL_METADATA;
		mdrDataRec.dwMDDataLen = dwDataBufLen;
		mdrDataRec.pbMDData = (PBYTE) lpDataBuf;
		mdrDataRec.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDKey, 
								NULL, 
								&mdrDataRec, 
								iDataIndex, 
								&dwReqDataLen);
	}
	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Check total size of key
	if (dwKeySize > m_dwMaxKeySize) {
		AddError(pCErrorCol,
				 MUTIL_CHK_KEY_TOO_BIG,
				 MUTIL_CHK_KEY_TOO_BIG_S,
				 tszKey,
				 NULL,
				 0);
	}

	// Check the KeyType property against schema class information
	hr = CheckKeyType(pCErrorCol, hMDKey, tszKey);
	if (FAILED(hr)) {
		goto LError;
	}

	delete lpDataBuf;

	// Close the key
	m_pIMeta->CloseKey(hMDKey);

LDone:

	// Set the interface to ICheckErrorCollection
	hr = pCErrorCol->QueryInterface(IID_ICheckErrorCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;

LError:

	if (pCErrorCol != NULL) {
		delete pCErrorCol;
	}
	if (hMDKey != NULL) {
		m_pIMeta->CloseKey(hMDKey);
	}
	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::AddError

Add an error to a given error collection.  Uses the string table to
get the error description.

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	lId			Identifing constant of the type of error
	lSeverity	Severity of the error
	tszKey		Base part of the key where the error occurred
	tszSubKey	NULL or second part of the key where the error occured
	dwProperty	Id of the property where the error occured or 0

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if bstrMachine == NULL or ppIReturn == NULL
	S_OK on success

Notes:
	I split the key parameter into 2 parts, because of the nature of
	the metabase API's taking 2 part keys, often you are working
	with keys in 2 parts.  This takes the responsibility for combining
	them from the caller, simplifying the caller and eliminating
	redundancy.
===================================================================*/
void CMetaUtil::AddError(CComObject<CCheckErrorCollection> *pCErrorCol,
						 long lId, 
						 long lSeverity, 
						 LPCTSTR tszKey,
						 LPCTSTR tszSubKey,
						 DWORD dwProperty) 
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszKey);
	ASSERT_NULL_OR_STRING(tszSubKey);

	long lNumErrors;

	pCErrorCol->get_Count(&lNumErrors);
	if (((DWORD) lNumErrors) == m_dwMaxNumErrors) {
		lId = MUTIL_CHK_TOO_MANY_ERRORS;
		lSeverity = MUTIL_CHK_TOO_MANY_ERRORS_S;
		tszKey = _T("");
		tszSubKey = NULL;
		dwProperty = 0;
	}
	else if (((DWORD) lNumErrors) > m_dwMaxNumErrors) {
		// Too many errors, bail
		return;
	}

	// Get the description
	TCHAR tszDescription[1024];
	LoadString(_Module.GetResourceInstance(), IDS_CHK_BASE + lId, tszDescription, 1024);

	// Build the full key
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (tszSubKey == NULL) {
		_tcscpy(tszFullKey, tszKey);
	}
	else {
		_tcscpy(tszFullKey, tszKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, tszSubKey);
	}

	// Report the error
	pCErrorCol->AddError(lId, lSeverity, tszDescription, tszFullKey, dwProperty);
}

/*===================================================================
CMetaUtil::KeyExists

Private function to see if a given key exists.

Parameters:
    hMDKey		Open metabase read handle
	tszSubKey	Subkey to check relatetive to hMDKey

Returns:
	TRUE if the key exists.  A key is considered to exist if on
		an open call, it is opened or ERROR_PATH_BUSY or 
		ERROR_ACCESS_DENIED is returned.
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::KeyExists(METADATA_HANDLE hMDKey, LPTSTR tszSubKey) 
{
	ASSERT_NULL_OR_STRING(tszSubKey);

	//Attempt to open the key
	USES_CONVERSION;
	HRESULT hr;
	METADATA_HANDLE hMDSubKey;

	hr = m_pIMeta->OpenKey(hMDKey,
						   T2W(tszSubKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDSubKey);
	if (FAILED(hr)) {
		// Why?
		if ((HRESULT_CODE(hr) == ERROR_PATH_BUSY) ||
			(HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)) {
			// It exists, just can't get to it
			return TRUE;
		}
		else {
			// Assume that it doesn't exist
			return FALSE;
		}
	}
	else { // SUCCEEDED(hr)
		m_pIMeta->CloseKey(hMDSubKey);
		return TRUE;
	}
}

/*===================================================================
CMetaUtil::PropertyExists

Private function to see if a given property exists.

Parameters:
    hMDKey		Open metabase read handle
	tszSubKey	Subkey to check relatetive to hMDKey
	dwId		Id of the property to check

Returns:
	TRUE if the property exists.  A property is considered to exist if 
		on an GetData call, it is retrived or ERROR_INSUFFICENT_BUFFER 
		or ERROR_ACCESS_DENIED is returned.
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::PropertyExists(METADATA_HANDLE hMDKey, 
							   LPTSTR tszSubKey, 
							   DWORD dwId) 
{
	ASSERT_NULL_OR_STRING(tszSubKey);

	USES_CONVERSION;
	HRESULT hr;
	LPWSTR wszSubKey;
	METADATA_RECORD mdr;
	BYTE *lpDataBuf = NULL;
	DWORD dwDataBufLen;
	DWORD dwReqDataLen;

	if (tszSubKey == NULL) {
		wszSubKey = NULL;
	}
	else {
		wszSubKey = T2W(tszSubKey);
	}

	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return FALSE;
	}

	// See if there is a KeyType property  MD_KEY_TYPE
	mdr.dwMDIdentifier = dwId;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;

	hr = m_pIMeta->GetData(hMDKey, wszSubKey, &mdr, &dwReqDataLen);

	delete lpDataBuf;

	if (SUCCEEDED(hr) || 
		(HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) || 
		(HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

/*===================================================================
CMetaUtil::CheckCLSID

Private function to look up a CLSID in the local registry.

Parameters:
	tszCLSID	CLSID to check in string format.

Returns:
	TRUE if the CLSID is in the local registry
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::CheckCLSID(LPCTSTR tszCLSID) {
	ASSERT_STRING(tszCLSID);

	HKEY hCLSIDsKey;
	HKEY hCLSIDKey;
	LONG lRet;

	// Open HKEY_CLASSES_ROOT\CLSID
	lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT,
					   _T("CLSID"),
					   0,
					   KEY_READ,
					   &hCLSIDsKey);
	if (lRet != ERROR_SUCCESS) {
		return FALSE;
	}

	// Open the specific CLSID
	lRet = RegOpenKeyEx(hCLSIDsKey,
					   tszCLSID,
					   0,
					   KEY_READ,
					   &hCLSIDKey);
	if (lRet != ERROR_SUCCESS) {
		RegCloseKey(hCLSIDsKey);
		return FALSE;
	}

	// Close the keys
	RegCloseKey(hCLSIDsKey);
	RegCloseKey(hCLSIDKey);

	return TRUE;
}

/*===================================================================
CMetaUtil::CheckMTXPackage

Private function to look up a Microsoft Transaction Server package 
identifier (GUID) in the local registry.

Parameters:
	tszPackId	MTX package identifier (GUID) in string format

Returns:
	TRUE if the package id is in the local registry
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::CheckMTXPackage(LPCTSTR tszPackId) {
	ASSERT_STRING(tszPackId);

	HKEY hMTSPackKey;
	HKEY hPackIdKey;
	LONG lRet;

	// Open HKEY_LOCAL_MACHINE\Software\Microsoft\Transaction Server\Packages
	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					   _T("Software\\Microsoft\\Transaction Server\\Packages"),
					   0,
					   KEY_READ,
					   &hMTSPackKey);
	if (lRet != ERROR_SUCCESS) {
		return FALSE;
	}

	// Open the specific package id
	lRet = RegOpenKeyEx(hMTSPackKey,
					   tszPackId,
					   0,
					   KEY_READ,
					   &hPackIdKey);
	if (lRet != ERROR_SUCCESS) {
		RegCloseKey(hMTSPackKey);
		return FALSE;
	}

	// Close the keys
	RegCloseKey(hMTSPackKey);
	RegCloseKey(hPackIdKey);

	return TRUE;
}

/*===================================================================
CMetaUtil::CheckKeyType

Private method to check class information on a non-schema key via
the KeyType property.

Directly Generates:
	MUTIL_CHK_NO_KEYTYPE
	MUTIL_CHK_NO_KEYTYPE_NOT_FOUND

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDKey		Open metabase handle for the key to check
	tszKey		Full path of the key to check

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckKeyType(CComObject<CCheckErrorCollection> *pCErrorCol, 
								METADATA_HANDLE hMDKey, 
								LPTSTR tszKey) 
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;
	METADATA_RECORD mdr;
	BYTE *lpDataBuf = NULL;
	DWORD dwDataBufLen;
	DWORD dwReqDataLen;

	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// See if there is a KeyType property  MD_KEY_TYPE
	mdr.dwMDIdentifier = MD_KEY_TYPE;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;

	hr = m_pIMeta->GetData(hMDKey, NULL, &mdr, &dwReqDataLen);

	if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
		// Try a bigger buffer
		delete lpDataBuf;
		dwDataBufLen = dwReqDataLen;
		lpDataBuf = new BYTE[dwDataBufLen];
		if (lpDataBuf == NULL) {
			hr = E_OUTOFMEMORY;
			goto LError;
		}

		mdr.dwMDIdentifier = MD_KEY_TYPE;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;

		hr = m_pIMeta->GetData(hMDKey, NULL, &mdr, &dwReqDataLen);
	}

	if (hr == MD_ERROR_DATA_NOT_FOUND) {
		// Error: KeyType property not found
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_KEYTYPE,
				 MUTIL_CHK_NO_KEYTYPE_S,
				 tszKey,
				 NULL,
				 0);
		goto LDone;
	}
	else if (FAILED(hr)) {
		// Unexpected error
		goto LError;
	}
	else {  
		// KeyType property exists, get class information
		LPTSTR tszClassName;
		CClassInfo *pCClassInfo;
		
		tszClassName = W2T(reinterpret_cast<LPWSTR> (lpDataBuf));
		pCClassInfo = m_pCSchemaTable->GetClassInfo(tszKey, tszClassName);

		if (pCClassInfo == NULL) {
			// Error: KeyType does not map to a class
			AddError(pCErrorCol,
					 MUTIL_CHK_NO_KEYTYPE_NOT_FOUND,
					 MUTIL_CHK_NO_KEYTYPE_NOT_FOUND_S,
					 tszKey,
					 NULL,
					 MD_KEY_TYPE);
			goto LDone;
		}
		else { // KeyType maps to a class name
			// Check mandatory properties
			CClassPropInfo *pCMandatoryList;

			pCMandatoryList = m_pCSchemaTable->GetMandatoryClassPropList(tszKey, tszClassName);
			while (pCMandatoryList != NULL) {
				// Make sure the property exists
				if (!PropertyExists(hMDKey, NULL, pCMandatoryList->GetId())) {
					AddError(pCErrorCol,
							 MUTIL_CHK_MANDATORY_PROP_MISSING,
							 MUTIL_CHK_MANDATORY_PROP_MISSING_S,
							 tszKey,
							 NULL,
							 pCMandatoryList->GetId());
				}

				// Next mandatory list element
				pCMandatoryList = pCMandatoryList->GetListNext();
			}
		}
	}
	
LDone:

	delete lpDataBuf;

	return S_OK;

LError:
	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckIfFileExists

Private function to check if there is indeed a file or dir at the 
path indicated. 

Parameters:
tszFSPath   The filesystem path to check.
pfExists    Returns true if the file or dir at the path exists,
            false if it does not. Indeterminate in error cases.

Returns:
    S_OK on success.
    other HRESULTs from subroutines otherwise.
===================================================================*/
HRESULT CMetaUtil::CheckIfFileExists(LPCTSTR tszFSPath,
                                     BOOL *pfExists)
{
    ASSERT_STRING(tszFSPath);

    DWORD dwResult; 
    DWORD dwLastError;
    HRESULT hr = S_OK;

    dwResult = GetFileAttributes(tszFSPath);

    if (dwResult == 0xFFFFFFFF) {

        dwLastError = GetLastError();

        if ((dwLastError == ERROR_FILE_NOT_FOUND) || (dwLastError == ERROR_PATH_NOT_FOUND)) {

            // The file or dir doesn't exist
            *pfExists = FALSE;

        } else {

            // Some other error occurred (access denied, etc.)
            hr = HRESULT_FROM_WIN32(dwLastError);
            *pfExists = FALSE;      // Callers shouldn't be looking at this
        }
        
    } else {

        // The file or dir is there
        *pfExists = TRUE;
    }

    return hr;
}


/*------------------------------------------------------------------
 * C N a m e T a b l e E n t r y
 */


/*===================================================================
CNameTableEntry::Init

Constructor

Parameters:
    tszName		Name to add to the table

Returns:
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
HRESULT CNameTableEntry::Init(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	m_tszName = new TCHAR[_tcslen(tszName) + 1];
	if (m_tszName == NULL) {
		return E_OUTOFMEMORY;
	}
	_tcscpy(m_tszName, tszName);

	return S_OK;
}


/*------------------------------------------------------------------
 * C N a m e T a b l e
 */

/*===================================================================
CNameTable::CNameTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CNameTable::CNameTable() 
{
	// Clear the hash table
	memset(m_rgpNameTable, 0, NAME_TABLE_HASH_SIZE * sizeof(CNameTableEntry *));
}

/*===================================================================
CNameTable::~CNameTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CNameTable::~CNameTable()
{
	int iIndex;
	CNameTableEntry *pCDelete;

	// For each hash table entry
	for (iIndex =0; iIndex < NAME_TABLE_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgpNameTable[iIndex] != NULL) {
			// Nuke the first table entry
			ASSERT_POINTER(m_rgpNameTable[iIndex], CNameTableEntry);
			pCDelete = m_rgpNameTable[iIndex];
			m_rgpNameTable[iIndex] = pCDelete->m_pCHashNext;
			delete pCDelete;
		}
	}
}

/*===================================================================
CNameTable::IsCaseSenDup

Checks for a name table entry with the same case sensitive name.

Parameters:
	tszName		Name to check for a duplicate entry

Returns:
	TRUE if a duplicate entry is found
	FALSE otherwise
===================================================================*/
BOOL CNameTable::IsCaseSenDup(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	int iPos;
	CNameTableEntry *pCLoop;

	iPos = Hash(tszName);
	pCLoop = m_rgpNameTable[iPos];
	while (pCLoop != NULL) {
		ASSERT_POINTER(pCLoop, CNameTableEntry);
		ASSERT_STRING(pCLoop->m_tszName);
		if (_tcscmp(tszName, pCLoop->m_tszName) == 0) {
			return TRUE;
		}
		pCLoop = pCLoop->m_pCHashNext;
	}

	return FALSE;
}

/*===================================================================
CNameTable::IsCaseInsenDup

Checks for a name table entry with the same case insensitive name.

Parameters:
	tszName		Name to check for a duplicate entry

Returns:
	TRUE if a duplicate entry is found
	FALSE otherwise
===================================================================*/
BOOL CNameTable::IsCaseInsenDup(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	int iPos;
	CNameTableEntry *pCLoop;

	iPos = Hash(tszName);
	pCLoop = m_rgpNameTable[iPos];
	while (pCLoop != NULL) {
		ASSERT_POINTER(pCLoop, CNameTableEntry);
		ASSERT_STRING(pCLoop->m_tszName);
		if (_tcsicmp(tszName, pCLoop->m_tszName) == 0) {
			return TRUE;
		}
		pCLoop = pCLoop->m_pCHashNext;
	}

	return FALSE;
}

/*===================================================================
CNameTable::Add

Adds an entry to the name table

Parameters:
	tszName		Name to add to table

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CNameTable::Add(LPCTSTR tszName)
{
	ASSERT_STRING(tszName);

	// Create an entry
	HRESULT hr;
	CNameTableEntry *pCNew;

	pCNew = new CNameTableEntry;
	if (pCNew == NULL) {
		return E_OUTOFMEMORY;
	}
	hr = pCNew->Init(tszName);
	if (FAILED(hr)){
		delete pCNew;
		return hr;
	}

	// Add it to the table
	int iPos;

	iPos = Hash(tszName);
	pCNew->m_pCHashNext = m_rgpNameTable[iPos];
	m_rgpNameTable[iPos] = pCNew;

	return S_OK;
}

/*===================================================================
CNameTable::Hash

Private hash function for the name table.  The hash is case 
insensitive.

Parameters:
	tszName		Name to hash

Returns:
	Hash value for the input name.
===================================================================*/
int CNameTable::Hash(LPCTSTR tszName)
{
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		// Make CharUpper do single character conversions
		uiSum += _totlower(tszName[uiIndex]);
	}

	return (uiSum % NAME_TABLE_HASH_SIZE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\lib\beta2\admin.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    admin.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetAdminObject(
    OUT IMSAdminBase ** AdmCom
    )
{

    HRESULT result;
    IClassFactory * classFactory;

    //
    // Get the admin class factory.
    //

    result = CoGetClassObject(
                 GETAdminBaseCLSID(TRUE),
                 CLSCTX_SERVER,
                 NULL,
                 IID_IClassFactory,
                 (VOID **)&classFactory
                 );

    if( SUCCEEDED(result) ) {

        //
        // Create the admin object.
        //

        result = classFactory->CreateInstance(
                     NULL,
                     IID_IMSAdminBase,
                     (VOID **)AdmCom
                     );

        classFactory->Release();

    }

    return result;

}   // MdGetAdminObject

HRESULT
MdReleaseAdminObject(
    IN IMSAdminBase * AdmCom
    )
{

    HRESULT result;

    //
    // Terminate the admin object.
    //

    AdmCom->Release();

    return result;

}   // MdReleaseAdminObject


//
// Private functions.
//


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\mdtools\mddmp\mddmp.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mddmp.cxx

Abstract:

    Meta Data Dump Utility.

Author:

    Keith Moore (keithmo)        03-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api,hr,fatal)                                          \
            if( FAILED(hr) ) {                                              \
                                                                            \
                wprintf(                                                    \
                    L"%S:%lu failed, error %lx %S\n",                       \
                    (api),                                                  \
                    __LINE__,                                               \
                    (result),                                               \
                    (fatal)                                                 \
                        ? "ABORTING"                                        \
                        : "CONTINUING"                                      \
                    );                                                      \
                                                                            \
                if( fatal ) {                                               \
                                                                            \
                    goto cleanup;                                           \
                                                                            \
                }                                                           \
                                                                            \
            } else


//
// Private types.
//

typedef struct _ENUM_CONTEXT {

    LPWSTR Leaf;
    WCHAR Path[MAX_PATH];

} ENUM_CONTEXT, *PENUM_CONTEXT;


//
// Private globals.
//


//
// Private prototypes.
//

VOID
DumpTree(
    IMSAdminBase * AdmCom,
    PENUM_CONTEXT Context
    );

BOOL
WINAPI
EnumCallback(
    IMSAdminBase * AdmCom,
    LPWSTR ObjectName,
    VOID * Context
    );


//
// Public functions.
//


INT
__cdecl
wmain(
    INT argc,
    LPWSTR argv[]
    )
{

    HRESULT result;
    IMSAdminBase * admCom;
    ENUM_CONTEXT context;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    admCom = NULL;

    //
    // Initialize COM.
    //

    result = CoInitializeEx(
                 NULL,
                 COINIT_MULTITHREADED
                 );

    TEST_HRESULT( "CoInitializeEx()", result, TRUE );

    //
    // Get the admin object.
    //

    result = MdGetAdminObject( &admCom );

    TEST_HRESULT( "MdGetAdminObject()", result, TRUE );

    //
    // Dump the metabase tree.
    //

    wcscpy(
        context.Path,
        L"/"
        );

    DumpTree(
        admCom,
        &context
        );

cleanup:

    //
    // Release the admin object.
    //

    if( admCom != NULL ) {

        result = MdReleaseAdminObject( admCom );
        TEST_HRESULT( "MdReleaseAdminObject()", result, FALSE );

    }

    //
    // Shutdown COM.
    //

    CoUninitialize();
    return 0;

}   // main


//
// Private functions.
//

VOID
DumpTree(
    IMSAdminBase * AdmCom,
    PENUM_CONTEXT Context
    )
{

    HRESULT result;
    METADATA_GETALL_RECORD * data;
    METADATA_GETALL_RECORD * scan;
    DWORD numEntries;
    INT pathLen;
    LPWSTR leaf;

    result = MdGetAllMetaData(
                 AdmCom,
                 METADATA_MASTER_ROOT_HANDLE,
                 Context->Path,
                 0,
                 &data,
                 &numEntries
                 );

    if( FAILED(result) ) {

        wprintf(
            L"Cannot get metadata for %s, error %lx\n",
            Context->Path,
            result
            );

        return;

    }

    if( numEntries > 0 ) {
        wprintf( L"%s\n", Context->Path );
    }

    pathLen = wcslen( Context->Path );

    for( scan = data ; numEntries > 0 ; numEntries--, scan++ ) {

        wprintf( L"%*cIdentifier = %lu\n",   pathLen, ' ', scan->dwMDIdentifier );
        wprintf( L"%*cAttributes = %08lx\n", pathLen, ' ', scan->dwMDAttributes );
        wprintf( L"%*cUserType   = %lu\n",   pathLen, ' ', scan->dwMDUserType   );
        wprintf( L"%*cDataType   = %lu\n",   pathLen, ' ', scan->dwMDDataType   );
        wprintf( L"\n" );

    }

    MdFreeMetaDataBuffer( (VOID *)data );

    leaf = Context->Leaf;
    Context->Leaf = Context->Path + wcslen( Context->Path );

    result = MdEnumMetaObjects(
                 AdmCom,
                 Context->Path,
                 &EnumCallback,
                 (VOID *)Context
                 );

    Context->Leaf = leaf;

    if( FAILED(result) ) {

        wprintf(
            L"Cannot enumerate meta objects, error %lx\n",
            result
            );

        return;

    }

}   // DumpTree

BOOL
WINAPI
EnumCallback(
    IMSAdminBase * AdmCom,
    LPWSTR ObjectName,
    VOID * Context
    )
{

    PENUM_CONTEXT context;
    LPWSTR leaf;

    if( *ObjectName != '\0' ) {

        context = (PENUM_CONTEXT)Context;

        leaf = context->Leaf;
        if( leaf > ( context->Path + 1 ) ) {
            *leaf++ = L'/';
        }

        wcscpy(
            leaf,
            ObjectName
            );

        DumpTree(
            AdmCom,
            context
            );

    }

    return TRUE;

}   // EnumCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\chkerror.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkError.cpp

Owner: t-BrianM

This file contains implementation of the check error collection for
CheckSchema and CheckKey.

Notes:
	I implemented the error stuff as a linked list of COM CheckError
	objects.  It is assumed that the error collection will be 
	created, all elements added to it, then used.  No changes after
	creation!  Because of the static nature of the list, the links
	are physicaly located in the CheckError objects, no node wrapping
	needed.  This design cuts down on the copying and redundancy.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "ChkError.h"

/*------------------------------------------------------------------
 * C C h e c k E r r o r C o l l e c t i o n
 */

/*===================================================================
CCheckErrorCollection::CCheckErrorCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorCollection::CCheckErrorCollection() : m_iNumErrors(0),
												 m_pCErrorList(NULL),
												 m_pCErrorListEnd(NULL)
{
}

/*===================================================================
CCheckErrorCollection::~CCheckErrorCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorCollection::~CCheckErrorCollection() 
{
	// Release all of the elements
	CComObject<CCheckError> *pCLoop;
	CComObject<CCheckError> *pCRelease;

	pCLoop = m_pCErrorList;
	while (pCLoop != NULL) {
		pCRelease = pCLoop;
		pCLoop = pCLoop->GetNextError();
		pCRelease->Release();
	}
}

/*===================================================================
CCheckErrorCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CCheckErrorCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ICheckErrorCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CCheckErrorCollection::get_Count

Get method for Count property.  Counts the number of errors in the
collection.

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorCollection::get_Count(long *plReturn) 
{
	TRACE0("MetaUtil: CCheckErrorCollection::get_Count\n");
	ASSERT_NULL_OR_POINTER(plReturn, long);

	if (plReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plReturn = m_iNumErrors;

	return S_OK;
}

/*===================================================================
CCheckErrorCollection::get_Item

Get method for Item property.  Returns a CheckError given its index.

Parameters:
	varId		[in] 1 based index or Name of the CheckError to get
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL or lIndex <= 0
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorCollection::get_Item(long lIndex, 
											 LPDISPATCH * ppIReturn) 
{
	TRACE0("MetaUtil: CCheckErrorCollection::get_Item\n");
	ASSERT_NULL_OR_POINTER(ppIReturn, LPDISPATCH);

	if ((lIndex <= 0) || (ppIReturn == NULL)) {
		// 0 or less, too small  OR  ppIReturn == NULL
		return ::ReportError(E_INVALIDARG);
	}
	else if (lIndex >= m_iNumErrors) {
		// Too large
		return ::ReportError(ERROR_NO_MORE_ITEMS);
	}
	else {
		// Get the requested error
		HRESULT hr;
		CComObject<CCheckError> *pCLoop;

		pCLoop = m_pCErrorList;
		while ((lIndex > 1) && (pCLoop != NULL)) {
			lIndex--;
			pCLoop = pCLoop->GetNextError();
		}

		// Set the interface to IDispatch
		hr = pCLoop->QueryInterface(IID_IDispatch, (void **) ppIReturn);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}
		ASSERT(*ppIReturn != NULL);

		return S_OK;
	}
}

/*===================================================================
CCheckErrorCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the CheckErrors.

Parameters:
	ppIReturn	[out, retval] Interface for the enumeration object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorCollection::get__NewEnum(LPUNKNOWN *ppIReturn) 
{
	TRACE0("MetaUtil: CCheckErrorCollection::get__NewEnum\n");
	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the check error enumeration
	CComObject<CCheckErrorEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CCheckErrorEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pCErrorList);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CCheckErrorCollection::AddError(

Adds an error to the error collection.

Parameters:
	lId				Identifier for this error
	lSeverity		Severity of the error
	tszDescription	Description of error for users
	tszKey			Key where error occurred
	lProperty		Property where error occurred

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success

Notes:
	It is assumed that the CheckError collection will be created 
	then all of the errors will be added before the collection is 
	sent to the client.  Similar to Init(), however it could be
	called multiple times.
===================================================================*/
HRESULT CCheckErrorCollection::AddError(long lId, 
										long lSeverity, 
										LPCTSTR tszDescription, 
										LPCTSTR tszKey, 
										long lProperty) 
{
	ASSERT(lId > 0);
	ASSERT(lSeverity > 0);
	ASSERT_STRING(tszDescription);
	ASSERT_STRING(tszKey);
	ASSERT(lProperty >= 0);

	HRESULT hr;

	// Create the new element
	CComObject<CCheckError> *pNewError = NULL;
	ATLTRY(pNewError = new CComObject<CCheckError>);
	if (pNewError == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pNewError->Init(lId, lSeverity, tszDescription, tszKey, lProperty);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// AddRef it
	pNewError->AddRef();

	// Add it to the end of the list
	if (m_pCErrorList == NULL) {
		m_pCErrorList = pNewError;
		m_pCErrorListEnd = pNewError;
	}
	else {
		m_pCErrorListEnd->SetNextError(pNewError);
		m_pCErrorListEnd = pNewError;
	}

	// Count it
	m_iNumErrors++;

	return S_OK;
}


/*------------------------------------------------------------------
 * C C h e c k E r r o r E n u m
 */

/*===================================================================
CCheckErrorEnum::CCheckErrorEnum()

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorEnum::CCheckErrorEnum() : m_pCErrorList(NULL),
									 m_pCErrorListPos(NULL)
{
}

/*===================================================================
CCheckErrorEnum::Init

Constructor

Parameters:
	pCErrorList		Pointer to first element in list to enumerate.

Returns:
	S_OK on success
===================================================================*/
HRESULT CCheckErrorEnum::Init(CComObject<CCheckError> *pCErrorList) 
{
	ASSERT_NULL_OR_POINTER(pCErrorList, CComObject<CCheckError>);

	// Set list head and current position
	m_pCErrorList = pCErrorList;
	m_pCErrorListPos = pCErrorList;

	// AddRef all of the elements
	CComObject<CCheckError> *pCLoop;

	pCLoop = m_pCErrorList;
	while (pCLoop != NULL) {
		pCLoop->AddRef();
		pCLoop = pCLoop->GetNextError();
	}

	return S_OK; 
}

/*===================================================================
CCheckErrorEnum::~CCheckErrorEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorEnum::~CCheckErrorEnum() 
{
	// Release all of the elements
	CComObject<CCheckError> *pCLoop;
	CComObject<CCheckError> *pCRelease;

	pCLoop = m_pCErrorList;
	while (pCLoop != NULL) {
		pCRelease = pCLoop;
		pCLoop = pCLoop->GetNextError();
		pCRelease->Release();
	}
}

/*===================================================================
CCheckErrorEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
	E_INVALIDARG if rgvarDest == NULL
	S_FALSE if outputs less than ulNumToGet items
	S_OK if outputs ulNumToGet items
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Next(unsigned long ulNumToGet, 
								   VARIANT FAR* rgvarDest, 
								   unsigned long FAR* pulNumGot) 
{ 
	TRACE0("MetaUtil: CCheckErrorEnum::Next\n");
	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (pulNumGot != NULL) {
		pulNumGot = 0;
	}

	if (rgvarDest == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;
	unsigned int uiDestIndex;
	IDispatch *pIDispatch;

	// While we have more to get and have more left
	uiDestIndex = 0;
	while ((uiDestIndex < ulNumToGet) && (m_pCErrorListPos != NULL)) {
		// Set the interface to IDispatch
		hr = m_pCErrorListPos->QueryInterface(IID_IDispatch, (void **) &pIDispatch);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}
		ASSERT(pIDispatch != NULL);

		// Put it in the output array
		VariantInit(&(rgvarDest[uiDestIndex]));
		rgvarDest[uiDestIndex].vt = VT_DISPATCH;
		rgvarDest[uiDestIndex].pdispVal = pIDispatch;

		// Next element
		m_pCErrorListPos = m_pCErrorListPos->GetNextError();
		uiDestIndex++;
	}

	// If pulNumGot isn't NULL, set it
	if (pulNumGot != NULL) {
		*pulNumGot = uiDestIndex;
	}

	if (uiDestIndex == ulNumToGet) {
		// Returned the requested number of elements
		TRACE0("MetaUtil: CCheckErrorEnum::Next Ok\n");
		return S_OK;
	}
	else {
		// Returned less than the requested number of elements
		TRACE0("MetaUtil: CCheckErrorEnum::Next False\n");
		return S_FALSE;
	}
}

/*===================================================================
CCheckErrorEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Skip(unsigned long ulNumToSkip) 
{ 
	TRACE0("MetaUtil: CCheckErrorEnum::Skip\n");

	unsigned long ulIndex;

	ulIndex = ulNumToSkip;
	while ((ulIndex != 0) && (m_pCErrorListPos != NULL)) {
		m_pCErrorListPos = m_pCErrorListPos->GetNextError();
		ulIndex--;
	}

	return S_OK; 
}

/*===================================================================
CCheckErrorEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Reset() 
{
	TRACE0("MetaUtil: CCheckErrorEnum::Reset\n");

	// Set our position back to the first element
	m_pCErrorListPos = m_pCErrorList;

	return S_OK;
}

/*===================================================================
CCheckErrorEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if not enough memory to create clone
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn) 
{
	TRACE0("MetaUtil: CCheckErrorEnum::Clone\n");
	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CCheckErrorEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CCheckErrorEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pCErrorList);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK; 
}


/*------------------------------------------------------------------
 * C C h e c k E r r o r
 */

/*===================================================================
CCheckError::CCheckError

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckError::CCheckError() : m_lId(0),
							 m_lSeverity(0),
							 m_tszDescription(NULL),
							 m_tszKey(NULL),
							 m_lProperty(0),
							 m_pNextError(NULL)
{
}

/*===================================================================
CCheckError::Init

Constructor

Parameters:
	lId				Identifier for this error
	lSeverity		Severity of the error
	tszDescription	Description of error for users
	tszKey			Key where error occurred
	lProperty		Property where error occurred

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CCheckError::Init(long lId,
						  long lSeverity,
						  LPCTSTR tszDescription,
						  LPCTSTR tszKey,
						  long lProperty) 
{
	ASSERT(lId > 0);
	ASSERT(lSeverity > 0);
	ASSERT_STRING(tszDescription);
	ASSERT_STRING(tszKey);
	ASSERT(lProperty >= 0);

	m_lId = lId;
	m_lSeverity = lSeverity;

	// Copy tszDescription to m_tszDescription
	m_tszDescription = new TCHAR[_tcslen(tszDescription) + 1];
		if (m_tszDescription == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
	_tcscpy(m_tszDescription, tszDescription);

	// Copy tszKey to m_tszKey
	m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
	_tcscpy(m_tszKey, tszKey);

	m_lProperty = lProperty;

	return S_OK; 
}

/*===================================================================
CCheckError::~CCheckError

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckError::~CCheckError() 
{
	if (m_tszDescription != NULL) {
		delete m_tszDescription;
	}
	if (m_tszKey != NULL) {
		delete m_tszKey;
	}
}

/*===================================================================
CCheckError::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CCheckError::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ICheckError,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CCheckError::get_Id

Get method for Id property.  Gets the Id for this error, so it can
be easily processed by recovery logic.

Parameters:
	plId	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plId == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Id(long *plId)
{
	TRACE0("MetaUtil: CCheckError::get_Id\n");
	ASSERT_NULL_OR_POINTER(plId, long);

	if (plId == NULL) {
		return E_INVALIDARG;
	}

	*plId = m_lId;

	return S_OK;
}

/*===================================================================
CCheckError::get_Severity

Get method for Severity property.  Gets the severity for this error, 
so it can be filtered.

Parameters:
	plSeverity	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plSeverity == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Severity(long *plSeverity)
{
	TRACE0("MetaUtil: CCheckError::get_Severity\n");
	ASSERT_NULL_OR_POINTER(plSeverity, long);

	if (plSeverity == NULL) {
		return E_INVALIDARG;
	}

	*plSeverity = m_lSeverity;

	return S_OK;
}

/*===================================================================
CCheckError::get_Description

Get method for Description property.  Gets the description for this 
error, so users can understand it.

Parameters:
	pbstrDescription	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pbstrDescription == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Description(BSTR *pbstrDescription)
{
	TRACE0("MetaUtil: CCheckError::get_Description\n");
	ASSERT_NULL_OR_POINTER(pbstrDescription, BSTR);

	if (pbstrDescription == NULL) {
		return E_INVALIDARG;
	}

	USES_CONVERSION;

	*pbstrDescription = T2BSTR(m_tszDescription);

	return S_OK;
}

/*===================================================================
CCheckError::get_Key

Get method for Key property.  Gets the key where the error occurred.

Parameters:
	pbstrKey	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pbstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Key(BSTR * pbstrKey)
{
	TRACE0("MetaUtil: CCheckError::get_Key\n");
	ASSERT_NULL_OR_POINTER(pbstrKey, BSTR);

	if (pbstrKey == NULL) {
		return E_INVALIDARG;
	}

	USES_CONVERSION;

	*pbstrKey = T2BSTR(m_tszKey);

	return S_OK;
}

/*===================================================================
CCheckError::get_Property

Get method for Property property.  Gets the property where the error 
occurred.

Parameters:
	pbstrProperty	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pbstrProperty == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Property(long * plProperty)
{
	TRACE0("MetaUtil: CCheckError::get_Property\n");
	ASSERT_NULL_OR_POINTER(plProperty, long);

	if (plProperty == NULL) {
		return E_INVALIDARG;
	}

	*plProperty = m_lProperty;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\chkerror.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkError.h

Owner: t-BrianM

This file contains the headers for the CheckError collection.
===================================================================*/

#if !defined(AFX_CHKERROR_H__A4FA4E13_EF45_11D0_9E65_00C04FB94FEF__INCLUDED_)
#define AFX_CHKERROR_H__A4FA4E13_EF45_11D0_9E65_00C04FB94FEF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

class CCheckError;

/*
 * C C h e c k E r r o r C o l l e c t i o n
 *
 * Implements the error collection for CheckSchema and CheckKey
 */

class CCheckErrorCollection : 
	public IDispatchImpl<ICheckErrorCollection, &IID_ICheckErrorCollection, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CCheckErrorCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ICheckErrorCollection)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CCheckErrorCollection) 

	CCheckErrorCollection();
	~CCheckErrorCollection();

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICheckErrorCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ LPDISPATCH * ppIReturn);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);

// No Interface
	HRESULT AddError(long lId, long lSeverity, LPCTSTR tszDescription, LPCTSTR tszKey, long lProperty);

private:
	int m_iNumErrors;

	CComObject<CCheckError> *m_pCErrorList;
	CComObject<CCheckError> *m_pCErrorListEnd;
};


/*
 * C C h e c k E r r o r E n u m
 *
 * Implements error enumeration for CheckSchema and CheckKey
 */

class CCheckErrorEnum : 
	public IEnumVARIANT,
	public CComObjectRoot
{
public:
	CCheckErrorEnum();
	HRESULT Init(CComObject<CCheckError> *pCErrorList);
	~CCheckErrorEnum();

BEGIN_COM_MAP(CCheckErrorEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CCheckErrorEnum) 

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppIReturn);

private:
	CComObject<CCheckError> *m_pCErrorList;
	CComObject<CCheckError> *m_pCErrorListPos;
};


/*
 * C C h e c k E r r o r
 *
 * Implements CheckError objects for CheckSchema and CheckKey
 */

class CCheckError : 
	public IDispatchImpl<ICheckError, &IID_ICheckError, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CCheckError();
	HRESULT Init(long lId, long lSeverity, LPCTSTR tszDescription, LPCTSTR tszKey, long lProperty);
	~CCheckError();

BEGIN_COM_MAP(CCheckError)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ICheckError)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CCheckError) 

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICheckError
	STDMETHOD(get_Id)(/*[out, retval]*/ long *plId);
	STDMETHOD(get_Severity)(/*[out, retval]*/ long *plSeverity);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pbstrDescription);
	STDMETHOD(get_Key)(/*[out, retval]*/ BSTR *pbstrKey);
	STDMETHOD(get_Property)(/*[out, retval]*/ long *plProperty);

// No Interface
	CComObject<CCheckError> *GetNextError() {
		ASSERT_NULL_OR_POINTER(m_pNextError, CComObject<CCheckError>);
		return m_pNextError;
	}
	void SetNextError(CComObject<CCheckError> *pNextError) { 
		ASSERT_NULL_OR_POINTER(pNextError, CComObject<CCheckError>);
		m_pNextError = pNextError; 
	}

private:
	long m_lId;
	long m_lSeverity;
	LPTSTR m_tszDescription;
	LPTSTR m_tszKey;
	long m_lProperty;

	CComObject<CCheckError> *m_pNextError;
};
#endif // !defined(AFX_CHKERROR_H__A4FA4E13_EF45_11D0_9E65_00C04FB94FEF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\metautil.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MetaUtil.cpp

Owner: t-BrianM

This file contains the DLL interface.  Generated by the ATL wizard.
I just added the debugging stuff.
===================================================================*/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "MetaUtil.h"

#include "MetaUtil_i.c"
#include "MUtilObj.h"
#include "propcol.h"
#include "ChkError.h"
#include "MetaSchm.h"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MetaUtil, CMetaUtil)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
		IRTL_DEBUG_INIT();
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		IRTL_DEBUG_TERM();
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\keycol.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: KeyCol.h

Owner: t-BrianM

This file contains the headers for the key collections.
===================================================================*/

#ifndef __KEYCOL_H_
#define __KEYCOL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

/*
 * C F l a t K e y C o l l e c t i o n
 *
 * Implements non-recursive subkey collections.
 */

class CFlatKeyCollection : 
	public IDispatchImpl<IKeyCollection, &IID_IKeyCollection, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CFlatKeyCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IKeyCollection)	
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CFlatKeyCollection)

	CFlatKeyCollection();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey);
	~CFlatKeyCollection();

// IKeyCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ BSTR *pbstrRetKey);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);
	STDMETHOD(Add)(/*[in]*/ BSTR bstrRelKey);
	STDMETHOD(Remove)(/*[in]*/ BSTR bstrRelKey);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

private:
	LPTSTR m_tszBaseKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;
};


/*
 * C F l a t K e y E n u m
 *
 * Implements non-recursive subkey enumerations.
 */

class CFlatKeyEnum :
	public IEnumVARIANT,
	public CComObjectRoot
{

public:
	CFlatKeyEnum();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey, int iIndex);
	~CFlatKeyEnum();

BEGIN_COM_MAP(CFlatKeyEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CFlatKeyEnum)  

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppIReturn);


private:
	int m_iIndex;
	LPTSTR m_tszBaseKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;
};

/*
 * C K e y S t a c k
 *
 * C K e y S t a c k N o d e
 *
 * Internal classes used to maintain and clone the state for a
 * deep key enumberation.
 */
class CKeyStack;

class CKeyStackNode {

	friend CKeyStack;

public:
	CKeyStackNode() { m_tszRelKey = NULL; m_iIndex = 0; m_pCNext = NULL; }
	HRESULT Init(LPCTSTR tszRelKey, int iIndex);
	~CKeyStackNode();

	int GetIndex() { return m_iIndex; }
	void SetIndex(int iIndex) { ASSERT(iIndex >= 0); m_iIndex = iIndex; }

	LPTSTR GetBaseKey() { return m_tszRelKey; }

	CKeyStackNode *Clone();

private:
	LPTSTR m_tszRelKey;
	int m_iIndex;

	CKeyStackNode *m_pCNext;
};

class CKeyStack {
public:
	CKeyStack() { m_pCTop = NULL; }
	~CKeyStack();

	void Push(CKeyStackNode *pCNew);
	CKeyStackNode *Pop();

	BOOL IsEmpty() { return (m_pCTop == NULL); }

	CKeyStack *Clone();

private:
	CKeyStackNode *m_pCTop;

};


/*
 * C D e e p K e y C o l l e c t i o n
 *
 * Implements recursive (depth first) subkey collections.
 */

class CDeepKeyCollection : 
	public IDispatchImpl<IKeyCollection, &IID_IKeyCollection, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CDeepKeyCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IKeyCollection)	
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDeepKeyCollection)

	CDeepKeyCollection();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey);
	~CDeepKeyCollection();

// IKeyCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ BSTR *pbstrRetKey);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);
	STDMETHOD(Add)(/*[in]*/ BSTR bstrRelKey);
	STDMETHOD(Remove)(/*[in]*/ BSTR bstrRelKey);
	
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

private:
	LPTSTR m_tszBaseKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	HRESULT CountKeys(LPTSTR tszBaseKey, long *plNumKeys);
	HRESULT IndexItem(LPTSTR tszRelKey, long lDestIndex, long *plCurIndex, LPTSTR ptszRet);
};


/*
 * C D e e p K e y E n u m
 *
 * Implements recursive (depth first) subkey enumerations.
 */

class CDeepKeyEnum :
	public IEnumVARIANT,
	public CComObjectRoot
{

public:
	CDeepKeyEnum();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey, CKeyStack *pCKeyStack);
	~CDeepKeyEnum();

BEGIN_COM_MAP(CDeepKeyEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDeepKeyEnum)  

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum);


private:
	LPTSTR m_tszBaseKey;
	CKeyStack *m_pCKeyStack;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;
};

#endif //__KEYCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\metaschm.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MetaSchm.h

Owner: t-BrianM

This file contains the headers for the CMetaSchemaTable object and
other schema related objects.
===================================================================*/

#ifndef __METASCHM_H_
#define __METASCHM_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

// Ripped from schemini.hxx
struct PropValue {
	DWORD dwMetaID;
	DWORD dwSynID;
	DWORD dwMetaType;
	DWORD dwFlags;
	DWORD dwMask;
	DWORD dwMetaFlags;
	DWORD dwUserGroup;
	BOOL fMultiValued;
};

// All hash table sizes are prime numbers between powers of 2
// and are ~10x larger than the expected number of items.
#define SCHEMA_HASH_SIZE          181
#define PROPERTY_HASH_SIZE       1559
#define CLASS_HASH_SIZE           181
#define CLASS_PROPERTY_HASH_SIZE  709

/*
 * C P r o p I n f o
 *
 * C P r o p I n f o T a b l e
 *
 * Internal classes used to store and represent property information
 */

class CPropInfoTable;

class CPropInfo {

	friend CPropInfoTable;

public:
    CPropInfo() : m_dwId(0), 
				  m_tszName(NULL), 
				  m_pType(NULL),
				  m_pCIdHashNext(NULL),
				  m_pCNameHashNext(NULL) { }
	HRESULT Init(DWORD dwId);
	HRESULT SetName(LPCTSTR tszName);
	HRESULT SetTypeInfo(PropValue *pType);
	~CPropInfo() { 
		if (m_tszName != NULL) delete m_tszName; 
		if (m_pType != NULL) delete m_pType;
	}

	DWORD GetId() { return m_dwId; }
	LPCTSTR GetName()  { return m_tszName; }
	PropValue *GetTypeInfo() { return m_pType; }

private:
	DWORD m_dwId;
	LPTSTR m_tszName;
	PropValue *m_pType;

	CPropInfo *m_pCNameHashNext;
	CPropInfo *m_pCIdHashNext;

};

class CPropInfoTable {
public:
	CPropInfoTable();
	~CPropInfoTable();

	HRESULT Load(CComPtr<IMSAdminBase> &pIMeta, METADATA_HANDLE hMDComp);
	void Unload();

	CPropInfo *GetPropInfo(DWORD dwId);
	CPropInfo *GetPropInfo(LPCTSTR tszName);

private:
	BOOL m_fLoaded;
	CPropInfo *m_rgCPropIdTable[PROPERTY_HASH_SIZE];
	CPropInfo *m_rgCPropNameTable[PROPERTY_HASH_SIZE];


	unsigned int IdHash(DWORD dwId) { return dwId % PROPERTY_HASH_SIZE; }
	unsigned int NameHash(LPCTSTR tszName);
};


/*
 * C C l a s s P r o p I n f o
 *
 * C C l a s s I n f o
 *
 * C C l a s s I n f o T a b l e
 *
 * Internal classes used to store and represent class information
 */

class CClassInfoTable;
class CClassInfo;

class CClassPropInfo {

	friend CClassInfo;

public:
	CClassPropInfo() : m_dwId(0),
					   m_fMandatory(FALSE),
					   m_pCHashNext(NULL),
					   m_pCListNext(NULL) {}
	HRESULT Init(DWORD dwId, BOOL fMandatory) {
		m_dwId = dwId;
		m_fMandatory = fMandatory;
		return S_OK;
	}

	DWORD GetId() { return m_dwId; }
	BOOL IsMandatory() { return m_fMandatory; }
	CClassPropInfo *GetListNext() { return m_pCListNext; }

private:
	DWORD m_dwId;
	BOOL m_fMandatory;
	// Property default information could also be added...

	CClassPropInfo *m_pCHashNext;
	CClassPropInfo *m_pCListNext;
};

class CClassInfo {

	friend CClassInfoTable;

public:
	CClassInfo();
	HRESULT Init(LPCTSTR tszName);
	~CClassInfo();

	HRESULT Load(CComPtr<IMSAdminBase> &pIMeta, METADATA_HANDLE hMDClasses);
	void Unload();

	CClassPropInfo *GetProperty(DWORD dwId);
	CClassPropInfo *GetOptionalPropList() { return m_pCOptionalPropList; }
	CClassPropInfo *GetMandatoryPropList() { return m_pCMandatoryPropList; }

private:
	LPTSTR m_tszName;
	CClassInfo *m_pCHashNext;

	BOOL m_fLoaded;
	CClassPropInfo *m_rgCPropTable[CLASS_PROPERTY_HASH_SIZE];
	CClassPropInfo *m_pCOptionalPropList;
	CClassPropInfo *m_pCMandatoryPropList;

	unsigned int Hash(DWORD dwId) { return dwId % CLASS_PROPERTY_HASH_SIZE; }
};

class CClassInfoTable {
public:
	CClassInfoTable();
	~CClassInfoTable();

	HRESULT Load(CComPtr<IMSAdminBase> &pIMeta, METADATA_HANDLE hMDComp);
	void Unload();

	CClassInfo *GetClassInfo(LPCTSTR tszName);

private:
	BOOL m_fLoaded;
	CClassInfo *m_rgCClassTable[CLASS_HASH_SIZE];

	unsigned int Hash(LPCTSTR tszName);
};


/*
 * C M e t a S c h e m a
 *
 * Internal class used to store schema information for a machine
 */

class CMetaSchemaTable;

class CMetaSchema {

	friend CMetaSchemaTable;

public:
	CMetaSchema() : m_fPropTableDirty(TRUE), 
		            m_fClassTableDirty(TRUE),
		            m_tszMachineName(NULL),
					m_pCNextSchema(NULL) { }
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszMachineName);
	~CMetaSchema() { if (m_tszMachineName != NULL) delete m_tszMachineName; }

	CPropInfo *GetPropInfo(DWORD dwId);
	CPropInfo *GetPropInfo(LPCTSTR tszName);

	CClassInfo *GetClassInfo(LPCTSTR tszClassName);
	CClassPropInfo *GetClassPropInfo(LPCTSTR tszClassName, DWORD dwPropId);
	CClassPropInfo *GetMandatoryClassPropList(LPCTSTR tszClassName);
	CClassPropInfo *GetOptionalClassPropList(LPCTSTR tszClassName);
	void ChangeNotification(LPTSTR tszKey, MD_CHANGE_OBJECT *pcoChangeObject);


private:
	LPTSTR m_tszMachineName;

	BOOL m_fPropTableDirty;
	BOOL m_fClassTableDirty;

	CPropInfoTable m_CPropInfoTable;
	CClassInfoTable m_CClassInfoTable;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchema *m_pCNextSchema;

	HRESULT LoadPropTable();
	HRESULT LoadClassTable();
};


/*
 * C M e t a S c h e m a T a b l e
 *
 * Implements IMetaSchemaTable.  Stores all of the schema information
 * for all of the machines.  I made it global so it can persist after 
 * CMetaUtil is destructed.
 */
class CMSAdminBaseSink;

class CMetaSchemaTable {
public:
	CMetaSchemaTable();
	~CMetaSchemaTable();

	DWORD AddRef() { return ++m_dwNumRef; }
	DWORD Release() { 
		m_dwNumRef--; 
		if (!m_dwNumRef) {
			delete this;
            return 0;
        }
		return m_dwNumRef;
	}

	void Load();
	void Unload();

	CPropInfo *GetPropInfo(LPCTSTR tszKey, DWORD dwPropId);
	CPropInfo *GetPropInfo(LPCTSTR tszKey, LPCTSTR tszPropName);

	CClassInfo *GetClassInfo(LPCTSTR tszKey, LPCTSTR tszClassName);
	CClassPropInfo *GetClassPropInfo(LPCTSTR tszKey, LPCTSTR tszClassName, DWORD dwPropId);
	CClassPropInfo *GetMandatoryClassPropList(LPCTSTR tszKey, LPCTSTR tszClassName);
	CClassPropInfo *GetOptionalClassPropList(LPCTSTR tszKey, LPCTSTR tszClassName);

	// Event sink callback
	HRESULT SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT pcoChangeObject[]);


private:
	DWORD m_dwNumRef;
	BOOL m_fLoaded;
	CMetaSchema *m_rgCSchemaTable[SCHEMA_HASH_SIZE];
	CComObject<CMSAdminBaseSink> *m_CMSAdminBaseSink;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchema *GetSchema(LPCTSTR tszKey);
	unsigned int Hash(LPCTSTR tszName);
};


/*
 * C M S A d m i n B a s e S i n k
 *
 * Minimal ATL COM object that catches change notification events from the
 * metabase object and passes them on to the CMetaSchemaTable object.
 */

class CMSAdminBaseSink :
	public IMSAdminBaseSink,
	public CComObjectRoot
{
public:
	CMSAdminBaseSink();
	~CMSAdminBaseSink();

BEGIN_COM_MAP(CMSAdminBaseSink)
	COM_INTERFACE_ENTRY(IMSAdminBaseSink)
END_COM_MAP()
// DECLARE_NOT_AGGREGATABLE(CMSAdminBaseSink)

// IMSAdminBaseSink
	STDMETHOD(SinkNotify)(DWORD dwMDNumElements, MD_CHANGE_OBJECT pcoChangeObject[]);
	STDMETHOD(ShutdownNotify)(void);

// No Interface
	HRESULT Connect(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCMetaSchemaTable);
	void Disconnect();

private:
	BOOL m_fConnected;
	DWORD m_dwCookie;
	CComPtr<IConnectionPoint> m_pIMetaConn;
	CMetaSchemaTable *m_pCMetaSchemaTable;
};

#endif // #ifndef __METASCHM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\keycol.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: KeyCol.cpp

Owner: t-BrianM

This file contains implementation of the key collections.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "keycol.h"

/*------------------------------------------------------------------
 * C F l a t K e y C o l l e c t i o n
 */

/*===================================================================
CFlatKeyCollection::CFlatKeyCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CFlatKeyCollection::CFlatKeyCollection() : m_tszBaseKey(NULL)
{
}

/*===================================================================
CFlatKeyCollection::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase admin base object
	tszBaseKey	Name of key to enumerate from

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CFlatKeyCollection::Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);

	m_pIMeta = pIMeta;

	// Copy tszBaseKey to m_tszBaseKey
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	return S_OK;
}

/*===================================================================
CFlatKeyCollection::~CFlatKeyCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CFlatKeyCollection::~CFlatKeyCollection() 
{
	if (m_tszBaseKey != NULL)
		delete m_tszBaseKey;
}

/*===================================================================
CFlatKeyCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CFlatKeyCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IKeyCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CFlatKeyCollection::get_Count

Get method for Count property.  Counts the number of subkeys

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plReturn == NULL
	S_OK on success

Notes:
	Actually counts all of the subkeys.  Do not call in a loop!
===================================================================*/
STDMETHODIMP CFlatKeyCollection::get_Count(long * plReturn)
{
	TRACE0("MetaUtil: CFlatKeyCollection::get_Count\n");

	ASSERT_NULL_OR_POINTER(plReturn, long);

	if (plReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	*plReturn = 0;

	// Count the subkeys
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	int iIndex;

	iIndex = 0;
	for (;;) {  // FOREVER, will return from loop
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszBaseKey), 
								wszSubKey, 
								iIndex);
		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				// Ran out of items, return the number we counted
				*plReturn = iIndex;
				return S_OK;
			}
			else {
				return ::ReportError(hr);
			}
		}
		iIndex++;
	}
}

/*===================================================================
CFlatKeyCollection::get_Item

Get method for Item property.  Returns a key given its index.

Parameters:
	lIndex		[in] 1 based index of the key to get
	pbstrRetKey	[out, retval] Retrived key

Returns:
	E_INVALIDARG if pbstrRetKey == NULL or lIndex <= 0
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::get_Item(long lIndex, BSTR *pbstrRetKey)
{
	TRACE0("MetaUtil: CFlatKeyCollection::get_Item\n");

	ASSERT_NULL_OR_POINTER(pbstrRetKey, BSTR);

	if ((pbstrRetKey == NULL) || (lIndex <= 0)) {
		return ::ReportError(E_INVALIDARG);
	}

	*pbstrRetKey = NULL;

	USES_CONVERSION;
	HRESULT hr;
	
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];

	hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
							T2W(m_tszBaseKey), 
							wszSubKey, 
							lIndex - 1);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	*pbstrRetKey = W2BSTR(wszSubKey);

	return S_OK;
}

/*===================================================================
CFlatKeyCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the subkeys.

Parameters:
	ppIReturn	[out, retval] Interface for the enumberation object

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::get__NewEnum(LPUNKNOWN * ppIReturn)
{
	TRACE0("MetaUtil: CFlatKeyCollection::get__NewEnum\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the flat key enumeration
	CComObject<CFlatKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CFlatKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, 0);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CFlatKeyCollection::Add

Adds a key to the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to add

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::Add(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CFlatKeyCollection::Add\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::CreateKey(m_pIMeta, tszFullKey);
}

/*===================================================================
CFlatKeyCollection::Remove

Removes a key from the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to remove

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::Remove(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CFlatKeyCollection::Remove\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::DeleteKey(m_pIMeta, tszFullKey);
}

/*------------------------------------------------------------------
 * C F l a t K e y E n u m
 */

/*===================================================================
CFlatKeyEnum::CFlatKeyEnum

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/

CFlatKeyEnum::CFlatKeyEnum() : m_tszBaseKey(NULL),
							   m_iIndex(0)
{
}

/*===================================================================
CFlatKeyEnum::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszBaseKey	Name of key to enumerate from
	iIndex		Index of next element in enumeration

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CFlatKeyEnum::Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey, int iIndex) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);
	ASSERT(iIndex >= 0);

	m_pIMeta = pIMeta;

	// Copy tszBaseKey to m_tszBaseKey
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	m_iIndex = iIndex;

	return S_OK;
}

/*===================================================================
CFlatKeyEnum::~CFlatKeyEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CFlatKeyEnum::~CFlatKeyEnum()
{
	if (m_tszBaseKey != NULL) {
		delete m_tszBaseKey;
	}
}

/*===================================================================
CFlatKeyEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
    E_INVALIDARG if rgvarDest == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Next(unsigned long ulNumToGet, 
								VARIANT FAR* rgvarDest, 
								unsigned long FAR* pulNumGot) 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Next\n");
	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (rgvarDest == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	unsigned int uiDestIndex;

	// Clear the output array
	for(uiDestIndex = 0; uiDestIndex < ulNumToGet; uiDestIndex++) {
		VariantInit(&(rgvarDest[uiDestIndex]));
	}

	// For each subkey to get
	uiDestIndex = 0;
	while (uiDestIndex < ulNumToGet) {
		// Get a subkey
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszBaseKey), 
								wszSubKey, 
								m_iIndex);
		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				if (pulNumGot != NULL) {
					*pulNumGot = uiDestIndex;
				}
				return S_FALSE;
			}
			else {
				return ::ReportError(hr);
			}
		}

		// Output the subkey
		rgvarDest[uiDestIndex].vt = VT_BSTR;
		rgvarDest[uiDestIndex].bstrVal = W2BSTR(wszSubKey);

		// Setup next iteration
		m_iIndex++;
		uiDestIndex++;
	}

	if (pulNumGot != NULL) {
		*pulNumGot = uiDestIndex;
	}

	return S_OK;
}

/*===================================================================
CFlatKeyEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Skip(unsigned long ulNumToSkip) 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Skip\n");

	m_iIndex += ulNumToSkip;

	return S_OK;
}

/*===================================================================
CFlatKeyEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Reset() 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Reset\n");

	m_iIndex = 0;

	return S_OK; 
}

/*===================================================================
CFlatKeyEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn) 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Clone\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CFlatKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CFlatKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, m_iIndex);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}


/*------------------------------------------------------------------
 * C K e y S t a c k N o d e
 */

/*===================================================================
CKeyStackNode::Init

Constructor

Parameters:
	tszRelKey	Relative key for the enumeration level, NULL for root
	iIndex		0-based index for the next element

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if iIndex < 0
	S_OK on success
===================================================================*/
HRESULT CKeyStackNode::Init(LPCTSTR tszRelKey, int iIndex)
{
	ASSERT_NULL_OR_STRING(tszRelKey);
	ASSERT(iIndex >= 0);

	// Copy the relative key string
	if (tszRelKey == NULL) {
		// RelKey is empty
		m_tszRelKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszRelKey = new TCHAR[_tcslen(tszRelKey) + 1];
		if (m_tszRelKey == NULL) {
			return E_OUTOFMEMORY;
		}
		_tcscpy(m_tszRelKey, tszRelKey);
	}

	m_iIndex = iIndex;

	return S_OK;
}

/*===================================================================
CKeyStackNode::~CKeyStackNode

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CKeyStackNode::~CKeyStackNode() 
{
	if (m_tszRelKey != NULL) {
		delete m_tszRelKey;
	}
}

/*===================================================================
CKeyStackNode::Clone

Copies the node, except for the next pointer, which is NULL.

Parameters:
	None

Returns:
	NULL on failure
	Pointer to copy of node on success
===================================================================*/
CKeyStackNode *CKeyStackNode::Clone()
{
	HRESULT hr;
	CKeyStackNode *pCRet;

	pCRet = new CKeyStackNode();
	if (pCRet == NULL) {
		return NULL;
	}

	hr = pCRet->Init(m_tszRelKey, m_iIndex);
	if (FAILED(hr)) {
		delete pCRet;
		return NULL;
	}

	return pCRet;
}

/*------------------------------------------------------------------
 * C K e y S t a c k
 */

/*===================================================================
CKeyStack::~CKeyStack

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CKeyStack::~CKeyStack()
{
	// Delete the remaining nodes
	CKeyStackNode *pCDelete;

	while(m_pCTop != NULL) {
		ASSERT_POINTER(m_pCTop, CKeyStackNode);

		pCDelete = m_pCTop;
		m_pCTop = m_pCTop->m_pCNext;
		delete pCDelete;
	}
}

/*===================================================================
CKeyStack::Push

Pushes a CKeyStackNode onto the stack

Parameters:
	pNew	Pointer to CKeyStackNode to push on the stack

Returns:
	Nothing, never fails

Notes:
	CKeyStack "owns" the memory pointed to by pNew after call.
	CKeyStack or a later caller will delete it when done with it.
===================================================================*/
void CKeyStack::Push(CKeyStackNode *pCNew)
{
	ASSERT_POINTER(pCNew, CKeyStackNode);

	pCNew->m_pCNext = m_pCTop;
	m_pCTop = pCNew;
}

/*===================================================================
CKeyStack::Pop

Pops a CKeyStackNode from the stack

Parameters:
	None

Returns:
	Pointer to the top element or NULL if the stack is empty

Notes:
	Caller "owns" the memory pointed to by pNew after call.
	Caller is expected to delete it when it is done with it.
===================================================================*/
CKeyStackNode *CKeyStack::Pop()
{
	CKeyStackNode *pCRet;

	pCRet = m_pCTop;
	if (m_pCTop != NULL) {
		m_pCTop = m_pCTop->m_pCNext;
		ASSERT_NULL_OR_POINTER(m_pCTop, CKeyStackNode);
	}

	return pCRet;
}

/*===================================================================
CKeyStack::Clone

Copies the stack, including all of the nodes.

Parameters:
	Sheep

Returns:
	NULL on failure
	Pointer to copy of stack on success
===================================================================*/
CKeyStack *CKeyStack::Clone()
{
	CKeyStack *pCRet;

	// Build the container
	pCRet = new CKeyStack();
	if (pCRet == NULL) {
		return NULL;
	}

	// Copy the nodes
	CKeyStackNode *pCSource;
	CKeyStackNode **ppCDest;

	pCSource = m_pCTop;
	ppCDest = &(pCRet->m_pCTop);
	while(pCSource != NULL) {
		ASSERT_POINTER(pCSource, CKeyStackNode);

		*ppCDest = pCSource->Clone();
		if ((*ppCDest) == NULL) {
			delete pCRet;
			return NULL;
		}

		ppCDest = &((*ppCDest)->m_pCNext);
		pCSource = pCSource->m_pCNext;
	}
	*ppCDest = NULL;

	return pCRet;
}


/*------------------------------------------------------------------
 * C D e e p K e y C o l l e c t i o n
 */

/*===================================================================
CDeepKeyCollection::CDeepKeyCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyCollection::CDeepKeyCollection() : m_tszBaseKey(NULL) 
{
}

/*===================================================================
CDeepKeyCollection::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszBaseKey	Name of key to enumerate from

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CDeepKeyCollection::Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);

	m_pIMeta = pIMeta;

	// Copy tszBaseKey to m_tszBaseKey
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	return S_OK;
}

/*===================================================================
CDeepKeyCollection::~CDeepKeyCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyCollection::~CDeepKeyCollection() 
{
	if (m_tszBaseKey != NULL)
		delete m_tszBaseKey;
}

/*===================================================================
CDeepKeyCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CDeepKeyCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IKeyCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CDeepKeyCollection::get_Count

Get method for Count property.  Counts the number of subkeys

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pVal == NULL
	S_OK on success

Notes:
	Actually counts all of the subkeys recursivly.  Very slow, do 
	not put in a loop!
===================================================================*/
STDMETHODIMP CDeepKeyCollection::get_Count(long * pVal)
{
	TRACE0("MetaUtil: CDeepKeyCollection::get_Count\n");

	ASSERT_NULL_OR_POINTER(pVal, long);

	if (pVal == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	hr = CountKeys(m_tszBaseKey, pVal);
	
	return hr;
}

/*===================================================================
CDeepKeyCollection::get_Item

Get method for Item property.  Returns a key given its index.

Parameters:
	lIndex		[in] 1 based index of the key to get
	pbstrRetKey	[out, retval] Interface for the enumberation object

Returns:
	E_INVALIDARG if lIndex <= 0 or pbstrRetKey == NULL
	ERROR_NO_MORE_ITEMS if index is > count
	S_OK on success

Notes:
	This method is slow.  Deep enumerations are much faster.  Might 
	be able to do some hacking with a stack object and cached location 
	to speed up sequential calls.  
===================================================================*/
STDMETHODIMP CDeepKeyCollection::get_Item(long lIndex, BSTR *pbstrRetKey)
{
	TRACE0("MetaUtil: CDeepKeyCollection::get_Item\n");
	
	ASSERT_NULL_OR_POINTER(pbstrRetKey, BSTR);

	if ((lIndex <= 0) || (pbstrRetKey == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;
	TCHAR tszRetKey[ADMINDATA_MAX_NAME_LEN];
	long lCurIndex;

	lCurIndex = 1;
	tszRetKey[0] = _T('\0');

	hr = IndexItem(NULL, lIndex, &lCurIndex, tszRetKey);
	if (hr == S_FALSE) {
		// Ran out of items before we found it
		return ::ReportError(ERROR_NO_MORE_ITEMS);
	}
	else if (hr == S_OK) {
		// Found it
		*pbstrRetKey = T2BSTR(tszRetKey);
	}
	else {
		return ::ReportError(hr);
	}

	return hr;
}

/*===================================================================
CDeepKeyCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the subkeys.

Parameters:
	ppIReturn	[out, retval] Interface for the enumberation object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyCollection::get__NewEnum(LPUNKNOWN * ppIReturn)
{
	TRACE0("MetaUtil: CDeepKeyCollection::get__NewEnum\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the deep key enumeration
	CComObject<CDeepKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CDeepKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, NULL);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CDeepKeyCollection::Add

Adds a key to the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to add

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyCollection::Add(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CDeepKeyCollection::Add\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::CreateKey(m_pIMeta, tszFullKey);
}

/*===================================================================
CDeepKeyCollection::Remove

Removes a key from the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to remove

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyCollection::Remove(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CDeepKeyCollection::Remove\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::DeleteKey(m_pIMeta, tszFullKey);
}

/*===================================================================
CDeepKeyCollection::CountKeys

Private, recursive method for counting keys

Parameters:
	tszBaseKey	[in] Key to begin counting with (but not to count)
				NULL can represent the root key.
	plNumKeys	[out] Number of keys counter, not including the base
	
Returns:
	S_OK on success
===================================================================*/
HRESULT CDeepKeyCollection::CountKeys(LPTSTR tszBaseKey, long *plNumKeys) 
{
	ASSERT_NULL_OR_STRING(tszBaseKey);
	ASSERT_POINTER(plNumKeys, long);

	*plNumKeys = 0;

	USES_CONVERSION;
	HRESULT hr;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszFullSubKey[ADMINDATA_MAX_NAME_LEN];
	int iIndex;

	iIndex = 0;
	for (;;) {  // FOREVER, will return from loop
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								T2W(tszBaseKey), 
								wszSubKey, 
								iIndex);
		if (FAILED(hr)) {
			if ((HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) ||
				(HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND)) {
				// Ran out of items, break
				return S_OK;
			}
			else {
				return ::ReportError(hr);
			}
		}
		else { // SUCCEEDED(hr)
			// Build the full subkey
			if ((tszBaseKey == NULL) ||
				(tszBaseKey[0] == _T('\0')) ) {
				wcscpy(wszFullSubKey, wszSubKey);
			}
			else {
				wcscpy(wszFullSubKey, T2W(tszBaseKey));
				wcscat(wszFullSubKey, L"/");
				wcscat(wszFullSubKey, wszSubKey);
			}

			// Count this key
			(*plNumKeys)++;

			// Count the subkeys
			long lNumSubKeys;
			hr = CountKeys(W2T(wszFullSubKey), &lNumSubKeys);
			if (FAILED(hr)) {
				return hr;
			}
			(*plNumKeys) += lNumSubKeys;

		}
		iIndex++;
	}
}

/*===================================================================
CDeepKeyCollection::IndexItem

Private, recursive method for indexing keys

Parameters:
	tszRelKey	Relative key to index from
	lDestIndex	Destination index
	plCurIndex	Current (working) index
	tszRet		Result from search	

Returns:
	S_OK if the destination index was reached
	S_FALSE if the destination index was not reached
===================================================================*/
HRESULT CDeepKeyCollection::IndexItem(LPTSTR tszRelKey, long lDestIndex, long *plCurIndex, LPTSTR tszRet) 
{
	ASSERT_NULL_OR_STRING(tszRelKey);
	ASSERT_POINTER(plCurIndex, long);
	ASSERT_STRING(tszRet);

	USES_CONVERSION;
	HRESULT hr;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszRelSubKey[ADMINDATA_MAX_NAME_LEN];
	int iIndex;

	// Open the base key
	METADATA_HANDLE hMDBaseKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszBaseKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDBaseKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	iIndex = 0;
	for (;;) {  // FOREVER, will return from loop
		hr = m_pIMeta->EnumKeys(hMDBaseKey, 
								T2W(tszRelKey), 
								wszSubKey, 
								iIndex);
		if (FAILED(hr)) {
			m_pIMeta->CloseKey(hMDBaseKey);
			if ((HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) ||
				(HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND)) {
				// Ran out of items, break
				return S_FALSE;
			}
			else {
				return ::ReportError(hr);
			}
		}
		else {
			// Build the full subkey
			if ((tszRelKey == NULL) ||
				(tszRelKey[0] == _T('\0')) ) {
				wcscpy(wszRelSubKey, wszSubKey);
			}
			else {
				wcscpy(wszRelSubKey, T2W(tszRelKey));
				wcscat(wszRelSubKey, L"/");
				wcscat(wszRelSubKey, wszSubKey);
			}

			// Is this the destination?
			if ((*plCurIndex) == lDestIndex) {
				//Found it, copy it to the return buffer
				_tcscpy(tszRet, W2T(wszRelSubKey));

				m_pIMeta->CloseKey(hMDBaseKey);
				return S_OK;
			}

			// Count this key
			(*plCurIndex)++;

			// Check the subkeys
			hr = IndexItem(W2T(wszRelSubKey), lDestIndex, plCurIndex, tszRet);
			if (hr == S_OK) {
				//Found it
				m_pIMeta->CloseKey(hMDBaseKey);
				return S_OK;
			}
			else if (FAILED(hr)) {
				m_pIMeta->CloseKey(hMDBaseKey);
				return hr;
			}
		}
		iIndex++;
	}

	// Close the base key
	m_pIMeta->CloseKey(hMDBaseKey);

	return S_OK;
}

/*------------------------------------------------------------------
 * C D e e p K e y E n u m
 */

/*===================================================================
CDeepKeyEnum::CDeepKeyEnum

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyEnum::CDeepKeyEnum() : m_tszBaseKey(NULL),
							   m_pCKeyStack(NULL)
{
}

/*===================================================================
CDeepKeyEnum::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszBaseKey	Name of key to enumerate from
	pKeyStack	pointer to a stack containing the state to copy or
				NULL to start from the begining

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CDeepKeyEnum::Init(const CComPtr<IMSAdminBase> &pIMeta, 
						   LPCTSTR tszBaseKey, 
						   CKeyStack *pCKeyStack) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);
	ASSERT_NULL_OR_POINTER(pCKeyStack, CKeyStack);

	HRESULT hr;

	m_pIMeta = pIMeta;
	
	// Copy the base string
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	// Setup the stack
	if (pCKeyStack == NULL) {
		// Build a new stack
		CKeyStackNode *pCNew;

		m_pCKeyStack = new CKeyStack();
		if (m_pCKeyStack == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}

		// Create the first node
		pCNew = new CKeyStackNode();
		if (pCNew == NULL) {
			delete m_pCKeyStack;
			m_pCKeyStack = NULL;
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pCNew->Init(NULL, 0);
		if (FAILED(hr)) {
			delete m_pCKeyStack;
			m_pCKeyStack = NULL;
			return ::ReportError(E_OUTOFMEMORY);
		}

		// Put the first node onto the stack
		m_pCKeyStack->Push(pCNew);
	}
	else {
		// Clone the stack we were passed
		m_pCKeyStack = pCKeyStack->Clone();
		if (m_pCKeyStack == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
	}

	return S_OK;
}

/*===================================================================
CDeepKeyEnum::~CDeepKeyEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyEnum::~CDeepKeyEnum()
{
	if (m_tszBaseKey != NULL) {
		delete m_tszBaseKey;
	}
	if (m_pCKeyStack != NULL) {
		delete m_pCKeyStack;
	}
}

/*===================================================================
CDeepKeyEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
	S_OK if outputs ulNumToGet items
	S_FALSE if outputs less than ulNumToGet items
	E_OUTOFMEMORY if allocation failed
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Next(unsigned long ulNumToGet, 
								VARIANT FAR* rgvarDest, 
								unsigned long FAR* pulNumGot) 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Next\n");

	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (pulNumGot != NULL) {
		pulNumGot = 0;
	}

	USES_CONVERSION;
	HRESULT hr;
	unsigned int i;
	CKeyStackNode *pCKeyNode;
	CKeyStackNode *pCSubKeyNode;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszRelSubKey[ADMINDATA_MAX_NAME_LEN];

	// Open the base key
	METADATA_HANDLE hMDBaseKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszBaseKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDBaseKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// For each element to retrive
	for (i=0; i < ulNumToGet; i++) {
		// Get a subkey
		do {
			// Pop a key off the stack
			pCKeyNode = m_pCKeyStack->Pop();

			// if the stack is empty, we're done return S_FALSE
			if (pCKeyNode == NULL) {
				m_pIMeta->CloseKey(hMDBaseKey);
				if (pulNumGot != NULL) {
					*pulNumGot = i;
				}
				return S_FALSE;
			}

			// Attempt to Enum the next key
			hr = m_pIMeta->EnumKeys(hMDBaseKey, 
									T2W(pCKeyNode->GetBaseKey()), 
									wszSubKey, 
									pCKeyNode->GetIndex());

			// If failed delete the stack entry
			if (FAILED(hr)) {
				delete pCKeyNode;

				if ((HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) &&
					(HRESULT_CODE(hr) != ERROR_PATH_NOT_FOUND)) {
					// Got an unexpected Error
					m_pIMeta->CloseKey(hMDBaseKey);
					return ::ReportError(hr);
				}
				
			}

		} while (FAILED(hr));

		// Build the relative subkey
		if ((pCKeyNode->GetBaseKey() == NULL) ||
			((pCKeyNode->GetBaseKey())[0] == _T('\0')) ) {
			wcscpy(wszRelSubKey, wszSubKey);
		}
		else {
			wcscpy(wszRelSubKey, T2W(pCKeyNode->GetBaseKey()));
			wcscat(wszRelSubKey, L"/");
			wcscat(wszRelSubKey, wszSubKey);
		}

		// Output the relative subkey
		VariantInit(&(rgvarDest[i]));
		rgvarDest[i].vt = VT_BSTR;
		rgvarDest[i].bstrVal = W2BSTR(wszRelSubKey);

		// Increment the key index
		pCKeyNode->SetIndex(pCKeyNode->GetIndex() + 1);

		// Push the key back onto the stack
		m_pCKeyStack->Push(pCKeyNode);

		// Create a stack node for the subkey
		pCSubKeyNode = new CKeyStackNode();
		if (pCSubKeyNode == NULL) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pCSubKeyNode->Init(W2T(wszRelSubKey), 0);
		if (FAILED(hr)) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(hr);
		}

		// Push the subkey onto the stack
		m_pCKeyStack->Push(pCSubKeyNode);
	}

	// Close the base key
	m_pIMeta->CloseKey(hMDBaseKey);

	if (pulNumGot != NULL) {
		*pulNumGot = i;
		}

	return S_OK;
}

/*===================================================================
CDeepKeyEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK if outputs ulNumToGet items
	E_OUTOFMEMORY if allocation failed
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Skip(unsigned long ulNumToSkip) 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Skip\n");

	USES_CONVERSION;
	HRESULT hr;
	unsigned long i;
	CKeyStackNode *pCKeyNode;
	CKeyStackNode *pCSubKeyNode;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszRelSubKey[ADMINDATA_MAX_NAME_LEN];

	// Open the base key
	METADATA_HANDLE hMDBaseKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszBaseKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDBaseKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// For each element to stip
	for (i=0; i < ulNumToSkip; i++) {
		// Get a subkey
		do {
			// Pop a key off the stack
			pCKeyNode = m_pCKeyStack->Pop();

			// if the stack is empty, we're done return S_OK
			if (pCKeyNode == NULL) {
				m_pIMeta->CloseKey(hMDBaseKey);
				return S_OK;
			}

			// Attempt to Enum the next key
			hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
									T2W(pCKeyNode->GetBaseKey()), 
									wszSubKey, 
									pCKeyNode->GetIndex());

			// If failed delete the stack entry
			if (FAILED(hr)) {
				delete pCKeyNode;

				if ((HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) &&
					(HRESULT_CODE(hr) != ERROR_PATH_NOT_FOUND)) {
					// Got an unexpected Error
					m_pIMeta->CloseKey(hMDBaseKey);
					return ::ReportError(hr);
				}
			}

		} while (FAILED(hr));

		// Build the relative subkey
		if ((pCKeyNode->GetBaseKey() == NULL) ||
			((pCKeyNode->GetBaseKey())[0] == _T('\0')) ) {
			wcscpy(wszRelSubKey, wszSubKey);
		}
		else {
			wcscpy(wszRelSubKey, T2W(pCKeyNode->GetBaseKey()));
			wcscat(wszRelSubKey, L"/");
			wcscat(wszRelSubKey, wszSubKey);
		}

		// Increment the key index
		pCKeyNode->SetIndex(pCKeyNode->GetIndex() + 1);

		// Push the key back on the stack
		m_pCKeyStack->Push(pCKeyNode);

		// Create a stack node for the subkey
		pCSubKeyNode = new CKeyStackNode();
		if (pCSubKeyNode == NULL) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pCSubKeyNode->Init(W2T(wszRelSubKey), 0);
		if (FAILED(hr)) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(hr);
		}

		// Push the subkey onto the stack
		m_pCKeyStack->Push(pCSubKeyNode);
	}

	// Close the base key
	m_pIMeta->CloseKey(hMDBaseKey);

	return S_OK;
}

/*===================================================================
CDeepKeyEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	E_OUTOFMEMORY if not enough memory to build a new stack
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Reset() 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Reset\n");

	HRESULT hr;

	// Build a new stack (if this fails we still have the old stack)
	CKeyStack *pCNewStack;
	CKeyStackNode *pCNewNode;

	pCNewStack = new CKeyStack();
	if (pCNewStack == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// Create the first node
	pCNewNode = new CKeyStackNode();
	if (pCNewNode == NULL) {
		delete pCNewStack;
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pCNewNode->Init(NULL, 0);
	if (FAILED(hr)) {
		delete pCNewStack;
		return ::ReportError(E_OUTOFMEMORY);
	}

	// Put the first node onto the new stack
	pCNewStack->Push(pCNewNode);

	// Replace the old stack
	delete m_pCKeyStack;
	m_pCKeyStack = pCNewStack;

	return S_OK; 
}

/*===================================================================
CDeepKeyEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if not enough memory to create clone
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn) 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Clone\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CDeepKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CDeepKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, m_pCKeyStack);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\metaschm.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MetaSchm.cpp

Owner: t-BrianM

This file contains implementation of the CMetaSchemaTable object and
other schema related objects.

The CMetaSchemaTable object has COM style reference counting so it 
can service objects created by CMetaUtil.  I didn't make it a full
blown COM object because all of the class stuff would be a pain to
export.

To reduce the overhead of maintaining this object (which may or
may not be used), all information is loaded on demand, then set
dirty or unloaded when portions of the metabase associated with it
are modified.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "MetaSchm.h"

/*------------------------------------------------------------------
 * C P r o p I n f o
 */

/*===================================================================
CPropInfo::Init

Constructor

Parameters:
	dwId		Id of property

Returns:
	S_OK on success
===================================================================*/
HRESULT CPropInfo::Init(DWORD dwId) 
{
	m_dwId = dwId;

	return S_OK;
}

/*===================================================================
CPropInfo::SetName

Sets the property name.

Parameters:
	tszName		Name of property

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropInfo::SetName(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);
	ASSERT(m_tszName == NULL); // m_tszName not yet set

	m_tszName = new TCHAR[_tcslen(tszName) + 1];
	if (m_tszName == NULL) {
		return E_OUTOFMEMORY;
	}
	_tcscpy(m_tszName, tszName);

	return S_OK;
}

/*===================================================================
CPropInfo::SetTypeInfo

Sets the property name.

Parameters:
	pType	PropValue structure containing type information.

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropInfo::SetTypeInfo(PropValue *pType)
{
	ASSERT_POINTER(pType, PropValue);
	ASSERT(m_pType == NULL); // m_pType not yet set

	m_pType = new PropValue;
	if (m_pType == NULL) {
		return E_OUTOFMEMORY;
	}
	memcpy(m_pType, pType, sizeof(PropValue));

	return S_OK;
}


/*------------------------------------------------------------------
 * C P r o p I n f o T a b l e
 */

/*===================================================================
CPropInfoTable::CPropInfoTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropInfoTable::CPropInfoTable() : m_fLoaded(FALSE)
{
	// Clear the hash tables
	memset(m_rgCPropIdTable, 0, PROPERTY_HASH_SIZE * sizeof(CPropInfo *));
	memset(m_rgCPropNameTable, 0, PROPERTY_HASH_SIZE * sizeof(CPropInfo *));
}

/*===================================================================
CPropInfoTable::~CPropInfoTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropInfoTable::~CPropInfoTable() 
{
	if (m_fLoaded) {
		Unload();
	}
}

/*===================================================================
CPropInfoTable::Load

Loads properties from the "_Machine_/Schema/Properties" key into the
property information table.  On failure, recovers by unloading 
everything.

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	hMDComp		Open metabase handle to "_Machine_" key

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CPropInfoTable::Load(CComPtr<IMSAdminBase> &pIMeta, 
							 METADATA_HANDLE hMDComp) 
{
	//If it's already loaded, unload then reload
	if (m_fLoaded) {
		Unload();
	}

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdrDataRec;
	DWORD dwReqDataLen;
	DWORD dwReturnBufLen;
	UCHAR *lpReturnBuf = NULL;
	unsigned int uiLoc;
	CPropInfo *pCNewProp;
	METADATA_HANDLE hMDNames = NULL;
	METADATA_HANDLE hMDTypes = NULL;

	//Setup the return buffer
	dwReturnBufLen = 1024;
	lpReturnBuf = new UCHAR[dwReturnBufLen];
	if (lpReturnBuf == NULL)
		return E_OUTOFMEMORY;	

	// Open the Schema/Properties/Names subkey
	hr = pIMeta->OpenKey(hMDComp, 
			             L"Schema/Properties/Names", 
						 METADATA_PERMISSION_READ, 
					     MUTIL_OPEN_KEY_TIMEOUT,
					     &hMDNames);
	if (FAILED(hr)) {
		delete lpReturnBuf;
		return hr;
	};

	// For each name	
	iDataIndex = 0;
	mdrDataRec.dwMDIdentifier = 0;
	mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrDataRec.dwMDUserType = ALL_METADATA;
	mdrDataRec.dwMDDataType = ALL_METADATA;
	mdrDataRec.dwMDDataLen = dwReturnBufLen;
	mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
	mdrDataRec.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDNames, 
						  NULL, 
						  &mdrDataRec, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Make sure we got a string
		if (mdrDataRec.dwMDDataType != STRING_METADATA) {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto LError;
		}

		// Create the property object
		pCNewProp = new CPropInfo;
		if (pCNewProp == NULL) {
			hr = E_OUTOFMEMORY;
			goto LError;
		}
		hr = pCNewProp->Init(mdrDataRec.dwMDIdentifier); 
		if (FAILED(hr)) {
			delete pCNewProp;
			goto LError;
		}
		hr = pCNewProp->SetName(W2T(reinterpret_cast<LPWSTR> (lpReturnBuf))); 
		if (FAILED(hr)) {
			delete pCNewProp;
			goto LError;
		}

		// Add it to the Id hash table
		uiLoc = IdHash(mdrDataRec.dwMDIdentifier);
		pCNewProp->m_pCIdHashNext = m_rgCPropIdTable[uiLoc];
		m_rgCPropIdTable[uiLoc] = pCNewProp;

		// Add it to the Name hash table
		uiLoc = NameHash(pCNewProp->m_tszName);
		pCNewProp->m_pCNameHashNext = m_rgCPropNameTable[uiLoc];
		m_rgCPropNameTable[uiLoc] = pCNewProp;

		iDataIndex++;
		mdrDataRec.dwMDIdentifier = 0;
		mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrDataRec.dwMDUserType = ALL_METADATA;
		mdrDataRec.dwMDDataType = ALL_METADATA;
		mdrDataRec.dwMDDataLen = dwReturnBufLen;
		mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
		mdrDataRec.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDNames, 
							  NULL, 
							  &mdrDataRec, 
							  iDataIndex, 
							  &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Schema/Properties/Names sub-key
	pIMeta->CloseKey(hMDNames);
	hMDNames = NULL;


	// Open the Schema/Properties/Types sub-key
	hr = pIMeta->OpenKey(hMDComp, 
			             L"Schema/Properties/Types", 
						 METADATA_PERMISSION_READ, 
					     MUTIL_OPEN_KEY_TIMEOUT,
					     &hMDTypes);
	if (FAILED(hr)) {
		goto LError;
	};

	// For each type
	iDataIndex = 0;
	mdrDataRec.dwMDIdentifier = 0;
	mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrDataRec.dwMDUserType = ALL_METADATA;
	mdrDataRec.dwMDDataType = ALL_METADATA;
	mdrDataRec.dwMDDataLen = dwReturnBufLen;
	mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
	mdrDataRec.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDTypes, 
						  NULL, 
						  &mdrDataRec, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Make sure we got binary data
		if (mdrDataRec.dwMDDataType != BINARY_METADATA) {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto LError;
		}

		// Look for an existing property object for this Id
		pCNewProp = GetPropInfo(mdrDataRec.dwMDIdentifier);
		if (pCNewProp == NULL) {
			// Create the property object
			pCNewProp = new CPropInfo;
			if (pCNewProp == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			hr = pCNewProp->Init(mdrDataRec.dwMDIdentifier);
			if (FAILED(hr)) {
				delete pCNewProp;
				goto LError;
			}

			// Add it to the Id hash table
			uiLoc = IdHash(mdrDataRec.dwMDIdentifier);
			pCNewProp->m_pCIdHashNext = m_rgCPropIdTable[uiLoc];
			m_rgCPropIdTable[uiLoc] = pCNewProp;
		}

		// Add type information to the property object
		pCNewProp->SetTypeInfo(reinterpret_cast<PropValue *> (lpReturnBuf));

		iDataIndex++;
		mdrDataRec.dwMDIdentifier = 0;
		mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrDataRec.dwMDUserType = ALL_METADATA;
		mdrDataRec.dwMDDataType = ALL_METADATA;
		mdrDataRec.dwMDDataLen = dwReturnBufLen;
		mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
		mdrDataRec.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDTypes, 
							  NULL, 
							  &mdrDataRec, 
							  iDataIndex, 
							  &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Schema/Properties/Types sub-key
	pIMeta->CloseKey(hMDTypes);
	hMDTypes = NULL;

	delete lpReturnBuf;

	m_fLoaded = TRUE;

	return S_OK;

LError:
	if (hMDNames != NULL) {
		pIMeta->CloseKey(hMDNames);
	}
	if (hMDTypes != NULL) {
		pIMeta->CloseKey(hMDTypes);
	}

	if (lpReturnBuf != NULL) {
		delete lpReturnBuf;
	}

	// Cleanup the entries we loaded
	Unload();

	return hr;
}

/*===================================================================
CPropInfoTable::Unload

Unloads the property information table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CPropInfoTable::Unload() 
{
	int iIndex;
	CPropInfo *pCDeleteProp;

	//Clear the Name table
	memset(m_rgCPropNameTable, 0, PROPERTY_HASH_SIZE * sizeof(CPropInfo *));

	// For each Id hash table entry
	for (iIndex =0; iIndex < PROPERTY_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCPropIdTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDeleteProp = m_rgCPropIdTable[iIndex];
			m_rgCPropIdTable[iIndex] = pCDeleteProp->m_pCIdHashNext;
			delete pCDeleteProp;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CPropInfoTable::GetPropInfo

Gets property information from the table based on property id

Parameters:
	dwId	Id of property to get

Returns:
	NULL if property not found or error
	Pointer to CPropInfo class on success
===================================================================*/
CPropInfo *CPropInfoTable::GetPropInfo(DWORD dwId) 
{
	CPropInfo *pCCurProp;

	// Go to the table location
	pCCurProp = m_rgCPropIdTable[IdHash(dwId)];

	// Look at all of the entries
	while ((pCCurProp != NULL) && (pCCurProp->m_dwId != dwId)) {
		pCCurProp = pCCurProp->m_pCIdHashNext;
	}

	return pCCurProp; // Will be NULL if not found
}

/*===================================================================
CPropInfoTable::GetPropInfo

Gets property information from the table based on property name.
Case insensitive.

Parameters:
	tszName		Name of property to get

Returns:
	NULL if property not found or error
	Pointer to CPropInfo class on success
===================================================================*/
CPropInfo *CPropInfoTable::GetPropInfo(LPCTSTR tszName) 
{
	CPropInfo *pCCurProp;

	// Go to the table location
	pCCurProp = m_rgCPropNameTable[NameHash(tszName)];

	// Look at all of the entries
	while ((pCCurProp != NULL) && 
		   (_tcsicmp(pCCurProp->m_tszName, tszName) != 0)) {
		pCCurProp = pCCurProp->m_pCNameHashNext;
	}

	return pCCurProp; // Will be NULL if not found
}

/*===================================================================
CPropInfoTable::NameHash

Private function to get a hash value from a property name for the
name table.  Case insensitive.

Parameters:
	tszName		Name to hash

Returns:
	Hash value of name
===================================================================*/
unsigned int CPropInfoTable::NameHash(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		uiSum += _totlower(tszName[uiIndex]);
	}

	return (uiSum % PROPERTY_HASH_SIZE);
}

/*------------------------------------------------------------------
 * C C l a s s P r o p I n f o
 */

// Everything is inline

/*------------------------------------------------------------------
 * C C l a s s I n f o
 */

/*===================================================================
CClassInfo::CClassInfo

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfo::CClassInfo() : m_tszName(NULL),
						   m_pCHashNext(NULL),
						   m_fLoaded(FALSE),
						   m_pCOptionalPropList(NULL),
						   m_pCMandatoryPropList(NULL)
{
	// Clear the hash table
	memset(m_rgCPropTable, 0, CLASS_PROPERTY_HASH_SIZE * sizeof(CClassPropInfo *));
}

/*===================================================================
CClassInfo::Init

Constructor

Parameters:
	tszName		Name of the class

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CClassInfo::Init(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	m_tszName = new TCHAR[_tcslen(tszName) + 1];
	if (m_tszName == NULL) {
		return E_OUTOFMEMORY;
	}
	_tcscpy(m_tszName, tszName);

	return S_OK;
}

/*===================================================================
CClassInfo::~CClassInfo

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfo::~CClassInfo() 
{
	Unload();

	if (m_tszName != NULL) {
		delete m_tszName;
	}
}

/*===================================================================
CClassInfo::Load

Loads class properties from the "_Machine_/Schema/Classes/_Class_/Mandatory"
and "_Machine_/Schema/Classes/_Class_/Optional" keys into the class 
property information table, mandatory list and optional list.  On 
failure, recovers by unloading everything.

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	hMDClasses	Open metabase handle to "_Machine_/Schema/Classes" key

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CClassInfo::Load(CComPtr<IMSAdminBase> &pIMeta, 
						 METADATA_HANDLE hMDClasses)
{
	USES_CONVERSION;
	HRESULT hr;

	//If it's already loaded, unload then reload
	if (m_fLoaded) {
		Unload();
	}

	// Open the class key
	METADATA_HANDLE hMDClass = NULL;
	hr = pIMeta->OpenKey(hMDClasses, 
			             T2W(m_tszName),
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClass);
	if (FAILED(hr)) {
		return hr;
	}

	// Load the class properties
	METADATA_HANDLE hMDClassProp = NULL;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwReturnBufLen;
	UCHAR *lpReturnBuf = NULL;
	unsigned int uiLoc;
	CClassPropInfo *pCNewClassProp;

	//Setup the return buffer
	dwReturnBufLen = 1024;
	lpReturnBuf = new UCHAR[dwReturnBufLen];
	if (lpReturnBuf == NULL) {
		hr = E_OUTOFMEMORY;
		goto LError;
	}


	// Load the mandatory class properties
	// Open the Mandatory key
	hr = pIMeta->OpenKey(hMDClass, 
			             L"Mandatory", 
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClassProp);
	if (FAILED(hr)) {
		goto LError;
	}

	// For each Mandatory property	
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwReturnBufLen;
	mdr.pbMDData = (PBYTE) lpReturnBuf;
	mdr.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDClassProp, 
						  NULL, 
						  &mdr, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)|| (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {

		// Handle insufficent buffer errors
		if ((HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
			// Allocate more memory
			delete lpReturnBuf;
			dwReturnBufLen = dwReqDataLen;
			lpReturnBuf = new UCHAR[dwReturnBufLen];
			if (lpReturnBuf == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			// Loop again
			hr = S_OK;
		}
		else { //Buffer is big enough, proceed to add the class property
			// Create the Class Property object
			pCNewClassProp = new CClassPropInfo;
			if (pCNewClassProp == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			hr = pCNewClassProp->Init(mdr.dwMDIdentifier, TRUE);
			if (FAILED(hr)) {
				delete pCNewClassProp;
				goto LError;
			}

			//Add it to the mandatory list
			pCNewClassProp->m_pCListNext = m_pCMandatoryPropList;
			m_pCMandatoryPropList = pCNewClassProp;
		
			//Add it to the hash table
			uiLoc = Hash(mdr.dwMDIdentifier);
			pCNewClassProp->m_pCHashNext = m_rgCPropTable[uiLoc];
			m_rgCPropTable[uiLoc] = pCNewClassProp;

			iDataIndex++;
		}

		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwReturnBufLen;
		mdr.pbMDData = (PBYTE) lpReturnBuf;
		mdr.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDClassProp, 
							  NULL, 
							  &mdr, 
							  iDataIndex, 
							  &dwReqDataLen);
	}
	
	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Mandatory key
	pIMeta->CloseKey(hMDClassProp);
	hMDClassProp = NULL;
	

	// Load the optional class properties
	// Open the Optional key
	hr = pIMeta->OpenKey(hMDClass, 
			             L"Optional", 
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClassProp);
	if (FAILED(hr)) {
		goto LError;
	}

	// For each Optional property
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwReturnBufLen;
	mdr.pbMDData = (PBYTE) lpReturnBuf;
	mdr.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDClassProp, 
						  NULL, 
						  &mdr, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)|| (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {

		// Handle insufficent buffer errors
		if ((HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
			// Allocate more memory
			delete lpReturnBuf;
			dwReturnBufLen = dwReqDataLen;
			lpReturnBuf = new UCHAR[dwReturnBufLen];
			if (lpReturnBuf == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}

			// Loop again
			hr = S_OK;
		}
		else { //Buffer is big enough, proceed to add the class property
			// Create the Class Property object
			pCNewClassProp = new CClassPropInfo;
			if (pCNewClassProp == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
				}
			hr = pCNewClassProp->Init(mdr.dwMDIdentifier, FALSE);
			if (FAILED(hr)) {
				delete pCNewClassProp;
				goto LError;
			}

			//Add it to the optional list
			pCNewClassProp->m_pCListNext = m_pCOptionalPropList;
			m_pCOptionalPropList = pCNewClassProp;
			
		
			//Add it to the hash table
			uiLoc = Hash(mdr.dwMDIdentifier);
			pCNewClassProp->m_pCHashNext = m_rgCPropTable[uiLoc];
			m_rgCPropTable[uiLoc] = pCNewClassProp;

			iDataIndex++;
		}

		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwReturnBufLen;
		mdr.pbMDData = (PBYTE) lpReturnBuf;
		mdr.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDClassProp, 
							  NULL, 
							  &mdr, 
							  iDataIndex, 
							  &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Optional key
	pIMeta->CloseKey(hMDClassProp);

	delete lpReturnBuf;
	
	// Close the Class key
	pIMeta->CloseKey(hMDClass);

	m_fLoaded = TRUE;

	return S_OK;

//Error durring loading, back out
LError:
	if (hMDClassProp != NULL) {
		pIMeta->CloseKey(hMDClassProp);
	}
	if (hMDClass != NULL) {
		pIMeta->CloseKey(hMDClass);
	}

	if (lpReturnBuf != NULL) {
		delete lpReturnBuf;
	}

	Unload();

	return hr;
}

/*===================================================================
CClassInfo::Unload

Unloads the class property information table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CClassInfo::Unload() 
{
	int iIndex;
	CClassPropInfo *pCDeleteProp;

	// Clear the lists
	m_pCOptionalPropList = NULL;
	m_pCMandatoryPropList = NULL;

	// For each hash table entry
	for (iIndex =0; iIndex < CLASS_PROPERTY_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCPropTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDeleteProp = m_rgCPropTable[iIndex];
			m_rgCPropTable[iIndex] = pCDeleteProp->m_pCHashNext;
			delete pCDeleteProp;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CClassInfo::GetProperty

Get the CClassPropInfo (class property info) object from the hash 
table given the property id.

Parameters:
	dwId	Identifier of the property to get

Returns:
	NULL on failure
	Pointer to the CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CClassInfo::GetProperty(DWORD dwId) {
	CClassPropInfo *pCCurProp;

	// Go to the table location
	pCCurProp = m_rgCPropTable[Hash(dwId)];

	// Look at all of the entries
	while ((pCCurProp != NULL) && (pCCurProp->m_dwId != dwId)) {
		pCCurProp = pCCurProp->m_pCHashNext;
	}

	return pCCurProp; // Will be NULL if not found
}


/*------------------------------------------------------------------
 * C C l a s s I n f o T a b l e
 */

/*===================================================================
CClassInfoTable::CClassInfoTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfoTable::CClassInfoTable() : m_fLoaded(FALSE) 
{
	// Clear the hash table
	memset(m_rgCClassTable, 0, CLASS_HASH_SIZE * sizeof(CClassInfo *));
}

/*===================================================================
CClassInfoTable::~CClassInfoTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfoTable::~CClassInfoTable() 
{
	if (m_fLoaded) {
		Unload();
	}
}

/*===================================================================
CClassInfoTable::Load

Loads classes from the "_Machine_/Schema/Classes" key into the class 
information table.  On failure, recovers by unloading everything.

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	hMDComp		Open metabase handle to "_Machine_" key

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CClassInfoTable::Load(CComPtr<IMSAdminBase> &pIMeta, 
							  METADATA_HANDLE hMDComp) 
{
	ASSERT(pIMeta.p != NULL);

	USES_CONVERSION;
	HRESULT hr;

	//If it's already loaded, unload then reload
	if (m_fLoaded) {
		Unload();
	}
	
	int iKeyIndex;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	LPTSTR tszSubKey;
	int iLoc;
	CClassInfo *pCNewClass;

	//Load the classes
	METADATA_HANDLE hMDClasses = NULL;

	// Open the Schema/Classes subkey
	hr = pIMeta->OpenKey(hMDComp, 
			             L"Schema/Classes", 
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClasses);
	if (FAILED(hr)) {
		return hr;
	};

	// For each subkey
	iKeyIndex = 0;
	hr = pIMeta->EnumKeys(hMDClasses, 
						  NULL, 
						  wszSubKey, 
						  iKeyIndex);
	while (SUCCEEDED(hr)) {
		tszSubKey = W2T(wszSubKey);

		// Create the new class	
		pCNewClass = new CClassInfo;
		if (pCNewClass == NULL) {
			hr = E_OUTOFMEMORY;
			goto LError;
		}
		hr = pCNewClass->Init(tszSubKey); 
		if (FAILED(hr)) {
			delete pCNewClass;
			goto LError;
		}

		// Load the class properties
		hr = pCNewClass->Load(pIMeta, hMDClasses);
		if (FAILED(hr)) {
			delete pCNewClass;
			goto LError;
		}

		// Add it to the hash table
		iLoc = Hash(tszSubKey);
		pCNewClass->m_pCHashNext = m_rgCClassTable[iLoc];
		m_rgCClassTable[iLoc] = pCNewClass;

		iKeyIndex++;
		hr = pIMeta->EnumKeys(hMDClasses, 
							  NULL, 
							  wszSubKey, 
							  iKeyIndex);
	}

	//Make sure we ran out of items
	if (!(HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS)) {
		goto LError;
	}

	// Close the schema properties key
	pIMeta->CloseKey(hMDClasses);

	m_fLoaded = TRUE;

	return S_OK;

LError:
	if (hMDClasses != NULL) {
		pIMeta->CloseKey(hMDClasses);
	}

	// Cleanup the entries we loaded
	Unload();

	return hr;
}

/*===================================================================
CClassInfo::Unload

Unloads the class information table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CClassInfoTable::Unload() 
{
	int iIndex;
	CClassInfo *pCDeleteClass;

	// For each hash table entry
	for (iIndex =0; iIndex < CLASS_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCClassTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDeleteClass = m_rgCClassTable[iIndex];
			m_rgCClassTable[iIndex] = pCDeleteClass->m_pCHashNext;
			delete pCDeleteClass;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CCClasssInfoTable::GetClassInfo

Get the CClassInfo (class info) object from the hash table given
the class name

Parameters:
	tszClassName	Name of the class to get info for

Returns:
	NULL on failure
	Pointer to the CClassInfo object on success
===================================================================*/
CClassInfo *CClassInfoTable::GetClassInfo(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	CClassInfo *pCCurClass;

	// Go to the table location
	pCCurClass = m_rgCClassTable[Hash(tszName)];

	// Look at all of the entries
	while ((pCCurClass != NULL) && 
		   (_tcscmp(pCCurClass->m_tszName, tszName) != 0)) {
		pCCurClass = pCCurClass->m_pCHashNext;
	}

	return pCCurClass; // Will be NULL if not found
}

/*===================================================================
CClassInfoTable::Hash

Private function to get a hash value from a class name for the
class table.

Parameters:
	tszName		Name to hash

Returns:
	Hash value of name
===================================================================*/
unsigned int CClassInfoTable::Hash(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		uiSum += tszName[uiIndex];
	}

	return (uiSum % CLASS_HASH_SIZE);
}


/*------------------------------------------------------------------
 * C M e t a S c h e m a
 */

/*===================================================================
CMetaSchema::Init

Constructor

Parameters:
	pIMeta			ATL Smart pointer to the metabase
	tszMachineName	Name of machine the schema is for

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CMetaSchema::Init(const CComPtr<IMSAdminBase> &pIMeta, 
						  LPCTSTR tszMachineName) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszMachineName);

	m_pIMeta = pIMeta;

	m_tszMachineName = new TCHAR[_tcslen(tszMachineName) + 1];
	if (m_tszMachineName == NULL)
		return E_OUTOFMEMORY;
	_tcscpy(m_tszMachineName, tszMachineName);

	return S_OK;
}

/*===================================================================
CMetaSchema::GetPropInfo

Get the CPropInfo (property info) object for a given id

Parameters:
	dwId	Id of property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchema::GetPropInfo(DWORD dwId) 
{
	// Make sure the property table is up to date
	if (m_fPropTableDirty) {
		HRESULT hr;

		hr = LoadPropTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Pass on the call
	return m_CPropInfoTable.GetPropInfo(dwId);
}

/*===================================================================
CMetaSchema::GetPropInfo

Get the CPropInfo (property info) object for a given name

Parameters:
	tszName		Name of property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchema::GetPropInfo(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	// Make sure the property table is up to date
	if (m_fPropTableDirty) {
		HRESULT hr;

		hr = LoadPropTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Pass on the call
	return m_CPropInfoTable.GetPropInfo(tszName);
}

/*===================================================================
CMetaSchema::GetClassInfo

Get the CClassInfo (class info) object for a given class name

Parameters:
	tszClassName	Name of the class to get info for

Returns:
	NULL on failure
	Pointer to the CClassInfo object on success
===================================================================*/
CClassInfo *CMetaSchema::GetClassInfo(LPCTSTR tszClassName) {
	ASSERT_STRING(tszClassName);

	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Pass on the call
	return m_CClassInfoTable.GetClassInfo(tszClassName);
}

/*===================================================================
CMetaSchema:::GetClassPropInfo

Get the CClassPropInfo (class property info) object for a given 
class name and property id.

Parameters:
	tszClassName	Name of the class get property from
	dwPropId		Id of property to get info for

Returns:
	NULL on failure
	Pointer to the CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchema::GetClassPropInfo(LPCTSTR tszClassName, 
											  DWORD dwPropId) 
{
	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Get the class
	CClassInfo *pCClassInfo;

	pCClassInfo = m_CClassInfoTable.GetClassInfo(tszClassName);
	
	if (pCClassInfo == NULL) {
		return NULL;
	}
	else {
		// Pass on the call
		return pCClassInfo->GetProperty(dwPropId);
	}
}

/*===================================================================
CMetaSchema::GetMandatoryClassPropList

Get the list of optional class properties for a class name.

Parameters:
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first optional CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchema::GetMandatoryClassPropList(LPCTSTR tszClassName) 
{
	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Get the class
	CClassInfo *pCClassInfo;

	pCClassInfo = m_CClassInfoTable.GetClassInfo(tszClassName);
	
	if (pCClassInfo == NULL) {
		return NULL;
	}
	else {
		// Pass on the call
		return pCClassInfo->GetMandatoryPropList();
	}
}

/*===================================================================
CMetaSchema::GetOptionalClassPropList

Get the list of optional class properties for a class name.

Parameters:
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first optional CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchema::GetOptionalClassPropList(LPCTSTR tszClassName) 
{
	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Get the class
	CClassInfo *pCClassInfo;

	pCClassInfo = m_CClassInfoTable.GetClassInfo(tszClassName);
	
	if (pCClassInfo == NULL) {
		return NULL;
	}
	else {
		// Pass on the call
		return pCClassInfo->GetOptionalPropList();
	}
}

/*===================================================================
CMetaSchema::ChangeNotification

Processes change events effecting the machine where the schema is
located.  If the dirty flag for the property and class tables is not 
already set a call to Unload() is made to free up memory no longer 
needed.

Parameters:
	tszChangedKey		Cannonized key where change took place
	pcoChangeObject		Pointer to the change event information

Returns:
	Nothing
===================================================================*/
void CMetaSchema::ChangeNotification(LPTSTR tszKey,
									 MD_CHANGE_OBJECT *pcoChangeObject) 
{
	ASSERT_POINTER(pcoChangeObject, MD_CHANGE_OBJECT);

	USES_CONVERSION;
	LPTSTR tszChangedKey;

	tszChangedKey = tszKey;

    // Skip the slash 
    if (*tszChangedKey != _T('\0') && *tszChangedKey == _T('/')) {
        tszChangedKey++;
    }

	if (_tcsnicmp(tszChangedKey, _T("schema/"), 7) == 0) {
		// It effects a "Schema" subkey
		if ((_tcsnicmp(tszChangedKey, _T("schema/properties/"), 18) == 0) ||
			(_tcsicmp(tszChangedKey, _T("schema/properties")) == 0)) {
			// It effects "Schema/Properties"
			if (!m_fPropTableDirty) {
				// Unload the prop table
				m_CPropInfoTable.Unload();
			}
			m_fPropTableDirty = TRUE;
		}
		else if ((_tcsnicmp(tszChangedKey, _T("schema/classes/"), 15) == 0) ||
				 (_tcsicmp(tszChangedKey, _T("schema/classes")) == 0)) {
			// It effects "Schema/Classes"
			if (!m_fClassTableDirty) {
				// Unload the class table
				m_CClassInfoTable.Unload();
			}
			m_fClassTableDirty = TRUE;
		}
	}
	else if (_tcsicmp(tszChangedKey, _T("schema")) == 0) {
		// Just the "Schema" key was changed
		if (!m_fPropTableDirty) {
			// Unload the prop table
			m_CPropInfoTable.Unload();
		}
		m_fPropTableDirty = TRUE;

		if (!m_fClassTableDirty) {
			// Unload the class table
			m_CClassInfoTable.Unload();
		}
		m_fClassTableDirty = TRUE;
	}
}

/*===================================================================
CMetaSchema::LoadPropTable

(Re)loads a dirty property table

Parameters:
	None

Returns:
	S_OK on success
===================================================================*/
HRESULT CMetaSchema::LoadPropTable() 
{
	USES_CONVERSION;
	HRESULT hr;

	// Open the Machine key
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   L"",              // schema path moved to /schema
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Load the properties
	hr = m_CPropInfoTable.Load(m_pIMeta, hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Close the Machine key
	m_pIMeta->CloseKey(hMDKey);

	m_fPropTableDirty = FALSE;

	return S_OK;
}

/*===================================================================
CMetaSchema::LoadClassTable

(Re)loads a dirty class table

Parameters:
	None

Returns:
	S_OK on success
===================================================================*/
HRESULT CMetaSchema::LoadClassTable() 
{
	USES_CONVERSION;
	HRESULT hr;

	// Open the Machine key
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   L"",              // schema path moved to /schema
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Load the properties
	hr = m_CClassInfoTable.Load(m_pIMeta, hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Close the Machine key
	m_pIMeta->CloseKey(hMDKey);

	m_fClassTableDirty = FALSE;

	return S_OK;
}


/*------------------------------------------------------------------
 * C M e t a S c h e m a T a b l e
 */

/*===================================================================
CMetaSchemaTable::CMetaSchemaTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMetaSchemaTable::CMetaSchemaTable() : m_dwNumRef(1),
									   m_fLoaded(FALSE)
{
	m_CMSAdminBaseSink = new CComObject<CMSAdminBaseSink>;
	m_CMSAdminBaseSink->AddRef();

	// Clear the hash table
	memset(m_rgCSchemaTable, 0, SCHEMA_HASH_SIZE * sizeof(CMetaSchema *));
}

/*===================================================================
CMetaSchemaTable::~CMetaSchemaTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMetaSchemaTable::~CMetaSchemaTable() 
{
	TRACE0("MetaUtil: CMetaSchemaTable::~CMetaSchemaTable\n");

	if (m_fLoaded) {
		Unload();
	}

	DWORD dwTemp;

	if (m_CMSAdminBaseSink != NULL) {
		dwTemp = m_CMSAdminBaseSink->Release();

		TRACE1("MetaUtil: CMetaSchemaTable::~CMetaSchemaTable Release Sink %i\n", dwTemp);
	}
}

/*===================================================================
CMetaSchemaTable::Load

Loads/Creates the schema information for all of the machines

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMetaSchemaTable::Load() 
{
	USES_CONVERSION;
	HRESULT hr;

	if (m_fLoaded) {
		Unload();
	}

	// Create an instance of the Metabase Admin Base Object
	// Need a seperate instance so we pick up changes made
	// by our "parent" MetaUtil object family.
	hr = ::CoCreateInstance(CLSID_MSAdminBase,
						    NULL,
						    CLSCTX_ALL,
					        IID_IMSAdminBase,
						    (void **)&m_pIMeta);
	if (FAILED(hr)) {
		m_pIMeta = NULL;
		return;
	}

	// Build the schema list
	int iKeyIndex;
	wchar_t wszMDSubKey[ADMINDATA_MAX_NAME_LEN];
	CMetaSchema *pCNewSchema;
	int iLoc;

	// For each subkey of root
	iKeyIndex = 0;
	hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
							NULL, 
							wszMDSubKey, 
							iKeyIndex);
	while (SUCCEEDED(hr)) {
		// Create the new schema
		pCNewSchema = new CMetaSchema;
		if (pCNewSchema == NULL) {
			goto LError;
		}
		hr = pCNewSchema->Init(m_pIMeta, W2T(wszMDSubKey));
		if (FAILED(hr)) {
			delete pCNewSchema;
			goto LError;
		}

		// Add it to the hash table
		iLoc = Hash(W2T(wszMDSubKey));
		pCNewSchema->m_pCNextSchema = m_rgCSchemaTable[iLoc];
		m_rgCSchemaTable[iLoc] = pCNewSchema;

		// Next
		iKeyIndex++;
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								NULL, 
								wszMDSubKey, 
								iKeyIndex);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Setup notification
	if (m_CMSAdminBaseSink != NULL) {
		m_CMSAdminBaseSink->Connect(m_pIMeta, this);
	}

	m_fLoaded = TRUE;

	return;

LError:
	// Back out of the load
	Unload();	
}

/*===================================================================
CMetaSchemaTable::Unload

Unloads the schema table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMetaSchemaTable::Unload() {
	int iIndex;
	CMetaSchema *pCDelete;

	// Stop notification
	if (m_CMSAdminBaseSink != NULL) {
		m_CMSAdminBaseSink->Disconnect();
	}

	m_pIMeta = NULL;

	// For each hash table entry
	for (iIndex =0; iIndex < SCHEMA_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCSchemaTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDelete = m_rgCSchemaTable[iIndex];
			m_rgCSchemaTable[iIndex] = pCDelete->m_pCNextSchema;
			delete pCDelete;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CMetaSchemaTable::GetPropInfo

Get the CPropInfo (property info) object for a given key and id

Parameters:
	tszKey		Key the property is located under
	dwPropId	Id of the property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchemaTable::GetPropInfo(LPCTSTR tszKey, 
										 DWORD dwPropId) 
{
	ASSERT_STRING(tszKey);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetPropInfo(dwPropId);
	}
	else {
		return NULL;
	}
}

/*===================================================================
CMetaSchemaTable::GetPropInfo

Get the CPropInfo (property info) object for a given key and name

Parameters:
	tszKey		Key the property is located under
	tszPropName	Name of the property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchemaTable::GetPropInfo(LPCTSTR tszKey, 
										 LPCTSTR tszPropName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszPropName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetPropInfo(tszPropName);
	}
	else {
		return NULL;
	}
}

/*===================================================================
CMetaSchemaTable::GetClassInfo

Get the CClassInfo (class info) object for a given key and class name

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class to get info for

Returns:
	NULL on failure
	Pointer to the CClassInfo object on success
===================================================================*/
CClassInfo *CMetaSchemaTable::GetClassInfo(LPCTSTR tszKey, 
										   LPCTSTR tszClassName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetClassInfo(tszClassName);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::GetClassPropInfo

Get the CClassPropInfo (class property info) object for a given 
key, class name and property id.

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class get property from
	dwPropId		Id of property to get info for

Returns:
	NULL on failure
	Pointer to the CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchemaTable::GetClassPropInfo(LPCTSTR tszKey, 
												   LPCTSTR tszClassName, 
												   DWORD dwPropId) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetClassPropInfo(tszClassName, dwPropId);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::GetMandatoryClassPropList

Get the list of mandatory class properties for a given key and class
name.

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first mandatory CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchemaTable::GetMandatoryClassPropList(LPCTSTR tszKey, 
															LPCTSTR tszClassName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetMandatoryClassPropList(tszClassName);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::GetOptionalClassPropList

Get the list of optional class properties for a given key and class
name.

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first optional CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchemaTable::GetOptionalClassPropList(LPCTSTR tszKey, 
														   LPCTSTR tszClassName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}
	
	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetOptionalClassPropList(tszClassName);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::SinkNotify

Metabase change notification callback from CMSAdminBaseSink.  Either
determines a need to reload all of the schema information or sends
the message on to the appropriate CMetaSchema object.

Parameters:
	dwMDNumElements		Number of change events
	pcoChangeObject		Array of change events

Returns:
	S_OK always
===================================================================*/
HRESULT CMetaSchemaTable::SinkNotify(DWORD dwMDNumElements, 
									 MD_CHANGE_OBJECT pcoChangeObject[]) 
{
	ASSERT(IsValidAddress(pcoChangeObject, dwMDNumElements * sizeof(MD_CHANGE_OBJECT), FALSE));

	USES_CONVERSION;
	DWORD dwIndex;
	CMetaSchema *pCMetaSchema;

	// For each event
	for (dwIndex = 0; dwIndex < dwMDNumElements; dwIndex++) {
		// Figure out what machine it's for
		TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
		_tcscpy(tszKey, W2T(pcoChangeObject[dwIndex].pszMDPath));
		CannonizeKey(tszKey);
		pCMetaSchema = GetSchema(tszKey);

		// If the machine is not found
		if (pCMetaSchema == NULL) {
			// Reload the schema table
			Load();
		}
		else {
			// Send it to the appropriate machine
			pCMetaSchema->ChangeNotification(tszKey, &(pcoChangeObject[dwIndex]));
		}
	}

	return S_OK;
}

/*===================================================================
CMetaSchemaTable::GetSchema

Get the schema object that contains information on the given key.

Parameters:
	tszKey			Approxiamte key to get schema information for.

Returns:
	NULL on failure
	Pointer to the CMetaSchema object on success
===================================================================*/
CMetaSchema *CMetaSchemaTable::GetSchema(LPCTSTR tszKey) {

	// Extract the machine name
	TCHAR tszMachineName[ADMINDATA_MAX_NAME_LEN];
	::GetMachineFromKey(tszKey, tszMachineName);

	// Find the right schema
	CMetaSchema *pCCurSchema;
	
	pCCurSchema =m_rgCSchemaTable[Hash(tszMachineName)];
	while ((pCCurSchema != NULL) && 
		   (_tcsicmp(pCCurSchema->m_tszMachineName, tszMachineName) != 0)) {
		pCCurSchema = pCCurSchema->m_pCNextSchema;
	}

	return pCCurSchema; // Will be NULL if not found
}

/*===================================================================
CMetaSchemaTable::Hash

Private function to get a hash value from a machine name for the
schema table.

Parameters:
	tszName		Machinea name to hash

Returns:
	Hash value of name
===================================================================*/
unsigned int CMetaSchemaTable::Hash(LPCTSTR tszName) {
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		uiSum += _totlower(tszName[uiIndex]);
	}

	return (uiSum % SCHEMA_HASH_SIZE);
}

/*------------------------------------------------------------------
 * C M S A d m i n B a s e S i n k
 */

/*===================================================================
CMSAdminBaseSink::CMSAdminBaseSink

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMSAdminBaseSink::CMSAdminBaseSink() : m_fConnected(FALSE),
									   m_dwCookie(0),
									   m_pCMetaSchemaTable(NULL)
{
}

/*===================================================================
CMSAdminBaseSink::~CMSAdminBaseSink

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMSAdminBaseSink::~CMSAdminBaseSink() 
{
	TRACE0("MetaUtil: CMSAdminBaseSink::~CMSAdminBaseSink !!!!!!!!!!!\n");

	// Make sure we disconnected
	if (m_fConnected) {
		Disconnect();
	}
}

/*===================================================================
CMSAdminBaseSink::SinkNotify

Entry point for notification events from the metabase admin base
object.

Parameters:
	dwMDNumElements		Number of change events
	pcoChangeObject		Array of change events

Returns:
	E_FAIL	if m_pCMetaSchemaTable == NULL
	S_OK	on success
===================================================================*/
STDMETHODIMP CMSAdminBaseSink::SinkNotify(DWORD dwMDNumElements, 
										  MD_CHANGE_OBJECT pcoChangeObject[]) 
{
	TRACE0("MetaUtil: CMSAdminBaseSink::SinkNotify\n");
	ASSERT(IsValidAddress(pcoChangeObject, dwMDNumElements * sizeof(MD_CHANGE_OBJECT), FALSE));

	if (m_pCMetaSchemaTable == NULL) {
		return E_FAIL;
	}

	// Pass on the notification
	return m_pCMetaSchemaTable->SinkNotify(dwMDNumElements, pcoChangeObject);	
}

/*===================================================================
CMSAdminBaseSink::ShutdownNotify

Entry point for the shutdown notification event from the metabase 
admin base object.

Parameters:
	None

Returns:
	ERROR_NOT_SUPPORTE always
===================================================================*/
STDMETHODIMP CMSAdminBaseSink::ShutdownNotify() {
	return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
}

/*===================================================================
CMSAdminBaseSink::Connect

Begins notification of change events.  Connects to the metabase admin
base object.

Parameters:
	pIMeta				Pointer to the metabase admin base object
	pCMetaSchemaTable	Pointer to the schema table so that events
						can be sent back to it.

Returns:
	E_NOINTERFACE if can not convert IMSAdminBase to 
		IConnectionPointContainer.
	S_OK on success
===================================================================*/
HRESULT CMSAdminBaseSink::Connect(CComPtr<IMSAdminBase> &pIMeta, 
							      CMetaSchemaTable *pCMetaSchemaTable)
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_POINTER(pCMetaSchemaTable, CMetaSchemaTable);

	HRESULT hr;

	if (m_fConnected) {
		Disconnect();
	}

	m_pCMetaSchemaTable = pCMetaSchemaTable;

	// Get the connection container
	CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pIMetaConnContainer;

	pIMetaConnContainer = pIMeta;
	if (pIMetaConnContainer == NULL) {
		// Failure to change interfaces
		return E_NOINTERFACE;
	}

	// Get the connection point
	hr = pIMetaConnContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &m_pIMetaConn);
	if (FAILED(hr)) {
		return hr;
	}

	// Advise (connect)
	AddRef();
	m_pIMetaConn->Advise((IMSAdminBaseSink *) this, &m_dwCookie);

	m_fConnected = TRUE;

	return S_OK;
}

/*===================================================================
CMSAdminBaseSink::Disconnect

Stops notification of change events.  Disconnects from the metabase
admin base object.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMSAdminBaseSink::Disconnect()
{
	if (!m_fConnected) {
		// Not connected
		return;
	}

	// Stop notification
	m_pIMetaConn->Unadvise(m_dwCookie);

	// No longer needed
	m_pIMetaConn = NULL;
	m_pCMetaSchemaTable = NULL;

	m_fConnected = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\mutilobj.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MUtilObj.cpp

Owner: t-BrianM

This file contains implementation of the main MetaUtil class.
Except CheckSchema is in ChkSchm.cpp and CheckKey is in ChkKey.cpp
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "keycol.h"

/*------------------------------------------------------------------
 * C M e t a U t i l  (edit and general portions)
 */

/*===================================================================
CMetaUtil::CMetaUtil

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMetaUtil::CMetaUtil() : m_dwMaxPropSize(10 * 1024), //  10k
						 m_dwMaxKeySize(100 * 1024), // 100k
						 m_dwMaxNumErrors(100)
{
}

/*===================================================================
CMetaUtil::FinalConstruct

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
HRESULT CMetaUtil::FinalConstruct() 
{
	HRESULT hr;

	// Create the metabase admin base object
	hr = ::CoCreateInstance(CLSID_MSAdminBase,
						    NULL,
						    CLSCTX_ALL,
					        IID_IMSAdminBase,
						    (void **)&m_pIMeta);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create a schema table
	m_pCSchemaTable = new CMetaSchemaTable;
	if (m_pCSchemaTable == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	
	return S_OK;
}

/*===================================================================
CMetaUtil::FinalRelease

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMetaUtil::FinalRelease() 
{
	m_pIMeta = NULL;

	if (m_pCSchemaTable != NULL)
		m_pCSchemaTable->Release();
}

/*===================================================================
CMetaUtil::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/

STDMETHODIMP CMetaUtil::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMetaUtil,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}

	return S_FALSE;
}

/*===================================================================
CMetaUtil::EnumKeys

Do a flat (non-recursive) enumeration of subkeys

Parameters:
    bstrBaseKey	[in] Key to enumerate the subkeys of
	ppIReturn	[out, retval] interface for the ouput key collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::EnumKeys(BSTR bstrBaseKey, 
								 IKeyCollection ** ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::EnumKeys\n");

	ASSERT_NULL_OR_POINTER(bstrBaseKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IKeyCollection *);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Create the Flat Keys Collection
	CComObject<CFlatKeyCollection> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CFlatKeyCollection>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, OLE2T(bstrBaseKey));
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IKeyCollection
	hr = pObj->QueryInterface(IID_IKeyCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CMetaUtil::EnumAllKeys

Do a deep (recursive) enumeration of subkeys

Parameters:
    bstrBaseKey	[in] Key to enumerate the subkeys of
	ppIReturn	[out, retval] interface for the ouput key collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::EnumAllKeys(BSTR bstrBaseKey, 
									IKeyCollection ** ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::EnumAllKeys\n");

	ASSERT_NULL_OR_POINTER(bstrBaseKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IKeyCollection *);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Create the Flat Keys Collection
	CComObject<CDeepKeyCollection> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CDeepKeyCollection>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, OLE2T(bstrBaseKey));
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IKeyCollection
	hr = pObj->QueryInterface(IID_IKeyCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CMetaUtil::EnumProperties

Do an enumeration of properties

Parameters:
    bstrBaseKey	[in] Key to enumerate the properties of
	ppIReturn	[out, retval] interface for the ouput property collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::EnumProperties(BSTR bstrKey, 
									   IPropertyCollection **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::EnumProperties\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IKeyCollection *);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Create the Flat Keys Collection
	CComObject<CPropertyCollection> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CPropertyCollection>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_pCSchemaTable, OLE2T(bstrKey));
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IPropertyCollection
	hr = pObj->QueryInterface(IID_IPropertyCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CMetaUtil::CreateKey

Create a new key

Parameters:
    bstrKey		[in] Key to create

Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CreateKey(BSTR bstrKey)
{
	TRACE0("MetaUtil: CMetaUtil::CreateKey\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);

	if (bstrKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::CreateKey(m_pIMeta, tszKey);
}

/*===================================================================
CMetaUtil::DeleteKey

Delete a key

Parameters:
    bstrKey		[in] Key to delete

Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::DeleteKey(BSTR bstrKey)
{
	TRACE0("MetaUtil: CMetaUtil::DeleteKey\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);

	if (bstrKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::DeleteKey(m_pIMeta, tszKey);
}

/*===================================================================
CMetaUtil::RenameKey

Rename a key

Parameters:
    bstrOldName		[in] Original Key Name
	bstrNewName		[in] New key name

Returns:
	E_INVALIDARG if bstrOldName == NULL OR bstrNewName == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::RenameKey(BSTR bstrOldName, BSTR bstrNewName)
{
	TRACE0("MetaUtil: CMetaUtil::RenameKey\n");
	ASSERT_NULL_OR_POINTER(bstrOldName, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrNewName, OLECHAR);

	if ((bstrOldName == NULL) || (bstrNewName == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	TCHAR tszOldName[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszNewName[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszOldName, OLE2T(bstrOldName));
	CannonizeKey(tszOldName);

	_tcscpy(tszNewName, OLE2T(bstrNewName));
	CannonizeKey(tszNewName);

	// Figure out the key's common root
	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	int i;

	i = 0;
	while ((tszOldName[i] != _T('\0')) && (tszNewName[i] != _T('\0')) &&
		   (tszOldName[i] == tszNewName[i])) {
		tszParent[i] = tszOldName[i];
		i++;
	}
	if (i == 0) {
		// Nothing in common
		tszParent[i] = _T('\0');
	}
	else {
		// Back up to the first slash
		while ((i > 0) && (tszParent[i] != _T('/'))) {
			i--;
		}

		// Cut it off at the slash
		tszParent[i] = _T('\0');
	}

	int iParentKeyLen;
	iParentKeyLen = _tcslen(tszParent);

	LPTSTR tszRelOldName;
	LPTSTR tszRelNewName;

	// Figure out the relative new and old names
	tszRelOldName = tszOldName + iParentKeyLen;
	if (*tszRelOldName == _T('/')) {
		tszRelOldName++;
	}

	tszRelNewName = tszNewName + iParentKeyLen;
	if (*tszRelNewName == _T('/')) {
		tszRelNewName++;
	}

	// Open the parent
	METADATA_HANDLE hMDParentKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(tszParent),
						   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDParentKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Rename the key
	hr = m_pIMeta->RenameKey(hMDParentKey,
							 T2W(tszRelOldName), 
							 T2W(tszRelNewName));
	if (FAILED(hr)) {
		m_pIMeta->CloseKey(hMDParentKey);
		return ::ReportError(hr);
	}

	// Close the parent
	m_pIMeta->CloseKey(hMDParentKey);

	return S_OK;
}

/*===================================================================
CMetaUtil::CopyKey

Copy a key

Parameters:
    bstrSrcKey		[in] Source Key Name
	bstrDestKey		[in] Destination key name
	fOverwrite		[in] If true then already existing properties
					at destination are overwritten.

Returns:
	E_INVALIDARG if bstrSrcKey == NULL OR bstrDestKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CopyKey(BSTR bstrSrcKey, BSTR bstrDestKey, BOOL fOverwrite)
{
	TRACE0("MetaUtil: CMetaUtil::CopyKey\n");
	ASSERT_NULL_OR_POINTER(bstrSrcKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrDestKey, OLECHAR);

	if ((bstrSrcKey == NULL) || (bstrDestKey == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszSrcKey[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszDestKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszSrcKey, OLE2T(bstrSrcKey));
	CannonizeKey(tszSrcKey);

	_tcscpy(tszDestKey, OLE2T(bstrDestKey));
	CannonizeKey(tszDestKey);

	return ::CopyKey(m_pIMeta, tszSrcKey, tszDestKey, fOverwrite, TRUE);
}

/*===================================================================
CMetaUtil::MoveKey

Move a key

Parameters:
    bstrSrcKey		[in] Source Key Name
	bstrDestKey		[in] Destination key name
	fOverwrite		[in] If true then already existing properties
					at destination are overwritten.

Returns:
	E_INVALIDARG if bstrSrcKey == NULL OR bstrDestKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::MoveKey(BSTR bstrSrcKey, BSTR bstrDestKey, BOOL fOverwrite)
{
	TRACE0("MetaUtil: CMetaUtil::MoveKey\n");
	ASSERT_NULL_OR_POINTER(bstrSrcKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrDestKey, OLECHAR);

	if ((bstrSrcKey == NULL) || (bstrDestKey == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszSrcKey[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszDestKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszSrcKey, OLE2T(bstrSrcKey));
	CannonizeKey(tszSrcKey);

	_tcscpy(tszDestKey, OLE2T(bstrDestKey));
	CannonizeKey(tszDestKey);

	return ::CopyKey(m_pIMeta, tszSrcKey, tszDestKey, fOverwrite, FALSE);
}

/*===================================================================
CMetaUtil::GetProperty

Gets a property object from the metabase.

Parameters:
    bstrKey		[in] Key containing property to get
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for retreived property.
	
Returns:
	E_INVALIDARG if bstrKey == NULL or ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::GetProperty(BSTR bstrKey, 
									VARIANT varId, 
									IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::GetProperty\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if ((bstrKey == NULL) || (ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::GetProperty(m_pIMeta, m_pCSchemaTable, tszKey, varId, ppIReturn);
}

/*===================================================================
CMetaUtil::CreateProperty

Creates a property object that can be written to the Metbase or
retreives the property if it already exists.

Parameters:
    bstrKey		[in] Key containing property to get
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for retreived property.
	
Returns:
	E_INVALIDARG if bstrKey == NULL or ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CreateProperty(BSTR bstrKey, 
									   VARIANT varId, 
									   IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::CreateProperty\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if ((bstrKey == NULL) || (ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::CreateProperty(m_pIMeta, m_pCSchemaTable, tszKey, varId, ppIReturn);
}

/*===================================================================
CMetaUtil::DeleteProperty

Deletes a property from the metabase.

Parameters:
    bstrKey		[in] Key containing property to get
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	
Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::DeleteProperty(BSTR bstrKey, VARIANT varId)
{
	TRACE0("MetaUtil: CMetaUtil::DeleteProperty\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);

	if (bstrKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::DeleteProperty(m_pIMeta, m_pCSchemaTable, tszKey, varId);
}

/*===================================================================
CMetaUtil::ExpandString

Expands a string with environment variables.  Maximum output is 1024
bytes.

Parameters:
    bstrIn		[in] String to expand
	pbstrRet	[out, retval] Expanded string
	
Returns:
	E_INVALIDARG if bstrIn == NULL or pbstrRet == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::ExpandString(BSTR bstrIn, BSTR *pbstrRet)
{
	ASSERT_POINTER(bstrIn, OLECHAR);
	ASSERT_NULL_OR_POINTER(pbstrRet, BSTR);

	if ((bstrIn == NULL) || (pbstrRet == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszRet[1024];
	int iRet;

	iRet = ExpandEnvironmentStrings(OLE2T(bstrIn), tszRet, 1024);
	if (iRet == 0) {
		::ReportError(GetLastError());
	}

	*pbstrRet = T2BSTR(tszRet);

	return S_OK;
}

/*===================================================================
MetaUtil::PropIdToName

Converts a property Id to its name, as listed in 
_Machine_/Schema/Properties/Names

Parameters:
    bstrKey		[in] Approximate key where property is located, 
				needed to determine what schema to use.
	lId			[in] Id of property
	pbstrName	[out, retval] Output name of property
	
Returns:
	E_INVALIDARG if bstrKey == NULL or pbstrName == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::PropIdToName(BSTR bstrKey, long lId, BSTR *pbstrName)
{
	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(pbstrName, BSTR);

	if ((bstrKey == NULL) || (pbstrName == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
	CPropInfo *pCPropInfo;

	// Convert the base key to cannonical form
	_tcscpy(tszKey, OLE2T(bstrKey));
	CannonizeKey(tszKey);

	// Get the property info from the Schema Table
	pCPropInfo = m_pCSchemaTable->GetPropInfo(tszKey, lId);

	// Did we find it?  Is there a name entry?
	if ((pCPropInfo == NULL) || (pCPropInfo->GetName() == NULL)) {
		// No, return ""
		*pbstrName = T2BSTR(_T(""));
	}
	else {
		// Yes, return the name
		*pbstrName = T2BSTR(pCPropInfo->GetName());
	}
	return S_OK;
}

/*===================================================================
MetaUtil::PropNameToId

Converts a property name to its id, as listed in 
_Machine_/Schema/Properties/Names

Parameters:
    bstrKey		[in] Approximate key where property is located, 
				needed to determine what schema to use.
	pbstrName	[in] Name of property
	lId			[out, retval] Output id of property
	
Returns:
	E_INVALIDARG if bstrKey == NULL OR bstrName == NULL OR plId == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::PropNameToId(BSTR bstrKey, BSTR bstrName, long *plId)
{
	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrName, OLECHAR);
	ASSERT_NULL_OR_POINTER(plId, long);

	if ((bstrKey == NULL) || (bstrName == NULL) || (plId == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
	CPropInfo *pCPropInfo;

	// Convert the base key to cannonical form
	_tcscpy(tszKey, OLE2T(bstrKey));
	CannonizeKey(tszKey);

	// Get the property info from the Schema Table
	pCPropInfo = m_pCSchemaTable->GetPropInfo(tszKey, OLE2T(bstrName));

	// Did we find it?
	if (pCPropInfo == NULL) {
		// No, return 0
		*plId = 0;
	}
	else {
		// Yes, return the id
		*plId = pCPropInfo->GetId();
	}
	return S_OK;
}

/*===================================================================
MetaUtil::get_Config

Gets the value of a configuration setting.

Valid Settings:
	MaxPropertySize
	MaxKeySize
	MaxNumberOfErrors

Parameters:
    bstrSetting		[in] Name of the setting
	pvarValue		[out, retval] Value of the setting
	
Returns:
	E_INVALIDARG if bstrSettting doesn't match any known settings
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::get_Config(BSTR bstrSetting, VARIANT *pvarValue)
{
	ASSERT_POINTER(bstrSetting, OLECHAR);
	ASSERT_POINTER(pvarValue, VARIANT);

	USES_CONVERSION;
	LPTSTR tszSetting;

    if( !bstrSetting )
    {
        return ::ReportError(E_INVALIDARG);
    }

	VariantInit(pvarValue);
	tszSetting = OLE2T(bstrSetting);

	if (_tcsicmp(tszSetting, _T("MaxPropertySize")) == 0) {
		V_VT(pvarValue) = VT_I4;
		V_I4(pvarValue) = m_dwMaxPropSize;
	}
	else if (_tcsicmp(tszSetting, _T("MaxKeySize")) == 0) {
		V_VT(pvarValue) = VT_I4;
		V_I4(pvarValue) = m_dwMaxKeySize;
	}
	else if (_tcsicmp(tszSetting, _T("MaxNumberOfErrors")) == 0) {
		V_VT(pvarValue) = VT_I4;
		V_I4(pvarValue) = m_dwMaxNumErrors;
	}
	else {
		return ::ReportError(E_INVALIDARG);
	}

	return S_OK;
}

/*===================================================================
MetaUtil::put_Config

Sets the value of a configuration setting.

Valid Settings:
	MaxPropertySize
	MaxKeySize
	MaxNumberOfErrors

Parameters:
    bstrSetting		[in] Name of the setting
	varValue		[out, retval] New value of the setting
	
Returns:
	E_INVALIDARG if bstrSettting doesn't match any known settings or
		if varValue is of an unexpected subtype.
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::put_Config(BSTR bstrSetting, VARIANT varValue)
{
	ASSERT_POINTER(bstrSetting, OLECHAR);

	USES_CONVERSION;
	HRESULT hr;
	LPTSTR tszSetting;

	tszSetting = OLE2T(bstrSetting);

	// Cleanup any IDispatch or byref stuff
	CComVariant varValue2;

	hr = VariantResolveDispatch(&varValue, &varValue2);
	if (FAILED(hr)) {
        return hr;
	}

	if (_tcsicmp(tszSetting, _T("MaxPropertySize")) == 0) {
		// Set Maximum Property Size
		switch (V_VT(&varValue2)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4
		if (FAILED(hr = VariantChangeType(&varValue2, &varValue2, 0, VT_UI4))) {
			return ::ReportError(hr);
			}

		// fallthru to VT_UI4

		case VT_UI4:

			m_dwMaxPropSize = V_UI4(&varValue2);
			break;

		default:

			// Unexpected data type
			return ::ReportError(E_INVALIDARG);
		}
	}
	else if (_tcsicmp(tszSetting, _T("MaxKeySize")) == 0) {
		// Set Maximum Key Size
		switch (V_VT(&varValue2)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4
		if (FAILED(hr = VariantChangeType(&varValue2, &varValue2, 0, VT_UI4))) {
			return ::ReportError(hr);
			}

		// fallthru to VT_UI4

		case VT_UI4:

			m_dwMaxKeySize = V_UI4(&varValue2);
			break;

		default:

			// Unexpected data type
			return ::ReportError(E_INVALIDARG);
		}
	}
	else if (_tcsicmp(tszSetting, _T("MaxNumberOfErrors")) == 0) {
		// Set Maximum Number of Errors
		switch (V_VT(&varValue2)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4
		if (FAILED(hr = VariantChangeType(&varValue2, &varValue2, 0, VT_UI4))) {
			return ::ReportError(hr);
			}

		// fallthru to VT_UI4

		case VT_UI4:

			m_dwMaxNumErrors = V_UI4(&varValue2);
			break;

		default:

			// Unexpected data type
			return ::ReportError(E_INVALIDARG);
		}
	}
	else {
		return ::ReportError(E_INVALIDARG);
	}

	return S_OK;
}

/*------------------------------------------------------------------
 * Methods also supported by the collections
 *
 * Actual implementation here to avoid redundant code
 */

/*===================================================================
CreateKey

Create a new key

Parameters:
	pIMeta		[in] Smart pointer to metabase, passed by reference
	            to avoid the copy and unneeded AddRef/Release.
				Would have used const, however the '->' operator
				would not work.
    tszKey		[in] Key to create

Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
HRESULT CreateKey(CComPtr<IMSAdminBase> &pIMeta, 
				  LPCTSTR tszKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszChild[ADMINDATA_MAX_NAME_LEN];

	::SplitKey(tszKey, tszParent, tszChild);

	// Open the parent key
	METADATA_HANDLE hMDParent;

	hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						 T2W(tszParent),
						 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					     MUTIL_OPEN_KEY_TIMEOUT,
						 &hMDParent);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create the child
	hr = pIMeta->AddKey(hMDParent, T2W(tszChild)); 
	if (FAILED(hr)) {
		pIMeta->CloseKey(hMDParent);
		return ::ReportError(hr);
	}

	// Close the parent key
	pIMeta->CloseKey(hMDParent);

	return S_OK;
}

/*===================================================================
DeleteKey

Delete a key

Parameters:
	pIMeta		[in] Smart pointer to metabase, passed by reference
	            to avoid the copy and unneeded AddRef/Release.
				Would have used const, however the '->' operator
				would not work.
    tszKey		[in] Key to delete

Returns:
	E_INVALIDARG if pbSuccess == NULL
	S_OK on success
===================================================================*/
HRESULT DeleteKey(CComPtr<IMSAdminBase> &pIMeta, 
				  LPCTSTR tszKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszChild[ADMINDATA_MAX_NAME_LEN];

	::SplitKey(tszKey, tszParent, tszChild);

	// Open the parent key
	METADATA_HANDLE hMDParent;

	hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						 T2W(tszParent),
						 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					     MUTIL_OPEN_KEY_TIMEOUT,
						 &hMDParent);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Delete the child
	hr = pIMeta->DeleteKey(hMDParent, T2W(tszChild)); 
	if (FAILED(hr)) {
		pIMeta->CloseKey(hMDParent);
		return ::ReportError(hr);
	}

	// Close the parent key
	pIMeta->CloseKey(hMDParent);

	return S_OK;
}

/*===================================================================
CMetaUtil::CopyKey

Copy or move a key

Parameters:
    bstrSrcKey		[in] Source Key Name
	bstrDestKey		[in] Destination key name
	fOverwrite		[in] If true then already existing properties
					at destination are overwritten.
	fCopy			[in] If true than copy the key, else move it

Returns:
	S_OK on success
===================================================================*/
HRESULT CopyKey(CComPtr<IMSAdminBase> &pIMeta, 
				LPTSTR tszSrcKey, 
				LPTSTR tszDestKey, 
				BOOL fOverwrite, 
				BOOL fCopy) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszSrcKey);
	ASSERT_STRING(tszDestKey);

	USES_CONVERSION;
	HRESULT hr;


	// Check for overlap
	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	int i;

	i = 0;
	while ((tszSrcKey[i] != _T('\0')) && (tszDestKey[i] != _T('\0')) &&
		   (tszSrcKey[i] == tszDestKey[i])) {
		tszParent[i] = tszSrcKey[i];
		i++;
	}
    
    // Terminate tszParent
	tszParent[i] = _T('\0');

	if (i == 0) {
		// Nothing in common

		TCHAR tszSrcParent[ADMINDATA_MAX_NAME_LEN];
		TCHAR tszSrcChild[ADMINDATA_MAX_NAME_LEN];
		TCHAR tszDestParent[ADMINDATA_MAX_NAME_LEN];
		TCHAR tszDestChild[ADMINDATA_MAX_NAME_LEN];

		::SplitKey(tszSrcKey, tszSrcParent, tszSrcChild);
		::SplitKey(tszDestKey, tszDestParent, tszDestChild);

		// Open the parent source key
		METADATA_HANDLE hMDSrcParent;

		hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 T2W(tszSrcParent),
							 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							 MUTIL_OPEN_KEY_TIMEOUT,
							 &hMDSrcParent);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}

		// Open the parent dest key
		METADATA_HANDLE hMDDestParent;

		hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 T2W(tszDestParent),
							 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							 MUTIL_OPEN_KEY_TIMEOUT,
							 &hMDDestParent);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}


		// Copy the children
		hr = pIMeta->CopyKey(hMDSrcParent, T2W(tszSrcChild), 
							 hMDDestParent, T2W(tszDestChild), 
							 fOverwrite, fCopy);
		if (FAILED(hr)) {
			pIMeta->CloseKey(hMDSrcParent);
			pIMeta->CloseKey(hMDDestParent);
			return ::ReportError(hr);
		}

		// Close the parents
		pIMeta->CloseKey(hMDSrcParent);
		pIMeta->CloseKey(hMDDestParent);
	}
	else {
		// Something in common

		// Back up to the first slash
		while ((i > 0) && (tszParent[i] != _T('/'))) {
			i--;
		}

		// Cut it off at the slash
		tszParent[i] = _T('\0');

		int iParentKeyLen;
		iParentKeyLen = _tcslen(tszParent);

		LPTSTR tszSrcChild;
		LPTSTR tszDestChild;

		// Figure out the relative new and old names
		tszSrcChild = tszSrcKey + iParentKeyLen;
		if (*tszSrcChild == _T('/')) {
			tszSrcChild++;
		}

		tszDestChild = tszDestKey + iParentKeyLen;
		if (*tszDestChild == _T('/')) {
			tszDestChild++;
		}

		// Open the parent key
		METADATA_HANDLE hMDParent;

		hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 T2W(tszParent),
							 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							 MUTIL_OPEN_KEY_TIMEOUT,
							 &hMDParent);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}


		// Copy the children
		hr = pIMeta->CopyKey(hMDParent, T2W(tszSrcChild), 
							 hMDParent, T2W(tszDestChild), 
							 fOverwrite, fCopy);
		if (FAILED(hr)) {
			pIMeta->CloseKey(hMDParent);
			return ::ReportError(hr);
		}

		// Close the parent
		pIMeta->CloseKey(hMDParent);
	}

	return S_OK;
}

/*===================================================================
GetProperty

Gets a property object from the metabase.

Parameters:
	pIMeta			[in] Smart pointer to metabase, passed by 
					reference to avoid the copy and unneeded 
					AddRef/Release.  Would have used const, however 
					the '->' operator would not work.
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key containing property to get
	varId			[in] Identifier of property to get.  Either the 
					Id (number) or Name (string).
	ppIReturn		[out, retval] Interface for retreived property.
	
Returns:
	S_OK on success
===================================================================*/
HRESULT GetProperty(CComPtr<IMSAdminBase> &pIMeta,
					CMetaSchemaTable *pCSchemaTable,
					LPCTSTR tszKey, 
					VARIANT varId, 
					IProperty **ppIReturn) 
{
	ASSERT(pIMeta != NULL);
	ASSERT_STRING(tszKey);
	ASSERT_POINTER(ppIReturn, IProperty *);

	HRESULT hr;
	DWORD dwId;

	// Figure out the property id
	hr = ::VarToMetaId(pCSchemaTable, tszKey, varId, &dwId);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create the property object
	CComObject<CProperty> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CProperty>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(pIMeta, pCSchemaTable, tszKey, dwId, FALSE);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IProperty
	hr = pObj->QueryInterface(IID_IProperty, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CreateProperty

Creates a property object that can be written to the Metbase or
retreives the property if it already exists.

Parameters:
	pIMeta			[in] Smart pointer to metabase, passed by 
					reference to avoid the copy and unneeded 
					AddRef/Release.  Would have used const, however 
					the '->' operator would not work.
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key containing property to get
	varId			[in] Identifier of property to get.  Either the 
					Id (number) or Name (string).
	ppIReturn		[out, retval] Interface for retreived property.
	
Returns:
	S_OK on success
===================================================================*/
HRESULT CreateProperty(CComPtr<IMSAdminBase> &pIMeta,
					   CMetaSchemaTable *pCSchemaTable,
					   LPCTSTR tszKey, 
					   VARIANT varId, 
					   IProperty **ppIReturn) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);
	ASSERT_POINTER(ppIReturn, IProperty *);

	HRESULT hr;
	DWORD dwId;

	// Figure out the property id
	hr = ::VarToMetaId(pCSchemaTable, tszKey, varId, &dwId);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create the property object
	CComObject<CProperty> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CProperty>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(pIMeta, pCSchemaTable, tszKey, dwId, TRUE);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IProperty
	hr = pObj->QueryInterface(IID_IProperty, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
DeleteProperty

Deletes a property from the metabase.

Parameters:
    pIMeta			[in] Smart pointer to metabase, passed by 
					reference to avoid the copy and unneeded 
					AddRef/Release.  Would have used const, however 
					the '->' operator would not work.
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key containing property to get
	varId			[in] Identifier of property to get.  Either the 
					Id (number) or Name (string).
	
Returns:
	S_OK on success
===================================================================*/
HRESULT DeleteProperty(CComPtr<IMSAdminBase> &pIMeta,
					   CMetaSchemaTable *pCSchemaTable,
					   LPTSTR tszKey, 
					   VARIANT varId) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;
	DWORD dwId;

	hr = ::VarToMetaId(pCSchemaTable, tszKey, varId, &dwId);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Open the key
	METADATA_HANDLE hMDKey;

	hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						 T2W(tszKey),
						 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					     MUTIL_OPEN_KEY_TIMEOUT,
						 &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Delete the property
	hr = pIMeta->DeleteData(hMDKey, NULL, dwId, ALL_METADATA); 
	if (FAILED(hr)) {
		pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}

	// Close the key
	pIMeta->CloseKey(hMDKey);

	return S_OK;
}

/*===================================================================
VarToMetaId

Converts a variant to a metabase property id.  IDispatch is resolved,
strings are looked up in the schema property list and integers are
converted to a DWORD.

Parameters:
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key the property is under (needed to get the 
					right schema)
	varId			[in] Variant to resolve
	pdwId			[out] Metabase property Id that varId resolved to

Returns:
	E_INVALIDARG if varId subtype isn't an integer or string
	ERROR_FILE_NOT_FOUND if varId is a BSTR that doesn't match any
		property names.
	S_OK on success
===================================================================*/
HRESULT VarToMetaId(CMetaSchemaTable *pCSchemaTable,
					LPCTSTR tszKey, 
					VARIANT varId, 
					DWORD *pdwId) 
{
	ASSERT_STRING(tszKey);
	ASSERT_POINTER(pdwId, DWORD);

	USES_CONVERSION;
	HRESULT hr;
	CComVariant varId2;
	CPropInfo *pCPropInfo;

    // VBScript can call us with a VARIANT that isn't a simple type,
    // such as VT_VARIANT|VT_BYREF.  This resolves it to a simple type.
    if (FAILED(hr = VariantResolveDispatch(&varId, &varId2)))
        return hr;

    switch (V_VT(&varId2)) {

    case VT_BSTR:
        // Look up the property name
		pCPropInfo = pCSchemaTable->GetPropInfo(tszKey, OLE2T(V_BSTR(&varId2)));
		if (pCPropInfo == NULL) {
			return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		}
		*pdwId = pCPropInfo->GetId();

		return S_OK;
        break;
        
    case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI8:
        // Coerce all integral types to VT_UI4, which is the same as REG_DWORD
        if (FAILED(hr = VariantChangeType(&varId2, &varId2, 0, VT_UI4)))
            return hr;

        // fallthru to VT_UI4

    case VT_UI4:
		*pdwId = V_UI4(&varId2);
        break;

    default:
        return E_INVALIDARG;   // Cannot handle this data type
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\propcol.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: PropCol.cpp

Owner: t-BrianM

This file contains implementation of the property collection and
property object.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "PropCol.h"


/*------------------------------------------------------------------
 * C P r o p e r t y C o l l e c t i o n
 */

/*===================================================================
CPropertyCollection::CPropertyCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyCollection::CPropertyCollection() : m_pCSchemaTable(NULL),
											 m_tszKey(NULL)
{
}

/*===================================================================
CPropertyCollection::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszKey		Name of key to enumerate properties of

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropertyCollection::Init(const CComPtr<IMSAdminBase> &pIMeta,
								  CMetaSchemaTable *pCSchemaTable, 
								  LPTSTR tszKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Copy tszKey to m_tszKey
	if (tszKey == NULL) {
		// Key is root
		m_tszKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
		CannonizeKey(m_tszKey);
		
		// Make sure the key exists by opening and closing it
		METADATA_HANDLE hMDKey;

		hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							   T2W(m_tszKey),
							   METADATA_PERMISSION_READ,
							   MUTIL_OPEN_KEY_TIMEOUT,
							   &hMDKey);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}

		m_pIMeta->CloseKey(hMDKey);
	}

	return S_OK; 
}

/*===================================================================
CPropertyCollection::~CPropertyCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyCollection::~CPropertyCollection() 
{
	m_pCSchemaTable->Release();

	if (m_tszKey != NULL) {
		delete m_tszKey;
	}
}

/*===================================================================
CPropertyCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CPropertyCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IPropertyCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CPropertyCollection::get_Count

Get method for Count property.  Counts the number of properties for
this key.

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plReturn == NULL
	S_OK on success

Notes:
	Actually counts all of the properties.  Do not call in a loop!
===================================================================*/
STDMETHODIMP CPropertyCollection::get_Count(long * plReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::get_Count\n");

	ASSERT_NULL_OR_POINTER(plReturn, long);

	if (plReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwDataLen;
	DWORD dwReqDataLen;

	dwDataLen = 1024;
	pbData = new BYTE[dwDataLen];
	if (pbData == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	*plReturn = 0;
	for(;;) {  // FOREVER, will return out of loop
		// Get a property
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwDataLen;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszKey), 
								&mdr,
								*plReturn,
								&dwReqDataLen);

		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				// Done, cleanup and return the result
				delete pbData;
				return S_OK;
			}
			else if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
				// Make a bigger buffer and try again
				delete pbData;
				dwDataLen = dwReqDataLen;
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					return ::ReportError(E_OUTOFMEMORY);
					}
			}
			else {
				delete pbData;
				return ::ReportError(hr);
			}
		}
		else { // SUCCEEDED(hr)
			// Count it
			(*plReturn)++;
		}
	}
}

/*===================================================================
CPropertyCollection::get_Item

Get method for Item property.  Returns a key given its index.

Parameters:
	varId		[in] 1 based index or Name of the property to get
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL or lIndex <= 0
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::get_Item(long lIndex, 
										   LPDISPATCH * ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::get_Item\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPDISPATCH);

	if ((ppIReturn == NULL) || (lIndex <= 0)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Get the requested property
	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwReqDataLen;

	pbData = new BYTE[1024];
	if (pbData == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = 0;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.pbMDData = pbData;
	mdr.dwMDDataLen = 1024;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
							T2W(m_tszKey), 
							&mdr,
							lIndex - 1,
							&dwReqDataLen);

	// If the buffer was too small, try again with a bigger one
	if (FAILED(hr) && (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
		delete pbData;
		pbData = new BYTE[dwReqDataLen];
		if (pbData == NULL) {
			return ::ReportError(hr);
		}

		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwReqDataLen;
		mdr.dwMDDataTag = 0;

		hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszKey), 
								&mdr,
								lIndex - 1,
								&dwReqDataLen);
	}

	// If we got it create a properties object
	if (SUCCEEDED(hr)) {
		// Create the property object
		CComObject<CProperty> *pObj = NULL;
		ATLTRY(pObj = new CComObject<CProperty>);
		if (pObj == NULL) {
			delete pbData;
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, &mdr);
		if (FAILED(hr)) {
			delete pbData;
			return ::ReportError(hr);
		}

		// Set the interface to IDispatch
		hr = pObj->QueryInterface(IID_IDispatch, (void **) ppIReturn);
		if (FAILED(hr)) {
			delete pbData;
			return ::ReportError(hr);
		}
		ASSERT(*ppIReturn != NULL);
	}
	else {  // FAILED(hr)
		delete pbData;
		return ::ReportError(hr);
	}

	delete pbData;
	return S_OK;
}

/*===================================================================
CPropertyCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the properties.

Parameters:
	ppIReturn	[out, retval] Interface for the enumeration object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::get__NewEnum(LPUNKNOWN * ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::get__NewEnum\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the property enumeration
	CComObject<CPropertyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CPropertyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, 0);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CPropertyCollection::Get

Get a property object from the base key of the collection.

Parameters:
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::Get(VARIANT varId, IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::Get\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if (ppIReturn == NULL) {
		return E_INVALIDARG;
	}

	return ::GetProperty(m_pIMeta, m_pCSchemaTable, m_tszKey, varId, ppIReturn);
}

/*===================================================================
CPropertyCollection::Add

Add a property object to the base key of the collection.

Parameters:
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::Add(VARIANT varId, IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::Add\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if (ppIReturn == NULL) {
		return E_INVALIDARG;
	}

	return ::CreateProperty(m_pIMeta, m_pCSchemaTable, m_tszKey, varId, ppIReturn);
}

/*===================================================================
CPropertyCollection::Remove

Remove a property from the base key of the collection.

Parameters:
	varId		[in] Identifier of property to remove.  Either the 
				Id (number) or Name (string).

Returns:
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::Remove(VARIANT varId)
{
	TRACE0("MetaUtil: CPropertyCollection::Remove\n");

	return ::DeleteProperty(m_pIMeta, m_pCSchemaTable, m_tszKey, varId);
}


/*------------------------------------------------------------------
 * C P r o p e r t y E n u m
 */

/*===================================================================
CPropertyEnum::CPropertyEnum

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyEnum::CPropertyEnum() : m_pCSchemaTable(NULL),
								 m_tszKey(NULL),
								 m_iIndex(0)
{
}

/*===================================================================
CPropertyEnum::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszKey		Name of key to enumerate properties of
	iIndex		Index of next element in enumeration

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropertyEnum::Init(const CComPtr<IMSAdminBase> &pIMeta,
							CMetaSchemaTable *pCSchemaTable, 
							LPCTSTR tszKey, 
							int iIndex) 
{ 
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);
	ASSERT(iIndex >= 0);

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Copy m_tszKey
	if (tszKey == NULL) {
		// Key is root
		m_tszKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
		CannonizeKey(m_tszKey);
	}

	m_iIndex = iIndex;

	return S_OK; 
}

/*===================================================================
CPropertyEnum::~CPropertyEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyEnum::~CPropertyEnum() 
{
	m_pCSchemaTable->Release();

	if (m_tszKey != NULL) {
		delete m_tszKey;
	}
}

/*===================================================================
CPropertyEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
	E_INVALIDARG if rgvarDest == NULL
	E_OUTOFMEMORY if allocation failed
	S_OK if outputs ulNumToGet items
	S_FALSE if outputs less than ulNumToGet items
===================================================================*/
STDMETHODIMP CPropertyEnum::Next(unsigned long ulNumToGet, 
								 VARIANT FAR* rgvarDest, 
								 unsigned long FAR* pulNumGot) 
{
	TRACE0("MetaUtil: CPropertyEnum::Next\n");

	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (rgvarDest == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwDataLen;
	DWORD dwReqDataLen;
	unsigned int uiDestIndex;
	IDispatch *pIDispatch;

	dwDataLen = 1024;
	pbData = new BYTE[dwDataLen];
	if (pbData == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// For each property to get
	uiDestIndex = 0;
	while (uiDestIndex < ulNumToGet) {
		// Get a property
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwDataLen;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszKey), 
								&mdr,
								m_iIndex,
								&dwReqDataLen);

		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				// Done, cleanup and return the result
				if (pulNumGot != NULL) {
					*pulNumGot = uiDestIndex;
				}
				delete pbData;
				return S_FALSE;
			}
			else if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
				// Try again with a bigger buffer
				delete pbData;
				dwDataLen = dwReqDataLen;
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					return ::ReportError(E_OUTOFMEMORY);
					}
			}
			else {
				delete pbData;
				return ::ReportError(hr);
			}
		}
		else { // SUCCEEDED(hr)
			// Create the property object
			CComObject<CProperty> *pObj = NULL;
			ATLTRY(pObj = new CComObject<CProperty>);
			if (pObj == NULL) {
				delete pbData;
				return ::ReportError(E_OUTOFMEMORY);
			}
			hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, &mdr);
			if (FAILED(hr)) {
				delete pbData;
				return ::ReportError(hr);
			}

			// Set the interface to IDispatch
			hr = pObj->QueryInterface(IID_IDispatch, (void **) &pIDispatch);
			if (FAILED(hr)) {
				delete pbData;
				return ::ReportError(hr);
			}
			ASSERT(pIDispatch != NULL);

			// Put it in the output array
			VariantInit(&(rgvarDest[uiDestIndex]));
			rgvarDest[uiDestIndex].vt = VT_DISPATCH;
			rgvarDest[uiDestIndex].pdispVal = pIDispatch;

			// Next element
			m_iIndex++;
			uiDestIndex++;
		}
	}

	delete pbData;

	if (pulNumGot != NULL) {
		*pulNumGot = uiDestIndex;
	}

	return S_OK;
}

/*===================================================================
CPropertyEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CPropertyEnum::Skip(unsigned long ulNumToSkip) 
{
	TRACE0("MetaUtil: CPropertyEnum::Skip\n");

	m_iIndex += ulNumToSkip;

	return S_OK;
}

/*===================================================================
CPropertyEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CPropertyEnum::Reset() 
{
	TRACE0("MetaUtil: CPropertyEnum::Reset\n");

	m_iIndex = 0;

	return S_OK;
}

/*===================================================================
CPropertyEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if not enough memory to create clone
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn)  
{
	TRACE0("MetaUtil: CPropertyEnum::Clone\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CPropertyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CPropertyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, m_iIndex);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}



/*------------------------------------------------------------------
 * C P r o p e r t y
 */

/*===================================================================
CProperty::CProperty

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CProperty::CProperty() : m_pCSchemaTable(NULL),
						 m_tszKey(NULL),
						 m_dwId(0),
						 m_dwAttributes(0),
						 m_dwUserType(0),
						 m_dwDataType(0)
{
	VariantInit(&m_varData);
}

/*===================================================================
CProperty::Init

Constructor

Parameters:
	tszKey	Name of key where the property is located
	dwId	Id of property
	bCreate TRUE if this property can be created (does not have to exist)

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CProperty::Init(const CComPtr<IMSAdminBase> &pIMeta,
						CMetaSchemaTable *pCSchemaTable,
						LPCTSTR tszKey, 
						DWORD dwId, 
						BOOL bCreate) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Set the Key and Id members
	if (tszKey == NULL) {
		m_tszKey = NULL;
	}
	else {
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
		CannonizeKey(m_tszKey);
	}

	m_dwId = dwId;

	// Open the key (to be sure it exists)
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	
	// Get the property
	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwReqLen;

	pbData = new BYTE[1024];
	if (pbData == NULL) {
		m_pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}

	mdr.dwMDIdentifier = m_dwId;
	mdr.dwMDAttributes = 0;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
    mdr.pbMDData = pbData;
	mdr.dwMDDataLen = 1024;
	mdr.dwMDDataTag = 0;

	hr = m_pIMeta->GetData(hMDKey,
						   NULL,
						   &mdr,
						   &dwReqLen);

	// If the buffer was too small, try again with a bigger one
	if (FAILED(hr) && (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
		delete pbData;
		pbData = new BYTE[dwReqLen];
		if (pbData == NULL) {
			m_pIMeta->CloseKey(hMDKey);
			return ::ReportError(hr);
		}

		mdr.dwMDIdentifier = m_dwId;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwReqLen;
		mdr.dwMDDataTag = 0;

		hr = m_pIMeta->GetData(hMDKey,
							   NULL,
							   &mdr,
							   &dwReqLen);
	}

	// If we got it fill in the fields
	if (SUCCEEDED(hr)) {
		m_dwAttributes = mdr.dwMDAttributes;
		m_dwUserType = mdr.dwMDUserType;
		m_dwDataType = mdr.dwMDDataType;
		SetDataToVar(mdr.pbMDData, mdr.dwMDDataLen);
	}
	// If the property doesn't exist and we're creating, set defaults
	else if ((bCreate) && (hr == MD_ERROR_DATA_NOT_FOUND)) {
		m_dwAttributes = 0;
		m_dwUserType = 0;
		m_dwDataType = 0;
		VariantClear(&m_varData);
	}
	else {  //(FAILED(hr))
		delete pbData;
		m_pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}

	delete pbData;

	// Close the key
	m_pIMeta->CloseKey(hMDKey);

	return S_OK;
}

/*===================================================================
CProperty::Init

Constructor

Parameters:
	tszKey	Name of key where property is located
	mdr		METADATA_RECORD containing the current property info

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CProperty::Init(const CComPtr<IMSAdminBase> &pIMeta,
						CMetaSchemaTable *pCSchemaTable, 
						LPCTSTR tszKey, 
						METADATA_RECORD *mdr) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);

	HRESULT hr;

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Set the Key member
	if (tszKey == NULL) {
		m_tszKey = NULL;
	}
	else {
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
	}

	// Use mdr to set the rest
	m_dwId = mdr->dwMDIdentifier;
	m_dwAttributes = mdr->dwMDAttributes;
	m_dwUserType = mdr->dwMDUserType;
	m_dwDataType = mdr->dwMDDataType;
	hr = SetDataToVar(mdr->pbMDData, mdr->dwMDDataLen);
	if (FAILED(hr)) {
		::ReportError(hr);
	}

	return S_OK;
}

/*===================================================================
CProperty::~CProperty

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CProperty::~CProperty() 
{
	m_pCSchemaTable->Release();

	if (m_tszKey != NULL) {
		delete m_tszKey;
	}

	VariantClear(&m_varData);
}

/*===================================================================
CProperty::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CProperty::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IProperty,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CProperty::get_Id

Get method for Id property.  Identifier for this metabase property.

Parameters:
	plId	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulId == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Id(long *plId)
{
	//TRACE0("MetaUtil: CProperty::get_Id\n");
	ASSERT_NULL_OR_POINTER(plId, long);

	if (plId == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plId = (long) m_dwId;

	return S_OK;
}

/*===================================================================
CProperty::get_Name

Get method for Name property.  Name of this metabase property.

Parameters:
	pbstrName	[out, retval] Value to return to client.  If property
				has no name "" is returned

Returns:
	E_INVALIDARG if pbstrName == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Name(BSTR *pbstrName)
{
	TRACE0("MetaUtil: CProperty::get_Name\n");
	ASSERT_NULL_OR_POINTER(pbstrName, BSTR);

	if (pbstrName == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	CPropInfo *pCPropInfo;

	// Get the property info from the Schema Table
	pCPropInfo = m_pCSchemaTable->GetPropInfo(m_tszKey, m_dwId);

	// Did we find it?  Is there a name entry
	if ((pCPropInfo == NULL) || (pCPropInfo->GetName() == NULL)) {
		// No, return ""
		*pbstrName = T2BSTR(_T(""));
	}
	else {
		// Yes, return the name
		*pbstrName = T2BSTR(pCPropInfo->GetName());
	}

	return S_OK;
}

/*===================================================================
CProperty::get_Attributes

Get method for Attributes property.  Gets the attribute flags for
this property.

Parameters:
	plAttributes	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulAttributes == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Attributes(long *plAttributes)
{
	//TRACE0("MetaUtil: CProperty::get_Attributes\n");
	ASSERT_NULL_OR_POINTER(plAttributes, long);

	if (plAttributes == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plAttributes = (long) m_dwAttributes;

	return S_OK;
}

/*===================================================================
CProperty::put_Attributes

Put method for Attributes property.  Sets the attribute flags for
this property.

Parameters:
	lAttributes	[in] New value for attributes.

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CProperty::put_Attributes(long lAttributes)
{
	TRACE0("MetaUtil: CProperty::put_Attributes\n");

	m_dwAttributes = (DWORD) lAttributes;

	return S_OK;
}

/*===================================================================
CProperty::get_UserType

Get method for UserType property.  Gets the User Type for this
metabase property.

Parameters:
	plUserType	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulUserType == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_UserType(long *plUserType)
{
	//TRACE0("MetaUtil: CProperty::get_UserType\n");
	ASSERT_NULL_OR_POINTER(plUserType, long);

	if (plUserType == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plUserType = (long) m_dwUserType;

	return S_OK;
}

/*===================================================================
CProperty::put_UserType

Put method for UserType property.  Sets the user type

Parameters:
	lUserType	[in] New value for user type.

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CProperty::put_UserType(long lUserType)
{
	TRACE0("MetaUtil: CProperty::put_UserType\n");

	m_dwUserType = (DWORD) lUserType;

	return S_OK;
}

/*===================================================================
CProperty::get_DataType

Get method for DataType property.  Gets the type of data stored in
the metabase property.

Parameters:
	plDataType	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulDataType == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_DataType(long *plDataType)
{
	//TRACE0("MetaUtil: CProperty::get_DataType\n");
	ASSERT_NULL_OR_POINTER(plDataType, long);

	if (plDataType == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plDataType = (long) m_dwDataType;

	return S_OK;
}

/*===================================================================
CProperty::put_DataType

Put method for DataType property.  Sets the data type

Parameters:
	lDataType	[in] New value for data type.

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CProperty::put_DataType(long lDataType)
{
	TRACE0("MetaUtil: CProperty::put_DataType\n");

	m_dwDataType = (DWORD) lDataType;

	return S_OK;
}

/*===================================================================
CProperty::get_Data

Get method for Data property.  Gets the data for this metabase
property.

Parameters:
	pvarData	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pvarData == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Data(VARIANT *pvarData)
{
	//TRACE0("MetaUtil: CProperty::get_Data\n");
	ASSERT_NULL_OR_POINTER(pvarData, VARIANT);

	if (pvarData == NULL) {
		return E_INVALIDARG;
	}

	HRESULT hr;

	hr = VariantCopy(pvarData, &m_varData);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	return S_OK;
}

/*===================================================================
CProperty::put_Data

Put method for Data property.  Sets the data

Parameters:
	varData	[in] New value for data
===================================================================*/
STDMETHODIMP CProperty::put_Data(VARIANT varData)
{
	TRACE0("MetaUtil: CProperty::put_Data\n");

	HRESULT hr;

	hr = VariantCopy(&m_varData, &varData);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	return S_OK;
}

/*===================================================================
CProperty::Write

Writes changes made to this object to the metabase

Parameters:
	None

Returns:
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::Write()
{
	USES_CONVERSION;

	TRACE0("MetaUtil: CProperty::Write\n");

	HRESULT hr;

	// Open the key for write access
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszKey),
						   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	
	// Create the data record
	METADATA_RECORD mdr;

	mdr.dwMDIdentifier = m_dwId;
	mdr.dwMDAttributes = m_dwAttributes;
	mdr.dwMDUserType = m_dwUserType;
	mdr.dwMDDataType = m_dwDataType;
	hr = GetDataFromVar(mdr.pbMDData, mdr.dwMDDataLen);
	if (FAILED(hr)) {
		m_pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}
	mdr.dwMDDataTag = 0;

	// Set the data
	hr = m_pIMeta->SetData(hMDKey,
						   L"",
						   &mdr);
	if (FAILED(hr)) {
		m_pIMeta->CloseKey(hMDKey);
		delete mdr.pbMDData;
		return ::ReportError(hr);
	}

	// Close the key
	m_pIMeta->CloseKey(hMDKey);
	delete mdr.pbMDData;

	return S_OK;
}

/*===================================================================
CProperty::SetDataToVar

Private function to save property data from its raw form to the
variant data member.

Parameters:
	pbData		Raw property data to convert to variant
	dwDataLen	Length of property data

Returns:
	ERROR_INVALID_DATA if m_dwDataType is not recognized
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
HRESULT CProperty::SetDataToVar(BYTE *pbData, DWORD dwDataLen) 
{
	ASSERT((pbData == NULL) || IsValidAddress(pbData, dwDataLen, FALSE));

	HRESULT hr;

	hr = VariantClear(&m_varData);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	switch(m_dwDataType) {

	case DWORD_METADATA:
		// I4 subtype
		V_VT(&m_varData) = VT_I4;
		V_I4(&m_varData) = *(reinterpret_cast<long *> (pbData));
		break;

	case STRING_METADATA:
	case EXPANDSZ_METADATA:
		// BSTR subtype
		V_VT(&m_varData) = VT_BSTR;
		V_BSTR(&m_varData) = W2BSTR(reinterpret_cast<LPCWSTR> (pbData));
		break;

	case MULTISZ_METADATA: {
		ULONG   cStrings = 0;
		// Metabase string are Unicode
        LPCWSTR pwsz     = reinterpret_cast<LPCWSTR> (pbData);
        LPCWSTR pwszEnd  = reinterpret_cast<LPCWSTR> (pbData + dwDataLen);

        // Data is a series of null-terminated strings terminated by two nulls.
        // Figure out how many values we have
        while ((*pwsz != L'\0') && (pwsz < pwszEnd))
        {
            cStrings++;
            pwsz += wcslen(pwsz) + 1; // skip string and trailing \0
        }

        // Create a SAFEARRAY to hold the return result.  The array
        // has to be of VARIANTs, not BSTRs, as you might expect, because
        // VBScript will not accept an array of BSTRs (although VB5 will).
        SAFEARRAYBOUND rgsabound[1] = {{cStrings, 0L}};
        SAFEARRAY*     psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);

        if (psa == NULL)
            return ::ReportError(E_OUTOFMEMORY);

        // now stuff the values into the array
        LONG i = 0;
        pwsz   = reinterpret_cast<LPCWSTR> (pbData);

        while ((*pwsz != L'\0') && (pwsz < pwszEnd))
        {
            // Stuff the string into a BSTR VARIANT
            CComVariant vt = W2BSTR(pwsz);
            ASSERT(V_VT(&vt) == VT_BSTR);
            HRESULT hr = SafeArrayPutElement(psa, &i, (void*) &vt);
            if (FAILED(hr))
                ::ReportError(hr);
            i++;
            pwsz += wcslen(pwsz) + 1; // skip string and trailing \0
        }

        V_VT(&m_varData) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&m_varData) = psa;

        break;
	}

	case BINARY_METADATA:
		// BSTR of byte data subtype
		V_VT(&m_varData) = VT_BSTR;
		V_BSTR(&m_varData) = SysAllocStringByteLen((char *) pbData, dwDataLen);
		break;

	default:
		// Unknown data type
		return ::ReportError(ERROR_INVALID_DATA);
	}
	
	return S_OK;
}

/*===================================================================
CProperty::GetDataFromVar

Private function to get data from the variant data member to its
raw form.

Supported SubTypes:

	DWORD_METADATA:
		I1, I2, I4, I8, UI1, UI2, UI4, UI8

	STRING_METADATA and EXPANDSZ_METADATA:
		BSTR

	MULTISZ_METADATA
		VT_ARRAY | VT_VARIANT (1 Dimension, stops on NULL or EMPTY)
		VT_ARRAY | VT_BSTR    (1 Dimension)

	BINARY_METADATA
		BSTR
		
Parameters:
	pbData		Pointer to output buffer (allocated by this function)
	dwDataLen	Length of data in output buffer

Returns:
    ERROR_INVALID_DATA if m_dwDataType is not recognized or does not
		match the expected variant subtype.
	E_OUTOFMEMORY on allocation failure
	S_OK on succes

Notes:
	Case statements are used for each dwMDDataType value to facilitate
	adding support for additional VariantSubType to Data conversions.

    MULTISZ_METADATA with VT_ARRAY | VT_VARIANT stops at a NULL or
	EMPTY entry because it is easy to allocate an array one bigger
	than you need in VBScript.  Instead of erroring in this case, I 
	stop when I hit such an entry.  This also allows a larger array 
	to be allocated that is terminated by NULL or EMPTY.
===================================================================*/
HRESULT CProperty::GetDataFromVar(BYTE * &pbData, DWORD &dwDataLen) 
{	
	USES_CONVERSION;
	HRESULT hr;

	// Cleanup any IDispatch or byref stuff
	CComVariant varData;

	hr = VariantResolveDispatch(&m_varData, &varData);
	if (FAILED(hr)) {
        return hr;
	}

	switch(m_dwDataType) {

	case DWORD_METADATA:
		// I4 subtype

		switch (V_VT(&varData)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4, which is the same as DWORD_METADATA
		if (FAILED(hr = VariantChangeType(&varData, &varData, 0, VT_UI4)))
			return ::ReportError(hr);

		// fallthru to VT_UI4

		case VT_UI4:
			
			dwDataLen = sizeof(DWORD);
			pbData = reinterpret_cast<BYTE *> (new DWORD);
			if (pbData == NULL) {
				return ::ReportError(E_OUTOFMEMORY);
			}

			*(reinterpret_cast<DWORD *> (pbData)) = V_UI4(&varData);
			break;

		default:
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}
		
		break;

	case STRING_METADATA:
	case EXPANDSZ_METADATA:
		// BSTR subtype

		switch (V_VT(&varData)) {

		case VT_BSTR:
			// Ignores the length field, terminate at the first NULL
			dwDataLen = (wcslen(OLE2W(V_BSTR(&varData))) + 1) * sizeof(wchar_t);

			pbData = new BYTE[dwDataLen];
            if( pbData == NULL )
            {
                return ::ReportError(E_OUTOFMEMORY);
            }
			memcpy(pbData, OLE2W(V_BSTR(&varData)), dwDataLen);

		default:
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}

		break;

	case MULTISZ_METADATA:
		// ARRAY of BSTR subtype
		
		// if it's a 1 Dimentional Array subtype
		if (((V_VT(&varData) & VT_ARRAY) == VT_ARRAY) && 
			(SafeArrayGetDim(V_ARRAY(&varData)) == 1) ) {
			
			// Get Array Bounds
			long lLBound;
			long lUBound;
			long lNumElements;
			hr = SafeArrayGetLBound(V_ARRAY(&varData), 1, &lLBound);
			if (FAILED(hr)) {
				return ::ReportError(hr);
			}
			hr = SafeArrayGetUBound(V_ARRAY(&varData), 1, &lUBound);
			if (FAILED(hr)) {
				return ::ReportError(hr);
			}

			lNumElements = lUBound - lLBound + 1;

			// Process the element types
			switch (V_VT(&varData)) {

			case VT_ARRAY | VT_VARIANT : {

				VARIANT *rgvarRaw;   // Before resolveIDispatch
				CComVariant *rgvar;  // After resolveIDispatch
				LPWSTR wszIndex;
				int i;
				int iStrLen;

				rgvar = new CComVariant[lUBound - lLBound + 1];
				if (rgvar == NULL) {
					return ::ReportError(E_OUTOFMEMORY);
				}

				hr = SafeArrayAccessData(V_ARRAY(&varData), (void **) &rgvarRaw);
				if (FAILED(hr)) {
					return ::ReportError(hr);
				}

				// Pass 1, resolve IDispatch, check types and figure out how much memory is needed
				dwDataLen = 0;
				for (i = 0; i < lNumElements; i++) {
					hr = VariantResolveDispatch(&(rgvarRaw[i]), &(rgvar[i]));
					if (FAILED(hr)) {
						return hr;
					}

					if (V_VT(&(rgvar[i])) != VT_BSTR) {
						if ((V_VT(&(rgvar[i])) == VT_EMPTY) ||
							(V_VT(&(rgvar[i])) == VT_NULL)) {
							// NULL or EMPTY, Stop Here
							lNumElements = i;
							break;
						}
						else {
							SafeArrayUnaccessData(V_ARRAY(&varData));
							return ::ReportError(ERROR_INVALID_DATA);
						}
					}

					dwDataLen += (wcslen(OLE2W(V_BSTR(&(rgvar[i])))) + 1) * sizeof(wchar_t);
				}
				dwDataLen += sizeof(wchar_t);

				// Allocate
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					SafeArrayUnaccessData(V_ARRAY(&varData));
					return ::ReportError(E_OUTOFMEMORY);
				}

				// Pass 2, copy to desination
				wszIndex = reinterpret_cast<LPWSTR> (pbData);
				for (i = 0; i < lNumElements; i++) {
					iStrLen = (wcslen(OLE2W(V_BSTR(&(rgvar[i])))) + 1);
					memcpy(wszIndex, OLE2W(V_BSTR(&(rgvar[i]))), iStrLen * sizeof(wchar_t));
					wszIndex += iStrLen;
				}
				*wszIndex = L'\0';

				SafeArrayUnaccessData(V_ARRAY(&varData));

				break;
			}

			case VT_ARRAY | VT_BSTR : {

				BSTR *rgbstr;
				LPWSTR wszIndex;
				int i;
				int iStrLen;

				hr = SafeArrayAccessData(V_ARRAY(&varData), (void **) &rgbstr);
				if (FAILED(hr)) {
					return ::ReportError(hr);
				}

				// Pass 1, figure out how much memory is needed
				dwDataLen = 0;
				for (i = 0; i < lNumElements; i++) {
					dwDataLen += (wcslen(OLE2W(rgbstr[i])) + 1) * sizeof(wchar_t);
				}
				dwDataLen += sizeof(wchar_t);

				// Allocate
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					SafeArrayUnaccessData(V_ARRAY(&varData));
					return ::ReportError(E_OUTOFMEMORY);
				}

				// Pass 2, copy to desination
				wszIndex = reinterpret_cast<LPWSTR> (pbData);
				for (i = 0; i < lNumElements; i++) {
					iStrLen = (wcslen(OLE2W(rgbstr[i])) + 1);
					memcpy(wszIndex, OLE2W(rgbstr[i]), iStrLen * sizeof(wchar_t));
					wszIndex += iStrLen;
				}
				*wszIndex = L'\0';

				SafeArrayUnaccessData(V_ARRAY(&varData));

				break;
			}

			default:
				// Unexpected data type
				return ::ReportError(ERROR_INVALID_DATA);	
			}
		}
		else { // Array is not one dimensional
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}

		break;

	case BINARY_METADATA:
		// BSTR of bytes subtype
		switch (V_VT(&varData)) {

		case VT_BSTR:
			// Use the length field, since NULL values are allowed
			dwDataLen = SysStringByteLen(V_BSTR(&varData));

			pbData = new BYTE[dwDataLen];
                        if( pbData == NULL )
                        {
                            return ::ReportError(E_OUTOFMEMORY);
                        }
			memcpy(pbData, V_BSTR(&varData), dwDataLen);

		default:
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}

		break;

	default:
		// Unknown metabase data type
		return ::ReportError(ERROR_INVALID_DATA);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\mutilobj.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MUtilObj.h

Owner: t-BrianM

This file contains the headers for the main MetaUtil object and
utility functions.
===================================================================*/

#ifndef __METAUTIL_H_
#define __METAUTIL_H_

#include "resource.h"   // main symbols
#include <iadmw.h>		// Metabase base object unicode interface
#include <iiscnfg.h>	// MD_ & IIS_MD_ defines
#include "utility.h"
#include "MetaSchm.h"
#include "keycol.h"
#include "propcol.h"
#include "chkerror.h"

#define MUTIL_OPEN_KEY_TIMEOUT 5000  //Timeout for metabase OpenKey() calls

/*
 * C M e t a U t i l
 *
 * Implements the main MetaUtil object
 */

class ATL_NO_VTABLE CMetaUtil : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMetaUtil, &CLSID_MetaUtil>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMetaUtil, &IID_IMetaUtil, &LIBID_MetaUtil>
{
public:
	CMetaUtil();
	HRESULT FinalConstruct();
	void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_METAUTIL)

BEGIN_COM_MAP(CMetaUtil)
	COM_INTERFACE_ENTRY(IMetaUtil)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
// DECLARE_NOT_AGGREGATABLE(CMetaUtil)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMetaUtil
	STDMETHOD(EnumProperties)(/*[in]*/ BSTR bstrKey, /*[out, retval]*/ IPropertyCollection **ppIReturn);
	STDMETHOD(EnumKeys)(/*[in]*/ BSTR bstrBaseKey, /*[out, retval]*/ IKeyCollection **ppIReturn);
	STDMETHOD(EnumAllKeys)(/*[in]*/ BSTR bstrBaseKey, /*[out, retval]*/ IKeyCollection **ppIReturn);

	STDMETHOD(CreateKey)(/*[in]*/ BSTR bstrKey);
	STDMETHOD(DeleteKey)(/*[in]*/ BSTR bstrKey);
	STDMETHOD(RenameKey)(/*[in]*/ BSTR bstrOldName, /*[in]*/ BSTR bstrNewName);
	STDMETHOD(CopyKey)(/*[in]*/ BSTR bstrSrcKey, /*[in]*/ BSTR bstrDestKey, /*[in]*/ BOOL fOverwrite);
	STDMETHOD(MoveKey)(/*[in]*/ BSTR bstrSrcKey, /*[in]*/ BSTR bstrDestKey, /*[in]*/ BOOL fOverwrite);

	STDMETHOD(GetProperty)(/*[in]*/ BSTR bstrKey, /*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(CreateProperty)(/*[in]*/ BSTR bstrKey, /*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(DeleteProperty)(/*[in]*/ BSTR bstrKey, /*[in]*/ VARIANT varId);

	STDMETHOD(CheckSchema)(/*[in]*/ BSTR bstrMachine, /*[out, retval]*/ ICheckErrorCollection **ppIReturn);
	STDMETHOD(CheckKey)(/*[in]*/ BSTR bstrKey, /*[out, retval]*/ ICheckErrorCollection **ppIReturn);

	STDMETHOD(ExpandString)(/*[in]*/ BSTR bstrIn, /*[out, retval]*/ BSTR *pbstrRet);
	STDMETHOD(PropIdToName)(/*[in]*/ BSTR bstrKey, /*[in]*/ long lId, /*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(PropNameToId)(/*[in]*/ BSTR bstrKey, /*[in]*/ BSTR bstrName, /*[out, retval]*/ long *plId);

	STDMETHOD(get_Config)(/*[in]*/ BSTR bstrSetting, /*[out, retval]*/ VARIANT *pvarValue);
	STDMETHOD(put_Config)(/*[in]*/ BSTR bstrSetting, /*[in]*/ VARIANT varValue);

private:
	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	// Schema table
	CMetaSchemaTable *m_pCSchemaTable;

	// Configuration variables
	DWORD m_dwMaxPropSize;
	DWORD m_dwMaxKeySize;
	DWORD m_dwMaxNumErrors;

	// General check methods
	void AddError(CComObject<CCheckErrorCollection> *pCErrorCol, long lId, long lSeverity, LPCTSTR tszKey, LPCTSTR tszSubKey, DWORD dwProperty);
	BOOL KeyExists(METADATA_HANDLE hMDKey, LPTSTR tszSubKey);
	BOOL PropertyExists(METADATA_HANDLE hMDKey, LPTSTR tszSubKey, DWORD dwId);

	// CheckSchema specific methods
	HRESULT CheckPropertyNames(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDMachine, LPTSTR tszMachine);
	HRESULT CheckPropertyTypes(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDMachine, LPTSTR tszMachine);
	HRESULT CheckClasses(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDMachine, LPTSTR tszMachine);
	HRESULT CheckClassProperties(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDClassKey, LPTSTR tszClassKey, LPTSTR tszClassSubKey);

	// CheckKey specific methods
	BOOL CheckCLSID(LPCTSTR tszCLSID);
	BOOL CheckMTXPackage(LPCTSTR tszPackId);
	HRESULT CheckKeyType(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDKey, LPTSTR tszKey);
	HRESULT CheckIfFileExists(LPCTSTR pszFSPath, BOOL *pfExists);
};

// Methods also supported by the collections
HRESULT CreateKey(CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszKey);
HRESULT DeleteKey(CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszKey);
HRESULT CopyKey(CComPtr<IMSAdminBase> &pIMeta, LPTSTR tszSrcKey, LPTSTR tszDestKey, BOOL fOverwrite, BOOL fCopy);
HRESULT GetProperty(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, VARIANT varId, IProperty **ppIReturn);
HRESULT CreateProperty(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, VARIANT varId, IProperty **ppIReturn);
HRESULT DeleteProperty(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPTSTR tszKey, VARIANT varId);

// Utility
HRESULT VarToMetaId(CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, VARIANT varId, DWORD *pdwId);

// Schema Error Constants (*_S is severity)
#define MUTIL_CHK_NO_SCHEMA						1000
#define MUTIL_CHK_NO_SCHEMA_S					1
#define MUTIL_CHK_NO_PROPERTIES					1001
#define MUTIL_CHK_NO_PROPERTIES_S				1
#define MUTIL_CHK_NO_PROP_NAMES					1002
#define MUTIL_CHK_NO_PROP_NAMES_S				1
#define MUTIL_CHK_NO_PROP_TYPES					1003
#define MUTIL_CHK_NO_PROP_TYPES_S				1
#define MUTIL_CHK_NO_CLASSES					1004
#define MUTIL_CHK_NO_CLASSES_S					1
#define MUTIL_CHK_PROP_NAME_BAD_TYPE			1100
#define MUTIL_CHK_PROP_NAME_BAD_TYPE_S			1
#define MUTIL_CHK_PROP_NAME_NOT_UNIQUE			1101
#define MUTIL_CHK_PROP_NAME_NOT_UNIQUE_S		1
#define MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE		1102
#define MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE_S	1
#define MUTIL_CHK_PROP_TYPE_BAD_TYPE			1200
#define MUTIL_CHK_PROP_TYPE_BAD_TYPE_S			1

#define MUTIL_CHK_PROP_TYPE_BAD_DATA			1201
#define MUTIL_CHK_PROP_TYPE_BAD_DATA_S			2
#define MUTIL_CHK_CLASS_NO_MANDATORY			1300
#define MUTIL_CHK_CLASS_NO_MANDATORY_S			1
#define MUTIL_CHK_CLASS_NO_OPTIONAL				1301
#define MUTIL_CHK_CLASS_NO_OPTIONAL_S			1
#define MUTIL_CHK_CLASS_NOT_CASE_UNIQUE			1302
#define MUTIL_CHK_CLASS_NOT_CASE_UNIQUE_S		2
#define MUTIL_CHK_CLASS_PROP_NO_TYPE		    1303
#define MUTIL_CHK_CLASS_PROP_NO_TYPE_S			2
#define MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE		1304
#define MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE_S	2
#define MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE		1305
#define MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE_S	2
#define MUTIL_CHK_CLASS_PROP_BAD_ATTR			1306
#define MUTIL_CHK_CLASS_PROP_BAD_ATTR_S			2

#define MUTIL_CHK_DATA_TOO_BIG					2000
#define MUTIL_CHK_DATA_TOO_BIG_S				3
#define MUTIL_CHK_KEY_TOO_BIG					2001
#define MUTIL_CHK_KEY_TOO_BIG_S					3
#define MUTIL_CHK_CLSID_NOT_FOUND				2002
#define MUTIL_CHK_CLSID_NOT_FOUND_S				1
#define MUTIL_CHK_MTX_PACK_ID_NOT_FOUND			2003
#define MUTIL_CHK_MTX_PACK_ID_NOT_FOUND_S		1
#define MUTIL_CHK_PATH_NOT_FOUND				2004
#define MUTIL_CHK_PATH_NOT_FOUND_S				1
#define MUTIL_CHK_NO_NAME_ENTRY					2100
#define MUTIL_CHK_NO_NAME_ENTRY_S				3
#define MUTIL_CHK_NO_TYPE_ENTRY					2101
#define MUTIL_CHK_NO_TYPE_ENTRY_S				3
#define MUTIL_CHK_BAD_DATA_TYPE					2102
#define MUTIL_CHK_BAD_DATA_TYPE_S				2
#define MUTIL_CHK_BAD_USER_TYPE					2103
#define MUTIL_CHK_BAD_USER_TYPE_S				2
#define MUTIL_CHK_BAD_ATTR						2104
#define MUTIL_CHK_BAD_ATTR_S					2

#define MUTIL_CHK_NO_KEYTYPE					2200
#define MUTIL_CHK_NO_KEYTYPE_S					3
#define MUTIL_CHK_NO_KEYTYPE_NOT_FOUND			2201
#define MUTIL_CHK_NO_KEYTYPE_NOT_FOUND_S		1
#define MUTIL_CHK_MANDATORY_PROP_MISSING		2202
#define MUTIL_CHK_MANDATORY_PROP_MISSING_S		2

#define MUTIL_CHK_TOO_MANY_ERRORS				9000
#define MUTIL_CHK_TOO_MANY_ERRORS_S				3

#endif //__METAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B40F6F44_E116_11D0_9E58_00C04FB94FEF__INCLUDED_)
#define AFX_STDAFX_H__B40F6F44_E116_11D0_9E58_00C04FB94FEF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <OleAuto.h>    // OLE Automation types

#undef  ASSERT
#include <irtldbg.h>
#undef  ASSERT
#define ASSERT(x) IRTLASSERT(x)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B40F6F44_E116_11D0_9E58_00C04FB94FEF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MetaUtil.rc
//
#define IDS_PROJNAME						100
#define IDR_METAUTIL						101
#define IDS_CHK_BASE						10000
#define IDS_CHK_NO_SCHEMA					11000
#define IDS_CHK_NO_PROPERTIES				11001
#define IDS_CHK_NO_PROP_NAMES				11002
#define IDS_CHK_NO_PROP_TYPES				11003
#define IDS_CHK_NO_CLASSES					11004
#define IDS_CHK_PROP_NAME_BAD_TYPE			11100
#define IDS_CHK_PROP_NAME_NOT_UNIQUE		11101
#define IDS_CHK_PROP_NAME_NOT_CASE_UNIQUE	11102
#define IDS_CHK_PROP_TYPE_BAD_TYPE			11200
#define IDS_CHK_PROP_TYPE_BAD_DATA			11201

#define IDS_CHK_CLASS_NO_MANDATORY			11300
#define IDS_CHK_CLASS_NO_OPTIONAL			11301
#define IDS_CHK_CLASS_NOT_CASE_UNIQUE		11302
#define IDS_CHK_CLASS_PROP_NO_TYPE			11303
#define IDS_CHK_CLASS_PROP_BAD_DATA_TYPE    11304
#define IDS_CHK_CLASS_PROP_BAD_USER_TYPE    11305
#define IDS_CHK_CLASS_PROP_BAD_ATTR		    11306
#define IDS_CHK_DATA_TOO_BIG				12000
#define IDS_CHK_KEY_TOO_BIG					12001
#define IDS_CHK_CLSID_NOT_FOUND				12002
#define IDS_CHK_MTX_PACK_ID_NOT_FOUND		12003
#define IDS_CHK_PATH_NOT_FOUND				12004
#define IDS_CHK_NO_NAME_ENTRY				12100
#define IDS_CHK_NO_TYPE_ENTRY				12101
#define IDS_CHK_BAD_DATA_TYPE				12102
#define IDS_CHK_BAD_USER_TYPE				12103
#define IDS_CHK_BAD_ATTR					12104
#define IDS_CHK_NO_KEYTYPE					12200
#define IDS_CHK_NO_KEYTYPE_NOT_FOUND		12201
#define IDS_CHK_MANDATORY_PROP_MISSING		12202
#define IDS_CHK_TOO_MANY_ERRORS				19000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\propcol.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: PropCol.h

Owner: t-BrianM

This file contains the headers for the property collection and
property object.
===================================================================*/

#ifndef __PROPCOL_H_
#define __PROPCOL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols


/*
 * C P r o p e r t y C o l l e c t i o n
 *
 * Implements property collections
 */

class CPropertyCollection : 
	public IDispatchImpl<IPropertyCollection, &IID_IPropertyCollection, &LIBID_MetaUtil>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CPropertyCollection();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPTSTR tszKey);
	~CPropertyCollection();

BEGIN_COM_MAP(CPropertyCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IPropertyCollection)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CPropertyCollection)  

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPropertyCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ LPDISPATCH *ppIReturn);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);
	STDMETHOD(Get)(/*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(Add)(/*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(Remove)(/*[in]*/ VARIANT varId);

private:
	LPTSTR m_tszKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchemaTable *m_pCSchemaTable; 
};


/*
 * C P r o p e r t y E n u m
 *
 * Implements property enumberations
 */

class CPropertyEnum : 
	public IEnumVARIANT,
	public CComObjectRoot
{
public:
	CPropertyEnum();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, int iIndex);
	~CPropertyEnum();

BEGIN_COM_MAP(CPropertyEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CPropertyEnum) 

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppIReturn);

private:
	int m_iIndex;
	LPTSTR m_tszKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchemaTable *m_pCSchemaTable;
};


/*
 * C P r o p e r t y
 *
 * Implements property objects.
 */

class CProperty : 
	public IDispatchImpl<IProperty, &IID_IProperty, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CProperty();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, DWORD dwId, BOOL bCreate);
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, METADATA_RECORD *mdr);
	~CProperty();

BEGIN_COM_MAP(CProperty)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IProperty)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CProperty) 

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IProperty
	STDMETHOD(get_Id)(/*[out, retval]*/ long *plId);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(get_Attributes)(/*[out, retval]*/ long *plAttributes);
	STDMETHOD(put_Attributes)(/*[in]*/ long plAttributes);
	STDMETHOD(get_UserType)(/*[out, retval]*/ long *plAttributes);
	STDMETHOD(put_UserType)(/*[in]*/ long plAttributes);
	STDMETHOD(get_DataType)(/*[out, retval]*/ long *plAttributes);
	STDMETHOD(put_DataType)(/*[in]*/ long plAttributes);
	STDMETHOD(get_Data)(/*[out, retval]*/ VARIANT *pvarData);
	STDMETHOD(put_Data)(/*[in]*/ VARIANT varData);
	STDMETHOD(Write)();

private:
	LPTSTR  m_tszKey;
	DWORD   m_dwId;

	DWORD   m_dwAttributes;
	DWORD   m_dwUserType;
	DWORD   m_dwDataType;
	VARIANT m_varData;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchemaTable *m_pCSchemaTable;

	HRESULT SetDataToVar(BYTE *pbData, DWORD dwDataLen);
	HRESULT GetDataFromVar(BYTE * &pbData, DWORD &dwDataLen);
};

#endif //ifndef __PROPCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\utility.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: Utility.h

Owner: t-BrianM

This file contains the headers for the utility functions.
===================================================================*/

#ifndef __UTILITY_H_
#define __UTILITY_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/*
 * U t i l i t i e s
 */

// Sets up the ErrorInfo structure
HRESULT ReportError(DWORD dwErr);
HRESULT ReportError(HRESULT hr);

// Metabase key manipulation
LPTSTR CannonizeKey(LPTSTR tszKey);
void SplitKey(LPCTSTR tszKey, LPTSTR tszParent, LPTSTR tszChild);
void GetMachineFromKey(LPCTSTR tszFullKey, LPTSTR tszMachine);
BOOL KeyIsInSchema(LPCTSTR tszFullKey);
BOOL KeyIsInIISAdmin(LPCTSTR tszFullKey);

// Variant manipulation
HRESULT VariantResolveDispatch(VARIANT* pVarIn, VARIANT* pVarOut);

#endif //__UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\pwalker\ntstuff.c ===
#include "pwalker.h"
#pragma hdrstop

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)


//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
	
typedef LONG KPRIORITY;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SpareUl2;
    ULONG SpareUl3;
    ULONG PeakVirtualSize;
    ULONG VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    ULONG QuotaPeakPagedPoolUsage;
    ULONG QuotaPagedPoolUsage;
    ULONG QuotaPeakNonPagedPoolUsage;
    ULONG QuotaNonPagedPoolUsage;
    ULONG PagefileUsage;
    ULONG PeakPagefileUsage;
    ULONG PrivatePageCount;
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef LONG NTSTATUS;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,             // obsolete...delete
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemUnused1,
    SystemUnused2,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemUnused3,
    SystemUnused4,
    SystemUnused5,
    SystemUnused6,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification
} SYSTEM_INFORMATION_CLASS;

#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

typedef NTSTATUS (NTAPI * FN_NTQUERYSYSTEMINFORMATION)(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

//
//  Task list structure as returned by GetTaskList().
//

typedef struct _TASK_LISTA
{
    DWORD  dwProcessId;
    DWORD  dwParentProcessId;
    DWORD  dwPriority;
    DWORD  dwThreadCount;
    CHAR   ProcessName[MAX_PATH];

} TASK_LISTA, *PTASK_LISTA, FAR *LPTASK_LISTA;

typedef struct _TASK_LISTW
{
    DWORD  dwProcessId;
    DWORD  dwParentProcessId;
    DWORD  dwPriority;
    DWORD  dwThreadCount;
    WCHAR  ProcessName[MAX_PATH];

} TASK_LISTW, *PTASK_LISTW, FAR *LPTASK_LISTW;

#ifdef UNICODE
#define TASK_LIST   TASK_LISTW
#define LPTASK_LIST LPTASK_LISTW
#else
#define TASK_LIST   TASK_LISTA
#define LPTASK_LIST LPTASK_LISTA
#endif

#define CKMP_ALLOC(cb)           (VOID *)LocalAlloc( LPTR, (cb) )
#define CKMP_REALLOC(p,cb)       (VOID *)LocalReAlloc( (HLOCAL)p, (cb), LPTR )
#define CKMP_FREE(p)             LocalFree( (HLOCAL)(p) )

#define INITIAL_SIZE			65536
#define EXTEND_SIZE				32768

HLOCAL
GetLocalTaskListNt(
    LPDWORD pdwNumTasks
    )
{
    LPTASK_LISTW                pTaskListW;
    PSYSTEM_PROCESS_INFORMATION processInfo;
    PSYSTEM_PROCESS_INFORMATION processScan;
    NTSTATUS                    status;
    ULONG                       bufferSize;
    ULONG                       totalOffset;
    ULONG                       processCount;
    ULONG                       i;
	FN_NTQUERYSYSTEMINFORMATION _pfnNtQuerySystemInformation = NULL;
	HMODULE						hNtdll;

    hNtdll = GetModuleHandleA( "NTDLL.DLL" );
    if( hNtdll != NULL )
    {
        _pfnNtQuerySystemInformation = (FN_NTQUERYSYSTEMINFORMATION)
            GetProcAddress( hNtdll, "NtQuerySystemInformation" );
	}

    //
    // Bail if we couldn't find the entrypoint.
    //

    if( _pfnNtQuerySystemInformation == NULL ) {
        return NULL;
    }

    //
    // Read the process info.
    //

    bufferSize = INITIAL_SIZE;

retry:

    processInfo = CKMP_ALLOC( bufferSize );

    if( processInfo == NULL ) {
        return NULL;
    }

    status = _pfnNtQuerySystemInformation(
                 SystemProcessInformation,
                 processInfo,
                 bufferSize,
                 NULL
                 );

    if( status == STATUS_INFO_LENGTH_MISMATCH ) {
        CKMP_FREE( processInfo );
        bufferSize += EXTEND_SIZE;
        goto retry;
    }

    if( !NT_SUCCESS(status) ) {
        return NULL;
    }

    //
    // Count the number of active processes.
    //

    processCount = 0;
    totalOffset = 0;
    processScan = processInfo;

    for( ; ; ) {

        processCount++;

        if( processScan->NextEntryOffset == 0 ) {
            break;
        }

        totalOffset += processScan->NextEntryOffset;
        processScan = (PVOID)( (PCHAR)processInfo + totalOffset );

    }

    //
    // Now allocate the user's buffer.
    //

    pTaskListW = CKMP_ALLOC( processCount * sizeof(*pTaskListW) );

    if( pTaskListW == NULL ) {
        CKMP_FREE( processInfo );
        return NULL;
    }

    //
    // And map 'em over.
    //

    totalOffset = 0;
    processScan = processInfo;

    for( i = 0 ; i < processCount ; i++ ) {

        PWCHAR name;
        ULONG len;

        pTaskListW[i].dwProcessId = (DWORD)processScan->UniqueProcessId;
        pTaskListW[i].dwParentProcessId = (DWORD)processScan->InheritedFromUniqueProcessId;
        pTaskListW[i].dwPriority = (DWORD)processScan->BasePriority;
        pTaskListW[i].dwThreadCount = (DWORD)processScan->NumberOfThreads;

        if( processScan->ImageName.Buffer == NULL ) {

            name = L"Idle";
            len = sizeof( L"Idle" ) - sizeof(WCHAR);

        } else {

            name = processScan->ImageName.Buffer;
            len = processScan->ImageName.Length;

        }

        RtlCopyMemory(
            pTaskListW[i].ProcessName,
            name,
            len
            );

        pTaskListW[i].ProcessName[len / sizeof(WCHAR)] = L'\0';

        totalOffset += processScan->NextEntryOffset;
        processScan = (PVOID)( (PCHAR)processInfo + totalOffset );

    }

    //
    // Cleanup & we're outta here.
    //

    *pdwNumTasks = (DWORD)processCount;
    CKMP_FREE( processInfo );

    return (HLOCAL) pTaskListW;

}   // GetLocalTaskListNt

BOOL 
GetLocalTaskNameNt( 
	HLOCAL hTaskList, 
	DWORD dwItem,
	LPSTR lpszTaskName,
	DWORD cbMaxTaskName
	)
{
	LPTASK_LISTW pTaskListW = (LPTASK_LISTW) hTaskList;
	BOOL success;
	
	success = WideCharToMultiByte( CP_ACP, 0,
					pTaskListW[dwItem].ProcessName, -1,
					lpszTaskName, cbMaxTaskName, NULL, NULL );
	return success;
}


DWORD
GetLocalTaskProcessIdNt( 
	HLOCAL hTaskList, 
	DWORD dwItem
	)
{
	LPTASK_LISTW pTaskListW = (LPTASK_LISTW) hTaskList;
	
	return pTaskListW[dwItem]. dwProcessId;
}


void 
FreeLocalTaskListNt( 
	HLOCAL hTaskList 
	)
{
	CKMP_FREE( hTaskList );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\metautil\utility.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: Utility.h

Owner: t-BrianM

This file contains implementation of the utility functions.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"

/*------------------------------------------------------------------
 * U t i l i t i e s
 */

/*===================================================================
Report Error

Sets up IErrorInfo.  Does a simple FormatMessage and returns the
correct HRESULT.  Ripped from a-georgr's stuff.

Parameters:
	hr		HRESULT to return to caller
	dwErr	Win32 error code to format message for

Returns:
	hr
===================================================================*/
HRESULT ReportError(HRESULT hr, DWORD dwErr)
{
    HLOCAL pMsgBuf = NULL;

    // If there's a message associated with this error, report that
    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
    {
        AtlReportError(CLSID_MetaUtil, (LPCTSTR) pMsgBuf,
                       IID_IMetaUtil, hr);
    }

    // TODO: add some error messages to the string resources and
    // return those, if FormatMessage doesn't return anything (not
    // all system errors have associated error messages).
    
    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);

    return hr;
}


// Report a Win32 error code
HRESULT ReportError(DWORD dwErr)
{
    return ::ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}


// Report an HRESULT error
HRESULT ReportError(HRESULT hr)
{
    return ::ReportError(hr, (DWORD) hr);
}


/*===================================================================
Cannonize Key

Converts a key into cannonical form.  To do this it does the following:
	o Removes leading slashes
	o Converts back-slashes to forward-slashes
	CONSIDER: Resolve . and ..
	CONSIDER: Case conversion

Parameters:
	tszKey		[in, out] Key to cannonize

Returns:
	Nothing
===================================================================*/
LPTSTR CannonizeKey(LPTSTR tszKey) {
	LPTSTR tszSrc;
	LPTSTR tszDest;

	tszSrc = tszKey;
	tszDest = tszKey;

	// Remove leading slashes
	while ((*tszSrc == _T('/')) || (*tszSrc == _T('\\'))) {
		tszSrc++;
	}

	// Convert slashes
	while (*tszSrc) {
		if (*tszSrc == _T('\\')) {
			*tszDest = _T('/');
		}
		else {
			*tszDest = *tszSrc;
		}
		tszSrc++;
		tszDest++;
	}

	*tszDest = '\0';

	return tszKey;
}

/*===================================================================
Split Key

Splits a key path into parent and child parts.  For example:
tszKey =    "/LM/Root/Path1/Path2/Path3"
tszParent = "/LM/Root/Path1/Path2"
tszChild =  "Path3"

Parameters:
	tszKey		[in] Key to split
	tszParent	[out] Parent part of key (allocated for ADMINDATA_MAX_NAME_LEN)
	tszChild	[out] Child part of key (allocated for ADMINDATA_MAX_NAME_LEN)

Returns:
	Nothing
===================================================================*/
void SplitKey(LPCTSTR tszKey, LPTSTR tszParent, LPTSTR tszChild) {
	ASSERT_STRING(tszKey);
	ASSERT(IsValidAddress(tszParent,ADMINDATA_MAX_NAME_LEN * sizeof(TCHAR), TRUE));
	ASSERT(IsValidAddress(tszChild,ADMINDATA_MAX_NAME_LEN * sizeof(TCHAR), TRUE));

	LPTSTR tszWork;

	// Copy the key to the parent
	_tcscpy(tszParent, tszKey);

	// Find the end of the parent
	tszWork = tszParent;
	while (*tszWork != _T('\0')) {
		tszWork++;
	}

	// Find the start of the child
	while ( (tszWork != tszParent) && (*tszWork != _T('/')) ) {
		tszWork--;
	}

	// Cut off and copy the child
	if (*tszWork == _T('/')) {
		// Multiple parts
		*tszWork = _T('\0');
		tszWork++;
		_tcscpy(tszChild, tszWork);
	}
	else if (*tszWork != _T('\0')) {
		// One part
		_tcscpy(tszChild, tszWork);
		*tszWork = _T('\0');
	}
	else {
		// No parts
		tszChild[0] = _T('\0');
	}
}

/*===================================================================
Get Machine From Key

Gets the machine name part of a full key path.  Assumes that the machine
name is the first component of the path.  For example:
tszKey =     "/LM/Root/Path1/Path2/Path3"
tszMachine = "LM"

Parameters:
	tszKey		[in] Full Key to get machine name of
	tszMachine	[out] Machine name part of path (allocated for ADMINDATA_MAX_NAME_LEN)

Returns:
	Nothing
===================================================================*/
void GetMachineFromKey(LPCTSTR tszFullKey, LPTSTR tszMachine) {
	ASSERT_STRING(tszFullKey);
	ASSERT(IsValidAddress(tszMachine, ADMINDATA_MAX_NAME_LEN * sizeof(TCHAR), TRUE));

	int iSource;
	int iDest;

	iSource = 0;

	// Copy the machine name
	iDest = 0;
	while ((tszFullKey[iSource] != _T('/')) && 
		   (tszFullKey[iSource] != _T('\0'))) {

		tszMachine[iDest] = tszFullKey[iSource];

		iSource++;
		iDest++;
	}

	// Cap it off with NULL
	tszMachine[iDest] = _T('\0');
}

/*===================================================================
Key Is In Schema

Determines if a full key path is or is part of the schema.
For Example:

TRUE
"/Schema"
"/Schema/Properties"
"/Schema/Properties/Words"

FALSE
""
"/LM"
"/LM/ROOT/Schema"
"/LM/ROOT/Path/Schema"
"/LM/ROOT/Path1/Path2"

Parameters:
	tszKey		[in] Key to evaluate

Returns:
	TRUE if key is in the schema
===================================================================*/
BOOL KeyIsInSchema(LPCTSTR tszFullKey) {
	ASSERT_STRING(tszFullKey);

	LPTSTR tszWork;

	// Remove the const so I can play with the read pointer
	tszWork = const_cast <LPTSTR> (tszFullKey);

	// Skip the slash 
	if (*tszWork != _T('\0') && *tszWork == _T('/')) {
		tszWork++;
	}

	// Check for "schema\0" or "schema/"
	if ((_tcsicmp(tszWork, _T("schema")) == 0) ||
		(_tcsnicmp(tszWork, _T("schema/"), 7) == 0)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

/*===================================================================
Key Is In IISAdmin

Determines if a full key path is or is part of IISAdmin.
For Example:

TRUE
"/LM/IISAdmin"
"/SomeMachine/IISAdmin"
"/LM/IISAdmin/Extensions"
"/LM/IISAdmin/Extensions/DCOMCLSIDs"

FALSE
""
"/LM"
"/LM/ROOT/IISAdmin"
"/LM/ROOT/Path/IISAdmin"
"/LM/ROOT/Path1/Path2"

Parameters:
	tszKey		[in] Key to evaluate

Returns:
	TRUE if key is in IISAdmin
===================================================================*/
BOOL KeyIsInIISAdmin(LPCTSTR tszFullKey) {
	ASSERT_STRING(tszFullKey);

	LPTSTR tszWork;

	// Remove the const so I can play with the read pointer
	tszWork = const_cast <LPTSTR> (tszFullKey);

	// Skip leading slashes
	while (*tszWork == _T('/')) {
		tszWork++;
	}

	// Skip the machine name
	while ((*tszWork != _T('/')) && (*tszWork != _T('\0'))) {
		tszWork++;
	}

	// Skip the slash after the machine name
	if (*tszWork != '\0') {
		tszWork++;
	}

	// Check for "iisadmin\0" or "iisadmin/"
	if ((_tcsicmp(tszWork, _T("iisadmin")) == 0) ||
		(_tcsnicmp(tszWork, _T("iisadmin/"), 8) == 0)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


// 
// VariantResolveDispatch
//   Convert an IDispatch VARIANT to a (non-Dispatch) VARIANT by
//   invoking its default property until the object that remains
//   is not an IDispatch.  If the original VARIANT is not an IDispatch
//   then the behavior is identical to VariantCopyInd(), with the
//   exception that arrays are copied.
// 
// Parameters:
//   pVarOut       - if successful, the return value is placed here
//   pVarIn        - the variant to copy
//   GUID& riidObj - the calling interface (for error reporting)
//   nObjID        - the Object's name from the resource file
// 
//   pVarOut need not be initialized.  Since pVarOut is a new
//   variant, the caller must VariantClear this object.
// 
// Returns:
//   The result of calling IDispatch::Invoke.  (either NOERROR or
//   the error resulting from the call to Invoke)   may also return
//   E_OUTOFMEMORY if an allocation fails
// 
//   This function always calls Exception() if an error occurs -
//   this is because we need to call Exception() if an IDispatch
//   method raises an exception.  Instead of having the client
//   worry about whether we called Exception() on its behalf or
//   not, we always raise the exception.
// 

HRESULT
VariantResolveDispatch(
    VARIANT* pVarIn,
    VARIANT* pVarOut)
{
    ASSERT(pVarIn != NULL  &&  pVarOut != NULL);
    
    VariantInit(pVarOut);

    HRESULT hrCopy;
    
    if (V_VT(pVarIn) & VT_BYREF)
        hrCopy = VariantCopyInd(pVarOut, pVarIn);
    else
        hrCopy = VariantCopy(pVarOut, pVarIn);
    
    if (FAILED(hrCopy))
        return ::ReportError(hrCopy);
    
    // Follow the IDispatch chain.
    while (V_VT(pVarOut) == VT_DISPATCH)
    {
        VARIANT     varResolved;        // value of IDispatch::Invoke
        DISPPARAMS  dispParamsNoArgs = {NULL, NULL, 0, 0}; 
        EXCEPINFO   ExcepInfo;
        HRESULT     hrInvoke;
        
        // If the variant is equal to Nothing, then it can be argued
        // with certainty that it does not have a default property!
        // hence we return DISP_E_MEMBERNOTFOUND for this case.
        if (V_DISPATCH(pVarOut) == NULL)
            hrInvoke = DISP_E_MEMBERNOTFOUND;
        else
        {
            VariantInit(&varResolved);
            hrInvoke = V_DISPATCH(pVarOut)->Invoke(
                DISPID_VALUE,
                IID_NULL,
                LOCALE_SYSTEM_DEFAULT,
                DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                &dispParamsNoArgs,
                &varResolved,
                &ExcepInfo,
                NULL);
        }
        
        if (FAILED(hrInvoke))
        {
            if (hrInvoke != DISP_E_EXCEPTION)
                hrInvoke = ::ReportError(hrInvoke);
            // for DISP_E_EXCEPTION, SetErrorInfo has already been called
            
            VariantClear(pVarOut);
            return hrInvoke;
        }
        
        // The correct code to restart the loop is:
        //
        //      VariantClear(pVar)
        //      VariantCopy(pVar, &varResolved);
        //      VariantClear(&varResolved);
        //
        // however, the same affect can be achieved by:
        //
        //      VariantClear(pVar)
        //      *pVar = varResolved;
        //      VariantInit(&varResolved)
        //
        // this avoids a copy.  The equivalence rests in the fact that
        // *pVar will contain the pointers of varResolved, after we
        // trash varResolved (WITHOUT releasing strings or dispatch
        // pointers), so the net ref count is unchanged. For strings,
        // there is still only one pointer to the string.
        //
        // NOTE: the next iteration of the loop will do the VariantInit.
        
        VariantClear(pVarOut);
        *pVarOut = varResolved;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\pwalker\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDD_MAIN                        101
#define IDI_MAIN                        102
#define IDR_MAIN                        103
#define IDI_DUMP                        104
#define IDC_PROCESSES                   1000
#define IDC_MEMORY                      1001
#define IDM_UPDATE                      40001
#define IDM_SAVE                        40002
#define IDM_EXIT                        40004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\pwalker\pwalker.h ===
#pragma warning(disable:4057 4100 4201 4214 4514)
#define WIN32_LEAN_AND_MEAN
#define STRICT
#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <windowsx.h>
#include <tlhelp32.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#pragma hdrstop

HLOCAL
GetLocalTaskListNt(
    LPDWORD pdwNumTasks
    );

BOOL 
GetLocalTaskNameNt( 
	HLOCAL hTaskList, 
	DWORD dwItem,
	LPSTR lpszTaskName,
	DWORD cbMaxTaskName
	);

DWORD
GetLocalTaskProcessIdNt( 
	HLOCAL hTaskList, 
	DWORD dwItem
	);

void 
FreeLocalTaskListNt( 
	HLOCAL hTaskList 
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\pwalker\pwalker.c ===
#include "pwalker.h"
#pragma hdrstop

#include "resource.h"

#define DLG_MSG(hwnd, message, fn)    \
    case (message): return (BOOL) HANDLE_##message((hwnd), (wParam), (lParam), (fn))
#define WPPS WritePrivateProfileString
#define GPPI GetPrivateProfileInt
#define Clear(x) memset(&x, 0, sizeof(x))

#define DUMP_WINDOW_EXTRA 16

#define GET_DUMP_PROCESS(hwnd) (HANDLE) GetWindowLong(hwnd, 0)
#define GET_DUMP_START(hwnd) GetWindowLong(hwnd, 4)
#define GET_DUMP_END(hwnd) GetWindowLong(hwnd, 8)
#define GET_DUMP_OFFSET(hwnd) GetWindowLong(hwnd, 12)
#define GET_DUMP_CY(hwnd) GetWindowLong(hwnd, 16)

#define SET_DUMP_PROCESS(hwnd, x) SetWindowLong(hwnd, 0, (DWORD) x)
#define SET_DUMP_START(hwnd, x) SetWindowLong(hwnd, 4, x)
#define SET_DUMP_END(hwnd, x) SetWindowLong(hwnd, 8, x)
#define SET_DUMP_OFFSET(hwnd, x) SetWindowLong(hwnd, 12, x)
#define SET_DUMP_CY(hwnd, x) SetWindowLong(hwnd, 16, x)
#define IDC_STATUS 8888

// Type definitions for pointers to call tool help functions. 
typedef BOOL (WINAPI *MODULEWALK)(HANDLE hSnapshot, LPMODULEENTRY32 lpme); 
typedef BOOL (WINAPI *THREADWALK)(HANDLE hSnapshot, LPTHREADENTRY32 lpte); 
typedef BOOL (WINAPI *PROCESSWALK)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe); 
typedef HANDLE (WINAPI *CREATESNAPSHOT)(DWORD dwFlags, DWORD th32ProcessID);  

//
// global variables
//
static CREATESNAPSHOT pCreateToolhelp32Snapshot = NULL; 
static MODULEWALK  pModule32First  = NULL;
static MODULEWALK  pModule32Next   = NULL;
static PROCESSWALK pProcess32First = NULL;
static PROCESSWALK pProcess32Next  = NULL;
static THREADWALK  pThread32First  = NULL;
static THREADWALK  pThread32Next   = NULL;

static HINSTANCE ghInstance = NULL;
static HWND ghwndProcesses = NULL;
static HWND ghwndMemory = NULL;
static HWND ghwndStatus = NULL;
static HCURSOR ghWait = NULL;
static BOOL gfToolhelp = FALSE;
static HANDLE ghSnapshot = NULL;
static HANDLE ghTargetProcess = NULL;
static HWND ghwndDump = NULL;
static UINT um_dump = 0;
static DWORD gcyLine = 0;
static char gszIniFile[] = "pwalker.ini";
static char gszPreferences[] = "Preferences";
static char gszDialogX[] = "X";
static char gszDialogY[] = "Y";
static char gszDumpWindowClass[] = "Dump Window";
static char gszDumpX[] = "Dump X";
static char gszDumpY[] = "Dump Y";
static char gszDumpCX[] = "DumpCX";
static char gszDumpCY[] = "DumpCY";

//
// forward functions declarations
//
BOOL CALLBACK main_dlgproc( HWND, UINT, WPARAM, LPARAM );
void main_OnCommand( HWND, UINT, HWND, UINT );
LONG main_OnNotify( HWND, int, LPNMHDR );
BOOL main_OnInitDialog( HWND, HWND, LPARAM );
void main_OnClose( HWND );
void main_OnDestroy( HWND );
BOOL InitToolhelp32 ( void );
void WalkProcesses( void );
void WalkProcess( void );
void DumpProcessMemory( void );
LRESULT CALLBACK dump_wndproc( HWND, UINT, WPARAM, LPARAM );
int ListView_GetFocusItem( HWND );
DWORD ListView_GetItemData( HWND, int );
void __cdecl PrintStatus(LPCSTR, ...);
void SaveSnapshot( HWND );

//
// main 
//
int PASCAL 
WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmd, int nShow)
{
	//
	// init common controls and toolhelp
	//
	InitCommonControls( );
	gfToolhelp = InitToolhelp32( );
	um_dump = RegisterWindowMessage( "Dump!" );
	ghWait = LoadCursor( NULL, IDC_WAIT );

	{
		TEXTMETRIC tm;
		HDC hDC;
		HFONT hFont;

		hDC = CreateCompatibleDC( NULL );
		hFont = SelectFont( hDC, GetStockFont( ANSI_FIXED_FONT ) );
		GetTextMetrics( hDC, &tm );
		SelectFont( hDC, hFont );
		DeleteDC( hDC );
		gcyLine = tm.tmHeight;
	}

	
	//
	// store instance handle (we'll need it later)
	//
	ghInstance = hInstance;

	//
	// create main window (all initializations are inside WM_INITDIALOG)
	//
	DialogBox( hInstance, MAKEINTATOM( IDD_MAIN ), NULL, main_dlgproc );

	return 0;
}

//
// main dialog window proc
//
BOOL CALLBACK 
main_dlgproc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	switch( message ) {
		DLG_MSG( hwnd, WM_COMMAND, main_OnCommand );
		DLG_MSG( hwnd, WM_NOTIFY, main_OnNotify );
		DLG_MSG( hwnd, WM_INITDIALOG, main_OnInitDialog );
		DLG_MSG( hwnd, WM_CLOSE, main_OnClose );
		DLG_MSG( hwnd, WM_DESTROY, main_OnDestroy );
	}

	return FALSE;
}

void 
main_OnCommand( HWND hwnd, UINT id, HWND hCtl, UINT code)
{
	switch( id ) {
	case IDOK:
		if( GetFocus( ) == ghwndProcesses ) {
			WalkProcess( );
			break;
		}
		if( GetFocus( ) == ghwndMemory ) {
			DumpProcessMemory( );
		}
		break;
	case IDM_UPDATE:
		WalkProcesses( );
		break;
	case IDM_SAVE:
		SaveSnapshot( hwnd );
		break;
	case IDM_EXIT:
		PostMessage( hwnd, WM_CLOSE, 0, 0 );
		break;
	}
}

//
//
//
LONG
main_OnNotify( HWND hwnd, int id, LPNMHDR lpHdr )
{

	if( lpHdr->idFrom == IDC_PROCESSES && lpHdr->code == NM_CLICK ) {
		WalkProcess( );
	}

	if( lpHdr->idFrom == IDC_MEMORY && lpHdr->code == NM_CLICK ) {
		DumpProcessMemory( );
	}

	return 0;
}


//
// initialize dialog box
//
BOOL 
main_OnInitDialog( HWND hwnd, HWND hwndFocus, LPARAM lParam )
{
	HICON hIcon;
	RECT R, r, rStatus;
	int x, y, cx, cy;
	LV_COLUMN co;
	
	//
	//
	//
	hIcon = LoadIcon( ghInstance, MAKEINTATOM( IDI_MAIN ) );
	SendMessage( hwnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon );

    // Create the status window.     
	ghwndStatus = CreateStatusWindow( 
		WS_VISIBLE | WS_CHILD | WS_BORDER, 
		" ", hwnd, IDC_STATUS );
	SendMessage( ghwndStatus, SB_SIMPLE, TRUE, 0 );
	GetWindowRect(ghwndStatus, &rStatus );

	//
	// position dialog
	//
	GetWindowRect( hwnd, &r );
	GetWindowRect( GetDesktopWindow( ), &R );
	x = R.left + ((R.right - R.left) - (r.right - r.left)) / 2;
	y = R.top + ((R.bottom - R.top) - (r.bottom - r.top)) / 2;
	x = GetPrivateProfileInt( gszPreferences, gszDialogX, x, gszIniFile);
	y = GetPrivateProfileInt( gszPreferences, gszDialogY, y, gszIniFile);
	cx = r.right - r.left;
	cy = r.bottom - r.top + (rStatus.bottom - rStatus.top);
	SetWindowPos( hwnd, NULL, x, y, cx, cy, SWP_NOZORDER);
	x = rStatus.left;
	y = rStatus.top + (rStatus.bottom - rStatus.top);
	SetWindowPos( ghwndStatus, 0, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE );

	//
	// create columns in "Processes" list control
	//
	ghwndProcesses = GetDlgItem( hwnd, IDC_PROCESSES );
	SetWindowFont( ghwndProcesses, GetStockFont( ANSI_FIXED_FONT ), FALSE );
	Clear( co );
	co.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	co.fmt = LVCFMT_LEFT;
	co.cx = 200;
	co.pszText = "Process";
	ListView_InsertColumn( ghwndProcesses, 0, &co );
	co.pszText = "Total Committed";
	co.cx = 200;
	ListView_InsertColumn( ghwndProcesses, 1, &co );

	ghwndMemory = GetDlgItem( hwnd, IDC_MEMORY );
	SetWindowFont( ghwndMemory, GetStockFont( ANSI_FIXED_FONT ), FALSE );

	co.cx = 100;
	co.fmt = LVCFMT_RIGHT;
	co.pszText = "Address";
	ListView_InsertColumn( ghwndMemory, 0, &co );

	co.pszText = "AllocBase";
	ListView_InsertColumn( ghwndMemory, 1, &co );

	co.pszText = "Size";
	ListView_InsertColumn( ghwndMemory, 2, &co );

	co.cx = 120;
	co.fmt = LVCFMT_LEFT;
	co.pszText = "Protection";
	ListView_InsertColumn( ghwndMemory, 3, &co );
	co.cx = 100;
	co.pszText = "Type";
	ListView_InsertColumn( ghwndMemory, 4, &co );

	FORWARD_WM_COMMAND( hwnd, IDM_UPDATE, 0, 0, PostMessage );
	SetFocus( ghwndProcesses );

	return TRUE;
}

//
// just end dialog
//
void
main_OnClose( HWND hwnd )
{
	EndDialog( hwnd, IDOK );
}

//
//	perform any dialog cleanup
//
void
main_OnDestroy( HWND hwnd )
{
	char buf[12];
	RECT r;

	if( IsWindow( ghwndDump ) ) {
		DestroyWindow( ghwndDump );
	}

	if( gfToolhelp && ghTargetProcess ) {
		CloseHandle( ghTargetProcess );
	}

	if( gfToolhelp && ghSnapshot ) {
		CloseHandle( ghSnapshot );
	}

	//
	// save dialog position
	//
	GetWindowRect( hwnd, &r );
	wsprintf( buf, "%d", r.left );
	WPPS( gszPreferences, gszDialogX, buf, gszIniFile );
	wsprintf( buf, "%d", r.top );
	WPPS( gszPreferences, gszDialogY, buf, gszIniFile );

}

// Function that initializes tool help functions. 
BOOL InitToolhelp32 (void) 
{ 
    BOOL   bRet  = FALSE;     
	HMODULE hKernel = NULL;  

    // Obtain the module handle of the kernel to retrieve addresses of 
    // the tool helper functions. 
    hKernel = GetModuleHandle("KERNEL32.DLL");      
	if (hKernel)    { 
        pCreateToolhelp32Snapshot = 
            (CREATESNAPSHOT)GetProcAddress(hKernel, 
            "CreateToolhelp32Snapshot");  
        pModule32First  = (MODULEWALK)GetProcAddress(hKernel, 
            "Module32First"); 
        pModule32Next   = (MODULEWALK)GetProcAddress(hKernel, 
            "Module32Next");  
        pProcess32First = (PROCESSWALK)GetProcAddress(hKernel, 
            "Process32First"); 
        pProcess32Next  = (PROCESSWALK)GetProcAddress(hKernel, 
            "Process32Next");  
        pThread32First  = (THREADWALK)GetProcAddress(hKernel, 
            "Thread32First"); 
        pThread32Next   = (THREADWALK)GetProcAddress(hKernel, 
            "Thread32Next");  
        // All addresses must be non-NULL to be successful. 
        // If one of these addresses is NULL, one of 
        // the needed lists cannot be walked. 
        bRet =  pModule32First && pModule32Next  && pProcess32First && 
                pProcess32Next && pThread32First && pThread32Next && 
                pCreateToolhelp32Snapshot;     
	} else {
        bRet = FALSE; // could not get the module handle of kernel  
	}
    return bRet; 
}  

void
WalkProcesses( void )
{
	LV_ITEM li;
	int item = 0;
	DWORD dwTasks;
	PROCESSENTRY32 pe;
	HLOCAL hTaskList;
	char *pszExename;
	HCURSOR hCursor = SetCursor( ghWait );

	Clear( pe );
	pe.dwSize = sizeof( pe );

	Clear( li );
	li.mask = LVIF_TEXT | LVIF_PARAM;

	ListView_DeleteAllItems( ghwndProcesses );
	ListView_DeleteAllItems( ghwndMemory );

	if( gfToolhelp ) {
		if( ghSnapshot ) {
			CloseHandle( ghSnapshot );
		}
		ghSnapshot = pCreateToolhelp32Snapshot( TH32CS_SNAPALL, 0 );
		if( !ghSnapshot ) {
			goto done;
		}
		if( pProcess32First( ghSnapshot, &pe ) ) {
			do {
				pszExename = strrchr( pe.szExeFile, '\\' );
				if( pszExename ) {
					pszExename++;
				}else{
					pszExename = pe.szExeFile;
				}
				li.pszText = pszExename;
				li.lParam = pe.th32ProcessID;
				ListView_InsertItem( ghwndProcesses, &li );
				li.iItem = item++;
			} while( pProcess32Next( ghSnapshot, &pe ) );
		}
	}else{

		hTaskList = GetLocalTaskListNt( &dwTasks );
		for( li.iItem = 0; li.iItem < (int) dwTasks; li.iItem++ ) {
	
			GetLocalTaskNameNt( hTaskList, li.iItem, 
				pe.szExeFile, sizeof( pe.szExeFile ) );
			pszExename = strrchr( pe.szExeFile, '\\' );
			if( pszExename ) {
				pszExename++;
			}else{
				pszExename = pe.szExeFile;
			}
			li.pszText = pszExename;
			li.lParam = GetLocalTaskProcessIdNt( hTaskList, li.iItem);
			ListView_InsertItem( ghwndProcesses, &li );
		}
		FreeLocalTaskListNt( hTaskList );
	}
done:
	SetFocus( ghwndProcesses );
	SetCursor( hCursor );
	return ;
}

void 
WalkProcess( void )
{
	MEMORY_BASIC_INFORMATION bi;
	VOID * lpAddress;
	LV_ITEM li;
	int item;
	char buf[32];
	DWORD dwProcess;
	HCURSOR hCursor = SetCursor( ghWait );

	item = ListView_GetFocusItem( ghwndProcesses );
	if( ghTargetProcess && gfToolhelp ) {
		CloseHandle( ghTargetProcess );
	}
	dwProcess = ListView_GetItemData( ghwndProcesses, item );
	__try {
		ghTargetProcess = OpenProcess( 
			PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 
			FALSE, dwProcess );
	} __except( EXCEPTION_EXECUTE_HANDLER ) {
		PrintStatus( "Failure to open process %x (%d)", 
			dwProcess, GetLastError() );
	}

	SetWindowRedraw( ghwndMemory, FALSE );

	Clear( bi );
	Clear( li );
	lpAddress = NULL;

	ListView_DeleteAllItems( ghwndMemory );

	__try {

		while( VirtualQueryEx( ghTargetProcess, lpAddress, &bi, sizeof( bi ) ) ) {
			lpAddress = (PVOID)((DWORD) lpAddress + bi.RegionSize );
			if( bi.State != MEM_COMMIT ) {
				continue;
			}

			li.iSubItem = 0;
 			li.mask = LVIF_TEXT | LVIF_PARAM;
			wsprintf( buf, "%08x", bi.BaseAddress );
			li.pszText = buf;
			li.lParam = (DWORD) bi.BaseAddress;
			ListView_InsertItem( ghwndMemory, &li );

			li.iSubItem = 1;
 			li.mask = LVIF_TEXT;
			wsprintf( buf, "%08x", bi.AllocationBase );
			li.pszText = buf;
			ListView_SetItem( ghwndMemory, &li );

			li.iSubItem = 2;
			wsprintf( buf, "%d", bi.RegionSize );
			li.pszText = buf;
			ListView_SetItem( ghwndMemory, &li );

			li.iSubItem = 3;
			buf[0] = '\0';

			if( (bi.Protect & PAGE_NOACCESS) == PAGE_NOACCESS ) {
				strcat( buf, "NOACCESS " );
			}
			if( (bi.Protect & PAGE_READONLY) == PAGE_READONLY ) {
				strcat( buf, "RO " );
			}
			if( (bi.Protect & PAGE_READWRITE) == PAGE_READWRITE ) {
				strcat( buf, "RW " );
			}
			if( (bi.Protect & PAGE_WRITECOPY) == PAGE_WRITECOPY ) {
				strcat( buf, "WC " );
			}
			if( (bi.Protect & PAGE_EXECUTE) == PAGE_EXECUTE ) {
				strcat( buf, "X " );
			}
			if( (bi.Protect & PAGE_EXECUTE_READ) == PAGE_EXECUTE_READ ) {
				strcat( buf, "XR " );
			}
			if( (bi.Protect & PAGE_EXECUTE_READWRITE) == 
				PAGE_EXECUTE_READWRITE ) {
				strcat( buf, "XRW " );
			}
			if( (bi.Protect & PAGE_EXECUTE_WRITECOPY) == 
				PAGE_EXECUTE_WRITECOPY ) {
				strcat( buf, "XWC " );
			}
			if( (bi.Protect & PAGE_GUARD) == PAGE_GUARD ) {
				strcat( buf, "Guard " );
			}
			if( (bi.Protect & PAGE_NOCACHE) == PAGE_NOCACHE ) {
				strcat( buf, "Nc " );
			}

			li.pszText = buf;
			ListView_SetItem( ghwndMemory, &li );


			li.iSubItem = 4;
			switch( bi.Type ) {
			case MEM_IMAGE:
				li.pszText = "Image";
				break;
			case MEM_MAPPED:
				li.pszText = "Mapped";
				break;
			case MEM_PRIVATE:
				li.pszText = "Private";
				break;
			default:
				li.pszText = "Bogus";
				break;
			}
			ListView_SetItem( ghwndMemory, &li );

			li.iItem++;
		}
	} __except( EXCEPTION_EXECUTE_HANDLER ) {
		PrintStatus( "Failure in VirtualQueryEx (%d)", GetLastError() );
	}

	SetWindowRedraw( ghwndMemory, TRUE );
	InvalidateRect( ghwndMemory, NULL, TRUE );
	UpdateWindow( ghwndMemory );
	SetCursor( hCursor );
}

//
// 
//
void 
DumpProcessMemory( ) 
{
	WNDCLASS wc;
	int x,y,cx,cy;
	int item;
	DWORD dwAddress;
	HCURSOR hCursor = SetCursor( ghWait );

	item = ListView_GetFocusItem( ghwndMemory );
	dwAddress = ListView_GetItemData( ghwndMemory, item );

	if( !GetClassInfo( ghInstance, gszDumpWindowClass, &wc ) ) {
		Clear( wc );
		wc.hInstance = ghInstance;
		wc.lpfnWndProc = dump_wndproc;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.hIcon = LoadIcon( ghInstance, MAKEINTATOM( IDI_DUMP ) );
		wc.hCursor = LoadCursor( NULL, IDC_ARROW );
		wc.cbWndExtra = DUMP_WINDOW_EXTRA;
		wc.lpszClassName = gszDumpWindowClass;

		if(!RegisterClass( &wc ) ) {
			PrintStatus( "Failure to register dump window class" );
			goto done;
		}
	}

	if( !IsWindow( ghwndDump ) ) {

		x = y = cx = cy = CW_USEDEFAULT;

		x = GPPI( gszPreferences, gszDumpX, x, gszIniFile );
		y = GPPI( gszPreferences, gszDumpY, y, gszIniFile );
		cx = GPPI( gszPreferences, gszDumpCX, cx, gszIniFile );
		cy = GPPI( gszPreferences, gszDumpCY, cy, gszIniFile );

		ghwndDump = CreateWindow( gszDumpWindowClass, "", 
			WS_OVERLAPPEDWINDOW | WS_VSCROLL,
			x, y, cx, cy, NULL, NULL, ghInstance, NULL );

		if( ghwndDump ) {
			SendMessage( ghwndDump, um_dump, 
			         (WPARAM) ghTargetProcess, (LPARAM) dwAddress );
			ShowWindow( ghwndDump, SW_SHOW );
			UpdateWindow( ghwndDump );
		}else{
			PrintStatus( "Error: %d", GetLastError() );
		}
	}else{
		SendMessage( ghwndDump, um_dump, 
			     (WPARAM) ghTargetProcess, (LPARAM) dwAddress );
	}
done:
	SetCursor( hCursor );
}

BOOL 
dump_OnCreate( HWND hwnd, LPCREATESTRUCT lpCreate )
{
	SetScrollRange( hwnd, SB_VERT, 0, 100, FALSE );
	SetScrollPos( hwnd, SB_VERT, 0, TRUE );
	return TRUE;
}

void
dump_OnDestroy( HWND hwnd )
{
	RECT r;
	char buf[32];


	GetWindowRect( hwnd, &r );
	wsprintf( buf, "%d", r.left );
	WPPS( gszPreferences, gszDumpX, buf, gszIniFile );
	wsprintf( buf, "%d", r.top );
	WPPS( gszPreferences, gszDumpY, buf, gszIniFile );
	wsprintf( buf, "%d", r.right - r.left );
	WPPS( gszPreferences, gszDumpCX, buf, gszIniFile );
	wsprintf( buf, "%d", r.bottom - r.top );
	WPPS( gszPreferences, gszDumpCY, buf, gszIniFile );

}

void
dump_OnPaint( HWND hwnd )
{
	PAINTSTRUCT ps;
	HFONT hFont;
	RECT r;
	int line, byte, nLines;
	char buf[1024];
	BYTE mem[18];
	char *p = buf;
	DWORD dwOffset = GET_DUMP_OFFSET( hwnd );
	DWORD dwEnd = GET_DUMP_END( hwnd );
	DWORD dwRead;
	HANDLE hProcess = GET_DUMP_PROCESS( hwnd );
	
	BeginPaint( hwnd, &ps );
	hFont = SelectFont( ps.hdc, GetStockObject( ANSI_FIXED_FONT ) );

	GetClientRect( hwnd, &r );
	nLines = (r.bottom - r.top) / gcyLine;

	for( line = 0; line < nLines; line++ ) {
		Clear( mem );

		__try {
			ReadProcessMemory( hProcess, (PVOID) dwOffset, mem, 16, &dwRead );
		} __except( EXCEPTION_EXECUTE_HANDLER ) {
			strcpy( mem, "????????????????");
		}

		wsprintf(buf, "%08x ", dwOffset);

		p = buf + 9;
		for(byte = 0; byte < 16; byte++ ) {
			wsprintf( p, "%02x  ", mem[byte] );
			p += (byte == 7) ? 4 : 3;
		}

		for( byte = 0; byte < 16; byte++ ) {
			if( mem[byte] >= ' ' ) {
				p[byte] = mem[byte]; 
			}else{
				p[byte] = ' ';
			}
		}
		p[16] = '\0';

		TextOut( ps.hdc, 0, line * gcyLine, buf, strlen( buf ) );

		dwOffset += 16;

		if( dwOffset > dwEnd) {
			break;
		}

	}


	SelectFont( ps.hdc, hFont );
	EndPaint( hwnd, &ps );
}

void 
dump_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
	DWORD dwOffset = GET_DUMP_OFFSET( hwnd );
	DWORD dwStart = GET_DUMP_START( hwnd );
	DWORD dwEnd = GET_DUMP_END( hwnd );
	RECT r, ri;
	DWORD cyLines, Line, maxLine, newLine;

	GetClientRect( hwnd, &r );
	r.bottom -= (r.bottom - r.top) % gcyLine;
	cyLines = (r.bottom - r.top) / gcyLine;

	Line = (dwOffset - dwStart ) / 16;
	maxLine = ( dwEnd - dwStart ) / 16 - cyLines;

	switch( code ) {
	case SB_TOP:
		newLine = 0;
		break;
	case SB_BOTTOM:
		newLine = maxLine;
		break;
	case SB_PAGEUP:
		newLine = max( Line - cyLines + 1, 0 );
		break;
	case SB_PAGEDOWN:
		newLine = min( Line + cyLines - 1, maxLine );
		break;
	case SB_LINEUP:
		newLine = max( 0, Line - 1 );
		break;
	case SB_LINEDOWN:
		newLine = min( Line + 1, maxLine );
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		newLine = MulDiv( pos, maxLine, 100 );
		break;
	default:
		goto done;
	}

	SET_DUMP_OFFSET( hwnd, dwStart + newLine * 16 );

	pos = MulDiv(newLine, 100, maxLine );
	SetScrollPos( hwnd, SB_VERT, pos, TRUE );
	ScrollWindowEx( hwnd, 0, ( Line - newLine ) * gcyLine, 
		NULL, &r, NULL, &ri, SW_INVALIDATE );
	InvalidateRect( hwnd, &ri, TRUE );

done:
	UpdateWindow( hwnd );
}

void
dump_OnSize( HWND hwnd, int state, int cx, int cy )
{
	InvalidateRect( hwnd, NULL, TRUE );
	UpdateWindow( hwnd );
}

void
dump_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
	switch( vk ) {
	case VK_DOWN:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_LINEDOWN, 0, PostMessage );
		break;
	case VK_UP:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_LINEUP, 0, PostMessage );
		break;

	case VK_PRIOR:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_PAGEUP, 0, PostMessage );
		break;
	case VK_NEXT:
	case ' ':
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_PAGEDOWN, 0, PostMessage );
		break;

	case VK_HOME:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_TOP, 0, PostMessage );
		break;
	
	case VK_END:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_BOTTOM, 0, PostMessage );
		break;

	case VK_ESCAPE:
		PostMessage( hwnd, WM_CLOSE, 0, 0 );
		break;

	}
}

//
// dump window proc
//
LRESULT CALLBACK
dump_wndproc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	switch( message ) {
		HANDLE_MSG( hwnd, WM_CREATE, dump_OnCreate );
		HANDLE_MSG( hwnd, WM_DESTROY, dump_OnDestroy );
		HANDLE_MSG( hwnd, WM_PAINT, dump_OnPaint );
		HANDLE_MSG( hwnd, WM_VSCROLL, dump_OnVScroll );
		HANDLE_MSG( hwnd, WM_SIZE, dump_OnSize );
		HANDLE_MSG( hwnd, WM_KEYDOWN, dump_OnKey );
	default:
		if( message == um_dump ) {
			char buf[80];
			MEMORY_BASIC_INFORMATION bi;
			HANDLE hProcess = (HANDLE) wParam;
			DWORD dwOffset = (DWORD) lParam;

			wsprintf( buf, "Process %x at %x", wParam, lParam );
			SetWindowText( hwnd, buf );
			SetScrollPos( hwnd, SB_VERT, 0, TRUE );
			InvalidateRect( hwnd, NULL, TRUE );

			Clear( bi );
			if(! VirtualQueryEx( hProcess, (PVOID) dwOffset, 
				                 &bi, sizeof( bi ) ) ) {
				PrintStatus( "Error: %d", GetLastError() );
			}
			SET_DUMP_PROCESS( hwnd, hProcess );
			SET_DUMP_START( hwnd, (DWORD) bi.BaseAddress );
			SET_DUMP_END( hwnd, (DWORD) bi.BaseAddress + bi.RegionSize );
			SET_DUMP_OFFSET( hwnd, (DWORD) bi.BaseAddress );
		}
	}

	return DefWindowProc( hwnd, message, wParam, lParam );
}

//
// returns the number of the item which has focus or -1
//
int ListView_GetFocusItem( HWND hwnd )
{
	int cItems = ListView_GetItemCount( hwnd );
	int item;

	for( item = 0; item < cItems; item++ ) {
		if( ListView_GetItemState( hwnd, item, LVIS_FOCUSED ) ) {
			return item;
		}
	}

	return -1;
}

//
// returns .lParam of the specified item or -1
//
DWORD ListView_GetItemData( HWND hwnd, int item)
{
	LV_ITEM li;

	if( item != -1 ) {
		Clear( li );
		li.mask = LVIF_PARAM;
		li.iItem = item;

		if( ListView_GetItem( hwnd, &li ) ) {
			return li.lParam;
		}
	}

	return (DWORD) -1;
}


//
// formats message to status bar
//
void __cdecl
PrintStatus(LPCSTR fmt, ...)
{
	char buf[4096];
	va_list marker;

	va_start( marker, fmt );
	wvsprintf( buf, fmt, marker );
	va_end( marker );

	SendMessage( ghwndStatus, SB_SETTEXT, 0, (LPARAM) buf );
}

//
//
//
void SaveSnapshot( HWND hwnd )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\setkey\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-28-95   Johnl    Created
//
//----------------------------------------------------------------------------

#define IDS_BASE                       4000

#define IDS_BANNER1                    (IDS_BASE+1)
#define IDS_BANNER2                    (IDS_BASE+2)
#define IDS_BAD_FLAG                   (IDS_BASE+3)
#define IDS_BAD_ARG                    (IDS_BASE+4)
#define IDS_MISSING_ARG                (IDS_BASE+5)
#define IDS_FAILED_TO_SET              (IDS_BASE+6)
#define IDS_SUCCESSFUL_SET             (IDS_BASE+7)
#define IDS_SUCCESSFUL_SET_DEF         (IDS_BASE+8)

#define IDS_USAGE1                     (IDS_BASE+20)
#define IDS_USAGE2                     (IDS_BASE+21)
#define IDS_USAGE3                     (IDS_BASE+22)
#define IDS_USAGE4                     (IDS_BASE+23)
#define IDS_USAGE5                     (IDS_BASE+24)
#define IDS_USAGE6                     (IDS_BASE+25)
#define IDS_USAGE7                     (IDS_BASE+26)
#define IDS_USAGE8                     (IDS_BASE+27)
#define IDS_USAGE9                     (IDS_BASE+28)
#define IDS_USAGE10                    (IDS_BASE+29)
#define IDS_USAGE11                    (IDS_BASE+30)
#define IDS_USAGE12                    (IDS_BASE+31)
#define IDS_USAGE13                    (IDS_BASE+32)
#define IDS_USAGE14                    (IDS_BASE+33)
#define IDS_USAGE15                    (IDS_BASE+34)
#define IDS_USAGE16                    (IDS_BASE+35)
#define IDS_USAGE17                    (IDS_BASE+36)
#define IDS_USAGE18                    (IDS_BASE+37)
#define IDS_USAGE19                    (IDS_BASE+38)
#define IDS_USAGE20                    (IDS_BASE+39)

#define IDS_FILE_NOT_FOUND             (IDS_BASE+50)
#define IDS_KEYCHECK_FAILED            (IDS_BASE+51)
#define IDS_FAILED_OPENING_SERVER      (IDS_BASE+52)
#define IDS_SETSECRET_FAILED           (IDS_BASE+53)
#define IDS_BAD_PASSWORD               (IDS_BASE+54)
#define IDS_SECPKG_NOT_FOUND           (IDS_BASE+55)

#define IDS_NO_KEYS_INSTALLED          (IDS_BASE+70)
#define IDS_DELETE_SUCCESSFUL          (IDS_BASE+71)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\setkey\setkey.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    httpfilt.cxx

Abstract:

    This module contains the code to create or set the HTTP PCT/SSL keys and
    password

Author:

    John Ludeman (johnl)   19-Oct-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>

#define SECURITY_WIN32
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <sslsp.h>
#include <w3svc.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include <strings.h>

//
// macros
//

#define IS_ARG(c)   ((c) == L'-' || (c) == L'/')

#define TO_UNICODE( pch, ach )  \
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, (pch), -1, (ach), sizeof((ach))/sizeof(WCHAR))

#define TO_ANSI( pch, ach )     \
    WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK, pch, -1, ach, sizeof(ach), 0, 0 )

//
//  Private constants.
//

//
//  Private types.
//

BOOL fUUDecode = TRUE;

//
//  Private prototypes.
//

DWORD
SetRegKeys(
    IN  LPWSTR        pszServer,
    IN  LPWSTR        pszPrivateKeyFile,
    IN  LPWSTR        pszCertificateFile,
    IN  LPWSTR        pszPassword,
    IN  LPWSTR        pszAddress
    );

BOOL
SetKeySecret(
    WCHAR * pszServer,
    WCHAR * pszFormat,
    WCHAR * pszAddress,
    VOID *  pvData,
    DWORD   cbData
    );

void usage();

VOID
uudecode_cert(
    char   * bufcoded,
    DWORD  * pcbDecoded
    );

VOID
printfids(
    DWORD ids,
    ...
    );

DWORD
DeleteAll(
    WCHAR * pszServer
    );

BOOL
TsGetSecretW(
    WCHAR *       pszSecretName,
    WCHAR * *     ppchValue
    );

//
//  Public functions.
//


int
__cdecl
main(
    int   argc,
    char * argv[]
    )
{
    DWORD  err;
    CHAR   buff[MAX_PATH+1];
    BOOL   fDeleteAll = FALSE;

    LPWSTR password = NULL;
    LPWSTR privatekey = NULL;
    LPWSTR cert = NULL;
    LPWSTR address = NULL;
    LPWSTR server = NULL;

    WCHAR  achpassword[MAX_PATH+1];
    WCHAR  achprivatekey[MAX_PATH+1];
    WCHAR  achcert[MAX_PATH+1];
    WCHAR  achaddress[MAX_PATH+1];
    WCHAR  achserver[MAX_PATH+1];


    printfids( IDS_BANNER1 );
    printfids( IDS_BANNER2 );

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {

            case 'u':
            case 'U':
                fUUDecode = FALSE;
                break;

            case 'd':
            case 'D':
                fDeleteAll = TRUE;
                break;

            default:
                printfids( IDS_BAD_FLAG, **argv );
                usage();

            }
        } else if ( !server && (*argv)[0] == L'\\' && (*argv)[1] == L'\\'
                    && !password ) {
            TO_UNICODE( (*argv) + 2, achserver );
            server = achserver;
        } else if (!password) {
            TO_UNICODE( *argv, achpassword );
            password = achpassword;
        } else if (!privatekey) {
            TO_UNICODE( *argv, achprivatekey );
            privatekey = achprivatekey;
        } else if (!cert) {
            TO_UNICODE( *argv, achcert );
            cert = achcert;
        } else if (!address) {
            TO_UNICODE( *argv, achaddress );
            address = achaddress;
        } else {
            printfids( IDS_BAD_ARG, *argv);
            usage();
        }
    }

    if ( fDeleteAll )
    {
        return DeleteAll( server );
    }

    //
    //  Address and server are optional
    //

    if (!(password && privatekey && cert)) {
        printfids( IDS_MISSING_ARG );
        usage();
    }

    if ( err = SetRegKeys( server, privatekey, cert, password, address ) )
    {
        printfids( IDS_FAILED_TO_SET );
    }
    else
    {
        if ( address )
        {
            TO_ANSI( address, buff );
            printfids( IDS_SUCCESSFUL_SET,
                       buff );
        }
        else
        {
            printfids( IDS_SUCCESSFUL_SET_DEF );
        }

    }

    return err;

}   // main

void usage()
{
    printfids( IDS_USAGE1 );
    printfids( IDS_USAGE2 );
    //printfids( IDS_USAGE3 );      // -p help
    printfids( IDS_USAGE4 );
    printfids( IDS_USAGE5 );
    printfids( IDS_USAGE6 );
    printfids( IDS_USAGE7 );
    printfids( IDS_USAGE8 );
    printfids( IDS_USAGE9 );
    printfids( IDS_USAGE10 );
    printfids( IDS_USAGE11 );
    printfids( IDS_USAGE12 );
    printfids( IDS_USAGE13 );
    //printfids( IDS_USAGE14 );     // -p help
    printfids( IDS_USAGE15 );
    printfids( IDS_USAGE16 );
    printfids( IDS_USAGE17 );
    printfids( IDS_USAGE18 );
    printfids( IDS_USAGE19 );
    printfids( IDS_USAGE20 );

    exit(1);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetRegKeys
//
//  Synopsis:   This loads the data contained in two files, a private key
//              file, which contains the key, and a certificate file,
//              which contains the certificate of the public portion of the key.
//              These are loaded, then turned into a credential handle, then
//              set in the registry as secrets
//
//  Arguments:  [pszServer]          -- Server to create secrets, NULL for local
//              [pszPrivateKeyFile]  -- Unicode file name
//              [pszCertificateFile] -- Unicode file name
//              [pszPassword]        -- Unicode password
//              [pszAddress]         -- Unicode IP address for name or NULL
//
//  History:    9-27-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SetRegKeys(
    IN  LPWSTR        pszServer,
    IN  LPWSTR        pszPrivateKeyFile,
    IN  LPWSTR        pszCertificateFile,
    IN  LPWSTR        pszPassword,
    IN  LPWSTR        pszAddress
    )
{
    HANDLE          hFile;
    SSL_CREDENTIAL_CERTIFICATE  creds;
    DWORD           cbRead;
    SECURITY_STATUS scRet = 0;
    TimeStamp       tsExpiry;
    CHAR            achPassword[MAX_PATH + 1];
    CredHandle      hCreds;
    DWORD           cch;
    CHAR            buff[MAX_PATH+1];

    //
    // Fetch data from files:
    //

    hFile = CreateFileW( pszPrivateKeyFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                         );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TO_ANSI( pszPrivateKeyFile, buff );

        printfids( IDS_FILE_NOT_FOUND,
                   GetLastError(),
                   buff );

        return GetLastError();
    }

    creds.cbPrivateKey = GetFileSize( hFile, NULL );

    if (creds.cbPrivateKey == (DWORD) -1 )
    {
        CloseHandle( hFile );
        return GetLastError();
    }

    creds.pPrivateKey = LocalAlloc( LMEM_FIXED, creds.cbPrivateKey );

    if ( !creds.pPrivateKey )
    {
        CloseHandle( hFile );
        return GetLastError();
    }

    if (! ReadFile( hFile,
                    creds.pPrivateKey,
                    creds.cbPrivateKey,
                    &cbRead,
                    NULL ) )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        return GetLastError();
    }

    CloseHandle( hFile );

    //
    //  Only the certificate is UUencoded
    //

    hFile = CreateFileW( pszCertificateFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TO_ANSI( pszCertificateFile, buff );
        printfids( IDS_FILE_NOT_FOUND,
                   GetLastError(),
                   buff );

        LocalFree( creds.pPrivateKey );
        return GetLastError();
    }

    creds.cbCertificate = GetFileSize( hFile, NULL );

    if (creds.cbCertificate == (DWORD) -1 )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        return GetLastError();
    }

    creds.pCertificate = LocalAlloc( LMEM_FIXED, creds.cbCertificate + 1);

    if ( !creds.pCertificate )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        return GetLastError();
    }

    if (! ReadFile( hFile,
                    creds.pCertificate,
                    creds.cbCertificate,
                    &cbRead,
                    NULL ) )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        LocalFree( creds.pCertificate );

        return GetLastError();
    }

    CloseHandle( hFile );

    //
    //  Zero terminate so we can uudecode
    //

    ((BYTE *)creds.pCertificate)[cbRead] = '\0';

    if ( fUUDecode )
    {
        uudecode_cert( creds.pCertificate,
                       &creds.cbCertificate );
    }

    //
    // Whew!  Now that we have safely loaded the keys from disk, get a cred
    // handle based on the certificate/prv key combo
    //

    //
    //  BUGBUG - password field should be Unicode, do a quick conversion
    //  until structure is fixed
    //

    cch = TO_ANSI( pszPassword, achPassword );

    if ( !cch )
    {
        return GetLastError();
    }

    creds.pszPassword = achPassword;

    //
    //  Note we always do the credential check locally even if the server is
    //  remote.  This means the local machine must have the correct security
    //  provider package installed.
    //

#if 0
    if ( !pszServer )
    {
#endif
        scRet = AcquireCredentialsHandleW(  NULL,               // My name (ignored)
                                            SSLSP_NAME_W,       // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            &creds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &hCreds,            // Handle
                                            &tsExpiry );

        if ( FAILED(scRet) )
        {
            if ( scRet == SEC_E_NOT_OWNER )
            {
                printfids( IDS_BAD_PASSWORD );
            }
            else if ( scRet == SEC_E_SECPKG_NOT_FOUND )
            {
                printfids( IDS_SECPKG_NOT_FOUND );
            }
            else
            {
                printfids( IDS_KEYCHECK_FAILED,
                           scRet );
            }
        }
#if 0
    }
    else
    {
        printf("\nWarning! Bypassing credential check because target is remote\n");
    }
#endif

    //
    //  If we successfully acquired a credential handle, set the secrets
    //

    if ( !FAILED( scRet ))
    {
        if ( !pszServer )
        {
            FreeCredentialsHandle( &hCreds );
        }

        //
        //  Supply the default name if none was supplied
        //

        if ( !pszAddress )
            pszAddress = L"Default";

        //
        //  Set the secrets
        //

        if ( !SetKeySecret( pszServer,
                            L"W3_PUBLIC_KEY_%s",
                            pszAddress,
                            creds.pCertificate,
                            creds.cbCertificate ) ||
             !SetKeySecret( pszServer,
                            L"W3_PRIVATE_KEY_%s",
                            pszAddress,
                            creds.pPrivateKey,
                            creds.cbPrivateKey ) ||
             !SetKeySecret( pszServer,
                            L"W3_KEY_PASSWORD_%s",
                            pszAddress,
                            achPassword,
                            strlen( achPassword ) + 1) )
        {
            printfids( IDS_SETSECRET_FAILED,
                       GetLastError());

            scRet = (SECURITY_STATUS) GetLastError();
        }
        else
        {
            WCHAR InstalledKeys[16384];
            WCHAR * pchKeys;

            *InstalledKeys = L'\0';

            //
            //  Ok if this fails, it may not exist yet
            //

            if ( TsGetSecretW( W3_SSL_KEY_LIST_SECRET,
                               &pchKeys ))
            {
                wcscpy( InstalledKeys, pchKeys );
            }

            wcscat( InstalledKeys, pszAddress );
            wcscat( InstalledKeys, L"," );

#if DBG
            printf("New list: %S\n", InstalledKeys);
#endif

            if ( !SetKeySecret( pszServer,
                                L"W3_KEY_LIST",
                                pszAddress,
                                InstalledKeys,
                                (wcslen( InstalledKeys ) + 1) * sizeof(WCHAR)))
            {
#if DBG
                printf("Warning: failed to set key list data, error %d\n");
#endif
                scRet = (SECURITY_STATUS) GetLastError();
            }
        }
    }

    //
    // Zero out and free the key data memory, on success or fail
    //

    ZeroMemory( creds.pPrivateKey, creds.cbPrivateKey );
    ZeroMemory( creds.pCertificate, creds.cbCertificate );
    ZeroMemory( achPassword, cch );
    ZeroMemory( pszPassword, cch );

    LocalFree( creds.pPrivateKey );
    LocalFree( creds.pCertificate );

    //
    // Tell the caller about it.
    //

    return( scRet );

}

BOOL
SetKeySecret(
    WCHAR * pszServer,
    WCHAR * pszFormat,
    WCHAR * pszAddress,
    VOID *  pvData,
    DWORD   cbData
    )
{
    BOOL                  fResult;
    NTSTATUS              ntStatus;
    LSA_UNICODE_STRING    unicodeName;
    LSA_UNICODE_STRING    unicodeSecret;
    LSA_UNICODE_STRING    unicodeServer;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR                 achSecretName[MAX_PATH+1];
    CHAR                  buff[MAX_PATH+1];


    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    if ( pszServer )
    {
        unicodeServer.Buffer        = pszServer;
        unicodeServer.Length        = wcslen( pszServer ) * sizeof(WCHAR);
        unicodeServer.MaximumLength = unicodeServer.Length + sizeof(WCHAR);
    }

    ntStatus = LsaOpenPolicy( pszServer ? &unicodeServer : NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );

        TO_ANSI( pszServer, buff );

        printfids(IDS_FAILED_OPENING_SERVER,
                  buff,
                  GetLastError() );

        return FALSE;
    }

    //
    //  Build the secret name
    //

    wsprintfW( achSecretName,
               pszFormat,
               pszAddress );

    unicodeSecret.Buffer        = pvData;
    unicodeSecret.Length        = (USHORT) cbData;
    unicodeSecret.MaximumLength = (USHORT) cbData;

    unicodeName.Buffer        = achSecretName;
    unicodeName.Length        = wcslen( achSecretName ) * sizeof(WCHAR);
    unicodeName.MaximumLength = unicodeName.Length + sizeof(WCHAR);

    //
    //  Query the secret value.
    //

    ntStatus = LsaStorePrivateData( hPolicy,
                                    &unicodeName,
                                    pvData ? &unicodeSecret : NULL );

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    LsaClose( hPolicy );

    if ( !fResult )
        SetLastError( LsaNtStatusToWinError( ntStatus ));

    return fResult;

}   // SetKeySecret

VOID
printfids(
    DWORD ids,
    ...
    )
{
    CHAR szBuff[2048];
    CHAR szString[2048];
    va_list  argList;

    //
    //  Try and load the string
    //

    if ( !LoadString( GetModuleHandle( NULL ),
                      ids,
                      szString,
                      sizeof( szString ) ))
    {
        printf( "Error loading string ID %d\n",
                ids );

        return;
    }

    va_start( argList, ids );
    vsprintf( szBuff, szString, argList );
    va_end( argList );

    printf( szBuff );
}

const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//
//  We have to squirt a record into the decoded stream
//

#define CERT_RECORD            13
#define CERT_SIZE_HIBYTE        2       //  Index into record of record size
#define CERT_SIZE_LOBYTE        3

unsigned char abCertHeader[] = {0x30, 0x82,           // Record
                                0x00, 0x00,           // Size of cert + buff
                                0x04, 0x0b, 0x63, 0x65,// Cert record data
                                0x72, 0x74, 0x69, 0x66,
                                0x69, 0x63, 0x61, 0x74,
                                0x65 };

VOID uudecode_cert(char   * bufcoded,
                   DWORD  * pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout = bufcoded;
    unsigned char *pbuf;
    int nprbytes;
    char * beginbuf = bufcoded;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' ||
          *bufcoded == '\t' ||
          *bufcoded == '\r' ||
          *bufcoded == '\n' )
    {
          bufcoded++;
    }

    //
    //  If there is a beginning '---- ....' then skip the first line
    //

    if ( bufcoded[0] == '-' && bufcoded[1] == '-' )
    {
        bufin = strchr( bufcoded, '\n' );

        if ( bufin )
        {
            bufin++;
            bufcoded = bufin;
        }
        else
        {
            bufin = bufcoded;
        }
    }
    else
    {
        bufin = bufcoded;
    }

    //
    //  Strip all cr/lf from the block
    //

    pbuf = bufin;
    while ( *pbuf )
    {
        if ( *pbuf == '\r' || *pbuf == '\n' )
        {
            memmove( pbuf, pbuf+1, strlen( pbuf + 1) + 1 );
        }
        else
        {
            pbuf++;
        }
    }

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */

    while(pr2six[*(bufin++)] <= 63);
    nprbytes = bufin - bufcoded - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin  = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    //
    //  Now we need to add a new wrapper sequence around the certificate
    //  indicating this is a certificate
    //

    memmove( beginbuf + sizeof(abCertHeader),
             beginbuf,
             nbytesdecoded );

    memcpy( beginbuf,
            abCertHeader,
            sizeof(abCertHeader) );

    //
    //  The beginning record size is the total number of bytes decoded plus
    //  the number of bytes in the certificate header
    //

    beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
    beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);

    nbytesdecoded += sizeof(abCertHeader);

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;
}

BOOL
TsGetSecretW(
    WCHAR *       pszSecretName,
    WCHAR * *     ppchValue
    )
/*++
    Description:

        Retrieves the specified unicode secret

        Note we're loose with the allocated buffer since we're a simple
        command line app.

    Arguments:

        pszSecretName - LSA Secret to retrieve
        ppchValue - Receives pointer to allocated buffer

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    NTSTATUS              ntStatus;
    LSA_UNICODE_STRING *  punicodePassword = NULL;
    LSA_UNICODE_STRING    unicodeSecret;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;


    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    unicodeSecret.Buffer        = pszSecretName;
    unicodeSecret.Length        = wcslen( pszSecretName ) * sizeof(WCHAR);
    unicodeSecret.MaximumLength = unicodeSecret.Length + sizeof(WCHAR);

    //
    //  Query the secret value.
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    if( NT_SUCCESS(ntStatus) )
    {
        *ppchValue = (WCHAR *) punicodePassword->Buffer;

        return TRUE;
    }

    return FALSE;

}   // TsGetSecretW

DWORD
DeleteAll(
    WCHAR * pszServer
    )
{
    WCHAR * pchKeys;
    WCHAR * pszAddress;

    if ( !TsGetSecretW( L"W3_KEY_LIST",
                        &pchKeys ))
    {
        printfids( IDS_NO_KEYS_INSTALLED );
        return NO_ERROR;
    }

#if DBG
    printf("Installed keys: %S\n", pchKeys);
#endif

    pszAddress = pchKeys;
    while ( pchKeys = wcschr( pchKeys, L',' ))
    {
        //
        //  Ignore empty segments
        //

        if ( *pszAddress != L',' )
        {
            *pchKeys = L'\0';

#if DBG
            printf("deleting %S\n", pszAddress );
#endif

            //
            //  Nuke the secrets
            //

            SetKeySecret( pszServer,
                          L"W3_PUBLIC_KEY_%s",
                          pszAddress,
                          NULL,
                          0 );
            SetKeySecret( pszServer,
                          L"W3_PRIVATE_KEY_%s",
                          pszAddress,
                          NULL,
                          0 );
            SetKeySecret( pszServer,
                          L"W3_KEY_PASSWORD_%s",
                          pszAddress,
                          NULL,
                          0 );
        }

        pchKeys++;
        pszAddress = pchKeys;
    }

    //
    //  Now delete the list key
    //


    if ( !SetKeySecret( pszServer,
                        L"W3_KEY_LIST",
                        L"",
                        NULL,
                        0 ))
    {
#if DBG
        printf("Warning: failed to set key list data, error %d\n");
#endif
        return GetLastError();
    }

    printfids( IDS_DELETE_SUCCESSFUL );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\dllexist\main.cpp ===
/* DLLexist.exe July 1998
	
		DLLexist is a command line tool made for use with the IIS/Terrain Toolkit.
	  
		It finds the directory where IIS is installed by checking the registry key 
		of the IISADMIN Service.  

		Then it dumps the Name, Size, Version Number, Manufacturer and Description
		of every DLL in the IIS directory.

		This information is output to standard out where it is meant to be
		piped to a file.
*/


#include <windows.h>		// for file calls	
#include <iostream.h>
#include <string.h>			// for strlen function and others
#include <stdio.h>			// for printf function and others


#define IISADMINKEY "SYSTEM\\CurrentControlSet\\Services\\IISADMIN"
#define IISADMINNAME "ImagePath"
#define IISEXENAME "\\inetinfo.exe"	
// above are used to find the IIS install directory

#define NOTAVAILABLE "NA"			// when a version # or size is unavailable


void GetFileVer( CHAR *szFileName, CHAR *szVersion, CHAR *szCompanyName, CHAR *szFileDescription );
void GetFileSize( CHAR *szFileName, CHAR *szSize );
BOOL getIISDir(char *, unsigned int);
BOOL setCurrentDir(char *);
void printCurrentDir(void);
void printFileName(WIN32_FIND_DATA *);



int __cdecl  main(int argc, char** argv)
{	
	char buff[255];
	WIN32_FIND_DATA foundFileData;
	HANDLE searchHandle;

	// get the IIS install directory in buff
	if(!getIISDir(buff,256))
		return 1;

	// set cwd to the IIS install dir
	if(!setCurrentDir(buff))
		return 1;

	//Print the header information
	printf("%-12s %-15s %-10s %-30s %-30s","Filename","Version","FileSize","Company","Description");
	printf("\n");

	// Loop through all DLL's and dump their information
	searchHandle = FindFirstFile("*.dll",&foundFileData);
	if(searchHandle == INVALID_HANDLE_VALUE)
		return 1;

	printFileName(&foundFileData); 
	while( (FindNextFile(searchHandle,&foundFileData)) != 0 )
		printFileName(&foundFileData);

	return 0;
	
}


// prints the cFileName member of a WIN32_FIND_DATA struct
// THIS FUNCTION TRUSTS that d points to a VALID structure
// on same line, the version number is also printed;
void printFileName(WIN32_FIND_DATA *d)
{
	char *version = new char[256];
	char *filesize = new char[256];
	char *company = new char[256];
	char *description = new char[256];

	GetFileVer(d->cFileName,version,company,description);
	GetFileSize(d->cFileName,filesize);

	printf("%-12s %-15s %-10s %-30s %-30s",d->cFileName,version,filesize,company,description);
	printf("\n");

	delete [] version;
	delete [] filesize;
	delete [] company;
	delete [] description;
}

// attempts to change current directory to directory specified in p
// return true if successful, false otherwise
BOOL setCurrentDir(char *p)
{
	if( (SetCurrentDirectory(p))==0)
		return false;
	else
		return true;
}

// prints current working directory
void printCurrentDir(void)
{
	char buffer[255];
	if((GetCurrentDirectory(256,buffer)==0) )
		printf("Current Directory Failed\n");
	else
		printf("%s\n", buffer);

	return;
}


// getIISDir(...) returns the IIS directory.
// It does a lookup in the registry for the IISADMIN service to get the IIS directory
// c is buffer to put IIS path in
// s is the size of c
// depends on the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\IISADMIN\ImagePath Key
BOOL getIISDir(char *c, unsigned int s)
{

	DWORD buffSize;
	unsigned char buffer[255];
	LONG retVal;
	HKEY iisKey;
	int stringSize;

	buffSize = 256;
	retVal = RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
							IISADMINKEY,
							0, 
							KEY_EXECUTE, 
							&iisKey 
						); 
	if(retVal != ERROR_SUCCESS)
		return false;

	retVal =  RegQueryValueEx(	iisKey,
								IISADMINNAME, 
								NULL, 
								NULL,
								buffer, 
								&buffSize 
						); 
	if(retVal != ERROR_SUCCESS)
		return false;

	stringSize = strlen((const char*)buffer);
	buffer[stringSize-strlen(IISEXENAME)] = 0;
	
	if( s< (strlen( (const char*)buffer)))
			return false;

	strcpy(c,(const char*)buffer);
	return true;
}


/* 
	GetFileSize takes a filename in szFileName and returns the
	size of that file in bytes in szSize.  If GetFileSize fails
	then NOTAVAILABLE is returned in szSize
*/
void GetFileSize( CHAR *szFileName, CHAR *szSize )
{
	HANDLE fileHandle;
	DWORD	fileSize;

	fileHandle = CreateFile(szFileName, 
							GENERIC_READ,  
							FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
							NULL,
							OPEN_EXISTING,
							NULL,
							NULL);
	
	if(fileHandle == INVALID_HANDLE_VALUE)
	{
		strcpy(szSize,NOTAVAILABLE);
		return;
	}

	fileSize = GetFileSize(	fileHandle,
							NULL 
						   );
 
	if(fileSize == 0xFFFFFFFF)
	{
		strcpy(szSize,NOTAVAILABLE);
		return;
	}
	wsprintf(szSize,"%d",fileSize);
	CloseHandle(fileHandle);
}



/* 
	Get FileVer Info, grabbed from tonygod

	szFilename contains filename
	szVersion will contain versionInfo if successful
	NOTAVAILABLE otherwise

	szCompanyName will contain companyName if successful
	NOTAVAILABLE otherwise

	szFileDescription will contain fileDescription if successful
	NOTAVAILABLE otherwise

*/

void GetFileVer( CHAR *szFileName, CHAR *szVersion, CHAR *szCompanyName, CHAR *szFileDescription)
{
    BOOL bResult;
    DWORD dwHandle = 0;
    DWORD dwSize = 0;
    LPVOID lpvData;
    UINT uLen;
    VS_FIXEDFILEINFO *pvs;
	LPVOID	buffer;  // a void *

    dwSize = GetFileVersionInfoSize( szFileName, &dwHandle );
    if ( dwSize == 0 ) 
	{
		strcpy(szVersion,NOTAVAILABLE);
		strcpy(szCompanyName,NOTAVAILABLE);
		strcpy(szFileDescription,NOTAVAILABLE); 
        return;
    }
		
    lpvData = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize );
    if ( lpvData == NULL ) 
	{
        strcpy(szVersion,NOTAVAILABLE);
		strcpy(szCompanyName,NOTAVAILABLE);
		strcpy(szFileDescription,NOTAVAILABLE); 
        return;
    }
    
    bResult = GetFileVersionInfo(
        szFileName,
        dwHandle,
        dwSize,
        lpvData
        );

    if ( !bResult ) 
	{
        strcpy(szVersion,NOTAVAILABLE);
		strcpy(szCompanyName,NOTAVAILABLE);
		strcpy(szFileDescription,NOTAVAILABLE); 
        return;	
    }

    bResult = VerQueryValue(	lpvData,
								"\\",
								(LPVOID *)&pvs,
								&uLen
							);
    if ( !bResult ) 
        strcpy(szVersion,NOTAVAILABLE);
	else
		wsprintf( szVersion, "%d.%d.%d.%d",		HIWORD(pvs->dwFileVersionMS),
												LOWORD(pvs->dwFileVersionMS),
												HIWORD(pvs->dwFileVersionLS),
												LOWORD(pvs->dwFileVersionLS));

	
	/* the below query strings need to be fixed, should make a call to VerQueryValue with \VarInfo\Translation */
	/* right now it checks for unicode first and then it checks for Us English, this picks up all this works ... must
		fix later*/
	
	char szQueryStr[ 0x100 ];
	char szQueryStr2[0x100 ];
 
	// Format the strings with the 1200 codepage (Unicode)
	wsprintf(szQueryStr,"\\StringFileInfo\\%04X%04X\\%s",GetUserDefaultLangID(), 1200,"FileDescription" );
	wsprintf(szQueryStr2, "\\StringFileInfo\\%04X%04X\\%s", GetUserDefaultLangID(), 1200, "CompanyName" );
	
	bResult = VerQueryValue(lpvData,szQueryStr,&buffer,&uLen);               
	if(uLen == 0)
	{
		VerQueryValue(lpvData,"\\StringFileInfo\\040904E4\\FileDescription",&buffer,&uLen);
		if(uLen == 0)
			strcpy(szFileDescription,NOTAVAILABLE);
		else
			strcpy(szFileDescription,(const char *)buffer);	
	}
	else
	{
		strcpy(szFileDescription,(const char *)buffer);
	}


	bResult = VerQueryValue(lpvData,szQueryStr2,&buffer,&uLen);              
	if(uLen == 0)
	{
		VerQueryValue(lpvData,"\\StringFileInfo\\040904E4\\CompanyName",&buffer,&uLen);              
		if(uLen == 0)
			strcpy(szCompanyName,NOTAVAILABLE);
		else
			strcpy(szCompanyName,(const char *)buffer);		
	}
	else
	{
		strcpy(szCompanyName,(const char *)buffer);
	}
    HeapFree( GetProcessHeap(), 0, lpvData );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\ipperm\uiutils.cpp ===
#include "uiutils.h"

BOOL
ADDRESS_CHECK::LocateName(
    BOOL fGrant,
    DWORD iIndex,
    PNAME_HEADER* ppHd,
    PNAME_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate a name in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list ( 0-based )
    ppHd - updated with ptr to name header
    pHeader - updated with ptr to name list entry
    piIndexInHeader - updated with index in array pHeader->iName

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    PNAME_LIST_ENTRY    pE;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( iIndex < pE->cNames )
            {
                *pHeader = pE;
                *piIndexInHeader = iIndex;
                return TRUE;
            }
            iIndex -= pE->cNames;
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
    }

    return FALSE;
}



//inline
DWORD
ADDRESS_CHECK::GetNbAddr(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        return pHd->cAddresses;
    }

    return 0;
}


BOOL
ADDRESS_CHECK::BindCheckList(
    LPBYTE p,
    DWORD c
    )
/*++

Routine Description:

    Bind a check list ( presented as a BLOB ) to an
    ADDRESS_CHECK object

Arguments:

    p - ptr to BLOB
    c - size of BLOB

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    PADDRESS_CHECK_LIST pList;
    UINT                l;

  /*  if ( p == NULL )
    {
        if ( m_Storage.Init() && m_Storage.Resize( sizeof(ADDRESS_CHECK_LIST)
                + sizeof(ADDRESS_HEADER) * 2
                + sizeof(NAME_HEADER) * 2 ) )
        {
            DWORD i;
            pList = (PADDRESS_CHECK_LIST)m_Storage.GetAlloc();
            pList->iDenyAddr = i = MAKEREF( sizeof(ADDRESS_CHECK_LIST) );
            i += sizeof(ADDRESS_HEADER);
            pList->iGrantAddr = i;
            i += sizeof(ADDRESS_HEADER);
            pList->iDenyName = i;
            i += sizeof(NAME_HEADER);
            pList->iGrantName = i;
            i += sizeof(NAME_HEADER);
            pList->cRefSize = MAKEOFFSET(i);
            pList->dwFlags = RDNS_FLAG_DODNS2IPCHECK;

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
  */  {
        return m_Storage.Init( p, c );
    }
}


BOOL
ADDRESS_CHECK::GetAddr(
    BOOL fGrant,
    DWORD iIndex,
    LPDWORD pdwFamily,
    LPBYTE* pMask,
    LPBYTE* pAddr
    )
/*++

Routine Description:

    Get an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    pdwFamily - updated with address family ( as in sockaddr.sa_type )
    pMask - updated with ptr to mask
    pAddr - updated with ptr to address

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PADDRESS_LIST_ENTRY pHeader;
    PADDRESS_HEADER     pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateAddr( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        UINT cS = GetAddrSize( pHeader->iFamily );
        *pdwFamily = pHeader->iFamily;
        pStore = MAKEPTR(pStore, pHeader->iFirstAddress);
        *pMask = pStore;
        *pAddr = pStore+iIndexInHeader*cS;

        return TRUE;
    }

    return FALSE;
}

  
BOOL
ADDRESS_CHECK::GetName(
    BOOL        fGrant,
    DWORD       iIndex,
    LPSTR*      ppName,
    LPDWORD     pdwFlags
    )
/*++

Routine Description:

    Get DNS name in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index (0-based) in specified list
    ppName - updated with ptr to DNS name
    pdwFlags - updated with DNS flags, can be NULL

Return Value:

    TRUE if iIndex valid in specified list, otherwise FALSE

--*/
{
    PNAME_LIST_ENTRY    pHeader;
    PNAME_HEADER        pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateName( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        *ppName = (LPSTR)MAKEPTR(pStore, pHeader->iName[iIndexInHeader] );
        if ( pdwFlags )
        {
            *pdwFlags = pHeader->cComponents & DNSLIST_FLAGS;
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
ADDRESS_CHECK::GetNbName(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        return pHd->cNames;
    }

    return 0;
}

UINT
ADDRESS_CHECK::GetAddrSize(
    DWORD dwF
    )
/*++

Routine Description:

    Returns address size in byte based on family ( sockaddr.sa_type )

Arguments:

    dwF - address family ( as in sockaddr.sa_type )

Return Value:

    Address length, in byte. 0 for unknown address families

--*/
{
    DWORD dwS;

   // switch ( dwF )
   // {
     //   case AF_INET:
            dwS = SIZEOF_IP_ADDRESS;
       //     break;

       // default:
         //   dwS = 0;
           // break;
   // }

    return dwS;
}
BOOL
ADDRESS_CHECK::LocateAddr(
    BOOL fGrant,
    DWORD iIndex,
    PADDRESS_HEADER* ppHd,
    PADDRESS_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate an address in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    ppHd - updated with ptr to address header
    pHeader - updated with ptr to address list entry
    piIndexInHeader - updated with index in array addressed by
                      pHeader->iFirstAddress

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            // adjust index by 1: 1st entry is mask
            if ( iIndex < (pHd->Entries[iL].cAddresses-1) )
            {
                *pHeader = pHd->Entries+iL;
                *piIndexInHeader = iIndex+1;
                return TRUE;
            }
            iIndex -= (pHd->Entries[iL].cAddresses-1);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\ipperm\ipperm.cpp ===
//***********************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  metasnap.cpp
//  
//  Description: Metabase Snapshot utility tool main  
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//***********************************************************




#define INITGUID

#define E_UNKNOWN_ARG 0x10000
#define E_WRONG_NUMBER_ARGS 0x20000
#define E_NULL_PTR 0x30000

#define DEFAULT_MD_TIMEOUT 0x1000
#define DEFAULT_GETALL_BUFFER_SIZE 4096
//#define DBG_ASSERT(exp)
//# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

//#include "stdafx.h"
//#include "winsock.h"
//#undef dllexp
//#include "tcpdllp.hxx"
//#define  _RDNS_STANDALONE
//#include "afx.h"
#include <objbase.h>
#include <coguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <mbstring.h>

#include "iadmw.h"
#include "iiscnfg.h"
#include "uiutils.h"

//#include <pudebug.h>
//extern "C" DEBUG_PRINTS * g_pDebug = NULL;

//#undef dllexp
//#include "tcpdllp.hxx"
//#define  _RDNS_STANDALONE


enum ERROR_PARAMETER
{
	MACHINE_NAME,
	START_KEY_NAME,
};

struct _CMD_PARAMS
{
	LPWSTR szMachineName;
	LPWSTR szStartKey;
	BOOL bShowSecure; //
	DWORD dwErrParameter; // to determine which parameter is incorrect
};

typedef struct _CMD_PARAMS CMD_PARAMS;
//typedef CString* pCString;

// Global variables:

//DWORD* dwSortArray;
PBYTE pbGetAllBuffer;

// Function prototypes:

HRESULT PrintKeyRecursively(IMSAdminBase *pcAdmCom, WCHAR *lpwstrFullPath, CMD_PARAMS* pcpCommandStructure);
HRESULT PrintAllPropertiesAtKey (IMSAdminBase *pcAdmCom, METADATA_HANDLE hmdHandle, 
							                          CMD_PARAMS* pcpCommandStructure);
VOID    PrintProperty(METADATA_GETALL_RECORD & mdr, BOOL bShowSecure);
VOID    PrintDataTypeAndValue(METADATA_GETALL_RECORD *pmdgr, BOOL bShowSecure);

DWORD ParseCommands (int argc, char *argv[], CMD_PARAMS *pcpCommandStructure);
VOID DisplayHelp();


// new stuff
DWORD
AddAccessEntries(
    IN  ADDRESS_CHECK & ac,
    IN  BOOL fName,
    IN  BOOL fGrant,
    //OUT CObListPlus & oblAccessList,
    OUT DWORD & cEntries
    )
/*++

Routine Description:

    Add specific kind of addresses from the list to the oblist of
    access entries

Arguments:

    ADDRESS_CHECK & ac              : Address list input object
    BOOL fName                      : TRUE for names, FALSE for ip
    BOOL fGrant                     : TRUE for granted, FALSE for denied        
    CObListPlus & oblAccessList     : ObList to add access entries to
    int & cEntries                  : Returns the number of entries
    
Return Value:

    Error code

Notes:

    Sentinel entries (ip 0.0.0.0) are not added to the oblist, but
    are reflected in the cEntries return value

--*/
{
    DWORD i;
    DWORD dwFlags;

    if (fName)
    {
        //
        // Domain names
        //
        LPSTR lpName;

        cEntries = ac.GetNbName(fGrant);
		//printf("Number of names: %ld.\n",cEntries);
        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetName(fGrant, i,  &lpName, &dwFlags))
            {
				if (fGrant)
					printf("\tGranted to %s.\n",lpName);
				else
					printf("\tDenied to %s.\n",lpName);
			/*CString strDomain(lpName);
                if (!(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN))
                {
                    strDomain = _T("*.") + strDomain;
                }*/

                //oblAccessList.AddTail(new CIPAccessDescriptor(fGrant, strDomain));
            }
        }
    }
    else
    {
        //
        // IP Addresses
        //
        LPBYTE lpMask;
        LPBYTE lpAddr;
        cEntries = ac.GetNbAddr(fGrant);
		//printf("Number of addresses: %ld.\n",cEntries);
        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetAddr(fGrant, i,  &dwFlags, &lpMask, &lpAddr))
            {
	 			if (lpAddr[0] != 0 || lpAddr[1] != 0 || lpAddr[2] !=0 || lpAddr[3] !=0)
				{

 					if (lpAddr[0] != 0 || lpAddr[1] != 0 || lpAddr[2] !=0 || lpAddr[3] !=0)
					if (fGrant)
						printf("\tGranted to %d",lpAddr[0]);
					else
						printf("\tDenied to %d",lpAddr[0]);

					for (int j = 1; j<4; j++)
						printf(".%d",lpAddr[j]);
					
 					if (lpMask[0] != 255 || lpMask[1] != 255 || lpMask[2] !=255 || lpMask[3] !=255)
					{
						printf(" (Mask: %d",lpMask[0]);					
						for (int j = 1; j<4; j++)
							printf(".%d",lpMask[j]);
						printf(")");
					}
					printf(".\n");
				}
				else 
					printf("\tDenied to everyone.\n");
            }
        }
    }

    return ERROR_SUCCESS;
}
DWORD
BuildIplOblistFromBlob(
    IN METADATA_GETALL_RECORD & mdgr
	//OUT CObListPlus & oblAccessList,
   // OUT BOOL & fGrantByDefault
    )
{
    //oblAccessList.RemoveAll();

    if (mdgr.dwMDDataLen == 0)
    {
        return ERROR_SUCCESS;
    }

    ADDRESS_CHECK ac;
    ac.BindCheckList(mdgr.pbMDData, mdgr.dwMDDataLen);

    DWORD cGrantAddr, cGrantName, cDenyAddr, cDenyName;

    //                   Name/IP Granted/Deny
    // ============================================================
    AddAccessEntries(ac, TRUE,   TRUE, cGrantName);
    AddAccessEntries(ac, FALSE,  TRUE, cGrantAddr);
    AddAccessEntries(ac, TRUE,   FALSE, cDenyName);
    AddAccessEntries(ac, FALSE,  FALSE, cDenyAddr);

    ac.UnbindCheckList();

//    fGrantByDefault = (cDenyAddr + cDenyName != 0L)
  //      || (cGrantAddr + cGrantName == 0L);

    return ERROR_SUCCESS;
}  




// end new



VOID __cdecl main (int argc, char *argv[])
{
	if (argc == 1)
	{
		DisplayHelp();
		return;
	}
	
	CMD_PARAMS pcpCommands;
	DWORD dwRetVal = ParseCommands (argc, argv, &pcpCommands);

	if (dwRetVal != ERROR_SUCCESS)
	{
		if (dwRetVal == E_OUTOFMEMORY)
			fprintf (stderr, "ERROR: Out of memory.");
		else if (dwRetVal == E_WRONG_NUMBER_ARGS)
			fprintf (stderr, "ERROR: Invalid number of arguments.");
		else if (dwRetVal == E_INVALIDARG)
		{
			fprintf (stderr, "ERROR: Invalid input value");
			switch (pcpCommands.dwErrParameter)
			{
				case (MACHINE_NAME):
					fputs (" for MachineName.", stderr);
					break;
				case (START_KEY_NAME):
					fputs (" for StartKey.", stderr);
					break;
				default:
					fputs (".", stderr);
					break;
			}
		}
		else 
			fprintf (stderr, "ERROR: Unknown error in processing arguments.");

		fputs(" Enter \"metasnap\" without arguments to display help.\n", stderr);
		return;
	}

	IMSAdminBase *pcAdmCom = NULL;   //interface pointer
	IClassFactory * pcsfFactory = NULL;
	COSERVERINFO csiMachineName;
	COSERVERINFO *pcsiParam = NULL;

	// Fill the structure for CoGetClassObject:
		csiMachineName.pAuthInfo = NULL;
		csiMachineName.dwReserved1 = 0;
		csiMachineName.dwReserved2 = 0;
		pcsiParam = &csiMachineName;
		csiMachineName.pwszName = pcpCommands.szMachineName;

	// Initialize COM:
    HRESULT hresError = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hresError))
	{
		fprintf (stderr, "ERROR: COM Initialization failed. Error: %d (%#x)\n", hresError, hresError);
        return;
	}

	hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
							IID_IClassFactory, (void**) &pcsfFactory);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(REGDB_E_CLASSNOTREG): 
			fprintf(stderr, "ERROR: IIS Metabase does not exist.\n");
			break;
		case HRESULT_FROM_WIN32(E_ACCESSDENIED): 
			fprintf(stderr, "ERROR: Access to Metabase denied.\n");
			break;
		case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):  
			fprintf(stderr, "ERROR: The specified host is unavailable.\n");
			break;
 		default:
			fprintf (stderr, "ERROR: Couldn't get Metabase Object. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
        return;
	}

	hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcAdmCom);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(RPC_S_SEC_PKG_ERROR):
			fprintf (stderr, "ERROR: A security-related error occurred.\n");
			break;
		case HRESULT_FROM_WIN32(E_OUTOFMEMORY):
			fprintf (stderr, "ERROR: There is not enough memory available.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't create Metabase Instance. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		pcsfFactory->Release();
		return;
	}

	pcsfFactory->Release();

	METADATA_HANDLE hmdHandle;
	
	hresError = pcAdmCom->OpenKey (
								METADATA_MASTER_ROOT_HANDLE,
								pcpCommands.szStartKey,
								METADATA_PERMISSION_READ,
								DEFAULT_MD_TIMEOUT,
								&hmdHandle);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
			fprintf (stderr, "ERROR: The specified key is already in use.\n"); 
			break;
		case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
			fprintf (stderr, "ERROR: The specified key is not found.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't open Metabase Key. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		pcAdmCom->Release();
		return; 
	}

	// Recurse and dump children
	printf("\nIP address and domain name access restrictions:\n");
	hresError = PrintKeyRecursively(pcAdmCom, pcpCommands.szStartKey, &pcpCommands);

	if (hresError != ERROR_SUCCESS)
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
			fprintf (stderr, "ERROR: Could not open a key because it is already in use.\n"); 
			break;
		case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
			fprintf (stderr, "ERROR: There is not enough memory available.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Failed dumping metabase. Error: %u (%#x)\n", hresError, hresError);
			break;
		}
	}

	pcAdmCom->CloseKey (hmdHandle);
	pcAdmCom->Release();

	if (hresError == ERROR_SUCCESS)
		fputs("Successfully printed IP Security information.\n", stderr);
}

DWORD ParseCommands (int argc, char *argv [], CMD_PARAMS *pcpCommandStructure)
{
	if (pcpCommandStructure == NULL) 
		return E_NULL_PTR;

	if ( argc > 3 )
		return E_WRONG_NUMBER_ARGS;

	// Set default values:
	pcpCommandStructure->szMachineName = (LPWSTR) HeapAlloc (GetProcessHeap(), 
											HEAP_ZERO_MEMORY, (9 + 1) * sizeof (WCHAR) );

	if (pcpCommandStructure->szMachineName == NULL)
		return E_OUTOFMEMORY;

	wcscpy(pcpCommandStructure->szMachineName,L"localhost");
	pcpCommandStructure->bShowSecure = FALSE;


	// Handle StartKey:
	DWORD dwStartKeyLen = _mbstrlen(argv[1]) + 3;
	pcpCommandStructure->szStartKey = (LPWSTR) HeapAlloc (GetProcessHeap(), 
									HEAP_ZERO_MEMORY, (dwStartKeyLen + 1) * sizeof (WCHAR));
	LPWSTR lpwstrTemp = (LPWSTR) HeapAlloc (GetProcessHeap(), 
									HEAP_ZERO_MEMORY, (dwStartKeyLen + 1) * sizeof (WCHAR));

//	_mbscpy(lpwstrTemp,"/LM");
//	wcscat(lpwstrTemp, argv[1]);
//	printf("%S\n",lpwstrTemp);
	//	wcscpy(pcpCommands.szStartKey, lpwstrTemp);

	if (pcpCommandStructure->szStartKey == NULL)
		return E_OUTOFMEMORY;

	DWORD dwResult = MultiByteToWideChar(
		CP_ACP,
		0,
		argv[1],
		dwStartKeyLen + 1,
		pcpCommandStructure->szStartKey,
		dwStartKeyLen + 1);

	if (dwResult == 0)
	{
		pcpCommandStructure->dwErrParameter = START_KEY_NAME;
		return E_INVALIDARG;
	}
	// Add /lm to StartKey:
	wcscpy(lpwstrTemp,L"/LM");
	wcscat(lpwstrTemp, pcpCommandStructure->szStartKey);
	wcscpy(pcpCommandStructure->szStartKey, lpwstrTemp);

	// Chop off trailing slashes:
	LPWSTR lpwchTemp = pcpCommandStructure->szStartKey;	
	for (DWORD i=0; i < dwStartKeyLen-1; i++)
		lpwchTemp++;

	if (!wcscmp(lpwchTemp, TEXT("/") ) || !wcscmp(lpwchTemp, TEXT("\\")) )
			*(lpwchTemp) = (WCHAR)'\0';

	// Look for MachineName:

	if ( argc > 2 && strcmp("-s",argv[2]))
	{
		DWORD dwMachineNameLen = _mbstrlen(argv[2]);
		pcpCommandStructure->szMachineName = (LPWSTR) HeapAlloc (GetProcessHeap(), 
									HEAP_ZERO_MEMORY, (dwMachineNameLen + 1) * sizeof (WCHAR) );

		if (pcpCommandStructure->szMachineName == NULL)
			return E_OUTOFMEMORY;

		dwResult = MultiByteToWideChar(
			CP_ACP,
			0,
			argv[2],
			dwMachineNameLen + 1,
			pcpCommandStructure->szMachineName,
			dwMachineNameLen + 1);

		if (dwResult == 0)
		{
			pcpCommandStructure->dwErrParameter = MACHINE_NAME;
			return E_INVALIDARG;
		}

		// Check for "-s" flag:
		if (argc == 4)
		{
			if ( !strcmp("-s",argv[3]) )
				pcpCommandStructure->bShowSecure = TRUE;
			else
				return E_INVALIDARG;
		}
	}
	else if (argc == 3 && !strcmp("-s",argv[2]))
			pcpCommandStructure->bShowSecure = TRUE;
	else if (argc > 2)
		return E_INVALIDARG;

	return ERROR_SUCCESS;
}


HRESULT PrintKeyRecursively(IMSAdminBase *pcAdmCom, WCHAR *lpwstrFullPath, CMD_PARAMS* pcpCommandStructure)
{
	METADATA_HANDLE hmdHandle;
	HRESULT hresError = pcAdmCom->OpenKey(
								METADATA_MASTER_ROOT_HANDLE,
								lpwstrFullPath,
								METADATA_PERMISSION_READ,
								DEFAULT_MD_TIMEOUT,
								&hmdHandle);

	if (hresError != ERROR_SUCCESS)
		return hresError;
   // Get all data into a buffer:

	DWORD dwNumDataEntries ;
	DWORD dwDataSetNumber;
	DWORD dwRequestBufferSize = DEFAULT_GETALL_BUFFER_SIZE;
	DWORD dwRequiredDataLen;

	  // Allocate a default buffer size
	pbGetAllBuffer = (PBYTE)HeapAlloc 
						(GetProcessHeap(),
						HEAP_ZERO_MEMORY,
						DEFAULT_GETALL_BUFFER_SIZE);

	if (pbGetAllBuffer == NULL)
		return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);

	hresError = pcAdmCom -> GetAllData (
				hmdHandle,
				TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				dwRequestBufferSize,
				pbGetAllBuffer,
				&dwRequiredDataLen);


	if (hresError == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
	{
		// retry the GetAllData with the new buffer size

		dwRequestBufferSize = dwRequiredDataLen;
		pbGetAllBuffer = (PBYTE)HeapReAlloc 
									(GetProcessHeap(),
									0,
									pbGetAllBuffer,
									dwRequestBufferSize);

		if (!pbGetAllBuffer)
			return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);

		hresError = pcAdmCom -> GetAllData (
				hmdHandle,
				TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				dwRequestBufferSize,
				pbGetAllBuffer,
				&dwRequiredDataLen);
	}

	if (hresError != ERROR_SUCCESS)
	{
		HeapFree (GetProcessHeap(), 0, pbGetAllBuffer);
		return hresError;
	}

	METADATA_GETALL_RECORD *pmdgr = NULL;
	
	for (DWORD dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{
		pmdgr = &(((METADATA_GETALL_RECORD *) pbGetAllBuffer)[dwIndex]);
		pmdgr->pbMDData = pmdgr->dwMDDataOffset + pbGetAllBuffer;

		if (pmdgr->dwMDIdentifier == 6019 && pmdgr->dwMDDataType == BINARY_METADATA &&
			pmdgr->dwMDDataLen > 0)
		{
			printf("  [%S]\n",lpwstrFullPath);
		//	PrintProperty(*pmdgr, pcpCommandStructure->bShowSecure);
			
			BuildIplOblistFromBlob( *pmdgr);

		}
	}



	WCHAR *lpwstrTempPath = (WCHAR*) HeapAlloc 
									(GetProcessHeap(),
									HEAP_ZERO_MEMORY,
									METADATA_MAX_NAME_LEN * sizeof (WCHAR));

	if (lpwstrTempPath == NULL)
		return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

	// Find out number of the children:
	DWORD dwChildCount = 0;
	while (1)
	{
		hresError = pcAdmCom->EnumKeys (
								hmdHandle,
								TEXT("/"),
								lpwstrTempPath,
								dwChildCount);

		if (hresError != ERROR_SUCCESS)
			break;
		dwChildCount++;
	}

	if (dwChildCount == 0)
		return ERROR_SUCCESS;

	// Dynamically allocate arrays:
	LPWSTR * lpwstrChildPath = new LPWSTR[dwChildCount];
	DWORD * dwSortedIndex = new DWORD[dwChildCount];

	// Initialization:
	for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
	{
		dwSortedIndex[dwIndex] = dwIndex;

		hresError = pcAdmCom->EnumKeys (
								hmdHandle,
								TEXT("/"),
								lpwstrTempPath,
								dwIndex);

		lpwstrChildPath[dwIndex] = (WCHAR*) HeapAlloc
									(GetProcessHeap(),
									HEAP_ZERO_MEMORY,
									(wcslen (lpwstrTempPath) + 1) * sizeof (WCHAR));

		if (lpwstrChildPath[dwIndex] == NULL)
		{
			hresError = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
		else
			wcscpy(lpwstrChildPath[dwIndex], lpwstrTempPath);
	}

	if (hresError == ERROR_SUCCESS)
	{
		// Sort children lexicographically (here we assume that dwChildCount is small)
		if (dwChildCount > 1 )
		{
			 DWORD dwTemp;
			 for (DWORD i = 1; i < dwChildCount; i++)
				for (DWORD j=0; j < dwChildCount-i; j++)
				{
					if (wcscmp(lpwstrChildPath[dwSortedIndex[j]],lpwstrChildPath[dwSortedIndex[j+1]]) > 0)
					{
						dwTemp = dwSortedIndex[j+1];
						dwSortedIndex[j+1] = dwSortedIndex[j];
						dwSortedIndex[j] = dwTemp;
					}
				}
		}

		for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
		{
			// create the full path name for the child:
			wsprintf(lpwstrTempPath,TEXT("%s/%s"),lpwstrFullPath,lpwstrChildPath[dwSortedIndex[dwIndex]]);
			HeapFree (GetProcessHeap(), 0, lpwstrChildPath[dwSortedIndex[dwIndex]]);
			hresError = PrintKeyRecursively (pcAdmCom, lpwstrTempPath, pcpCommandStructure);

			if (hresError != ERROR_SUCCESS)
				break;
		}
	}

	// Close keys, free memory and exit
	pcAdmCom->CloseKey(hmdHandle);
	delete lpwstrChildPath;
	delete dwSortedIndex;
	HeapFree (GetProcessHeap(), 0, lpwstrTempPath);

	return hresError;
}






VOID DisplayHelp()
{
	fprintf (stderr, "\n DESCRIPTION: Displays the IP address/domain name restictions.\n\n");
	fprintf (stderr, " FORMAT: ipperm <StartKey> <MachineName>\n\n");
	fprintf (stderr, "    <StartKey>   : metabase key to start at.\n");
	fprintf (stderr, "    <MachineName>: name of host (optional, default: localhost).\n\n");
	fprintf (stderr, " EXAMPLES: ipperm  /w3svc/1  t-tamasn2\n");
	fprintf (stderr, "           ipperm  /  >  dump.txt  (dump all to text)\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\metasnap\convert.cpp ===
//**************************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  convert.cpp
//
//  Description: Conversion tables for metabase properties
//				 corresponding to ADSI names
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//**************************************************************

#include "convert.h"
#include <iiscnfgp.h>  // has MD_* constants


//*************************************************
// METABASE CONSTANT - ADSI PROPERTY NAME TABLE
//*************************************************

tPropertyNameTable  gPropertyNameTable[]=
{
//  These are global to all services and should only be set at the IIS root
    {MD_MAX_BANDWIDTH                ,_T("MaxBandwidth")},
    {MD_KEY_TYPE                     ,_T("KeyType")},
//  These properties are applicable to both HTTP and FTP virtual servers
    {MD_CONNECTION_TIMEOUT           ,_T("ConnectionTimeout")},
    {MD_MAX_CONNECTIONS              ,_T("MaxConnections")},
    {MD_SERVER_COMMENT               ,_T("ServerComment")},
    {MD_SERVER_STATE                 ,_T("ServerState")},
    {MD_SERVER_COMMAND               ,_T("ServerCommand")},
    {MD_SERVER_AUTOSTART             ,_T("ServerAutoStart")},
    {MD_CLUSTER_SERVER_COMMAND       ,_T("ClusterServerCommand")},
    {MD_CLUSTER_ENABLED              ,_T("ClusterEnabled")},
    {MD_SERVER_SIZE                  ,_T("ServerSize")},
    {MD_SERVER_LISTEN_BACKLOG        ,_T("ServerListenBacklog")},
    {MD_SERVER_LISTEN_TIMEOUT        ,_T("ServerListenTimeout")},
    {MD_DOWNLEVEL_ADMIN_INSTANCE     ,_T("DownlevelAdminInstance")},
    {MD_SERVER_BINDINGS              ,_T("ServerBindings")},
    {MD_SERVER_CONFIGURATION_INFO,    _T("ServerConfigurationInfo")},

//internals
    {MD_SERVER_PLATFORM              ,_T("ServerPlatform")},
    {MD_SERVER_VERSION_MAJOR         ,_T("MajorVersion")},
    {MD_SERVER_VERSION_MINOR         ,_T("MinorVersion")},
    {MD_SERVER_CAPABILITIES          ,_T("Capabilities")},

//  These properties are specific to HTTP and belong to the virtual server
    {MD_SECURE_BINDINGS              ,_T("SecureBindings")},
    {MD_NTAUTHENTICATION_PROVIDERS   ,_T("NTAuthenticationProviders")},
    {MD_SCRIPT_TIMEOUT               ,_T("CGITimeout")},
    {MD_CACHE_EXTENSIONS             ,_T("CacheISAPI")},
    {MD_CREATE_PROCESS_AS_USER       ,_T("CreateProcessAsUser")},
    {MD_CREATE_PROC_NEW_CONSOLE      ,_T("CreateCGIWithNewConsole")},
    {MD_POOL_IDC_TIMEOUT             ,_T("PoolIDCTimeout")},
    {MD_ALLOW_KEEPALIVES             ,_T("AllowKeepAlive")},
    {MD_FILTER_LOAD_ORDER            ,_T("FilterLoadOrder")},
    {MD_FILTER_IMAGE_PATH            ,_T("FilterPath")},
    {MD_FILTER_STATE                 ,_T("FilterState")},
    {MD_FILTER_ENABLED               ,_T("FilterEnabled")},
    {MD_FILTER_FLAGS                 ,_T("FilterFlags")},
    {MD_FILTER_DESCRIPTION           ,_T("FilterDescription")},

    { MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, _T("AllowPathInfoForScriptMappings")},
    { MD_AUTH_CHANGE_URL,                     _T("AuthChangeUrl")},
    {MD_AUTH_EXPIRED_URL,                     _T("AuthExpiredUrl")},
    {MD_AUTH_NOTIFY_PWD_EXP_URL,              _T("NotifyPwdExpUrl")},
    {MD_AUTH_EXPIRED_UNSECUREURL,             _T("AuthExpiredUnsecureUrl")},
    {MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL,      _T("NotifyPwdExpUnsecureUrl")},
    {MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,           _T("PasswordExpirePrenotifyDays")},
    {MD_AUTH_CHANGE_FLAGS,                    _T("PasswordChangeFlags")},
    {MD_ADV_CACHE_TTL,                        _T("PasswordCacheTTL")},
    {MD_NET_LOGON_WKS,                        _T("NetLogonWorkstation")},
    {MD_USE_HOST_NAME,                        _T("UseHostName")},
#if defined(CAL_ENABLED)
    #define MD_CAL_VC_PER_CONNECT        (IIS_MD_HTTP_BASE+130)
    #define MD_CAL_AUTH_RESERVE_TIMEOUT  (IIS_MD_HTTP_BASE+131)
    #define MD_CAL_SSL_RESERVE_TIMEOUT   (IIS_MD_HTTP_BASE+132)
    #define MD_CAL_W3_ERROR              (IIS_MD_HTTP_BASE+133)

    {MD_CAL_VC_PER_CONNECT,                   _T("CalVcPerConnect")},
    {MD_CAL_AUTH_RESERVE_TIMEOUT,             _T("CalReserveTimeout")},
    {MD_CAL_SSL_RESERVE_TIMEOUT,              _T("CalSslReserveTimeout")},
    {MD_CAL_W3_ERROR,                         _T("CalLimitHttpError")},
#endif
    { MD_IN_PROCESS_ISAPI_APPS      , _T("InProcessIsapiApps")},
    { MD_CUSTOM_ERROR_DESC          , _T("CustomErrorDescriptions")},

    {MD_MAPCERT                      ,_T("MapCert")},
    {MD_MAPNTACCT                    ,_T("MaPNTAccT")},
    {MD_MAPNAME                      ,_T("MapName")},
    {MD_MAPENABLED                   ,_T("MapEnabled")},
    {MD_MAPREALM                     ,_T("MapRealm")},
    {MD_MAPPWD                       ,_T("MapPwd")},
    {MD_ITACCT                       ,_T("ITACCT")},
    {MD_CPP_CERT11                   ,_T("CppCert11")},
    {MD_SERIAL_CERT11                ,_T("SerialCert11")},
    {MD_CPP_CERTW                    ,_T("CppCertw")},
    {MD_SERIAL_CERTW                 ,_T("SerialCertw")},
    {MD_CPP_DIGEST                   ,_T("CppDigest")},
    {MD_SERIAL_DIGEST                ,_T("SerialDigest")},
    {MD_CPP_ITA                      ,_T("CppIta")},
    {MD_SERIAL_ITA                   ,_T("SerialIta")},

// Compression Filter Properties
    {MD_HC_COMPRESSION_DIRECTORY     ,_T("HcCompressionDirectory")},
    {MD_HC_CACHE_CONTROL_HEADER      ,_T("HcCacheControlHeader")},
    {MD_HC_EXPIRES_HEADER            ,_T("HcExpiresHeader")},
    {MD_HC_DO_DYNAMIC_COMPRESSION    ,_T("HcDoDynamicCompression")},
    {MD_HC_DO_STATIC_COMPRESSION     ,_T("HcDoStaticCompression")},
    {MD_HC_DO_ON_DEMAND_COMPRESSION  ,_T("HcDoOnDemandCompression")},
    {MD_HC_DO_DISK_SPACE_LIMITING    ,_T("HcDoDiskSpaceLimiting")},
    {MD_HC_NO_COMPRESSION_FOR_HTTP_10,_T("HcNoCompressionForHttp10")},
    {MD_HC_NO_COMPRESSION_FOR_PROXIES,_T("HcNoCompressionForProxies")},
    {MD_HC_NO_COMPRESSION_FOR_RANGE  ,_T("HcNoCompressionForRange")},
    {MD_HC_SEND_CACHE_HEADERS        ,_T("HcSendCacheHeaders")},
    {MD_HC_MAX_DISK_SPACE_USAGE      ,_T("HcMaxDiskSpaceUsage")},
    {MD_HC_IO_BUFFER_SIZE            ,_T("HcIoBufferSize")},
    {MD_HC_COMPRESSION_BUFFER_SIZE   ,_T("HcCompressionBufferSize")},
    {MD_HC_MAX_QUEUE_LENGTH          ,_T("HcMaxQueueLength")},
    {MD_HC_FILES_DELETED_PER_DISK_FREE,_T("HcFilesDeletedPerDiskFree")},
    {MD_HC_MIN_FILE_SIZE_FOR_COMP    ,_T("HcMinFileSizeForComp")},
    {MD_HC_COMPRESSION_DLL           ,_T("HcCompressionDll")},
    {MD_HC_FILE_EXTENSIONS           ,_T("HcFileExtensions")},
    {MD_HC_PRIORITY                  ,_T("HcPriority")},
    {MD_HC_DYNAMIC_COMPRESSION_LEVEL ,_T("HcDynamicCompressionLevel")},
    {MD_HC_ON_DEMAND_COMP_LEVEL      ,_T("HcOnDemandCompLevel")},
    {MD_HC_CREATE_FLAGS              ,_T("HcCreateFlags")},
// Job Object Site Properties
    {MD_CPU_LIMITS_ENABLED           ,_T("CpuLimitsEnabled")},
    {MD_CPU_RESET_INTERVAL           ,_T("CpuResetInterval")},
    {MD_CPU_LOGGING_INTERVAL         ,_T("CpuLoggingInterval")},
    {MD_CPU_LOGGING_OPTIONS          ,_T("CpuLoggingOptions")},
    {MD_CPU_LOGGING_MASK             ,_T("CpuLoggingMask")},
    {MD_CPU_CGI_LIMIT                ,_T("CpuCgiLimit")},
    {MD_CPU_LIMIT_LOGEVENT           ,_T("CpuLimitLogEvent")},
    {MD_CPU_LIMIT_PRIORITY           ,_T("CpuLimitPriority")},
    {MD_CPU_LIMIT_PROCSTOP           ,_T("CpuLimitProcStop")},
    {MD_CPU_LIMIT_PAUSE              ,_T("CpuLimitPause")},
// Job Object per file properties
    {MD_CPU_CGI_ENABLED              ,_T("CpuCgiEnabled")},
    {MD_CPU_APP_ENABLED              ,_T("CpuAppEnabled")},


// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
    {MD_VR_PATH                      ,_T("Path")},
    {MD_VR_USERNAME                  ,_T("UNCUserName")},
    {MD_VR_PASSWORD                  ,_T("UNCPassword")},
    {MD_VR_ACL                       ,_T("VrAcl")},
// This is used to flag down updated vr entries - Used for migrating vroots
    {MD_VR_UPDATE                    ,_T("VrUpdate")},

//  Logging related attributes
    {MD_LOG_TYPE                     ,_T("LogType")},
    {MD_LOGFILE_DIRECTORY            ,_T("LogFileDirectory")},
    {MD_LOGFILE_PERIOD               ,_T("LogFilePeriod")},
    {MD_LOGFILE_TRUNCATE_SIZE        ,_T("LogFileTruncateSize")},
    {MD_LOGSQL_DATA_SOURCES          ,_T("LogOdbcDataSource")},
    {MD_LOGSQL_TABLE_NAME            ,_T("LogOdbcTableName")},
    {MD_LOGSQL_USER_NAME             ,_T("LogOdbcUserName")},
    {MD_LOGSQL_PASSWORD              ,_T("LogOdbcPassword")},
//  {MD_LOG_CLSID                    ,_T("LogClsid")},
//  {MD_LOG_STATE                    ,_T("LogState")},
    {MD_LOGEXT_FIELD_MASK            ,_T("ExtLogFieldMask")},
    {MD_LOGEXT_FIELD_MASK2           ,_T("ExtLogFieldMask2")},
    {MD_LOG_PLUGIN_ORDER             ,_T("LogPluginClsid")},

//  These are FTP specific properties
    {MD_EXIT_MESSAGE                 ,_T("ExitMessage")},
    {MD_GREETING_MESSAGE             ,_T("GreetingMessage")},
    {MD_MAX_CLIENTS_MESSAGE          ,_T("MaxClientsMessage")},
    {MD_MSDOS_DIR_OUTPUT             ,_T("MSDOSDirOutput")},
    {MD_ALLOW_ANONYMOUS              ,_T("AllowAnonymous")},
    {MD_ANONYMOUS_ONLY               ,_T("AnonymousOnly")},
    {MD_LOG_ANONYMOUS                ,_T("LogAnonymous")},
    {MD_LOG_NONANONYMOUS             ,_T("LogNonAnonymous")},

//  These are SSL specific properties
    {MD_SSL_PUBLIC_KEY               ,_T("SslPublicKey")},
    {MD_SSL_PRIVATE_KEY              ,_T("SslPrivateKey")},
    {MD_SSL_KEY_PASSWORD             ,_T("SslKeyPassword")},
    {MD_SSL_KEY_REQUEST              ,_T("SslKeyRequest")},
    {MD_SSL_FRIENDLY_NAME            ,_T("SslFriendlyName")},
    {MD_SSL_IDENT                    ,_T("SslIdent")},

// These are server certificate properties
    {MD_SSL_CERT_HASH                ,_T("SslCertHash")},
    {MD_SSL_CERT_CONTAINER           ,_T("SslCertContainer")},
    {MD_SSL_CERT_PROVIDER            ,_T("SslCertProvider")},
    {MD_SSL_CERT_PROVIDER_TYPE       ,_T("SslCertProviderType")},
    {MD_SSL_CERT_OPEN_FLAGS          ,_T("SslCertOpenFlags")},
    {MD_SSL_CERT_STORE_NAME          ,_T("SslCertStoreName")},

// These are Certificate Trust List properties
    {MD_SSL_CTL_IDENTIFIER          ,_T("SslCtlIdentifier")},
    {MD_SSL_CTL_CONTAINER           ,_T("SslCtlContainer")},
    {MD_SSL_CTL_PROVIDER            ,_T("SslCtlProvider")},
    {MD_SSL_CTL_PROVIDER_TYPE       ,_T("SslCtlProviderType")},
    {MD_SSL_CTL_OPEN_FLAGS          ,_T("SslCtlOpenFlags")},
    {MD_SSL_CTL_STORE_NAME          ,_T("SslCtlStoreName")},
    {MD_SSL_CTL_SIGNER_HASH         ,_T("SslCtlSignerHash")},

// Metabase property that defines whether to use DS mapper or not
    {MD_SSL_USE_DS_MAPPER           ,_T("SslUseDSMapper")},

// Metabase property that holds SSL replication information
    {MD_SSL_REPLICATION_INFO        ,_T("SslReplicationInfo")},

// Metabase properties that are used by the CertWiz ActiveX control, that
// is used for the Certificate/CTL UI management tool

    {MD_SSL_CERT_ENROLL_HISTORY     ,_T("SslCertEnrollHistory")},
    {MD_SSL_CERT_ENROLL_TIME        ,_T("SslCertEnrollTime")},
    {MD_SSL_CERT_ENROLL_STATE       ,_T("SslCertEnrollState")},
    {MD_SSL_CERT_ENROLL_STATE_ERROR ,_T("SslCertEnrollStateError")},


// Metabase properties used for Fortezza certificates
    {MD_SSL_CERT_IS_FORTEZZA        ,_T("IsFortezza")},
    {MD_SSL_CERT_FORTEZZA_PIN       ,_T("FortezzaPin")},
    {MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER     ,_T("FortezzaPin")},
    {MD_SSL_CERT_FORTEZZA_PERSONALITY       ,_T("FortezzaPersonality")},
    {MD_SSL_CERT_FORTEZZA_PROG_PIN          ,_T("FortezzaProgPin")},

// Metabase properties that are used by the CertWiz ActiveX control to keep
// track of the user's entry history, and whether DEBUG is enabled.  We keep
// these private properties on a per VS basis.
    {MD_SSL_CERT_WIZ_DEBUG                  ,_T("WizDebug")},
    {MD_SSL_CERT_WIZHIST_SZ_TARGET_CA       ,_T("WizhistTargetCA")},
    {MD_SSL_CERT_WIZHIST_SZ_FILE_NAME_USED_LAST     ,_T("WizhistFileNameUsedLast")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_COMMON_NAME  ,_T("WizhistCN")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_O            ,_T("WizhistO")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_OU           ,_T("WizhistOU")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_C            ,_T("WizhistC")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_L            ,_T("WizhistL")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_S            ,_T("WizhistS")},
    {MD_SSL_CERT_WIZHIST_SZ_USER_NAME       ,_T("WizhistUserName")},
    {MD_SSL_CERT_WIZHIST_SZ_USER_PHONE      ,_T("WizhistUserPhone")},
    {MD_SSL_CERT_WIZHIST_SZ_USER_EMAIL      ,_T("WizhistUserEmail")},

    {MD_SSL_CERT_WIZGUID_ICERTGETCONFIG     ,_T("WizguidICERTGETCONFIG")},
    {MD_SSL_CERT_WIZGUID_ICERTREQUEST       ,_T("WizguidICERTREQUEST")},
    {MD_SSL_CERT_WIZGUID_XENROLL            ,_T("WizguidXENROLL")},

//  File and Directory related properties - these should be added in the
//  metabase with a user type of
    {MD_AUTHORIZATION                ,_T("Authorization")},
    {MD_AUTHORIZATION_PERSISTENCE    ,_T("AuthorizationPersistence")},
    {MD_REALM                        ,_T("Realm")},
    {MD_HTTP_EXPIRES                 ,_T("HttpExpires")},
    {MD_HTTP_PICS                    ,_T("HttpPics")},
    {MD_HTTP_CUSTOM                  ,_T("HttpCustomHeaders")},
    {MD_DIRECTORY_BROWSING           ,_T("DirectoryBrowsing")},
    {MD_DEFAULT_LOAD_FILE            ,_T("DefaultDoc")},
    {MD_CONTENT_NEGOTIATION      ,    _T("ContentNegotiation")},
    {MD_CUSTOM_ERROR                 ,_T("HTTPErrors")},
    {MD_FOOTER_DOCUMENT              ,_T("DefaultDocFooter")},
    {MD_FOOTER_ENABLED               ,_T("EnableDocFooter")},
    {MD_HTTP_REDIRECT                ,_T("HttpRedirect")},
    {MD_DEFAULT_LOGON_DOMAIN         ,_T("DefaultLogonDomain")},
    {MD_LOGON_METHOD                 ,_T("LogonMethod")},
    {MD_SCRIPT_MAPS                  ,_T("ScriptMaps")},
    {MD_SCRIPT_TIMEOUT               ,_T("ScriptTimeout")},
    {MD_MIME_MAP                     ,_T("MimeMap")},
    {MD_ACCESS_PERM                  ,_T("AccessPerm")},
    {MD_SSL_ACCESS_PERM              ,_T("SslAccessPerm")},
    {MD_IP_SEC                       ,_T("IPSecurity")},
    {MD_ANONYMOUS_USER_NAME          ,_T("AnonymousUserName")},
    {MD_ANONYMOUS_PWD                ,_T("AnonymousUserPass")},
    {MD_ANONYMOUS_USE_SUBAUTH        ,_T("AnonymousPasswordSync")},
    {MD_DONT_LOG                     ,_T("DontLog")},
    {MD_ADMIN_ACL                    ,_T("AdminACL")},
    {MD_SSI_EXEC_DISABLED            ,_T("SSIExecDisable")},
    {MD_DO_REVERSE_DNS               ,_T("EnableReverseDns")},
    {MD_WIN32_ERROR                  ,_T("Win32Error")},
    {MD_ALLOW_REPLACE_ON_RENAME      ,_T("AllowReplaceOnRename")},
    {MD_CC_NO_CACHE                  ,_T("CacheControlNoCache")},
    {MD_CC_MAX_AGE                   ,_T("CacheControlMaxAge")},
    {MD_CC_OTHER                     ,_T("CacheControlCustom")},

//ASP and WAM params
    { MD_ASP_BUFFERINGON                  , _T("AspBufferingOn")},
    { MD_ASP_LOGERRORREQUESTS             , _T("AspLogErrorRequests")},
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER    , _T("AspScriptErrorSentToBrowser")},
    { MD_ASP_SCRIPTERRORMESSAGE           , _T("AspScriptErrorMessage")},
    { MD_ASP_SCRIPTFILECACHESIZE          , _T("AspScriptFileCacheSize")},
    { MD_ASP_SCRIPTENGINECACHEMAX         , _T("AspScriptEngineCacheMax")},
    { MD_ASP_SCRIPTTIMEOUT                , _T("AspScriptTimeout")},
    { MD_ASP_SESSIONTIMEOUT               , _T("AspSessionTimeout")},
    { MD_ASP_ENABLEPARENTPATHS            , _T("AspEnableParentPaths")},
    { MD_ASP_MEMFREEFACTOR                , _T("AspMemFreeFactor")},
    { MD_ASP_MINUSEDBLOCKS                , _T("AspMinUseDblocks")},
    { MD_ASP_ALLOWSESSIONSTATE            , _T("AspAllowSessionState")},
    { MD_ASP_SCRIPTLANGUAGE               , _T("AspScriptLanguage")},
    { MD_ASP_QUEUETIMEOUT                 , _T("AspQueueTimeout")},
    //{ MD_ASP_STARTCONNECTIONPOOL          , _T("AspStartConnectionPool")},
    { MD_ASP_ALLOWOUTOFPROCCMPNTS         , _T("AspAllowOutOfProcComponents")},
    { MD_ASP_EXCEPTIONCATCHENABLE         , _T("AspExceptionCatchEnable")},
    { MD_ASP_CODEPAGE                     , _T("AspCodepage")},
    { MD_ASP_SCRIPTLANGUAGELIST           , _T("AspScriptLanguages")},
    { MD_ASP_ENABLESERVERDEBUG            , _T("AppAllowDebugging")},
    { MD_ASP_ENABLECLIENTDEBUG            , _T("AspEnableClientDebug")},
    { MD_ASP_TRACKTHREADINGMODEL          , _T("AspTrackThreadingModel")},

    // new 5.0 ASP params
    { MD_ASP_ENABLEASPHTMLFALLBACK        , _T("AspEnableAspHTMLFallback")},
    { MD_ASP_ENABLECHUNKEDENCODING        , _T("AspEnableChunkedEncoding")},
    { MD_ASP_ENABLETYPELIBCACHE           , _T("AspEnableTypeLibCache")},
    { MD_ASP_ERRORSTONTLOG                , _T("AspErrorsToNTLog")},
    { MD_ASP_PROCESSORTHREADMAX           , _T("AspProcessorThreadMax")},
    { MD_ASP_REQEUSTQUEUEMAX              , _T("AspRequestQueueMax")},
    { MD_ASP_ENABLEAPPLICATIONRESTART     , _T("AspEnableApplicationRestart")},
    { MD_ASP_QUEUECONNECTIONTESTTIME      , _T("AspQueueConnectionTestTime")},
    { MD_ASP_SESSIONMAX                   , _T("AspSessionMax")},

    // Thread gate params
    { MD_ASP_THREADGATEENABLED            , _T("AspThreadGateEnabled")},
    { MD_ASP_THREADGATETIMESLICE          , _T("AspThreadGateTimeSlice")},
    { MD_ASP_THREADGATESLEEPDELAY         , _T("AspThreadGateSleepDelay")},
    { MD_ASP_THREADGATESLEEPMAX           , _T("AspThreadGateSleepMax")},
    { MD_ASP_THREADGATELOADLOW            , _T("AspThreadGateLoadLow")},
    { MD_ASP_THREADGATELOADHIGH           , _T("AspThreadGateLoadHigh")},

// WAM params
    //{ MD_APP_COMMAND                  , _T("AppCommand")},
    //{ MD_APP_STATUS                   , _T("AppStatus")},
    //{ MD_APP_ERRORCODE                , _T("AppErrorCode")},
    { MD_APP_ROOT                     , _T("AppRoot")},
    { MD_APP_ISOLATED                 , _T("AppIsolated")},
    { MD_APP_WAM_CLSID                , _T("AppWamClsid")},
    { MD_APP_PACKAGE_ID               , _T("AppPackageId")},
    { MD_APP_PACKAGE_NAME             , _T("ApPackageName")},
    { MD_APP_LAST_OUTPROC_PID         , _T("AppLastOutprocId")},
    //{ MD_APP_WAM_RUNTIME_FLAG         , _T("AppWamRuntimmeFlag")},
    //{ MD_APP_OOP_CRASH_LIMIT          , _T("AppOopCrashLimit")},

    {0,0}
};

CString tPropertyNameTable::MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(dwCode == PropertyNameTable[i].dwCode)
            return PropertyNameTable[i].lpszName;
    }
    return _T("");
}


//************************************************
// PROPERTY PREDEFINED VALUES TABLE
//************************************************

struct tValueTable gValueTable[]=
{
//  Valid values for MD_AUTHORIZATION
    {MD_AUTH_ANONYMOUS               ,_T("Anonymous"),  MD_AUTHORIZATION},
    {MD_AUTH_BASIC                   ,_T("Basic"),      MD_AUTHORIZATION},
    {MD_AUTH_NT                      ,_T("NT"),     MD_AUTHORIZATION},
    {MD_AUTH_MD5                     ,_T("MD5"),        MD_AUTHORIZATION},
    {MD_AUTH_MAPBASIC                ,_T("MapBasic"),   MD_AUTHORIZATION},
//  Valid values for MD_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_ACCESS_PERM},
//  Valid values for MD_SSL_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_SSL_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_SSL_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_SSL_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_SSL_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_SSL_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_SSL_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_SSL_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_SSL_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_SSL_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_SSL_ACCESS_PERM},
//  Valid values for MD_DIRECTORY_BROWSING
    {MD_DIRBROW_SHOW_DATE            ,_T("Date"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_TIME            ,_T("Time"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_SIZE            ,_T("Size"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_EXTENSION       ,_T("Extension"), MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_LONG_DATE            ,_T("LongDate"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_ENABLED              ,_T("Enabled"),   MD_DIRECTORY_BROWSING},// Allow directory browsing
    {MD_DIRBROW_LOADDEFAULT          ,_T("LoadDefault"),MD_DIRECTORY_BROWSING},// Load default doc if exists
    {MD_DIRBROW_MASK                 ,_T("MaskAll"),        MD_DIRECTORY_BROWSING},
//  Valid values for MD_LOGON_METHOD
    {MD_LOGON_INTERACTIVE    ,_T("Interactive"),    MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_BATCH          ,_T("Batch"),      MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_NETWORK        ,_T("Network"),        MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_FILTER_STATE
    {MD_FILTER_STATE_LOADED          ,_T("Loaded"), MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_FILTER_STATE_UNLOADED        ,_T("Unloaded"),   MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE },
//  Valid values for MD_FILTER_FLAGS
    {/*SF_NOTIFY_SECURE_PORT*/0x00000001         ,_T("SecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_NONSECURE_PORT*/0x00000002      ,_T("NonSecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_READ_RAW_DATA*/0x000008000      ,_T("ReadRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_PREPROC_HEADERS*/0x00004000     ,_T("PreprocHeaders"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATION*/0x00002000      ,_T("Authentication"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_URL_MAP*/0x00001000             ,_T("UrlMap"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ACCESS_DENIED*/0x00000800       ,_T("AccessDenied"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RESPONSE*/0x00000040       ,_T("SendResponse"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RAW_DATA*/0x00000400       ,_T("SendRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_LOG*/0x00000200                 ,_T("NotifyLog"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_REQUEST*/0x00000080      ,_T("EndOfRequest"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_NET_SESSION*/0x00000100  ,_T("EndOfNetSession"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATIONEX*/  0x20000000  ,_T("AuthenticationX"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE*/0x10000000,_T("RequestSecurityContextClose"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_RENEGOTIATE_CERT*/0x08000000,   _T("RenegotiateCert"), MD_FILTER_FLAGS},

    {/*SF_NOTIFY_ORDER_HIGH*/0x00080000   ,_T("OrderHigh"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_MEDIUM*/0x00040000   ,_T("OrderMedium"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_LOW*/0x00020000   ,_T("OrderLow"), MD_FILTER_FLAGS},

//  Valid values for MD_SERVER_STATE
    {MD_SERVER_STATE_STARTING        ,_T("Starting"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STARTED         ,_T("Started"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPING        ,_T("Stopping"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPED         ,_T("Stopped"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSING         ,_T("Pausing"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSED          ,_T("Paused"),     MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_CONTINUING      ,_T("Continuing"), MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_COMMAND
    {MD_SERVER_COMMAND_START         ,_T("Start"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_STOP          ,_T("Stop"),       MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_PAUSE         ,_T("Pause"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_CONTINUE      ,_T("Continue"),   MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_SIZE
    {MD_SERVER_SIZE_SMALL            ,_T("Small"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_MEDIUM           ,_T("Medium"), MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_LARGE            ,_T("Large"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},

    //{APPCMD_NONE, _T("None"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_VERIFY, _T("Verify"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_GETSTATUS, _T("GetStatus"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATE, _T("Create"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEINPROC, _T("CreateInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEOUTPROC, _T("CreateOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOINPROC, _T("ChangeToInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOOUTPROC, _T("ChangeToOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_DELETE, _T("Delete"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_UNLOAD, _T("Unload"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},

    //{APPSTATUS_Error, _T("Error"),            MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Created, _T("Created"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Deleted, _T("Deleted"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_UnLoaded, _T("Unloaded"),      MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Killed, _T("Killed"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Running, _T("Running"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Stopped, _T("Stopped"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_NoApplication, _T("NoApplication"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_AppSubNode, _T("AppSubNode"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},

// NEED LOGGING Updates
#if 0
    {MD_LOGTYPE_NONE     ,_T("LOGTYPE_NONE")},
    {MD_LOGTYPE_FILE     ,_T("LOGTYPE_FILE")},
    {MD_LOGTYPE_ODBC     ,_T("LOGTYPE_ODBC")},
    {MD_LOGFILE_PERIOD_MAXSIZE   ,_T("LOGFILE_PERIOD_MAXSIZE")},
    {MD_LOGFILE_PERIOD_DAILY     ,_T("LOGFILE_PERIOD_DAILY")},
    {MD_LOGFILE_PERIOD_WEEKLY    ,_T("LOGFILE_PERIOD_WEEKLY")},
    {MD_LOGFILE_PERIOD_MONTHLY   ,_T("LOGFILE_PERIOD_MONTHLY")},
#endif
    {0,0}
};

CString  tValueTable::MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    CString strResult=_T("");
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if(ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
        {
            if(ValueTable[i].dwFlags==tValueTable::TYPE_EXCLUSIVE)
            {
                if (ValueTable[i].dwCode == dwValueContent)
                    return ValueTable[i].lpszName;
            }
            else if ((ValueTable[i].dwCode & dwValueContent) == ValueTable[i].dwCode)
            {
                strResult = strResult + ValueTable[i].lpszName + _T(" ");
            }

        }
    }
    strResult.TrimRight();
    return strResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\ipperm\uiutils.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rdns.hxx

Abstract:

    Reverse DNS service

Author:

    Philippe Choquier (phillich)    5-june-1996

--*/

#if !defined(_RDNS_INCLUDE)
#define _RDNS_INCLUDE

#include "windef.h"

//# include "string.hxx"

typedef LPVOID DNSARG;

typedef void (*DNSFUNC)( DNSARG, BOOL, LPSTR );

#define RDNS_REQUEST_TYPE_IP2DNS    0
#define RDNS_REQUEST_TYPE_DNS2IP    1

#define SIZEOF_IP_ADDRESS           4
/*
typedef struct _DNSFUNCDESC
{
    DWORD   dwRequestType;
    DNSFUNC pFunc;
} DNSFUNCDESC, *PDNSFUNCDESC;

extern BOOL InitRDns();
extern void TerminateRDns();

 
BOOL 
AsyncHostByAddr(
    PDNSFUNCDESC pFunc,    // will store DNS name, post dummy completion status
                    // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,      // ptr to be passed to FUNC
    struct sockaddr *pHostAddr, 

    BOOL *pfSync,   // updated with TRUE if sync call
    LPSTR pName,
    DWORD dwMaxNameLen
    );

 
BOOL
AsyncAddrByHost(
    PDNSFUNCDESC pFunc,    // will store DNS name, post dummy completion status
                    // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,      // ptr to be passed to FUNC
    struct sockaddr *pHostAddr,

    BOOL *pfSync,   // updated with TRUE if sync call
    LPSTR pName
    );


BOOL
FireUpNewThread(
    PDNSFUNCDESC pFunc,
    DNSARG pArg,
    LPVOID pOvr
    );

#define XAR_GRAIN   256

//
// extensible array class
//
*/
class XAR {
public:
    XAR() { m_fDidAlloc = FALSE; m_pAlloc = NULL; m_cAlloc = m_cUsed = 0; }
    ~XAR() { }
    //~XAR() { if ( m_fDidAlloc ) LocalFree( m_pAlloc ); }

    BOOL Init( LPBYTE p=NULL, DWORD c=0) { m_fDidAlloc = FALSE; m_pAlloc = p; m_cAlloc = m_cUsed = c; return TRUE; }
    VOID Terminate() 
        { 
          /*  if ( m_fDidAlloc ) 
            {
                LocalFree( m_pAlloc ); 
            }*/
            m_fDidAlloc = FALSE; 
            m_pAlloc = NULL; 
            m_cAlloc = m_cUsed = 0; 
        }
    BOOL Resize( DWORD dwDelta );
    DWORD GetUsed() { return m_cUsed; }
    VOID SetUsed( DWORD c ) { m_cUsed = c; }
    VOID AdjustUsed( int c ) { m_cUsed += (DWORD)c; }
    LPBYTE GetAlloc() { return m_pAlloc; }

private:
    LPBYTE m_pAlloc;
    DWORD  m_cAlloc;
    DWORD  m_cUsed;
    BOOL   m_fDidAlloc;
} ;
/*
//
// This type defines a relocatable index inside a dynamic array.
// to allow easy fixups when part of the array is to be extended/shrinked
// index are identified by setting bit 31 to 1. Other DWORD in the reference
// part of the array are assumed to have bit 31 set to 0.
// The size of the reference part of the array is defined by cRefSize
//
*/
typedef DWORD SELFREFINDEX;

// combine array base address with SELFREFINDEX
#define MAKEPTR(a,b)    ((LPBYTE)(a)+((b)&0x7fffffff))
// build a SELFREFINDEX from an offset in array
#define MAKEREF(a)      ((a)|0x80000000)
// build an offset from a SELFREFINDEX
#define MAKEOFFSET(a)   ((a)&0x7fffffff)

//
// ADDRESS_CHECK_LIST Flags. bit31 must not be used.
//

#define RDNS_FLAG_DODNS2IPCHECK     0x00000001

// uses non-standard extension : zero-sized array in struct
#pragma warning(disable:4200)

// array header

typedef struct _ADDRESS_CHECK_LIST {
    SELFREFINDEX    iDenyAddr;      // address deny list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iGrantAddr;     // address grant list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iDenyName;      // DNS name deny list
                                    // points to NAME_HEADER
    SELFREFINDEX    iGrantName;     // DNS name grant list
                                    // points to NAME_HEADER
    DWORD           dwFlags;
    DWORD           cRefSize;       // size of reference area ( in bytes )
} ADDRESS_CHECK_LIST, *PADDRESS_CHECK_LIST;

typedef struct _ADDRESS_LIST_ENTRY {
    DWORD           iFamily;
    DWORD           cAddresses;
    DWORD           cFullBytes;
    DWORD           LastByte;
    SELFREFINDEX    iFirstAddress;  // points to array of addresses
                                    // which size are derived from iFamily
} ADDRESS_LIST_ENTRY, *PADDRESS_LIST_ENTRY;

typedef struct _ADDRESS_HEADER {
    DWORD               cEntries;   // # of Entries[]
    DWORD               cAddresses; // total # of addresses in all 
                                    // ADDRESS_LIST_ENTRY
    ADDRESS_LIST_ENTRY  Entries[];
} ADDRESS_HEADER, *PADDRESS_HEADER ;

typedef struct _NAME_LIST_ENTRY {
    DWORD           cComponents;    // # of DNS components
    DWORD           cNames;         
    SELFREFINDEX    iName[];        // array of references to DNS names
} NAME_LIST_ENTRY, *PNAME_LIST_ENTRY;

typedef struct _NAME_HEADER {
    DWORD           cEntries;
    DWORD           cNames;         // total # of names for all Entries[]
    //NAME_LIST_ENTRY Entries[0];   // array of name classes
} NAME_HEADER, *PNAME_HEADER ;
/*
typedef struct ADDRCMPDESC {
    LPBYTE  pMask;
    UINT    cFullBytes;
    UINT    LastByte;
    UINT    cSizeAddress;
} ADDRCMPDESC, *PADDRCMPDESC;

typedef struct NAMECMPDESC {
    LPVOID  pName;
    LPBYTE  pBase;
} NAMECMPDESC, *PNAMECMPDESC;


typedef LPVOID ADDRCHECKARG;
typedef void (*ADDRCHECKFUNC)(ADDRCHECKARG, BOOL );
typedef void (*ADDRCHECKFUNCEX)(ADDRCHECKARG, BOOL, LPSTR );

typedef int (__cdecl *CMPFUNC)(const void*, const void*, LPVOID);

#define SIZE_FAST_REVERSE_DNS   128
*/
enum AC_RESULT {
    AC_NOT_CHECKED,
    AC_IN_DENY_LIST,
    AC_NOT_IN_DENY_LIST,    // deny list present but not in deny list
    AC_IN_GRANT_LIST,
    AC_NOT_IN_GRANT_LIST,   // grant list present but not in grant list
    AC_NO_LIST
} ;

#define DNSLIST_FLAG_NOSUBDOMAIN        0x80000000
#define DNSLIST_FLAGS                   0x80000000  // bitmask of all flags

class ADDRESS_CHECK {
public:
      ADDRESS_CHECK() {}
      ~ADDRESS_CHECK() {}
    //
      BOOL BindCheckList( LPBYTE p = NULL, DWORD c = 0 );
      VOID UnbindCheckList() { m_Storage.Terminate(); }
 /*     BOOL BindAddr( struct sockaddr* pAddr )
    {
        m_pAddr = pAddr;
        m_fDnsResolved = FALSE;
	m_fIpResolved = FALSE;
	m_dwErrorResolving = 0;
        m_strDnsName.Reset();
        
        return TRUE;
    }

      VOID UnbindAddr()
    {
        m_pAddr = NULL;
        m_strDnsName.Reset();
        m_fDnsResolved = FALSE;
    }

      XAR* GetStorage() { return &m_Storage; }
      AC_RESULT CheckAccess(
        LPBOOL           pfSync,
        ADDRCHECKFUNC    pFunc,
        ADDRCHECKARG     pArg
        );

    //
    void AdjustRefs( LPBYTE, DWORD dwCut, DWORD dwAdj );

*/    //
    UINT GetAddrSize( DWORD );
  //  VOID MakeAcd( PADDRCMPDESC pacd, LPBYTE pMask, UINT cLen );

    // for UI, addr
  //    BOOL AddAddr( BOOL fGrant, DWORD dwFamily, LPBYTE pMask, LPBYTE pAddr );
    //  BOOL DeleteAddr( BOOL fGrant, DWORD iIndex );
      BOOL GetAddr( BOOL fGrant, DWORD iIndex, LPDWORD pdwFamily, LPBYTE* pMask, LPBYTE* pAddr );
      DWORD GetNbAddr( BOOL fGrant );
    BOOL LocateAddr( BOOL fGrant, DWORD iIndex, PADDRESS_HEADER* ppHd, PADDRESS_LIST_ENTRY* pHeader, LPDWORD iIndexInHeader );
     // BOOL DeleteAllAddr( BOOL fGrant );
    //  BOOL SetFlag( DWORD dwFlag, BOOL fEnable );
    //  DWORD GetFlags();

    // test all mask for this family, do bsearch on each
   // BOOL IsMatchAddr( BOOL fGrant, DWORD dwFamily, LPBYTE pAddr );

 /*   AC_RESULT CheckAddress(
        struct sockaddr* pAddr
        );

      BOOL QueryDnsName( 
        LPBOOL           pfSync,
        ADDRCHECKFUNCEX  pFunc,
        ADDRCHECKARG     pArg,
        LPSTR *          ppName
        );
      AC_RESULT CheckIpAccess( LPBOOL pfNeedDns);
      AC_RESULT CheckDnsAccess()
        { return CheckName( m_strDnsName.QueryStr() ); }

      BOOL IsDnsResolved()
        { return m_fDnsResolved; }
      LPSTR QueryResolvedDnsName()
        { return m_strDnsName.QueryStr(); }
      DWORD QueryErrorResolving()
        { return m_dwErrorResolving; }
*/
    // for UI, name
  //    BOOL AddName( BOOL fGrant, LPSTR pName, DWORD dwFlags = 0 );
   // BOOL AddReversedName( BOOL fGrant, LPSTR pName );
     // BOOL DeleteName( BOOL fGrant, DWORD iIndex );
      BOOL GetName( BOOL fGrant, DWORD iIndex,  LPSTR* ppName, LPDWORD pdwFlags = NULL );
   // BOOL GetReversedName( BOOL fGrant, DWORD iIndex, LPSTR pName, LPDWORD pdwSize );
      DWORD GetNbName( BOOL fGrant );
    BOOL LocateName( BOOL fGrant, DWORD iIndex, PNAME_HEADER* ppHd, PNAME_LIST_ENTRY* pHeader, LPDWORD iIndexInHeader );
    //  BOOL DeleteAllName( BOOL fGrant );
     // DWORD QueryCheckListSize() { return m_Storage.GetUsed(); }
     // LPBYTE QueryCheckListPtr() { return m_Storage.GetAlloc(); }
    //UINT GetNbComponent( LPSTR pName );

    // test all classes, do bsearch on each
 /*   BOOL IsMatchName( BOOL fGrant, LPSTR pName );

    BOOL CheckReversedName( LPSTR pName );  // synchronous version
      AC_RESULT CheckName( LPSTR pName );     // synchronous version
    LPSTR InitReverse( LPSTR pR, LPSTR pTarget, LPBOOL pfAlloc );
    VOID TerminateReverse( LPSTR, BOOL );

    VOID AddrCheckDnsCallBack(
        BOOL    fSt,
        LPSTR   pDns
        );
    VOID AddrCheckDnsCallBack2(
        BOOL                fSt,
        struct sockaddr*    pAddr
        );
    VOID AddrCheckDnsCallBack3(
        BOOL                fSt,
        struct sockaddr*    pAddr
        );
    VOID ResolveDnsCallBack(
        BOOL    fSt,
        LPSTR   pDns
        );

#if DBG
    VOID DumpAddrAndName( VOID );
    VOID DumpAddr( BOOL );
    VOID DumpName( BOOL );
#endif
*/
private:
    XAR                 m_Storage;
   // struct  sockaddr *  m_pAddr;
   // struct  sockaddr    m_ResolvedAddr;
   // STR                 m_strDnsName;
    BOOL                m_fDnsResolved;
    BOOL                m_fIpResolved;
    DWORD               m_dwErrorResolving;
//    ADDRCHECKFUNC       m_HttpReqCallback;
  //  ADDRCHECKFUNCEX     m_HttpReqCallbackEx;
    //ADDRCHECKARG        m_HttpReqParam;
} ;

/*
typedef struct _SID_CACHE_ENTRY
{
    DWORD   tExpire;   // now + TTL
    DWORD   dwSidLen;
    BYTE    Sid[0];
} SID_CACHE_ENTRY, *PSID_CACHE_ENTRY;


class CSidCache
{
public:
    CSidCache() {}
    ~CSidCache() {}
    //
    BOOL Init();
    VOID Terminate();
    //
      BOOL AddToCache( PSID, DWORD dwTTL );   // TTL in seconds
      BOOL IsInCache( PSID );
      BOOL CheckPresentAndResetTtl( PSID, DWORD );
    //
    BOOL Scavenger();

private:
    XAR  xaStore;   // buffer of SID_CACHE_ENTRY
    CRITICAL_SECTION    csLock;
} ;

//
// PEN : Password Expiration Notification API
//

extern CSidCache g_scPen;

  BOOL PenAddToCache( PSID, DWORD  );
  BOOL PenIsInCache( PSID );
  BOOL PenCheckPresentAndResetTtl( PSID, DWORD );
#define PenInit g_scPen.Init
#define PenTerminate g_scPen.Terminate
#define PenScavenger g_scPen.Scavenger
#define PEN_TTL (10*60)     // in seconds

#if DBG
extern VOID TestAPI();
#endif

#if defined(_RDNS_STANDALONE)

typedef
VOID
(* PFN_SCHED_CALLBACK)(
    VOID * pContext
    );

 
DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTimeInterval,
    BOOL               fPeriodic = FALSE
    )
{
    return 0;
}

 
BOOL
RemoveWorkItem(
    DWORD  pdwCookie
    )
{
    return FALSE;
}

#endif
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\metasnap\convert.h ===
//**************************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  convert.h
//  
//  Description: Conversion tables for metabase properties  
//				 corresponding to ADSI names
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//**************************************************************

#if !defined (__CONVERT_H)
#define __CONVERT_H 


#include <afx.h>
#include <tchar.h>
//*************************************************
// METABASE CONSTANT - ADSI PROPERTY NAME TABLE 
//*************************************************

struct tPropertyNameTable;
tPropertyNameTable gPropertyNameTable[];

struct tPropertyNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;

	static CString MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
};


//************************************************
// PROPERTY PREDEFINED VALUES TABLE
//************************************************

struct tValueTable;
tValueTable gValueTable[];

struct tValueTable 
{
	enum {TYPE_EXCLUSIVE=1};
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwRelatedPropertyCode; // code of the Property this value can be used for
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static CString MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\thttp\thttp.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    thttp.c

Abstract:

    Simple test program for the HTTP API.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

#include <windows.h>
#include <wininet.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>

//
// macros
//

#define IS_ARG(c)   ((c) == '-')

//
//  Private constants.
//

#define DEFAULT_CONTEXT 1
#define OPEN_CONTEXT    2
#define CONNECT_CONTEXT 3
#define REQUEST_CONTEXT 4

#define LOAD_ENTRY( hMod, Name )  \
   (p##Name = (pfn##Name) GetProcAddress( (hMod), #Name ))

//
//  Private types.
//

typedef struct _QUERY_LEVEL
{
    DWORD   QueryType;
    CHAR  * QueryName;

} QUERY_LEVEL;

#define MK_QUERY(x) { HTTP_QUERY_ ## x, #x }

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetOpenA)(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef
INTERNETAPI
INTERNET_STATUS_CALLBACK
(WINAPI *
pfnInternetSetStatusCallback)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetConnectA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnHttpOpenRequestA)(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpAddRequestHeadersA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpSendRequestA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpQueryInfoA)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCloseHandle)(
    IN HINTERNET hInternet
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetReadFile)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

//
//  Private globals.
//

CHAR MoreHeaders[] = "Pragma: This is garbage!\r\n";

HMODULE hWininet;

LPTSTR AcceptTypes[] =
    {
        "*/*",
         NULL
    };

QUERY_LEVEL QueryLevels[] =
    {
        MK_QUERY( STATUS_CODE ),
        MK_QUERY( STATUS_TEXT ),
        MK_QUERY( VERSION ),
        MK_QUERY( MIME_VERSION ),

        MK_QUERY( CONTENT_TYPE ),
        MK_QUERY( CONTENT_TRANSFER_ENCODING ),
        MK_QUERY( CONTENT_ID     ),
        MK_QUERY( CONTENT_DESCRIPTION ),
        MK_QUERY( CONTENT_LENGTH ),
        MK_QUERY( CONTENT_LANGUAGE ),
        MK_QUERY( ALLOW ),
        MK_QUERY( PUBLIC ),
        MK_QUERY( DATE ),
        MK_QUERY( EXPIRES ),
        MK_QUERY( LAST_MODIFIED ),
        MK_QUERY( MESSAGE_ID ),
        MK_QUERY( URI ),
        MK_QUERY( DERIVED_FROM ),
        MK_QUERY( COST ),
        MK_QUERY( LINK ),
        MK_QUERY( PRAGMA ),
        MK_QUERY( CONNECTION ),
        MK_QUERY( RAW_HEADERS_CRLF )
    };
#define NUM_LEVELS (sizeof(QueryLevels) / sizeof(QueryLevels[0]))

BOOL Verbose = FALSE;
BOOL Quiet   = FALSE;   // Don't print failed headers and content
BOOL Recurse = FALSE;   // Follow links
BOOL Cache   = FALSE;   // Don't allow caching (i.e., force reload)
BOOL Stats   = FALSE;   // Print stats
BOOL Logs   = FALSE;    // Print log
BOOL LargeBuf= TRUE;   // Use 8k reads rather then 512 byte
BOOL KeepAlive = FALSE;
DWORD AccessType = PRE_CONFIG_INTERNET_ACCESS;
BOOL EnableCallbacks = FALSE;
BOOL UserSuppliedContext = FALSE;

INTERNET_STATUS_CALLBACK PreviousCallback;

DWORD cLevel     = 0;   // Current recurse level
DWORD cMaxLevel  = 10;  // Max Recurse level
DWORD cbReceived = 0;
DWORD cmsecStart = 0;
DWORD cFiles     = 0;
DWORD cIterations= 1;   // Total iterations to perform request

LPSTR GatewayServer = NULL;

INTERNET_PORT nServerPort = 0;

DWORD LogError = ERROR_SUCCESS;

HANDLE AsyncEvent = NULL;
BOOL AsyncMode = FALSE;
DWORD AsyncResult;
DWORD AsyncError;
DWORD Context = 0;


pfnInternetOpenA              pInternetOpenA;
pfnInternetSetStatusCallback  pInternetSetStatusCallback;
pfnInternetConnectA           pInternetConnectA;
pfnHttpOpenRequestA           pHttpOpenRequestA;
pfnHttpAddRequestHeadersA     pHttpAddRequestHeadersA;
pfnHttpSendRequestA           pHttpSendRequestA;
pfnHttpQueryInfoA             pHttpQueryInfoA;
pfnInternetCloseHandle        pInternetCloseHandle;
pfnInternetReadFile           pInternetReadFile;


//
//  Private prototypes.
//

void usage(void);

DWORD
DoTest(
    LPSTR Host,
    LPSTR Verb,
    LPSTR Object
    );

BOOL
add_headers(
    HINTERNET hHttpRequest,
    LPSTR lpszHeaders,
    DWORD dwHeadersLength
    );

void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);

VOID
FindLink(
    LPSTR   Host,
    LPSTR   Verb,
    CHAR *  buf,
    DWORD   len,
    CHAR *  pchLink,
    BOOL *  pfCopyingLink,
    CHAR *  pchReferer
    );

DWORD ReadHtml(HINTERNET hInternet, LPVOID buf, DWORD len, LPDWORD pRead);

BOOL
LoadWininet(
    VOID
    );

//
//  Public functions.
//


int
__cdecl
main(
    int   argc,
    char * argv[]
    )
{
    LPSTR host = NULL;
    LPSTR verb = NULL;
    LPSTR object = NULL;

    if ( !LoadWininet() )
    {
        printf(" Unable to load wininet.dll, error %d\n", GetLastError() );
        return GetLastError();
    }

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'c':
                EnableCallbacks = TRUE;
                break;

            case 'C':
                Cache = TRUE;
                break;

            case 'G':
                printf("'G' flag is not supported at this time\n");
                GatewayServer = ++*argv;
                //AccessType = GATEWAY_INTERNET_ACCESS;
                break;

            case 'i':

                if ( isdigit( argv[0][1] ))
                {
                    cIterations = atoi( ++*argv );

                    while ( isdigit( *(*argv)++ ))
                        ;
                }
                break;

            case 'k':
                KeepAlive = TRUE;
                break;

            case 'l':
                LargeBuf = TRUE;
                break;

            case 'L':
                AccessType = LOCAL_INTERNET_ACCESS;
                break;

            case 'p':
                object = ++*argv;
                break;

            case 'P':

                if ( isdigit( argv[0][1] ))
                {
                    nServerPort = (INTERNET_PORT)atoi( ++*argv );

                    while ( isdigit( *(*argv)++ ))
                        ;
                }
                break;

            case 'q':
                Quiet = TRUE;
                break;

            case 'r':
                Recurse = TRUE;

                if ( isdigit( argv[0][1] ))
                {
                    cMaxLevel = atoi( ++*argv );

                    while ( isdigit( *(*argv)++ ))
                        ;
                }
                break;

            case 's':
                Stats = TRUE;
                cmsecStart = GetTickCount();
                break;

            case 'v':
                Verbose = TRUE;
                break;

            case 'x':
                ++*argv;
                if (!**argv) {
                    Context = DEFAULT_CONTEXT;
                } else {
                    Context = (DWORD)strtoul(*argv, NULL, 0);
                    UserSuppliedContext = TRUE;
                }
                break;

            case 'y':
                AsyncMode = TRUE;
                break;

            case 'z':
                Logs = TRUE;
                cmsecStart = GetTickCount();
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (!host) {
            host = *argv;
        } else if (!verb) {
            verb = *argv;
        } else if (!object) {
            object = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (!verb) {
        verb = "GET";
    }

    if (!object) {
        object = "\r\n";
    }

    if (!(host && verb && object)) {
        printf("error: missing command-line argument\n");
        usage();
    }

    if (AsyncMode) {

        //
        // create an auto-reset event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    //  Make stdout "binary" so we can retrieve GIFs, JPEGs, etc.
    //

    _setmode( _fileno( stdout ), _O_BINARY );

    //
    //  Perform some tests.
    //

    while ( cIterations-- )
    {
        DWORD Error;

        Error = DoTest(host, verb, object );

        if( Error != ERROR_SUCCESS ) {
            LogError = Error;
        }
    }

    if ( Stats )
    {
        DWORD csecTotal = (GetTickCount() - cmsecStart) / 1000;
        DWORD cMin      = csecTotal / 60;
        DWORD cSec      = csecTotal % 60;

        fprintf( stderr,
                 "=====================================\n"
                 "Total data bytes received: %ld\n"
                 "Total files retrieved:     %ld\n"
                 "Total time:                %d:%d\n"
                 "=====================================\n",
                 cbReceived,
                 cFiles,
                 cMin,
                 cSec );
    }

    if ( Logs )
    {
        DWORD csecTotal = (GetTickCount() - cmsecStart) ;
        SYSTEMTIME SystemTime;

        GetLocalTime( &SystemTime );

        fprintf( stderr,
                "LOG: [%02u/%02u %02u:%02u:%02u] "
                 "%-10s %-32s %4s %8d %8d\n",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond,
                        GatewayServer,
                        host,
                        object,
                        LogError,
                        csecTotal );
    }


    return 0;

}   // main

void usage() {
    printf("usage: thttp [-c] [-C] [-l] [-L] [-k] [-p<path>] [-q] [-r] [-s] [-v] [-P]\n"
                "        [-x$] [-y] [-z] [-G<servername>] <host> [<verb>] [<object>]\n"
           "\n"
           "where: -c    = Enable call-backs\n"
           "       -C    = Enable caching\n"
           "       -i[n] = Iterate n times\n"
           "       -l    = Large network buffer\n"
           "       -L    = Force local access (i.e., do not use gateway)\n"
           "       -k    = Use Keep-Alive\n"
           "       -p    = path (e.g. if path starts with '/')\n"
           "       -q    = Quiet mode, no failed headers, no content\n"
           "       -r[n] = Recurse into links, n = max recurse level\n"
           "       -s    = Print network statistics\n"
           "       -v    = Verbose mode\n"
           "       -G    = specific gateway server\n"
           "       -P[n] = Use port n; default = 80\n"
           "       -x    = Context value. $ is number string (binary, hex, decimal)\n"
           "       -y    = Async mode\n"
           "       -z    = print log\n"
           "Verb defaults to \"GET\"\n"
           "Object defaults to \"\\r\\n\"\n"
           );
    exit(1);
}

BOOL
LoadWininet(
    VOID
    )
{
    if ( !(hWininet = LoadLibrary( "wininet.dll" )) )
    {
        printf("Failed to load wininet.dll\n" );
        return FALSE;
    }

    if ( !LOAD_ENTRY( hWininet, InternetOpenA ) ||
         !LOAD_ENTRY( hWininet, InternetSetStatusCallback ) ||
         !LOAD_ENTRY( hWininet, InternetConnectA ) ||
         !LOAD_ENTRY( hWininet, HttpOpenRequestA ) ||
         !LOAD_ENTRY( hWininet, HttpAddRequestHeadersA ) ||
         !LOAD_ENTRY( hWininet, HttpSendRequestA ) ||
         !LOAD_ENTRY( hWininet, HttpQueryInfoA ) ||
         !LOAD_ENTRY( hWininet, InternetCloseHandle ) ||
         !LOAD_ENTRY( hWininet, InternetReadFile ) )
    {
        return FALSE;
    }

    return TRUE;
}

DWORD
DoTest(
    LPSTR Host,
    LPSTR Verb,
    LPSTR Object
    )
{
    DWORD Error = ERROR_SUCCESS;
    HINTERNET InternetHandle = NULL;
    HINTERNET InternetConnectHandle = NULL;
    HINTERNET hhttp = NULL;
    DWORD     len;
    int       i;
    CHAR      buf[8192];
    CHAR      bufLink[512];
    BOOL      fCopyingLink = FALSE;

    *bufLink = '\0';

    //
    // open internet.
    //

    if (Verbose) {
        printf("calling InternetOpen()...\n");
    }

    InternetHandle = pInternetOpenA(
                        "THTTP: HTTP API Test Application", // lpszCallerName
                        AccessType,                         // dwAccessType
                        GatewayServer,                      // lpszProxyName
                        INTERNET_INVALID_PORT_NUMBER,       // nProxyPort
                        AsyncMode ? INTERNET_FLAG_ASYNC : 0 // dwFlags (async)
                        );
    if (InternetHandle == NULL) {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    fprintf(stderr, "error: InternetOpen() is async (spanish inquisition mode)\n");
                    printf("waiting for async InternetOpen()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                if (AsyncResult == 0) {
                    fprintf(stderr, "error: async InternetOpen() returns %d\n",
                        AsyncError);
                    goto Cleanup;
                } else {
                    InternetHandle = (HINTERNET)AsyncResult;
                }
            } else {
                fprintf(stderr, "error: async InternetOpen() returns %d\n", Error);
                goto Cleanup;
            }
        } else {
            fprintf( stderr,
                     "InternetOpen() failed, error %d\n",
                        Error = GetLastError() );

            goto Cleanup;
        }
    }

    if (Verbose) {
        printf("InternetOpen() returns %x\n", InternetHandle);
    }

    if (EnableCallbacks) {

        //
        // let's have a status callback
        //
        // Note that call-backs can be set even before we have opened a handle
        // to the internet/gateway
        //

        PreviousCallback = pInternetSetStatusCallback(InternetHandle, my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }


    //
    // Call internet connect to connect to the http server.
    //

    if (Verbose) {
        printf("calling InternetConnect()...\n");
    }

    InternetConnectHandle = pInternetConnectA(
                                InternetHandle,         // hInternetSession
                                Host,                   // lpszServerName
                                nServerPort,            // nServerPort
                                NULL,                   // lpszUserName
                                NULL,                   // lpszPassword
                                INTERNET_SERVICE_HTTP,  // dwService
                                0,                      // dwFlags
                                UserSuppliedContext ? Context : CONNECT_CONTEXT
                                );


    if( InternetConnectHandle == NULL )
    {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    fprintf(stderr, "error: InternetConnect() is async (spanish inquisition mode)\n");
                    printf("waiting for async InternetConnect()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                if (AsyncResult == 0) {
                    fprintf(stderr, "error: async InternetConnect() returns %d\n",
                        AsyncError);
                    goto Cleanup;
                } else {
                    InternetConnectHandle = (HINTERNET)AsyncResult;
                }
            } else {
                fprintf(stderr, "error: async InternetConnect() returns %d\n", Error);
                goto Cleanup;
            }
        } else {
            fprintf( stderr,
                     "InternetConnect() failed, error %d\n",
                        Error = GetLastError() );

            goto Cleanup;
        }
    }

    if (Verbose) {
        printf("InternetConnect() returns %x\n", InternetConnectHandle);
    }

    //
    //  Open a request handle.
    //

    if (Verbose) {
        printf("calling HttpOpenRequest()...\n");
    }

    hhttp = pHttpOpenRequestA(
                InternetConnectHandle,      // hHttpSession
                Verb,                       // lpszVerb
                Object,                     // lpszObjectName
                NULL,                       // lpszVersion
                NULL,                       // lpszReferer
                AcceptTypes,                // lplpszAcceptTypes
                (Cache ? 0 :
                         INTERNET_FLAG_RELOAD),
                UserSuppliedContext ? Context : REQUEST_CONTEXT
                );

    if( hhttp == NULL )
    {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    fprintf(stderr, "error: HttpOpenRequest() is async (spanish inquisition mode)\n");
                    printf("waiting for async HttpOpenRequest()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                if (AsyncResult == 0) {
                    fprintf(stderr, "error: async HttpOpenRequest() returns %d\n",
                        AsyncError);
                    goto Cleanup;
                } else {
                    hhttp = (HINTERNET)AsyncResult;
                }
            } else {
                fprintf(stderr, "error: async HttpOpenRequest() returns %d\n", Error);
                goto Cleanup;
            }
        } else {
            fprintf( stderr,
                     "HttpOpenRequest() failed, error %d\n",
                        Error = GetLastError() );

            goto Cleanup;
        }
    }

    if (Verbose) {
        printf("HttpOpenRequest() returns %x\n", hhttp);
    }

    //
    // add keep-alive header if requested
    //

    if (KeepAlive) {
        if (!add_headers(hhttp, "Connection: Keep-Alive\r\n", (DWORD)-1)) {
            fprintf(stderr, "HttpAddRequestHeaders() returns %d\n", GetLastError());
        }
    }

    //
    //  Add additional request headers.
    //

    if( !add_headers(
            hhttp,
            "Pragma: bite-me\r\n",
            (DWORD)-1L ) )
    {
        fprintf( stderr,
                 "HttpAddRequestHeaders() failed, error %d\n",
                 GetLastError() );
    }

    if( !add_headers(
            hhttp,
            "Pragma: bite-me-again\r\n",
            (DWORD)-1L ) )
    {
        fprintf( stderr,
                 "HttpAddRequestHeaders() failed, error %d\n",
                 GetLastError() );
    }

    if( !add_headers(
            hhttp,
            "Pragma: bite-me-a-third-time\r\n",
            (DWORD)-1L ) )
    {
        fprintf( stderr,
                 "HttpAddRequestHeaders() failed, error %d\n",
                 GetLastError() );
    }

    //
    //  Send the request.
    //

    if (Verbose) {
        printf("calling HttpSendRequest()...\n");
    }

    if( !pHttpSendRequestA(
            hhttp,          // hHttpRequest
            MoreHeaders,    // lpszHeaders
            (DWORD)-1L,     // dwHeadersLength
            NULL,           // lpOptional
            0 ) )           // dwOptionalLength
    {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("HttpSendRequest() waiting for async completion\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                Error = AsyncError;
                if (!AsyncResult) {
                    printf("error: ASYNC HttpSendRequest() returns FALSE\n");
                    if (Error == ERROR_SUCCESS) {
                        printf("error: ASYNC HttpSendRequest() (FALSE) returns ERROR_SUCCESS!\n");
                    } else {
                        printf("ASYNC HttpSendRequest() returns %d\n", Error);
                    }
                } else if (Verbose) {
                    printf("ASYNC HttpSendRequest() success\n");
                }
            } else {
                printf("error: ASYNC HttpSendRequest() returns %d\n", Error);
            }
        } else {
            fprintf( stderr,
                     "HttpSendRequest() failed, error %d\n",
                        Error = GetLastError() );
        }
    } else if (AsyncMode) {

        //
        // we expect async HttpSendRequest() to always return FALSE w/ error
        // or ERROR_IO_PENDING
        //

        printf("ASYNC HttpSendRequest() returns TRUE\n");
    // } else {

        //
        // Error is still ERROR_SUCCESS from initialization
        //

    }

    if (Error == ERROR_SUCCESS) {

        //
        //  Process the queries.
        //

        if ( Quiet )
        {
            len = sizeof(buf);

            //
            //  Only look for failures to retrieve if we're in quiet mode
            //

            if ( !pHttpQueryInfoA(
                    hhttp,
                    HTTP_QUERY_STATUS_CODE,
                    buf,
                    &len,
                    NULL ))
            {
                fprintf( stderr,
                         "HttpQueryInfo( HTTP_QUERY_STATUS_CODE ) failed, error %d\n",
                         GetLastError() );
            }

            if ( *buf != '2' )
            {
                Error = atoi(buf);
                goto PrintAllHeaders;
            }

            cFiles++;
        }
        else
        {
PrintAllHeaders:

            if( !Logs ) {
                for( i = 0 ; i < NUM_LEVELS ; i++ )
                {
                    len = sizeof(buf);

                    if( !pHttpQueryInfoA(
                            hhttp,
                            QueryLevels[i].QueryType,
                            buf,
                            &len,
                            NULL ) )
                    {
                        if ( QueryLevels[i].QueryType == HTTP_QUERY_STATUS_CODE &&
                             *buf == '2' )
                        {
                            cFiles++;
                        }

                        if ( !Quiet && GetLastError() != ERROR_HTTP_HEADER_NOT_FOUND )
                        {
                            fprintf( stderr,
                                     "HttpQueryInfo( %s ) failed, error %d\n",
                                     QueryLevels[i].QueryName,
                                     GetLastError() );
                        }
                    }
                    else
                    {
                        fprintf( stderr,
                                 "%s = %s\n",
                                 QueryLevels[i].QueryName,
                                 buf );
                    }
                }
            }
        }

        //
        //  Read the data.
        //

        for( ; ; )
        {
            len = LargeBuf ? sizeof(buf) : 512;

            Error = ReadHtml(hhttp, buf, len, &len);
            if (Error != ERROR_SUCCESS) {
                fprintf( stderr,
                         "InternetReadFile() failed, error %d\n",
                            Error = GetLastError() );

                break;
            }

            cbReceived += len;

            if( len == 0 )
            {
                if ( !Quiet )
                {
                    fprintf( stderr,
                             "EOF\n" );
                }

                break;
            }

            if ( !Quiet )
            {
                fwrite( buf, 1, (size_t)len, stdout );
            }

            if ( Recurse && cLevel < cMaxLevel )
            {
                CHAR ContentType[50];
                DWORD cbContentType = sizeof( ContentType );

                //
                //  Only look for links if the content type is text/html
                //

                if( pHttpQueryInfoA(
                        hhttp,
                        HTTP_QUERY_CONTENT_TYPE,
                        ContentType,
                        &cbContentType,
                        NULL ) &&
                    !_stricmp( ContentType,
                              "text/html" ))
                {
                    FindLink( Host,
                              Verb,
                              buf,
                              len,
                              bufLink,
                              &fCopyingLink,
                              Object );
                }
            }
        }

        //
        //  Perform an extraneous read.
        //

        len = sizeof(buf);

        Error = ReadHtml(hhttp, buf, len, &len);
        if (Error != ERROR_SUCCESS) {
            fprintf( stderr,
                     "InternetReadFile() failed, error %d\n",
                      Error = GetLastError() );
        }
        else
        if( len != 0 )
        {
            fprintf( stderr,
                     "BOGUS EXTRANEOUS READ: %d\n",
                     len );
        }
    }

Cleanup:

    //
    //  Close handles.
    //

    if( hhttp != NULL )
    {
        if( !pInternetCloseHandle( hhttp ) )
        {
            fprintf( stderr,
                     "InternetCloseHandle() failed, error %d\n",
                     GetLastError() );
        }
    }

    if( InternetConnectHandle != NULL )
    {
        if( !pInternetCloseHandle( InternetConnectHandle ) )
        {
            fprintf( stderr,
                     "InternetCloseHandle() failed, error %d\n",
                     GetLastError() );
        }
    }

    if( InternetHandle != NULL )
    {
        if( !pInternetCloseHandle( InternetHandle ) )
        {
            fprintf( stderr,
                     "InternetCloseHandle() failed, error %d\n",
                     GetLastError() );
        }
    }

    cLevel--;
    return( Error );
}   // DoTest

BOOL
add_headers(
    HINTERNET hHttpRequest,
    LPSTR lpszHeaders,
    DWORD dwHeadersLength
    )
{
    BOOL ok;

    ok = pHttpAddRequestHeadersA(hHttpRequest, lpszHeaders, dwHeadersLength, 0);
    if (AsyncMode) {
        if (!ok) {

            DWORD err;

            err = GetLastError();
            if (err == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("warning: HttpAddRequestHeaders() is async - unexpected\n");
                    printf("waiting for async HttpAddRequestHeaders()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                ok = (BOOL)AsyncResult;
                if (!ok) {
                    printf("error: async HttpAddRequestHeaders() returns %d\n",
                        AsyncError);
                }
            } else {
                printf("error: async HttpAddRequestHeaders() returns %d\n", err);
            }
        }
    }
    return ok;
}

VOID
my_callback(
    HINTERNET hInternet,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;
    BOOL unknown = FALSE;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        if (AsyncMode) {
            AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
            AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
            SetEvent(AsyncEvent);
        } else {
            printf("error: REQUEST_COMPLETE not expected - not async\n");
        }
        break;

    default:
        type$ = "???";
        unknown = TRUE;
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                hInternet,
                Context,
                UserSuppliedContext             ? "User"
                : (Context == DEFAULT_CONTEXT)  ? "Default"
                : (Context == OPEN_CONTEXT)     ? "Open"
                : (Context == CONNECT_CONTEXT)  ? "Connect"
                : (Context == REQUEST_CONTEXT)  ? "Request"
                : "???",
                type$
                );
        if (Info && !unknown) {
            if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
                if (Verbose) {
                    printf("dwResult = %x, dwError = %d\n",
                            ((LPINTERNET_ASYNC_RESULT)Info)->dwResult,
                            ((LPINTERNET_ASYNC_RESULT)Info)->dwError
                            );
                }
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }
}

VOID
FindLink(
    LPSTR   Host,
    LPSTR   Verb,
    CHAR *  buf,
    DWORD   len,
    CHAR *  pchLink,
    BOOL *  pfCopyingLink,
    CHAR *  pchReferer
    )
{
    DWORD Error;
    CHAR * pchEnd = buf + len;
    CHAR * pch = buf;
    DWORD  cchLink = strlen( pchLink );

    while ( TRUE )
    {
        if ( *pfCopyingLink )
        {
FindEOT:
            //
            //  Look for end of href
            //

            while ( pch < pchEnd )
            {
                if ( *pch == '"' )
                    goto FoundEOT;

                pchLink[cchLink++] = *pch;

                pch++;
            }

            //
            //  Used up all of the buffer and we didn't find the end of the tag,
            //  get some more data
            //

            pchLink[cchLink] = '\0';

            return;

FoundEOT:
            pchLink[cchLink] = '\0';
            *pfCopyingLink = FALSE;

            //
            //  We only traverse URLs of the form '/dir/bar/doc.htm'
            //

            if ( pchLink[0] != '/' )
            {
                CHAR * pchLastSlash;
                CHAR   achTemp[512];

                //
                //  If it's relative, use the referer to make it absolute
                //
                //  Note we don't process /dir/bar/doc.htm#GoHere tags
                //

                if ( (pchLastSlash = strrchr( pchReferer, '/' )) &&
                     strncmp( pchLink, "ftp:", 4 )               &&
                     strncmp( pchLink, "http:", 5 )              &&
                     strncmp( pchLink, "gopher:", 7 )            &&
                     strncmp( pchLink, "mailto:", 7 )            &&
                     !strchr( pchLink, '#' ))
                {
                    *(pchLastSlash + 1) = '\0';
                    strcpy( achTemp, pchReferer );
                    strcat( achTemp, pchLink );
                    strcpy( pchLink, achTemp );
                }
                else
                {
                    fprintf( stderr,
                             "Ignoring %s\n",
                             pchLink );
                    return;
                }
            }

            fprintf( stderr,
                     "Traversing %s\n",
                     pchLink );

            cLevel++;

            Error = DoTest(
                            Host,
                            Verb,
                            pchLink );

            if( Error != ERROR_SUCCESS ) {
                LogError = Error;
            }

        }
        else
        {
            *pchLink = '\0';

            //
            //  Scan for the beginning of an href tag
            //

            while ( pch < pchEnd )
            {
                if ( *pch == '<' )
                {
                    //
                    //  Look for "<A HREF="", note we aren't flexible about spacing
                    //

                    if ( !_strnicmp( pch, "<A HREF=\"", 9 ) ||
                         !_strnicmp( pch, "<IMG SRC=\"", 10 ))
                    {
                        pch += (toupper(pch[1]) == 'A' ? 9 : 10);
                        *pfCopyingLink = TRUE;
                        cchLink = 0;
                        goto FindEOT;
                    }
                }

                pch++;
            }

            //
            //  No tag found, return
            //

            return;
        }
    }
}

DWORD ReadHtml(HINTERNET hInternet, LPVOID buf, DWORD len, LPDWORD pRead) {

    DWORD error = ERROR_SUCCESS;

    if (!pInternetReadFile(hInternet, buf, len, pRead)) {
        if (AsyncMode) {
            error = GetLastError();
            if (error == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("ASYNC InternetReadFile() waiting for async completion\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                error = AsyncError;
                if (!AsyncResult) {
                    printf("error: ASYNC InternetReadFile() returns FALSE\n");
                    if (error == ERROR_SUCCESS) {
                        printf("error: ASYNC InternetReadFile() (FALSE) returns ERROR_SUCCESS!\n");
                    } else {
                        printf("ASYNC InternetReadFile() returns %d\n", error);
                    }
                } else if (Verbose) {
                    printf("ASYNC InternetReadFile() success\n");

                    //
                    // error should be ERROR_SUCCESS from callback
                    //

                    if (error != ERROR_SUCCESS) {
                        printf("error: async error = %d. Expected ERROR_SUCCESS\n", error);
                    }
                }
            } else {
                printf("error: ASYNC InternetReadFile() returns %d\n", error);
            }
        } else {
            error = GetLastError();
            printf("error: SYNC InternetReadFile() returns %d\n", error);
        }
    } else if (AsyncMode) {

        //
        // we expect async InternetReadFile() to always return FALSE w/ error
        // or ERROR_IO_PENDING
        //

        if (Verbose) {
            printf("ASYNC InternetReadFile() returns TRUE\n");
        }
    } else {

        //
        // error is still ERROR_SUCCESS from initialization
        //

        if (Verbose) {
            printf("SYNC InternetReadFile() returns TRUE\n");
        }
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\chs2\src\charfreq.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  CharFreq
Purpose:    To manage the CharFreq resource(CharFreq is one of the linguistic resources)
            The CharFreq is stored as the struct CCharFreq followed the frequecy table  
Notes:      
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    4/23/97
============================================================================*/
#include "myafx.h"

#include "charfreq.h"

// CJK unified idographs block in Unicode
#define  CJK_UFIRST 0x4e00  
#define  CJK_ULAST  0x9fff

// Constructor
CCharFreq::CCharFreq()
{
    m_idxFirst = 0;
    m_idxLast = 0;
    m_rgFreq = NULL;
}

// Destructor
CCharFreq::~CCharFreq()
{
}

// Init the Freq table from a file pointer to the table memory
BOOL CCharFreq::fOpen(BYTE* pbFreqMap)
{
    assert(pbFreqMap);
    assert(!m_rgFreq);

    CCharFreq* pFreq;

    pFreq = (CCharFreq*)pbFreqMap;
    if (pFreq->m_idxFirst >= pFreq->m_idxLast) {
        return FALSE;
    }

    m_idxFirst = pFreq->m_idxFirst;
    m_idxLast  = pFreq->m_idxLast;
    m_rgFreq   = (UCHAR*)(pbFreqMap + sizeof(m_idxFirst) + sizeof(m_idxLast)); 
    
    return TRUE;
}

// Close: clear the freq table setting
void CCharFreq::Close(void)
{
    m_idxFirst = 0;
    m_idxLast = 0;
    m_rgFreq = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\utils\terrain\tools\perms\perms.c ===
//
// Modification: 
//			oct.29, 1997 changed by a-zexu to debug bug#113977(incorrect output info).
//			May 10, 1998 changed by a-zexu to debug bug#158667.
//
//


#include "PERMS.H"                                  


PSID SidEveryone = NULL;
PSID SidOwnerGroup = NULL;
PSID SidFromLookupName = NULL;
PSID ASidFromLookupName[10];
PSID *AccountSids = NULL;
DWORD cbSidFromLookupName=0;
SAM_HANDLE SamServerHandle = NULL;
SAM_HANDLE SamDomainHandle = NULL;
ACCESS_MASK grant_mask = 0;                                                                               
BOOL g_noAccess = FALSE;
BOOL owner_flag = FALSE; 
BOOL owner_group = FALSE;
BOOL Local_Machine = TRUE;
ULONG Total_Sids=0;
BOOL inter_logon=FALSE;            /* interactive login flag */
PSECURITY_DESCRIPTOR SidFromGetFileSecurity;    /* address of security descriptor */
	
_cdecl main(int argc, char *argv[])
{
	char
								UserNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],    /* user name buff */
								SystemNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  /* system name buff */
								FileNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  /* system name buff */
								FileSystemNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  /* system name buff */
								RefDFromLookupName[LSA_WIN_STANDARD_BUFFER_SIZE],
								GeneralUseBuffer[LSA_WIN_STANDARD_BUFFER_SIZE],
								LocalSystemName[MAX_COMPUTERNAME_LENGTH + 1],
								FileName[LSA_WIN_STANDARD_BUFFER_SIZE],
								FilePath[LSA_WIN_STANDARD_BUFFER_SIZE];

	DWORD         cchRefDFromLookupName=0,
								SidsizeFromGetFileSecurity=0,
								lpcbsdRequired=0,
								SNameLen = MAX_COMPUTERNAME_LENGTH + 1;

	SID_NAME_USE  UseFromLookupName;                               

	DWORD         cchNameFromLookupSid;                            
	char          NameFromLookupSid[LSA_WIN_STANDARD_BUFFER_SIZE]; 
	char          RefDFromLookupSid[LSA_WIN_STANDARD_BUFFER_SIZE]; 
	DWORD         cchRefDFromLookupSid, 
								WStatus,
								WNetSize = LSA_WIN_STANDARD_BUFFER_SIZE;                            
	SID_NAME_USE  UseFromLookupSid;                                
	PSID usid;                /* user SID pointer */
	LPDWORD sidsize;
	LPSTR        User = NULL,
								System,
								Path,
								File = NULL,
								FileMachine = NULL;
	LPDWORD domain_size;
	PSID_NAME_USE psnu;
	LPTSTR pbslash;                  /* address of string for back slash  */
	SECURITY_INFORMATION           /* requested information  */
					 si =(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION
					 |DACL_SECURITY_INFORMATION);
	DWORD cbsd, LastError;            /* size of security descriptor buffer */
 
	BOOL  BoolStatus=TRUE;
	int i, k, j;
	ULONG ui;
	BOOL sys=FALSE, 
					fl=FALSE,
					LocalFlag=FALSE,
					BackUpPriv=TRUE,
					DriveFlag=FALSE,
					RecurseFlag=FALSE,
					RestorePriv=TRUE,
					DirFlag=FALSE;
	ULONG AccountSidsLength;
	HANDLE TokenHandle,
				 FindFileHandle;
	WIN32_FIND_DATA FindFileData;
	
	// Set Back up privs for process
	// Get our process token
	if(!GetTokenHandle(&TokenHandle))
	{
		syserror(GetLastError());
		return(TRUE);
	}

	// Have valid process token handle
	// Now set the backup operator priv

	if(!SetBackOperatorPriv(TokenHandle))
		BackUpPriv = FALSE;

	CloseHandle(TokenHandle);

	 // Initialize some memory say for 100 sids 
	 AccountSidsLength = 100 * sizeof ( PSID );
	 AccountSids = (PSID *) LocalAlloc( LPTR,  AccountSidsLength );
	 
	 // Initialize some memory for a large file security discriptor 
	 SidFromGetFileSecurity = (PSECURITY_DESCRIPTOR) GlobalAlloc( GPTR, (DWORD) LARGEPSID);
	 
	 // Check to see if memory was allocated
	 if(AccountSids == NULL || SidFromGetFileSecurity == NULL ) 
	 {
			syserror(GetLastError());
			return(TRUE);
	 }
	
	UserNameBuff[0] = (char) NULL;
	SystemNameBuff[0] = (char) NULL;
	FilePath[0] = (char) NULL;
	FileNameBuff[0] = (char) NULL;
	FileSystemNameBuff[0] = (char) NULL;
	GeneralUseBuffer[0] = (char) NULL;
	
	/* Check for valid command line argument syntax before processing */
	/* check for some count greater than zero and less than max argc count */
	if(argc > 1 && argc <= MAXARGS)
	{
		/* Need to make the following assumptions: That the first command line arg
			 can be a help request or other switch "/? -? /i -i" or an account name. 
			 and not a switch option, could be additional switches or a path name.
			 Also, switches can be intermixed the account name and path. Path is
			 not required local directory is assumed. First parse switches, 
			 account and path.
		*/
		

		/* Loop through  command line args */
		for(i=1; i<argc; i++)
		{
			/* check length of args, 2 may indicate a switch */
			switch(strlen(argv[i]))
			{
				case 1:
					if(sys == FALSE)    // if file flagg true have an invalid case
					{
						strcpy(UserNameBuff, argv[i]);
						// System is local
						System = NULL;
						sys = TRUE;
					}
					else 
					{   
						// copy the argument into the file name buffer
						strcpy(FileNameBuff,argv[i]);
						// Make the Machine name NULL for local machine
						FileMachine = NULL;
						LocalFlag = TRUE;
						fl = TRUE;
					}
				break;

				case 2:     /* Valid size for switch */
					/* check for switch flag */
					if( argv[i][0] == '/' || argv[i][0] == '-')
					{
						switch((int)argv[i][1])
						{ // Help Switch
							case (int) '?':
								usage(HELP, NULL);
								return(TRUE);

							// Interactive Logon Switchs
							case (int) 'i':
								inter_logon = TRUE;
								continue;

							case (int) 'I':
								inter_logon = TRUE;
								continue;

							// Recurse Subdirectories
							case (int) 's':
								 RecurseFlag = TRUE;
								continue;

							case (int) 'S':
								 RecurseFlag = TRUE;
								continue;


							default:
								usage(INVALID_SWT, argv[i]);
								usage(USAGE_ARG, NULL);
								return(TRUE);
						}
					}
					else      /* if not swiches then must be a  or 2 char path name */
					{  
						if(sys == FALSE)    // if file flag true have an invalid case
						{
							strcpy(UserNameBuff, argv[i]);
							// System is local
							System = NULL;
							sys = TRUE;
						}
						else 
						{   
							// copy the argument into the file name buffer
							strcpy(FileNameBuff,argv[i]);
							// Check for "_:" drive type
							pbslash = strchr(argv[i], 0x3a);
							if(pbslash != NULL)
							{
								strcat(FileNameBuff, "\\");
								// Set File pointer
								File = (LPTSTR) &FileNameBuff[0];
							}

							fl = TRUE;
						}
					}
					break;
				
				default:    /* look for account or path */
					// Also we know that a sys/user machine\user is the first string
						if(sys == FALSE)
						{  
						// need to to find the "\" in the 
							pbslash = strchr(argv[i], 0x5c);
							// check pointer location if a NULL no "\" or at first postion in string
							// if no slash have a account name only
							if(pbslash == NULL)
							{
								strcpy(UserNameBuff, argv[i]);
								// Set System to NULL
								System = NULL;
								sys = TRUE;
								break;
							}
							if( pbslash == argv[i])
							{
								usage(INVALID_ARG, argv[i]);
								usage(USAGE_ARG, NULL);
								return(TRUE);
							}
							// copy the string from the "\" tho the user buffer
							strcpy(UserNameBuff, ++pbslash);
							// copy the string up to the "\" in to the system buffer
							// now terminate the string at "\" to a NULL
							--pbslash;
							*pbslash = '\0';

							// Check to see if we have a domain name
							if(!IsDomainName(argv[i], (LPSTR) SystemNameBuff))
							{
								// add the "\\" to the begining of string
								strcpy(SystemNameBuff, "\\\\");
								strcat(SystemNameBuff, argv[i]);
								System = (LPTSTR) &SystemNameBuff[0];
							}
							else
							{
								System = (LPTSTR) &SystemNameBuff[0];
							//  printf("\n :%s is :%s \n", argv[i], System);
							}
							sys = TRUE;
						}
						else // File argument
						{   
							// Get the local machine name
							// machine is in UNC form.
							// add the "\\" to the begining of string
							strcpy(LocalSystemName, "\\\\");
							if(!GetComputerName(&LocalSystemName[2],
															 &SNameLen))
							{
								syserror(GetLastError());
								return(TRUE);
							}

							// Check for "\\" in first 2 chars in file path for UNC path
							if( strncmp(argv[i], "\\\\", 2) == 0)
							{
								// copy "\\ to the next \" to the file machine name
								for(j=0; j < (int) strlen(argv[i]); j++)
								{
									if(j<2)
										FileSystemNameBuff[j] = argv[i][j];
									else
									{
										// check for 3rd "\"
										if(argv[i][j] == 0x5c)
											break;
										FileSystemNameBuff[j] = argv[i][j];
									}
								}
								// add null to string
								FileSystemNameBuff[j] = '\0';
								// now need to check for the local machine name
								// The get file security call will fail if local
								// Compare the local machine name to the file machine
								if(_stricmp(LocalSystemName, FileSystemNameBuff) == 0)
								{
									// Have a local Machine UNC path
									// Check account machine name
									if(_stricmp(LocalSystemName, System) == 0)
									{
										// Have a local Machine equal to account machine
										// no need to look up sids for file machine.
										LocalFlag = TRUE;
									}
									
									// Make the Machine name NULL for local machine
									FileMachine = NULL;
									// Need to strip off UNC name of local machine
									// The j counter is at "\" character

									strcpy(FileNameBuff, &argv[i][j]);
								}
								else  // Have a nonlocal path
								{
									// Need to check system name against account machine
									if(System != NULL)
										if(_stricmp(FileSystemNameBuff, System) == 0)
										{
											// Have a file Machine equal to account machine
											// no need to look up sids for file machine.
											LocalFlag = TRUE;
										}
									strcpy(FileNameBuff,argv[i]);
									FileMachine = (LPTSTR) &FileSystemNameBuff[0];

								}
								// printf("\n file machine: %s", FileMachine);

							}
							else  // have a local file  (assume local) or logical
							{
								// Need to get the logical or drive ie "_:" 
								pbslash = strchr(argv[i], 0x3a);
							// check pointer location if a NULL assume a "\xx\xx" type path
							if(pbslash == NULL)
							{
								strcpy(FileNameBuff,argv[i]);
								// set the filemachine name to a null to force local 
								FileMachine = NULL;
							}
							else
							{
								// Have a logical drive or a machine drive
								// Need the drive part 
								k = (int) strlen(argv[i]);
								for(j=0; j < k; j++)
								{
										GeneralUseBuffer[j] = argv[i][j];
										// check for  ":"
										if(argv[i][j] == 0x3a)
											break;
								}
								// add null to string
								GeneralUseBuffer[++j] = '\0';
								// WNetGetConnection
								WStatus = WNetGetConnection((LPTSTR) GeneralUseBuffer,    // Drive name
															(LPTSTR) FileSystemNameBuff,   // Returned Name
															&WNetSize);
	// Check return status
								if(WStatus == NO_ERROR) 
								{
									// Have a valid redirected drive
									// Build the full path name 
									strcat(FileNameBuff, argv[i]);
									// Next get the machine name of the share
									// copy "\\ to the next \" to the file machine name
									for(j=0; j < (int) strlen(FileSystemNameBuff); j++)
									{
										if(j>2)
										{
											// check for 3rd "\"
											if(FileSystemNameBuff[j] == 0x5c)
												break;
										}
									}
									// Add NULL
									FileSystemNameBuff[j] = '\0';
									FileMachine = (LPTSTR) &FileSystemNameBuff[0];
								}
								else
								{
									// Have a local machine drive 
									strcpy(FileNameBuff,argv[i]);
									// Check for drive only path "_:\" or "_:"
									// FindFirstFile has with it.
									// Need to convert "_:" to "_:\"
									if(k <= 3)
										DriveFlag = TRUE;

									// Check for a System = NULL
									if(System != NULL)
									{
										// Check User Account system against local name
										if(_stricmp(LocalSystemName, System) == 0)
										{
											// Have a local user account machine
											LocalFlag = TRUE;
										}
									}
									else // System is Local machine 
											LocalFlag = TRUE;

									// set the filemachine name to a null to force local 
									FileMachine = NULL;

								}
							}
						}  
							fl = TRUE;
							// Set File pointer
							File = (LPTSTR) &FileNameBuff[0];
		
						}
					
					break;

			}   /* end switch */
		}   /* end for argv loop */

		User = (LPTSTR) &UserNameBuff[0];
		// Make sure GeneralUseBuffer is null
		GeneralUseBuffer[0] = (CHAR) NULL;
		// Check to see if file was entered
		if(fl == FALSE)
		{
			usage(INVALID_FIL, (CHAR) NULL);
			return(FALSE);
		}
		

		// Clean up the file name ie "." ".." ".\" etc
		if(!CleanUpSource((LPTSTR) FileNameBuff, (LPTSTR) FileName, &DirFlag))
		{
			usage(INVALID_FIL, (LPTSTR) FileNameBuff);
			return(FALSE);
		}
		File = &FileName[0];
		Path = &FilePath[0];
		strcpy(Path, File);
		//Find last Slash
		pbslash = strrchr(Path, 0x5c);
		if(pbslash != NULL)
		{ 
			pbslash++;
			*pbslash = (CHAR) NULL;
		}
		

		/*** Get everyone SID by use LookupAccountName ***/	

		/* Have no buffer sizes first call to LookupAccountName will return 
			 need buffer sizes */		
		if( LookupAccountName( NULL, 
				TEXT("everyone"), 
				SidEveryone,
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}		

		/* Now have valid buffer sizes to call LookupAccountName for a valid SID */
		/* allocate memory for the sid */		
		SidEveryone =  LocalAlloc( (UINT) LMEM_FIXED, (UINT) cbSidFromLookupName);
		
		if(SidEveryone == NULL) 
		{                                                    
			syserror(GetLastError());
			return(TRUE);                                                          
		}     
		
		if( !LookupAccountName( NULL,
				TEXT("everyone"), 
				SidEveryone,
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}


		/* Have no buffer sizes first call to LookupAccountName will return 
			 need buffer sizes */		
		if( LookupAccountName( System, 
				User, 
				SidFromLookupName,
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}		

		/* Now have valid buffer sizes to call LookupAccountName for a valid SID */
		/* allocate memory for the sid */
		
		SidFromLookupName =  LocalAlloc( (UINT) LMEM_FIXED, (UINT) cbSidFromLookupName);
		
		if(SidFromLookupName == NULL) 
		{                                                    
			syserror(GetLastError());
			return(TRUE);                                                          
		}                                                                           
		
		
		if( !LookupAccountName( System,
				User, 
				SidFromLookupName, 
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}
		
		ASidFromLookupName[0] = SidFromLookupName;
		if(!VariableInitialization())
		{
			syserror(GetLastError());
			return(TRUE);
		}
		
		// look up the user's group sids for the machine the accounts on
		BoolStatus = LookupAllUserSidsWS(System);
		
		// look up the user's group sid for the workstation that the file resides on
		// Need to check if the account machine and file machine are the same.
		// If not done duplicate sids will be build.
		
		if( LocalFlag == FALSE)
		{
			if( !LookupAllUserSidsWS(FileMachine))
			{
				// system error message
				syserror(GetLastError());
				return(TRUE);
			}
		}
		// Not a directory 
		if(!DirFlag)
		{
		 // Need to get the findfirstfile
		 FindFileHandle = FindFirstFile(File, &FindFileData);
		 if(FindFileHandle == INVALID_HANDLE_VALUE)
		 {
				usage(INVALID_FIL, (LPTSTR) FileNameBuff);
				return(FALSE);
		 }

//		 FindClose(FindFileHandle);		

		 if(Path != NULL)
		 {
				strcpy(File, Path);
				// This sould give a valid path
				strcat(File,FindFileData.cFileName);
			}
			else    
				strcpy(File,FindFileData.cFileName);
		}
		else // need to fake out the Finfirstfile data structure
			FindFileData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;

		// Now have all of the user sid and the first file.
		// Loop through the files
		while(1)
		{
			if(strcmp(FindFileData.cFileName, ".") != 0) 
				if(strcmp(FindFileData.cFileName, "..") != 0)
			{

				/* The call to GetFileSecurity works similar to LookupAccountName 
					 in that the first call get need buffer sizes */
		 

				// Use a fairly larger buffer size of returned size value.
				// This will keep the number of malloc type calls down.
				SidsizeFromGetFileSecurity = LARGEPSID;
				BoolStatus = GetFileSecurityBackup(File, 
						si, 
						SidFromGetFileSecurity, 
						SidsizeFromGetFileSecurity,  /* buffer size */
						&lpcbsdRequired,    /* required buffer size */
						BackUpPriv);
				if(!BoolStatus)
				{
					// GetFileSecurity failed need to check if buffer was to small
					if(lpcbsdRequired != 0)
					{
						SidsizeFromGetFileSecurity = lpcbsdRequired;
						// Reallocate the memory to the new size
						SidFromGetFileSecurity =  GlobalReAlloc( SidFromGetFileSecurity, lpcbsdRequired, GMEM_ZEROINIT);  
						BoolStatus = GetFileSecurityBackup(File, 
								si, 
								SidFromGetFileSecurity, 
								SidsizeFromGetFileSecurity,    
								&lpcbsdRequired,     
								BackUpPriv);
						if(!BoolStatus)
						{ 
							syserror(GetLastError());
							return(TRUE);
						}
					}
					else // Have a problem with file
					{
						usage(INVALID_FIL, (LPTSTR) File);
						return(FALSE);
					}
				}
				// Clear access masks
				grant_mask = 0;
				if(!GetFilePermissions(SidFromGetFileSecurity, (PSID) SidFromLookupName))
				{
					syserror(GetLastError());
					return(TRUE);
				}
				// Need to chech for directory structure
				if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					// Display the directory perms
					if(!IsLastCharSlash(File))
					 strcat(File, "\\");
					DisplayPerms(File, TRUE);
					// Check Recurse subdirectories flagg
					// This is ugly but time is short
					if(!DirFlag)
						if(RecurseFlag == TRUE)
						{
							// Need the Filename, Path, user account sid, and Backup priv flag
							RecurseSubs(FindFileData.cFileName, Path, SidFromLookupName, BackUpPriv,
							RecurseFlag);
						}
				}
				else  // For initial files that are directories
					if(!DirFlag)
						DisplayPerms(File, TRUE);
			} // End if "." .""
			// Go for the next file 
			// for recursing subdirectories.
			if(DirFlag)
			{
				// Check recurse flag
				if(RecurseFlag)
				{
					// Need to update the path
					strcpy(Path, File);
					// Add the wild card
					strcat(File, "*");

					FindClose(FindFileHandle);
					// Need to get the findfirstfile
					FindFileHandle = FindFirstFile(File, &FindFileData);
					if(FindFileHandle == INVALID_HANDLE_VALUE)
					{
						syserror(GetLastError());
						return(TRUE);
					}
					// Add path to file
					strcpy(File, Path);
					// This sould give a valid path
					strcat(File,FindFileData.cFileName);
					DirFlag = FALSE;
					continue;
				}
				// Have only a single directory
				// if(!IsLastCharSlash(File))
				//  strcat(File, "\\");
				// DisplayPerms(File, TRUE);
				break;
			}
				
			if(FindNextFile(FindFileHandle, &FindFileData))
			{
				if(Path != NULL)
				{
					strcpy(File, Path);
					// This sould give a valid path
					strcat(File,FindFileData.cFileName);
				}
				else    
					strcpy(File,FindFileData.cFileName);

			}
			else    // Have end of files
				break